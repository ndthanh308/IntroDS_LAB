\section{Optimal Trajectory with the Connectivity and Battery Constraints}\label{sec4}
In this section, we target to solve Problem 1, i.e.,  optimize the UAV trajectory to minimize the mission time under the connectivity and the battery constraints. Note that it can be beneficial to change the UAV speed $v$ under the battery constraint since the maximum travel distance without replacing the battery depends on $v$ as shown in \eqref{eq:3}. For notational simplicity, we assume $H_\mathrm{CS}=H$, but the analysis can be easily extended for general case as mentioned in Remark~\ref{rmk3}. %\hs{For convenience, we assume that $H_\mathrm{CS}=H$.} %We note that Problem 1 is more challenging than Problem 1-1 since the problem considers not only maintaining the connection with a BS but also keeping the battery from running out by visiting some CSs. 

For Problem 1, we propose a generalized intersection method with battery constraint (GIM-B) by modifying our generalized intersection method in Section \ref{sec3}, and show that this GIM-B algorithm outputs an optimal solution for Problem~1 NP-easily. The pseudo code for this GIM-B algorithm is provided in Algorithm \ref{Algo4}. 
%%%%%%%%%%%%%%%%% Algorithm 4: GIM-B %%%%%%%%%%%%%%%
\begin{algorithm}
\caption{Generalized Intersection Method with Battery Constraint (GIM-B)} \label{Algo4}
\textbf{Input:} $\mathbf{u}_0$, $\mathbf{u}_F$, $\mathbf{a}_m$, $d_0$, $\lambda_m$, $\mathcal{V}$, $\mathbf{c}_n$, $\tau_{C_n}$, $w$, $w_2$ for $m\in\mathcal{M}$, $n\in\mathcal{N}$
\begin{algorithmic}[1]
\State \textbf{Def:} Function \textbf{BFS}$(\mathbf{x}_1,\mathbf{x}_2,G)$ for graph $G=(V,E)$ outputs 1 if  $\mathbf{x}_1\in V$ and $\mathbf{x}_2\in V$ are connected in the graph $G$ and otherwise outputs 0.
\State $V_\mathrm{GL}\leftarrow\{\mathbf{u}_0,\mathbf{u}_F,\mathbf{c}_1,...,\mathbf{c}_N\}$, $V_\mathrm{LO},E_\mathrm{LO},E_\mathrm{GL}\leftarrow \emptyset$
\State $V_\mathrm{in},E_\mathrm{in},E_1,...,E_{N+2} \leftarrow \emptyset$
\LeftComment{Consider the initial and the final points as CSs.}
\State $\mathbf{c}_{N+1} \leftarrow \mathbf{u}_0$, $\mathbf{c}_{N+2} \leftarrow \mathbf{u}_F$, $\tau_{C_{N+1}},\tau_{C_{N+2}}\leftarrow 0$
\State $V_\mathrm{in}\!\leftarrow\! \text{All intersection points}$ \hfill\Comment{Lines $6$-$10$ at Algorithm \ref{Algo1}}
%\For{$m,m'\in\mathcal{M}$, $m<m'$} \hfill\Comment{Find intersected points}
%    \If{$\|\mathbf{a}_m-\mathbf{a}_{m'}\|\leq 2d_0-\lambda_m-\lambda_{m'}$}
%        \State $V_\mathrm{in}\leftarrow V_\mathrm{in}\cup\{\mathbf{x}\in\mathbb{R}^2 \vert \ \|\mathbf{x}-\mathbf{a}_m\|=d_0-\lambda_m,$
%        \Statex \qquad\quad $|\mathbf{x}-\mathbf{a}_{m'}\|=d_0-\lambda_{m'}\}$
%    \EndIf
%\EndFor 
\State $V_\mathrm{all}\leftarrow V_\mathrm{GL}\cup V_\mathrm{in}$
\LeftComment{Step 1. Outage test: Check whether each possible line segment experiences an outage.}
\For{$\mathbf{x}_1,\mathbf{x}_2\in V_\mathrm{all}$, $\mathbf{x}_1\neq \mathbf{x}_2$} 
    \State $h_\mathrm{out}\leftarrow$ \textbf{ChkOut}$(\mathbf{x}_1,\mathbf{x}_2,\mathbf{a}_m, d_0, \lambda_m \text{ for } m\in\mathcal{M})$
    \For {$n\in [1:N+2]$}
        \If{$h_\mathrm{out}=0$, $\mathbf{c}_{n}\in \{\mathbf{x}_1,\mathbf{x}_2\}$ }
            \State $E_n\leftarrow E_n\cup (\mathbf{x}_1,\mathbf{x}_2,\|\mathbf{x}_1-\mathbf{x}_2\|)$
        \EndIf
    \EndFor
    \If{$h_\mathrm{out}\!=\!0$, $\mathbf{c}_{n}\!\not\in\!\{\mathbf{x}_1,\mathbf{x}_2\}$ for $n\in[1:N+2]$}
        \State $E_\mathrm{in}\leftarrow E_\mathrm{in}\cup (\mathbf{x}_1,\mathbf{x}_2,\|\mathbf{x}_1-\mathbf{x}_2\|)$
    \EndIf
\EndFor 
\LeftComment{Step 2. Local level search: Derive optimal paths between each pair of CSs.}
\For{$n\in [1:N+1]$, $n'\in[1:N]\cup \{N+2\}$, $n\neq n'$} 
    \LeftComment{Function \textbf{ChkFea} is described in line $1$ at Algorithm \ref{Algo1}.} 
    \State $h_\mathrm{Lfea}\leftarrow$ \textbf{ChkFea}$(\mathbf{c}_n,\mathbf{c}_{n'}, \mathbf{a}_m, d_0, \lambda_m$ for $m\in\mathcal{M})$ 
    \If{$h_\mathrm{Lfea}=1$}
        \State $V_\mathrm{LO}\leftarrow V_\mathrm{in}\cup \{\mathbf{c}_n, \mathbf{c}_{n'}\}$, $E_\mathrm{LO}\leftarrow E_\mathrm{in}\cup E_n\cup E_{n'}$
        \State $G_\mathrm{LO}\leftarrow (V_\mathrm{LO}, E_\mathrm{LO})$
        \LeftComment{Function \textbf{Dijkstra} is described in line $2$ at Algorithm \ref{Algo1}.}
        \State $(\ell_\mathrm{LO},\mathbf{S}_{V_\mathrm{LO}}(c_n, c_{n'}))\leftarrow \textbf{Dijkstra}(\mathbf{c}_n,\mathbf{c}_{n'},G_\mathrm{LO})$
        \State ($h_\mathrm{sp},v(c_n, c_{n'})) \leftarrow$ \textbf{ChkSp}$(\ell_\mathrm{LO},\mathcal{V},w,w_2)$
        \If{$h_\mathrm{sp}=1$}
            %\State \hs{$\mathbf{p}_\mathrm{LO}(\mathbf{c}_n,\mathbf{c}_{n'})\leftarrow$\textbf{FdPath}$(\mathbf{S}_{V_\mathrm{LO}},v_\mathrm{max})$}
            \State $E_\mathrm{GL}\leftarrow E_\mathrm{GL}\cup (\mathbf{c}_n,\mathbf{c}_{n'},\ell_\mathrm{LO}/v(c_n, c_{n'})+\tau_{C_{n'}})$
        \EndIf
    \EndIf
\EndFor  
\LeftComment{Step 3. Global level search: Derive an optimal path from the initial point to the final point over the graph of CSs.}
\State $\overrightarrow{G}_\mathrm{GL}\leftarrow (V_\mathrm{GL}, E_\mathrm{GL})$ \hfill\Comment{$\overrightarrow{G}_\mathrm{GL}$ is a directed graph.}
\State $h_\mathrm{Gfea}\leftarrow$ \textbf{BFS}$(\mathbf{u}_0,\mathbf{u}_F,\overrightarrow{G}_\mathrm{GL})$
\If{$h_\mathrm{Gfea}=1$}
    \State ($T$, $\mathbf{S}_{V_\mathrm{GL}})\leftarrow$ $\textbf{Dijkstra}(\mathbf{u}_0,\mathbf{u}_F,\overrightarrow{G}_\mathrm{GL})$
    \State ($\mathbf{u}(t)$, $\psi(t)$ for $t\in[0,T]$) $\leftarrow$ \textbf{FindPathG}$(\mathbf{S}_{V_\mathrm{GL}},$
    \Statex\qquad $v(c_n, c_{n'})$, $\mathbf{S}_{V_\mathrm{LO}}(c_n, c_{n'})$, $\tau_{C_{n'}}$ for $n\in[1:N+1],$
    \Statex\qquad $n'\in [1:N]\cup \{N+2\}$)
\Else
    \State $h_\mathrm{Gfea}\leftarrow 0$, $T\leftarrow\infty$, $\mathbf{u}(t),\psi(t) \leftarrow \mathrm{Null}$ for $t\in[0,T]$
\EndIf   
\end{algorithmic}
\textbf{Output:} \big($h_\mathrm{Gfea}$, $T$, $\mathbf{u}(t)$, $\psi(t)$ for $t\in[0,T]$\big)
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%
The resultant UAV trajectory from our algorithm consists of line segments between two points, where each point is one of the initial or final point, intersection points of the coverage boundaries, and CSs. The GIM-B algorithm determines the set of line segments (corresponding to edges in the equivalent graphs) that are connected one after another in three steps. First, it checks whether each possible line segment experiences an outage and constitutes the no-outage edge sets (in lines $7$-$17$). Then, the algorithm finds the optimal path in two levels. In the local level (in lines $18$-$29$), it finds the optimal path between each pair of CSs (by treating the initial and the final points also as CSs) by applying Dijkstra algorithm and derives the maximum allowable speed to travel between each pair of CSs by applying the function ChkSP whose pseudo code is in Algorithm \ref{Algo5}.\footnote{We assume that the UAV flies with a fixed speed while traveling through a path at the local level, which is justified later in Theorem \ref{Thm3}.} In this local level, note that it may not be possible to travel between two CSs because there is no path  between them  ($h_\mathrm{Lfea}=0$) or because the distance is too large to travel with the battery capacity ($h_\mathrm{sp}=0$). An example of the graph to derive an optimal path between two CSs at the local level is illustrated in Fig. \ref{Fig7}.
% Figure environment removed
In the global level (in lines $30$-$35$), we consider a directed graph whose vertex set consists of CSs and edge set consists of edges between CSs which has been checked to be reachable in the local level, with the weights of traveling and battery swapping time. For this graph, the algorithm first checks whether it is feasible to travel from the initial to the final points via the function breadth-first search (BFS) \cite{West:2001}, which searches all connected nodes from a start node in a graph with low complexity. If feasible, it constructs the UAV trajectory by applying the Dijkstra algorithm over the graph and then applying the function FindPathG that outputs the trajectory based on the sequence of visiting points in the global and the local levels, the speeds traveling between CSs, and the battery swapping times. An example of the graph to derive an optimal path between from the initial point to the final point at the global level is illustrated in Fig. \ref{Fig8}.
% Figure environment removed

%This method first derives an optimal local-path from the initial point or a CS $\mathbf{l}_0\in\{\mathbf{u}_0,\mathbf{c}_1,...,\mathbf{c}_n\}$ to the final point or another CS $\mathbf{l}_F\in\{\mathbf{u}_F,\mathbf{c}_1,...,\mathbf{c}_n\}$ without replacing the battery by constructing a local graph.} Then, to obtain an optimal trajectory from $\mathbf{u}_0$ to $\mathbf{u}_F$, it constructs a global graph including $\mathbf{u}_0$, $\mathbf{u}_F$, and $c_n$ for $n\in\mathcal{N}$ by using the induced paths in the local-graphs. The detailed pseudo code about our GIM-B is provided in Algorithm \ref{Algo4}. To reduce the time complexity of verifying whether each line segment used in the local-graphs experiences an outage, we test the hypothesis for every line segment at once before constructing the local-graphs (in lines $4$-$16$). We first find all intersection points of the coverage boundaries of the BSs and then check whether each line segment $\overline{\mathbf{x_1}\mathbf{x_2}}$ by two different vertices $\mathbf{x_1},\mathbf{x_2}\in V_\mathrm{all}$ experiences an outage via the function ChkOut described in Section \ref{sec3}, where the set $V_\mathrm{all}$ is given by the intersection points, $\mathbf{u}_0$, $\mathbf{u}_F$, and $\mathbf{c}_n$ for $n\in\mathcal{N}$.\footnote{To efficiently select the needed line segments for each local-graph, we save the line segments lying inside the set of coverage regions in different memories according to the types of its endpoints: $\mathbf{u}_0$, $\mathbf{u}_F$, $\mathbf{c}_n$ for $n\in\mathcal{N}$, or the others.} 

%Next, we find every optimal local-path from $\mathbf{l}_0$ to $\mathbf{l}_F$ without replacing the battery in the process similar to the generalized intersection method (in lines $17$-$28$). The feasibility of each local-path finding problem is checked through the function ChkFea described in Section \ref{sec3}. If the problem is feasible, then we construct an undirected local-graph $G_\mathrm{LO}=(V_\mathrm{LO}, E_\mathrm{LO})$ in a similar way as in Algorithm \ref{Algo1}, but to derive the local-edge set $E_\mathrm{LO}$, we just load the line segments tested whether they experience outages in advance. An example of the local-graph is represented in Fig. \ref{Fig7}.

%\hs{After constructing the local-graph, an optimal local-path from $\mathbf{l}_0$ to $\mathbf{l}_F$ in the local-graph $G_\mathrm{LO}$ is derived. We first derive  an optimal sequence $\mathbf{S}_{V_\mathrm{LO}}(\mathbf{l}_0,\mathbf{l}_F)$ of visiting nodes in $V_\mathrm{LO}$ and the corresponding path length $\ell_\mathrm{LO}$ via the Dijkstra algorithm.} Since the distance that the UAV can travel without replacing its battery is limited as \eqref{eq:3}, we verify whether the UAV can travel $\ell_{LO}$ within the battery capacity $(h_\mathrm{sp}=1)$ or not $(h_\mathrm{sp}=0)$ and then derive \hs{the maximum possible speed $v(\mathbf{l}_0,\mathbf{l}_F)\in\mathcal{V}$ for $\mathbf{S}_{V_\mathrm{LO}}(\mathbf{l}_0,\mathbf{l}_F)$ via the function ChkSp if $h_\mathrm{sp}=1$,} whose pseudo code is given in Algorithm \ref{Algo5} and it will be explained later.\footnote{We assume that the UAV flies with a fixed speed while traveling through a local-path, which is justified later in Theorem \ref{Thm3}.} 
%\hs{The optimal local-path $\mathbf{p}_\mathrm{LO}(\mathbf{l}_0,\mathbf{l}_F)$ is also derived by using the sequence $\mathbf{S}_{V_\mathrm{LO}}$ and the maximum possible speed $v_\mathrm{max}$ at the function FindPath explained in Section \ref{sec3} if $h_\mathrm{sp}=1$.} 

%Finally, we derive an optimal global-trajectory from $\mathbf{u}_0$ to $\mathbf{u}_F$ considering the battery replacement at some CSs by using the induced local-paths (in lines $25$, $29$-$36$). A directed global-graph $\overrightarrow{G}_\mathrm{GL}=(V_\mathrm{GL}, E_\mathrm{GL})$ is constructed based on the induced optimal local-paths. Here, the vertex set $V_\mathrm{GL}=\{\mathbf{u}_0,\mathbf{u}_F,\mathbf{c}_1,...,\mathbf{u}_N\}$ consists of the end points in the local-paths and the edge set $E_\mathrm{GL}$ is given by every tuple \hs{$(\mathbf{l}_0,\mathbf{l}_F,\ell_\mathrm{LO}/v(\mathbf{l}_0,\mathbf{l}_F)+\tau_{\mathbf{l}_F})$} satisfying $h_\mathrm{sp}=1$, \hs{where the weight of each edge $\ell_\mathrm{LO}/v(\mathbf{l}_0,\mathbf{l}_F)+\tau_{\mathbf{l}_F}$ includes the travel time from $\mathbf{l}_0$ to $\mathbf{l}_F$ in the maximum possible speed $v(\mathbf{l}_0,\mathbf{l}_F)$} and the delay $\tau_{\mathbf{l}_F}$ to replace the battery at $\mathbf{l}_F$. We note that the delay for battery swapping at $\mathbf{u}_F$ is $0$. An example of the global-graph $\overrightarrow{G}_\mathrm{GL}$ is illustrated in Fig. \ref{Fig8}.

%After that, we check whether the vertices $\mathbf{u}_0$ and $\mathbf{u}_F$ are connected in the global-graph $\overrightarrow{G}_\mathrm{GL}$ $(h_\mathrm{Gfea}=1)$ or not $(h_\mathrm{Gfea}=0)$ via the BFS algorithm. 
%\hs{If $h_\mathrm{Gfea}=1$, we find an optimal global-trajectory from $\mathbf{u}_0$ to $\mathbf{u}_F$. We search an optimal sequence $\mathbf{S}_{V_\mathrm{GL}}$ of visiting nodes in $V_\mathrm{GL}$ and its delivery time $T$ via the Dijkstra algorithm and then derive the optimal global-trajectory by using the sequence $\mathbf{S}_{V_\mathrm{GL}}$, the sequences $\mathbf{S}_{V_\mathrm{LO}}(\mathbf{l}_0,\mathbf{l}_F)$ and their speeds $v(\mathbf{l}_0,\mathbf{l}_F)$  for all possible local-paths, and the delay $\tau_{C_n}$ $(n\in\mathcal{N})$ to replace the battery for all CSs at the function FindPathG, which substitutes the node-visiting sequence into the global-trajectory in a similar way as in \cite[$(25)$-$(27)$]{Zhang:2019} but consider the local-paths and the delays for battery swapping.}


Algorithm \ref{Algo5} describes the function ChkSp which checks whether the UAV can travel a distance $\ell_\mathrm{LO}\geq 0$ without replacing the battery $(h_\mathrm{sp}=1)$ or not $(h_\mathrm{sp}=0)$ by using the maximum possible traveling distance function $d_\mathrm{fly}(v)$ in \eqref{eq:3} for speed $v\in\mathcal{V}$. If it is possible $(h_\mathrm{sp}=1)$, then it derives the maximum possible speed $v_\mathrm{max}\in\mathcal{V}$ whose maximum traveling distance $d_\mathrm{fly}(v_\mathrm{max})$ is not smaller than $\ell_\mathrm{LO}$. We note that the algorithm assumes that the UAV flies with a fixed speed between two CSs, while the speed can vary depending on the pair of CSs. The following theorem shows a sufficient condition for flying with a fixed speed between two CSs to be optimal.

%%%%%%% Algorithm 5: Checking Speed %%%%%%%%%
\begin{algorithm}[t]
\caption{Function ChkSp} \label{Algo5}
\textbf{Input:} $\ell_\mathrm{LO}$, $\mathcal{V}$, $w$, $w_2$
\begin{algorithmic}[1]
\If{$\{v\in\mathcal{V}|d_\mathrm{fly}(v)\geq \ell_\mathrm{LO}\}\neq \emptyset$}
    \State $h_\mathrm{sp}\leftarrow 1$ \hfill\Comment{Can travel $\ell_\mathrm{LO}$ without battery swapping} 
    
    \LeftComment{Find the maximum possible speed $v_\mathrm{max}$ that can travel the length $\ell_\mathrm{LO}$ without battery swapping.}
    \State $v_\mathrm{max}\leftarrow \max_{v\in\mathcal{V}}\{v|d_\mathrm{fly}(v)\geq \ell_\mathrm{LO}\}$
\Else
    \State $h_\mathrm{sp}\leftarrow 0$, $v_\mathrm{max}=0$
\EndIf
\end{algorithmic}
\textbf{Output:} $(h_\mathrm{sp}$, $v_\mathrm{max})$
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%

\begin{theorem}\label{Thm3} % fixed UAV speed
Assume that the UAV can fly with any speed $v\in[v_1,v_q]$ and the power consumption model $P_\mathrm{UAV}(v)$ is convex for $v\in[v_1,v_q]$. Then, for traveling between two CSs with the connectivity and battery constraints, flying with a fixed speed minimizes the traveling time.
%for any path length  \ell_\mathrm{LO}\geq 0$ between the two CSs.}
\end{theorem}
\begin{proof}
Let us assume that the path distance $\ell_\mathrm{LO}$ to travel between two CSs is partitioned by segments $\ell_1,...,\ell_K$ where $\ell_\mathrm{LO}=\sum_{k=1}^K\ell_k$ and the UAV flies with speed $\tilde{v}_k\in[v_1,v_q]$ for segment $\ell_k$ for $k\in[1:K]$. In this case, we have  the total travel time $T_\mathrm{LO}=\sum_{k=1}^K \ell_k/\tilde{v}_k$ and the total consumed energy $E_\mathrm{LO}=\sum_{k=1}^K (\ell_k/\tilde{v}_k)\cdot P_\mathrm{UAV}(\tilde{v}_k)$. We prove this theorem by showing the UAV can travel $\ell_\mathrm{LO}$ within time $T_\mathrm{LO}$ by a fixed speed $\bar{v}\in[v_1,v_q]$ while consuming energy equal to or less than $E_\mathrm{LO}$. First, the UAV can travel $\ell_\mathrm{LO}$ in time $T_\mathrm{LO}$ if it travels with the fixed speed $\bar{v}={\ell_\mathrm{LO}\over{\sum_{k'=1}^K \ell_{k'}/\tilde{v}_{k'}}}$. Second, $E_\mathrm{LO}$ is lower-bounded as:
\begin{align}
E_\mathrm{LO}&=\sum_{k=1}^K (\ell_k/\tilde{v}_k)\cdot P_\mathrm{UAV}(\tilde{v}_k) \label{eq:30}\\
\overset{(a)}\geq& \Biggl(\sum_{k'=1}^K \ell_{k'}/\tilde{v}_{k'}\!\Biggr)\!\cdot P_\mathrm{UAV}\left(\sum_{k=1}^K{{\ell_k/\tilde{v}_k}\over{\sum_{k'=1}^K \ell_{k'}/\tilde{v}_{k'}}}\cdot \tilde{v}_k\!\!\right) \label{eq:31}\\
=& T_\mathrm{LO} \cdot P_\mathrm{UAV}(\bar{v}), \label{eq:32}
\end{align}
where $(a)$ is by Jensen's inequality. Since the UAV with fixed speed $\bar{v}$ consumes less energy than $E_\mathrm{LO}$ as $\eqref{eq:32}$, this proves the theorem.  
\end{proof}
We note that the power consumption model in \eqref{eq:1} can be approximated as a convex function when $v\gg v_0(w)$ as proved in \cite{Zeng:2019}.\footnote{Such convexity of the power consumption model $P_\mathrm{UAV}(v)$ will be numerically shown in Section \ref{sec6}.} Hence, in Algorithm \ref{Algo1}, traveling with a fixed speed between two CSs, while the speed can vary depending on the pair of CSs, is approximately optimal.

Now, the following theorems show that our GIM-B algorithm outputs an optimal solution of Problem 1 NP-easily under the assumption that the power consumption model $P_\mathrm{UAV}(v)$ is  convex in the range of the UAV  speed.\footnote{We assume $|\mathcal{V}|=O(M)$ to make the complexity of selecting $v_\mathrm{max}$ in Algorithm \ref{Algo5} negligible.}

\begin{theorem}\label{Thm4} %GIM-B optimality
The GIM-B algorithm outputs an optimal solution for Problem 1 if the power consumption model $P_\mathrm{UAV}(v)$ is convex in the range of the UAV speed.
\end{theorem}
\begin{proof}
This proof is immediate from Theorems \ref{Thm1} and \ref{Thm3} and the optimality of the Dijkstra algorithm because
\begin{enumerate}
    \item Theorem \ref{Thm1} means that every path between two CSs at the local level has the minimum travel distance.
    \item Theorem \ref{Thm3} implies that flying with the same speed in each path at the local level is optimal. Hence, the GIM-B algorithm derives the minimum travel time for the paths.
    \item Under the graph $\overrightarrow{G}_\mathrm{GL}$ with the minimized edge weights, an optimal trajectory from $\mathbf{u}_0$ to $\mathbf{u}_F$ at the global level is derived by applying the Dijkstra algorithm.
\end{enumerate}
\end{proof}

\begin{theorem}\label{Thm5} % GIM-B complexity
If the number of CSs is smaller than or equal to the number of BSs, i.e., $N\leq M$, then the time complexity of the GIM-B algorithm is $O(M^6)$. 
\end{theorem}
\begin{proof}
Let us first state the cardinalities of the following sets: $|V_\mathrm{all}|=O(M^2)$, $|V_\mathrm{LO}|=O(M^2)$, and $|V_\mathrm{GL}|=O(N)$. The steps of Algorithm \ref{Algo4} have the following complexities:
\begin{itemize}
    \item Step 1. Outage test: For a line segment, performing the function ChkOut and selecting a memory to save the line segment among $E_\mathrm{in},E_1,...,E_{N+2}$ have the complexities $O(M^2)$ and $O(N)$, respectively. Since each line segment $\overline{\mathbf{x}_1\mathbf{x}_2}$ for $\mathbf{x}_1,\mathbf{x}_2\in V_\mathrm{all}$ and $\mathbf{x}_1\neq\mathbf{x}_2$ should be checked whether experiencing an outage, the complexity of this step is $(O(M^2)+O(N))\cdot |V_\mathrm{all}|^2=O(M^6)$.
    \item  Step 2. Local level search: The complexity of deriving an optimal path between a pair of CSs at the local level can be proved similarly with the proof of Theorem \ref{Thm2}. However, this algorithm constructs the edge set $E_\mathrm{LO}$ with only complexity $O(N)$ by just loading some of the saved memories $E_\mathrm{in},E_1,...,E_{N+2}$. Hence, the complexity of deriving an optimal path in the local level is $O(N)$+$O(M^4)=O(M^4)$. Since there are $O(N^2)$ pairs of the CSs, the complexity of the step is $O(M^4N^2)$.
    \item Step 3. Global level search: This complexity is dominated by applying the Dijkstra algorithm at the graph $\overrightarrow{G}_\mathrm{GL}$ with the complexity $O(|V_\mathrm{GL}|^2)=O(N^2)$ \cite{West:2001}. 
\end{itemize}
Consequently, the complexity of the GIM-B algorithm is $O(M^6)$ for $N\leq M$.
\end{proof}

We note that our GIM-B algorithm has the same complexity order as the generalized intersection method for $N\leq M$ despite considering the battery constraint. Note that the outage of every possible line segment is tested in advance in Step 1 of GIM-B algorithm. However, a direct extension from the GIM algorithm would be treating the pair of CSs as the initial and final points and applying a modified version of Algorithm~\ref{Algo1}, which implies performing the outage test in Step~2. The following corollary shows that such a direct extension of the GIM algorithm has a higher order of complexity.

%because the complexity is reduced by checking whether the line segments experience outages in advance before the step 2 in Algorithm \ref{Algo4}. The following corollary justifies it through showing the complexity of the GIM-B algorithm without previously checking whether the line segments experience outages is higher than $O(M^6)$.

\begin{corollary}\label{Cor1} % GIM-B complexity
If the outage test is separately performed in the derivation of  an optimal path between each pair of CSs,  the time complexity increases to  $O(M^6N^2)$.
\end{corollary}
\begin{proof}
This method checks whether each line segment experiences an outage at the step 2 in Algorithm \ref{Algo4}. In this case, the complexity for deriving a path between two CSs at the local level through the step 2 is the same as the complexity $O(M^6)$ of the generalized intersection method. Hence, the complexity of this method is dominated at deriving $O(N^2)$ paths for every CS pair: $O(M^6)\cdot O(N^2)=O(M^6N^2)$.
\end{proof}

Table \ref{Tab2} compares the GIM-B algorithm with the benchmark algorithms for Problem 1.
%%%%% Table 2 %%%%%%%%%%%%%%%%
\begin{table*}
\centering
\begin{tabular}{@{} c || c | c @{}}
\cline{1-3}
Algorithm ($^*$modified considering the battery constraint) & Complexity & Performance gap \\ \cline{1-3}
Exhaustive search$^*$ \cite{Zhang:2019} & $O(M!M^{3.5}N^2)$ & 0\\ \cline{1-3}
Exhaustive search with fixed association$^*$ \cite{Zhang:2019} & $O(M^{3.5}N^2)$ & $O(MNd_0/v_q+N\tau_\mathrm{max})$ \\ \cline{1-3}
Exhaustive search with quantization$^*$ \cite{Zhang:2019} & {$O(M^4Q^2N^2)$} & $O(MNd_0/v_q+N\tau_\mathrm{max})$ \\ \cline{1-3}
%Exhaustive search with quantization$^*$ \cite{Zhang:2019} in same association &  & $O((MNd_0/v_q)\sin(1/{Q}))$ \\ \cline{1-3}
Intersection method$^*$ \cite{Chen:2020} by checking outages via Algorithm \ref{Algo3} & $O(M^4N^2)$ & $O(MNd_0/v_q+N\tau_\mathrm{max})$ \\ \cline{1-3}
Ours (Generalized intersection method with battery constraint)  & $O(M^6)$ & $0$ \\ \cline{1-3}
%LCI-B method without performing Algorithm \ref{Algo3} in advance & $O(M^6N^2)$ & $0$ \\ \cline{1-3}
\end{tabular}
\caption{Comparison of algorithms for Problem 1}\label{Tab2}
\end{table*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We note that the benchmark algorithms in Table \ref{Tab2} use the same name as Table \ref{Tab1} but they are modified by considering the battery constraint.
Specifically, we modify each benchmark algorithm similarly as Algorithm \ref{Algo4}: Step 1 is skipped since it is not applicable for the exhaustive search and its variants \cite{Zhang:2019} and it is not beneficial for the intersection method \cite{Chen:2020}, Step 2 applies the corresponding benchmark algorithm with slight modification by treating the two CSs as the initial and the final points and checking whether traveling the resultant path is affordable with the battery capacity, and Step 3 applies the Dijkstra algorithm to obtain the trajectory in the global level. 
To compare with the results in Table \ref{Tab1}, we assume that the UAV flies with a constant speed of $v_q$ for the analysis of performance gap in Table \ref{Tab2}, i.e., assume $\mathcal{V}=\{0,v_q\}$. Also, to avoid the meaningless bound of infinite gap, it is assumed that a path from the initial point to the final point exists in Step 3 for each  algorithm, i.e., assume $h_\mathrm{Gfea}=1$.  Main observations for Table \ref{Tab2} are summarized in the following:
\begin{itemize}
    \item The GIM-B algorithm outputs an optimal solution of Problem 1 NP-easily.
    %\item \hs{The complexity order} of the GIM-B algorithm is the same with the generalized intersection method, while the complexities of the benchmark algorithms increase by $O(N^2)$ when considering the battery constraint and the CSs. Such complexity gain occurs since our GIM-B algorithm checks whether the line segments experience outages in advance. We note that the intersection method \cite{Chen:2020} cannot have the complexity gain by the process since it only considers a fixed BS association sequence at the local level search and hence there are few line segments needed to test whether experiencing outages.
    \item The performance gaps of the sub-optimal algorithms increase in $N$ due to the accumulation of the gaps in finding the path between each pair of CSs. Also, note that they depend on the maximum delay $\tau_\mathrm{max}$ for battery swapping because the number of visiting CSs can increase for the sub-optimal algorithms.
    \item Compared to Table \ref{Tab1}, the performance gap of the ES-Q algorithm with the finite number $Q$ of quantization points does not decrease in $Q$, because some of the edges in the graph $\overrightarrow{G}_\mathrm{GL}$ over the CSs of the GIM-B algorithm may disappear if we apply ES-Q algorithm in Step 2 due to the battery constraint.
    %\hs{We note that the ES-Q algorithm has the same performance gap tendency as in Table \ref{Tab1} only if the same association sequence for the BSs and the CSs in the GIM-B algorithm is possible in the ES-Q algorithm, where we call this special case of the ES-Q algorithm as the ES-Q algorithm with same association.} 
\end{itemize}
The aforementioned analysis implies that our intersection point-based algorithms have more advantages compared to the benchmark algorithms in the presence of the battery constraint and the CSs.





% Remark 3: H_CS < H
\begin{remark}\label{rmk3}
When $H_\mathrm{CS}<H$, we can solve Problem 1 by including the take-off and the landing times at charging station $C_n$ in overall delay $\tau_{C_n}$ for $n\in\mathcal{N}$ and considering the consumed energy for them in the battery capacity model \eqref{eq:2}.
\end{remark}


% Remark 4: Benchmarking in general scenario
\begin{comment}
\begin{remark}\label{rmk4}
\ky{If we do not take any assumptions in Table \ref{Tab2}, then the performance gaps of the sub-optimal algorithms increase compared to this table. First, when we assume that the UAV flies with dynamic speed (i.e., $|\mathcal{V}|\geq 3$ where $0\in \mathcal{V}$), the maximum possible speed $v_\mathrm{max}$ in a path between two CSs at the local level decreases as its distance $\ell_\mathrm{LO}$ increases. Hence, it should be considered in the performance gaps that when the distance $\ell_\mathrm{LO}$ increases, its travel time additionally increases due to decreasing $v_\mathrm{max}$. Second, a path from the initial point to the final point may not exist in Step 3 for some sub-optimal algorithms (i.e., $h_\mathrm{Gfea}=0$) since some of the edges in the graph $\overrightarrow{G}_\mathrm{GL}$ over the CSs of the GIM-B algorithm may disappear if we apply the sub-optimal algorithms in Step 2 due to the battery constraint.}
\end{remark}
\end{comment}
