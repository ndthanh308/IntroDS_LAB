BSP-WHY~\cite{FG2010:HLPP,FG2015:IJPP} also uses (a previous version of) \textsc{Why} to verify bulk synchronous parallel programs. However, the two approaches are very different. BSP-WHY considers BSP programs written in an imperative style close to BSPlib~\cite{HILL1998:BSPLIB}. The verification proceeds by transforming well-formed programs --- a sub-class of what has been formally defined later by Dabrowski as textually aligned programs~\cite{DAB2019:JLAMP} --- into sequential simulating programs that are then verified using \textsc{Why}. The BSP-WHY code cannot be run on parallel machines.

The work closest to our is the specification, verification and extraction of BSML programs using the Coq proof assistant. Early contributions started with the work of Gava~\cite{GAV2003:PPL}. A formalization of BSML primitives in a style very close to the \why formalization presented in this paper was proposed by Tesson and Loulergue~\cite{TL2011:ICCS} and used in a framework, named \textsc{SyDPaCC}, for the verification of BSP functional programs~\cite{ELT2014:ITP,LRT2014:SAC}. The two main differences with our work is that: proofs are much less automated in Coq than in \why but the framework leverages the type-class resolution mechanism of Coq to automatically parallelize programs. For example in this framework, the user does not need to write the code for \w{mps_seq} and \w{mps_par}, but only needs to write \w{mps_spec} and to prove that its tupling with \w{sum} is leftwards and rightwards (i.e. can be written as calls to \w{fold_left} and \w{fold_right}) and exhibits a weak right inverse. The framework would then use transformation theorems to automatically obtain \w{mps_seq} and then verified correspondences as expressed in the post-conditions of \w{map_par} and \w{reduce_par} to automatically produce \w{mps_par}~\cite{LBT2015:IJPP}.

Ono et al.~\cite{OHT2011:SEFM} employed Coq to verify Hadoop MapReduce programs and extract Haskell code for Hadoop Streaming or directly write Java programs annotated with JML, utilizing Krakatoa~\cite{FM2007:CAV} to generate Coq lemmas. The first part of their work is functional and therefore closest to our work. However, it is limited to MapReduce which is more general than the \w{map_par} and \w{reduce_par} skeletons but is less expressive than BSML. The second part of their work is more imperative.
