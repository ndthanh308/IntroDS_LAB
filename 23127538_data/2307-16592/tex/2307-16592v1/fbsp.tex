The OCaml language is a versatile programming language that combines functional, imperative and object-oriented paradigms. BSML~\cite{LGB2005:ICCS} (Bulk Synchronous Parallel ML) is an OCaml-based library that embodies the principles of the BSP~\cite{VAL1990:CACM} (Bulk Synchronous Parallel) model. It provides a range of constants and functions to facilitate BSP programming. The BSP machine, viewed as a homogeneous distributed memory system with a point-to-point communication network and a global synchronization unit, serves as the underlying architecture for BSML. BSP programs, composed of consecutive super-steps, run on this kind of machine. The execution of each super-step follows a distinct pattern, starting with the computation phase where each processor-memory pair performs local computations using data available locally. This phase is followed by the communication phase, during which processors can request and exchange data with other processors. Finally, the synchronization phase concludes the super-step, synchronizing all processors globally.

With its collection of four expressive functions and constants like "bsp_p" representing the number of processors in the BSP machine, BSML empowers developers to create BSP algorithms. While OCaml supports imperative programming and BSML can exploit it~\cite{LOU2017:SCPE}, in this paper we only consider the pure functional aspects of OCaml and BSML. This deliberate focus differentiates it from the imperative counterparts provided by libraries such BSPlib for C~\cite{HILL1998:BSPLIB}. The types and informal semantics of BSML primitives are listed in Figure~\ref{fig:bsml:primitives}

% Figure environment removed



Let us consider a function "f" that maps integers to values of type "'a" (denoted as "f: int->'a" in OCaml). The BSML primitive "mkpar f" produces a \emph{parallel vector} of type "'a par" when applied to function "f". Within this parallel vector, each processor, identified by the index value "i" within the range $0\leq i<$"bsp_p", stores the computed value of "f i". For instance, employing the expression "mkpar(fun i->i)" yields a parallel vector denoted as $\langle 0,~\ldots,~\mathtt{bsp\_p}-1\rangle$ of type "int par". Throughout subsequent discussions, we shall refer to this parallel vector as "this." Additionally, the function "replicate" possesses the type "'a -> 'a par" and can be defined as follows: "let replicate = fun x -> mkpar(fun i -> x)". By employing the expression "replicate x," the value "x" becomes uniformly available across all processors within the parallel vector. Parallel vectors always have size "bsp_p".

To apply a parallel vector of functions (which is not a function) to a parallel vector of values, one has to use the primitive "apply". Both "mkpar" and "apply" are executed within the pure computation phase of a super-step. For communications and an implicit synchronization barrier, the last two primitives "proj" and "put" should be applied. "proj" is essentially an inverse of "mkpar" but the resulting function is partial and only defined on the domain "[0, p-1]". As the first constant constructor of any inductively defined type is considered as the empty message, "put" allows to program any communication pattern of a BSP super-step. In the input vector of "put", each function encodes the message to be sent to other processors by the processor holding it. In the result vector, each function represents the message received from other processors by the processor holding the function.

Figure~\ref{fig:bsml:example} presents a small BSML example using its primitives and "parfun" which is part of its standard library. "List.map" and "List.fold_left" are part of the OCaml standard library and are sequential map and reduce functions.

Lines 4--5, we define a function "list_of_par" which converts a parallel vector into a list. This function requires a full super-step for its execution because it needs data exchanges. Also part of the BSML standard library, "procs" has type "int list" and is the list "[0;$\ldots$;bsp_p-1]".

Lines 7--8, we define an algorithmic skeleton: a parallel map that operates on a distributed list (represented here as a value of type "'a list par"). This function also requires the computation phase of a super-step and does not need any data exchange or synchronization.

Lines 10--13, we define the "reduce" algorithmic skeleton, using a binary associative operation "op" and a neutral element "e", it ``sums'' a distributed list into a single value. It proceeds in two steps. First, each processor compute a partial ``sum'' of the list it holds locally. Second, this vector of partial sums is transformed into a list which is finally summed up. As we call "list_of_par", a full super-step is required.

Finally, in lines 15--18, we implement a parallel function to solve the maximum prefix sum problem. Computing at the same time the maximum prefix sum and the sum of a list (in a pair) can be implemented using "map" and "reduce". For example, on a machine with at least 4 processors, the value of
"mps (mkpar(function|0->[1;2]|1->[-1;2]|2->[-1;3]|3->[-4]|_->[]))"
is "6". Indeed, the argument of "mps" is a distributed version (on 4 processors) of the list "[1;2;-1;2;-1;3;-4]" and its prefix with the largest sum is the list without its last element. We specify and prove the correctness of "mps" in Section~\ref{sec:application}.

% Figure environment removed
