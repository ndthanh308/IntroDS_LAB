% Figure environment removed

\subsection{Specifying and verifying functional programs with \why}

\why is often used in the verification of imperative programs. As BSML is purely functional and BSML applications mostly used the functional features of OCaml, we focus here on the verification of functional programs. This focus is also a necessity as we will explain in the next subsection.

In addition to its core features, \why provides a standard library with data structures such as lists and arrays, as well as basic arithmetic logic with integers and reals. We illustrate this short introduction with the example of Figure~\ref{fig:why:maximum}. Note that this figure presents a pretty-printed version of the actual code, for example $\mathtt{/\backslash}$ is rendered as $\wedge$, \texttt{->} as $\rightarrow$, \texttt{'a} as $\alpha$, \textit{etc.}

WhyML developments are organized in \emph{modules}. The example defines two modules: \lstinline{Max} (lines 1--9) and \lstinline{MaxList} (lines 11-33). Defined modules can be used in other modules with the \lstinline{use} keyword. We use some modules of \why standard library: \lstinline{int.Int} about integer arithmetic (lines 2 and 12) and \lstinline{list.List}, \lstinline{list.Length}, \lstinline{list.NthNoOpt} for basic definitions and facts about lists (lines 13--15).

The module \lstinline{Max} is devoted to the specification and definition of a function \lstinline{max} which returns the largest of two integers. This function does not have any pre-condition but its post-conditions are introduced by the keyword \lstinline{ensures}.

Assuming the file \texttt{maximum.mlw} contains only the module \lstinline{Max}, verifying that \lstinline{max} satisfies its preconditions using the prover Alt-Ergo can be done with the following command:
{\codefigsize
\begin{verbatim}
why3 prove --prover alt-ergo maximum.mlw    
\end{verbatim}}
\noindent and the tool answers \lstinline{max} indeed satisfies its contract:
{\codefigsize
\begin{verbatim}
File maximum.mlw:
Goal max'vc.
Prover result is: Valid (0.00s, 8 steps).    
\end{verbatim}}

In our study, most of the functions to verify are recursive and often manipulate lists. Lines 19--30 are an example of a recursive function that takes a list of integers and returns the highest value the list contains.

To write the contract of function \lstinline{maximum}, we use the notation \lstinline{l[i]} to access the $i^\text{th}$ element of list \lstinline{l}. This notation is defined as a binary function in line~17 and is actually an alias for the \lstinline{nth} function of the standard library. Note that this definition is introduced by the keyword \lstinline{function} instead of the keyword \lstinline{let} (as in line 4). The purpose of \lstinline{([])} is to be used only in specifications while \lstinline{max} is code that is meant to be executed. Pure functions may be used in both roles if they are defined using both keywords. In this example, \lstinline{max} cannot be used in assertions while the bracket notation cannot be used in programs.

For \lstinline|maximum|, we have a larger contract with new clause types. We  add a pre-condition (following the keyword \lstinline{requires}) to this contract, due to the fact that our function is not defined on empty lists. To ensure termination, we define a \lstinline{variant}, which must be decreasing with each recursive call. The recursive call in line~30 is indeed called on the tail of the input list, thus this called is made on strictly smaller argument than \lstinline{l}.

We need quantifiers to express our post-conditions. The maximum value must be contained in the list (line 22 using \lstinline{exists}), and must be greater than or equal to all the values in the list (line 21 using \lstinline{forall}).

The definition of the function follows in lines 24--30. It proceeds by pattern matching on the input list. The case of the empty list (constructor \lstinline{Nil}) is \lstinline{absurd} as the pre-condition specifies the input list should not be empty (expressed as a fact on its length in line 20). If the list is a singleton (case \lstinline{(Cons h Nil)}), the result is of course the only element of the list. Otherwise --- and let us ignore lines 28--29 for the moment --- the result is the maximum of the head and the recursive call on the tail (line 30). Without lines 28--29, the execution of the tool now answers:
{\codefigsize
\begin{verbatim}
File maximum.mlw:
Goal max'vc.
Prover result is: Valid (0.00s, 8 steps).
File maximum.mlw:
Goal maximum'vc.
Prover result is: Timeout (5.00s).
\end{verbatim}}
Using Z3 or CVC5, or increasing the timeout, or changing the proof strategy does not change the outcome. It is possible to apply transformations to the goals. Using the \why IDE, just splitting the verification condition for \lstinline{maximum} gives five verification conditions: one for verifying the empty case is indeed absurd, one to check that the recursive call is indeed decreasing, one to check the pre-condition of the recursive call and one for each post-conditions. All these sub-goals are valid but the one corresponding to the post-condition in line 22 which remains unknown. To help the provers, we added lines 28--29 which relate elements of \lstinline{l} with elements of its tail via \lstinline{nth}. This assertion is easily verified and then eases the verification of the post-condition. The answer of the tool changes to:
{\codefigsize
\begin{verbatim}
Prover result is: Valid (0.09s, 749 steps).
\end{verbatim}}


\subsection{Limitations with higher-order functions}

% Figure environment removed

To show the limitations of \why in handling higher-order functions, let us consider the example of Figure~\ref{fig:why:higher_order}. Intuitively,  \lstinline{option 'a} extends the type \lstinline{'a} with a value \lstinline{None} and all the other values are encapsulated in the constructor \lstinline{Some}.

In lines 1--10, we define a module \lstinline{Concrete} containing the definition of a function \lstinline{remove_option} that extracts the value encapsulated in an optional value assuming this value is not \lstinline{None}. In the module \lstinline{Failure}, we apply this function but through a higher-order function \lstinline{apply} that just applies a function to a value. The tool fails to verify the function \lstinline{test_KO} which intuitively does exactly the same as \lstinline{remove_option}.
Note that if \lstinline{remove_option} was performing side effects or was partial because it may raise exceptions, \why would reject the program with an error. Here the problem is less visible. Indeed, the arguments of a higher-order function must be purely functional and \emph{total} functions.
In our case \lstinline{remove_option} is not total as its pre-condition excludes \lstinline{None}. The manifestation of the problem can be seen in a sub-verification condition generated by \why:
\lstinline{forall opt:option 'a. opt <> None}, which is impossible to prove.

Still, as most BSML primitives are higher-order functions, and we need to use functions such as \lstinline{remove_option}, a work-around was needed. Our solution is shown in module \lstinline{Abstract} (lines 19--24). Instead of writing a concrete implementation of \lstinline{remove_option}, we \emph{declare} a function \lstinline{remove_option} without defining it, and we only give its semantics (with an \lstinline{axiom}) when the pre-condition is met. It looks like a total function but if its application does not satisfy the precondition then it is impossible to reason about the result of the application. If the overall verification of a client code works despite an incorrect application of \lstinline{remove_option}, it means the result of the incorrect application was not used.
In module \lstinline{Success}, the same client code as module \lstinline{Failure} uses module \lstinline{Abstract} instead of module \lstinline{Concrete} and the verification succeeds.