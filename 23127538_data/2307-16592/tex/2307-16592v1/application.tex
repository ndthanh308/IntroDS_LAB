% Figure environment removed

% Figure environment removed

To exercise the formalization presented in the previous section, we specify and verify an implementation of the maximum prefix sum informally presented in Section~\ref{sec:fbsp}. As in the BSML implementation, the implementation with WhyML relies on algorithmic skeletons. The skeleton \w{par_map} is defined in lines 1--6 of Figure~\ref{fig:bsml:why:skeletons}. The only different with its BSML/OCaml counterpart is the post-conditions including one expressed as a correspondence with the sequential \w{map}. Given a distributed list \w{dl} (of type \w{par(list 'a)}), one obtains the same result by either applying \w{map_par} then transforming the obtained distributed list into a list with \w{to_list}, or applying the sequential \w{map} to the sequentialization of the distributed list. Line 5 is just a hint for the provers: an application of lemma \w{flatten_map} that basically commute \w{map} and \w{flatten}.

The implementation (lines 8-20) of the parallel reduction \w{reduce_par} is also very close to its BSML/OCaml counterpart of Figure~\ref{fig:bsml:example}. As expected, the post-condition on line 16 is expressed with respect to the sequential reduction here implemented with the usual \w{fold_left} function. As the result is already a sequential value there is no need to sequentialize it. However, this correspondence is true only if \w{op} is associative and \w{e} is its neutral element which are two pre-conditions stated lines 10--11. There are two additional pre-conditions and a \w{ghost} argument, i.e. an argument only used in the contract (and possible annotations) of the function. The reason is again to deal with a form of partial functions. \w{op} is a total function, but it may not have the desired properties (associativity, neutral element) on all the values of its input type. Indeed, the OCaml version of "op" for "mps" that we will also use in the WhyML version of \w{mps}, is not associative if we consider all pairs of integers. In the maximum prefix sum problem, the first component of such a pair represents the maximum prefix sum, it is therefore positive, and the second component the sum of the list, thus it is lower or equal to the first component. The ghost argument \w{inv} expresses such properties on the values manipulated during the reduction. This is an invariant: \w{op} should preserve the property (line 12) and the input values \w{e} and \w{dl} should satisfy this property (line 13). The predicates \w{associative}, \w{neutral}, \w{preserves} and \w{satisfies} are defined in Figure~\ref{fig:bsml:why:algebra}. Such definitions work also well when there is no need for an invariant: in this case we simply use the constant boolean function always returning \w{true}.

% Figure environment removed

With these skeletons, it is possible to implement a parallel function to compute the maximum prefix sum of a distributed list as we did in Section~\ref{sec:fbsp}. First, we define a \emph{specification} as an inefficient function but direct translation of the informal specification: the \w{mps_spec} function on lines 1--2 of Figure~\ref{fig:bsml:why:mps}. We also define \w{op} (lines 7--8) and \w{f} (line 10) which are the arguments to \w{map} and \w{reduce} as in the BSML/OCaml example of Figure~\ref{fig:bsml:example}. This time they are not local definitions because we need to state and verify some lemmas about them and because we have two versions of \w{mps}: \w{mps_seq} and \w{map_par}.
The invariant explained above is defined lines 12--13. We need an auxiliary function to verify the correctness of our functions with respect to the specification: \w{ms} (line 4--5) is the tupling of \w{mps_spec} and \w{sum}. The rest of the code in Figure~\ref{fig:bsml:why:mps} is the definitions of the sequential and parallel versions of the maximum prefix sum computation. Both of them are expressed as a composition of map and reduce.

The proof that \w{mps_seq} indeed implements the specification \w{mps_spect} proceeds by using the first homomorphism theorem. This theorem states that a homomorphic function can be implemented as a composition of map and reduce. A function \w{f} is homomorphic when there exists a binary operation $\odot$ such that: \w{forall l1 l2: list 'a. f(l1++l2) = (f l1)} $\odot$ \w{(f l2)} where \w{++} denotes list concatenation. \w{mps_spec} is not homomorphic but \w{ms} is. Two lines of annotations are necessary to guide the provers in the sequential case (lines 17--18). The parallel case does need any annotation: basically the contracts of \w{map_par} and \w{reduce_par} state their correspondence with their sequential counterpart thus the correspondence of the parallel \w{mps_par}â€” with the sequential \w{mps_seq}, and \w{mps_seq} satisfies \w{mps_spec}.

The full development is about 600 lines of WhyML with about 45\% of specifications and 55\% of code. It generates 74 goals, 100\% of which are proved. Their verification produces 37 sub-goals. The strategy \texttt{Auto level 2} is used: it tries the provers CVC4, Alt-Ergo, CVC5 and Z3 with a short timeout (1s). If the goal is not proved then it splits the goal and try on the sub-goals with the same timeout and finally if necessary tries with a larger timeout (10s). Alt-Ergo version 2.4.3 proved 11 goals taking between 0.02s and 0.56s (when successful) and CVC4 version 1.6 proved 91 goals taking between 0.04s and 2.45s. Several sub-goals can contribute to a goal to be proved. For example the verification condition of \w{mps_seq} is split in 3 sub-goals. In the number of the goals proved by CVC4 and Alt-Ergo the root goals verified because their sub-goals are proved are not counted. In our case, only 9 goals needed to be split to achieve their proofs.