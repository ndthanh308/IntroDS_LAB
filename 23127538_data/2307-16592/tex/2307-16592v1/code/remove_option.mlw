module Concrete
  use export option.Option
      
  let remove_option (opt : option 'a) : 'a 
    requires { opt <> None } ensures { (Some result) = opt } 
  = match opt with
    | Some x -> x
    | None -> absurd
    end
end
module Failure
  use Concrete
  let apply (f:'a->'b)(a:'a) : 'b = f a

  let test_KO (c: option 'a) : 'a (* CANNOT BE VERIFIED *)
    requires { c <> None } ensures { Some(result) = c } 
  = apply remove_option c
end
module Abstract 
  use export option.Option
    
  val function remove_option(opt: option 'a) : 'a   
  axiom remove_option: forall x: 'a. remove_option(Some x) = x
end
module Success      
  use Abstract 
  let apply (f:'a->'b)(a:'a) : 'b = f a

  let test_OK (c: option 'a) : 'a
    requires { c <> None } ensures { Some(result) = c } 
   = apply remove_option c     
end