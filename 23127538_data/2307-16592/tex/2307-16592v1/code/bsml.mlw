theory BSML
  use int.Int
  val constant bsp_p : int
  axiom at_least_one_processor : bsp_p > 0

  type par 'a       
  val ghost function get (_ : par 'a) (_ : int) : 'a
  axiom extensionality: 
    forall v v': par 'a. 
    (forall i: int. 0<=i<bsp_p -> get v i = get v' i) -> v = v'

  val mkpar (f : int -> 'a ) : par 'a 
    ensures { forall i:int. 0 <= i < bsp_p -> get result i = f i }
      
  val apply (f : par ('a -> 'b)) (v : par 'a ) : par 'b
    ensures { forall i:int. 0 <= i < bsp_p -> 
                       get result i = (get f i) (get v i) }
      
  val proj (v : par 'a) (x : int) : 'a 
    ensures { result = get v x } 
    
  val put (v : par (int -> 'a)) : par (int -> 'a) 
    ensures { forall s d:int. 0 <= s < bsp_p -> 0 <= d < bsp_p -> 
                             (get result d) s = (get v s) d }
end