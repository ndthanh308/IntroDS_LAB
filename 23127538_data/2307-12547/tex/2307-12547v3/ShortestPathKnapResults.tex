\section{\shortestpathknapsack}

We now consider \shortestpathknapsack. We observe that all the $u$ to $v$ paths in the reduced instance of \pathknapsack in the proof of \Cref{thm:pk-pathwidth} are of the same length. Hence, we immediately obtain the following result as a corollary of \Cref{thm:pk-pathwidth}.

\begin{corollary}\label{cor:shortest-pathwidth}
\shortestpathknapsack is \NPC even for graphs of pathwidth at most two and the weight of every edge is one. In particular, \shortestpathknapsack is \PNPH parameterized by pathwidth.
\end{corollary}

Interestingly, \shortestpathknapsack admits a pseudo-polynomial-time algorithm for any graph unlike \pa and \pathknapsack.

\begin{theorem}\label{thm:shortest-algo}
There is an algorithm for \shortestpathknapsack running in time $\OO((m+n\log n)\cdot\min\{s^2,(\alpha(\VV))^2\})$, where $m$ is the number of edges in the input graph.
\end{theorem}

\begin{proof}
Let $(\GG=(\VV,\EE,(c(e))_{e\in\EE}),(w(u))_{u\in\VV},(\alpha(u))_{u\in\VV},s,d,x,y)$ be an arbitrary instance of \shortestpathknapsack. We design a greedy and dynamic-programming based algorithm. For every vertex $v\in \VV$, we store a boolean marker $b_v$, the distance $\delta_v$ of $v$ from $x$, and a set $D_v=\{(w,\alpha):\exists$ an $x$ to $v$ shortest-path \PP such that $w(\PP)=w, \alpha(\PP)=\alpha,$ and for every other $x$ to $v$ shortest-path \QQ, we have either $w(\QQ)>w$ or $\alpha(\QQ)<\alpha \text{ (or both)}\}$. That is, we store undominated weight-value pairs of all shortest $x$ to $v$ paths in $D_v$. We initialize $b_x=\false, \delta_x=0, D_x=\{(w(x),\alpha(x)\}, b_u=\false, \delta_u=\infty,$ and $ D_u=\emptyset$ for every $u\in\VV\setminus\{x\}$.

Updating DP table: We pick a vertex $z=\argmin_{v\in\VV:b_v=\false}\delta_v$. We set $b_z=\true$. For every neighbor $u$ of $z$, if $\delta_u>\delta_z+c(\{z,u\})$, then we reset $D_u=\emptyset$ and set $\delta_u=\delta_z+c(\{z,u\})$. If $\delta_u=\delta_z+c(\{z,u\})$, then update $D_u$ as follows: for every $(w,\alpha)\in D_z$, we update 
$D_z$ to $(D_z\cup\{(w+w(u),\alpha+\alpha(u))\})$ if $w+w(u)\le s$. We remove all dominated pairs from $D_u$ just before finishing each iteration. If we have $b_v=\true$ for every vertex, then we output \yes if there exists a pair $(w,\alpha)\in D_y$ such that $w\le s$ and $\alpha\ge d$. Else, we output \no.

We now argue the correctness of our algorithm. Following the proof of correctness of the classical Dijkstra's shortest path algorithm, we observe that if $b_v$ is $\true$ for any vertex $v\in\VV$, its distance from $x$ is $\delta_v$~\cite{DBLP:books/daglib/0023376}. We claim that at the end of updating a table entry in every iteration, the following invariant holds: for every vertex $v\in\VV$ such that $b_v=\true$, $(k_1,k_2)\in D_v$ if and only if there exists an $x$ to $v$ undominated shortest path $\PP$ using only vertices marked $\true$ such that $w(\PP)=k_1$ and $\alpha(\PP)=k_2$.

The invariant clearly holds after the first iteration. Let us assume that the invariant holds after $i\;(>\!\!\!\!1)$ iterations; $\VV_T$ be the set of vertices which are marked $\true$ after $i$ iterations. We have $|\VV_T|=i>1$. Suppose the algorithm picks the vertex $z_{i+1}$ in the $(i+1)$-th iterationl; that is, we have $z_{i+1}=\argmin_{v\in\VV:b_v=\false}\delta_v$ when we start the $(i+1)$-th iteration. Let $\PP^*=x,\ldots,z,z_{i+1}$ be an undominated $x$ to $z_{i+1}$ shortest path using the vertices marked $\true$ only. Then we need to show that $(w(\PP^*),\alpha(\PP^*))\in D_{z_{i+1}}$. We claim that the prefix of the path $\PP^*$ from $x$ to $z$, let us call it $\QQ=x,\ldots,z$, is an undominated $x$ to $z$ shortest path using the vertices marked \true only. It follows from the standard proof of correctness of Dijkstra's algorithm~\cite{DBLP:books/daglib/0023376} that $\QQ$ is a shortest path from $x$ to $z$. Now, to show that $\QQ$ is undominated, let us assume that another shortest path $\RR$ from $x$ to $z$ dominates $\QQ$. Then the shortest path $\RR^\pr$ from $x$ to $z_{i+1}$ which is $\RR$ followed by $z_{i+1}$ also dominates $\PP^*$ contradicting our assumption that $\PP^*$ is an undominated shortest path from $x$ to $z_{i+1}$. We now observe that the iteration $j$ when the vertex $z$ was marked \true must be less than $(i+1)$ since $z$ is already marked \true in the $(i+1)$-th iteration. Now, applying induction hypothesis after the $j$-th iteration, we had $(w(\QQ),\alpha(\QQ))\in D_z$ and $(w(\PP^*),\alpha(\PP^*))\in D_{z_{i+1}}$. Also, at the end of the $j$-th iteration, the $\delta_z$ and $\delta_{z_{i+1}}$ values are set to the distances of $z$ and $z_{i+1}$ from $x$ respectively. Thus, the $D_z$ and $D_{z_{i+1}}$ are never reset to $\emptyset$ after $j$-th iteration. Also, we never remove any undominated pairs from DP tables. Since $\PP^*$ is an undominated $x$ to $z_{i+1}$ path, we always have $(w(\PP^*),\alpha(\PP^*))\in D_{z_{i+1}}$ from the end of $j$-th iteration and thus, in particular, after $(i+1)$-th iteration. Hence, invariant (i) holds for $z_{i+1}$ after $(i+1)$-th iteration. Now consider any vertex $z^\pr$ other than $z_{i+1}$ which is marked \true after $(i+1)$-th iteration. Let $\PP_1=x,\ldots,z^\pr$ be an undominated $x$ to $z^\pr$ shortest path using the vertices marked \true only. If $\PP_1$ does not pass through the vertex $z_{i+1}$, then we have $(w(\PP_1),\alpha(\PP_1))\in D_{z_{z^\pr}}$ by induction hypothesis after $i$-iterations. If $\PP_1$ passes through $z_{i+1}$, we have $\delta_{z_{i+1}}<\delta_{z^\pr}$ since all the edge weights are positive. However, this contradicts our assumption that $z^\pr$ had already been picked by the algorithm and marked \true before $z_{i+1}$ was picked. Hence, $\PP_1$ cannot use $z_{i+1}$ as an intermediate vertex. Hence, after $(i+1)$ iterations, for every vertex $v\in\VV$ such that $b_v=\true$, for every $x$ to $v$ shortest path \PP using only vertices marked \true, we have $(w(\PP),\alpha(\PP))\in D_v$.


For the other direction, let $(k_1,k_2)$ be an arbitrary pair in $D_{z_{i+1}}$ after $(i+1)$ iterations. Let $j$ be the iteration when $(k_1,k_2)$ was first included in $D_{z_{i+1}}$; $z^\pr$ be the vertex that the algorithm picked and marked \true in the $j$-th iteration. Since $(k_1,k_2)$ was included in $D_{z_{i+1}}$ in the $j$-th iteration, we must have an edge between $z^\pr$ and $z_{i+1}$. From the proof of correctness of Dijkstra's algorithm, we observe that, after the end of the $j$-th iteration, $\delta_{z_{i+1}}$ is $\delta_{z^\pr}+c(\{z^\pr,z_{i+1}\})$ which is actually the distance of $z_{i+1}$ from $x$ and was thus never decreased after $j$-th iteration of the algorithm. Hence, $D_{z_{i+1}}$ is never reset to $\emptyset$ after the $j$-th iteration and thus the pair $(k_1,k_2)$ remains in $D_{z_{i+1}}$ from $j$-th iteration till $(i+1)$-th iteration. Also, it follows from the proof of correctness of Dijkstra's algorithm that there is a shortest path from $x$ to $z_{i+1}$ using vertices marked \true in the first $j$ iterations only. In particular, there exists an undominated shortest path $\PP_1$ from $x$ to $z_{i+1}$ using vertices marked \true in the first $(i+1)$ iterations only with $w(\PP_1)=k_1$ and $\alpha(\PP_1)=k_2$. Hence, the invariant holds for $z_{i+1}$ after $(i+1)$ iterations. For every other vertex $z^\prr\in\VV$ such that $z^\prr$ is marked \true, we have already argued before that we cannot have a shortest $x$ to $z^\prr$ path using $z_{i+1}$ as an intermediate vertex. Thus, the invariant holds for $z^\prr$ thanks to induction hypothesis.


For every vertex $v\in\VV$, the cardinality of $D_v$ is at most $s$ and also at most $\alpha(\VV)$ and thus at most $\min\{s,\alpha(\VV)\}$. Implementing the above algorithm using a standard Fibonacci heap-based priority queue to find $\argmin_{v\in\VV:b_v=\false}\delta_v$ gives us a running time $\OO((m+n\log n)\cdot\min\{s^2,(\alpha(\VV))^2\})$ where $m$ is the number of edges in the graph.
\end{proof}

Clearly, \shortestpathknapsack admits a polynomial-time algorithm for trees since only one path exists between every two vertices.

\begin{observation}\label{obs:shortest-tree-poly}
\shortestpathknapsack is in \Pb for trees.
\end{observation}

Using the technique in \Cref{thm-fptas}, we use \Cref{thm:shortest-algo} as a black-box to obtain the following approximation algorithm. We again omit its proof due to its similarity with \Cref{thm-fptas}.


\begin{theorem}\label{thm-fptas-shortest-path}
There is a $\text{poly}(n,1/\eps)$ time, $(1-\eps)$ factor approximation algorithm for \shortestpathknapsack for optimizing the value of the solution.
\end{theorem}