\section{Results for \shortestpathknapsack}

We now consider \shortestpathknapsack. We observe that all the $u$ to $v$ paths in the reduced instance of \pathknapsack in the proof of \Cref{thm:pk-pathwidth} are of the same length. Hence, we immediately obtain the following result as a corollary of \Cref{thm:pk-pathwidth}.

\begin{corollary}\label{cor:shortest-pathwidth}
\shortestpathknapsack is \NPC even for graphs of pathwidth at most two and the weight of every edge is one. In particular, \shortestpathknapsack is \PNPH parameterized by pathwidth.
\end{corollary}

Interestingly, \shortestpathknapsack admits a pseudo-polynomial-time algorithm for general graphs unlike \pa and \pathknapsack.

\begin{theorem}\label{thm:shortest-algo}
There is an algorithm for \shortestpathknapsack running in time $\OO(n\log n\cdot\min\{s^2,(\alpha(\VV[\GG]))^2\})$.
\end{theorem}

\begin{proof}
Let $(\GG(\VV,\EE),(c(e))_{e\in\EE},(w(u))_{u\in\VV},(\alpha(u))_{u\in\VV},s,d,x,y)$ be an arbitrary instance of \shortestpathknapsack. We design a greedy and dynamic-programming based algorithm. For every vertex $v\in \VV$, we store a boolean marker $b_v$, the distance $\delta_v$ of $v$ from $x$ and a set $D_v=\{(w,\alpha):\exists\text{ an $x$ to $v$ shortest-path \PP such that }w(\PP)=w, \alpha(\PP)=\alpha\text{ for every other $x$ to $v$ shortest-path \QQ, we have wither }w(\QQ)>w \text{ or }\alpha(\QQ)<\alpha\}$. That is, we store undominated weight-value pairs of all shortest $x$ to $v$ paths. We initialize $b_x=\false, \delta_x=0, D_x=\{(w(x),\alpha(x)\}, b_u=\false, \delta_u=\infty,$ and $ D_u=\emptyset$ for every $u\in\VV\setminus\{x\}$.

Updating DP table: We pick a vertex $z=\argmin_{v\in\VV:b_v=\false}\delta_v$. We set $b_z=\false$. For every neighbor $u$ of $z$, we set $\delta_u=\min\{\delta_u,\delta_z+c(\{z,u\})\}$. If $\delta_u=\delta_z+c(\{z,u\})$, then update $D_u$ as follows: for every $(w,\alpha)\in D_z$, we put $(w+w(u),\alpha+\alpha(u))$ in $D_u$ if $w+w(u)\le s$; and we finally remove all dominated pairs from $D_u$. If we have $b_v=\true$ for every vertex, then we output \yes if there exists a pair $(w,\alpha)\in D_y$ such that $w\le s$ and $\alpha\ge d$. Otherwise, we output \no.

We now argue the correctness of our algorithm. Following the proof of correctness of the classical Dijkstra's shortest path algorithm, we observe that if $b_v$ is \true for any vertex $v\in\VV$, its distance from $x$ is $\delta_v$~\cite{DBLP:books/daglib/0023376}. We claim that at the end of updating a table entry, the following invariant holds: for every vertex $v\in\VV$ such that $b_v=\true$ and $x$ to $v$ undominated shortest path \PP using only vertices marked \true, $(w(\PP),\alpha(\PP))\in D_v$. The invariant holds vacuously after initialization since every vertex is marked \false. The invariant holds inductively since we update the DP table of the neighbors of vertices which are labeled \true. For every vertex $v\in\VV$, the cardinality of $D_v$ is at most $s$ and also at most $\alpha(\VV[\GG])$ and thus at most $\min\{s,\alpha(\VV[\GG])\}$. Implementing the above algorithm using standard Fibonacci heap-based priority queue to find $\argmin_{v\in\VV:b_v=\false}\delta_v$ gives us a running time $\OO(n\log n\cdot\min\{s^2,(\alpha(\VV[\GG]))^2\})$.
\end{proof}

Clearly, \shortestpathknapsack admits a polynomial-time algorithm for trees since only one path exists between every two vertices.

\begin{observation}\label{obs:shortest-tree-poly}
\shortestpathknapsack is polynomial-time solvable for trees.
\end{observation}

Using the technique in \Cref{thm-fptas}, we use \Cref{thm:shortest-algo} in a black-box fashion to have the following approximation algorithm. We again omit its proof due to its similarity with \Cref{thm-fptas}.


\begin{theorem}\label{thm-fptas-shortest-path}
There is an $(1-\eps)$ factor approximation algorithm for \shortestpathknapsack for optimizing the value of the solution running in time $\text{poly}(n,1/\eps)$.
\end{theorem}