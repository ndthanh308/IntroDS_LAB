

\subsubsection{Algorithm 4}\label{sec:algo4}
\begin{theorem}\label{thm:poly_path}
	 \pa is polynomial time solvable for Path .
\end{theorem}
\begin{proof}
Consider a path $\PP$ with $\mathcal{O}(n)$ vertices. The maximum degree of $\PP$ is 2. Suppose an attack is caused at a node $x$. An attack can propagate from $x$ to, at most, two neighbors of $x$. The attack spreading process executes recursively to the other non-affected nodes. Each neighbor of $x$ is connected with $\mathcal{O}(n)$  number of vertices. So, for each neighbor of $x$, there are n of possible choices to cause maximum damage by connecting all the affected nodes. Since the degree of $x$ is 2, thus the algorithm runs at most $\mathcal{O}(n^2)$ times.
\end{proof}



\subsubsection{Algorithm 5}\label{sec:algo5}
\begin{theorem}\label{thm:fpt-vc}
	\pa is \FPT with respect to size of vertex cover of the solution set $\WW$.
\end{theorem}
\begin{proof}
	Steps:\\
	* After applying color coding on $\GG$ we get a subgraph $\HH$.\\
	* Our solution of \pa $\WW$ is contained in the $\HH$.\\
	* Again applying color coding we get the \vc $\XX$ of $\HH$ and also $\XX$ subset of $\WW$.\\
	* We can find $\HH$ by adding the one-hop neighbor of $\XX$ with it.\\
	* $\HH$ has bounded treewidth, which is at most the \vc $\XX$ of $\HH$, we get $\WW$.

\end{proof}


\break
\textcolor{blue}{
\subsubsection{FPTAS(for Treewidth)}\label{fptas}
Let us consider $I$is the instance of \pa. We define $I= (w_u)_{u\in\VV},(\alpha_u)_{u\in\VV}, s, d)$, where $s$ is the budget and $d$ is the target value. Let $OPT=\sum_{u \in \UU}\alpha_u$, which means $\UU$ be an optimal solution provided by the Treewidth Algorithm on $I$. The run time of Treewidth Algorithm on $I$ is $2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot {\sf min}\{s,d\} \leq 2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot {\sf min}\{s,\sum_{u \in \UU}\alpha_u\}\leq 2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot {\sf min}\{s,OPT\} \leq 2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot OPT $.\\
Now, from the definition of $greedy\_path$ we have,\\
\begin{equation}\label{eq1}
	greedy\_path \leq OPT
\end{equation}
\begin{align*}
	\text{and, \quad} OPT & \leq \sum_{{u_i, u_j \in \UU}\atop{i\not=j}}\alpha_{{path}_{u_i \leadsto u_j}}\\
	& \leq \sum_{\substack{u_i, u_j \in \VV, \\ u_i \leadsto u_j \text{~budget feasible}\\i\not=j}} \alpha_{{path}_{u_i \leadsto u_j}}\\
	& \leq\displaystyle
	{n
	\choose
	2}* greedy\_path
\end{align*}
\begin{equation}\label{eq2}
	\text{So,  \quad}OPT \leq \frac{n(n-1)}{2}* greedy\_path 
\end{equation}
\subsubsection{Algorithm }\label{sec:algo3}
Approximation Scheme for \pa.
\begin{breakablealgorithm}\label{algo_fptas}
	\hspace*{\algorithmicindent}
	\begin{algorithmic}[1]		
		\State \textbf{Construct} instance $I'=(w_u)_{u\in\VV},\Bigl(\lfloor \frac{\alpha_u}{\mu}\rfloor\Bigr)_{u\in\VV}, s, d)$;
		\State \textbf{Run} Treewidth Algorithm on $I'$ to compute an solution $\WW' \subseteq \VV$ such that $\UU'$ be an optimal solution;
		\State \textbf{Output} $\UU'$;
	\end{algorithmic}
\end{breakablealgorithm}
Let $I'=(w_u)_{u\in\VV},\Bigl(\lfloor \frac{\alpha_u}{\mu}\rfloor\Bigr)_{u\in\VV}, s, d)$ be another instance by rounding down the values and $ALG=\sum_{u \in \UU'}\alpha_u$ be the optimal value provided by the FPTAS Algorithm. Also, $ALG$ is the maximum possible value for the modified values. Note that $\UU'$ is a feasible solution for $I$.
\begin{theorem}\label{thm:fptas}
	Algorithm\ref{sec:algo3} is a fully polynomial approximation scheme for \pa.
\end{theorem}
\begin{proof}
	\begin{equation}\label{eq5}
		\text{Let\quad} \mu =\frac{\epsilon}{n} greedy\_path
	\end{equation}
	and $OPT'$ is the optimal solution produced by the Treewidth Algorithm for instance $I'$. So, for this case,\\
	\begin{equation}\label{eq3}
		\text{Run time} = 2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot OPT'
	\end{equation}
	\begin{align*}
		\text{Then,} \tab OPT' & = \sum_{u \in \UU'}\Bigl\lfloor\frac{\alpha_u}{\mu}\Bigr\rfloor\\
		& \leq \frac{1}{\mu}\sum_{u \in \UU'} \alpha_u \text{,\quad since ~} x\geq\lfloor x \rfloor ~\forall ~ x\in\mathbb{R}\\
		& \leq \frac{1}{\mu}OPT\\
		& = \frac{n*OPT}{\epsilon*greedy\_path} \quad \text{[ from equation \ref{eq5} ]} \\
		& \leq \frac{n}{\epsilon} *\frac{n(n-1)}{2} \quad \text{[ from equation \ref{eq2} ]}\\
		& = \frac{n^2 (n-1)}{2\epsilon}
	\end{align*}
	So, from the equation \ref{eq3}, the running time of the FPTAS Algorithm for $I'$ is $ 2^{k\log k}\cdot n^{\mathcal{O}(1)}\cdot\frac{n^2 (n-1)}{2\epsilon} = \frac{1}{2\epsilon}2^{k\log k}\cdot n^{\mathcal{O}(1)}$, which
	is polynomial in $n$ and $1/ \epsilon$. \\
	\noindent
	Now, we want to prove that a solution $\sum_{\substack{u\in \UU'\\ }}{\alpha_u}$ produced by the FPTAS Algorithm must be at least $ (1-\epsilon) OPT$. 
	\begin{align*}
		\text{Now,\quad}\sum_{i\in \UU'}\frac{\alpha_u}{\mu} & \geq \sum_{u \in \UU'}\Bigl\lfloor\frac{\alpha_u}{\mu}\Bigr\rfloor \text{,\quad since ~} x\geq\lfloor x \rfloor ~\forall ~ x\in\mathbb{R} \\
		& \geq \sum_{u \in \UU}\Bigl\lfloor\frac{\alpha_u}{\mu}\Bigr\rfloor \text{,\quad since ~ \UU' is optimal}\\	
		& \geq \sum_{u \in \UU}\Bigl(\frac{\alpha_u}{\mu} -1\Bigr) \text{,\quad since ~} \lfloor x \rfloor \geq x-1 ~\forall ~ x\in\mathbb{R} 
	\end{align*}
	After multiplication of $\mu$ on both sides, we get;
	\begin{align*}
		\sum_{i\in \UU'} \alpha_u & \geq \sum_{i\in \UU} \alpha_u - \mu|\UU|\\
		& \geq OPT - n\mu
	\end{align*}
	\begin{align*}
		\text{So,} \qquad ALG &= \sum_{i\in \UU'} \alpha_u\\
		& \geq OPT - n\mu\\
		& = OPT - \epsilon* greedy\_path\\
		& \geq OPT -\epsilon* OPT \quad \text{[ from equation \ref{eq1} ]}\\
		& \geq (1-\epsilon)OPT
	\end{align*}
	This completes the proof.
\end{proof}
}




\begin{comment}
	content...


	\begin{Algorithms}[h]
		\caption{$\textbf{\pa}$ ($T$, $(r_u)_{u\in\VV}$, $(\alpha_u)_{u\in\VV}$, $x$, $r_a$, $n$)}\label{algo_Atpr}
		\begin{algorithmic}[1]



			\INPUT A tree $\TT=(\VV,\EE)$ rooted at node $x$ contains $n$ number of vertices. Available resource at a node $u$ is $r_u$ and possible damage at $u$ is $\alpha_u$ $\forall$ $u\in\VV$. The attacker initiates an attack at the node $x$ with the attacker's resource $r_a$.

			\OUTPUT Maximum possible damage at $x$.


			\Statex
			%\Procedure{$\textbf{\pa}$}{ $T$, int $r_a$, int $n$, int $resource[]$, int $damage []$}
			\State \Call {$\textbf{FindMaxDamage}$}{$d_x,r_a$};
			\State \textbf{return} $D_x[d_x,r_a]$;
			%\EndProcedure
			%\Statex
			%\Statex
			\algstore{bkbreak}
		\end{algorithmic}
	\end{Algorithms}

	%This algorithm returns the maximum possible damage at node $x$ retrieved from the entry at index $(d_x, r_a)$ of the DP table $D_x$ of $x$ after calling the function \Call {$\textbf{FindMaxDamage}$}{,} where $d_x$ is the maximum degree of $x$. We maintain a DP table $D_u$ for each node $u \in \VV$.\\



	\begin{Algorithms}[h]
		\ContinuedFloat
		%\caption{FindMaxDamage}
		\begin{algorithmic}[1]
			\algrestore{bkbreak}

			\Function{$\textbf{FindMaxDamage}$ }{$d_x, r_a$}

			\If{$ x ~is ~leaf$ }
			\For{$q =0$ to $r_a$}
			\State $D_x[0,q]=$\Call{$\textbf{CalculateValueFor}$}{$0,q$};
			\EndFor
			\Else
			\For{$i =0$ to $d_x$}
			\If{$i!=0$}
			\State \Call {$\textbf{FindMaxDamage}$}{$d\textsubscript{y\textsubscript{i}},r_a$};
			\EndIf
			\For{$p =0$ to $r_a$}
			\State $D_x[i,p]=$\Call{$\textbf{CalculateValueFor}$}{$i,p$};
			\EndFor
			\EndFor
			\EndIf

			\EndFunction

			\algstore{bkbreak}
		\end{algorithmic}
	\end{Algorithms}

	%The \Call {$\textbf{FindMaxDamage}$}{,} procedure works as follows. Line 4 calculates the DP table of $x$ if it is a leaf node. It considers the degree$(x)=d_x$ and the attacker's resource $=r_a$ as parameters. The \textbf{for} loop of lines 4-7 constructs the DP table of the leaf node $x$ by calling the function \Call{$\textbf{CalculateValueFor}$}{,}. The DP table of a leaf node is nothing but a 1-D array. If $x$ is not a leaf node, then lines 8-17 execute and form the DP table $D_x$ of $x$. Here, the DP tables are 2-D arrays of size $(d_x+1 \times r_a+1)$. The \textbf{for} loop of line 9 recursively constructs the DP tables for each child $y_i$ of $x$, where $y_i$ is the $i^{th}$ child of $x$. In other words, the DP tables for all the children of $x$ are constructed before we get the table $D_x$ of $x$. In line 11 recursive call conducted by the\Call {$\textbf{FindMaxDamage}$}{,} with the maximum degree of $y_i$ which we represent as $d\textsubscript{y\textsubscript{i}}$. DP tables are filled by calling the function \Call{$\textbf{CalculateValueFor}$}{,} in line 14.



	\begin{Algorithms}[h]
		\ContinuedFloat
		%\caption{CalculateValueFor}
		\begin{algorithmic}[1]
			\algrestore{bkbreak}

			\Function{$\textbf{CalculateValueFor}$ }{$i, p$}

			\If{$i=0$ }
			\If{$p-r_x>=0$}
			\State \textbf{return} $\alpha_x$;
			\Else
			\State \textbf{return} $0$;
			\EndIf
			\Else
			\If{$p-r_x>=0$}
			\State \textbf{return} $\max_{0\leq k\leq p-r_x}\{D\textsubscript{y\textsubscript{i}}[d\textsubscript{y\textsubscript{i}},k]+D_x[i-1,p-k]\}$;
			\Else
			\State \textbf{return} $0$;
			\EndIf
			\EndIf


			\EndFunction

		\end{algorithmic}
	\end{Algorithms}




	This algorithm returns the maximum possible damage at node $x$ retrieved from the entry at index $(d_x, r_a)$ of the DP table $D_x$ of $x$ after calling the function \Call {$\textbf{FindMaxDamage}$}{,} where $d_x$ is the maximum degree of $x$. We maintain a DP table $D_u$ for each node $u \in \VV$.\\

	The \Call {$\textbf{FindMaxDamage}$}{,} procedure works as follows. Line 4 calculates the DP table of $x$ if it is a leaf node. It considers the degree$(x)=d_x$ and the attacker's resource $=r_a$ as parameters. The \textbf{for} loop of lines 4-7 constructs the DP table of the leaf node $x$ by calling the function \Call{$\textbf{CalculateValueFor}$}{,}. The DP table of a leaf node is nothing but a 1-D array. If $x$ is not a leaf node, then lines 8-17 execute and form the DP table $D_x$ of $x$. Here, the DP tables are 2-D arrays of size $(d_x+1 \times r_a+1)$. The \textbf{for} loop of line 9 recursively constructs the DP tables for each child $y_i$ of $x$, where $y_i$ is the $i^{th}$ child of $x$. In other words, the DP tables for all the children of $x$ are constructed before we get the table $D_x$ of $x$. In line 11 recursive call conducted by the \Call {$\textbf{FindMaxDamage}$}{,} with the maximum degree of $y_i$ which we represent as $d\textsubscript{y\textsubscript{i}}$. DP tables are filled by calling the function \Call{$\textbf{CalculateValueFor}$}{,} in line 14.\\

	The \Call{$\textbf{CalculateValueFor}$}{,} procedure calculates the maximum possible damage if the attacker attacks with $p$ amount of resource at a node $x$ that currently consists of $i$ number of children. Lines 20-25 execute if $i=0$; that is when we consider $x$ does not have any child. At this time, the maximum damage possible at $x$ is $\alpha_x$ if it has defending-resource $r_x \leq p$; otherwise, the maximum damage is $0$. If $i \neq 0$, i.e., $x$ has at least one child to at most $d_x$ number of children, then lines 26-32 execute. Line 28 calculates maximum damage if we add the $i^{th}$ child $y_i$ of $x$ with $k$ amount of resource, into the solution of the previous row of $D_x$ where the resource amount is $k-1$. We vary $k$ from $0$ to $p-r_x$. This line 28 executes if defending resource $r_x $ of $x$ is $\leq p$; otherwise, the function returns $0$.


\end{comment}
\begin{comment}

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed

	% Figure environment removed
\end{comment}