
\section{Introduction}

The \kp problem is one of the most well-studied problems in computer science~\cite{CacchianiILM22,cacchiani2022knapsack,kellerer2004multidimensional,martello1990knapsack}. Here, we are given a set of $n$ items with corresponding sizes $w_1,\ldots,w_n$ and values $\alpha_1,\ldots,\alpha_n$, the size (aka budget) $s$ of the bag, and the goal is to compute a subset of items whose total value is as high as possible and total size is at most $s$. 

Often there exist natural graph structures on the set of items in the \kp problem, and we want the solution to satisfy some graph theoretic constraint also. For example, suppose a company wants to lease a set of mobile towers, each of which comes at a specific cost with a specific number of customers. The company has a budget and wants to serve the maximum number of customers. However, every mobile tower is in the range of some but not all the other towers. The company wants to provide fast connection between every pair of its customers, which is possible only if they are connected via other intermediary towers of the company. Here we have a natural graph structure --- the vertices are the towers, and we have an edge between two vertices if they are in the range of one another. In this situation, the company wants to lease a connected subset of towers which has the maximum total number of customers (to maximize its earning) subject to its budget constraint. We call this problem \pa.

Now, let us consider another application scenario where there is a railway network and a company wants to lease a railway path between station A and station B, maybe via other stations, to operate train services between them. Suppose the cost model puts a price tag on every station, and the links between two stations are complementary if the company owns both the stations. Each station also allows the owner to earn revenues from advertisement, etc. In this scenario, the company would like to lease from the entire railway network a path between stations A and B whose total revenues are as high as possible, subject to a budget constraint. We call this problem \pathknapsack. If the company's primary goal is to provide the fastest connectivity between A and B, then the company wants to lease a shortest path between A and B, whose total revenues are as high as possible, subject to a budget constraint. We study this problem also under the name \shortestpathknapsack. The formal definitions of the above problems are in Section~\ref{sec:prelim}.

% A graph $\GG=(\VV,\EE)$ is given with $n$ number of nodes and $m$ number of edges. Every vertex has some defending requirements $r_u$ and possible damage $\alpha_u$. The attacker has some power $r_a$ that he can attack a node with $r_a$ amount of tolerance. Due to the attack, the defending power of a node decreases, and the attacker's power also decreases after the successful attack.
% In this problem, the attacker's goal is to attack a node to cause maximum damage with the attacker's resource $r_a$ so that attack can spread to as many connected nodes as possible. The defender tries to defend that node by allocating resources to minimize damage.

% \subsection{Motivation for \conknapsack}
% \begin{itemize}
% 	\item[\ding{70}] In real-world scenarios, the attacker can spread malware in a computer network to cause damage. The hacker can enter any corporate environment with vital information (e.g., credit card details, IP addresses, or connections to any corporate server) stored in a hacked system (e.g., a business computer). In this way, the attack spreads in a chain to the other connected nodes of an infected node.\\

% 	\item[\ding{70}] Consider a scenario of a terrorist attack; terrorists use fire or gases in a specific area to attack. Wind can spread the fire from the affected target region to the neighboring areas. Due to the attack, the damage was caused in the surrounding areas where the attack spread out, and that must be bounded within a connected region.\\

% 	\item[\ding{70}] Another real-world application of our problem is the spreading of an infectious disease. The virus spreads to a person if he/she comes into contact with infected people. So, the spreading of a virus always follows a connected way of fashion. \\

	%\item[\LARGE $\diamond$] There are other examples where an attack may not spread within connected nodes. For instance, during a bank robbery may not choose the nearest banks to attack after their first attack. The robber only selects those banks whose security potential is vulnerable.

% \end{itemize}

% \subsection{Motivation for \pathknapsack}
% \begin{itemize}
% 	\item[\ding{70}] In urban areas, there are many bank branches, and during a bank robbery, a robber preferably chooses those branches with large escape paths from that bank to his safe shelter to avoid being captured. He strategically chooses a path from the source to the destination based on the constraints like his driving speed and time-dependent traffic conditions through the network.
% \end{itemize}

% \subsection{Motivation for \consepknapsack}

% \subsection{Motivation for \indpsetknapsack}

\subsection{Contribution}

We study the computational complexity of \pa, \pathknapsack, and \shortestpathknapsack under the lens of parameterized complexity as well as approximation algorithms. We consider the treewidth of the underlying graph and the vertex cover size of the solution as our parameters. We note that both the parameters are well known to be small for many graphs appearing in various real-world applications. We summarize our results in \Cref{tbl:summary}.

\begin{table}
	\begin{center}
		\begin{tabular}{|c|c|}\hline
  
		\scriptsize \conknapsack & \makecell{\scriptsize Strongly \NPC even if max degree is $4$ [\Cref{thm:pa-gen-npc}]\\\scriptsize \NPC even for stars [\Cref{thm:pa-star-npc}]\\\scriptsize $2^{\OO(\tw\log\tw)}\cdot\text{poly}(n)\min\{s^2,d^2\}^{\dagger^\star}$ [\Cref{thm:treewidth-pa}]\\\scriptsize $2^{\OO(\tw\log\tw)}\cdot\text{poly}(n,1/\eps)^\dagger$ time, $(1-\eps)$ approximation [\Cref{thm-fptas}]\\\scriptsize No $\OO(f(vcs).\text{poly}(n,s,d)$ algorithm unless \ETH fails$^\ddagger$ 
[\Cref{thm:vcs-woh}].} \\\hline

		\scriptsize \pathknapsack & \makecell{\scriptsize Strongly \NPC even if max degree is $3$ [\Cref{thm:path-gen-npc}]\\\scriptsize  \NPC for graphs with pathwidth 2 [\Cref{thm:pk-pathwidth}]\\\scriptsize Polynomial-time algorithm for trees [\Cref{obs:pk-tree-poly}]\\\scriptsize $2^{\OO(\tw\log\tw)}\cdot\text{poly}(\min\{s^2,d^2\})^{\dagger^\star}$ [\Cref{thm:treewidth-path}]\\\scriptsize $2^{\OO(\tw\log\tw)}\cdot\text{poly}(n,1/\eps)^\dagger$ time, $(1-\eps)$ approximation [\Cref{thm-fptas-path}]\\\scriptsize $\OO\left((2e)^{2vcs} vcs^{\OO(\log vcs)}n^{\OO(1)}\right)^\ddagger$ time algorithm [\Cref{cor:vcs-path}].} \\\hline
   
			 \scriptsize \shortestpathknapsack & \makecell{\scriptsize \NPC for graphs with pathwidth 2 [\Cref{cor:shortest-pathwidth}]\\\scriptsize $\OO(n\log n\cdot\min\{s^2,(\alpha(\VV))^2\})$ time algorithm [\Cref{thm:shortest-algo}]\\ \scriptsize Polynomial-time algorithm for trees [\Cref{obs:shortest-tree-poly}]\\\scriptsize $(1-\eps)$ approximation in $\text{poly}(n,1/\eps)$ time [\Cref{thm-fptas-shortest-path}].}\\\hline
    
			 % \indpsetknapsack & \makecell{Strongly \NPC [\Cref{thm:ind}]\\$\OO\left(2^{\tw}\cdot\text{poly}(\min\{s,d\})\right)^{\dagger^\star}$ [\Cref{thm:treewidth-indset}]\\$\OO\left(2^{\tw}\cdot\text{poly}(n,1/\eps)\right)^\dagger$ time, $(1-\eps)$ approximation [\Cref{thm-fptas-indset}]\\\WOH parameterized by $k^{\star\star}$ [\Cref{obs:ind-woh}].} \\\hline
    
		\end{tabular}
  \caption{Summary of results. $\dagger: \tw$ is the treewidth of the input graph; $\star: s$ and $d$ are respectively target size and target profit; $\ddagger: vcs$ is the size of the minimum vertex cover of the subgraph induced by the solution; $\star\star: k$ is the number of vertices in the solution; $\alpha(\VV)=\sum_{v\in\VV}\alpha(v)$ where $\alpha(v)$ is the value of the vertex $v$ in \VV.}	
  \label{tbl:summary}
	\end{center}
\end{table}



We observe that all our problems admit fixed-parameter pseudo-polynomial time algorithms with respect to the treewidth of the graph. Further, all the problems admit an FPTAS for graphs with small (at most $\OO(\log n)$) treewidth. Our results seem to indicate that \shortestpathknapsack is computationally the easiest, followed by \pathknapsack and \pa.

\subsection{Related Work}
To the best of our knowledge, Yamada et al.~\cite{yamada2002heuristic} initiated the study of the \kp problem with a graph structure on the items (which they called conflict graph), where the goal is to compute an independent set which has the maximum total value and satisfies the budget constraint. The paper proposes a set of heuristics and upper bounds based on Lagrangean relaxation. Later, Hifi and Michrafy~\cite{hifi2006reactive,hifi2007reduction} designed a meta-heuristic approach using reactive local search techniques for the problem. Pferschy and Schauer~\cite{PferschyS09} showed that this problem is strongly \NPH and presented FPTAS for some special graph classes. Bettinelli et al.~\cite{BettinelliCM17} proposed a dynamic programming based pruning in a branching based algorithm using the upper bounds proposed by Held et al.~\cite{HeldCS12}. Coniglio et al.~\cite{ConiglioFS21} presented a branch-and-bound type algorithm for the problem. Finally, Luiz et al.~\cite{LuizSU21} proposed a cutting plane based algorithm. Pferschy and Schauer~\cite{PferschyS17}, Gurski and Rehs~\cite{GurskiR19}, and Goebbels et al.~\cite{GoebbelsGK22} showed approximation algorithms for the \kp problem with more sophisticated neighborhood constraints. This problem (and also the variant where the solution should be a clique instead of an independent set) also admits an algorithm running in time $n^{\OO(k)}$ where $k$ is the thinness of the input graph~\cite{DBLP:journals/dam/BonomoE19,DBLP:journals/orl/ManninoORC07}.


Ito et al.~\cite{ito2008approximability} studied FPTASes for a generalized version of our problems, called the {\sc Maximum partition} problem but on a specialized graph class, namely the class of series-parallel graphs. Although their work mentions that their results can be extended to bounded treewidth graphs, the authors state that the algorithmic techniques for that is more complex but do not explain the techniques. To the best of our knowledge, there is no follow-up work where the techniques for bounded treewidth graphs are explained.

Bonomo-Braberman and Gonzalez~\cite{DBLP:journals/dam/Bonomo-Braberman22b} studied a general framework for, which they called "locally checkable problems", which can be used to obtain FPT algorithms for all our problems parameterized by treewidth. However, the running time of these algorithms obtained by their framework is worse than our algorithms parameterized by treewidth.

There are many other generalizations of the basic \kp problem which have been studied extensively in the literature. We refer to \cite{CacchianiILM22,cacchiani2022knapsack,kellerer2004multidimensional,martello1990knapsack} for an overview.
