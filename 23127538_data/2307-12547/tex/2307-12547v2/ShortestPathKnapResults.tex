\section{\shortestpathknapsack}

We now consider \shortestpathknapsack. We observe that all the $u$ to $v$ paths in the reduced instance of \pathknapsack in the proof of \Cref{thm:pk-pathwidth} are of the same length. Hence, we immediately obtain the following result as a corollary of \Cref{thm:pk-pathwidth}.

\begin{corollary}\label{cor:shortest-pathwidth}
\shortestpathknapsack is \NPC even for graphs of pathwidth at most two and the weight of every edge is one. In particular, \shortestpathknapsack is \PNPH parameterized by pathwidth.
\end{corollary}

Interestingly, \shortestpathknapsack admits a pseudo-polynomial-time algorithm for any graph unlike \pa and \pathknapsack.

\begin{theorem}\label{thm:shortest-algo}
There is an algorithm for \shortestpathknapsack running in time $\OO(n\log n\cdot\min\{s^2,(\alpha(\VV))^2\})$, where $\GG=(\VV,\EE)$ is the input graph.
\end{theorem}

\begin{proof}
Let $(\GG=(\VV,\EE),(c(e))_{e\in\EE},(w(u))_{u\in\VV},(\alpha(u))_{u\in\VV},s,d,x,y)$ be an arbitrary instance of \shortestpathknapsack. We design a greedy and dynamic-programming based algorithm. For every vertex $v\in \VV$, we store a boolean marker $b_v$, the distance $\delta_v$ of $v$ from $x$ and a set $D_v=\{(w,\alpha):\exists$ an $x$ to $v$ shortest-path \PP such that $w(\PP)=w, \alpha(\PP)=\alpha$ and for every other $x$ to $v$ shortest-path \QQ, we have either $w(\QQ)>w$ or $\alpha(\QQ)<\alpha\}$. That is, we store undominated weight-value pairs of all shortest $x$ to $v$ paths. We initialize $b_x=\false, \delta_x=0, D_x=\{(w(x),\alpha(x)\}, b_u=\false, \delta_u=\infty,$ and $ D_u=\emptyset$ for every $u\in\VV\setminus\{x\}$.

Updating DP table: We pick a vertex $z=\argmin_{v\in\VV:b_v=\false}\delta_v$. We set $b_z=\true$. For every neighbor $u$ of $z$, we set $\delta_u=\min\{\delta_u,\delta_z+c(\{z,u\})\}$. If $\delta_u=\delta_z+c(\{z,u\})$, then update $D_u$ as follows: for every $(w,\alpha)\in D_z$, we put $(w+w(u),\alpha+\alpha(u))$ in $D_u$ if $w+w(u)\le s$; and we finally remove all dominated pairs from $D_u$ just before finishing each iteration. If we have $b_v=\true$ for every vertex, then we output \yes if there exists a pair $(w,\alpha)\in D_y$ such that $w\le s$ and $\alpha\ge d$. Else, we output \no.

We now argue the correctness of our algorithm. Following the proof of correctness of the classical Dijkstra's shortest path algorithm, we observe that if $b_v$ is $\true$ for any vertex $v\in\VV$, its distance from $x$ is $\delta_v$~\cite{DBLP:books/daglib/0023376}. We claim that at the end of updating a table entry in every iteration, the following invariant holds: for every vertex $v\in\VV$ such that $b_v=\true$ and every $x$ to $v$ undominated shortest path $\PP$ using only vertices marked $\true$, we have $(w(\PP),\alpha(\PP))\in D_v$. The invariant holds vacuously after initialization since every vertex is marked $\false$. Let us assume that the invariant hold after $i$ iterations; $\VV_T$ be the set of vertices which are marked $\true$ after $i$ iterations. Suppose the algorithm picks the vertex $z_{i+1}$ in the $(i+1)$-th iteration. Let $\PP^*=x,\ldots,y,z_{i+1}$ be an undominated $x$ to $z_{i+1}$ shortest path using the vertices marked $\true$ only. Then we claim that the prefix of the path $\PP^*$ from $x$ to $y$, let us call it $\QQ=x,\ldots,y$, is an undominated $x$ to $y$ shortest path. That $\QQ$ is a shortest path from $x$ to $y$ follows from standard proof of correctness of Dijkstra's algorithm~\cite{DBLP:books/daglib/0023376}. Now, to show that $\QQ$ is undominated, let us assume that another shortest path $\RR$ from $x$ to $y$ dominates $\QQ$. Then the shortest path $\RR^\pr$ from $x$ to $z_{i+1}$ which is $\RR$ followed by $z_{i+1}$ also dominates $\PP^*$ contradicting our assumption that $\PP^*$ is an undominated shortest path from $x$ to $z_{i+1}$. Hence, the pair $(w(\PP^*),\alpha(\PP^*))$ is put in $D_{z_{i+1}}$ in the $(i+1)$-th iteration. And since the algorithm only removes dominated pairs in every iteration, the pair $(w(\PP^*),\alpha(\PP^*))$ remains in $D_{z_{i+1}}$ after the end of $(i+1)$-th iteration also. This proves that the invariant holds after $(i+1)$-th iteration also, and thus the correctness of the algorithm. For every vertex $v\in\VV$, the cardinality of $D_v$ is at most $s$ and also at most $\alpha(\VV)$ and thus at most $\min\{s,\alpha(\VV)\}$. Implementing the above algorithm using a standard Fibonacci heap-based priority queue to find $\argmin_{v\in\VV:b_v=\false}\delta_v$ gives us a running time $\OO(n\log n\cdot\min\{s^2,(\alpha(\VV))^2\})$.
\end{proof}

Clearly, \shortestpathknapsack admits a polynomial-time algorithm for trees since only one path exists between every two vertices.

\begin{observation}\label{obs:shortest-tree-poly}
\shortestpathknapsack is in \Pb for trees.
\end{observation}

Using the technique in \Cref{thm-fptas}, we use \Cref{thm:shortest-algo} as a black-box to obtain the following approximation algorithm. We again omit its proof due to its similarity with \Cref{thm-fptas}.


\begin{theorem}\label{thm-fptas-shortest-path}
There is a $\text{poly}(n,1/\eps)$ time, $(1-\eps)$ factor approximation algorithm for \shortestpathknapsack for optimizing the value of the solution.
\end{theorem}