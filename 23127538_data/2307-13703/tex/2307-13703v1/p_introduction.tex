\section{Introduction}
In industrial automation, Programmable Logic Controllers (PLC) are widely used. To design the control code running on a PLC, a beneficial approach is to use formal means in order to first specify the logical behavior of the PLC before implementing the control code \cite{Schumacher.13b}. 
Using a formal specification in the design phase has multiple advantages like using the specification as documentation and communication tool, allowing an automatic transformation into control code and applying formal verification at specification level \cite{Julius.19}. 

In this context, IEC 60848 GRAFCET \cite{iec60848} can be used as a description means. 
GRAFCET is a graphical, semi-formal, domain-specific language to model, e.g., control code of PLCs.
GRAFCET is used in several industrial domains like railway transport and the manufacturing industry and is widely known in the respective areas \cite{Provost.11}. This acceptance of GRAFCET might improve the acceptance of formal methods in the respective domains, which is still a problem \cite{VogelHeuser.14}.
Although GRAFCET adapts concepts of Petri nets -~like transitions and steps, connected alternately by arcs~- it provides a considerable number of additional modeling mechanisms like hierarchical structuring of the specification which allow for compact modeling of complex systems \cite{Mross.22}. 
Regarding the application of formal methods to GRAFCET specifications, there is preliminary work by Julius et al. \cite{Julius.17} to allow a code generation of such hierarchical GRAFCET specifications to PLC-code.
Because the work presented by Julius et al. does not cover verification of the Grafcets (the term \textit{Grafcet} refers to an instance of GRAFCET), we extend the approach with formal verification.
A verification on specification level has the advantage of finding possible design errors early in the design process, given that the costs of correcting errors in software systems increases exponentially as the development phase progresses \cite{Boehm.1981}.

%was haben wir vor:
The verification approach proposed in this work is a structural analysis that approximates the variable values of GRAFCET and takes elements into account proposed by the standard that result in concurrent behavior. 
The term \textit{structural analysis} originally refers to a type of verification of Petri nets that uses algebraic tools that do not require to build the reachability graph \cite{Cabasino.13}, resulting in a linear relaxation of the reachability graph. Similarly, the structural analysis of GRAFCET proposed in this work approximates the GRAFCET behavior using, among others, a linear relaxation. Further, the structural analysis of GRAFCET is performed on the basis of its structure, i.e., how the steps and transitions are connected by arcs. It does not take into account its transition conditions and, therefore, not the internal variables. Hence, structural analysis is a subtype of static analysis, which in general approximates the states of a program and therefore, its behavior without executing it \cite{Praehofer.12}.
The structural analysis proposed in this work is able to approximate the reachability and concurrency of steps as well as the values of output variables. This information can be used to identify safety critical situations or possible race conditions. The resulting over-approximation leads to the fact that false alarms can take place.

We will compare the proposed approach to other possible approaches in Sec.~\ref{sec:relWork}, followed by the preliminaries in Sec.~\ref{sec:prelim} on GRAFCET and on analysis means from the field of Petri nets that are applied to GRAFCET in Sec.~\ref{ssec:flowinsens}.  
In Sec.~\ref{sec:contribution} we point out why concurrent structures are challenging (Sec.~\ref{ssec:problem}) and present an approach that is twofold: In Sec.~\ref{ssec:stepApprox} we present an algorithm that calculates reachable and concurrent steps and, therefore, approximates the values of step variables. In Sec.~\ref{ssec:flowinsens} we present an analysis using means from the field of Petri nets to obtain information about how often actions can be executed to approximate the values of internal and output variables.
We end with evaluating the proposed analysis on a practical example (Sec.~\ref{sec:eval}) before giving a conclusion (Sec.~\ref{sec:conclusion}).