
\section{Structural analysis of GRAFCET}
\label{sec:contribution}
A static analysis of GRAFCET based on its control flow without building the state space or part of it is challenging since concurrent actions can change the global variable values, but the concurrency is not directly visible from an arbitrary point in the control flow.
%To approach this challenge we first consider the different elements in GRAFCET resulting in concurrent behavior in Sec. \ref{ssec:problem}, before we present a structural analysis of GRAFCET that identifies concurrent steps based on the control flow in Sec.~\ref{ssec:stepApprox}.
To approach this challenge, we first consider the different elements in GRAFCET resulting in concurrent behavior in Sec. \ref{ssec:problem}, before we present a structural analysis of GRAFCET in Sec.~\ref{ssec:stepApprox} that identifies concurrent steps along the control flow to make the concurrency visible at arbitrary points in the control flow.
In Sec.~\ref{ssec:flowinsens} we present an analysis that approximates the internal and output variable values taking the concurrent behavior into account.

\subsection{Problem definition for the structural analysis of GRAFCET}
\label{ssec:problem}

%control flow
Before applying a control flow based analysis we need to define the control flow of GRAFCET.
In GRAFCET, instructions that read variable values are connected to conditions associated with transitions, %(neglecting conditional actions for a moment) 
and instructions that write variable values are connected to actions associated with steps. Therefore, the statements of the control flow correspond to steps and transitions which are connected by arcs forming the flow relations (in Sec.~\ref{ssec:syntax} formalized via $\bullet t$ and $t \bullet$).
This relation we want to use to analyze the behavior of the GRAFCET.
Besides the arcs, Grafcets can have additional flow relations induced by hierarchical elements like enclosing steps and forcing orders. Those relations are always between different partial Grafcets.

In comparison to sequential programs (i.e., programs written for example in C running on
a single thread) statements of the Grafcet's control flow can be executed concurrent to each other. This is a problem when the statements depend on each other and their execution order is non-deterministic. Particularly steps can be activated in parallel and their associated actions are executed concurrently in a non-deterministic order due to changes of input variables. 
An example of two such actions could be the execution of the value assignments $x := 0$ and $x := x +1$ where the execution order has an influence on the resulting value of $x$.
Therefore, analysis means from the field of sequential programs are not applicable to GRAFCET.

The GRAFCET standard \cite{iec60848} presents different structures resulting in concurrent behavior as shown in the partial Grafcets G1 to G8 in Fig. \ref{fig:concurrentStructures}:
\begin{itemize}
	\item Multiple conditional actions (graphically represented by a flag, followed by an expression like $\uparrow\! x$, where $\uparrow$ is called a rising edge of $x$ and occurs when $x$ changes from 0 to 1) associated to a single step (G1)
	\item Multiple initially active steps in a sequence (G2) or in parallel (G3)
	\item Elements producing active steps like source transitions ($\bullet t = \emptyset$ in G5) or its equivalence using an activation of parallel sequences (G4) as introduced by the standard \cite{iec60848}
	\item Activation of parallel sequences activating multiple steps at the same time ($|{t \bullet}| > 1$ in G6)
	\item Concurrently activated partial Grafcets (G7 and G8)   
\end{itemize}
All these structures can result in a non-deterministic firing order of transitions and a non-deterministic execution order of actions. The latter is indicated in Fig. \ref{fig:concurrentStructures} by actions $a$ and $b$ in concurrent parts of the Grafcet. 
Only the last structure containing G7 and G8 occurs in relation to a hierarchical structuring indicated by the Global Grafcet notation enclosing the partial Grafcets G7 and G8. 

%%Häufigkeit
Besides the fact that the order of firings and executions is non-deterministic, their number of executions (i.e., how often a transition or action is executed) is non-deterministic as well. 
%With number of execution we mean how often a transition or action is executed. 
E.g., source transitions can non-deterministically generate multiple active steps in a subsequent sequence due to the non-deterministic change of input variables. Structures like shown in G4 in Fig.~\ref{fig:concurrentStructures} have a similar behavior.\\


%======================================
%======================================
\subsection{Analysis of the reachability and concurrency of steps}
\label{ssec:stepApprox}
To analyze the presented behavior of GRAFCET, we propose an algorithm (in which $A \triangleleft B$ is short for $A \leftarrow A \cup B$) 
that approximates the reachability (Alg. \ref{alg:reachabilility}) and concurrency (Alg. \ref{alg:concurrency}) of steps. 
Both algorithms only take the structure of the Grafcet into account, i.e., assuming the transition conditions evaluate to true. % by approximating every internal variable by the $[- \infty, \infty]$ interval. 
Because of this approximation, the analysis is independent of variable values affected by potential race conditions which allows to take the concurrent elements of GRAFCET into account.


\begin{algorithm}[H]
	\caption{Analysis of reachable steps}
	\label{alg:reachabilility}
	\begin{algorithmic}[1]
		\Function{ReachAnalysis}{initial Worklist $W$, partial Grafcet $c \in C$, initially concurrent steps $\mathcal{S}$}
		\While {$\exists t \in W$}% \neq \emptyset$}
		\State $W \leftarrow W\backslash \{t\}$
		\State $\mathcal{S'} \leftarrow \mathcal{S}$
		
		\If {$s' \in S^R$ holds for all $s' \in {\bullet t}$}
		\ForAll{$s \in t \bullet$}
		\If {$s \notin S^R$}
		\State $S^R \triangleleft \{s\} $
		\State $W \triangleleft {s \bullet}$
		\EndIf
		\State $\mathcal{S}\, \triangleleft\,$\textsc{ConcurrAnalysis}$(c,$ $\mathcal{S}, t, s)$
		\EndFor
		\EndIf
		\ForAll{$s'' \in S_c$}
		\If {${S^C_{s''}}'\in\mathcal{S'}  \not =S^C_{s''}\in\mathcal{S}$}
		\State $W \triangleleft s''\bullet$
		\EndIf
		\EndFor
		\EndWhile
		\State \textbf{return} $S^R, \mathcal{S}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}

% ========= Reachability analysis ========
To analyze the reachable steps, we propose a worklist algorithm, presented in Alg. \ref{alg:reachabilility}. The algorithm  analyzes the flow along the transitions and calculates a set $S^R \subseteq S_c$ of reachable steps for a given partial Grafcet $c \in C$ and its initial situation $S^I \subseteq S_c$ which will be defined in a moment. 
For a transition $t$ from the worklist the algorithm examines if all upstream steps $s' \in \bullet t$ are reachable (line 5).  
This is an over-approximation of a transition being enabled. The downstream steps $ s \in t \bullet$ are marked as reachable and in turn their downstream transitions $s \bullet$ are put on the worklist until the analysis stabilizes. For every step $s$ that is reached this way we calculate its concurrent steps $S^C_s$ using \textsc{ConcurrAnalysis} which is discussed below. Since the sets of concurrent steps $\mathcal{S}$ can still change after the respective steps are marked as reachable, the stabilization has a second criteria: If the algorithm calculates additional concurrent steps $S_{s''}^C$ to a step $s''$ its downstream transitions are put on the worklist (line 11-13) to propagate them along the transitions as discussed below.



%============ hierarchical dependencies =========
The initialization of $W$ covers the control flow caused by enclosing steps and forcing orders.
As presented in \cite{Lesage.93}, hierarchical dependencies form a partial order. Each of these dependencies yields an initial situation $S^I \subseteq S_c$ in the inferior partial Grafcet $c$. Therefore, every partial Grafcet might have multiple initial situations $S^I$: initial steps induce $S^I \leftarrow I_c$, for enclosings the initial situation are the steps activated by the enclosing step ($S^I \leftarrow M_c$) and for forcings the initial situation is the situation that is enforced by the forcing order ($S^I \leftarrow S_a$ which holds for all $a \in A_\mathit{fo}$ and $S_a \subseteq S_c$).
The worklist is initialized with the initially enabled transitions which are the downstream transitions $s\bullet$ of the initially active steps ($W \leftarrow \{s\!\bullet | s\in S^I\}$). 

\begin{algorithm}[H]
	\caption{Analysis of concurrent steps}
	\label{alg:concurrency}
	\begin{algorithmic}[1]
		\Function{ConcurrAnalysis}{partial Grafcet $c$, set of concurrent steps for every step $\mathcal{S}=\{S_s^C\}_{s \in S_c}$, current transition $t$, current step $s \in t \bullet$}
		\State $S_s^C \triangleleft {t\bullet} \backslash \{s\} $
		\State $S_s^C \triangleleft \bigcap_{s' \in \bullet t} S_{s'}^C$
		\ForAll {$s'' \in S^C_s$}
		\State $S_{s''}^C \triangleleft \{s\}$
		\EndFor		
		\State \textbf{return} $\mathcal{S}$
		\EndFunction
	\end{algorithmic}
\end{algorithm}
% Figure environment removed
% Figure environment removed


% ============ Concurrency analysis ===========
To analyze concurrent steps, we extend Alg.~\ref{alg:reachabilility} by Alg.~\ref{alg:concurrency}. It calculates for every step $s \in S_c$ a set $S^C_s$ of steps concurrent to $s$ called $\mathcal{S} = \{S_s^C\}_{s \in S_c}$. The basic assumption is that the downstream steps $t \bullet$ of a transition $t$ have the same concurrent steps as the upstream steps $\bullet t$. This is true for basic sequences without activation of parallel sequences like e.g., in G6 in Fig.~\ref{fig:concurrentStructures}.  
When a parallel sequence is activated (i.e., $|t\!\bullet\!| > 1$) all downstream steps $s \in t \bullet$ become concurrent to each other (line 2). With synchronizations (i.e., $|\!\bullet\! t| > 1$) the opposite is the case. Therefore, in line 3 we intersect the concurrent steps $S^C_{s'}$ of the upstream steps $s' \in \bullet t$ of $t$. This propagates the concurrent steps along the transitions except for synchronized steps. 
Since concurrency is a symmetric relation, the algorithm adds the current step $s$ to all its concurrent steps $s''$ in lines 4 - 5.

To initialize the concurrency analysis, we set all initially active steps concurrent to each other ($S_s^C \leftarrow S^I \backslash \{s\}$ if $s \in S^I$, $\emptyset$ otherwise).

Source transitions are a special case since they can activate the downstream steps concurrently to all other active steps in every possible situation. To model this behavior we calculate $S^R$ as presented above and run Alg. \ref{alg:reachabilility} again with an initial $\mathcal{S}$ that represents this behavior (i.e., $S_s^C \triangleleft S^R$ if $s$ is a downstream step of a source transition).




To illustrate the algorithm, cf. Fig. \ref{fig:exampleconcurrencyalg}, with an initial situation $S^I = \{s3, s4, s5\}$ indicated by the black dots induced, e.g., by a forcing order. Therefore, we initialize $W \leftarrow \{t3, t4\}$ and $\mathcal{S} \leftarrow \{S_{s1}^C, \dotsb, S_{s6}^C \}$, where $S_{s3}^C = \{s4, s5\}, S_{s4}^C = \{s3, s5\}, S_{s5}^C = \{s3, s4\}$ and $S_{s1}^C = S_{s2}^C = S_{s6}^C = \emptyset$. Assuming we withdraw $t = t4$ from the worklist in the first iteration of Alg. \ref{alg:reachabilility}, we mark $s = s6$ as reachable in line 8. Executing Alg. \ref{alg:concurrency} we have $\mathbin{t \mathbin{\bullet}} \backslash \{s\} = \emptyset$ and  $\bigcap_{s' \in \bullet t} S_{s'}^C = \{s3, s5\} \cap \{s3, s4\} = \{s3\}$. In line 5 of Alg.~\ref{alg:concurrency} we add $s6$ to $S_{s3}^C$. $t5$ (due to line 9 in Alg. \ref{alg:reachabilility}) and $t3$ (due to line 13 in Alg. \ref{alg:reachabilility}) are added to the worklist and the algorithm iterates along the transitions as long as $\mathcal{S}$ does change. %or a new step is marked as reachable 
This results in values for $\mathcal{S}$ indicated in Fig. \ref{fig:exampleconcurrencyalg} by the sets next to the steps.


%======================================== 
%========================================

\subsection{Approximation of internal variables and conditions} 
\label{ssec:flowinsens}

In the previous Sec.~\ref{ssec:stepApprox}, we proposed an analysis to approximate the step variables of GRAFCET. 
In this section, we propose an analysis to approximate the internal and output variables written by stored actions. 
Fig. \ref{fig:structuralAnalysis} shows an overview of the proposed analysis. To evaluate the variable values, we over-approximate the action's number of executions and assume the order to be non-deterministic. The number of executions is influenced by multiple structural elements of GRAFCET. Those are: 1) source transitions (Fig. \ref{fig:concurrentStructures}, G5) and the equivalent with an activation of parallel sequences (Fig. \ref{fig:concurrentStructures}, G4), 2) loops as well as 3) multiple active steps in a sequence (Fig. \ref{fig:concurrentStructures}, G2). The influence of the different structural elements on how often an action might be executed is covered by the respective steps 1) - 3) of the analysis (cf. Fig.~\ref{fig:structuralAnalysis}).
%resulting in a different number of execution for actions are covered by the respective steps 1) - 3) of the analysis (cf. Fig.~\ref{fig:structuralAnalysis}).

%S-invariants
First, we calculate the S-invariants of the Grafcet. 
If the Grafcet is covered with S-invariants (i.e., for every step there is at least one S-invariant with a value $n \in \mathbb{N}$ for the corresponding step) it is a sufficient condition that the number of how often a step can be activated is bounded by $n$ (without taking loops and multiple initially active steps into account, which are covered in steps 2) and 3)). 
Otherwise the possible number of the steps' activation is considered to be infinite and therefore, all actions not covered with S-invariants (i.e., there is no S-invariant with a value $n \not= 0$ for the corresponding step $s_a$ of the action $a$) can be executed infinitely often. 
%Otherwise we assume the active steps of the Grafcet to be unbounded, which means that all actions not covered with S-invariants (i.e., there is no S-invariant with a value of 1 for the corresponding step $s_a$ of the action $a$) can be executed infinitely often. 
This detects structures like in G4 (with a S-invariant $\mathbf{y}_{G4} = (1, 0, 0)$ that does not cover steps $2$ and $3$) and G5 (with no existing S-invariant) in Fig. \ref{fig:concurrentStructures}. On the other hand structures like in G6 are covered with S-invariants ($\mathbf{y}_{G6, 1} = (1, 1, 0, 1, 0)$ and $\mathbf{y}_{G6, 2} = (1, 0, 1, 0, 1)$).
%T-invariants
However, even if a Grafcet is $n$-bounded, loops can cause actions to execute infinitely often. Therefore, in the $n$-bounded case we calculate the T-invariants (step 2) in Fig. \ref{fig:structuralAnalysis}) to detect loops to approximate the number of executions further (e.g. the structure in G7, Fig. \ref{fig:concurrentStructures} has a T-invariant $\mathbf{x}_{G7} = (1, 1)$). In case of a loop we assume the associated actions to be executed infinitely often. In step 3) in Fig. \ref{fig:structuralAnalysis} we consider the number of initially active steps $S^I$ that can cause a multiple executions of actions as well. 
If  the actions' number of executions is not infinite it is calculated with $n\cdot |S^I|$.
% Figure environment removed %TODO unten y in ander Klammern
The approach can be illustrated using the partial Grafcet in Fig. \ref{fig:exampleinvariants}. It has one S-invariant $\mathbf{y} = (2, 2, 1, 1, 1)$ and is therefore $n$-bounded with $n = 2$. The partial Grafcet has no T-invariant and therefore, no loop. Due to the two initial steps $1$ and $2$ in combination with the Grafcet being $2$-bounded, step $5$ can be activated four times since $n \cdot |S^I| = 2 \cdot 2 = 4$. Note that a value of $n > 1$ could be considered a design error by itself. 

%calculation of variable values
To calculate the input and output variable values (step 4) in Fig. \ref{fig:structuralAnalysis}) and to take into account the non-deterministic order of the action's execution, we select the order resulting in the largest result to guarantee over-approximation and therefore soundness.
We calculate all possible values $X_{\mathit{calc}}$ for every variable using the number of executions of the corresponding actions identified in the first three steps. Then we choose the minimal and maximal result as lower and upper bound of the variable value's interval or the initialization value zero to approximate the variable value: $[\mathrm{min}(\mathrm{min}(X_{\mathit{calc}}), 0), \mathrm{max}(0, \mathrm{max}(X_{\mathit{calc}}))]$. For the example in Fig. \ref{fig:exampleinvariants} the action on activation associated to step $5$ can be executed four times as shown above. The resulting interval for $k$ evaluates to $[0, 4]$. %TODO: sprachliche Mängel bei "activation of steps is bounded", da mehrfache Schritte nicht einbezogen sind. 

In the end we can check if the conditions in transitions and actions are satisfiable using the approximated internal and step variables.
