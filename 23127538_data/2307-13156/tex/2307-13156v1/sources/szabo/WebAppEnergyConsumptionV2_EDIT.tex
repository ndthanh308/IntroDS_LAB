\begin{abstract}
The aim of this paper is to shortly introduce the need of considering energy consumption when developing dynamic web applications. The underlying problem is presented from the users' point of view, namely that a web page that consumes too much energy might be the main reason of unwanted browser restarts or worse responsibility. Later, similarities and differences to related work are shown to contrast specifics of web applications, in both contexts of development and evolution. Then, we define an example development project using React with Typescript as frontend technology and Tensorflow with Python as backend technology. Energy consumption measurement will be distributed between the Firefox browser running the frontend and PyRAPL library at backend. After the initial measurements based on selected scenarios, we focus on analysis of energy consumption changes caused by directed evolution of the web application. All presented content aims to contribute to the topic of software engineering education by focusing on sustainable software solutions.

\keywords{Energy consumption \and Evolving web applications \and Python \and RAPL \and React \and Typescript.}
\end{abstract}
%
%
%
\section{Motivation}
"Everything is on the Internet" is a very common phrase of the last two decades. All industries consider this medium as the most important one to inform (potential) customers, clients etc. Common types of Internet-based communication include e-mail, chat and web pages. Using amount of information as classification criteria, we could say that web pages aim to provide much more information and functionality than e-mail or chat\cite{similarweb}. Usual implementations often include both chat and e-mail option as a form of one-on-one communication. Current webs offer lots of functionalities in form of rich web applications.

Nowadays, web browsers obviously offer the possibility to open more than one web page at the same time. So, the user does not need to run many browsers. With increasing number of open web pages, memory and CPU load from browsing also increases. Modern web browsers are optimised for a huge number of simultaneously opened pages, but the browser developers used selected webs when they optimised these products\cite{mdntesting}.

Despite this kind of usage focused optimisations, sometimes the users experience browser failures. Opened pages require restart (become slow) due to high resource usage, servers stop responding or more precisely the request is timed out. Mobile devices such as laptops and phones are more sensitive to such intensive resource usage since they are not continuously charged. Servers might have a shorter lifetime under higher workload.

Web pages also have their creators: designers and developers. In a world close to perfect, systematic testing process\cite{mdntesting} is also executed before deployment. Testing can uncover design and implementation weaknesses, but some types of weaknesses are usage specific, which is impossible to completely cover by testing. Users will also report some system failures they experience during application use.

User feedback\cite{swevolutionbook} points to further application improvements. This is what we call evolution of web applications. We have two sides. On the one, there are the users requesting changes, on the other one, there are the developers trying to implement the best improvement.

In this paper, we focus on a kind of web application evolution that is addressing energy consumption optimisation. First, we present related work and tools. Then, we introduce an example project using selected (measurable) technologies\cite{raplzhang,raplinaction}. To improve the measured stats of the example web application, we implement selected evolution techniques. To make it more interesting, we take a look at a different type of evolution: extending functionality; and its impact on the energy consumption profile of the application. Result analysis and what-if discussions will close the teaching class. We only present the process in this paper.

\section{Server/Client-side Green Computing and Evolution}
Web applications usually follow the same architecture. The logic and data of the application are distributed into a number of components, which are also distributed and/or grouped into specific virtual or physical locations\cite{architecture}.

The roles of these system modules are clear: presentation of information, storing underlaying data and implementation of the logic of the application. Logical distribution is much simpler in terms that there are only two parts: the modules run from within the browser (a.k.a. frontend) and everything else (a.k.a. backend). As the application is growing during its evolution, the architecture might be subject of change as well, but there also exist generic architectural patterns preparing the system for long-term evolution that do not require significant changes in the system architecture, such as the microservices' or microfrontends' architecture\cite{architecture}. In all of these architectures, front- and backends are clearly defined. Thus, the architecture comprehension could be minimised to understanding of the historical client/server architecture, considering frontend the client and backend the server.

Evolution of software is necessary\cite{swevolutionbook}. Since there is almost impossible to provide a final software from the first try so that software will not require any further modifications. The literature defines these necessary and/or user-requested modifications as software evolution. Sure, there exist solutions that do not require any improvements after implementation as they are complete and perfect (S-type software by Lehman, perfection is not subject of change over time) or, at least there is no better solution (P-type software by Lehman, where a minimal chance of further one-time modification exists, but that requires progress in theory and practical state of the art).

Majority of software is of E-type, meaning we expect a kind of evolution. This evolution is guided by the feedback from the system usage, which includes direct user feedback, usage data analysis etc. Part of this is profiling in different production environments.

With web applications, the problem of profiling a distributed application raises\cite{architecture}. But, a partial profiling can be done by separately analysing the selected nodes the system is being distributed to.

When we focus on energy profiling\cite{balkishanprofiling}, a significant problem is the limited ability to separate the effects of the artefacts under profiling from the side-effects of measuring and effects of other system components. Invasive and non-invasive measurements are used at different level of error\cite{raplzhang,raplinaction}. Non-invasive is the way, when one is measuring the whole system, and the artefact selection is done by scenario design (test setup in automation). An invasive way is to introduce changes into the system to be able to measure with a lower error. Some techniques emit signals to external measuring only, other might be derived from Unit-testing techniques\cite{unit}.

RAPL\cite{raplzhang,raplinaction} supports both, since there exists its language library integrations such as PyRAPL integration, but it could be also used as an external measurement tool such as the power gadget. Getting inside interpreters is much more complicated, therefore browser or operating system level measurements are kind different. The browser itself needs to include a development support interface for data collection, which data could be then used in further analysis, e.g. using RAPL again. Firefox web browser includes energy profiling ability since version 104. The energy model is not included in the browser, collected data are sent to a web service that processes them to a readable form.

Our preliminary profiling results in technologies show that even React and Angular web application frameworks are already significantly different when developing standard news applications (fetching news data from a database and displaying them in an equally formatted form). While React seems to be slower in execution (see Fig.~\ref{RvA1}), Fig.~\ref{RvA2} shows a significantly lower workload.
% Figure environment removed

% Figure environment removed

\section{Our Example Web Application}
We propose a web application containing user profiles and allowing chat messaging between these users. We select React and Typescript as frontend technologies, while a very basic backend will be implemented using Python. Two development projects as building blocks of one application.

Repair and evolution tasks for the example:
\begin{enumerate}
\item In the application, there will be a programming error causing increased energy consumption of the browser (too many re-renders), which will be eliminated "based on user feedback".
\item According to energy saving design guides, we will evolve the style of the application to decrease frontend energy consumption (i.e. moving from light to dark theme style).
\end{enumerate}

Later, we will focus on the Python backend, measuring it using the pyRAPL library:
\begin{verbatim}
import pyRAPL

pyRAPL.setup( ... )

@pyRAPL.mesureit()
def Application(params):
\end{verbatim}

Here, the task will be to extend the backend. E.g. by an infantry filter, translator or even more advanced AI NLP procedure (supported by the Tensorflow library).

\section{Expected outputs}
We expect the increase of understanding of RAPL reports and profiles, especially their usage during software evolution. Practical experience with using the selected technologies in web application development will point out the similarity between different programming languages when using the same (object or component oriented) pragmas.

Certain level of competition between student groups (we plan to apply pair programming) will be set up based on comparing level of sustainability of the provided versions of the web application. Applications covering the same subset of functionalities will be sorted according to their energy requirements. The more classic competition in functional size will be also applied, thus, the ultimate winners will be the members of the team that implements the most functionalities by reaching a local minimum in energy consumption. We consider this factor as the evaluation of sustainability of the provided software solution:
\begin{itemize}
\item best functionality,
\item lowest energy consumption,
\item best of both worlds.
\end{itemize}


Practically, we expect that the teams will measure the frontends in Firefox and, separately, the Python backends as well. Then, the sum of the measurement results over a 5 minute interval will serve as the value entering the evaluation. Proof of correctness and function coverage of the measurements will be checked based on the submitted source codes and measurement logs.

\section*{Conclusion}
This paper aimed to present topics of the identically entitled lecture at the SusTrainable Summer School in Coimbra. These topics are web application architecture, development and evolution, with an emphasis on energy consumption measurement of selected components of the application architecture. Topics' presentation is enriched by using the illustrative example described in Section 3, more precisely its setup and first evolutionary steps.

The following practical session will provide discussion and competition environment to the attendees to evolutionary improve both frontend and backend functionality and energetic performance.

To be able to fulfil all described tasks, the attendees must have at least basic programming skills in the presented technologies (Typescript, React, Python), and basic soft skills to "survive" in a team of three developers. From technical perspective, there would be the usage of low-edge configurations pointing to more significant improvements, since top developer computers will be not running out of any resources in the lab exercises.

\subsubsection{Acknowledgements} This work acknowledges the support of the ERASMUS+ project “SusTrainable -- Promoting Sustainability as a Fundamental Driver in Software Development Training and Education”, no. 2020–1–PT01–KA203–078646.

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{99}
\bibitem{similarweb}
Similarweb: App Intelligence; A $360^{\circ}$ View Of The Digital World, \url{https://www.similarweb.com/corp/research/mobile-app-intelligence/}. Last accessed 18
Jun 2023

\bibitem{mdntesting}
MDN Web Docs: Tools and testing, \url{https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing}. Last accessed 18
Jun 2023

\bibitem{swevolutionbook}
Software evolution and feedback: Theory and practice, Edited by Nazim H. Madhavji ... [et al.]. John Wiley \& Sons Ltd, The Atrium, Southern Gate, Chichester, West Sussex PO19 8SQ, England (2006). ISBN-13: 978-0-470-87180-5

\bibitem{raplzhang}
Zhang, H, Hoffmann, H.: A Quantitative Evaluation of the RAPL Power Control System (2014)

\bibitem{raplinaction}
Khan, K. N., Hirki, M., Niemi, T., Nurminen, J. K., Ou, Z.: RAPL in Action: Experiences in Using RAPL for Power Measurements. ACM Trans. Model. Perform. Eval. Comput. Syst. 3, 2, Article 9 (June 2018), 26 pages. \url{https://doi.org/10.1145/3177754}

\bibitem{architecture}
Smith, S.: Architecting Modern Web Applications with ASP.NET Core and Azure. Microsoft Developer Division, .NET, and Visual Studio product teams, A division of Microsoft Corporation, One Microsoft Way, Redmond, Washington (2023)

\bibitem{balkishanprofiling}
Sharma, B.: Web Front End Profiling Client Side Performance Testing, \url{https://www.linkedin.com/pulse/web-front-end-profiling-client-side-performance-testing-sharma}, Published 29 Dec 2020

\bibitem{unit}
Noureddine, A., Rouvoy, R., Seinturier, L.: Unit Testing of Energy Consumption of Software Libraries. International Symposium On Applied Computing (SAC), March 2014, Gyeongju, South Korea. pp.1200-1205.

\end{thebibliography}

\end{document}
