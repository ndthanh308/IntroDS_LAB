\begin{abstract}
This paper explains how we want to teach sustainable programming for the Internet of Things, IoT, in the upcoming SusTrainable summer school.
Two aspects of sustainable IoT programming are discussed.
There is green computing, limiting the energy consumption of IoT applications.
Another important aspect is the efficient creation and maintenance of such IoT applications.
The lecture will show that both aspects can be served by Task-Oriented programming, TOP.
The students will experience the better maintenance of TOP based IoT applications by extending a given program in the practical session.

\keywords{IoT-programming \and TOP \and Green Computing \and Software Maintenance.}

\end{abstract}

\section{Introduction}

This paper discusses how to teach two aspects of sustainable Internet of Things, IoT, programming.

The first aspect is known as green computing.
It concerns the energy consumption of the IoT, especially the power used by the edge nodes of the IoT.
This is important since many edge nodes are battery powered, and we want to stretch the interval between battery charges.
Due to the enormous amount of edge nodes,  also reducing the energy consumption of other nodes is worthwhile.
These edge nodes together consume several percents of the worldwide total of electricity.

The second aspect of sustainable IoT computing is the creation and maintenance of IoT system software.
The rapidly increasing number of applications for the IoT makes it important to produce and update this software efficiently and reliable.
However, traditional tiered IoT applications are notoriously hard to produce and maintain because they are built using a layered architecture.
The IoT system consists typically of a user interface in the presentation layer.
This is often a web page, but it can also be an app tailored for smartphones or a wall mounter tablet like devices.
Next, there is an application layer containing web servers, various data storages and collectors to fill these storages with fresh data from the edge nodes.
The communication between application layer and the edge nodes is done in the network layer.
Apart from the well-known TCP connections, there are also tailored network services like MQTT~\cite{mqtt} and Protobuf~\cite{protobuf} used.
Finally, the bottom layer contains the edge devices.
These are single board computers, like a Raspberry Pi, or microcontrollers, like an ESP8266, equipped with sensors and actuators to measure and control phenomena in the real world.

Each of the subsystems in an IoT application is programmed in its own programming language.
By various communication protocols, these subsystems co-operate to establish the goals of the IoT application.
This makes IoT software a multi-lingual distributed heterogeneous system.
The various languages and protocols used give rise to semantic friction~\cite{ireland_classification_2009}.
There is limited support to ensure that the diverse subsystems cooperate smoothly.
Combined with the physical distribution of the edge nodes, this makes the development and maintenance of IoT applications a challenging and error-prone endeavour.

The lecture shows that Task-Oriented Programming, TOP, provides solutions for those problems.
In the iTask system, a TOP system for distributed interactive applications, the programmer specifies tasks to be done by users and the system itself at a high level of abstraction~\cite{plasmeijer_task-oriented_2012}.
All communication between subsystems, the storage of data, and even a web interface tailored to the task of specific users is generated automatically.
This single program replaces the various components of an IoT system mentioned above.
The iTask system is embedded in the strongly typed functional programming language Clean~\cite{Clean:language}.
The strong type-system prevents run time errors by checking programs at compile time.
Hence, run time type errors cannot occur in iTask programs.

Recent results show that TOP programs for the IoT are considerably shorter and simpler than their traditional counterparts~\cite{LubbersTIOT}.
The TOP programs use less programming languages and paradigms.
Together, this makes those programs easier to develop and maintain.

\section{Green Computing}

To reduce the energy consumption of IoT nodes, several strategies are applied.

The communication between the edge node and the server can consume a significant fraction of the energy consumption.
Edge computing limits this energy consumption by processing as much data as possible on the nodes where it is collected, instead of sending all collected data to the server, processing it there, and communicating the results.

Another strategy to reduce the energy consumption of the IoT is by using energy efficient microcontrollers, like a ESP8266, instead of single board computers, like a Raspberry Pi, to drive the edge nodes.
This reduces the energy consumption of such a device by another of magnitude, but this comes at a price.
The microcontrollers have a very limited amount of memory and processing power.
This often forces us to use domain-specific programming languages, like MicroPython, on these devices.
These nodes typically run either no operating system, or a limited real-time operating system.
This implies that the user program has to take care of the interleaving of multiple subtasks.
The iTask ecosystem offers the mTask language to run tasks on such microcontrollers~\cite{lubbers_writing_2019}.


Most microcontrollers have some sleeping modes on top of the basic low energy consumption.
The system temporarily shuts down part of the system to save energy in such a sleeping mode.
Obvious candidates for parts to switch off are the Wi-Fi radio and peripheral controllers that are not needed for some time.
Even the main processor and the RAM can be put in sleep mode when it is known that nothing has to be done for some time.
The system wakes up and starts working again, and hence consuming energy, after a specified sleeping time, or when an external interrupt wakes the system.
In the 2022 Sustrainable summer school in Rijeka we have shown how the mTask system can achieve such energy savings automatically~\cite{TFP22}.
For the upcoming summer school, some results are reused, but do not require any knowledge of this lecture.

\section{Task-Oriented IoT Programming by Example}

A complete introduction to TOP is outside the scope of this paper.
We illustrate the basic concepts with a few variations of a program reading a temperature sensor and showing this value in a web browser.
This example is concise, but contains all layers of an IoT application mentioned in the introduction.

The examples use a Shared Data Source, SDS, to store the latest temperature.
Such an SDS is a memory location that various tasks can read and update.
Within a single program, this behaves like a global variable.
Between various programs, an SDS is more like a database.
Here, the SDS \prog{tempSDS} contains just a real number to represent the temperature.
But, SDSs can contain values of any first order datatype, including for instance large lists of records.

\subsection{Local Temperature Sensor}

In the first version of our program, all tasks run on the same server.
The sensor is connected directly to this server, the SDS lives here and the web-server also runs on this machine.

\begin{lstlisting}[language=Clean,caption={An iTask program to read a local temperature sesnsor and display the value.},label={lst:itask1}]
tempSDS :: SimpleSDSLens Real
tempSDS = sharedStore "tempSDS" -273.15 // brrr

localSensor :: Task Real
localSensor =
    withDHT TempID \dht ->
    get tempSDS >>- \old ->
        devTask dht old -|| viewSharedInformation [] tempSDS <<@ Label "temperature"

devTask :: DHT Real -> Task Real
devTask dht old =
    temperature dht >>~ \new ->
        if (old <> new)
            (set new tempSDS >-| devTask dht new)
            (waitForTimer False delayTime >-| devTask dht old)

Start world = doTasks localSensor world

delayTime = 5
\end{lstlisting}

The \prog{localSensor} task first creates a sensor object, \prog{dht}, with \prog{withDHT}.
The argument \prog{TempID} tells how to access the physical sensor, we skip details.
Next, the task reads the current value of the SDS by \prog{get}.
The combinator \prog{>>-} bind the result of this task to the lambda function with \prog{old} as argument.
This function uses the combinator \prog{-||} for the parallel composition of the tasks \prog{devTask} and the \prog{viewSharedInformation}.
The view of the SDS is automatically updated when a change occurs.
This task keeps displaying the latest temperature as long as it runs.
The \prog{devTask} controls the sensor.
With \prog{temperature dht} we read the current value of the sensor.
Next, we check if the \prog{new} value is differs from the \prog{old} one.
When they are different, we update the SDS with the new value and call the function recursively.
Otherwise, we wait some time and start this task recursively.

This simple program contains two energy optimizations.
First, we update the SDS only when the temperature is changed.
This prevents that the web page is updated to display the same value with all associated computations and network traffic.
Future versions will execute this computation on the edge node to obtain edge-computation.
Next, the \prog{waitForTimer} tasks impose a delay.
During this time, the task does not require energy.

\subsection{Remote Temperature Sensor}

The temperature sensor is connected to a remote node in a more realistic IoT example.
We assume that the remote machine is sufficiently powerful to run an iTask program and that we have access to it.
A Raspberry Pi is perfectly suited for this job.

Our example program remains largely unchanged.
We only have to indicate which tasks runs on which machines and where the SDS is stored.
We chose to store the SDS on the remote machine.
We replace \prog{localSensor} by \prog{remoteSensor}.
The differences with the previous task is that it asks the user of the program for the address of the remote machine to run \prog{devTask}.
The function \prog{asyncTask} takes care of moving the task to the remote machine.
We tell the \prog{viewSharedInformation} that it has to display the value of this remote SDS instead of a local SDS by \prog{remoteShare}.
All other code is unchanged.

\begin{lstlisting}[language=Clean,caption={The iTask task to read a remote sensor and display its value.},label={lst:itask2}]
remoteSensor :: Task Real
remoteSensor =
    withDHT TempID \dht ->
    get tempSDS >>- \old ->
    enterInformation [] <<@ Title "device" >>? \dev ->
        asyncTask dev.domain dev.port (devTask dht old)
    -|| viewSharedInformation [] (remoteShare tempSDS dev) <<@ Label "temperature"
\end{lstlisting}

In general, it is hard to decide which part of the code is executed where.
The code executed remotely can use all functions and data types specified in the program.
To ensure that the desired code is available, the iTask system makes the entire code available on every machine executing some part of the program.
This holds even for a browser displaying the user interface.

\subsection{Remote Temperature Sensor on Microcontroller}

The introduction explains that microcontrollers are attractive hardware for edge nodes since they consume less energy and are cheaper.
Unfortunately, we cannot execute the code from the previous section on common microcontrollers.
The generated code is just too large and requires too much processing power.

The mTask system allows us to identify what parts of the program must be executed on the microcontroller.
The simple data structures and first-order strict evaluation of mTask ensure that these tasks can be executed on the restricted hardware.
The mTask system is powered by an embedded domain-specific language, DSL, offering task definitions very similar to iTask.
In contrast to standalone DSLs, embedded DSLs are expressed in terms of the host language~\cite{hudak_modular_1998}.
The strong type system of the host language ensures that the mTask parts of a program will co-operate smoothly within iTask programs.

In \prog{mTaskSensor}, the user enters the remote device.
Next, it starts the mTask task on the specified device with \prog{withDevice} in parallel with displaying the value of the temperature SDS.

All code of the \prog{devTask} is compiled dynamically to byte code that is executed by the mTask run time system running on that device.
First, the \prog{liftsds} makes a copy of the \prog{tempSDS} on the device.
The mTask machinery takes care of synchronization between those shares.
The \prog{DHT} definition creates a sensor object.
The \prog{fun} primitive defines a mTask function called \prog{measure}.
This function has the old temperature as its argument.
Just like the iTask version of this task, it reads the temperature sensor and updates the SDS when the \prog{new} value differs from the \prog{old} one.
The \prog{main} expression reads the old temperature from the SDS and calls the \prog{measure} function.

\begin{lstlisting}[language=Clean,caption={An iTask\slash{}mTask program to read a remote sensor and display its value.},label={lst:mtask}]
mTaskSensor :: Task Real
mTaskSensor =
    enterInformation [] <<@ Title "device" >>? \dev ->
        withDevice dev (liftmTask devTask)
    -|| viewSharedInformation [] tempSDS <<@ Label "temperature"

devTask :: v Real | mTask v
devTask =
  liftsds \rSDS -> tempSDS In
  DHT DHT_I2C \dht ->
  fun \measure = (\old ->
    temperature dht >>~. \new ->
    If (new  !=. old) (setSds rSDS new >>|. measure new) (measure old) In
  {main = getSds rSDS >>~. measure}
\end{lstlisting}

The reader might notice that this mTask code does not contain an explicit delay.
The mTask system is equipped with a scheduler that will automatically put the device into sleep mode in orde to save energy when there are no tasks that need execution~\cite{TFP22}.

\section{Sustainable Programming}

To verify that the TOP code is indeed more sustainable than traditional tiered code, we implemented a real world IoT example~\cite{smartSensors} in four ways~\cite{lubbers20tiered,LubbersTIOT}.
For the traditional implementation, we use a Raspberry Pi 3 as edge node and Python, JSON, HTML, PHP, Redis and MongoDB to construct the software.
This is called Python Raspberry Sensor, PRS.
Its direct counterpart uses just Clean and the iTask library and is called Clean Raspberry Sensor, CRS.
We made a variant with a WEMOS D1 mini microcontroller instead of the Raspberry Pi for both implementations.
The microcontroller runs MicroPython in the tiered approach.
This is called Python WEMOS Sensor, PWS.
The microcontroller runs mTask in the tierless TOP approach.
This variant is called Clean WEMOS Sensor, CWS.
Table~\ref{table:t1} give some key figures about these implementations.

\begin{table}[h!]
\centering
\caption{Key figures about the four implementations of the smart sensor.}%
\label{table:t1}
\begin{tabular}{l r r r r}
\toprule
   & PRS & CRS & PWS & CWS \\
 \midrule
 number of languages used & 6 & 1 & 7 & 2 \\
 total SLOC & 576 & 155 & 562 & 155 \\
 files & 38 & 3 & 35 & 3 \\
 memory residence (KiB) & 3557 & 2726 & 20 & 0.9 \\
 power consumption edge node (W) & 1-2 & 1-2 & 0.2 & 0.2 \\
 \bottomrule
\end{tabular}
\end{table}

The number of languages and files used in these TOP variants is significant smaller.
In addition, these are single source files that are checked by the strong static type system of Clean.
The Clean based versions use considerable less Source Lines of Code, SLOC, than the Python based variants.
Checking the details about the source code reveals that the TOP code is in most case 95\% shorter than their tiered counterpart.
The interface to MongoDB is only 26\% smaller and consumes almost half of the TOP code.
We can achieve a huge reduction of code by using a native SDS instead of the external MongoDB.

The code size differs not much by replacing the Raspberry Pi to a WEMOS microcontroller.
However, the restrictions of the microcontroller require an additional programming language and an appropriate distribution of tasks that obeys the limitations of the microcontroller languages.
This might be tricky for complex programs.

The microcontroller based software has the required small memory residence and achieve the desired power saving of about one order of magnitude.

\section{Teaching}

The lecture in the upcoming SusTrainable summer school will tell this story in some more detail.
We will focus on easier maintenance and its support in the TOP approach.
Other lectures in the 2023 summer school will argue the importance of maintenance by showing that up to 90\% of the total project effort is allocated to this phase of the software life cycle.

We will give the students an initial project that works with a microcontroller in the practical part of the tutorial.
The plan is to start with a project like the one in this paper.
Students will experience the support for changing such a project.
This project will be extended in steps by controlling the measurement interval dynamically, adding humidity measurements, storing historical data, and extending the user interface.
% \section{conclusion}

% bla bla

\section*{Acknowledgements}
This work acknowledges the support of the ERASMUS\raisebox{.25ex}{+} project ``SusTrainable---Promoting Sustainability as a Fundamental Driver in Software Development Training and Education'', no.\ 2020--1--PT01--KA203--078646.

%\bibliographystyle{splncs04}
%\bibliography{bibliography}
%
%\end{document}

