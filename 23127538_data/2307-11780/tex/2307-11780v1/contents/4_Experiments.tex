\section{Experiments}

\label{sec:Experiments}

\input{figures/caseTT}

\input{figures/t1_empirical.tex}

\input{figures/t2_quantitative.tex}

We implemented \textsc{Beep} in C++\footnote{https://github.com/BEEP-algorithm/BEEP-algorithm} and conducted all experiments on a computer with a 2 GHz CPU and 16 GB of memory.
We mainly conducted two studies to compare \textsc{Beep} with \textsc{Ditto}, one of the SOTA multivariate pattern mining algorithms.

\subsection{Case Study}

To examine that \textsc{Beep} could discover meaningful patterns (for effectiveness), we conducted a case study on a real-world table tennis dataset, with two analysts, each with over three years of experience analyzing table tennis data.
The dataset collected 716 sequences (average length was 5.91) from 10 matches played in 2019 by \textit{Ito Mima}, one of the top players in the world, against Chinese players.
Shown as Figure \ref{fig:tt}, the dataset considered four attributes; namely, the technique the player used to hit the ball (\textit{Tech}), the area where the ball impacted the table (\textit{Ball}), the spin of the ball (\textit{Spin}), and the position of the player (\textit{Player}) (more details can be found in Appendix \ref{app:values}).
We ran both \textsc{Ditto} and \textsc{Beep} on this dataset and summarized the results as follows.

\textbf{\textsc{Beep} can summarize a smaller set of informative patterns in shorter time than \textsc{Ditto}.}
Shown as Table \ref{tab:empirical}, \textsc{Beep} summarized 62 patterns in 425 seconds, while \textsc{Ditto} summarized 161 ones in 1747 seconds.
Meanwhile, the patterns summarized by \textsc{Beep} can be found in more sequences ($avg.$ $freq.$ is 12.94), with a reasonable number of missing values (guaranteed the authentication of patterns).
As a result, \textsc{Beep} reduces the analysis burden of analysts.

\textbf{\textsc{Beep} can find multivariate patterns with tolerances of single-value noises.}
Shown as Figure \ref{fig:tt}, \textsc{Beep} found a multivariate pattern $p$ in two sequences $s_1$ and $s_2$.
Sequence $s_1$ has a missing value at the second hit, where \textit{Ito}'s opponent used the technique \textit{Touch Short}, a control technique similar to \textit{Push}.
The analysts believed that $p$ summarized $s_1$ well, despite the missing value.
Sequence $s_2$ has a missing value at the third hit, where \textit{Ito} received the ball at \textit{Half-long Backhand}, different from \textit{Half-long Forehand} in $p$.
The analysts checked the video and found this value in $s_2$ to be recorded incorrectly.
If we had instead used the \textsc{Ditto} algorithm, these two sequences would have been encoded by other short patterns and thus unable to reveal these insights.

\subsection{Quantitative Experiments}

\label{sec:quantitative}

To quantitatively evaluate the performance of \textsc{Beep}, we compared \textsc{Beep} with \textsc{Ditto} on multi-scaled synthetic data, from the aspects of the number of summarized patterns, the description length reduction (both for evaluating effectiveness), and the runtime (for evaluating efficiency), shown as Table \ref{tab:quantitative}.

Given that \textsc{Beep} mainly introduces two improvements -- namely, the miss codes and the LSH-based acceleration -- we performed an ablation study to evaluate the effects of each improvement.
Specifically, we considered five algorithms: (1) \textsc{Ditto}, (2) the complete \textsc{Beep} algorithm, (3) \textsc{Beep}-miss (only with miss codes), (4) \textsc{Beep}-LSH (only with LSH-based acceleration), and (5) \textsc{Beep}-none (without neither improvements).

We construct 5 datasets, varying in terms of the number of sequences ($|S|$), the length of each sequence ($|s_i|$), the number of attributes ($|A|$), and the number of optional values of each attribute ($|V_k|$).
We further randomly generated \textbf{5 patterns} and planted them to the datasets, each with 5 non-empty values and a random length and covering 10\% of the events in the dataset.
For each pattern, we randomly chose two occurrences and set one value as a missing value for each occurrence, resulting in \textbf{10 total missing values}.
According to our manual check, all five algorithms found all five planted patterns.
Meanwhile, \textsc{Beep}-miss and \textsc{Beep} detected all the planted missing values.

\textbf{\textsc{Beep} and \textsc{Beep}-miss mined a smaller set of patterns with the highest description length reduction.}
Comparing \textsc{Beep}-LSH with \textsc{Beep} and comparing \textsc{Beep}-none with \textsc{Beep}-miss, we find that miss codes can reduce the number of patterns and compress more information.
We believe that miss codes can filter out similar patterns and preserve only one, leaving a smaller set of meaningful patterns.
Miss codes also allow for encoding sequences with long patterns with missing values, rather than multiple short patterns, resulting in a short description length.

\textbf{\textsc{Beep} and \textsc{Beep}-LSH had the lowest runtime.}
Comparing \textsc{Beep}-miss with \textsc{Beep} and comparing \textsc{Beep}-none with \textsc{Beep}-LSH, we found that the LSH-based acceleration substantially reduced runtime but led to more patterns and larger description lengths.

\textbf{In summary, \textsc{Beep} struck a good balance between effectiveness and efficiency and outperformed \textsc{Ditto}.}
\textsc{Beep} balanced the strengths of \textsc{Beep}-miss and \textsc{Beep}-LSH, with a nearly best performance on both information compression and efficiency.
Comparing with \textsc{Ditto}, \textsc{Beep} summarized a more refined set of patterns (smaller $|P|$ in most cases) with less runtime (smaller $t$) and a smaller description length (higher $\Delta L\%$).
