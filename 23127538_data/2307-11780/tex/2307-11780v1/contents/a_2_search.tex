\section{Covering Algorithm}

\label{app:search}

Algorithm \ref{alg:cover} shows the process of obtaining the optimal cover $C$ given a sequence $s$ and patterns in $CT$.
The core idea is to traverse each pattern $p$ in $CT^*$ (line 2) and try to cover $s$ by $p$ (line 3\textasciitilde7) until all the values in $s$ are marked as covered by a pattern (line 8\textasciitilde9).
If there exist values not marked (line 10\textasciitilde12), they will be marked as covered by the corresponding singleton patterns in $ST$ (line 13\textasciitilde15).
To ensure that the final cover $C$ is optimal, we follow the \textsc{Krimp} algorithm \cite{vreeken2011krimp} and employ a greedy algorithm.
We traverse the patterns in $CT^*$ in a fixed order (Cover Order): $\downarrow ||~p~||$, $\downarrow support(p~|~S)$, and $\uparrow$ lexicographically.
This order ensures that the patterns that have more values and higher frequency, which are more meaningful, will be used first.

\begin{algorithm}[!htb]
    \caption{Covering Algorithm}
    \label{alg:cover}
    \KwIn{A sequence $s$, a code table $CT$}
    \KwOut{An optimal cover $C$}
    \tcc{the explanation can be found in Sec. \ref{sec:coverAlgorithm}}
    $C \leftarrow \emptyset$, $marks \leftarrow \emptyset$, $misses \leftarrow \emptyset$\;
    \For{{\bf each} $p\in CT^*$ in Cover Order} {
        \For{{\bf each} $(marks\_p, misses\_p) \in search(p, s)$}{
            \If{$marks \cap marks\_p = \emptyset$}{
                $C \leftarrow C \cup (marks\_p, misses\_p)$\;
                $marks \leftarrow marks \cup marks\_p$\;
                $misses \leftarrow misses \cup misses\_p$\;
            }
        }
        \If{$|marks| = |s| \times |A|$}{
            {\bf break}\;
        }
    }
    \For{{\bf each} event $e \in s$} {
        \For{{\bf each} value $v \in e$} {
            \If{$v$ is not marked by $marks$} {
                $mark$ = \{cover $v$ by singleton pattern $v$ in $ST$\}\;
                $C \leftarrow C \cup (mark, \emptyset)$\;
                $marks \leftarrow marks \cup mark$\;
            }
        }
    }
    \Return{$C$}
\end{algorithm}

This is a time-consuming algorithm, leading to a high cost for calculating the description length.
The first loop (line 2-9) searches each pattern $p$ in $s$, which is similar to a string matching problem.
We employ the well-known KMP algorithm for searching each pattern, whose time complexity is $O(||s|| + ||p||)$, where $||s||$ and $||p||$ represent the number of values in $s$ and $p$, respectively.
Thus, the total time complexity of the first loop is $O(|P| \times ||s|| + ||P||)$, where $|P|$ and $||P||$ indicate the total number of patterns and values in $P$, respectively.
The second loop (line 10-15) traverses each value in sequence $s$, with a time complexity of $O(||s||)$.
Thus, the time complexity of the covering algorithm is $O(|P| \times ||s|| + ||P|| + ||s||)$.
As we need to cover each sequence $s$ with $CT$ to calculate the description length, the time complexity of the description length calculation is $O(|P| \times ||S|| + ||P|| \times |S| + ||S||)$, where $|S|$ and $||S||$ indicate the total number of sequences and values in $S$, respectively.

% Given a pattern $p$, a simple DFS-based algorithm (Algorithm \ref{alg:search}, \ref{alg:check}) searches pattern $p$ in sequence $s$ and finds every occurrence (line 3), where the limitations on gap events and missing values are considered.
% For each time pattern where $p$ occurs, the searching algorithm returns the position of each value and the missing values, namely $marks_p$ and $misses_p$ respectively.
% If all the positions in $marks_p$ are not marked, the algorithm uses pattern $p$ to cover these positions and updates the three variables.

% \begin{algorithm}[!htb]
%     \caption{Searching Algorithm}
%     \label{alg:search}
%     \KwIn{A sequence $s$, a pattern $p$}
%     \KwOut{All occurrences $occurs$}
%     \tcc{the explanation can be found in Appendix \ref{app:search}}
%     $occurs \leftarrow \emptyset$\;
%     $max\_gaps \leftarrow |p| - 1$, $max\_misses \leftarrow (||p|| + 5) / 10$\;
%     \For{$i \leftarrow$ 1 to $|s|$} {
%         $found$, $marks$, $misses$ = dfs($s$, $p$, $i$, 1, $max\_gaps$, $max\_misses$)\;
%         \If{$found$} {
%             $occurs \leftarrow occurs + (marks, misses)$\;
%         }
%     }
%     \Return{$occurs$}
% \end{algorithm}

% \begin{algorithm}[!htb]
%     \caption{DFS Algorithm}
%     \label{alg:check}
%     \KwIn{A sequence $s$, a pattern $p$, the start index in sequence $si$, the start index in pattern $pi$, max number of gap events $max\_gaps$, max number of missing values $max\_misses$}
%     \KwOut{Whether the patter occurs $found$, all positions $marks$, and positions of missing values $misses$}
%     \tcc{the explanation can be found in Appendix \ref{app:search}}
%     \If{$|s| - si < |p| - pi$} {
%         \Return{{\bf false}}\;
%     }

%     $es \leftarrow$ the $si$-th event of $s$\;
%     $ep \leftarrow$ the $pi$-th event of $p$\;
%     $marks \leftarrow \emptyset$\;
%     $num\_misses \leftarrow 0$, $misses \leftarrow \emptyset$\;
%     \For{$k \leftarrow$ 1 to $|A|$} {
%         \If{$ep[k]$ is not empty} {
%             \eIf{$ep[k] != es[k]$} {
%                 $num\_misses += 1$\;
%                 $misses \leftarrow misses + (si, k)$
%             } {
%                 $marks \leftarrow marks + (si, k)$
%             }
%         }
%     }
%     \If{$num_misses > max_misses$} {
%         \Return{{\bf false}}\;
%     }

%     \For{$i \leftarrow 0$ to $max\_gaps$} {
%         $found$, $marks^*$, $misses^*$ = dfs($s$, $p$, $si+1+i$, $pi+1$, $max\_gaps-i$, $max\_misses-num\_misses$)\;
%         \If{$found$} {
%             $marks \leftarrow marks \cup marks^*$\;
%             $misses \leftarrow misses \cup misses^*$\;
%             \Return{{\bf true}, marks, misses}\;
%         }
%     }
%     \Return{{\bf false}}\;
% \end{algorithm}