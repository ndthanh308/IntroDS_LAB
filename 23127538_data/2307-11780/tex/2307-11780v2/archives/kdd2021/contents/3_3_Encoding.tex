\subsection{Dataset Encoding}

\label{sec:encoding}

To encode the dataset with the code table, our algorithm takes three steps: covering, encoding, and calculating the encoded length.

\subsubsection{Covering}

Covering is the process of using patterns to describe a sequence.
A sequence $s$ is first separated into several patterns in code table $CT$ without overlapped values. The result is called a cover $C=cover(s~|~CT)$.
In the formal manner, given a sequence $s$ and a code table $CT$, a cover $C$ records which patterns are used and the location of each value in the pattern.
For example, sequence $s$ in Fig. \ref{fig:ct} is covered by pattern $p_1$, pattern $p_2$ and singleton value $y$.
For pattern $p_1$, cover $C$ records that it covers the first three events, and that there exists one miss value at the second attribute of $e_2$, and no gap events.
For pattern $p_2$, cover $C$ records that it covers the events $e_2$, $e_4$, and $e_5$, and that there exists one gap event and no miss value.
For singleton value $y$, cover $C$ simply records its position.

Note that for a given code table, there may exist many ways of varying utility to cover a sequence.
The simplest way is to use only singleton values to cover the sequence.
However, this is also the least useful way, because it cannot compress any information or extract any patterns.
In section \ref{sec:coverAlgorithm}, we explain how \textsc{Beep} finds an optimal way to cover a sequence with our code table design.

\subsubsection{Encoding}

Encoding is the process of using codes in the code table to describe a sequence, rather than patterns.
Given a multivariate sequence $s$, a code table $CT$, and a cover $C$, we encode the sequence into a code stream $cs$ through four steps.
(1) Scan the sequence $s$ left-to-right and top-to-bottom to find the first value that is not encoded, and look up the pattern $p_i$ to which the value belongs in the cover $C$.
(2) Traverse the sequence $s$ from the first event of $p_i$ to the last event of $p_i$.
During the traversal, the first event of $p_i$ is encoded as the pattern code $code_p(p_i)$, the gap events are encoded as gap codes, and the other events are encoded as fill codes.
All these codes are sorted in the order they are traversed.
(3) Find all the miss values in cover $C$.
For each miss value, assuming that it belongs to event $e$, we insert the miss code after the pattern code or the fill code that encodes $e$.
(4) Concatenate the code stream of the pattern to the entire code stream and mark all the values in the pattern as encoded.
We repeat these four steps until all the values in the sequence are encoded.

For example, Fig. \ref{fig:ct} demonstrates how a sequence $s$ is encoded as a code stream $CS$ given a cover $C$ and a code table $CT$.
We encode $s$ with three patterns, namely, $p_1$, $p_2$, and singleton $y$, in the order of traversal.
We first encode $p_1$ with no gap events and a missing value at $a_2$ of $e_2$.
Then, we encode $p_2$ with one gap event and no missing values.
Finally, we encode the singleton value $y$.


\subsubsection{Calculating the Encoded Length}

After encoding, we need to calculate the encoded length of the dataset to evaluate the model.
We consider the encoded length in two parts, namely the encoded length of the code table $L(CT~|~C)$ and the encoded length of the dataset $L(S~|~CT)$.
The optimization goal is to minimize the total encoded length $L(CT~|~C)+L(S~|~CT)$.

As the basis, we consider the length of each code.
Given that each code should be unique in order to avoid ambiguity during decoding, we use prefix codes \cite{cover1999elements} to optimize the length of distinct codes.
Given the set of all code streams $CS=\{cs_i~for~each~sequence~s_i\}$, the length of each type of code can be computed by Shannon entropy \cite{shannon1948mathematical}.
For pattern $p$, the length of the pattern code $code_p(p)$ is the negative log-likelihood
\begin{displaymath}
    L\left(code_p\left(p\right)\right)=-lg2\left(\frac{usage\left(p\right)}{\sum_{p_i \in CT}usage\left(p_i\right)}\right),
\end{displaymath}
where $lg2(k)$ means the logarithm of $k$ to the base $2$, and $usage(p)$ is the number of pattern codes of pattern $p$ in $CS$.
Similarly, we can give the calculation formulas for gap code $code_g(p)$, fill code $code_f(p)$, and miss code $code_m(p)$ as follows.
\begin{displaymath}
    \begin{aligned}
        L\left(code_g\left(p\right)\right)=&-lg2\left(\frac{gaps\left(p\right)}{gaps\left(p\right)+fills\left(p\right)+misses\left(p\right)}\right), \\
        L\left(code_f\left(p\right)\right)=&-lg2\left(\frac{fills\left(p\right)}{gaps\left(p\right)+fills\left(p\right)+misses\left(p\right)}\right), \\
        L\left(code_m\left(p\right)\right)=&-lg2\left(\frac{misses\left(p\right)}{gaps\left(p\right)+fills\left(p\right)+misses\left(p\right)}\right) \\ &+ L_N\left(~|~A~|~\right),
    \end{aligned}
\end{displaymath}
where $gaps(p)$, $fills(p)$, and $misses(p)$ are the number of gap codes, fill codes, and miss codes, respectively, of pattern $p$ in $CS$.
Miss code $code_m(p)$ contains additional bits for the index of missing attributes, which is denoted by $L_N(|A|)$.
Function $L_N(k)$ represents the number of bits required to encode integer $k$, where the MDL optimal Universal code for integers is considered \cite{grunwald2007minimum}.

\textbf{The encoded length of the code table.} To obtain a minimum description length, we treat patterns in $ST$ and patterns in $CT^*$ differently, where $L(CT~|~C)=L(ST)+L(CT^*)$.

For $ST$, we consider each attribute separately and encode the number of optional values and their supports:
\begin{displaymath}
    L\left(ST\right)=\sum_{1\leq k \leq ~|~A~|~}\left(L_N\left(~|~V_k~|~\right)
    + log\left(
        \begin{array}{c}
                ~|~S^k~|~ \\
                ~|~V_k~|~
            \end{array}
        \right)
    \right),
\end{displaymath}
where $S^k$ is a univariate dataset that preserves the $k$-th attribute of each event in dataset $S$.

For $CT^*$, we encode the number of patterns, the sum of their usages, the distribution of their usages over different patterns, and the original patterns:
\begin{displaymath}
    \begin{aligned}
        L\left(CT^*\right)= & L_N\left(~|~P^*~|~\right)+L_N\left(usage\left(P^*\right)\right)            \\
                            & +log\left(\begin{array}{c}
                ~|~usage\left(P^*\right)~|~ \\
                ~|~P^*~|~
            \end{array}\right)+\sum_{p_i\in P^*}L\left(p_i\right),
    \end{aligned}
\end{displaymath}
where $P^*$ is the set of all patterns in $CT^*$.
Considering that $|~P^*~|$ and $usage(P^*)$ can be zero, we define $L_N(0)=0$.
For a non-singleton pattern $p_i$, we encode the number of events, the number of values, the number of gaps, the number of misses, and the first column (i.e., each value in the pattern) as
\begin{displaymath}
    \begin{aligned}
        L\left(p_i\right) = & L_N\left(~|~p_i~|~\right)+L_N\left(~||~p_i~||~\right)                            \\
                            & +L_N\left(gaps\left(p_i\right)+1\right)+L_N\left(misses\left(p_i\right)+1\right) \\
                            & +\sum_{v\in p_i}L\left(code_p\left(v~|~ST\right)\right),
    \end{aligned}
\end{displaymath}
where $L(code_p(v ~|~ ST))$ represents the encoded length of a value $v$ in pattern $p_i$.
Here, we directly use the pattern code of singleton value $v$ in $ST$.

\textbf{The encoded length of the whole dataset given a code table.} We encode the number of sequences $|~S~|$, the length $|~s_i~|$ of each sequence $s_i$, the number of attributes $|~A~|$, and the codes in $CS$.
Thus, we obtain the equation
\begin{displaymath}
    \begin{aligned}
        L\left(S~|~CT\right)= & L_N\left(~|~S~|~\right) + \sum_{s_i \in S}L_N\left(~|~s_i~|~\right) + L_N\left(~|~A~|~\right) + L\left(CS\right),
    \end{aligned}
\end{displaymath}
where $L(CS)$ is the description length for $CS$ -- the sum of the description length of four types of codes:
\begin{displaymath}
    \begin{aligned}
        L\left(CS\right)= & \sum_{p_i \in CT}usage\left(p_i\right)L\left(code_p\left(p_i\right)\right)     \\
                          & + \sum_{p_i \in CT}gaps\left(p_i\right)L\left(code_g\left(p_i\right)\right)    \\
                          & + \sum_{p_i \in CT}fills\left(p_i\right)L\left(code_f\left(p_i\right)\right)   \\
                          & + \sum_{p_i \in CT}misses\left(p_i\right)L\left(code_m\left(p_i\right)\right).
    \end{aligned}
\end{displaymath}