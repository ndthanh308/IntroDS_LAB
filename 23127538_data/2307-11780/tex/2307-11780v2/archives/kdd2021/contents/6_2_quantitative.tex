\subsection{Quantitative Experiments}

\label{sec:quantitative}

\subsubsection{Synthetic data}

We performed quantitative experiments on multi-scaled synthetic data shown in Table \ref{tab:quantitative}.
We generated 15 datasets in 5 levels, varying in terms of the number of sequences ($|S|$), the length of each sequence ($|s_i|$), the number of attributes ($|A|$), and the number of optional values of each attribute ($|V_k|$).
The data generation consisted of three steps.
First, we generated sequences randomly, ensuring that all the optional values had similar frequencies.
More precisely, for any two optional values of an attribute, the frequency of one value must be higher than 90\% of the frequency of the other value.
Second, we generated 5 multivariate patterns, each of which contained 5 values and a random length.
Third, we added these patterns to the dataset generated in the first step.
We ensured that each pattern covered 10\% of the events in the dataset.
At the same time, for each pattern, we randomly chose two occurrences and set one value as a missing value for each occurrence, resulting in 10 total missing values.

\subsubsection{Experiments Setup}

We compared \textsc{Beep} with the state-of-art MDL-based multivariate pattern mining algorithm, \textsc{Ditto}, the source code of which has been implemented in C++ and published for research purposes\footnote{http://eda.mmci.uni-saarland.de/ditto/}.
Given that \textsc{Beep} mainly introduces two improvements -- namely, the miss codes and the LSH-based acceleration -- we performed an ablation study to evaluate how each improvement contributes to \textsc{Beep}.
Specifically, we considered five algorithms: (1) \textsc{Ditto}, (2) \textsc{Beep}-\,- (no miss codes; no LSH-based acceleration), (3) \textsc{Beep}-miss (no miss codes), (4) \textsc{Beep}-LSH (no LSH-based acceleration), and (5) the complete \textsc{Beep} algorithm.
Furthermore, we set the parameters of these algorithms, where the \textit{min support} of a pattern was $0.1 \times |S|$ for \textsc{Ditto}, and the threshold \textit{th} of LSH was $0.05 \times |S|$ for \textsc{Beep}-miss and \textsc{Beep}.
We ran the five algorithms on the 15 datasets and calculate the average performance of each algorithm on each level of datasets.

\subsubsection{Results}

The results are shown in Table \ref{tab:quantitative} and summarized as follows.

\textbf{\textsc{Beep} can discover all the planted patterns and missing values.} All five algorithms found all the planted patterns. Moreover, \textsc{Beep}-LSH and \textsc{Beep} detected all the planted missing values. Both \textsc{Ditto} and \textsc{Beep} work well in this scenario.

\textbf{\textsc{Beep}-\,- and \textsc{Ditto} have similar performance.} This proves that we can regard \textsc{Ditto} as the baseline algorithm and compare \textsc{Beep} with it fairly.

\textbf{LSH-based acceleration contributes to efficiency but sacrifices effectiveness.}
Comparing \textsc{Beep}-LSH with \textsc{Beep} and comparing \textsc{Beep}-\,- with \textsc{Beep}-miss, we find that LSH-based acceleration reduces runtime substantially.
However, when applying LSH-based acceleration, some patterns may not be found, meaning that the total description length may be longer.

\textbf{Miss codes help compress information but sacrifice efficiency.}
Comparing \textsc{Beep}-miss with \textsc{Beep} and comparing \textsc{Beep}-\,- with \textsc{Beep}-LSH, we find that miss codes can reduce the number of patterns and compress more information.
We believe that miss codes can filter out similar patterns and preserve only one, leaving a smaller set of meaningful patterns.
Miss codes also allow for the encoding of sequences with long patterns with missing values, rather than multiple short patterns, so that we obtain a short description length.
However, an algorithm that allows missing values spends more time searching for patterns.

\textbf{\textsc{Beep} strikes a good balance between effectiveness and efficiency.}
Comparing \textsc{Beep} with \textsc{Beep}-miss and \textsc{Beep}-LSH, we find that \textsc{Beep} balances the strengths of \textsc{Beep}-miss and \textsc{Beep}-LSH.
Although \textsc{Beep}-miss and \textsc{Beep}-LSH showed the best performance on efficiency and information compression, respectively, \textsc{Beep} has a nearly best performance on both efficiency and information compression.
In practice, analysts can choose one of these three algorithms according to their needs, although \textsc{Beep} will be the best choice in most scenarios.