\section{Definitions}

\label{sec:Predefinitions}

In this section, we formally define the input and the output of \textsc{Beep}.

\textbf{Input: }
We define the input as a dataset $S$ of multivariate event sequences, where the number of sequences is denoted by $|S|$.
% We consider a dataset $S$ of $|S|$ multivariate event sequences as the input of our algorithm.
Each sequence $s_i \in S$ is a vector of $|s_i|$ events, denoted $s_i = (e_1, e_2, ..., e_{|s_i|})$.
We further define $||S||=\sum_i{|s_i|}$ as the number of events in the whole dataset.
For each event $e$, we consider a same set of categorical attributes $A=\{a_1, a_2, ..., a_{|A|}\}$.
Thus, an event $e$ can be considered a vector of values, denoted $e=(v_1, v_2, ..., v_{|A|})$, where for each $1 \leq k \leq |A|$, $v_k$ is an optional value of attribute $a_k$.
We define $V_k$ as a finite set of all optional values of attribute $a_k$.
Thus, the set $E$ of all distinct events has a maximum size of $|E|_{max} = \prod_{1\leq k\leq |A|}{|V_k|}$.
% The dataset $S$ is over multiple categorical attributes $A=\{a_1, a_2,\\ ..., a_{|A|}\}$.
% Finite set $V_k$ consists of all the optional values for the $k$-th attribute $a_k$.
% Furthermore, an event $e$ can be considered as a vector of values, denoted $e=(v_1, v_2, ..., v_{|A|})$, where the $k$-th value $v_k \in V_k$.
% We define $E$ as the set of all distinct events, where the size $|E|$ has a maximum value of $|E|_{max} = \prod_{1\leq k\leq |A|}{|V_k|}$.

\textbf{Output: }
The output of \textsc{Beep} is a set $P$ of $|P|$ multivariate patterns. To define a pattern we must first define two other pre-elements.
First, we define $e^a\preceq e^b$ to indicate that event $e^a$ preserves some attributes of event $e^b$ and drops others, i.e., $e^a$ is part of $e^b$ (e.g., in Figure \ref{fig:patterndef}, $e_1$ of $p_1$, which drops the first attribute, is part of $e_1$ of $s_1$).
Formally, assume that $I$ is the set that includes the indexes of all the attributes to be preserved (i.e., some integers between 1 and $|A|$). For each $1\leq k\leq |A|$, if $k \in I$, $e^a$ has the same $k$-th value as $e^b$.
Otherwise, the $k$-th value of $e^a$ is empty.
Second, we define $s^a \subseteq s^b$ to indicate that sequence $s^a=(e^a_1, ..., e^a_n)$ is a subsequence of sequence $s_b=(e^b_1, ..., e^b_m)$, if there exist integers $1\leq i_1\le i_2\le ...\le i_n\leq m$ such that $e^a_j\preceq e^b_{i_j}$ for each $1\leq j\leq n$.

Based on these two pre-definitions, we define a pattern $p_i \in P$ as a subsequence of numerous original sequences in the dataset $S$, where $|p_i|$ indicates the length and $||p_i||$ indicates the number of values.
For example, in Figure \ref{fig:patterndef}, there exist four sequences ($s_1$ to $s_4$) in a dataset over two attributes ($a_1$ and $a_2$).
The dataset can be summarized by two patterns ($p_1$ and $p_2$), where $|p_1|=|p_2|=3$, $||p_1||=4$, and $||p_2||=6$.
Sequence $s_1$ covered by pattern $p_1$ is the simplest case.
We further support three features as follows to obtain informative patterns in real-world dataset.

\input{figures/patternDefinition}

\begin{enumerate}[label={\bf F{{\arabic*}}}]
  \item \label{feature:gap} \textbf{Gap events.}
%   A gap event can separate two consecutive events in the pattern into non-consecutive events in the sequence, such as $e_2$ of $s_2$.
  A gap event can separate two consecutive events in the pattern into non-consecutive events in the sequence. For example, sequence $s_2$ is covered by pattern $p_2$, but the gap event $e_2$ is not captured by $p_2$.
  We allow gaps to ignore events that may be noise.

  \item \label{feature:miss} \textbf{Missing values.}
  A missing value occurs in the pattern but not in the sequence, e.g., $s_3$ misses the second value of $e_2$ when it is covered by $p_2$.
  In the strictest interpretation, pattern $p_2$ is not a subsequence of sequence $s_3$.
  However, we must consider the possibility (common in real-world data) that a missing value is actually noise.
  Value $z$ may be similar to value $y$ because they have similar contexts (e.g., in tennis, $drive$ and $topspin$ are both offensive techniques to hit hard and low), or it may be an anomaly (e.g., an error caused by an automatic data acquisition system).
  Ignoring the substitution of similar values can keep the pattern simple, while detecting the pattern despite anomalies can help to inspect and dig into the data.
  Note that we are the first work that introduces missing values into multivariate sequential pattern mining.

  \item \label{feature:interleaveing} \textbf{Interleaving patterns.}
  Two interleaving patterns overlap over a period of time\cite{tatti2012long}, e.g., pattern $p_1$ and $p_2$ are interleaving in sequence $s_4$.
  We allow interleaving patterns to discover simultaneous patterns.
\end{enumerate}

An informative pattern should be compact (i.e., the events in the pattern should occur within a short period of time in the original sequences) and authentic (i.e., there should exist as few missing values as possible).
Thus, we limit the maximum number of gap events in a pattern $p$ to $|p|-1$ and the maximum number of missing values in a pattern $p$ to $\lfloor||p|| \div 10 + 0.5\rfloor$.
Moreover, we allow only one missing value in an event.
