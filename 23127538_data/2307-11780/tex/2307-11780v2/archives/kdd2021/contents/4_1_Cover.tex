\subsection{Covering the Dataset}

\label{sec:coverAlgorithm}

Given a set of patterns $CT$ and a dataset $S$, the covering algorithm targets the optimal cover $C$ for each sequence $s_i \in S$ with the patterns in $CT$.
Considering that each sequence is independent, we cover the sequences separately.
Algorithm \ref{alg:cover} shows the process of obtaining the optimal cover $C$ given a sequence $s$ and patterns in $CT$.
First, we initialize three variables with an empty set (line 1), where $C$ is the output of the algorithm, $marks$ records which pattern each value in $s$ belongs to, and $misses$ records the position of all the miss values.
Note that $marks$ does not record any miss values, and $misses$ may record a value that is missed by two patterns.

The core idea is to traverse each pattern $p$ in $CT^*$ (line 2) and try to cover $s$ by $p$ (line 3\textasciitilde7) until all the values in $s$ are marked as covered by a pattern (line 8\textasciitilde9).
If there exist values not marked (line 10\textasciitilde12), they will be marked as covered by the corresponding singleton patterns in $ST$ (line 13\textasciitilde15).
To ensure that the final cover $C$ is optimal, we follow the \textsc{Krimp} algorithm \cite{vreeken2011krimp} and employ a greedy algorithm.
We traverse the patterns in $CT^*$ in a fixed order (Cover Order): $\downarrow ||~p~||$, $\downarrow support(p~|~S)$, and $\uparrow$ lexicographically.
This order ensures that the patterns that have more values and higher frequency, which are more meaningful, will be used first.
% To ensure that the final cover $C$ is optimal, we follow the \textsc{Krimp} algorithm \cite{vreeken2011krimp} and employ a greedy algorithm that traverses the patterns in $CT^*$ in a fixed order.
% We first consider patterns with more values, which are obviously more informative.
% We then consider patterns with higher frequency because higher frequency means more regularity.
% Finally, a lower likelihood of the cover are expected.
% Formally, the \textbf{Cover Order} is: $\downarrow ||~p~||$, $\downarrow support(p~|~S)$, and $\uparrow$ lexicographically.

Given a pattern $p$, a simple DFS-based algorithm (Appendix \ref{app:search}) searches pattern $p$ in sequence $s$ and finds every occurrence (line 3), where the limitations on gap events and missing values are considered.
For each time pattern where $p$ occurs, the searching algorithm returns the position of each value and the missing values, namely $marks_p$ and $misses_p$ respectively.
If all the positions in $marks_p$ are not marked, the algorithm uses pattern $p$ to cover these positions and updates the three variables.

\input{figures/a_covering.tex}