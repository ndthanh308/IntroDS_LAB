\section{Beep}

In this section, we introduce our algorithm, \textsc{Beep}, to mine multivariate patterns in racket sports.
Based on the MDL principle \cite{grunwald2007minimum}, \textsc{Beep} describes the dataset into two parts -- i.e., the pattern set and the description of each sequence based on the pattern set -- and expects the minimum description of the two parts (Equation \ref{eq:mdl}).
\begin{equation}
    \begin{aligned}
    \mathop{minimize}\limits_{P} \ L(S~|~P),~where~L(S~|~P) = L(P) + \sum_{s\in S}L(s~|~P),\\
    \end{aligned}
    \label{eq:mdl}
\end{equation}
where $L(S~|~P)$, $L(P)$, and $L(s~|~P)$ is the description length of dataset $S$ based on $P$, pattern set $P$, and sequence $s$ based on $P$, respectively (detailed calculation can be found in Section \ref{sec:coverAlgorithm}).

Inspired by Ditto \cite{bertens2016keeping}, \textsc{Beep} optimizes $L(S~|~P)$ iteratively and heuristically.
Initially, $P$ includes all singleton patterns (i.e., an event with only one non-empty value).
At each iteration, \textsc{Beep} generates a set of candidate patterns $C$ and filters each usefull candidate $cp \in C$ (i.e., $L(S~|~P + cp) < L(S~|~P)$).
After adding these useful candidates into $P$, \textsc{Beep} further filters out each redundant pattern $p \in P$ (i.e., $L(S~|~P - p) < L(S~|~P)$).
\textsc{Beep} will not stop until $P$ keeps the same at a certain iteraction, which indicates that $P$ approximates the optimal pattern set with the minimum description length $L(S~|~P)$.
The key contribution of \textsc{Beep} lies in three aspects as follows.

\subsection{Candidates Generation}

\label{sec:candidates}

\input{figures/candidate}

\textsc{Beep} constructs complex patterns with simple ones, i.e., combining each pair of patterns in $P$ at different alignments.
For example, in Fig. \ref{fig:candidate}, we list all the candidate patterns ($cp_1$ to $cp_6$) generated based on multivariate pattern $p_1$ and $p_2$ over three attributes.
However, when aligning $e_2$ of $p_1$ and $e_1$ of $p_2$, a conflict exists on value $x$ and $y$.
We resolve this conflict by regarding it as a missing value of one of the original patterns.
For example, a sequence perfectly matched by $p_1$ may also be covered by $cp_4$ with one missing value.


\subsection{Description Length Calculation}

\input{figures/encoding.tex}

\label{sec:coverAlgorithm}

The process of calculating description length is shown as Figure \ref{fig:ct}, where we convert pattern set $P$ into a code table ($CT$) and use $CT$ to encode each sequence $s\in S$ into a code stream $CS$.
We define $L(P)$ and $L(s | P)$ as the digital length of $CT$ and $CS$, respectively.
Detailed mathematical calculations can be found in Appendix \ref{app:mdl}.

\subsubsection{Code table}
The code table records a pattern code for all patterns in $P$, including the generated patterns ($CT^*$) and singleton patterns ($ST$).
For the generate patterns, the code table further records its gap code (for encoding gap events), fill code (for filling in the next event in $p$), and miss code (for encoding missing values).
We employ the Huffman coding algorithm \cite{moffat2019huffman} to represent each code as a distinct binary number according to the frequency it is used to encode the sequences in $S$, in order to ensure that the total description length is minimal.

\subsubsection{Sequence encoding}
Given a code table $CT$ and a sequence $s$, we first cover $s$ using the patterns in $CT$ ($C$ in Figure \ref{fig:ct}, pseudocode is in Appendix \ref{app:search}).
Then, \textsc{Beep} scans each value in $s$ in order and pushes the corresponding code to $CS$.
For example, sequence $s$ in Fig. \ref{fig:ct} is covered by pattern $p_1$, pattern $p_2$ and singleton value $y$.
Pattern $p_1$ starts from $e_1$ (the pattern code) and covers $e_2$ and $e_3$ (two fill codes), where $v_2$ of $e_2$ is missing (the miss code).
Pattern $p_2$ starts from $e_2$ (the pattern code), gaps at $e_3$ (the gap code), and covers $e_4$ and $e_5$ (two fill codes).
Singleton $y$ occurs at the last.

\subsection{Algorithm Acceleration}

\label{sec:lsh}

Description length calculation is the most time-consuming step, as it runs for each of thousands of candidates and considers thousands of original sequences (see Appendix \ref{app:search} for time complexity analysis).
However, a candidate $c$ is generated by combining each two patterns.
Only when two patterns often occur simultaneously or consecutively, the combined candidate is more likely to be a frequent pattern and benefits description length reduction.

Thus, we accelerate \textsc{Beep} by filtering out those pairs of patterns with low co-occurrence in advance.
For each pattern $p$, we record the positions where it occurs when covering the dataset.
A position is an index of a segment of original sequences, where a segment contains at most $l$ events (default $l$ is 20), and a long sequence will be cut into several segments.
Then, we apply weighted \textit{Locality Sensitive Hashing} (LSH) \cite{ioffe2010improved} to examine whether the two patterns occur in similar sets of positions.
If two sets of numbers have a weighted Jaccard similarity larger than a threshold $th$, the weighted LSH algorithm will regard them as the same.
