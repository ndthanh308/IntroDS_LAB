\section{Introduction}
% What is the problem?
Many software products are complex systems (e.g.\ browser applications) that interact with externally
provided data (e.g.\ websites). Such data from the outside world must
be validated before it can be processed by the software. If the validation
is not sufficiently rigorous, the data can trigger unintended application behavior, which
% unintended behavior can furthermore 
might lead to security-related vulnerabilities,
e.g.\ remote code execution or information leaks. Fuzz testing techniques\cite{sutton2007fuzzing}
can be used to uncover the underlying errors leading to vulnerabilities.
However, for complex input data structures, it is time-consuming to develop
test case generators and to fine-tune them to discover code paths that are
difficult to reach.

% Why is it interesting and important?
Major tech companies like Microsoft\cite{ms_onefuzz} and Google\cite{adkins2020building}
not only fuzz test their own products but also provide
fuzzing infrastructure
for external software. By March 2021, Google OSS Fuzz\cite{google_oss_fuzz} 
discovered 23,907 bugs in 316 software projects as highlighted by 
Ding et al.\cite{DBLP:journals/corr/abs-2103-11518}.
During a fuzz test, the software under test encounters various correct and malformed
inputs as produced by the fuzz test generator. As the tests are executed, the execution
of the software is monitored to detect unexpected behavior, like memory corruptions or sudden
termination, and in some cases code coverage.

In general, test case generation for fuzzing
is divided into two categories. First, the \emph{mutation-based} approach
relies on a provided corpus of valid input data, which is then
mutated by replacing subsets of the input with different values.
Secondly, the \emph{generation-based approach} involves the programmatic synthesis of input data based on the underlying data format. It is
essential for test case effectiveness to introduce errors into the generated output to trigger edge cases.

% Why is it hard?
Generally, the generation-based fuzzing approach yields better results more
quickly than the mutation-based approach. However, developing a test 
case generator is time-consuming work. First, the input grammar needs to
be studied and implemented to generate test cases that adhere to the
specification of the input structure.
Secondly, the test case generator needs to be fine-tuned to be able to
uncover unexpected behavior in the program under test by breaking the
rules of the input specification. However, this can lead in many
cases to the program under test rejecting the input all together.

% TODO WHY, need to spell this out! 

% What we do to solve this
%TODO I would like some more on the difficulty and possible solutions leading to a RL approach being a valid things to investigate
% ... i.e. the overall vision is to use RL in developing fuzzes... HTML is one example
Manually designing and implementing a high-quality, generation-based fuzzer is often a prohibitively time-consuming and expensive process. A partial solution has show itself in the form of machine learning which offers a viable approach for learning fuzzing strategies from existing examples of input data. Such systems have been investigated and demonstrated for complex domains such as PDF documents \cite{godefroid2017learn} and HTML \cite{sablotny2018rnnfuzz}. A major limitation of the aforementioned learned fuzzers is that they are based entirely on the existing input data, hence ignores the response from the software under test (e.g., code coverage and failures) when generating the input data. A potential solution comes in the form of reinforcement learning \cite{russel2010} which provides a coherent framework for learning optimal policies for sequential decision making based on observed rewards (e.g. code coverage). 

Our aim is to design, train and evaluate a complete generation-based fuzzer combining a deep generative model and reinforcement learning with the software under test in the loop. As a case-study, we focus on HTML data and the Firefox HTML rendering engine as
software under test. HTML has over 100 tags that can be further
specialized with the help of multiple different attributes. The standards document that
describes HTML 5 \cite{html5_w3} is over 1200 pages long. Furthermore, an
efficient test case generator needs to strike the right balance between
adhering to the structural rules and breaking them to uncover
code paths were not originally considered during development.

% Here to force the concept diagram to be close to the introduction
% Figure environment removed


% Why hasn't it been solved yet?

% What are the key components of my approach and result?
%We have adopted a two-step approach in order to break down the complex task of 
%developing test case generators by training a deep learning model
%to generate test cases.

We propose to break down the task of learning test case generators informed by code coverage in two parts. The first part is a Temporal Convolutional Network (TCN) which is trained on existing HTML data and used to generate novel HTML test cases conditioned on a specific HTML tag. Secondly, a reinforcement learning model is uses the generator model and feedback from the program execution to lean a policy for increasing the code coverage by selecting the optimal HTML tags. 
Further, we propose the use of a Double Deep Q-Network (DDQN) agent to learn the excepted value of the next action. 
Our combined approach outperforms both (i) a conventional grammar-based test case 
generator and (ii) the TCN generator model alone, in terms of code coverage.
The overall approach is highlighted in \Cref{exp:RL}.
While the approach is demonstrated for fuzz testing HTML rendering engines, the generic approach is applicable in other domains.

Our main contributions are:
\begin{itemize}
    %\item Proposing a TCN design to create a fuzz test case generator for HTML that
    %is also able to augment existing fuzzer by increasing their code coverage.
    \item A new neural network-based fuzz test case generator for HTML based on the TCN architecture which is able to augment existing fuzzers by increasing their code coverage.
    \item A novel neural network-based fuzzer combining a reinforcement learning DDQN agent with the TCN generator. 
    The agent is informed by code coverage and is trained to maximize code coverage by optimising the generating test cases.
    \item Empirical validation of the performance of the combined DDQN-TCN approach versus
    a default generation-based fuzzer in terms of code coverage in a modern web rendering engine.
\end{itemize}

The rest of the paper is organized as follows. First, \Cref{back} introduces
the necessary background concepts regarding TCNs and DDQN agents. This is followed
by describing the design of the proposed machine learning models in \Cref{design},
which leads to experimental setup in \Cref{exp}. The results are presented in
\Cref{res}. Next, \Cref{disc} discusses the performance of the DDQN agents, 
before \Cref{work} introduces the differences to existing 
research. The second to last part provides an outlook into
future work in \Cref{fut}, and finally, \Cref{con} concludes 
% the work we did
with a summary of our achievements.

