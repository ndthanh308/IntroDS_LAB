\begin{algorithm}[H]
\label{mergehelper}
\caption{\texttt{mergeHelper}(rightChild,\ rightIdx,\ leftChild,\ leftIdx,\ prev,\ pidx,\ curr)}
\textup{Node*} $newNode$\;
\If{$rightChild \rightarrow count + leftChild \rightarrow count < MAX$}
{
    \textup{Node*} $newChild$\;
    \If{$leftChild \rightarrow isLeaf$}
    {
        $newChild :=$ \texttt{new LeafNode()}\;
        $newChild \rightarrow next := rightChild \rightarrow next$\;
    }
    \Else
    {
        $newChild :=$ \texttt{new InternalNode()}\;
    }
    Merge $rightChild$ and $leftChild$ into $newChild$\;
    \label{alg15:line185}
    \If{\textup{!}$\,leftChild \rightarrow newNext$.\texttt{\textup{CAS}}(\texttt{\textup{nullptr}}, $newChild$)}
    {
        \label{alg15:line186}
        $newChild := leftChild \rightarrow newNext$\;
    }
    $newNode :=$ \texttt{new InternalNode()}\;
    Copy every element in $curr$ into $newNode$ replacing pointers $leftChild$ and $rightChild$ with $newChild$\;
    \label{alg15:line189}
}
\textbf{else} $newNode :=$ \texttt{borrowHelper}($rightChild,\ rightIdx,\ leftChild,\ leftIdx,\ curr$)\;
\If{$prev =$ \texttt{\textup{nullptr}}}
{
    \If{$newNode \rightarrow count = 0$} 
    {
        $newNode := newChild$ \tcp*{this occurs only when the left and right children are merged and newNode has only one child}
    }
    \textbf{if} \textup{!}$\,root$.\textup{\texttt{CAS}}($curr, newNode$) \textbf{then} \textbf{return} \textup{\texttt{nullptr}}\;
    \label{alg15:line194}
}
\textbf{else if} \textup{!}$\,prev \rightarrow ptr[pidx]$.\texttt{CAS}($curr, newNode$) \textbf{then} \textbf{return} \textup{\texttt{nullptr}}\;
\label{alg15:line195}
\textbf{return} $newNode$\;
\end{algorithm}
