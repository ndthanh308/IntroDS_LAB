We have already discussed the salient points where Uruv differs from existing techniques of concurrent range search. In particular, in contrast to the locking method of bundled references \cite{nelson2021bundled} and the lock-free method of constant time snapshots \cite{wei+:PPOPP:2021}, Uruv guarantees wait-freedom. The architecture ensuring wait-freedom in Uruv, i.e., its \texttt{stateArray}, has to accommodate its multi-versioning. The existing methods did not have to consider this.

Anastasia et al. \cite{braginsky+:SPAA:2012} developed the first lock-free B$^+$Tree. In their design, every node implements a linked-list augmented with an array. This ensures that each node in the linked-list is allocated contiguously. It slows down updates at the leaf and traversal down their tree. Uruvâ€™s design is inspired by their work, but, does away with the arrays in the nodes. As the experiments showed, it clearly benefits. Most importantly, we also support linearizable wait-free range search, which is not available in \cite{braginsky+:SPAA:2012}. OpenBw-Tree \cite{wang2018building} is an optimized lock-free B$^+$tree that was designed to achieve high performance under realistic workloads. However, again, it does not support range search.

We acknowledge that other recently proposed tree data structures could be faster than Uruv, for example, C-IST \cite{brown+:PPOPP2020} and LF-ABTree \cite{TrevorBrown:PhDThesis}. However, LF-ABTree is a relaxed tree where the height and the size of the nodes are relaxed whereas C-IST \cite{brown+:PPOPP2020} uses interpolation search on internal nodes to achieve high performance. That is definitely an attractive dimension towards which we plan to adapt the design of Uruv. Furthermore, they are not wait-free. Our focus was on designing a B$^+$Tree that supports wait-free updates and range search operations.

In regards to wait-free data structures, most of the attempts so far has been for Set or dictionary abstract data types wherein only insertion, deletion, and membership queries are considered. For example, Natarajan et al. \cite{Natarajan2013ConcurrentWR} presented wait-free red-black trees.  Applying techniques similar to fast-path-slow-path, which we used, Petrank and Timmet \cite{petrank2017practical} proposed converting lock-free data structures to wait-free ones. They used this strategy to propose wait-free implementations of inked-list, skip-list and binary search trees. There have been prior work on wait-free queues and stacks \cite{fatourou2011highly}, \cite{attiya2018nontrivial}. However, to our knowledge, this is the first work on a wait-free implementation of an abstract data type that supports add, remove, search and range queries.
