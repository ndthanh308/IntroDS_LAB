% \subsection{Maintenance of Invariants}

Uruv’s keys and values lie inside an extensive linked list indexed by a B$^+$Tree-like structure. Efficient indexing occurs as Uruv indexes sublists contained in leaf nodes wherein every leaf node is connected to the next. We, therefore, use two invariants,

\begin{enumerate}
    \item Each linked list inside a leaf node is sorted in ascending order by keys.
    \item Every leaf node’s elements should be lesser than its next leaf node’s elements if it exists.
\end{enumerate}

We now show that the two invariants described above are always maintained before and after the completion of every operation. Lookups and range queries maintain both invariants trivially since they do not modify Uruv. Showing invariants' maintenance reduces to showing their maintenance in inserts and deletes.

We first show why invariant one is maintained. Since inserts boil down to inserting into the linked list inside leaf nodes, the invariant one is trivially satisfied as we use Harris’ linked-list design\cite{harris2001pragmatic}. Since a delete operation also updates a key’s value with a unique value, the invariant one is satisfied as the key’s position in the linked list remains unchanged. If the linked list is the only structure that ends up being modified, the second invariant is trivially maintained. However, Insert/Delete can lead to a Split/Merge operation which affects the leaf nodes. We now show how the invariants are maintained in cases such as these.

In a split operation, a leaf node, $currLeaf$, is broken into two leaf nodes equally, splitting the elements of the original leaf node. Each half of $currLeaf$ is copied over to either half. This copy, in essence, is atomic since $currLeaf$ is frozen and cannot be modified. We ensure every key in the left half is lesser than in the right. The left half’s next pointer points to the right half, thereby connecting both halves. This maintains invariant two, wherein leaf nodes are sorted. We then atomically replace the pointer to the $currLeaf$ from its parent node with the two new pointers to both halves. We accordingly modify the parent node’s keys so we can correctly index the extra child. Invariant one is trivially satisfied since each leaf node’s linked list is just being copied over from $currLeaf$.

In a merge operation, a leaf node either borrows a key from its sibling node or merges with it into one new leaf node. Like above, we create new leaf nodes in both cases and replace the old ones atomically. Let us consider the case when a leaf node, $currLeaf$, has to borrow a key from its left sibling. We move the last key in the left sibling to the beginning of $currLeaf$. Using invariant two, the last key in the left sibling is lesser than the first key in $currLeaf$. Therefore, moving this key over to the beginning of $currLeaf$ maintains both invariants. If $currLeaf$ borrows a key from the right sibling, we will move the first key in the right sibling to the end of $currLeaf$. It is straightforward to see that both invariants are maintained.

We now show correctness for the last case of a leaf node, $currLeaf$, merging with its sibling. Without losing generality, let us say $currLeaf$ merges with its left sibling. We copy the keys from $currLeaf$ and its left sibling into a new leaf node, $newLeaf$. The copy is, in essence, atomic as both siblings are frozen. We ensure that the linked list in $newLeaf$ is sorted, maintaining an invariant one. $currLeaf$’s left sibling is connected to $newLeaf$, and $newLeaf$ is connected to $currLeaf$’s right sibling. This maintains invariant two since it was already true before the merge operation started, and it remains true as $newLeaf$ is just a sorted combination of both siblings’ keys.
