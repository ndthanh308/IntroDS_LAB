The first race condition can arise when two threads try to modify the \textit{vhead}, knowing that \textit{vnode}’s timestamp is not set. Let us say thread $t_1$ has read the current \textit{vhead} at line \ref{alg25:line298}, and finds out the current timestamp of the \textit{vnode} is not set. Similarly, thread $t_2$ reads the same information as $t_1$ and is now performing the \texttt{wfVCAS} operation at line \ref{alg25:line304}. If thread $t_2$ succeeds in changing the \textit{vhead} at line \ref{alg26:line321}, $t_1$ will fail as the current \textit{vhead} has changed. So only one thread can replace the \textit{vhead} with \textit{vnode}.

Let us discuss another race condition. A thread $t_1$ finds that the key to be inserted does not exist. It creates a new linked-list node and will add it to the linked-list with its \textit{vhead} pointing to the \textit{vnode} at line \ref{alg25:line314}. Now, $t_1$ stalls, and another thread $t_2$ finds that the key exists, and it tries to update the node’s \textit{vhead} with the \textit{vnode}. So, when thread $t_2$ reads the current \textit{vhead} of the node at line \ref{alg25:line303}, after initializing its \textit{vnode} at line \ref{alg25:init}, thread $t_2$ will not proceed further with the operation. In the end, only one thread will be able to replace the \textit{vhead} with \textit{vnode}.

Let us consider a final race condition wherein a thread tries to set the shared \texttt{stateArray} \textit{vnode}’s \textit{nextv} in the \texttt{wfVCAS} method. Let some thread $t_1$ stall just before executing line \ref{alg26:line320}, where it was about to set \textit{vnode}’s \textit{nextv} to the \textit{vhead} it read at line \ref{alg25:line297}. Let the $vhead$ it read be some \texttt{Vnode} $v_1$. While $t_1$ stalls, two things happen in parallel. First, the \textit{vhead} gets updated to another \texttt{Vnode}, $v_2$. Second, a thread, $t_2$, changes \textit{vnode}’s \textit{nextv} to $v_2$ at line \ref{alg26:line320} and successfully updates the \textit{vhead} at line \ref{alg26:line321}. Now thread $t_1$ wakes up and changes \textit{nextv} to $v_1$ at \ref{alg26:line320}, resulting in $v_2$ not being part of the versioned list. To avoid this race condition, we atomically update the \textit{nextv} of the $vnode$ at line \ref{alg26:line320} and check if it has already been changed by some other thread or not. If it has, then we restart the operation.
