
\subsection{The structures of the component nodes}
Here we first describe the structure of the nodes in \urv. See Figure \ref{fig:vlfll}. A versioning node is implemented by the objects of type Vnode. A key node as described in the last section, is implemented by the objects of the class llNode. Nodes of type llNode make the linked-list of a leaf-node which is implemented by the class VLF\_LL.

The leaf and internal nodes of \urv inherit the Node class. See Figure \ref{fig:tree-class}. An object of class Node of \urv, hereafter referred to as a node object, keeps count of the number of keys. A node object also stores a boolean to indicate if it is a leaf node. A boolean variable `frozen' helps with ``freezing a node'' while undergoing a split or merge in a lock-free updatable setting. A thread on finding that a node is frozen, helps the operation that triggered the freezing.  

\input{figs/vl_fll}

Every leaf node has three pointers $next$, $newNext$ and a pointer to version list $ver\_head$ and one variable $ts$ for the timestamp. The $next$ pointer points to the next adjacent leaf node in \urv. When a leaf node is split or merged, the $newNext$ pointer ensures leaf connection. A new leaf node is created to replace it when a leaf node is balanced. Using the $newNext$ pointer, we connect the old and new leaf nodes. When traversing the leaf nodes for \rangeQuery with $newNext$ set, we follow $newNext$ instead of $next$ since that node has been replaced by a newer node, ensuring correct traversal. The initial $ts$ value is associated with the construction of the leaf node. 

% Figure environment removed


\subsection{Versioned Linked-List}

The description of lock-free \lble implementation of the ADT operations \rangeQuery, \insertADT, and \remove requires detailing the versioned linked list. A versioned list holds the values associated with the key held at various periods. Each versioned node (\texttt{Vnode}) in the versioned list has a value, the time when the value was modified, and a link to the previous version of that key. Versioned linked-list information may be seen in Figure \ref{fig:vers_list} and Figure \ref{fig:vlfll}. The versioned list's nodes are ordered in descending order by the time they have been updated. Compared to the \cite{harris2001pragmatic}, there is no actual delinking of nodes; instead, we utilise a tombstone value (a special value not associated with any key) to indicate a deleted node. Moreover, deleting a node requires no help since there is no delinking. Although, for memory reclamation, we retain a record of active \rangeQuery and release nodes that are no longer needed. Any modification to the versioned linked list atomically adds a version node to the \texttt{vhead} of \texttt{llNode} using \texttt{CAS}. 

\subsection{Traversal and Proactive maintenance in \urv}

We traverse from root to a leaf following the order provided by the keys in the internal nodes. In each internal node a binary search is performed to determine the appropriate child pointer. While traversal in 
\insertADT and \remove operations, we follow the proactive approach  as described earlier. Essentially, if we notice that a node's key count has violated the maximum/minimum threshold, we instantly conduct a split/merge action, and the traversal is restarted. The proactive maintenance is shown in  Figure\ref{fig:Tree Operations}.


\input{figs/main_algo_fig}

\subsection{ADT Operations}
\input{algorithm/insert_tree}


\textbf{An \insertADT operation} starts with performing a traversal as described above to locate the leaf node to insert a key and its associated value. It begins with the root node; if it does not exist, it builds a new leaf node and makes it the root with a \textbf{\texttt{CAS}}. If it cannot update the root, another thread has already changed it, and it retries insertion. Method \textup{balanceRoot} splits the root if needed and replaces it with a new root using \texttt{CAS}. If \texttt{CAS} fails, then some other thread must have changed the root, and it returns null. If there is no need to split the root, it will return the current root. 

Lines \ref{alg1:line13}-\ref{alg1:line16} describe the helping mechanism, which makes the data structure lock-free. If any node helpIdx is set to a value other than -1, then the child node at helpIdx is undergoing the split/merge process. In that case, it will help that child finish its split/merge operation. Method \texttt{help} helps $child$ node in split/merge operation and returns the new $curr$ node if it successfully replaces it using $CAS$; otherwise, it returns null. Then, it performs a binary search over $curr$’s keys at line \ref{alg1:line17} to find the correct child pointer. It copies the child pointer into $child$ and stores its index in the pointer array as $cidx$. 

If the child node is a frozen leaf node or an internal node that has reached the threshold, it performs a split/merge operation. It starts by freezing its parent, $curr$, at line \ref{alg1:line20} by setting a special freezing marker on every child pointer, so that no other thread can change the parent node and cause inconsistency. After freezing the parent, it stores the index of the child pointer in helpIdx of the parent node using $CAS$ so that other threads can help in split/merge operation. If \textup{setHelpIdx} fails, that means some other thread has already set the helpIdx, and it retries. 

\textbf{Restructuring} a $child$ is performed at line \ref{alg1:line23} and \ref{alg1:line30} using \textup{balanceLeaf} and \textup{splitInternal} respectively. \textup{balanceLeaf} performs the split/merge operation on the leaf node based on the number of elements and returns the node replaced by the parent node using $CAS$. Similarly, \textup{splitInternal} splits the internal node and returns the new parent node. If in any of the above methods, $CAS$ is failed, then some other thread must have replaced it, and it will return nullptr and retries at line \ref{alg1:line29} and \ref{alg1:line25}. It repeats the same process until it reaches the leaf node. Once it reaches the leaf node, it performs the insert operation in the leaf node at line \ref{alg1:insert_tree}. It returns on success, otherwise it retries.

% \vspace{-0.2cm}\paragraph*{Balancing a Leaf.} This method is invoked when a leaf node is marked inside \textbf{\texttt{insertIntoUruv}} or \texttt{\textbf{deleteFromUruv}} in lines \ref{alg1:line23} and \ref{alg2:line57}. Detail explanation of the method is given in section \ref{sec:additionalalgo}. 
% The parent node, $currNode$, is already frozen, which prevents any thread from updating it. If the number of elements in the leaf is less than the minimum threshold, we either borrow a key from its sibling or merge it at line \ref{alg8:line124}. If the node has more elements than the maximum threshold, we split it at line \ref{alg8:line122}. The count of the leaf node can be inconsistent, so we might not need to split or merge the leaf. Since the node is frozen and cannot be used further, we replace it with a new copy at line \ref{alg8:line126}. For more algorithmic details, please refer to Algorithm \ref{balanceleaf} in the appendix.
% \vspace{-0.2cm}\paragraph*{Split.} Without loss of generality, let us consider the case where we are splitting a leaf node, $currLeaf$. This method creates two new leaf nodes, \textit{leftChild} and \textit{rightChild}, by splitting $currLeaf$ into two equal parts. Due to lack of space, the detailed explanation is mentioned in Appendix \ref{sec:additionalalgo}.
% at line \ref{alg19:line233}. We then check if \textit{newNext} is set or not at line \ref{alg19:line234}. If it is, that would mean some other thread already split the leaf and we use the children created by that thread. We then set \textit{leftChild}’s \textit{next} pointer to \textit{rightChild} at line \ref{alg19:line237}. After this, $currLeaf$’s parent will be copied into a new internal node replacing the pointer to $currLeaf$ with the pointers to the new leaf nodes at line \ref{alg19:line239}. The parent’s keys are adjusted with respect to the new children. Let us call the updated parent copy $newNode$. We now need to replace the parent with $newNode$ atomically. If the parent is the root, we try to update the root to $newNode$ via a \textbf{\texttt{CAS}} at line \ref{alg19:line241}. Otherwise, we atomically replace the pointer to the parent, with a pointer to $newNode$, in the grandparent at line \ref{alg19:line242}. Please refer to Figure \ref{fig:Tree Operations}(a) for a diagrammatic example.

% The significant difference between splitting an internal node and a leaf node is the lack of extra care needed to ensure that the leaf nodes are connected, and appropriate $newNext$ pointers are set for an accurate scan of leaf nodes. The way the parent is updated is slightly different in both cases but does not warrant an explanation as these algorithmic techniques are commonplace in the B$^+$Tree literature. For more algorithmic details, please refer to Algorithm \ref{splitinternal} and Algorithm \ref{splitleaf} in the appendix.
% \vspace{-0.2cm}\paragraph*{Merge.} Similarly, let us consider the case where we need to merge a leaf node, $currLeaf$.

% We first try to merge with or borrow a key from $currLeaf$’s left sibling. If it does not exist, we try with its right sibling. Considering the case when the left sibling exists, we first freeze it at line \ref{alg14:line171}. If the total size of the left sibling and $currLeaf$ is less than the maximum threshold, we merge them. If the total size is too big, we borrow a key from the left sibling.

% To merge them, we combine the keys and values from both siblings into a new leaf node, $newChild$ at line \ref{alg15:line185}. If the $newNext$ pointer is already set at line \ref{alg15:line186}, we set $newChild$ to that instead. Then, we copy the keys and pointers in their parent into a new node, replacing both sibling pointers with a pointer to $newChild$. $newNode$ represents this updated parent copy at line \ref{alg15:line189}. If we decide to borrow from the left sibling instead, we remove the sibling’s last key and make it $currLeaf$’s first key. Since both siblings are frozen, they need to be copied. Then, their parent is copied, and the pointers to the siblings are replaced with the pointers to their copies. The parent’s keys are adjusted with respect to the updated children.

% If their parent is the root, we try to update the root to $newNode$ via a \textbf{\texttt{CAS}} at \ref{alg15:line194}. Otherwise, we atomically replace the pointer to our parent with a pointer to $newNode$ in our grandparent at line \ref{alg15:line195}. Please refer to Figure \ref{fig:Tree Operations}(b) for a diagrammatic example. Notice that, while merging leaf nodes, we need extra care to ensure that all new leaf nodes are connected and appropriate $newNext$ pointers are set for correct range scans. For more algorithmic details, please refer to Algorithm \ref{merge} in the appendix.

\textbf{Insert into a leaf.} In the leaf node, all the updates occur concurrently in the versioned linked list. It first checks if the leaf node is  frozen. If it is, it returns \textup{"Failed"}, realizing that another thread is trying to balance this node. If the node’s count has reached the maximum threshold, it freezes it and returns \textup{"Failed"}. Leaf node is frozen by setting a special freezing mark on \textup{llnode} \textit{next} pointer and the \textit{vhead} pointer. In both the cases, when it returns \textup{"Failed"} insertion will be retried after balancing it. Otherwise, it would insert the key into the versioned lock-free linked list. If another thread is concurrently freezing the leaf node, the insertion into the linked list might fail. If it fails, it will again return \textup{"Failed"} and retries the insertion. If the key is already present in the linked list, it updates that key’s version by adding a new version node in the version list head with a new value. Else it will create a new node in the linked list containing the key and its value in the version node. After the key is inserted/updated in the linked list, its timestamp is set to the current timestamp, which is the linearization point for insertion in the tree.

\textbf{A \remove \op} follows a similar approach as \insertADT. It traverses the tree to the leaf node, where the key is present. The difference in traversal with respect to \insertADT \op is that at line \ref{alg1:line26}, instead of checking the max threshold, it checks for the minimum threshold. Instead of splitting the internal node  at line \ref{alg1:line30}, it merges the internal node. Once a leaf node is found, it checks whether the key is in the linked list. If it is in the linked list, it will update a tombstone value in the version list to mark that key as deleted. If the key is absent, it returns \textup{"Key not Present"}.

\textbf{Delete from Leaf.} If the key is present, this \op creates a versioned node with a tombstone value to set it as deleted. Just like inserting the new versioned node its timestamp is set to the current timestamp. If the key is not present in the linked list it simply returns "Key Not Present". Detail pseudocode is deferred to Appendix A. 


\textbf{\search \op.} Traversal to a leaf node in case of searching doesn't need to perform any balancing. After finding the leaf node, it checks the key in the linked list; if it is present, it returns the value from the version node from the head of the list; otherwise, it simply returns \textup{"Key not Present"}. Before reading the value from the versioned node it checks if the timestamp is set or not. If it is not set, it sets the timestamp as the current timestamp before reading the value. 

\textbf{\rangeQuery.} A range query returns keys and their associated values by a given range from the data. \urv supports a linearizable range query employing a multi-version linked list augmented to the nodes containing keys. This approach draws from Wei et al.\cite{wei+:PPOPP:2021}’s work.  
A global timestamp is read and updated every time a range query is run. The leaf node having a key larger than or equal to the beginning of the supplied range is searched after reading the current time. Then, it chooses a value for the relevant key from the versioned list of values. Figure \ref{fig:Tree Operations}(c) depicts a versioned linked list, with the higher versions representing the most recent modifications. 


By iterating over each versioned node individually, it selects the first value in the list whose timestamp is smaller than the current one. This means that the value was changed before the start of the range query, making it consistent. It continues to add all keys and values that are less than or equal to the end of the given range. Because all of the leaf nodes are connected, traversing them is quick. After gathering the relevant keys and values, the range query will produce the result. 

As a leaf node could be under split or merge, for every leaf node that we traverse, we first check whether their $newNext$ is set. If it is and the leaf pointed to by $newNext$ has a timestamp lower than the range query’s timestamp, it traverses the $newNext$ pointer. This ensures that our range query collects data from the correct leaf nodes. Were the timestamp not part of the leaf node, there is a chance that the range query traverses $newNext$ pointers indefinitely due to repeated balancing of the leaf nodes.