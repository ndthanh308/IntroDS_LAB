This section is intended for an algorithmic reference. A lot of this section has already been explained in the main paper.

\input{algorithm/delete_tree}


\ignore{
% \input{algorithm/search_tree}
% \input{algorithm/range_query}
\input{algorithm/insert_leaf}
\input{algorithm/wfinsert_leaf}
\input{algorithm/balance_root}
\input{algorithm/split_root_leaf}
\input{algorithm/split_root_internal}
\input{algorithm/balance_leaf}
\input{algorithm/delete_leaf}
\input{algorithm/wfdelete_leaf}
\input{algorithm/do_helping}
\input{algorithm/mark_internal}
\input{algorithm/mark_leaf}
}
\vspace{-0.2cm}\paragraph*{Freezing.} Before a node is split or merged, it is frozen along with its parent. Once the node is frozen, it becomes immutable. In an internal node, every child pointer will be marked by setting a designated bit one after the other at line \ref{alg12:line160}. Once all the child pointers are marked, the node is frozen. Unlike internal nodes, leaf nodes are frozen by marking all the linked-list entries one after the other. Nodes in the linked list are marked by marking the two pointers inside them. First, they are marked by setting the designated bit in the \textit{next} pointer at line \ref{alg13:line163}. After this, no more nodes can be added or deleted from the linked list.  Once this is done, the \textit{vhead}s are also marked in the linked-list nodes ensuring that no more updates can happen at any linked-list node at line \ref{alg13:line164}. The linked list becomes immutable once they are all marked, thereby freezing the leaf node. For more algorithmic details, please refer to \texttt{freezeInternal} and \texttt{freezeLeaf} in Fig \ref{fig:freeze}.


\vspace{-0.2cm}\paragraph*{Balancing a Leaf.} In this method leaf node is balanced by splitting or merging based on the number of elements in the node. The parent node, $currNode$, is already frozen, which prevents any thread from updating it. If the number of elements in the leaf is less than the minimum threshold, we either borrow a key from its sibling or merge it at line \ref{alg8:line124}. If the node has more elements than the maximum threshold, we split it at line \ref{alg8:line122}. The count of the leaf node can be inconsistent, so we might not need to split or merge the leaf. Since the node is frozen and cannot be used further, we replace it with a new copy at line \ref{alg8:line126}. Please refer to Figure \ref{fig:freeze} for more algorithmic details.
\input{algorithm/set_help_idx}

% \vspace{-0.2cm}\paragraph*{Insert into a leaf.} We first check if the leaf node is  marked. If it is, we return false at line \ref{alg5:line97} realizing that another thread is trying to balance this node. If the node’s count had reached the maximum threshold, we mark it at line \ref{alg5:line99} and return false at line \ref{alg5:line100}. In both these cases, insertion will be retried after balancing it. If balance was not needed, we insert the key into the versioned lock-free linked-list at line \ref{alg5:line101}. If another thread is marking the leaf node concurrently, then the insertion into the linked-list might fail. If it fails, we will retry the insertion. If the key is already present in the linked-list, we update that key’s version using \texttt{vCAS}. Else we will create a new node in the linked-list containing the key and its value. The moment the key is inserted/updated in the linked-list, it becomes visible to other threads operating on that leaf. 
%This is the linearization point for insertion in the tree. 
% For more algorithmic details please refer to Algorithm \ref{insertintoleaf}.


\vspace{-0.2cm}\paragraph*{Deleting from a leaf.} In the versioned lock-free linked list, the physical deletion of keys never happens. We will search for the key in the linked list at line \ref{alg9:line130}. If the key is not present, deletion is unnecessary; otherwise, the key is marked as deleted by updating its value to tombstone using \texttt{vCAS}. When the value of the key is updated with a tombstone, the delete is visible to other threads operating on that linked list. 

\vspace{-0.2cm}\paragraph*{Split.} Without loss of generality, let us consider the case where we are splitting a leaf node, $currLeaf$. This method creates two new leaf nodes, \textit{leftChild} and \textit{rightChild}, by splitting $currLeaf$ into two equal parts at line \ref{alg19:line233}. We then check if \textit{newNext} is set or not at line \ref{alg19:line234}. If it is, that would mean some other thread already split the leaf, and we use the children created by that thread. We then set \textit{leftChild}’s \textit{next} pointer to \textit{rightChild} at line \ref{alg19:line237}. After this, $currLeaf$’s parent will be copied into a new internal node replacing the pointer to $currLeaf$ with the pointers to the new leaf nodes at line \ref{alg19:line239}. The parent’s keys are adjusted with respect to the new children. Let us call the updated parent copy $newNode$. We now need to replace the parent with $newNode$ atomically. If the parent is the root, we try to update the root to $newNode$ via a \textbf{\texttt{CAS}} at line \ref{alg19:line241}. Otherwise, we atomically replace the pointer to the parent with a pointer to $newNode$, in the grandparent at line \ref{alg19:line242}. Please refer to Figure \ref{fig:Tree Operations}(a) for a diagrammatic example.\\

The significant difference between splitting an internal node and a leaf node is the lack of extra care needed to ensure that the leaf nodes are connected and appropriate $newNext$ pointers are set for an accurate scan of leaf nodes. The way the parent is updated is slightly different in both cases but does not warrant an explanation as these algorithmic techniques are commonplace in the B$^+$Tree literature. Please refer to Figure \ref{merge} for more algorithmic details.

\input{algorithm/insert_leaf}

\vspace{-0.2cm}\paragraph*{Merge.} Similarly, let us consider the case where we need to merge a leaf node, $currLeaf$. We first try to merge with or borrow a key from $currLeaf$’s left sibling. If it does not exist, we try with its right sibling. Considering the case when the left sibling exists, we first freeze it at line \ref{alg14:line171}. If the total size of the left sibling and $currLeaf$ is less than the maximum threshold, we merge them. If the total size is too big, we borrow a key from the left sibling.

To merge them, we combine the keys and values from both siblings into a new leaf node, $newChild$ at line \ref{alg15:line185}. If the $newNext$ pointer is already set at line \ref{alg15:line186}, we set $newChild$ to that instead. Then, we copy the keys and pointers in their parent into a new node, replacing both sibling pointers with a pointer to $newChild$. $newNode$ represents this updated parent copy at line \ref{alg15:line189}. If we decide to borrow from the left sibling instead, we remove the sibling’s last key and make it $currLeaf$’s first key. Since both siblings are frozen, they need to be copied. Then, their parent is copied, and the pointers to the siblings are replaced with the pointers to their copies. The parent’s keys are adjusted with respect to the updated children.
\input{algorithm/merge}

If their parent is the root, we try to update the root to $newNode$ via a \textbf{\texttt{CAS}} at \ref{alg15:line194}. Otherwise, we atomically replace the pointer to our parent with a pointer to $newNode$ in our grandparent at line \ref{alg15:line195}. Please refer to Figure \ref{fig:Tree Operations}(b) for a diagrammatic example. Notice that while merging leaf nodes, we need extra care to connect all new leaf nodes and appropriate $newNext$ pointers are set for correct range scans. Please refer to Figure \ref{merge} for more algorithmic details.
\vspace{-0.2cm}\paragraph*{Thread Helping.} To make our data structure lock-free, we do helping. Before performing any split or merge operation, each thread first tries to atomically update the variable, $helpIdx$, using \cas with the index of the child on which the operation will be performed at line \ref{alg17:line218}. If $helpIdx$ is not updated successfully, then another thread has already set it to a child, and this thread will be redirected to help that child’s balancing operation. So by keeping track of the index that needs to be helped, we ensure threads help each other to complete the rebalancing of the data structure.
\input{algorithm/borrow_helper}

Similarly, while traversing in insertion or deletion, we check if the $helpIdx$ is set for every node we go through at lines \ref{alg1:line13} and \ref{alg2:line48}, respectively. If it is, we help that node; otherwise, we proceed as usual. For more algorithmic details, please refer to Figure \ref{fig:freeze}.


\input{algorithm/wfinsert_leaf}

% \input{algorithm/merge_helper}
% \input{algorithm/split_internal}
% \input{algorithm/split_leaf}
