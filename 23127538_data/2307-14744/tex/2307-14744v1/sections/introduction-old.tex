Concurrent data structures have become very important due to their significant performance benefits over sequential data structures in multicore environments. Active research continues in this area resulting in new sophisticated and efficient concurrent data structures every year. Naive concurrency tends to use mutexes. When multiple threads need to update a data structure, access is granted to only one thread at a time. This technique ensures updates do not get corrupted. However, there is a drawback. Since mutexes enable mutual exclusion, a thread, $t_1$, has to potentially wait for another thread, $t_2$, to finish its operation before accessing the data structure. If thread $t_2$ crashes or slows down considerably, thread $t_1$ will end up waiting indefinitely or for a long time. This will affect the data structure’s performance.

Another type of concurrency called non-blocking concurrency can potentially mitigate the drawback. In this approach, concurrency is achieved without using mutexes. Atomic operations like \texttt{compare-and-swap (CAS)} are used to achieve necessary modifications in the data structure. We deal with lock-free and wait-free non-blocking concurrency. A significant attraction of lock-free concurrency is its progress guarantee: \textit{If multiple threads perform operations on a lock-free data structure, at least one of them will complete its operation given enough time.} A much stronger progress guarantee is provided by wait-free concurrency, wherein operations finish in a finite time.

Many lock-free data structures have been developed in recent years, including but not limited to linked lists, BSTs and queues. However, not much work is done for a lock-free B$^+$Tree. According to our literature review, Anastasia et al.\cite{braginsky+} proposed the first and only lock-free B$^+$Tree. Their tree uses a data structure, chunk, that can perform concurrent insert, delete and search operations on their nodes. Chunk is a continuous memory block where these operations can be performed with the help of a  lock-free linked list. We have developed an efficient lock-free ranged tree data structure, called Uruv, that is inspired by the B$^+$Tree’s design. Updates to Uruv are lock-free, and lookups and range queries are wait-free.

The state of a data structure is defined by the keys and the data it contains. Sometimes, a subset of keys within some given range and their data is required. Range queries are operations that return a set of all the keys and their data in a data structure within a given range. The B$^+$Tree is a ranged index that inherently supports ranged queries. Making a range query concurrent with other operations is essential for data structure performance in a multi-threaded environment. A naive way to perform a range query is by locking a part of the data structure that belongs to the range. This faces the same performance problems we discussed regarding lock-based data structures. A lock-free range query achieves this result without using mutexes, enabling lock-free performance guarantees. We build on the work of Wei et al.\cite{wei2021constant}, who propose a constant-time lock-free snapshot algorithm. Their algorithm works by storing multiple versions of keys in a data structure. Each key’s version is identified by timestamp and stores data the key was mapped to at that time. (TO-DO Add related work for range query)

We begin by summarizing the B$^+$Tree's design in Section \ref{sec:Preliminaries}. We then explain Uruv's design in Section \ref{sec:Design}. We detail important algorithms in Section \ref{sec:main_algo} and have detailed other algorithmic details in the Appendix. (TO-DO Update this paragraph once every later section is completed)