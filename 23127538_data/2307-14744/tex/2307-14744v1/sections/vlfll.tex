
% This data structure allows linearizable wait-free range queries in Uruv. The linked-list is based on Herlihy's linked-list \cite{Maurice+:AMP:book:2012}. We have also used  \cite{wei+:PPOPP:2021} 's work, and we use it inside our leaf nodes to store keys and their data. Each node in the linked-list has a key and pointers to the next linked-list node and the head of the versioned list. A versioned list contains various values the key had at different times. Each node in the versioned list contains a value, the time when the value was updated, and a pointer to that key's previous version. Please refer to figure \ref{fig:vlfll} for linked-list details. Nodes in the versioned list are sorted in descending order by their timestamp. We refer to these nodes as versioned nodes. A significant difference with \cite{Maurice+:AMP:book:2012} is the lack of physical deletion of nodes. A node is deleted by marking its versioned list’s head. Since there is no physical deletion, searching a node does not require any help unlike in Herlihy's linked-list.



When we insert a new key and its value into the liked list, we first find the predecessor and successor nodes of the key to be inserted at line \ref{alg21:line252}. Unlike Herlihy’s linked list, searching a node requires no help. We traverse the linked list until we reach the first node whose key is greater than or equal to the one we are inserting. If the key is already present, we have to update its value in the versioned list by adding a \texttt{Vnode} containing the new value at the versioned list’s head, $vhead$, atomically using \texttt{vCAS} at line \ref{alg21:line260}. If the node is not present in the linked list, we atomically add the new \texttt{llNode} between the previously found predecessor and successor nodes at line \ref{alg21:line264}. Once the \texttt{llNode} or \texttt{Vnode} is added to the linked list, we update the node's timestamp using the \texttt{initTs} method at line \ref{alg21:line265} and line \ref{alg24:line281}.


% \input{algorithm/linked_list/insert_ll}

When we need to read the value of a key, say at time t, we iterate the key’s versioned list and return the first value whose timestamp is lesser than or equal to t. This ensures we return a valid value if the reading thread slows down. The linearization point of the read is just after the linearization point of the update that inserted that versioned node.

When deleting a key, unlike a regular lock-free linked list where we mark the next pointer, we instead mark the key’s versioned list head, $vhead$, by updating its value to some unique marker value. For more algorithmic details, refer to Figure \ref{llfind}, \ref{llinsert} and \ref{wfllinsert}.
\input{algorithm/linked_list/find_ll}

% \input{algorithm/linked_list/init_ts}
% \input{algorithm/linked_list/read}
% \input{algorithm/linked_list/vCAS}
% \input{algorithm/linked_list/wfVCAS}
% \input{algorithm/linked_list/WFinsert_ll}

