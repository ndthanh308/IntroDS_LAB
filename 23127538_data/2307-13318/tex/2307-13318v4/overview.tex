\section{An Overview of Our Approach}
\label{sec:overview}
Consider the affine program \( P_1 \) in Figure~\ref{fig:ExampleLoopAndTransformedLoop}. Our approach has three parts, namely control flow transformation, invariant computation and invariant propagation.  

\smallskip
\noindent\emph{Control Flow Transformation}. For the non-nested loop \(P_1\), we extract each execution path from the loop entry to the exit and transform it into the form of loop \(P_2\). Each \textbf{case} statement corresponds to a possible path in the original loop with a path condition $\phi$ of taking the path specified by 
the conjunction of a conditional formula $\phi_c$  and an assignment formula $\phi_a$. For example, in the first case of \(P_2\) that corresponds to the case of entering the if-branch in \(P_1\), we have \(\phi_a\) is 
\((x' = x + 1 \land y' = y + 1)\), \(\phi_c\) is \(x > 49\), and \(\phi\) is \(\phi_a \land \phi_c\).

% Figure environment removed

Then, an ATS in Figure~\ref{fig:ATSforTransformedLoop} is directly derived from the transformed program. In this example, each \textbf{case} statement is considered as an independent location in the ATS, e.g., the location $\tsLoc_1$ stands for the first \textbf{case} in $P_2$. The transitions between the locations are derived from the jumps between different paths, where each transition guard $\tsGuardcond$ for a transition $\tsTran$, can be obtained through the formula:
$$
\tsGuardcond:= \phi_c \wedge \phi'_c[x'/x] \wedge \phi_a\wedge G\wedge G[x'/x]
$$
where, \(\phi_a\) and \(\phi_c\) represent the assignment and conditional formulas at the transition's start location, \(\phi'_c\) represents the conditional formula at the transition's end location, and \(G\) is the loop guard. After the \LTS{} is constructed, we apply the approaches~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} in Farkas' Lemma combined with the technique of invariant propagation to obtain invariants at all locations, and group them disjunctively together to obtain result invariants for original loop.
Note that the construction of the ATS is the key connection to apply Farkas' Lemma. 

\smallskip
\noindent\emph{Invariant Computation.} We first establish affine invariant templates at each location in the ATS by setting: 
$$
\tsMap(\tsLoc_{i}) := \fkCoeff_{\tsLoc_{i},1}x + \fkCoeff_{\tsLoc_{i},2}y + \fkConst_{\tsLoc_{i}} \geq 0\ ,\forall i \in \{1,2\}
$$
where, $\fkCoeff_{\tsLoc_{i},1},\fkCoeff_{\tsLoc_{i},2},\fkConst_{\tsLoc_{i}}$ are unknown coefficients to be resolved. Then, we generate the constraints from the initialization as well as consecution conditions via the Farkas' tabular in Figure~\ref{tab:farkas} and derive the initialization tabular and consecution tabular as shown in Figure~\ref{tab:farkasinitcons}. 
Setting \(\varphi=\theta\) and \(\psi=\eta(\tsLoc^*)\) in Theorem~\ref{thr:farkas}, the initialization of $\tsInitcond \models \tsMap(\tsLoc^*)$ results in linear constraints, 
while the consecution condition $\tsMap(\tsLoc) \wedge \tsGuardcond \models \tsMap(\tsLoc')'$ by setting \(\varphi=\tsMap(\tsLoc) \wedge \rho\) and \(\psi=\eta(\tsLoc')'\) results in quadratic constraints since we have a fresh $\lambda$, which we denote as $\mu$, multiplied by $\tsMap(\tsLoc)$.

% Figure environment removed



In this context, we adopt a unified notation by employing $\eta(\tsLoc)$ to represent both affine expressions and affine inequalities interchangeably throughout the manuscript. To resolve the quadratic constraints from the consecution, the previous approach~\cite{DBLP:conf/sas/SankaranarayananSM04} has considered heuristics to guess the value of the multiplier $\mu$ through either practical rules such as factorization or setting $\mu$ manually to $0$ or $1$. These settings relax the original consecution definition into two stronger forms:

\begin{itemize}
    \item \textbf{Local Consecution}: For transition $\tau : \langle \tsLoc_i, \tsLoc_j, \tsGuardcond \rangle$, \(\tsGuardcond \models \tsMap(\tsLoc_j)' \geq 0\),
    \item \textbf{Incremental Consecution}: For transition $\tau : \langle \tsLoc_i, \tsLoc_j, \tsGuardcond \rangle$, \(\tsGuardcond \models \tsMap(\tsLoc_j)' \geq \tsMap(\tsLoc_i)\).
\end{itemize}


Then, we collect the derived constraints to constitute a formula $\Phi$ in CNF, which further expands into a DNF \(\Phi'\). Note that each disjunctive clause in the DNF \(\Phi'\) is an affine assertion defining a polyhedral cone, and we solve for the unknown coefficients of the templates by computing the generators of these polyhedral cones. We present a polyhedral cone in the DNF \(\Phi'\) of the ATS in Figure~\ref{tab:geninv}, along with corresponding generators, as shown in Figure~\ref{tab:cs}, where "point" means a single vector, "ray" means a vector that can be scaled by an arbitrary positive value, and "line" means a vector that can be scaled by any positive or negative value. When putting the generators back to invariants, we obtain the invariants shown in the right part of Figure~\ref{tab:geninv}. The resulting disjunctive invariant is the disjunction of invariants at all locations over an \LTS{} \( \Gamma \), corresponding to the invariants required on different loop paths.

\smallskip
\noindent{\em Invariant Propagation.} In the preceding exposition, the computation of conjunctive affine invariants adheres to existing approaches~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable}. However, the strategies employed to resolve invariants at each location across the entire \(\LTS\) result in a significant decline in computational efficiency. To address this limitation, we introduce a propagation technique predicated on existing invariant computation results:

% Figure environment removed

% Figure environment removed


Consider the affine transition system $\Gamma$ in Figure~\ref{fig:ATSforTransformedLoop}. Its underlying directed graph $DG(\Gamma)$ is given in Figure~\ref{fig:ExampleDirectedGraph}. We first compute the invariant \(\tsMap(\tsLoc_{2}):= y = 50\wedge 0 \leq x \leq 49\) at the initial location \(\tsLoc_2\) as above. Then, we can eliminate all transitions pointing to \( \tsLoc_2 \) (the correctness of which is demonstrated in the following section), obtaining the graph in Figure~\ref{fig:ExampleDirectedGraphEliminateInit}. Notably, there exists a topological order, where \( \tsLoc_2\) precedes \( \tsLoc_1 \). Thus, we propagate the invariants at \( \tsLoc_2 \) along the transition \( \tsTran_4 \)'s transition guard $\tsGuardcond$ to establish the initial condition \(\tsInitcond\) of the \LTS{} over \( \tsLoc_1 \) in Figure~\ref{fig:ExampleDirectedGraphAfterCompute}, which is derived from removing \( \tsLoc_2 \) after propagation. Finally, by solving the invariants for the simplified ATS instead of the original ATS, we obtain the affine invariant \(\tsMap(\tsLoc_{1})= (x=y \wedge 50 \leq x \leq 99)\). Note that our invariant propagation is different from abstract interpretation, see Section~\ref{sec:related_work} for details.

Moreover, \(\eta(\tsLoc_{1})\) corresponds to the invariant within the loop, specifically representing the invariant at the first \textbf{case}. For the exit state \( x = 100 \), the disjunctive invariant generated within the loop, in conjunction with the loop exit condition \(\lnot G\), derives the program state \( x = 100\) outside the loop through stepwise deduction.