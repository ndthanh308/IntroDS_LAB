\section{Introduction}

An invariant at a program location is an assertion that over-approximates the set of program states reachable to that location, i.e., every reachable program state to the location is guaranteed to satisfy the assertion. Since invariants provide an over-approximation for reachable program states, they play a fundamental role in program verification and can be used for safety~\cite{DBLP:books/daglib/0080029,DBLP:conf/pldi/PadonMPSS16,DBLP:conf/cav/AlbarghouthiLGC12}, reachability~\cite{DBLP:conf/tacas/ColonS01,DBLP:conf/cav/BradleyMS05,DBLP:conf/sas/AliasDFG10,DBLP:conf/vmcai/PodelskiR04,DBLP:conf/ictac/ChenXYZZ07,DBLP:conf/fm/DavidKKL16,DBLP:conf/pldi/AsadiC0GM21} and time-complexity~\cite{DBLP:journals/toplas/ChatterjeeFG19} analysis.
Invariant generation targets the automated  generation of invariants which can be used to aid the verification of critical program properties.

Automated approaches for invariant generation have been studied for decades and there have been an abundance of literature along this line of research. From different program objects, invariant generation targets numerical values (e.g., integers or real numbers)~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/sas/Rodriguez-CarbonellK04,DBLP:conf/popl/SinghPV17,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/vmcai/BoutonnetH19}, arrays~\cite{DBLP:conf/vmcai/LarrazRR13,DBLP:conf/pldi/SrivastavaG09}, pointers~\cite{DBLP:conf/pldi/LeZN19,DBLP:journals/jacm/CalcagnoDOY11}, algebraic data types~\cite{DBLP:journals/pacmpl/KSG22}, etc. By different methodologies, invariant generation can be solved by abstract interpretation~\cite{DBLP:conf/popl/CousotC77,DBLP:conf/popl/CousotH78,DBLP:conf/vmcai/BoutonnetH19,DBLP:conf/sas/GopanR07}, constraint solving~\cite{DBLP:conf/vmcai/Cousot05,DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/GulwaniSV08,DBLP:conf/pldi/Chatterjee0GG20}, inference~\cite{DBLP:conf/oopsla/DilligDLM13,DBLP:journals/jacm/CalcagnoDOY11,DBLP:journals/fmsd/SharmaA16,DBLP:conf/cav/0001LMN14,DBLP:conf/sigsoft/Xu0W20,DBLP:conf/cav/GanX0ZD20,DBLP:conf/fmcad/SomenziB11,DBLP:conf/tacas/McMillan08,DBLP:conf/sas/DonaldsonHKR11}, recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18}, machine learning~\cite{DBLP:conf/popl/0001NMR16,DBLP:conf/pldi/HeSPV20,DBLP:conf/pldi/YaoRWJG20,DBLP:conf/iclr/RyanWYGJ20}, 
data-driven approaches~\cite{DBLP:conf/pldi/LeZN19,DBLP:conf/esop/0001GHALN13,DBLP:conf/icse/NguyenKWF12,DBLP:conf/icse/CsallnerTS08,DBLP:conf/cav/ChenHWZ15,FSE2022}, etc. Most results in the literature consider a strengthened version of invariants, called \emph{inductive invariants}, that requires the inductive condition that the invariant at a program location is preserved upon every execution back and forth to the location.

In this work, we consider the automated generation of disjunctive invariants, i.e., invariants that are in the form of a disjunction of assertions. Compared with conjunctive invariants, disjunctive invariants capture disjunctive features such as multiple phases and mode transitions in loops. Although extensive research has been conducted on conjunctive invariant generation, verification of programs with complex disjunctive loops still demands a more precise and scalable approach, rather than merely generating conjunctive invariants at the loop entry point to summarize the entire loop.

Moreover, most of the existing disjunctive invariant analyses rely on specific program patterns, such as alternating loop paths~\cite{DBLP:conf/cav/SharmaDDA11} or periodic regular loops~\cite{DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21}, which cannot be effectively generalized to real-world programs with arbitrary execution traces. Methods based on abstract interpretation or symbolic execution often fail to converge, or converge to low-precision invariants, when dealing with loops that are deeply nested or have large constant iteration counts. To address this, we propose a modular approach capable of handling complex loops and efficiently mitigating the computational explosion caused by the interleaving of paths in disjunctive loops.

We use constraint solving to generate real-valued affine disjunctive invariants. 
A typical constraint solving method is via Farkas' Lemma~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,DBLP:conf/cav/JiFFC22,oopsla22/scalable} 
that provides a complete characterization for affine invariants. However, the application of Farkas' Lemma is mostly limited to the conjunction of affine inequalities. The question on how to leverage Farkas' Lemma to affine disjunctive invariants remains to be a challenge. In this paper, we focus on the generation of affine disjunctive invariants in affine loops. 
An affine loop is a while loop where all conditional and assignment statements are in the form of linear expressions.

\smallskip
\noindent{\em Our contributions.} First,
we introduce a novel control flow transformation that extracts loop paths (from entry to exit) as standalone locations in a transition system and establishes transitions between them. 
Second, to alleviate the exponential computational overhead introduced by the control flow transformation, we propose an invariant propagation technique that propagates already-computed invariants to locations whose invariants yet need to be computed as much as possible.
Third, we fully resolve the infeasible situation in the application of Farkas' Lemma~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} and extend our approach to nested loops through loop summary. 
Fourth, we implement our approach as a prototype \ToolName\footnote{The tool implementation is available on GitHub: \url{https://github.com/WindOctober/DInvG}.}. Experimental evaluation with various state-of-the-art verification tools using over $100$ benchmarks from SV-COMP 2023~\cite{svcomp} and \cite{DBLP:conf/vmcai/BoutonnetH19}, shows that our approach is both tight (in the accuracy of the generated invariant) and is time efficient for real-valued disjunctive affine invariant generation. 

The remainder of this paper is structured as follows. Sec.~\ref{sec:Preliminary} revisits the fundamental definitions of affine transition systems and invariants, providing a variant of \textit{Farkas' Lemma} as well as the basic definitions of polyhedra. Sec.~\ref{sec:overview} offers an overview of how our tool \ToolName\ transforms programs and solves for disjunctive invariants. In Sec.~\ref{sec:alg}, we formalize the definition of control flow transformation and extract the corresponding affine transition systems, present the pseudocode for invariant propagation as well as optimizations for nested loop and infeasible traces, and prove that the disjunctive invariants generated are inductive. Sec.~\ref{sec:exp} demonstrates the efficiency and precision advantages of \ToolName\ compared to several state-of-the-art tools and conducts an ablation study on invariant propagation. Sec.~\ref{sec:related_work} compares our method with related verification approaches, elaborating on the conceptual and implementation differences between invariant propagation and control flow transformation.