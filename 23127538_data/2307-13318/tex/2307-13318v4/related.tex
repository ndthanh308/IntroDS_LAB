
\section{Related Works}
\label{sec:related_work}
Our methodology enhances conjunctive affine invariants by integrating optimizations from prior research~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable,DBLP:conf/cav/JiFFC22} and utilizing control flow transformation techniques to extend them to disjunctive forms. A principal contribution of this paper is the mitigation of computational inefficiencies resulting from the exponential state space expansion associated with disjunctive extensions, achieved through invariant propagation. Consequently, this approach distinguishes our work from existing studies.
The work~\cite{DBLP:conf/pldi/GulwaniSV08} generates disjunctive invariants by predefining disjunctive templates, heuristically selecting physical cut points (while we select abstract locations from loop paths) and transforming the quadratic constraints from Farkas' Lemma into SAT solving.
Other approaches for conjunctive affine invariant generation include ~\cite{DBLP:conf/atva/OliveiraBP17,DBLP:conf/cav/GuptaR09}.
These approaches propose completely different techniques, and thus are orthogonal to our approach. 


Polynomial invariant generation~\cite{DBLP:conf/dagstuhl/Kapur05,DBLP:journals/fcsc/YangZZX10,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/lics/HrushovskiOP018,DBLP:conf/issac/Rodriguez-CarbonellK04,DBLP:conf/vmcai/Cousot05,DBLP:conf/sas/AdjeGM15,DBLP:journals/fcsc/LinWYZ14,DBLP:conf/cav/ChenHWZ15,DBLP:conf/atva/OliveiraBP16,DBLP:conf/issac/HumenbergerJK17,DBLP:conf/popl/SankaranarayananSM04} has been widely investigated.
Most of these approaches consider conjunctive polynomial invariants only. 
Compared with conjunctive polynomial invariants, disjunctive affine invariants capture the precise feature of phase and mode changes in affine loops, and therefore are more precise. 

The works~\cite{DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21} are based on path dependency automata, requiring precise estimates of the number of iterations in loops, which limits their analysis to programs with regular alternation and inductive variables (computable general terms). The work~\cite{DBLP:conf/cav/SharmaDDA11} studies the detection of multiphase disjunctive invariants. Multiphase invariants are a special case of our control flow transformation since each phase in a multiphase loop cannot go back to previous phases, while in our control flow transformation, locations can go back and forth via transitions. Thus, we have a wider class of disjunctive invariants as compared with~\cite{DBLP:conf/cav/SharmaDDA11}. 

Our control flow transformation is related to control flow refinement~\cite{DBLP:conf/emsoft/BalakrishnanSIG09,DBLP:conf/pldi/GulwaniJK09,DBLP:journals/pacmpl/CyphertBKR19,DBLP:conf/cav/SilvermanK19} in the literature. 
These approaches mostly focus on representing the control flow of multiple loop iterations as regular expressions and refine these regular expressions by various approaches such as abstract domains, simulation relation and even invariant generation to reduce infeasible paths. 
Our control flow transformation considers the loop body within a single loop iteration, and is dedicated to the application of Farkas' Lemma. Thus, our control flow transformation has a different focus compared with these results. 
Moreover, the use of Farkas' Lemma can circumvent the issue that finer control flow may not always lead to finer analysis in control flow refinement~\cite{DBLP:journals/pacmpl/CyphertBKR19}. 

Our invariant propagation is related to abstract interpretation~\cite{DBLP:conf/popl/CousotH78,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/popl/SinghPV17,DBLP:conf/sas/GopanR07,DBLP:conf/vmcai/BoutonnetH19,DBLP:journals/entcs/HenryMM12}. The main difference is that it  propagates the \emph{already-computed} invariants (via Farkas' Lemma) to yet not computed locations as much as possible to minimize the invariant generation computation, while abstract interpretation usually requires an involved fixed-point iteration to \emph{compute} invariants.  


Recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18} works well over programs with specific structure that ensures closed form solutions. 
For example, the most related recurrence analysis approach~\cite{oopsla23} (that also targets disjunctive invariants) solves the exact invariant over the class of loops with (ultimate) strict alternation between different modes.  
Compared with recurrence analysis, our approach does not require specific program structure to ensure closed form solution, but is less precise over programs that can be solved exactly by recurrence analysis.


Finally, we compare our approach with other methods such as machine learning, inference and data-driven approaches. 
Unlike constraint solving that can have an accuracy guarantee for the generated invariants based on the constraints, these methods cannot have an accuracy guarantee. 
Furthermore, machine learning and data-driven approaches themselves cannot guarantee that the generated assertions are indeed invariants. 
Moreover, our approach can generate invariants \emph{without} the need of a goal property, while several approaches (such as IC3~\cite{DBLP:conf/fmcad/SomenziB11}, CLN2INV~\cite{DBLP:conf/iclr/RyanWYGJ20}, \cite{FSE2022}) usually requires a goal property.
Note that the invariant generation without a given goal property is a classical setting (see e.g. ~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/popl/CousotH78}), and has applications in loop summary and probabilistic program verification (see e.g.~\cite{DBLP:conf/cav/ChakarovS13,DBLP:conf/pldi/WangS0CG21}). 

LLM-based invariant generation methods~\cite{AutoSpec} performs poorly on certain complex programs exhibiting disjunctive features. Those large-scale models have been unable to precisely comprehend the disjunctive properties inherent in these programs, and the invariants they produce often necessitate iterative interaction with Frama-C until an invariant that can be successfully verified by Frama-C is generated.