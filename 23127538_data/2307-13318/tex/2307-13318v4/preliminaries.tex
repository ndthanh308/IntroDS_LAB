\section{Preliminaries}
\label{sec:Preliminary}
Below we revisit affine transition systems~\cite{DBLP:conf/sas/SankaranarayananSM04} and their associated invariants, elucidate Farkas' Lemma, and outline fundamental principles from polyhedra theory. It is important to note that, within the scope of this paper, we treat linear and affine concepts equivalently.


\subsection{Affine Transition Systems and Invariants}

An \emph{affine inequality} over a set $V=\{x_1,\dots,x_n\}$ of real-valued variables is of the form $a_{1}x_{1} + \dots + a_{n}x_{n} + b \ge 0$, where $a_i$'s and $b$ are real coefficients. 
An \emph{affine assertion} over $V$ is a conjunction of affine inequalities over $V$. 

An affine transition system possesses a finite number of locations as well as real-valued variables, and specifies transitions between locations with affine guards and affine updates on the values of the variables. 

\begin{definition}[Affine Transition Systems~\cite{DBLP:conf/sas/SankaranarayananSM04}]\label{def:lts}
An \emph{affine transition system} (\LTS) is a tuple $\Gamma=\langle \tsVars, \tsVars', \tsLocs, \tsTrans, \tsLoc^*, \tsInitcond \rangle$:
\begin{itemize}
    \item 
    $\tsVars$ is a finite set of real-valued variables and $\tsVars'=\{\tsVar' \mid \tsVar \in \tsVars\}$ is the set of primed variables.
    \item 
    $\tsLocs$ is a finite set of \emph{locations} and $\tsLoc^*\in\tsLocs$ is the initial location.
    \item 
    $\tsTrans$ is a finite set of \emph{transitions} where each transition $\tsTran$ is a triple $\langle \tsLoc, \tsLoc', \tsGuardcond \rangle$ from location $\tsLoc$ to location $\tsLoc'$ with the guard affine assertion $\tsGuardcond$ over $\tsVars \cup \tsVars'$.
    \item
    $\tsInitcond$ is a disjunction of affine assertions over $\tsVars$ that specifies the initial condition at $\tsLoc^*$.  
\end{itemize}
The directed graph $\mbox{\sl DG}(\Gamma)$ of the \LTS{} $\Gamma$ is defined as the graph where the vertices are the locations of $\Gamma$ and there is an edge $(\tsLoc,\tsLoc')$ if and only if there is a transition $\langle \tsLoc, \tsLoc', \tsGuardcond \rangle$ with source location $\tsLoc$ and target location $\tsLoc'$.
\end{definition}

The intuition of an ATS $\Gamma=\langle \tsVars, \tsVars', \tsLocs, \tsTrans, \tsLoc^*, \tsInitcond \rangle$ is as follows. 
Each variable $\tsVar \in \tsVars$ represents the current value of the variable and each primed variable $\tsVar' \in \tsVars'$ represents the next value of its unprimed variable $\tsVar \in \tsVars$ after one step of transition. 
The transition $\langle \tsLoc, \tsLoc', \tsGuardcond \rangle$ specifies the jump from the current location $\tsLoc$ to the next location $\tsLoc'$ with the guard condition $\tsGuardcond$ specifying the condition to enable the transition. The guard condition involves both the current values (represented by $\tsVars$) and the next values (by $\tsVars'$), so that it can specify the relationship between the current and next values.  

Below we describe the semantics of an ATS. 
A \emph{valuation} over a finite set $V$ of variables is a function $\tsEval : V \rightarrow \Rset$ that assigns to each variable $\tsVar \in V$ a real value $\tsEval(\tsVar) \in \Rset$. 
We mostly consider valuations over the variables $\tsVars$ of an \LTS{} and simply abbreviate ``valuation over $\tsVars$'' as ``valuation'' (i.e., omitting $\tsVars$). 
Given an \LTS, a \emph{configuration} is a pair $(\tsLoc, \tsEval)$ with the intuition that $\tsLoc$ is the current location and $\tsEval$ is a valuation that specifies the current values for the variables. 

Given an affine assertion $\tsAssertphi$ and a valuation $\tsEval$ over a variable set $V$, we write $\tsEval \models \tsAssertphi$ to mean that $\tsEval$ satisfies $\tsAssertphi$, i.e., $\tsAssertphi$ is true when one substitutes the corresponding values $\tsEval(\tsVar)$ into all the variables $\tsVar$ in $\tsAssertphi$. Given an \LTS{} $\Gamma$, two valuations $\tsEval,\tsEval'$ and an affine assertion $\tsAssertphi$ over $\tsVars \cup \tsVars'$, we write $\tsEval, \tsEval' \models \tsAssertphi$ to mean that $\tsAssertphi$ is true when one substitutes every variable $\tsVar \in \tsVars$ by $\tsEval(\tsVar)$ and every variable $\tsVar' \in \tsVars'$ with $\tsEval'(\tsVar)$ in $\tsAssertphi$. Moreover, given two affine assertions $\tsAssertphi,\tsAssertpsi$ over a variable set $V$, we write $\tsAssertphi \models \tsAssertpsi$ to mean that $\tsAssertphi$ implies $\tsAssertpsi$, i.e., for every valuation $\tsEval$ over $V$ we have that $\tsEval \models \tsAssertphi$ implies $\tsEval \models \tsAssertpsi$. The case of disjunction of affine assertions is similar.

The semantics of an \LTS{} $\Gamma$ is given by its  paths. 
A \emph{path} $\tsPath$ of the \LTS{} $\Gamma$ is a finite sequence of configurations $(\tsLoc_0,\tsEval_0) \dots (\tsLoc_k,\tsEval_k)$ such that 
\begin{itemize}
    \item(\textbf{Initialization}) $\tsLoc_0 = \tsLoc^*$ and $\tsEval_0 \models \tsInitcond$, and 
    \item(\textbf{Consecution}) for every $0 \le j \le k-1$, there exists a transition $\tsTran = \langle \tsLoc, \tsLoc', \tsGuardcond \rangle$ such that $\tsLoc = \tsLoc_{j}$, $\tsLoc' = \tsLoc_{j+1}$ and $\tsEval_{j},\tsEval_{j+1} \models \tsGuardcond$. 
\end{itemize}

We say that a configuration $(\tsLoc, \tsEval)$ is \emph{reachable} if there exists a path  $(\tsLoc_0,\tsEval_0) \ldots$ $(\tsLoc_k,\tsEval_k)$ such that $(\tsLoc_k,\tsEval_k)=(\tsLoc, \tsEval)$. 
An \emph{invariant} at a location $\tsLoc$ of an \LTS{} is an assertion $\tsAssertphi$ such that for every path $\tsPath = (\tsLoc_0,\tsEval_0) \dots (\tsLoc_k,\tsEval_k)$ of the \LTS{} and each $0 \le i \le k$, it holds that $\tsLoc_i = \tsLoc$ implies $\tsEval_i \models \tsAssertphi$. An invariant $\tsAssertphi$ is \emph{affine} if $\tsAssertphi$ is an affine assertion over the variable set $\tsVars$, and is \emph{disjunctively affine} if $\tsAssertphi$ is a disjunction of affine assertions. 

In invariant generation, one often investigates a strengthened version of invariants called \emph{inductive invariants}. In this work, we present affine inductive invariants in the form of inductive affine assertion maps~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} as follows. 

An \emph{affine assertion map} (AAM) over an \LTS{} is a function $\tsMap$ that maps every location $\tsLoc$ of the \LTS{} to an affine assertion $\tsMap(\tsLoc)$ over the variables $\tsVars$. An AAM $\tsMap$ is called \emph{inductive} if the following holds:
\begin{itemize}
    \item (\textbf{Initialization})  $\tsInitcond \models \tsMap(\tsLoc^*)$;
    \item (\textbf{Consecution}) For every transition $\tsTran = \langle \tsLoc, \tsLoc', \tsGuardcond \rangle$, we have that $\tsMap(\tsLoc) \wedge \tsGuardcond \models \tsMap(\tsLoc')'$, where $\tsMap(\tsLoc')'$ is the affine assertion obtained by replacing every variable $\tsVar \in \tsVars$ in $\tsMap(\tsLoc')$ with its next-value counterpart $\tsVar' \in \tsVars'$.
\end{itemize}
By a straightforward induction on the length of a path under an \LTS, one could verify that every affine assertion in an inductive AAM is indeed an invariant. 


\subsection{Farkas' Lemma and Polyhedra}

Farkas' Lemma~\cite{FarkasLemma} is a classical theorem in the theory of affine inequalities and previous results ~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} have applied the theorem to affine invariant generation. In these results, the form of Farkas' Lemma follows~\cite[Corollary 7.1h]{DBLP:books/daglib/0090562}.


\begin{theorem}[Farkas' Lemma]\label{thr:farkas}
Consider an affine assertion $\tsAssertphi$ over a set $V=\{x_1,\dots, x_n\}$ of real-valued variables 
as in Figure~\ref{tsAssertphi in Farkas' Lemma}.
\noindent When $\tsAssertphi$ is satisfiable (i.e., there is a valuation over $V$ that satisfies $\tsAssertphi$), it implies an affine inequality $\tsAssertpsi$ as in Figure~\ref{tsAssertpsi in Farkas' Lemma} (i.e., $\tsAssertphi \models \tsAssertpsi$) if and only if there exist non-negative real numbers $\lambda_0, \lambda_1, \dots, \lambda_m$ such that 
(i) $c_j = \sum^{m}_{i=1} \lambda_{i} \cdot a_{ij}$ for all  $1 \le j \le n$, and 
(ii) $d = \lambda_0 + \sum^{m}_{i=1} \lambda_{i} \cdot b_{i}$ as in Figure~\ref{tab:farkas}. 
Moreover, $\tsAssertphi$ is unsatisfiable if and only if the inequality $-1 \geq 0$ (as $\tsAssertpsi$) can be derived from above.
\end{theorem}

% Figure environment removed

Farkas' Lemma simplifies the inclusion of a polyhedron inside a halfspace into the satisfiability of a system of affine inequalities. We refer to the case of unsatisfiable $\tsAssertphi$ with $\tsAssertpsi:=-1\ge 0$ in the statement of Theorem~\ref{thr:farkas} as \emph{infeasible implication}. 
The application of Farkas' Lemma can be visualized by the tabular form in Figure~\ref{tab:farkas} (taken from~\cite{DBLP:conf/cav/ColonSS03}), and we multiply $\lambda_0,\lambda_1,\dots,\lambda_m$ with their inequalities in $\tsAssertphi$ and sum up them together to get $\tsAssertpsi$. For $1 \le j \le m$, we require $\lambda_j \ge 0$. 

A subset $P$ of $\Rset^n$ is a \emph{polyhedron} if $P=\{\mathbf{x}\in \Rset^n\mid \mathbf{A}\cdot\mathbf{x}\le \mathbf{b}\}$ for some real matrix $A\in \Rset^{m\times n}$ and real vector $\mathbf{b}\in \Rset^m$, where $\mathbf{x}$ is treated as a column vector and the comparison $\mathbf{A}\cdot\mathbf{x}\le \mathbf{b}$ is defined in the coordinate-wise fashion. 
A polyhedron $P$ is a \emph{polyhedral cone} if $P=\{\mathbf{x}\in \Rset^n\mid \mathbf{A}\cdot\mathbf{x}\le \mathbf{0}\}$ for some real matrix $A\in \Rset^{m\times n}$, 
where $\mathbf{0}$ is the $m$-dimensional zero column vector. 
It is well-known from the Farkas-Minkowski-Weyl Theorem~\cite[Corollary 7.1a]{DBLP:books/daglib/0090562} that any polyhedral cone $P$ can be represented as $P=\{\sum_{i=1}^k \lambda_i\cdot \mathbf{g}_i\mid \lambda_i\ge 0 \mbox{ for all }1\le i\le k\}$ for some real vectors $\mathbf{g}_1,\dots,\mathbf{g}_k$, where such vectors $\mathbf{g}_i$'s are called a collection of \emph{generators} for the polyhedral cone $P$. 
