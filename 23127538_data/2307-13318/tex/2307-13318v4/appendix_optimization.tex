\section{Control Flow Transformation: Loop Summary}
\label{app:loop_sum}
In this section, we consider further optimizations. The first is the tackling of infeasible implications (i.e., "$-1\ge 0$") in the application of Farkas' Lemma. 
This situation has not been handled in the previous approaches in Farkas' Lemma. The infeasible implication is important in the generation of disjunctive invariants since ignoring them would break the internal disjunctive feature of the loop, thus leading to the failure of the generation of the desired disjunctive invariant. A key difficulty to tackle the infeasible implication is that we obtain general polyhedra rather than polyhedral cones in establishing the constraints for invariant generation, and thus cannot directly apply the generator computation over polyhedral cones. To address this difficulty, we show that it suffices to fix the nonlinear parameter $\mu$ multiplied to the template 
in the Farkas tabular (Figure~\ref{tab:farkas}) to $1$ and include the generators of both the polytope and the polyhedral cone of the Minkowski decomposition of the polyhedron resulting from the constraint solving of the PAP after the application of Farkas' Lemma. As its correctness proof is somewhat technical, we relegate them to Appendix~\ref{app:thm_infeasible} and Appendix~\ref{sec:appendix_minkowski}.

The second is the extension of our approach to nested loop. The main difficulty here is how to handle the inner loops in a nested loop. Recall that in the previous section, we transform a non-nested loop into a canonical form and further transforms it into an affine transition system. This cannot be applied to nested loops since the inner loops does not obey this canonical form. To address this difficulty, we consider to use the standard technique of loop summary to abstract the input-output relationship of the inner loops, and use the loop summaries of inner loops to construct the overall affine transition system for the outer loops. 

Given a nested affine while loop $W$, our approach works by first recursively computing the loop summary $\ProcSmry_{W'}$ for each inner while loop $W'$ in $W$ (from the innermost to the outermost), 
%that is a while loop which is in the loop body of $W$ and does not lie in other inner loops), 
and then %construct the affine transition system for 
tackling the main loop body via the control flow of the loop body and the loop summaries $\ProcSmry_{W'}$ of the inner loops. Below we fix a nested affine while loop $W$ with variable set $\tsVars=\{\tsVar_1,\dots,\tsVar_n\}$ and present the technical details. 

The most involved part in our approach is the transformation of the main loop $W$ into its corresponding \LTS{}.  %and the loop summaries of its inner loops. 
%Unlike the situation of unnested while loops, a direct recursive algorithm that transforms the loop $W$ into a canonical form in Figure~\ref{fig:unnestedPQandRecursive} as in the unnested case is not possible, since one needs to tackle the loop summaries from the inner while loops in $W$.
%since to apply the state-transition pattern here one needs to specify the conditions for the output of the inner while loops in a total conditionl branch (i.e., a conditional branch that appears at the top level like some $\varphi_i$ in Figure~\ref{?}). 
To address the inner loops, our algorithm works with the \emph{control flow graph} (CFG) $H$ of the loop body of the loop $W$ and considers the \emph{execution paths} in this CFG. The CFG $H$ is a directed graph whose vertices are the program counters of the loop body and whose edges describe the one-step jumps between these program counters. Except for the standard semantics of the jumps emitting from assignment statements and conditional branches, for a program counter that represents the entry point of an inner while loop that is not nested in other inner loops, we have the special treatment that the jump at the program counter is directed to the termination program counter of this inner loop in the loop body of $W$ (i.e., skipping the execution of this inner loop). An \emph{execution path} in the CFG $H$ is a directed path of program counters that ends in (i) either the termination program counter of the loop body of $W$ without visiting a  program counter that represents the \textbf{break} statement or (ii) a first \textbf{break} statement without visiting prior \textbf{break} statements. 
An example is as follows.

% Notably, our back-end includes two additional features. The first one is the functionality to remove invalid transitions with unsatisfiable guard condition $\tsGuardcond$. 
% The second one is the treatment of the situation of the unsatisfiability in the application of Farkas' Lemma 
% (see $-1\ge 0$ at the bottom of Figure~\ref{tab:farkasinit} and Figure~\ref{tab:farkascons}), which is however missing in the original tool StInG~\cite{Sting}. The former can simplify the \LTS{} to improve time efficiency and the later can increase accuracy. 
% A key difficulty in the second one is that we obtain polyhedra rather than polyhedral cones, and thus cannot directly apply the generator computation. To address this difficulty, we show that it suffices to consider $\mu=1$ in Figure~\ref{tab:farkascons} and include the generators of both the polytope and the polyhedral cone of the Minkowski decomposition of the polyhedron. As its correctness proof is somewhat technical, we relegate them to Appendix~\ref{sec:appendix_mu1} and Appendix~\ref{sec:appendix_minkowski}.

\begin{example}\label{eg:janne_cfg}
Consider the janne\_complex program from ~\cite{DBLP:conf/vmcai/BoutonnetH19} in Figure~\ref{fig:jannecomplex}.  
The CFG of the program is given in Figure~\ref{fig:janne_cfg} where the nodes correspond to the program counters, the directed edges with guards specifies the jumps and their conditions, and the affine assignments are given in the program counters $A_1,A_2,A_3$. 

\newsavebox{\jannecomplex}
\begin{lrbox}{\jannecomplex}
\begin{lstlisting}[mathescape]
while($x<30$){
    while($y<x$){
        if ($y>5$) $y=y*3$;
        else $y=y+2$;
        if (y>=10 && y<=12) $x=x+10$;
        else $x=x+1$;
    }
    $x=x+2$; $y=y-10$;
}
\end{lstlisting}
\end{lrbox}

% Figure environment removed

% Figure environment removed

We denote by $W$ the outer loop with entry point $E_{\mathrm{Outer}}$, and by $W'$ the inner loop with entry point $E_{\mathrm{inner}}$.    
%the CFG of a specific example with outermost loop $W$ and the inner loop $W'$ within $W$ from \emph{janne\_complex}~\cite{DBLP:conf/vmcai/BoutonnetH19} in Figure~\ref{fig:janne_cfg}. 
The execution path starts at the \emph{Initial Condition} $\left[x, y \right]$, jumps to the next vertices along the edge whose condition is satisfied (e.g., \emph{True} is tautology, \emph{$x < 30$} is satisfied when variable $x$ value is less than $30$, etc.), and terminates in the \emph{Exit} statement. 
The only execution path for the loop body of $W$ is %$E_{Outer} \rightarrow A_{IS} \rightarrow A_{1}$, 
$A_{IS} \rightarrow A_{1}$,
%\rightarrow E_{Outer}$, 
for which we abstract the whole inner loop by $A_{IS}$. 
%The \emph{$E_{Outer}$} means the outermost loop entry of $W$ and \emph{$E_{Inner}$} means the inner-loop entry of $W'$ in $W$. 
%The \emph{$A_1$, $A_2$, $A_3$} represents the assignment statements in the program and \emph{$A_{IS}$} is a special assignment statement for the inner-loop $W'$ which could be obtained by computing loop summary for $W'$. 
\qed 
\end{example}


Based on the CFG $H$ and the execution paths, our approach constructs the \LTS{} for the outer loop $W$ as follows. Since the output of an inner while loop $W'$ in $W$ cannot be exactly determined from the input to the loop $W'$, we first have fresh output variables 
$\overline{x}_{W',1},\dots,\overline{x}_{W',n'}$ to represent the output values of the variables $\overline{x}_{W',1},\dots,\overline{x}_{W',n'}$ after the execution of the inner loop $W'$. These output variables are used to express the loop summaries of these inner loops. 

Then, to get the numerical information from execution paths,  we symbolically compute the values of the program variables at each program counter in an execution path. In detail, given an execution path $\omega=\iota_1,\dots,\iota_k$ where each $\iota_i$ is a program counter of the loop body of the loop $W$, our approach computes the affine expressions $\alpha_{\tsVar,i}$ and PAPs $\beta_i$ (for $\tsVar\in \tsVars$ and $1\le i\le k$) over the program variables in $\tsVars$ (for which they represent their initial values at the start of the loop body of $W$ here) and the fresh output variables. 
%(for the output of the inner loops). 
The intuition is that (i) each affine expression $\alpha_{\tsVar,i}$ represents the value of the variable $\tsVar$ at the program counter $\iota_i$ along the execution path $\omega$ and (ii) each PAP $\beta_i$ specifies the condition that the program counter $\iota_i$ is reached along the execution path $\omega$. The computation is recursive on $i$ as follows.

Denote the vectors $\alpha_i:=(\alpha_{\tsVar_1,i},\dots, \alpha_{\tsVar_n,i})$ and  $\overline{x}_{W'}=(\overline{x}_{W',1},\dots,\overline{x}_{W',n'})$. For the base case when $i=1$, we have $\alpha_1=(\tsVar_1,\dots,\tsVar_n)$ and $\beta_1=\mathbf{true}$ that specifies the initial setting at the start program counter $\iota_1$ of the loop body of the original loop $W$. For the recursive case, suppose that our approach has computed the affine expressions in $\alpha_{i}$ and the PAP $\beta_i$. We classify four cases below:

\begin{itemize}
\item \emph{Case 1:} The program counter $\iota_{i}$ is an affine assignment statement $\mathbf{x}:=\mathbf{F}(\mathbf{x})$. Then we have that $\alpha_{i+1}= \alpha_i[\mathbf{F}(\mathbf{x})/\mathbf{x}]$ and $\beta_{i+1}:=\beta_i$.  
\item \emph{Case 2:} The program counter $\iota_{i}$ is a conditional branch with branch condition $b$ and the next program counter $\iota_{i+1}$ follows its \textbf{then}-branch. Then the vector $\alpha_{i+1}$ is the same as $\alpha_i$, and the PAP $\beta_{i+1}$ is obtained as $\beta_{i+1}=\beta_i\wedge b$.   
\item \emph{Case 3:} The program counter $\iota_{i}$ is a conditional branch with branch condition $b$ and the next program counter $\iota_{i+1}$ follows its \textbf{else}-branch. The only difference between this case and the previous case is that $\beta_{i+1}$ is obtained as $\beta_{i+1}:=\beta_i\wedge \neg b$.   
\item \emph{Case 4:} The program counter $\iota_{i}$ is the entry point of an inner while loop $W'$ of $W$ and $\iota_{i+1}$ is the successor program counter outside $W'$ in the loop body of $W$. Then $\alpha_{i+1}:=\overline{x}_{W'}$ and $\beta_{i+1}:=\ProcSmry_{W'}(\alpha_i, \overline{x}_{W'})$. Here we use the ouput variables to express the loop summary. Note that the loop summary $\ProcSmry_{W'}$ is recursively computed. 
\end{itemize}  

\begin{example}\label{eg:evolution}
Continue with the execution path in Example~\ref{eg:janne_cfg}. 
% Figure environment removed
The evolution of $\alpha_{i}$ and $\beta_{i}$ with the initial setting $\alpha_{1}=[x,y],\beta_{1}=\mathbf{true}$ is given in Figure~\ref{fig:outer_inner}.  %where $W$ denotes the current loop. 
\qed 
\end{example}


After the $\alpha_i,\beta_i$'s are obtained for an execution path $\omega=\iota_1,\dots,\iota_k$ from the recursive computation above, we let the PAP $\Psi_\omega:=\bigwedge_{i\in I} \beta_i$ where the index set $I$ is the set of all $1\le i\le k$ such that the program counter $\iota_i$ corresponds to either a conditional branch or the entry point of an inner while loop, and the vector of affine expression $\alpha_{\omega}:=\alpha_{k+1}$. Note that the PAP $\Psi_\omega$ is the condition that the execution of the loop body follows the execution path $\omega$, and the affine expressions in the vector $\alpha_\omega$ represent the values of the program variables after the execution path $\omega$ of the loop body of $W$ in terms of the initial values of the program variables and the fresh variables for the output of the inner while loops in $W$. 


Finally, our approach constructs the \LTS{} for the loop $W$ and we only present the main points:
\begin{itemize}
\item First, for each execution path $\omega$ of the loop body of $W$, we have a standalone location $\tsLoc_\omega$ for  this execution path. Recall that we abstract the inner loops, so that the execution paths can be finitely enumerated. 
\item Second, for all locations $\tsLoc_\omega,\tsLoc_{\omega'}$ (from the execution paths $\omega,\omega'$), we have the transition $\tau_{\omega,\omega'}:=(\tsLoc_{\omega}, \tsLoc_{\omega'}, \Psi_{\omega} \wedge \Psi'_{\omega'}\wedge \mathbf{x}'=\alpha_\omega)$ which means that if the execution path in the current iteration of the loop $W$ is $\omega$, then in the next iteration the execution path can be $\omega'$ with the guard condition $\Psi_{\omega} \wedge \Psi'_{\omega'}\wedge \mathbf{x}'=\alpha_\omega$ that comprises the conditions for the execution paths $\omega,\omega'$ and the condition $\mathbf{x}'=\alpha_\omega$ for the next values of the program variables.
\item Third, we enumerate all possible initial locations $l_\omega$, along with their corresponding initial condition $\tsInitcond= G \wedge \Psi_{\omega}$. To derive loop summary, we follow the standard technique (see e.g.~\cite{DBLP:conf/vmcai/BoutonnetH19}) to include the input variables $\tsVars_{\mathsf{in}}$ and conjunct the affine assertion $\bigwedge_{\tsVar\in\tsVars} \tsVar=\tsVar_{\mathsf{in}}$ into each disjunctive clause of the initial condition $\tsInitcond$. 

Manually specified initial condition can also be conjuncted into 
$\tsInitcond$. 
\end{itemize}

A detailed process that handles $\mathbf{break}$ statement is similar to the unnested situation. Again, we can remove invalid transitions by checking whether their guard condition is satisfiable or not. 

At the end of the illustration of our algorithms, we discuss possible extensions as follows. 