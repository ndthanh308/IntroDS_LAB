\section{Introduction}

Invariant generation is the classical problem that targets the automated  generation of invariants 
which can be used to aid the verification of critical program properties. An invariant at a program location is an assertion that over-approximates the set of program states reachable to that location, i.e., every reachable program state to the location is guaranteed to satisfy the assertion. Since invariants provide an over-approximation for reachable program states, they play a fundamental role in program verification and can be used for safety~\cite{DBLP:books/daglib/0080029,DBLP:conf/pldi/PadonMPSS16,DBLP:conf/cav/AlbarghouthiLGC12}, reachability~\cite{DBLP:conf/tacas/ColonS01,DBLP:conf/cav/BradleyMS05,DBLP:conf/sas/AliasDFG10,DBLP:conf/vmcai/PodelskiR04,DBLP:conf/ictac/ChenXYZZ07,DBLP:conf/fm/DavidKKL16,DBLP:conf/pldi/AsadiC0GM21} and time-complexity~\cite{DBLP:journals/toplas/ChatterjeeFG19} analysis in  program verification. 

Automated approaches for invariant generation have been studied over decades and there have been an abundance of literature along this line of research. From different types of program objects, invariant generation 
targets numerical values (e.g., integers or real numbers)~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/sas/Rodriguez-CarbonellK04,DBLP:conf/popl/SinghPV17,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/vmcai/BoutonnetH19}, arrays~\cite{DBLP:conf/vmcai/LarrazRR13,DBLP:conf/pldi/SrivastavaG09}, pointers~\cite{DBLP:conf/pldi/LeZN19,DBLP:journals/jacm/CalcagnoDOY11}, algebraic data types~\cite{DBLP:journals/pacmpl/KSG22}, etc. By the different methodologies in existing approaches, invariant generation can be solved by abstract interpretation~\cite{DBLP:conf/popl/CousotC77,DBLP:conf/popl/CousotH78,DBLP:conf/vmcai/BoutonnetH19,DBLP:conf/sas/GopanR07}, constraint solving~\cite{DBLP:conf/vmcai/Cousot05,DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/GulwaniSV08,DBLP:conf/pldi/Chatterjee0GG20}, inference~\cite{DBLP:conf/oopsla/DilligDLM13,DBLP:journals/jacm/CalcagnoDOY11,DBLP:journals/fmsd/SharmaA16,DBLP:conf/cav/0001LMN14,DBLP:conf/sigsoft/Xu0W20,DBLP:conf/cav/GanX0ZD20,DBLP:conf/fmcad/SomenziB11,DBLP:conf/tacas/McMillan08,DBLP:conf/sas/DonaldsonHKR11}, recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18}, machine learning~\cite{DBLP:conf/popl/0001NMR16,DBLP:conf/pldi/HeSPV20,DBLP:conf/pldi/YaoRWJG20,DBLP:conf/iclr/RyanWYGJ20}, 
data-driven approaches~\cite{DBLP:conf/pldi/LeZN19,DBLP:conf/esop/0001GHALN13,DBLP:conf/icse/NguyenKWF12,DBLP:conf/icse/CsallnerTS08,DBLP:conf/cav/ChenHWZ15,FSE2022}, etc. Most results in the literature consider a strengthened version of invariants, called \emph{inductive invariants}, that requires the inductive condition that the invariant at a program location is preserved upon every program execution back and forth to the location (i.e., under the assumption that the invariant holds at the location, it continues to hold whenever the program execution goes back to the location). 

 

An important criterion on the quality of invariants is the accuracy against the exact set of reachable program states. Invariants that have too much accuracy loss (i.e., including too many program states that actually are not reachable) may be not precise enough to verify a target program property, while invariants with better accuracy can verify more program properties. Thus, ensuring the accuracy of the generated invariants is an important subject in invariant generation. In this work, we consider the automated generation of disjunctive invariants, i.e., invariants that are in the form of a disjunction of assertions. Compared with conjunctive invariants, disjunctive invariants are capable of capturing disjunctive features such as multiple phases and mode transitions in while loops, and thus can be substantially more accurate than conjunctive ones. 

We consider the automated generation of numerical invariants (i.e., invariants over the numerical values of program variables). Numerical invariants are an important subclass of invariants that is closely related to numerical program failures such as array out-of-bound and division by zero. 

We focus on affine disjunctive invariants over affine while loops. An affine while loop is a while loop in which every conditional branch and loop guard is specified by affine inequalities, and every assignment statement is in the form of an affine expression 
that specifies an affine update on the current program state. Moreover, we consider the method of constraint solving that usually leads to accurate invariants. A typical constraint-solving method is via Farkas' Lemma~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,DBLP:conf/cav/JiFFC22,oopsla22/scalable}.  
that provides a complete characterization for affine inequalities. 
However, as Farkas' Lemma only concerns conjunction of affine inequalities, its application is limited to conjunctive affine invariant generation. The question on how to apply Farkas' Lemma to disjunctive affine invariant generation remains to be a challenge.   

To address this challenge, we explore a succinct disjunctive pattern from the conditional branches in an unnested loop, show how this disjunctive pattern can be integrated with Farkas' Lemma, and further explore algorithmic improvements and extensions to loop summary and nested loop. 
Our detailed contributions are as follows. 
\begin{itemize}
\item First, for an unnested while loop, we consider disjunctive invariants that arise from the conditional branches in the loop body. To utilize the disjunctive information from the conditional branches, our approach first pushes all the conditional branches in a loop body to the top level so that every top-level branch appears at the entry point of the loop body.
The motivation behind the top-level branches is that each top-level branch refers to a branch location with a standalone conjunctive invariant for the location, and the final invariant is an overall disjunction of the conjunctive invariants at the top-level branches. Taking one step further, our approach constructs an affine transition system that describes the transitions between the current and the next branch locations in a loop iteration,
and solves the conjunctive affine invariants over at the branch locations of the affine transition system by existing approaches via Farkas' Lemma. 
\item Second, under a mild non-crossing assumption for an affine transition system, we improve the constraint solving algorithm
by a novel invariant propagation technique that first generates the invariant only at the initial branch location and then obtains the invariants at other branch locations by a breadth-first propagation from the initial branch location. The invariant propagation technique improves the overall time efficiency by having the involved invariant computation only at the initial branch location and obtaining the invariants at other locations by a lightweight propagation process. 
\item Third, we extend our approach to generate affine disjunctive loop summary of affine while loops. Loop summary is the classical problem of the automated derivation of the input-output relationship for a while loop. In our extension, we follow the standard paradigm (see e.g.~\citet{DBLP:conf/vmcai/BoutonnetH19}) that incorporates fresh variables to represent the initial values of the program variables in the loop and generate the invariants for both the original program variables and the fresh variables through our approach to derive the loop summary.   
\item Fourth, to derive the disjunctive affine invariants and loop summaries of a nested loop, we extend our approach to nested while loops by integrating the loop summaries of the inner loops into the construction of the affine transition system for the outer loop. 
\item Finally, we implement our approach as a prototype tool built upon the Clang Static Analyzer~\cite{ClangStaticAnalyzer}. 
\end{itemize}

Experimental results over a wide range of benchmarks (including SV-COMP and WCET) demonstrate that our approach can prove safety properties that are related to various disjunctive features in affine loops and beyond previous approaches and state-of-the-art software verifiers, and derive substantially more accurate affine disjunctive loop summary than previous approaches. Moreover, our approach is more time efficient compared with previous approaches.
