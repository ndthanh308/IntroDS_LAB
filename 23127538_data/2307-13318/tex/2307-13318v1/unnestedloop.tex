\section{Disjunctive Affine Invariant Generation for Unnested Loops}

In this section, we present our approach for generating affine disjunctive loop invariants over unnested affine while loops. 
Throughout the section, we fix the set of program variables 
as $X=\{x_1,\dots,x_n\}$ and identify the set $X$ as the set of variables in the 
\LTS{} to be derived from the loop. We consider the canonical form of an unnested affine while loop as in Figure~\ref{fig:unnestedPQandRecursive}, where we have: 
\begin{itemize}
\item The PAP $G$ is the loop condition (or loop guard) for the while loop.
\item The vector $\mathbf{x}=(x_1,\dots,x_n)^{\mathrm{T}}$ represents the column vector of program variables, and each $\mathbf{F}_i$ ($1\le i\le m$) is an affine function, i.e.,  $\mathbf{F}_i(\mathbf{x})=\mathbf{A} \mathbf{x}+\mathbf{b}$ where $\mathbf{A}$ (resp. $\mathbf{b}$) is an $n\times n$ square matrices (resp. $n$-dimensional column vector) that specifies the affine update under the affine assertion $\phi_i$ (as a conditional branch). The assignment $\mathbf{x}:=\mathbf{F}_i(\mathbf{x})$ is considered simultaneously for the variables in $\mathbf{x}$ so that in one execution step, the current valuation $\tsEval$ is updated to $\mathbf{F}_i(\tsEval)$. 
\item The \textbf{switch} keyword represents a special conditional branching (i.e., different from its original meaning in e.g. C programming language) that if the current values of the program variables satisfy the condition $\phi_i$, then the assignment at the $i$th conditional branch (i.e., $\mathbf{x}:=\mathbf{F}_i(\mathbf{x})$) is executed. Note that the branch conditions $\phi_1,\dots,\phi_m$ need not to be pairwise disjoint (i.e., there can be some valuation $\tsEval$ that satisfies both $\phi_i,\phi_j$ ($i\ne j$)), so that our setting covers nondeterminism in imperative programs.  
\item The statements $\delta_1,\dots,\delta_m$ specify whether the loop continues after the affine update of the conditional branches $\phi_1,\dots,\phi_m$. Each statement $\delta_i$ is either the \textbf{skip} statement that does nothing (which means that the loop continues after the affine update of $\mathbf{F}_i$) or the \textbf{break} statement (which means that the loop exits after the affine update). 
\end{itemize}
A major motivation behind Figure~\ref{fig:unnestedPQandRecursive} is that we treat each top-level branch $\phi_i$ as a standalone branch location and the overall invariant is a disjunction of the invariants at these branch locations. 

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\unnestedP}
\begin{lrbox}{\unnestedP}
\begin{lstlisting}[mathescape]
switch {
  case $\phi_{P,1}$: $\mathbf{x}:=F_{P,1}(\mathbf{x})$;$\delta_{P,1}$;
  $\cdots$
  case $\phi_{P,p}$: $\mathbf{x}:=F_{P,p}(\mathbf{x})$;$\delta_{P,p}$;
}
\end{lstlisting}
\end{lrbox}

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\unnestedQ}
\begin{lrbox}{\unnestedQ}
\begin{lstlisting}[mathescape]
switch {
  case $\phi_{Q,1}$: $\mathbf{x}:=\mathbf{F}_{Q,1}(\mathbf{x})$;$\delta_{Q,1}$;
  $\cdots$
  case $\phi_{Q,q}$: $\mathbf{x}:=\mathbf{F}_{Q,q}(\mathbf{x})$;$\delta_{Q,q}$;
}
\end{lstlisting}
\end{lrbox}

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\unnestedRsequential}
\begin{lrbox}{\unnestedRsequential}
\begin{lstlisting}[mathescape]
switch {
  $\cdots$
  case $\phi_{P,i}$: 
    $\mathbf{x}:=(\mathbf{F}_{P,i}(\mathbf{x}))$;
    $break$;($\mbox{if }\delta_{P,i}=\textbf{break}$)
  $\cdots$
  case $\phi_{P,i}\wedge \phi_{Q,j}[\mathbf{F}_{P,i}(\mathbf{x})/\mathbf{x}]$: 
    $\mathbf{x}:=\mathbf{F}_{Q,j} (\mathbf{F}_{P,i}(\mathbf{x}))$; 
    $\delta_{Q,j}$;($\mbox{if }\delta_{P,i}=\textbf{skip}$)
  $\cdots$
}
\end{lstlisting}
\end{lrbox}

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\unnestedRconditional}
\begin{lrbox}{\unnestedRconditional}
\begin{lstlisting}[mathescape]
switch {
  $\cdots$
  case $\phi_{P,i}\wedge b$: 
    $\mathbf{x}:=\mathbf{F}_{P,i}(\mathbf{x})$;$\delta_{P,i}$;
  $\cdots$
  case $\phi_{Q,j}\wedge \neg b$: 
    $\mathbf{x}:=\mathbf{F}_{Q,j}(\mathbf{x})$;$\delta_{Q,j}$;
  $\cdots$
}
\end{lstlisting}
\end{lrbox}

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\unnested}
\begin{lrbox}{\unnested}
\begin{lstlisting}[mathescape]
while $G$ {
  switch 
    case $\phi_1$: $\mathbf{x}:=\mathbf{F}_1(\mathbf{x})$;$\delta_1$;
      $\vdots$ 
    case $\phi_m$: $\mathbf{x}:=\mathbf{F}_m(\mathbf{x})$;$\delta_m$;
}
\end{lstlisting}
\end{lrbox}
\vspace{-0.2cm}
% Figure environment removed
\vspace{-0.3cm}

Any unnested affine while loop with break statement can be transformed into the canonical form in Figure~\ref{fig:unnestedPQandRecursive} by recursively examining the substructures of the loop body of the loop. 
A detailed transformation is provided in 
Appendix~\ref{appendix:transform}.
Note that although the transformation into our canonical form may cause exponential blow up in the number of conditional branches in the loop body, in practice a loop typically has a small number of conditional branches and further improvement can be carried out by removing invalid branches (i.e., those whose branch condition is unsatisfiable). Moreover, such a canonical form is often necessary to derive precise disjunctive information for a while loop. 

Below we illustrate our algorithm to generate disjunctive affine invariants on unnested affine while loops. Informally, our algorithm applies the top-level branches and follows Farkas' Lemma for affine invariant generation as in \citet{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable}, and further proposes the improvement of invariant generation that is closely related to the top-level branches and has not been considered in the existing  approaches~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable}. Here we first consider an unnested affine while loop $W$. The workflow of our algorithm is demonstrated as follows (\textbf{Step B1} -- \textbf{Step B3}). 

\smallskip
\noindent\textbf{Step B1.} We first transform the loop $W$ into a canonical form $\mathsf{C}_W$ w.r.t Figure~\ref{fig:unnestedPQandRecursive} as stated previously. Taking Example~\ref{eg:realcode} as a running example, the canonical form of the example is given in Example~\ref{eg:transformedcode}. 

\smallskip
\noindent\textbf{Step B2.} Then we apply the top-level branches to transform the loop $\mathsf{C}_W$ into a \LTS{}. The transformation is in a straightforward fashion that every top-level conditional branch (i.e., $\phi_i$ in Figure~\ref{fig:unnestedPQandRecursive}) corresponds to a stand-alone location, and the guard of a transition is determined by the loop condition (i.e., $G$) as well as the branch conditions of the source and target locations of the transition. Formally, we have that the \LTS{} $\Gamma_W$ derived from the loop $W$ is given as follows:
\begin{itemize}
\item The set of locations is $\{\tsLoc_1,\dots, \tsLoc_m, \tsLoc_{e}\}$, 
where each $\tsLoc_i$ ($1\le i\le m$) corresponds to the branch location with branch condition $\phi_i$ and $\tsLoc_{e}$ is the termination program counter of the loop. 
\item For each $1\le i\le m$, if $\delta_i=\mathbf{break}$, we have that transition (where we denote $\mathbf{x}':=(x'_1,\dots,x'_n)^\mathrm{T}$)
$$
\tau_{i}=(\tsLoc_i, \tsLoc_e, G \wedge \phi_i \wedge  \mathbf{x}'=\mathbf{F}_i(\mathbf{x}))
$$
that specifies the one-step jump from the branch location $\tsLoc_i$ to the termination location $\tsLoc_e$, where the guard condition is a conjunction of the loop guard G (for staying in the loop at the current loop iteration), the branch condition $\phi_i$ (that the current execution of the loop body follows the location $\tsLoc_i$) and $\mathbf{x}'=\mathbf{F}_i(\mathbf{x})$ (for the affine update). 
\item For each $1\le i,j\le m$, where $\delta_i\neq \mathbf{break}$, we have the transition 
$$
\tau_{ij}=(\tsLoc_i, \tsLoc_j, G \wedge \phi_i \wedge G[\mathbf{x}'/\mathbf{x}] \wedge \phi_j[\mathbf{x}'/\mathbf{x}] \wedge \mathbf{x}'=\mathbf{F}_i(\mathbf{x}))
$$ 
that specifies the one-step jump from the branch location $\tsLoc_i$ to the branch location $\tsLoc_j$, for which the guard condition is $ G \wedge \phi_i \wedge G[\mathbf{x}'/\mathbf{x}] \wedge \phi_j[\mathbf{x}'/\mathbf{x}]\wedge \mathbf{x}'=\mathbf{F}_i(\mathbf{x})$ since the transition needs to pass the loop guard $G$, satisfy the branch condition $\phi_i$ when staying in the location $\tsLoc_i$, have the affine update specified by $\mathbf{F}_i$ and fulfill the loop guard $G[\mathbf{x}'/\mathbf{x}]$ and the branch condition $\phi_j$ upon entering the location $\tsLoc_j$. 
\item For each $1\le i\le m$, where $\delta_i\neq \mathbf{break}$, we have the transition 
$$
\tau'_{i}=(\tsLoc_i, \tsLoc_{e}, G\wedge \phi_i\wedge (\neg G)[\mathbf{x}'/\mathbf{x}]\wedge \mathbf{x}'=\mathbf{F}_i(\mathbf{x}))
$$ 
for the one-step jump from the branch location $\tsLoc_i$ to the termination location $\tsLoc_e$ for which the guard condition is a conjunction of the loop guard $G$, the branch condition  $\phi_i$, the affine update $\mathbf{x}'=\mathbf{F}_i(\mathbf{x})$ and the negation of the loop guard (for jumping out of the loop). 
\end{itemize} 

After the transformation, we remove transitions with unsatisfiable guard condition to reduce the size of the derived \LTS{}. The transformation for the running example has been given in Example~\ref{eg:runningtransitions}. 


\smallskip
\noindent\textbf{Step B3.} After the transformation into an \LTS{}, we follow existing approaches~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} that generate affine invariants with Farkas' Lemma. In particular, we apply the recent approach~\cite{oopsla22/scalable} that has the most scalability (see Example ~\ref{eg:farkasapplication} for the running example). A slight difference is that we do not encode the constraints for the termination program location $\tsLoc_{e}$. This is because the invariant at $\tsLoc_{e}$ can be derived 
from non-termination locations to the termination location. In the following, we further propose an invariant propagation technique that takes advantage of a common feature in the top-level branches to improve the time efficiency. 

In our invariant propagation, we explore a special structure in the derived \LTS{} that often arises in the top-level branches, and propose a technique that applies to the special structure and allows one to generate invariants at only one location and obtain the invariants at other locations through a propagation process. To illustrate the invariant propagation, we first identify the special structure of non-crossing affine transition systems. 

\begin{definition}
An \LTS{} $\Gamma$ is \emph{non-crossing} if there exists a depth-first search (DFS) tree of the directed graph $\mbox{\sl DG}(\Gamma)$ (i.e., its underlying directed graph) rooted at the initial location that does not have cross edges. (Recall that a cross edge in a DFS tree is an edge whose destination location is a visited location in the DFS but not an ancestor of the source location of the edge). 
\end{definition}

An example of a non-crossing DFS tree is given in Example~\ref{eg:propagation}, while a simple example that violates the non-crossing property would be a complete directed graph. Non-crossing ATS's are common in the top-level branch form of an unnested while loop. For example, the case of multiphase invariants~\cite{DBLP:conf/cav/SharmaDDA11} is a special case of non-crossing affine transition systems where a location is never entered again once it is left. The strict alternation between branch locations 
is also a special case of non-crossing affine transition systems. In general, any affine transition system that has one outgoing-transition for every location (which arises from deterministic mode change in while loops) is non-crossing, since in its DFS tree there is no cross edges. 

We illustrate the main workflow of our invariant propagation technique. Consider an \LTS{} $\Gamma$ transformed from an unnested affine while loop. Given a DFS tree $T$ of $\mbox{\sl DG}(\Gamma)$ rooted at the initial location $\tsLoc^*$ that has the non-crossing property and a conjunctive affine invariant $\eta(\tsLoc^*)$ at the location $\tsLoc^{*}$ generated from the approach by~\citet{oopsla22/scalable}, the invariant propagation works by repeatedly propagating the invariant $\eta(\tsLoc^*)$ from the root to other locations in a breadth-first search (BFS) from the root $\tsLoc^*$. In the BFS, a single step of propagation that is from a location $\tsLoc$ in the current BFS front with the invariant $\eta(\tsLoc)$ (as a DNF PAP) computed from the prior BFS process to a location $\tsLoc'$ in the next front, considers all transitions from 
$\tsLoc$ to $\tsLoc'$; for each such transition  $\tau=(\tsLoc, \tsLoc',\tsGuardcond)$, our approach computes a DNF PAP as an invariant $I(\tau,\tsLoc')$ for the \LTS{} $\Gamma[\tsLoc',K_\tau:=\{\tsEval'\mid \exists \tsEval.(\tsEval\models \eta(\tsLoc) \wedge \tsEval,\tsEval'\models \tsGuardcond)\}]$ (see Page~\pageref{pg:selfloop} for the definition of $\Gamma[-,-]$) via the approach by~\citet{oopsla22/scalable} 
and disjuncts all these $I(\tau,\tsLoc')$'s together to obtain $\eta(\tsLoc')$. Note that in such an ATS $\Gamma[\tsLoc',K_\tau:=\{\tsEval'\mid \exists \tsEval.(\tsEval\models \eta(\tsLoc) \wedge \tsEval,\tsEval'\models \tsGuardcond)\}]$ we consider self-loop transitions at a location $\tsLoc'$ since our approach needs to cover the case that when propagated to the location $\tsLoc'$, the ATS (and the original program) may dwell at the branch location $\tsLoc'$ for a finite unbounded number of steps. The invariant at the termination location $\tsLoc_{e}$ is also obtained by performing a single propagation step from the non-termination locations. 



The details of a single propagation in the BFS is as follows. 
Consider a location $\tsLoc$ at the current BFS front with the computed PAP invariant $\eta(\tsLoc)=\bigvee_{i=1}^d \Phi_i$ where each $\Phi_i$ is an affine assertion. Then for each transition $\tau=(\tsLoc, \tsLoc',\tsGuardcond)$, we have that $I(\tau,\tsLoc')=\bigvee_{i=1}^d I(\tau,\tsLoc',i)$ where each $I(\tau,\tsLoc',i)$ is a conjunctive affine invariant of the \LTS{} $\Gamma[\tsLoc',K_{\tau,i}:=\{\tsEval'\mid \exists \tsEval.(\tsEval\models \Phi_i \wedge \tsEval,\tsEval'\models \tsGuardcond)\}]$. 
Hence, our approach calculates $I(\tau,\tsLoc')$ by computing for each $1\le i\le d$ the conjunctive affine invariant $I(\tau,\tsLoc',i)$ (over  $\Gamma[\tsLoc',K_{\tau,i}]$) by the approaches~\cite{oopsla22/scalable}. 

\begin{example}
A preliminary example of invariant propagation for our running example has been given in Example~\ref{eg:propagation}, where we have the DFS tree and the breath-first propagation from the branch location $\tsLoc_2$ to $\tsLoc_1$. We give more details for the single propagation step from $\tsLoc_2$ to $\tsLoc_1$. 
For $\Phi:=\eta(\tsLoc_2)=(y=50\wedge 0\le x\le 49)$ and transition $\tau=(\tsLoc_2, \tsLoc_1,\tsGuardcond_5)$, our approach computes $K_{\tau}:=\{\tsEval'\mid \exists \tsEval.(\tsEval\models \Phi \wedge \tsEval,\tsEval'\models \tsGuardcond_5)=\{(x,y)\mid (x=50 \wedge y=50)\}$, and further derives the invariant for $\tsLoc_1$ from the ATS $\Gamma[\tsLoc_1,K_{\tau}]$ (that comprises only the location $\tsLoc_1$ and the self-loop transition $\tsGuardcond_1$ at $\tsLoc_1$). \qed
\end{example}

To instantiate a single propagation step, we need to encode the set $K_{\tau,i}$ as an affine assertion $\Phi'_{\tau,i}$ without quantifiers that defines the set, and this can be accomplished by the projection of the polyhedron $\{(\tsEval, \tsEval')\mid \tsEval\models \Phi_i \wedge \tsEval,\tsEval'\models \tsGuardcond\}$ onto the dimensions of $\tsEval'$. However, polyhedral projection is an operation with relatively high computation cost. Below we show that these $\Phi'_{\tau,i}$'s can be computed more efficiently by the resorting to the affine updates between $\mathbf{x}$ and $\mathbf{x}'$ from the original while loop. 

Consider the task to project the polyhedron $H=\{(\tsEval, \tsEval')\mid \tsEval\models \Phi \wedge \tsEval,\tsEval'\models \tsGuardcond\}$ in the treatment  of a transition $\tau=(\tsLoc, \tsLoc',\tsGuardcond)$ stated above, where $\Phi$ is an affine assertion. Recall that the transition is derived in the way that the relationship between the variables from $\tsVars$ and $\tsVars'$ is given by some affine assignment $\mathbf{x}:=\mathbf{A}\mathbf{x}+\mathbf{b}$ (i.e., $\mathbf{x}'=\mathbf{A}\mathbf{x}+\mathbf{b}$) under some conditional branch in the canonical form of Figure~\ref{fig:unnestedPQandRecursive}. We consider two cases below.
\begin{itemize}
\item The first case is that the matrix $\mathbf{A}$ is invertible. In this case, we have that $\mathbf{x}=\mathbf{A}^{-1}\mathbf{x}'-\mathbf{A}^{-1}\mathbf{b}$, and we obtain an affine assertion $\Phi'$ over $\tsVars'$ that defines the projected polyhedron directly as 
$(\Phi\wedge \tsGuardcond)[(\mathbf{A}^{-1}\mathbf{x}'-\mathbf{A}^{-1}\mathbf{b})/\mathbf{x}]$. In this case, no polyhedral projection is needed. 
\item The second case is that the matrix $A$ is not invertible. Then we solve the system of affine equations $\mathbf{A} \mathbf{x}=\mathbf{x}'-\mathbf{b}$ by the standard method of Gaussian Elimination in elementary affine algebra 
and obtains that 
$
\textstyle\mathbf{x}= \mathbf{u}(\mathbf{x}') + \sum_{i=1}^k a_k\cdot \mathbf{v}_i~(a_1,\dots, a_k\in \mathbb{R})
$
where (i) the vector $\mathbf{u}(\mathbf{x}')$ is a solution to the non-homogenous equation $\mathbf{A}\mathbf{x}=\mathbf{x}'-\mathbf{b}$ and can be expressed as an affine combination of the entries in $\mathbf{x}'$ (i.e., $\mathbf{u}(\mathbf{x}')=\mathbf{C} \mathbf{x}'+\mathbf{d}$ for some matrix $\mathbf{C}$ and vector $\mathbf{d}$) and (ii) $\mathbf{v}_1,\dots,\mathbf{v}_k$ are the basic solution of the homogeneous equation  $\mathbf{A}\mathbf{x}=\mathbf{0}$ and are constant vectors not relying on 
$\mathbf{x}'$. The fresh variables $a_1,\dots, a_k$ are the coefficients of the basic solution and can take any real value. 
As a consequence, the projection of the affine assertion $\tsEval\models \Phi \wedge \tsEval,\tsEval'\models \tsGuardcond$ (that defines the polyhedron $H$) onto the variables $\mathbf{x}'$ can be obtained  as the projection of the affine assertion 
$
\textstyle(\Phi\wedge \tsGuardcond)[(\mathbf{u}(\mathbf{x}') + \sum_{i=1}^k a_k\cdot \mathbf{v}_i)/\mathbf{x}]
$ 
onto the variables $\mathbf{x}'$ (i.e., projecting away the dimensions of $a_1,\dots, a_k$). Note that the number of the basic solution $a_1,\dots, a_k$ is equal to $n-\mathrm{rank}(A)$ where $\mathrm{rank}(A)$ is the rank of the matrix $A$. This means that the number of variables to be projected away is smaller than $n$.
It follows that in this case, it is possible to project away much less variables compared with the original projection method (that needs to project away all the $n$ variables $x_1,\dots,x_n$ in $\mathbf{x}$), and thus can further improve the time efficiency.
\end{itemize}

The advantage of incorporating invariant propagation lies at the observation that to generate the invariants at all the locations, previous approaches consider to solve them either as a whole~\cite{DBLP:conf/sas/SankaranarayananSM04} or separately~\cite{oopsla22/scalable} via the generator computation of polyhedral cones. Thus, all these approaches require to solve the invariants at all the locations with generator computation, an operation with relative high cost and possible exponential blow-up. Invariant propagation improves the time efficiency in that when the underlying \LTS{} has a non-crossing DFS tree, then it suffices to perform generator computation only in the computation of the invariants at the initial location and in the treatment of self-loops at other locations.  


Note that non-crossing affine transition systems do not cover all cases of directed acyclic graphs, but this can be partially remedied by first computing the strongly-connected components (SCCs) of the underlying \LTS{} and then considering each SCC separately. 

In summary, the workflow of our algorithm 
over an unnested affine while loop is as follows.

\begin{itemize}
\item First, our algorithm transforms an unnested affine while loop into the canonical form in Figure~\ref{fig:unnestedPQandRecursive} and further transforms it into an affine transition system. 
\item Second, our algorithm applies the approach by~\citet{oopsla22/scalable} and our invariant propagation technique (if possible) to obtain affine invariants at the branch locations of the affine transition system. In the case that the affine transition system is non-crossing w.r.t the initial location, our algorithm applies the approach by~\citet{oopsla22/scalable} to obtain the affine invariant at the initial location and afterwards derive the invariants at other locations through invariant propagation. Otherwise (i.e., the affine transition system is not non-crossing), our algorithm follows the original approach by~\citet{oopsla22/scalable} to generate the invariants at all the locations. 
\end{itemize}


By an induction on the depth of the DFS tree, we can prove that the assertions generated from our invariant propagation are indeed invariants and are at least as tight as the invariants generated by the previous approaches \cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable}. Due to space limitation, we relegate the detailed proofs to Appendix~\ref{sec:appendix_invpropagation_proof}. 

