\section{Overview of Our Approach}

In this section, we describe our our approach via a simple while loop with disjunctive feature. We first take a look at the example below. 

\lstset{language=program}
\lstset{tabsize=3}
\newsavebox{\origincode}

\begin{lrbox}{\origincode}
\begin{lstlisting}[mathescape]
  $x=0$;
  $y=50$;
  while($x<100$){
    $x=x+1$;
    if($x>50$)
      $y=y+1$;
  }
\end{lstlisting}
\end{lrbox}\
\newsavebox{\transcode}
\begin{lrbox}{\transcode}
\begin{lstlisting}[mathescape]
  $x=0$;
  $y=50$;
  while($x<100$){
    switch{
      case $x>49$:
        $x=x+1$;
        $y=y+1$;
      case $x\le 49$:
        $x=x+1$;
    }
  }
\end{lstlisting}
\end{lrbox}
\vspace{-0.6cm}
% Figure environment removed
\vspace{-0.3cm}
\begin{example}\label{eg:realcode}
Consider an affine while loop in Figure~\ref{fig:The source code} taken from~\citet{DBLP:conf/cav/SharmaDDA11}
with integer-valued variables $x,y$. Before the loop, the values of the variables $x,y$ are initialized to $0,50$, respectively. In each loop iteration, the value of $x$ is incremented by one, and if this value exceeds $50$, then the value of $y$ is incremented by one. The loop has a disjunctive feature from the if branch in the loop body that when the value of $x$ is no greater than $50$, then only the variable $x$ is incremented; when the value of $x$ reaches $51$, then both the variables $x,y$ are incremented (until the value of $x$ reaches $100$). \qed
\end{example}

Our approach has three main steps. \emph{The first step} to handle the loop is to transform the loop into an equivalent canonical form where all the conditional branches appear at the entry point (i.e., top level) of the loop body. Each top-level branch corresponds to a standalone conjunctive invariant at the branch, and the overall invariant is meant to be a disjunction of the conjunctive invariants at these top-level branches.  

\begin{example}\label{eg:transformedcode}
We push the if branch $\textbf{if}~(x>50)$ in Figure~\ref{fig:The source code} to the front of the loop body, so that we have two top-level branches $x>49$ and $x\le 49$ in Figure~\ref{fig:The transformed code}. Notice that if the value of $x$ is no greater than $49$ at the entry point of the original loop body, then the if branch is not executed and only the variable $x$ is incremented. Otherwise (i.e., the value of $x$ is greater than $49$), both the variables $x,y$ are incremented in the loop iteration. Thus, in Figure~\ref{fig:The transformed code} we have a special \textbf{switch} statement at the top of the loop body, and two top-level branches $x>49$ and $x\le 49$ to distinguish between the cases of the increment of only $x$ or both $x,y$. Our aim is to obtain independent invariants for the cases of $x>49$ and $x\le 49$, say $\eta_1$ for $x>49$ and $\eta_2$ for $x\le 49$, and the final invariant is the disjunction of $\eta_1\wedge x>49$ and $\eta_2\wedge x\le 49$ (i.e., $(\eta_1\wedge x>49) \vee (\eta_2\wedge x\le 49)$). \qed
\end{example}

To obtain the invariants for the top-level branches, \emph{our second step} is to construct an affine transition system that includes every top-level branch as a standalone location (we shall refer to such a location as a \emph{branch location}) and every possible jump between the top-level branches (for the current and next loop iteration) as a transition. The details are given as follows. 

\begin{example}\label{eg:runningtransitions}
To obtain an affine transition system that describes the jumps between the top-level branches in Figure~\ref{fig:The transformed code}, we treat the two branches $x>49$ and $x\le 49$ as standalone branch locations, and use $\tsLoc_1$ and $\tsLoc_2$ to denote the branch locations, respectively. Moreover, we have a special location $\tsLoc_e$ that represents the termination location of the loop. We further add transitions between the branch locations that respect their entry conditions in the current and next loop iteration. For example, the transition $\tsTran_{5} : \langle \tsLoc_{2}, \tsLoc_{1}, \tsGuardcond_{5} \rangle$ specifies the jump from the branch location $\tsLoc_2$ to the branch location $\tsLoc_1$ with the guard condition $\tsGuardcond_{5}$ specified by 
$x \le 49,~~50 \le x' \le 99,~~x' = x + 1,~~y' = y$, 
where (i) $x\le 49$ and $50 \le x' \le 99$ are derived from the entry condition $x\le 49$ of the branch location $\tsLoc_2$ (in the current loop iteration) and the counterpart $x>49$ of $\tsLoc_1$ (in the next loop iteration), both conjuncted with the loop guard, and (ii) $x' = x + 1, y' = y$ specify the update to the variables $x,y$ under the current branch location $\tsLoc_2$. In the same way, one can derive transitions for other jumps. The whole affine transition system is given in Figure~\ref{fig:cavsplitter}, where $\tsLoc_2$ is the initial location. Note that the transitions $\tsTran_{2},\tsTran_{6}$ are infeasible and hence can be removed. \qed
\end{example}

% Figure environment removed


After the affine transition system is constructed, \emph{our third step} applies existing approaches~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} via Farkas' Lemma to obtain the invariants at each branch location, and group these invariants disjunctively together to obtain the final invariant.  Below we give a detailed illustration. 


\begin{example}\label{eg:farkasapplication}
Consider to generate affine invariants over the \LTS{} in Figure~\ref{fig:The LTS}. The approach~\cite{DBLP:conf/sas/SankaranarayananSM04} first establishes a template at each location by setting $\tsMap(\tsLoc_{i}) := \fkCoeff_{\tsLoc_{i},1}x + \fkCoeff_{\tsLoc_{i},2}y + \fkConst_{\tsLoc_{i}} \geq 0$ for $i \in \{1,2,e\}$ (\textbf{Step A1} in the previous section). Then, it generates the constraints from  the initialization and consecution conditions (\textbf{Step A2}) and simplifies the constraints by the Farkas' tabular in Figure~\ref{tab:farkasinitcons} (\textbf{Step A3}). 
For initialization, the tabular in Figure~\ref{tab:fktabinit} gives the simplified constraints $[\fkCoeff_{\tsLoc_{2},1}=\lambda_{1},\fkCoeff_{\tsLoc_{2},2}=\lambda_{2},\fkConst_{\tsLoc_{2}} \geq -50\lambda_{2}]$ (recall Remark~\ref{remark:OriginFarkas}, where $\lambda_{0} \ge 0$ but we do not impose restriction on $\lambda_{1},\lambda_{2}$) and  generates the constraints $[50\fkCoeff_{\tsLoc_{2},2}+\fkConst_{\tsLoc_{2}} \geq 0]$ by projecting away the fresh variables $\lambda_{j}$'s. 
For consecution, we present the application of the Farkas' tabular to the transition $\tsTran_{5}$ as in Figure~\ref{tab:fktabcons}. The fresh variables $\lambda_{j}$'s are projected away and the fresh non-affine variable $\mu$ is eliminated by reasonable heuristics that guesses its value through either practical rules such as factorization or setting $\mu$ manually to $0$ or $1$. 
Other transitions 
are treated in a similar way. 

% Figure environment removed

The constraints obtained from the previous step constitutes a PAP $\Phi$ in CNF where each clause in the conjunction is the constraint derived from either the initialization or the consecution of a transition, and every disjunctive affine assertion in such a clause in the conjunction results from a distinct guessed value for the non-affine $\mu$ parameter in the tabular for consecution. In the last step (\textbf{Step A4}), 
the approach ~\cite{DBLP:conf/sas/SankaranarayananSM04} expands the PAP $\Phi$ equivalently into a DNF PAP (where each clause in the disjunction is an affine assertion that defines a polyhedral cone) and obtains the affine invariants by the generator computation of each polyhedral cone in the DNF PAP. 
For this example, one clause in the disjunction (treated as a polyhedral cone) from the DNF formula is shown in Figure~\ref{tab:cs} (where we abbreviate $\fkCoeff_{\tsLoc_{i},j}$, $\fkConst_{\tsLoc_{i}}$ as $\fkCoeff_{ij}$, $\fkConst_{i}$); further by computing the generators of the polyhedral cone in Figure~\ref{tab:cs}, we obtain the corresponding generators and their invariants in Figure~\ref{tab:geninv}, where in the left part each row specifies a generator with a type (a point, a ray or a line generator) over the unknown coefficients $\fkCoeff_{ij}$'s and $\fkConst_{i}$'s, and in the right part we instantiate the generator to the unknown coefficients in the template $\tsMap$ to obtain the invariants at location $\tsLoc_{1}$, $\tsLoc_{2}$ and $\tsLoc_{e}$. 

% Figure environment removed

The affine invariants obtained from the generator computation can be further minimized by removing trivial invariants such as $0\ge 0$ and redundant inequalities. After processing all the disjunctive clauses of the DNF and grouping all the generated invariants together, 
the final disjunctive invariant at the entry point of the loop body is $\tsMap(\tsLoc_{1})\vee \tsMap(\tsLoc_{2})$, which is 
$(x = y\wedge 50 \leq x \leq 99) \vee  (y = 50\wedge 0 \leq x \leq 49)$, and the invariant for the termination location $\tsLoc_e$ is derived from the invariants at $\tsLoc_{1}, \tsLoc_{2}$ and the transitions to $\tsLoc$ as 
$\tsMap(\tsLoc_{e})= (x = y = 100)$. The approach~\cite{oopsla22/scalable} improves the scalability by generating the invariants one location at a time that allows to detect redundant invariants more efficiently. \qed 
\end{example}

In the third step, we observe that simply to apply existing approaches in Farkas' Lemma incurs extra computation overhead since all these approaches require to compute the invariant at every location by an involved computation procedure. The overhead may be large if the number of branch locations is considerable. Thus, we propose an \emph{invariant propagation} technique that only computes the invariant at the initial branch location (during which our approach does not compute the invariant at other branch locations) and have a breadth-first propagation of this invariant to other branch locations, when the affine transition system admits a depth-first search tree without cross edges (i.e., edges that go back to a non-ancestor node). The following example illustrates this idea over the ATS in Figure~\ref{fig:The LTS}. 


\begin{example}\label{eg:propagation}
Consider the affine transition system in Figure~\ref{fig:The LTS}. Its underlying directed graph is given in Figure~\ref{fig:propagation} (here we ignore the termination location $\tsLoc_e$), for which we have a DFS tree that is composed of the solid tree edges and the dashed edges are back edges (i.e., edges that go back to an ancestor node). Notice that there is no cross edge in the DFS tree. Our invariant propagation technique utilizes the absence of cross edges. 

% Figure environment removed

First, our approach computes the invariant at the initial branch location $\tsLoc_2$ to be $\tsMap(\tsLoc_{2})= (y = 50\wedge 0 \leq x \leq 49)$. Then, our invariant propagation calculates a new initial condition $x = 50\wedge y=50$ for the branch location $\tsLoc_1$ by propagating the invariant $\tsMap(\tsLoc_{2})$ along the transition $\tsGuardcond_{5}$. Next, with the new initial condition, our approach solves the invariant at the branch location $\tsLoc_1$ by  considering only the self-loop transition $\tsGuardcond_{1}$ to obtain $\tsMap(\tsLoc_{1})= (x = y\wedge 50 \leq x \leq 99)$. Note that the back edge from $\tsLoc_1$ to $\tsLoc_2$ does not affect the invariant at $\tsLoc_1$ (even if $\tsGuardcond_{2}$ was feasible). Finally, the invariant at the termination location $\tsLoc_e$ is derived from $\tsMap(\tsLoc_{1})$ and $\tsMap(\tsLoc_{2})$. The key point of invariant propagation over this example is that the invariant at the branch location $\tsLoc_{1}$ is obtained by a propagation from that of $\tsLoc_{2}$, rather than a thorough invariant solving over the whole affine transition system. \qed
\end{example}

\smallskip
\noindent{\em Loop Summaries and Nested Loops.} Besides invariant generation over unnested affine while loops, our approach also generates affine disjunctive loop summary by introducing fresh input variables that represent the inputs of the programs and generating invariants over both the original program variables and the fresh input variables. Furthermore, our approach tackles nested affine while loops by computing the loop summaries of the inner loops and uses these summaries as the abstraction of the inner loops to construct the affine transition system for the outer loop. 

    



