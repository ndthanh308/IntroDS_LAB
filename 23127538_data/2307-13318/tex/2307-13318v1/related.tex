\section{Related Works}

Below we compare our approach with the most related approaches in the literature. 
We first have the comparison with the constraint-solving approaches. 
\begin{itemize}
\item 
Our approach uses the framework to apply Farkas' Lemma as proposed in~\citet{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} and extend the framework to disjunctive affine invariants and loop summary, for which our basic contribution is the construction of an affine transition system that reflects the disjunctive feature from the conditional branches in a loop. Furthermore, we propose invariant propagation to improve the time efficiency, and the use of loop summary to handle nested loops.  
The recent result~\cite{DBLP:conf/cav/JiFFC22} also considers Farkas' Lemma, but focuses on conjunctive affine invariants over unnested affine while loops through the use of eigenvalues and roots of polynomial equations, and hence is orthogonal to our approach. Besides, other approaches on affine invariant generation include ~\citet{DBLP:conf/pldi/GulwaniSV08,DBLP:conf/atva/OliveiraBP17,DBLP:conf/cav/GuptaR09}. 
The approach~\cite{DBLP:conf/pldi/GulwaniSV08} solves the quadratic constraints derived from Farkas' Lemma by SAT solvers and bit-vector modeling. 
The approach~\cite{DBLP:conf/atva/OliveiraBP17} uses eigenvectors to handle several restricted classes of conjunctive affine invariants.
The tool InvGEN ~\cite{DBLP:conf/cav/GuptaR09} generates conjunctive affine invariants by an integrated use of abstract interpretation and Farkas' Lemma. 
These approaches 
propose completely different techniques, and thus are orthogonal to our approach. 
\item Since our approach targets affine invariant generation, it is incomparable with previous results on polynomial invariant generation~\cite{DBLP:conf/dagstuhl/Kapur05,DBLP:journals/fcsc/YangZZX10,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/lics/HrushovskiOP018,DBLP:conf/issac/Rodriguez-CarbonellK04,DBLP:conf/vmcai/Cousot05,DBLP:conf/sas/AdjeGM15,DBLP:journals/fcsc/LinWYZ14,DBLP:conf/cav/ChenHWZ15,DBLP:conf/atva/OliveiraBP16,DBLP:conf/issac/HumenbergerJK17,DBLP:conf/popl/SankaranarayananSM04}. 
Moreover, most of these approaches consider only conjunctive polynomial invariants, and hence do not consider disjunction. 
\end{itemize}
It is also worth noting that the previous work~\cite{DBLP:conf/cav/SharmaDDA11} proposes a general framework for detecting multiphase disjunctive invariants that can be instantiated with constraint solving. Multiphase disjunctive invariants are a special case of our disjunctive pattern (that considers standalone conjunctive invariants at top-level branches) in the sense that each phase in a multiphase feature is directly captured by its phase condition as a top-level branch in our approach. 
Therefore, we consider a wider class of disjunctive invariants as compared with~\citet{DBLP:conf/cav/SharmaDDA11}. 

Second, we compare our approach with the results~\cite{DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21} that consider a similar disjunctive pattern to ours. These approaches propose \emph{path dependency automata} that consider different execution paths of the loop body w.r.t whether each conditional branch in the loop body is entered or not, treat each execution path as a standalone mode, and have transitions between these modes. However, an indispensible ingredient of path dependency automata is the exact estimation of the number of loop iterations sojourning in each mode, and hence is limited to inductive variables (i.e., assignments must be in the form $x:=x+c$ or $x:=c \ast x$) and strict alternation between different modes. Our approach directly constructs affine transition systems between different top-level branch locations, and hence do not have such limitation. 
Moreover, we extend our approach to handle nested loops via loop summary, while these approaches could not have an adequate support for nested loops.  

Third, we compare our approach with  abstract interpretation. Compared with the approaches that generate conjunctive affine invariants via polyhedral abstract domain~\cite{DBLP:conf/popl/CousotH78,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/popl/SinghPV17}, our approach targets the more general case of disjunctive affine invariants. There are also a bunch of abstract-interpretation approaches in disjunctive affine invariant generation, 
such as 
the work~\cite{DBLP:conf/sas/GopanR07} that performs disjunctive partitioning by representing the contribution of each iteration with a separate abstract-domain element, 
the recent work~\cite{DBLP:conf/vmcai/BoutonnetH19} that distinguishes different disjunctive cases by different entries into the conditional branches w.r.t the input values, 
and the state-of-the-art tool PAGAI~\cite{DBLP:journals/entcs/HenryMM12} that may infer disjunctive invariants as disjunctions of elements of the abstract domain via specific iteration algorithm. 
These approaches are based on abstract interpretation and heuristics different from our disjunctive pattern and techniques,
and hence are orthogonal to our approach. 

Fourth, we compare our approach with recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18}. Recurrence analysis usually relies on the existence of a closed form solution. For example, the very recent most related recurrence analysis approach ~\cite{oopsla23} (that also targets disjunctive invariants and loop summary) requires the (ultimate) strict alternation between top-level conditional branches to ensure the existence of a closed form solution, so that the applicability of this approach is limited and does not include nested loops. Our approach is not limited by the absence of a  closed form solution.  

Fifth, we compare our approach with other methods such as machine learning, inference and data-driven approaches. 
Unlike constraint solving that can have an accuracy guarantee for the generated invariants based on the constraints, these methods cannot have an accuracy guarantee. 
Furthermore, machine learning and data-driven approaches themselves cannot guarantee that the generated assertions are indeed invariants. 
Moreover, our approach can generate invariants \emph{without} the need of a goal property, while these approaches
usually requires a goal property.  
Note that the invariant generation without a given goal property is a classical setting (see e.g. ~\citet{DBLP:conf/cav/ColonSS03,DBLP:conf/popl/CousotH78}), and has applications in loop summary and 
probabilistic program verification (see e.g.~\citet{DBLP:conf/cav/ChakarovS13,DBLP:conf/pldi/WangS0CG21}). 

Finally, we compare our approach with the related approaches on loop summary. Compared with the approaches~\cite{DBLP:conf/cc/CousotC02,CousotSSGRR} that are based on convex polyhedra abstract domain and can only generate conjunctive affine loop summaries, our approach is able to generate disjunctive loop summaries. 
Compared with the approach by~\citet{DBLP:conf/vmcai/KranzS18} that applies Heyting completion~\cite{DBLP:journals/toplas/GiacobazziS98} (to make an existing domain meet-distributive) on-demand and computes a summary of the function for each on-demand created predicate (represented via Herbrand terms), our approach is capable of generating affine inequality invariants with arbitrary coefficients, while their approach mainly uses an equality domain (as well as a pointer domain) to track equality relations of limited form between variables. 
Compared with the approach by~\citet{DBLP:conf/vmcai/BoutonnetH19} that enhances abstract interpretation with disjunction from distinct entries into the conditional branches in the program by different initial inputs, our approach is orthogonal in the sense that we apply Farkas' Lemma and the top-level branches, which are completely different. Compared with (i) the PIPS tool~\cite{DBLP:conf/ics/IrigoinJT91,DBLP:journals/entcs/AncourtCI10,PIPS} that employs heuristics to generate conjunctive affine loop summaries and (ii) the approach by~\citet{DBLP:journals/entcs/AncourtCI10} that generates conjunctive affine invariants by a simple heuristics that examines the stepwise incremental update of affine assignments, our approach follows a completely different methodology 
and generates disjunctive affine loop summary. 
Compared with the approaches by ~\citet{DBLP:conf/asian/PopeeaC06,DBLP:journals/scp/PopeeaC13} that maintain a set of limited pre-fixed number of polyhedra for abstracting program states at each program point (to derive a disjunctive polyhedral analysis) under the framework of abstract interpretation, our approach is orthogonal to them and does not require the user to manually provide assertions. 
It would also be an interesting future direction to investigate how our approach could be used for procedure summary~\cite{DBLP:conf/ifip/Allen74,DBLP:conf/pldi/ZhangMNY14,DBLP:conf/esop/GulwaniT07}.


