\section{Disjunctive Affine Invariant Generation for Nested Loops}

Recall that in the previous section, we proposed a novel approach for generating disjunctive affine invariants over unnested while loops via Farkas' Lemma, top-level branches and an invariant propagation technique. 
In this section, we extend this approach to nested affine while loops. 
 

The main idea is as follows. Given a nested affine while loop $W$, our approach works by first recursively computing the loop summary $\ProcSmry_{W'}$ for each inner while loop $W'$ in $W$ (from the innermost to the outermost), 
and then 
tackling the main loop body via the top-level branches and the loop summaries $\ProcSmry_{W'}$ of the inner loops. Below we fix a nested affine while loop $W$ with variable set $\tsVars=\{\tsVar_1,\dots,\tsVar_n\}$ and present the technical details. 

The most involved part in our approach is the transformation of the main loop $W$ into its corresponding \LTS{} by the top-level branches.   
Unlike the situation of unnested while loops, a direct recursive algorithm that transforms the loop $W$ into a canonical form in Figure~\ref{fig:unnestedPQandRecursive} as in the unnested case is not possible, since one needs to tackle the loop summaries from the inner while loops in $W$.

To address the problem above, our algorithm works with the \emph{control flow graph} (CFG) $H$ of the loop body of the loop $W$ and considers the \emph{execution paths} in this CFG. The CFG $H$ is a directed graph whose vertices are the program counters of the loop body and whose edges describe the one-step jumps between these program counters. Except for the standard semantics of the jumps emitting from assignment statements and conditional branches, for a program counter that represents the entry point of an inner while loop that is not nested in other inner loops, we have the special treatment that the jump at the program counter is directed to the termination program counter of this inner loop in the loop body of $W$ (i.e., skipping the execution of this inner loop). An \emph{execution path} in the CFG $H$ is a directed path of program counters that ends in (i) either the termination program counter of the loop body of $W$ without visiting a  program counter that represents the \textbf{break} statement or (ii) a first \textbf{break} statement without visiting prior \textbf{break} statements. 
An example is as follows.

\begin{example}\label{eg:janne_cfg}
Consider the janne\_complex program from ~\citet{DBLP:conf/vmcai/BoutonnetH19} in Figure~\ref{fig:jannecomplex}.  
The CFG of the program is given in Figure~\ref{fig:janne_cfg} where the nodes correspond to the program counters, the directed edges with guards specifies the jumps and their conditions, and the affine assignments are given in the program counters $A_1,A_2,A_3$. 

\newsavebox{\jannecomplex}
\begin{lrbox}{\jannecomplex}
\begin{lstlisting}[mathescape]
while($x<30$){
    while($y<x$){
        if ($y>5$) $y=y*3$;
        else $y=y+2$;
        if (y>=10 && y<=12) $x=x+10$;
        else $x=x+1$;
    }
    $x=x+2$; $y=y-10$;
}
\end{lstlisting}
\end{lrbox}

% Figure environment removed

% Figure environment removed


We denote by $W$ the outer loop with entry point $E_{\mathrm{Outer}}$, and by $W'$ the inner loop with entry point $E_{\mathrm{inner}}$.    
The execution path starts at the \emph{Initial Condition} $\left[x, y \right]$, jumps to the next vertices along the edge whose condition is satisfied (e.g., \emph{True} is tautology, \emph{$x < 30$} is satisfied when variable $x$ value is less than $30$, etc.), and terminates in the \emph{Exit} statement. 
The only execution path for the loop body of $W$ is  
$A_{IS} \rightarrow A_{1}$,
for which we abstract the whole inner loop by $A_{IS}$. 
\qed 
\end{example}


Based on the CFG $H$ and the execution paths, our approach constructs the \LTS{} for the outer loop $W$ as follows. Since the output of an inner while loop $W'$ in $W$ cannot be exactly determined from the input to the loop $W'$, we first have fresh output variables 
$\overline{x}_{W',1},\dots,\overline{x}_{W',n'}$ to represent the output values of the variables $\overline{x}_{W',1},\dots,\overline{x}_{W',n'}$ after the execution of the inner loop $W'$. These output variables are used to express the loop summaries of these inner loops. 

Then, to get the numerical information from execution paths,  we symbolically compute the values of the program variables at each program counter in an execution path. In detail, given an execution path $\omega=\iota_1,\dots,\iota_k$ where each $\iota_i$ is a program counter of the loop body of the loop $W$, our approach computes the affine expressions $\alpha_{\tsVar,i}$ and PAPs $\beta_i$ (for $\tsVar\in \tsVars$ and $1\le i\le k$) over the program variables in $\tsVars$ (for which they represent their initial values at the start of the loop body of $W$ here) and the fresh output variables. 
The intuition is that (i) each affine expression $\alpha_{\tsVar,i}$ represents the value of the variable $\tsVar$ at the program counter $\iota_i$ along the execution path $\omega$ and (ii) each PAP $\beta_i$ specifies the condition that the program counter $\iota_i$ is reached along the execution path $\omega$. The computation is recursive on $i$ as follows.

Denote the vectors $\alpha_i:=(\alpha_{\tsVar_1,i},\dots, \alpha_{\tsVar_n,i})$ and  $\overline{x}_{W'}=(\overline{x}_{W',1},\dots,\overline{x}_{W',n'})$. For the base case when $i=1$, we have $\alpha_1=(\tsVar_1,\dots,\tsVar_n)$ and $\beta_1=\mathbf{true}$ that specifies the initial setting at the start program counter $\iota_1$ of the loop body of the original loop $W$. For the recursive case, suppose that our approach has computed the affine expressions in $\alpha_{i}$ and the PAP $\beta_i$. We classify four cases below:

\begin{itemize}
\item \emph{Case 1:} The program counter $\iota_{i}$ is an affine assignment statement $\mathbf{x}:=\mathbf{F}(\mathbf{x})$. Then we have that $\alpha_{i+1}= \alpha_i[\mathbf{F}(\mathbf{x})/\mathbf{x}]$ and $\beta_{i+1}:=\beta_i$.  
\item \emph{Case 2:} The program counter $\iota_{i}$ is a conditional branch with branch condition $b$ and the next program counter $\iota_{i+1}$ follows its \textbf{then}-branch. Then the vector $\alpha_{i+1}$ is the same as $\alpha_i$, and the PAP $\beta_{i+1}$ is obtained as $\beta_{i+1}=\beta_i\wedge b$.   
\item \emph{Case 3:} The program counter $\iota_{i}$ is a conditional branch with branch condition $b$ and the next program counter $\iota_{i+1}$ follows its \textbf{else}-branch. The only difference between this case and the previous case is that $\beta_{i+1}$ is obtained as $\beta_{i+1}:=\beta_i\wedge \neg b$.   
\item \emph{Case 4:} The program counter $\iota_{i}$ is the entry point of an inner while loop $W'$ of $W$ and $\iota_{i+1}$ is the successor program counter outside $W'$ in the loop body of $W$. Then $\alpha_{i+1}:=\overline{x}_{W'}$ and $\beta_{i+1}:=\ProcSmry_{W'}(\alpha_i, \overline{x}_{W'})$. Here we use the ouput variables to express the loop summary. Note that the loop summary $\ProcSmry_{W'}$ (see Page~\pageref{pg:loopsmry} for the definition of $\ProcSmry$) is recursively computed. 
\end{itemize}  

\begin{example}\label{eg:evolution}
Continue with the execution path in Example~\ref{eg:janne_cfg}. 
% Figure environment removed
The evolution of $\alpha_{i}$ and $\beta_{i}$ with the initial setting $\alpha_{1}=[x,y],\beta_{1}=\mathbf{true}$ is given in Figure~\ref{fig:outer_inner}.   
\qed 
\end{example}




After the $\alpha_i,\beta_i$'s are obtained for an execution path $\omega=\iota_1,\dots,\iota_k$ from the recursive computation above, we let the PAP $\Psi_\omega:=\bigwedge_{i\in I} \beta_i$ where the index set $I$ is the set of all $1\le i\le k$ such that the program counter $\iota_i$ corresponds to either a conditional branch or the entry point of an inner while loop, and the vector of affine expression $\alpha_{\omega}:=\alpha_{k+1}$. Note that the PAP $\Psi_\omega$ is the condition that the execution of the loop body follows the execution path $\omega$, and the affine expressions in the vector $\alpha_\omega$ represent the values of the program variables after the execution path $\omega$ of the loop body of $W$ in terms of the initial values of the program variables and the fresh variables for the output of the inner while loops in $W$. 


Finally, our approach constructs the \LTS{} for the loop $W$ and we only present the main points: 

\begin{itemize}
\item First, for each execution path $\omega$ of the loop body of $W$, we have a standalone location $\tsLoc_\omega$ for  this execution path. Recall that we abstract the inner loops, so that the execution paths can be finitely enumerated. 
\item Second, for all locations $\tsLoc_\omega,\tsLoc_{\omega'}$ (from the execution paths $\omega,\omega'$), we have the transition $\tau_{\omega,\omega'}:=(\tsLoc_{\omega}, \tsLoc_{\omega'}, \Psi_{\omega} \wedge \Psi'_{\omega'}\wedge \mathbf{x}'=\alpha_\omega)$ which means that if the execution path in the current iteration of the loop $W$ is $\omega$, then in the next iteration the execution path can be $\omega'$ with the guard condition $\Psi_{\omega} \wedge \Psi'_{\omega'}\wedge \mathbf{x}'=\alpha_\omega$ that comprises the conditions for the execution paths $\omega,\omega'$ and the condition $\mathbf{x}'=\alpha_\omega$ for the next values of the program variables.
\item Third, we enumerate all possible initial locations $l_\omega$, along with their corresponding initial conditions $\tsInitcond= G \wedge \Psi_{\omega}$. To derive loop summary, we follow the standard technique (see e.g.~\citet{DBLP:conf/vmcai/BoutonnetH19}) to include the input variables $\tsVars_{\mathsf{in}}$ and conjunct the affine assertion $\bigwedge_{\tsVar\in\tsVars} \tsVar=\tsVar_{\mathsf{in}}$ into each disjunctive clause of the initial condition $\tsInitcond$. 
Manually specified initial conditions can also be conjuncted into 
$\tsInitcond$. 
\end{itemize}

A detailed process that handles $\mathbf{break}$ statement is similar to the unnested situation. Again, we can remove invalid transitions by checking whether their guard condition is satisfiable or not. 


Finally, we apply the approach \cite{oopsla22/scalable} and our invariant propagation to the \LTS{} constructed above to obtain the loop summary as an invariant (over the variables in $\tsVars_{\mathsf{in}}\cup\tsVars$) generated at the termination location $\tsLoc_{e}$, and rename each variable $\tsVar\in\tsVars$ to its output 
$\tsVar_{\mathsf{out}}$. 

\begin{example}\label{eg:nested_execution}
Consider the janne\_complex program in Figure~\ref{fig:jannecomplex}. By integrating the loop summary of the inner loop, our approach constructs an affine transition system that corresponds to a while loop of $22$ top-level branches.  
For the lack of space, we relegate the detailed branches to Figure~\ref{fig:jannecomplexsmryfull} in Appendix~\ref{sec:appendix_innersmry}. \qed
\end{example}


At the end of the illustration of our algorithms, we discuss possible extensions as follows. 

\begin{remark}[Extensions]\label{rmk:extension}
Our approach can be extended in the following ways. To obtain a more precise top-level branch representation, one extension is by (i) distinguishing even/odd integer values of program variables and (ii) detecting hidden termination phases via the approach in \cite{DBLP:conf/cav/Ben-AmramG17}. To handle machine integers, another extension is by having a piecewise disjunctive treatment for the cases of overflow and non-overflow. 
Finally, our approach could be extended to floating point numbers by considering piecewise affine approximations~\cite{DBLP:conf/esop/Mine04, DBLP:conf/vmcai/Mine06}. 
\end{remark}
