\section{Introduction}

Invariant generation is the classical problem that targets the automated  generation of invariants 
%at program locations 
which can be used to aid the verification of critical program properties. An invariant at a program location is an assertion that over-approximates the set of program states reachable to that location, i.e., every reachable program state to the location is guaranteed to satisfy the assertion. Since invariants provide an over-approximation for reachable program states, they play a fundamental role in program verification and can be used for safety~\cite{DBLP:books/daglib/0080029,DBLP:conf/pldi/PadonMPSS16,DBLP:conf/cav/AlbarghouthiLGC12}, reachability~\cite{DBLP:conf/tacas/ColonS01,DBLP:conf/cav/BradleyMS05,DBLP:conf/sas/AliasDFG10,DBLP:conf/vmcai/PodelskiR04,DBLP:conf/ictac/ChenXYZZ07,DBLP:conf/fm/DavidKKL16,DBLP:conf/pldi/AsadiC0GM21} and time-complexity~\cite{DBLP:journals/toplas/ChatterjeeFG19} analysis in  program verification. 

Automated approaches for invariant generation have been studied over decades and there have been an abundance of literature along this line of research. From different program objects, invariant generation %can be divided into %the automated generation of 
%invariants over 
targets numerical values (e.g., integers or real numbers)~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/sas/Rodriguez-CarbonellK04,DBLP:conf/popl/SinghPV17,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/vmcai/BoutonnetH19}, arrays~\cite{DBLP:conf/vmcai/LarrazRR13,DBLP:conf/pldi/SrivastavaG09}, pointers~\cite{DBLP:conf/pldi/LeZN19,DBLP:journals/jacm/CalcagnoDOY11}, algebraic data types~\cite{DBLP:journals/pacmpl/KSG22}, etc. By different methodologies, invariant generation can be solved by abstract interpretation~\cite{DBLP:conf/popl/CousotC77,DBLP:conf/popl/CousotH78,DBLP:conf/vmcai/BoutonnetH19,DBLP:conf/sas/GopanR07}, constraint solving~\cite{DBLP:conf/vmcai/Cousot05,DBLP:conf/cav/ColonSS03,DBLP:conf/pldi/GulwaniSV08,DBLP:conf/pldi/Chatterjee0GG20}, inference~\cite{DBLP:conf/oopsla/DilligDLM13,DBLP:journals/jacm/CalcagnoDOY11,DBLP:journals/fmsd/SharmaA16,DBLP:conf/cav/0001LMN14,DBLP:conf/sigsoft/Xu0W20,DBLP:conf/cav/GanX0ZD20,DBLP:conf/fmcad/SomenziB11,DBLP:conf/tacas/McMillan08,DBLP:conf/sas/DonaldsonHKR11}, recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18}, machine learning~\cite{DBLP:conf/popl/0001NMR16,DBLP:conf/pldi/HeSPV20,DBLP:conf/pldi/YaoRWJG20,DBLP:conf/iclr/RyanWYGJ20}, 
data-driven approaches~\cite{DBLP:conf/pldi/LeZN19,DBLP:conf/esop/0001GHALN13,DBLP:conf/icse/NguyenKWF12,DBLP:conf/icse/CsallnerTS08,DBLP:conf/cav/ChenHWZ15,FSE2022}, etc. Most results in the literature consider a strengthened version of invariants, called \emph{inductive invariants}, that requires the inductive condition that the invariant at a program location is preserved upon every execution back and forth to the location (i.e., under the assumption that the invariant holds at the location, it continues to hold whenever the program execution goes back to the location). 


%An important criterion on the quality of invariants is the accuracy against the exact set of reachable program states. Invariants that have too much accuracy loss (i.e., including too many program states that actually are not reachable) may be not precise enough to verify a target program property, while invariants with better accuracy can verify more program properties. Thus, ensuring the accuracy of the generated invariants is an important subject in invariant generation. 

In this work, we consider the automated generation of disjunctive invariants, i.e., invariants that are in the form of a disjunction of assertions. Compared with conjunctive invariants, disjunctive invariants capture disjunctive features such as multiple phases and mode transitions in  loops. 
%We consider the automated generation of numerical invariants (i.e., invariants over the numerical values of program variables). Numerical invariants are an important subclass of invariants that is closely related to numerical program failures such as array out-of-bound and division by zero. 
%\ke{I've made a simple modification to the expression here. For the original version, please see the LaTeX source code. }
% We focus on affine disjunctive invariants over affine while loops. An affine while loop is a while loop in which every conditional branch and loop guard is specified by affine inequalities, and every assignment statement is in the form of an affine expression 
% that specifies an affine update on the current program state.
We primarily focus on the generation of affine disjunctive invariants in affine loops. %programs containing loops. 
An affine loop is a while loop where all conditional and assignment statements are in the form of linear expressions.

We consider constraint solving to generate affine disjunctive invariants. 
%that usually leads to accurate invariants. 
A typical constraint solving method is via Farkas' Lemma~\cite{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,DBLP:conf/cav/JiFFC22,oopsla22/scalable} 
that provides a complete characterization for affine invariants. However, the application of Farkas' Lemma is limited to  conjunction of affine inequalities. The question on how to leverage Farkas' Lemma to generate affine disjunctive invariants remains to be a challenge.   

\smallskip
\noindent{\em Our contributions.} To address the aforementioned challenge, we explore a succinct disjunctive pattern from the conditional branches in a non-nested loop, show how this disjunctive pattern can be integrated with Farkas' Lemma, and further explore
optimizations to increase the scalability, applicability and accuracy. Our detailed contributions cover the five points below. 
%algorithmic improvements and extensions to nested loop. Our detailed contributions are as follows. 
%\ke{I have completely changed the way this is written. For the original text, refer to the comments.}

%\begin{itemize}

% \item First, for an unnested while loop, we consider disjunctive invariants that arise from the conditional branches in the loop body. To utilize the disjunctive information from the conditional branches, our approach first pushes all the conditional branches in a loop body to the top level so that every top-level branch appears at the entry point of the loop body.
% The motivation behind the top-level branches is that each top-level branch refers to a branch location with a standalone conjunctive invariant for the location, and the final invariant is an overall disjunction of the conjunctive invariants at the top-level branches. Taking one step further, our approach constructs an affine transition system that describes the transitions between the current and the next branch locations in a loop iteration,
% and solves the conjunctive affine invariants over at the branch locations of the affine transition system by existing approaches via Farkas' Lemma. 
%\item 
\emph{First,} we recognize that an important source of disjunction arises from the branching in control flow. To utilize the branching information, we explore a control flow transformation that transforms the loop into a transition system compatible with Farkas' Lemma. For non-nested loops, our approach collects every path that jumps from the entry point to the end of the loop body. These paths are treated as locations in the transition system. Then, our approach establishes the transitions between these locations to finish the construction of the transition system. 
%Based on these Locations, we construct a transition system between them. 
Finally, affine conjunctive invariants are computed over the transition system by the previous approach~\cite{oopsla22/scalable} in Farkas' Lemma, and the disjunctive invariant is the disjunction of the invariants at all locations. 

%these transitions using constraint solving methods aided by Farkas' Lemma, focusing on their corresponding conjunctive invariants.

% \item Second, under a mild non-crossing assumption for an affine transition system, we improve the constraint solving algorithm
% by a novel invariant propagation technique that first generates the invariant only at the initial branch location and then obtains the invariants at other branch locations by a breadth-first propagation from the initial branch location. The invariant propagation technique improves the overall time efficiency by having the involved invariant computation only at the initial branch location and obtaining the invariants at other locations by a lightweight propagation process. 

%\item 
\emph{Second,} to mitigate the combinatorial explosion in the number of paths and during the invariant computation, we propose a novel invariant propagation technique dedicated to our control flow transformation. The technique starts to compute an invariant at the initial location, and proceeds by a 
%Initially, invariants are computed for the starting Location using constraint solving methods. Following this, a
breadth-first traversal to identify potential topological orders in the sub-transition system obtained by removing the initial location. Throughout invariant propagation, invariants are computed only at the initial location (of a strongly connected component of the transition system), and therefore could improve the scalability by mitigating the combinatorial explosion as stated above.  
%are propagated, significantly reducing the computational cost and effectively avoiding the extensive expense of directly calculating invariants for each path.

%\item 
\emph{Third,} we address the case of infeasible implication in the application of Farkas' Lemma that has not been addressed previously. This allows our approach to remove infeasible transitions in the transformed transition system, hence removing infeasible jumps between the paths of the loop body. Removing such transitions improves the accuracy of the generated invariants. Such accuracy gain is necessary since ignoring infeasible jumps may destroy the disjunctive feature in the loop. 

%\item 
\emph{Fourth,} we extend our approach to nested loops via standard loop summary that extracts the input-output relationship of a loop. This improves the applicability of our approach.  

%have extended the constraint solving approach based on Farkas' Lemma to handle nested loops by utilizing the concept of loop summarization. Loop summarization is a classic problem focused on automatically extracting the input-output relationships within loops. 
 

%have completed the implementation of the theoretical tools related to the -1 >= 0 aspect in Farkas' Lemma, as mentioned in the original paper. We have also proven that in the context of Farkas' Lemma, the non-linear relationships can be converted into linear ones without losing accuracy, specifically in scenarios where -1 >= 0.
% Third, we extend our approach to generate affine disjunctive loop summary of affine while loops. Loop summary is the classical problem of the automated derivation of the input-output relationship for a while loop. In our extension, we follow the standard paradigm (see e.g.~\citet{DBLP:conf/vmcai/BoutonnetH19}) that incorporates fresh variables to represent the initial values of the program variables in the loop and generate the invariants for both the original program variables and the fresh variables through our approach to derive the loop summary.   
% \item Fourth, to derive the disjunctive affine invariants and loop summaries of a nested loop, we extend our approach to nested while loops by integrating the loop summaries of the inner loops into the construction of the affine transition system for the outer loop. 

%\item 

\emph{Finally,} we implement our approach as a prototype upon the Clang Static Analyzer~\cite{ClangStaticAnalyzer}. Experiment over benchmarks from SV-COMP 2023~\cite{svcomp} and \cite{DBLP:conf/vmcai/BoutonnetH19} shows that our approach outperforms existing methods in both the number of solved instances and the time efficiency. Compared with the SV-COMP 2023 winner Veriabs~\cite{SVCOMP2023Veriabs} in \emph{ReachSafety}, our approach solves a comparable number of benchmarks with a speedup up to $3$ orders of magnitude in time efficiency. 
%\end{itemize}

%\ke{It appears that the WCET (Worst Case Execution Time) is not included in the subsequent experiments.}

%WCET) demonstrate that our approach can prove safety properties that are related to various disjunctive features in affine loops and beyond previous approaches and state-of-the-art software verifiers, and derive substantially more accurate affine disjunctive loop summary than previous approaches. Moreover, our approach is more time efficient compared with previous approaches.

\smallskip{\noindent \em Limitations.} Our approach handles integer-value variables by the over-approximation to real numbers, and hence cannot handle
machine integers in general. However, we can handle several simple properties of machine integers such as integer overflow by suitable piecewise linear representations. 
