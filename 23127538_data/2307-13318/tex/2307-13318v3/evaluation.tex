\section{Experimental Evaluation}

In this section, we present the evaluation of the implementation (referred to as {\ToolName}) of our approach to generate disjunctive affine invariants. We focus on the following two questions (\textbf{RQ1} and \textbf{RQ2}).

\begin{itemize}
    \item \textbf{RQ1:} How competitive is \ToolName\ when compared with other approaches?
    \item \textbf{RQ2:} How effective does invariant propagation enhance our approach?
\end{itemize}
\subsection{Experimental Setup}
\smalltitle{Implementation.} We implement our approach (including the algorithmic techniques in 
Section~\ref{sec:alg}) as a prototype tool based on the Clang Static Analyzer~\cite{ClangStaticAnalyzer}. The implementation includes a front-end for converting C programs into affine transition systems as described in Section~\ref{sec:cft}. The front-end first transforms affine loops into the canonical form as shown in Figure~\ref{fig:CanonicalForm}, and then converts them into the affine transition systems required by the back-end. We also implement the summary approach in Section~\ref{sec:otheropt}. 

The back-end \ToolName\ is an extension of StInG~\cite{Sting} written in C++ and uses PPL 1.2~\cite{DBLP:conf/sas/BagnaraRZH02} for polyhedra manipulation (e.g., projection, generator computation, etc.).
The back-end generates invariants at the initial location of (sub-)SCCs by the origianl tool StInG and implements invariant propagation method to propagate invariants to other locations. Moreover, the back-end implements the tackling of infeasible implication in the application of Farkas' Lemma and loop summary as described in Section~\ref{sec:otheropt}. 



\smalltitle{Environment.} All experiments are conducted on a machine equipped with a 12th Gen Intel(R) Core(TM) i7-12800HX CPU, 16 cores, 2304 MHz, 9.5GB RAM, running Ubuntu 20.04 (LTS). Following the competition settings of SV-COMP, for studies \textbf{RQ1} and \textbf{RQ2}, we impose a time limit of 900s. 


\smalltitle{Benchamarks.} We found a total of 114 benchmarks of affine programs, including those with/without disjunctive feature, sourced from: 1) 105 benchmarks from the SV-COMP, ReachSafety-Loop track. We excluded those with arrays, pointers, and other non-numeric features, those with modulus, division, polynomial, and other non-linear operations, and those with complex control flows involving \textit{goto} statements (as \textit{goto} will disrupt the regular loop features, making it more difficult for the front-end to extract the transition system). 2) 9 benchmarks from the recent paper~\cite{DBLP:conf/vmcai/BoutonnetH19}, which include complex nested loops and examples with disjunctive features.


\smalltitle{Methodology.} 
In \textbf{RQ1}, we compare \ToolName\ utilizing invariant propagation techniques with several state-of-the-art software verifiers, including Veriabs~\cite{SVCOMP2023Veriabs} (the winner in the reachsafety track of SV-COMP 2023), the well-developed CPAChecker~\cite{CPAchecker}, and a recent tool from~\citet{oopsla23}.

CPAChecker~\cite{CPAchecker} is a well-developed software verifier that is based on bounded model checking and interpolation and has a comprehensive ability to verify various kinds of properties. 

Veriabs~\cite{SVCOMP2023Veriabs} is a state-of-the-art software verifier that is an integration of various strategies such as fuzz testing, $k$-induction, loop shrinking, loop pruning, full-program induction, explicit state model checking and other invariant generation techniques. 

OOPSLA23~\cite{oopsla23} is a recent recurrence analysis tool that handles only loops with the ultimate strict alternation pattern that eventually the loop will alternate between different modes periodically and performs good on such class of programs. 

In \textbf{RQ2}, we focus on comparing the impact of the invariant propagation technique on the time efficiency. By contrasting the tool's performance when calculating invariants for each location individually against using invariant propagation on SV-COMP benchmarks, we analyze the role of invariant propagation.

\subsection{Tool Comparison (RQ1)}

Our work primarily focuses on the generation of disjunctive invariants, whereas tools like CPAChecker and Veriabs are specifically designed as bug finders for verifying assertions. However, by integrating the PPL library~\cite{DBLP:conf/sas/BagnaraRZH02} and Z3~\cite{z3}, we use the generated invariants to verify the correctness of assertions. In the SV-COMP examples in affine invariant generation, our approach shows performance advantage when compared with these specialized assertion-checking verification tools.



\begin{table}[H]
\centering
\resizebox{0.95\textwidth}{!}{% 
\begin{tabular}{|cc|ccc|ccc|ccc|ccc|}
\hline
\multicolumn{2}{|c|}{Benchmark}                 & \multicolumn{3}{c|}{\ToolName}                           & \multicolumn{3}{c|}{Veriabs}                                            & \multicolumn{3}{c|}{CPAChecker}                                         & \multicolumn{3}{c|}{OOPSLA23}                                           \\ \hline
\multicolumn{1}{|c|}{Source}            & \#Num & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & Time (s) & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & Time (s) & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & Time (s) & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & Time (s) \\ \hline
\multicolumn{1}{|c|}{loop-invariants}   & 5     & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{1}       & 0.47     & \multicolumn{1}{c|}{5}        & \multicolumn{1}{c|}{0}       & 153.31   & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{1}       & 1001.49  & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{4}       & 14.09    \\ \hline
\multicolumn{1}{|c|}{loop-new}          & 2     & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{0}       & 0.11     & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{2}       & 959.74   & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{2}       & 1807.20  & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{2}       & 5.83     \\ \hline
\multicolumn{1}{|c|}{loop-invgen}       & 5     & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{1}       & 0.41     & \multicolumn{1}{c|}{5}        & \multicolumn{1}{c|}{0}       & 160.51   & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{5}       & 4518.19  & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{1}       & 14.78    \\ \hline
\multicolumn{1}{|c|}{loops-crafted-1}   & 25    & \multicolumn{1}{c|}{21}       & \multicolumn{1}{c|}{4}       & 4.84     & \multicolumn{1}{c|}{25}       & \multicolumn{1}{c|}{0}       & 4010.55  & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{25}      & 22607.55 & \multicolumn{1}{c|}{22}       & \multicolumn{1}{c|}{3}       & 82.03    \\ \hline
\multicolumn{1}{|c|}{loop-simple}       & 2     & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{1}       & 2        & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{1}       & 944.69   & \multicolumn{1}{c|}{1}        & \multicolumn{1}{c|}{1}       & 919.03   & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{2}       & 5.82     \\ \hline
\multicolumn{1}{|c|}{loop-zilu}         & 26    & \multicolumn{1}{c|}{26}       & \multicolumn{1}{c|}{0}       & 0.77     & \multicolumn{1}{c|}{25}       & \multicolumn{1}{c|}{1}       & 1064.60  & \multicolumn{1}{c|}{26}       & \multicolumn{1}{c|}{0}       & 307.18   & \multicolumn{1}{c|}{0}        & \multicolumn{1}{c|}{26}      & 68.24    \\ \hline
\multicolumn{1}{|c|}{loops}             & 18    & \multicolumn{1}{c|}{15}       & \multicolumn{1}{c|}{3}       & 3.26     & \multicolumn{1}{c|}{17}       & \multicolumn{1}{c|}{1}       & 536.33   & \multicolumn{1}{c|}{17}       & \multicolumn{1}{c|}{1}       & 1123.35  & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{14}      & 48.36    \\ \hline
\multicolumn{1}{|c|}{loop-lit}          & 10    & \multicolumn{1}{c|}{10}       & \multicolumn{1}{c|}{0}       & 22.22    & \multicolumn{1}{c|}{10}       & \multicolumn{1}{c|}{0}       & 280.87   & \multicolumn{1}{c|}{5}        & \multicolumn{1}{c|}{5}       & 5655.33  & \multicolumn{1}{c|}{7}        & \multicolumn{1}{c|}{3}       & 29.59    \\ \hline
\multicolumn{1}{|c|}{loop-acceleration} & 10    & \multicolumn{1}{c|}{9}        & \multicolumn{1}{c|}{1}       & 0.32     & \multicolumn{1}{c|}{9}        & \multicolumn{1}{c|}{1}       & 493.13   & \multicolumn{1}{c|}{9}        & \multicolumn{1}{c|}{1}       & 1030.78  & \multicolumn{1}{c|}{8}        & \multicolumn{1}{c|}{1}       & 27.48    \\ \hline
\multicolumn{1}{|c|}{loop-crafted}      & 2     & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{0}       & 0.09     & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{0}       & 49.59    & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{0}       & 27.97    & \multicolumn{1}{c|}{2}        & \multicolumn{1}{c|}{0}       & 5.63     \\ \hline
\multicolumn{1}{|c|}{\cite{DBLP:conf/vmcai/BoutonnetH19}}      & 9     & \multicolumn{1}{c|}{9}        & \multicolumn{1}{c|}{0}       & 2.12     & \multicolumn{1}{c|}{9}        & \multicolumn{1}{c|}{0}       & 286.24   & \multicolumn{1}{c|}{4}        & \multicolumn{1}{c|}{5}       & 4576.98   & \multicolumn{1}{c|}{6}        & \multicolumn{1}{c|}{3}       & 28.98      \\ \hline
\multicolumn{1}{|c|}{\textbf{Total}}      & \textbf{114}     & \multicolumn{1}{c|}{104}        & \multicolumn{1}{c|}{10}       & \textbf{34.65}     & \multicolumn{1}{c|}{\textbf{107}}        & \multicolumn{1}{c|}{6}       & 8939.56   & \multicolumn{1}{c|}{68}        & \multicolumn{1}{c|}{46}       & 43573.42   & \multicolumn{1}{c|}{54}        & \multicolumn{1}{c|}{59}       & 330.83      \\ \hline

\end{tabular}%
}
\caption{Comparisons Over 114 Benchmarks}
\label{exp:ComparisonOverTools}
\end{table}

The complete comparison results of \ToolName\ with other tools are presented in Table~\ref{exp:ComparisonOverTools}. In the table, \textit{Source} indicates the source category of the benchmark. The term \textit{\#Ver.} represents the number of examples that were correctly verified by the verifier, and \textit{\#Unk.} (unknown) mainly arises from the following situations: a) The front-end fails to parse correctly, resulting in program crashes. b) Returns \textbf{Unknown}. c) Timeouts. For the benchmarks from~\cite{DBLP:conf/vmcai/BoutonnetH19}, which do not contain assertions to be verified, we set the invariants generated by our \ToolName\ as assertions and test them over the other three tools to obtain results.

From the table, it is evident that \ToolName\ typically requires less than 0.2 seconds averagely for verification, and its overall verification accuracy is very close to that of the SV-COMP winner Veriabs, significantly outperforming Veriabs in terms of time efficiency by 10X to 1000X. This is mainly because Veriabs employs a rich strategy to assist verification, granting it a stronger verification capability but also requiring more time for most examples. Despite that the tool from~\cite{oopsla23} having the fewest number of verified benchmarks, it outperforms CPAChecker and Veriabs in examples suitable for recurrence analysis. CPAChecker, as the most widely used and comprehensive bounded model checking and interpolation tool, experienced a broad range of timeouts in examples with complex loops that could not be verified within a finite unfolding of loops.

In summary, we conclude that \ToolName\ significantly outperforms other tools such as Veriabs in time efficiency for affine numerical programs, while its verification capability is not inferior to the SV-COMP winner Veriabs. We also conducted an in-depth analysis of the ten cases where our \ToolName\ returns \textbf{Unknown}. Some failures were due to type range constraints not yet implemented in the front-end (2 cases), or more complex property strengthening techniques were required, such as setting the generated invariant as a precondition and iteratively calculating the entire loop's invariant (1 case), dependency on modular arithmetic or dividing program variables into different modulus situations (3 cases), and cases requiring more complex loop generalization (2 cases), exceeding the computational range of the backend PPL library (1 case), and seemingly linear arithmetic but actually exponential iterative calculations (1 case). 7-8 of these cases could be further solved by optimizing the frontend and backend implementations. In the verifiable cases, the preliminary implementation of \ToolName\ has already far surpassed existing methods in efficiency. 

\begin{remark}[Other Related Approaches]
We are unable to have direct comparison with the very related work \citet{DBLP:conf/vmcai/BoutonnetH19,FSE2022,DBLP:journals/entcs/HenryMM12,DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21} due to the following reasons. First, the works \citet{DBLP:conf/vmcai/BoutonnetH19,DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21} neither publicize their implementation nor report the detailed invariants in some key benchmarks. 
Second, although the tool PAGAI~\cite{DBLP:journals/entcs/HenryMM12} claims the functionality of disjunctive invariant generation, we find that this functionality could not work in the disjunctive-invariant-generation mode.
Third, the tool in~\citet{FSE2022} accepts only the smtlib format of the CHC solver and has a preprocessing on the original CHC input, making the recovery of the original loop information difficult. We have tried the submodules of SeaHorn~\cite{SeaHorn} and Eldarica~\cite{Eldarica} to transform several examples with simple control flow from the literature 
%(e.g., \emph{Gopan07} and \emph{POPL07}) 
into their CHC format, but this tool does not terminate on the CHC inputs of these simple examples. 
%whereas the transformation of a program into the smtlib format is sophisticated and there is no existing tool that converts between the two complete different formats. In addition, their benchmarks are in smtlib format, so that we can not recover the loop information. 
%loses key information such as the execution feature of loop. 
%underling the smtlib-format mainly used for assertion verification and there are additional information involved when transforming C programming language into smtlib, which requires additional symbolic encoding making it entirely different but does not give a standard interface. To avoid making the comparison unfair, we do not compare to these software verification tools. 
We also note that machine learning approaches~\cite{DBLP:conf/iclr/RyanWYGJ20, DBLP:conf/pldi/YaoRWJG20, DBLP:conf/nips/SiDRNS18} could also generate disjunctive invariants, but we found robustness problem that a slight deviation in a simple program (without changing the branch structure in the loop) can cause these approaches non-terminating. Our approach is based on constraint solving and therefore does not have this robustness issue. \qed
\end{remark}

\subsection{Comparison in Invariant Propagation (RQ2)}
In this section, we compare the performance of \ToolName\ with and without invariant propagation on the aforementioned benchmarks. In Table~\ref{exp:propagation}, we present the overall results, where we can clearly observe that the use of invariant propagation leads to a 5X-50X improvement in time efficiency.

More specifically, through the scatter plot in Figure~\ref{fig:CompareProgation}, we compared the time performance of individual examples before and after the application of invariant propagation techniques. In some cases, invariant propagation led to significant efficiency improvements (10X-1000X). This is due to the fact that for more complex programs, the size of the \LTS{} \(\Gamma\) is larger, and applying invariant propagation techniques on this basis can maximize performance optimization. However, since the tool itself performs efficiently in most examples, the optimization brought by this technique is not apparent in those cases in the graph where the time is below 0.1 seconds. This is because the propagation itself, including the projection of sub-ATS, incurs a certain time cost, which dilutes the time optimization brought about by invariant propagation.

In conclusion, we can summarize that the invariant propagation technique significantly enhances the tool's scalability and yields better optimization results for relatively complex examples.

\begin{table}[t]
    \centering
    \resizebox{0.7\linewidth}{!}{%
        \begin{tabular}{|cc|cccccc|}
        \hline
        \multicolumn{2}{|c|}{\multirow{2}{*}{Benchmark}} & \multicolumn{6}{c|}{\ToolName}                                                                                                                                    \\ \cline{3-8} 
        \multicolumn{2}{|c|}{}                           & \multicolumn{3}{c|}{No PPG}                                                               & \multicolumn{3}{c|}{PPG}                                             \\ \hline
        \multicolumn{1}{|c|}{Source}        & \#Num      & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & \multicolumn{1}{c|}{Time (s)} & \multicolumn{1}{c|}{\#Ver.} & \multicolumn{1}{c|}{\#Unk.} & Time (s) \\ \hline
        \multicolumn{1}{|c|}{SV-COMP}       & 105        & \multicolumn{1}{c|}{93}     & \multicolumn{1}{c|}{12}     & \multicolumn{1}{c|}{1825.53}  & \multicolumn{1}{c|}{95}     & \multicolumn{1}{c|}{10}     & 32.53    \\ \hline
        \multicolumn{1}{|c|}{paper}         & 9          & \multicolumn{1}{c|}{9}      & \multicolumn{1}{c|}{0}      & \multicolumn{1}{c|}{10.76}    & \multicolumn{1}{c|}{9}      & \multicolumn{1}{c|}{0}      & 2.12     \\ \hline
        \end{tabular}
    }
    \smallskip
    \caption{Experiment for Invariant Propagation}
    \label{exp:propagation}
\end{table}

% Figure environment removed




