\section{Related Works}

Below we compare our approach with the most related approaches in the literature. %of invariant generation and loop summary. %We first have the comparison in invariant generation, then loop summary. 
%\paragraph{Constraint Solving} 
%As mentioned previously, the method of constraint solving generates invariants  by first constructing a template with unknown parameters for the invariants to be generated, then establishing constraints for the template from the inductive conditions for invariants, and finally obtaining the concrete invariants by solving the unknown parameters in the template against the established constraints. 
We first have the comparison with the constraint-solving approaches. 
%Note that our approach generates affine invariants via Farkas' Lemma, and hence is a constraint-solving approach for numerical invariant generation. The detailed comparison is as follows. 
\begin{itemize}
\item 
Our approach uses the framework to apply Farkas' Lemma as proposed in~\citet{DBLP:conf/cav/ColonSS03,DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} and extend the framework to disjunctive affine invariants, for which our basic contribution is the construction of an affine transition system that utilizes the disjunctive feature from the conditional branches in a loop. Furthermore, we propose invariant propagation to improve the time efficiency, the tackling of infeasible implications in the application of Farkas' Lemma to improve the accuracy, and the use of loop summary to handle nested loops.  
%so as to improve time efficiency and accuracy. 
The recent result~\cite{DBLP:conf/cav/JiFFC22} also considers Farkas' Lemma, but focuses on conjunctive affine invariants over non-nested affine while loops via the use of eigenvalues and roots of polynomial equations, and hence is orthogonal to our approach. Besides, other approaches on affine invariant generation include ~\citet{DBLP:conf/pldi/GulwaniSV08,DBLP:conf/atva/OliveiraBP17,DBLP:conf/cav/GuptaR09}. 
The approach~\cite{DBLP:conf/pldi/GulwaniSV08} solves the quadratic constraints derived from Farkas' Lemma by SAT solvers and bit-vector modeling. 
% to generate conjunctive affine invariants.  
The approach~\cite{DBLP:conf/atva/OliveiraBP17} uses eigenvectors to handle several restricted classes of conjunctive affine invariants.
The tool InvGEN ~\cite{DBLP:conf/cav/GuptaR09} generates conjunctive affine invariants by an integrated use of abstract interpretation and Farkas' Lemma. 
These approaches 
% target conjunctive affine invariants, and 
propose completely different techniques, and thus are orthogonal to our approach. 
\item Since our approach targets affine invariant generation, it is incomparable with previous results on polynomial invariant generation~\cite{DBLP:conf/dagstuhl/Kapur05,DBLP:journals/fcsc/YangZZX10,DBLP:conf/pldi/Chatterjee0GG20,DBLP:conf/lics/HrushovskiOP018,DBLP:conf/issac/Rodriguez-CarbonellK04,DBLP:conf/vmcai/Cousot05,DBLP:conf/sas/AdjeGM15,DBLP:journals/fcsc/LinWYZ14,DBLP:conf/cav/ChenHWZ15,DBLP:conf/atva/OliveiraBP16,DBLP:conf/issac/HumenbergerJK17,DBLP:conf/popl/SankaranarayananSM04}. 
%Note that, although affine functions are a special case of polynomials with degree $1$, these approaches focus on how to handle general polynomials (i.e., the general case that the degree can be greater than $1$) (through e.g. the Gr\"{o}bner base) and hence are orthogonal to our approach. 
Moreover, most of these approaches consider  conjunctive polynomial invariants, and hence do not consider disjunction. 
\end{itemize}
It is also worth noting that the previous work~\cite{DBLP:conf/cav/SharmaDDA11} proposes a general framework for detecting multiphase disjunctive invariants that can be instantiated with constraint solving. Multiphase disjunctive invariants are a restricted case of our transformation into affine transition systems in the sense that each phase in a multiphase feature cannot go back to previous phases, while in an affine transition system, locations can go back and forth via transitions. 
%a special PDA in which a location cannot go back to itself once the location is left. 
Therefore, we consider a wider class of disjunctive invariants as compared with~\citet{DBLP:conf/cav/SharmaDDA11}. 

Second, we compare our approach with the results~\cite{DBLP:conf/sigsoft/XieCLLL16,DBLP:conf/tase/LinZCSXLS21} that consider a similar disjunctive pattern to ours. These approaches propose \emph{path dependency automata} that consider different execution paths of the loop body w.r.t whether each conditional branch in the loop body is entered or not, treat each execution path as a standalone mode, and have transitions between these modes. However, an indispensible ingredient of path dependency automata is the exact estimation of the number of loop iterations sojourning in each mode, and hence is limited to inductive variables (i.e., assignments must be in the form $x:=x+c$ or $x:=c \ast x$) and strict alternation between different modes. Our approach constructs affine transition systems between different locations derives from the conditional branches, and hence do not have such limitation. 
%is more flexible than these approaches. 
Moreover, we extend our approach to handle nested loops via loop summary, while these approaches could not have an adequate support for nested loops.  

Third, we compare our control flow transformation with the related notion of control flow refinement~\cite{DBLP:conf/emsoft/BalakrishnanSIG09,DBLP:conf/pldi/GulwaniJK09,DBLP:journals/pacmpl/CyphertBKR19,DBLP:conf/cav/SilvermanK19} in the literature. These approaches mostly focus on representing the control flow of multiple loop iterations as regular expressions and refine these regular expressions by various approaches such as 
abstract domains, simulation relation and even invariant generation to reduce infeasible paths. 
Our control flow transformation considers the loop body within a single loop iteration, and is dedicated to the application of Farkas' Lemma. Thus, our control flow transformation has a different focus compared with these results. 



Fourth, we compare our approach with  abstract interpretation. Compared with the approaches that generate conjunctive affine invariants via polyhedral abstract domain~\cite{DBLP:conf/popl/CousotH78,DBLP:conf/sas/BagnaraHRZ03,DBLP:conf/popl/SinghPV17}, our approach targets the more general case of disjunctive affine invariants. There are also a bunch of abstract interpretation approaches in disjunctive affine invariant generation, 
such as 
the work~\cite{DBLP:conf/sas/GopanR07} that performs disjunctive partitioning by representing the contribution of each iteration with a separate abstract-domain element, 
the recent work~\cite{DBLP:conf/vmcai/BoutonnetH19} that distinguishes different disjunctive cases by different entries into the conditional branches w.r.t the input values, 
and the state-of-the-art tool PAGAI~\cite{DBLP:journals/entcs/HenryMM12} that may infer disjunctive invariants as disjunctions of elements of the abstract domain via specific iteration algorithm. 
% such as 
% the work~\cite{DBLP:conf/sas/GopanR07} that adds disjunctive invariants upon entering new conditional branches, 
% the recent work~\cite{DBLP:conf/vmcai/BoutonnetH19} that distinguishes different disjunctive cases by different entries into the conditional branches w.r.t the input values, 
% and the state-of-the-art tool PAGAI~\cite{DBLP:journals/entcs/HenryMM12} may infer disjunctive invariants in abstract domain depending on an iteration algorithm. 
These approaches are based on abstract interpretation and heuristics different from our disjunctive pattern and techniques,
%our application and improvement of Farkas' Lemma, 
and hence are orthogonal to our approach. %The experimental evaluation with a state-of-the-art abstract interpretor PAGAI~\cite{DBLP:journals/entcs/HenryMM12,PAGAI} shows that our approach can generate much tighter disjunctive affine invariants. 
It is worth noting that although our invariant propagation has a similar propagation process as abstract interpretation does, they are actually different as abstract interpretation usually requires a repeated iteration until a fixed point is reached, while our invariant propagation does not have such a fixed point computation. 

Fifth, we compare our approach with recurrence analysis~\cite{DBLP:conf/fmcad/FarzanK15,DBLP:conf/pldi/KincaidBBR17,DBLP:journals/pacmpl/KincaidCBR18}. Recurrence analysis works well over programs with specific structure that ensures closed form solutions. 
%usually relies on the existence of a closed form solution. 
For example, the most related recurrence analysis approach ~\cite{oopsla23} (that also targets disjunctive invariants) solves the exact invariant over the class of loops with (ultimate) strict alternation between different modes.  
%between top-level conditional branches to ensure the existence of a closed form solution, so that the applicability of this approach is limited and does not include nested loops. 
Compared with recurrence analysis, our approach does not require specific program structure to ensure closed form solution, but is less precise over programs that can be solved exactly by recurrence analysis.  

%Moreover, our experimental evaluation shows that our approach can prove safety properties that are beyond state-of-the-art software verifiers such as Seahorn, CPAChecker and Veriabs. 
%CPAChecker, SeaHorn and Ultimate Automizer, and is numerically robust against machine learning approaches. 
%We believe that this results from two facts: (i) The application of Farkas' Lemma well suits the situation where precise affine invariants are needed; (ii) The application of PDA captures common disjunctive features in a loop.
%Finally, it is worth  noting that a heuristic approach also based on the top-level branches is proposed in~\citet{DBLP:conf/tase/LinZCSXLS21} recently, but this approach relies heavily on the heuristics of inductive variables (i.e., assignments must be in the form $x:=x+c$ or $x:=c \ast x$) and the guessing of invariants, does not focus on nested loops, and requires a goal property; in contrast, our approach can handle PDA with arbitrary affine assignment and nested loops, and does not require a goal property. 
%(instead, our approach generate invariants by generator computation of polyhedral cones). 

Finally, we compare our approach with other methods such as machine learning, inference and data-driven approaches. 
%We first have a methodological comparison as follows. 
Unlike constraint solving that can have an accuracy guarantee for the generated invariants based on the constraints, these methods cannot have an accuracy guarantee. 
%since they cannot guarantee the accuracy of the coefficients in numerical invariants. 
Furthermore, machine learning and data-driven approaches themselves cannot guarantee that the generated assertions are indeed invariants. 
%while logical inference approaches often require a goal property and manual efforts. 
Moreover, our approach can generate invariants \emph{without} the need of a goal property, while these approaches
%several approaches (such as IC3~\cite{DBLP:conf/fmcad/SomenziB11}, CLN2INV~\cite{DBLP:conf/iclr/RyanWYGJ20}, \citet{FSE2022}) and state-of-the-art program analysis platforms (such as CPAchecker~\cite{CPAchecker}, SeaHorn~\cite{SeaHorn} and Ultimate Automizer~\cite{UltimateAutomizer}) 
usually requires a goal property.  
%and are only capable of generating invariants relevant to prove the property. 
Note that the invariant generation without a given goal property is a classical setting (see e.g. ~\citet{DBLP:conf/cav/ColonSS03,DBLP:conf/popl/CousotH78}), and has applications in loop summary and 
probabilistic program verification (see e.g.~\citet{DBLP:conf/cav/ChakarovS13,DBLP:conf/pldi/WangS0CG21}). 
%Next, 
%%for the purpose of an experimental evaluation, 
%we have compared our approach with the most recent data-driven approach in~\citet{FSE2022} and experimental results show that ???. Seahorn ??. 

%Finally, we compare our approach with the related approaches on loop summary. Compared with the approaches~\cite{DBLP:conf/cc/CousotC02,CousotSSGRR} that are based on convex polyhedra abstract domain and can only generate conjunctive affine loop summaries, our approach is able to generate disjunctive loop summaries. Compared with the approach by~\citet{DBLP:conf/vmcai/KranzS18} that applies Heyting completion~\cite{DBLP:journals/toplas/GiacobazziS98} (to make an existing domain meet-distributive) on-demand and computes a summary of the function for each on-demand created predicate (represented via Herbrand terms), our approach is capable of generating affine inequality invariants with arbitrary coefficients, while their approach mainly uses an equality domain (as well as a pointer domain) to track equality relations of limited form between variables. Compared with the approach by~\citet{DBLP:conf/vmcai/BoutonnetH19} that enhances abstract interpretation with disjunction from distinct entries into the conditional branches in the program by different initial inputs, our approach is orthogonal in the sense that we apply Farkas' Lemma and the top-level branches, which are completely different. Compared with (i) the PIPS tool~\cite{DBLP:conf/ics/IrigoinJT91,DBLP:journals/entcs/AncourtCI10,PIPS} that employs heuristics to generate conjunctive affine loop summaries and (ii) the approach by~\citet{DBLP:journals/entcs/AncourtCI10} that generates conjunctive affine invariants by a simple heuristics that examines the stepwise incremental update of affine assignments, our approach follows a completely different methodology 
%(Farkas' Lemma and the PDA pattern) and generates disjunctive affine loop summary. Compared with the approaches by ~\citet{DBLP:conf/asian/PopeeaC06,DBLP:journals/scp/PopeeaC13} that maintain a set of limited pre-fixed number of polyhedra for abstracting program states at each program point (to derive a disjunctive polyhedral analysis) under the framework of abstract interpretation, our approach is orthogonal to them and does not require the user to manually provide assertions. 
% Compared with the approaches by ~\citet{DBLP:conf/asian/PopeeaC06,DBLP:journals/scp/PopeeaC13} that requires the user to provide assertions and checks the provided assertions by complete decision procedures, our approach does not require the user to manually provide assertions. 
%Compared with the approach~\cite{DBLP:conf/sigsoft/XieCLLL16} that proposes the PDA pattern, our approach solves PDA by Farkas' Lemma so that PDAs with arbitrary affine assignments, nested loops and nondeterminism can be handled, while their approach is limited to inductive variables 
%%($x:=x+c$ or $x:=c \ast x$) 
%and strict alternation between PDA states.  
%so that their approach can only handle affine assignments and PDA patterns in restricted forms and cannot handle nondeterminism and nested loops. It would also be an interesting future direction to investigate how our approach could be used for procedure summary~\cite{DBLP:conf/ifip/Allen74,DBLP:conf/pldi/ZhangMNY14,DBLP:conf/esop/GulwaniT07}.


%Then we compare our results with existing approaches in procedure summary. The most relevant results are based on abstract interpretation~\cite{?,?}, the state-transition pattern ~\cite{?} and heuristics~\cite{?,?}. First, although our approach is based on the the state-transition pattern~\cite{?}, the original work only handles several deterministic regular patterns and incremental affine assignments (i.e., assignments of the form $x:=x+c$ where $c$ is a constant), while we further apply Farkas' Lemma and several related algorithmic improvements so that both nondeterminism, irregular patterns and aribitrary affine assignments can be handled. Second, compared with abstract interpretation based approaches that only handles multiphase disjunctive invariants or disjunctive invariants from different parts of inputs both determined by the conditional branches in the program, our approach considers the state-transition pattern arising from the conditional branches of the program, hence is more general than these approaches. Compared with the approaches~\cite{?,?} that are based on heuristics, our approach inherits the high accuracy from the completeness of Farkas' Lemma and reasonable affine under-approximation from the previous Farkas-based approaches~\cite{?,?}. Moreover, we show by experimental results that our approach can derive much tighter disjunctive loop summary than a standard loop summary tool PIPS~\cite{?}.  