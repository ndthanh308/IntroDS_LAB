\section{Overview of Our Approach}
\label{overview}
Below we use a simple affine while loop 
%with disjunctive feature 
as an example to provide an overview of our approach.
%how our method operates.%\ke{A slight modification has been made here.}
% In this section, we describe our our approach via a simple while loop with disjunctive feature. We first take a look at the example below. 


% Figure environment removed

%\ke{modification here.}
Consider the simple affine program \( P_1 \) as shown in Figure
~\ref{fig:ExampleLoopAndTransformedLoop}. Our method primarily involves three steps. \emph{The first step} is to transform general non-nested loops into a canonical control flow format, which is done by traversing from the loop head to the loop tail, extracting each feasible path \( \tsPath \) of the loop body, and converting it into an equivalent canonical form. This form corresponds to one \textbf{case} statement for each path's guard condition \( \phi \), where each guard condition is a conjunction of a conditional formula \( \phi_c \) and an assignment formula \( \phi_a \).


\begin{example}\label{eg:transformedcode}
%\ke{modification here.} 
Take the transformed program \( P_2 \) in Figure~\ref{fig:ExampleLoopAndTransformedLoop} as an example. we elaborate the transformation for $\textbf{case } x>49$. 
Starting from the loop head and traversing the source program \( P_1 \), we first handle the assignment \( x = x + 1 \) and transform the statement to the assignment formula \( \phi_a:= x'=x+1 \), where $x'$ is the value of $x$ after the assignment. 
Continuing the traversal, we handle the if branch $\textbf{if} (x>50)$ and explore both the situations where the branch condition is \emph{true} and \emph{false}. If the branch condition evaluates to \emph{true}, we establish the conditional formula \( \phi_c:= x+1 > 50 \) since the current value of $x$ has been incremented by one in the loop execution, and then traverse the assignment  \( y = y+1 \), resulting in the updated assignment formula \( \phi_a= x'=x+1 \wedge y'=y+1 \). At this point, the traversal reaches the loop tail. Hence, the path for the if branch evaluated to \emph{true} is described by the formula 
$\phi_c\wedge \phi_a$ where \( \phi_c=x > 49 \) and \( \phi_a = x'=x+1 \wedge y'=y+1 \), and corresponds to $\textbf{case } x>49$ in \( P_2 \). \qed
% We push the if branch $\textbf{if}~(x>50)$ in Figure~\ref{fig:The source code} to the front of the loop body, so that we have two top-level branches $x>49$ and $x\le 49$ in Figure~\ref{fig:The transformed code}. Notice that if the value of $x$ is no greater than $49$ at the entry point of the original loop body, then the if branch is not executed and only the variable $x$ is incremented. Otherwise (i.e., the value of $x$ is greater than $49$), both the variables $x,y$ are incremented in the loop iteration. Thus, in Figure~\ref{fig:The transformed code} we have a special \textbf{switch} statement at the top of the loop body, and two top-level branches $x>49$ and $x\le 49$ to distinguish between the cases of the increment of only $x$ or both $x,y$. Our aim is to obtain independent invariants for the cases of $x>49$ and $x\le 49$, say $\eta_1$ for $x>49$ and $\eta_2$ for $x\le 49$, and the final invariant is the disjunction of $\eta_1\wedge x>49$ and $\eta_2\wedge x\le 49$ (i.e., $(\eta_1\wedge x>49) \vee (\eta_2\wedge x\le 49)$). \qed
\end{example}

To obtain affine disjunctive invariants over the transformed program \( P_2 \), \emph{the second step} is to construct an ATS from \( P_2 \). In this ATS, each \textbf{case} statement in the program \( P_2 \) is considered as an independent location. The jumps between the locations are derived from the jumps between difference case statements in the current and next loop iteration of \(P_2\). 

%two paths of the loop are treated as transitions in the \LTS{}.

% To obtain the invariants for the top-level branches, \emph{our second step} is to construct an affine transition system that includes every top-level branch as a standalone location (we shall refer to such a location as a \emph{branch location}) and every possible jump between the top-level branches (for the current and next loop iteration) as a transition. The details are given as follows. 

\begin{example}\label{eg:runningtransitions} %\ke{modification here.}
To create an ATS from the transformed program \( P_2 \), our primary focus is on the creation of locations and transitions. In \( P_2 \), there are two \textbf{case} statements, leading to a maximum of four possible transitions in a complete directed graph. The ATS is shown in Figure~\ref{fig:ATSforTransformedLoop}. 
Take the self-loop transition $\tau_1$ at \( \tsLoc_1 \) in the figure. 
The location \( \tsLoc_1 \) corresponds to 
\(\textbf{case } x > 49 \) in \( P_2 \), and we denote $\phi_c:=x>49$. 
The transition \( \tsTran_{1}:=\langle \tsLoc_{1},\tsLoc_{1},\tsGuardcond_{1} \rangle \) describes the situation that the loop \( P_2 \) executes the case of $x>49$ both in the current and next loop iteration. In this transition, the guard condition $\tsGuardcond_{1}$ is a conjunction specifying that both the current and the next loop iterations enter 
\(\textbf{case } x > 49 \), which gives 
$$
\tsGuardcond_{1}:= \phi_c \wedge \phi_c[x'/x] \wedge \phi_a\wedge G\wedge G[x'/x]
$$
where $\phi_a:= x'=x+1 \wedge y'=y+1$ is the assignment formula discussed in Example~\ref{eg:transformedcode} and $G:=x<100$ is the loop guard. Other transitions 
(i.e., $\tau_2, \tau_3, \tau_4$)  are derived similarly, see Figure~\ref{fig:ATSforTransformedLoop} for details. \qed
\end{example}

%\( \tsGuardcond_{1} \)  satisfy \( \phi_{1c} \wedge G := x \ge 49 \wedge x<100 \), with \( G \) representing the loop condition. Additionally, considering the change in variable assignments from the path's assignment formula \( \phi_{1a}:= x'=x+1 \wedge y'=y+1 \), and for the variables to enter \( \tsLoc_{1} \) in the second loop iteration, the post-transition primed variables must satisfy \( \phi'_{1c} \wedge G' := x' \ge 49 \wedge x' <100 \). Thus, we derive \( \tsGuardcond_{1}:= \phi_{1c} \wedge G \wedge \phi_{1a} \wedge \phi'_{1c} \wedge G' \). 

%This formulation can be generalized to any transition from \( \tsLoc_{i} \) to \( \tsLoc_{j} \), with specific results referenced in Figure~\ref{fig:ATSforTransformedLoop}. 

After the ATS is constructed, \emph{the third step} is to apply the approaches~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} in Farkas' Lemma to obtain invariants at the locations of the ATS, and group them disjunctively together to obtain the final invariant.  Below we give a brief illustration. 

\begin{example}\label{eg:farkasapplication}
Consider to generate affine invariants over the \LTS{} in Figure~\ref{fig:ATSforTransformedLoop}. The approach~\cite{DBLP:conf/sas/SankaranarayananSM04} first establishes an affine template at each location by setting $\tsMap(\tsLoc_{i}) := \fkCoeff_{\tsLoc_{i},1}x + \fkCoeff_{\tsLoc_{i},2}y + \fkConst_{\tsLoc_{i}} \geq 0$ for $i \in \{1,2\}$, where $\fkCoeff_{\tsLoc_{i},1},\fkCoeff_{\tsLoc_{i},2},\fkConst_{\tsLoc_{i}}$ are unknown coefficients to be resolved. Then, it generates the constraints from  the initialization and consecution conditions and simplifies the constraints by the Farkas' tabular in Figure~\ref{tab:farkas}. 
The initialization of $\tsInitcond \models \tsMap(\tsLoc^*)$ results in linear constraints over the unknown coefficients, but the consecution  $\tsMap(\tsLoc) \wedge \tsGuardcond \models \tsMap(\tsLoc')'$ for a transition $\tsTran = \langle \tsLoc, \tsLoc', \tsGuardcond \rangle$ results in quadratic constraints in the unknown coefficients since we have an unknown coefficient (say $\mu$) multiplied to $\tsMap(\tsLoc)$. To resolve the quadratic constraints from the consecution, the previous approach~\cite{DBLP:conf/sas/SankaranarayananSM04} has considered heuristics to guess the value of the multiplier $\mu$ through either practical rules such as factorization or setting $\mu$ manually to $0$ or $1$. 

%For initialization, the tabular in Figure~\ref{tab:fktabinit} gives the simplified constraints $[\fkCoeff_{\tsLoc_{2},1}=\lambda_{1},\fkCoeff_{\tsLoc_{2},2}=\lambda_{2},\fkConst_{\tsLoc_{2}} \geq -50\lambda_{2}]$ (\ke{}where $\lambda_{0} \ge 0$ but we do not impose restriction on $\lambda_{1},\lambda_{2}$) and  generates the constraints $[50\fkCoeff_{\tsLoc_{2},2}+\fkConst_{\tsLoc_{2}} \geq 0]$ by projecting away the fresh variables $\lambda_{j}$'s.
%For consecution, we present the application of the Farkas' tabular to the transition $\tsTran_{4}$ as in Figure~\ref{tab:fktabcons}. The fresh variables $\lambda_{j}$'s are projected away and the fresh non-affine variable $\mu$ is eliminated by reasonable heuristics that guesses its value through either practical rules such as factorization or setting $\mu$ manually to $0$ or $1$, \ke{which is a relaxation condition for maintaining the inductiveness of AAM as provided in \cite{DBLP:conf/sas/SankaranarayananSM04}}. 
%Other transitions are treated in a similar way. 
After the application of the Farkas' tabular, the derived constraints in the unknown coefficients constitute a PAP $\Phi$ in CNF.  
%where each clause in the conjunction is the constraint derived from either the initialization or the consecution of a transition, and every disjunctive affine assertion in such a clause in the conjunction results from a distinct value for the non-affine $\mu$ parameter in the tabular for consecution. 
The approach ~\cite{DBLP:conf/sas/SankaranarayananSM04} expands the PAP $\Phi$ equivalently into a DNF where each clause in the disjunction is an affine assertion that defines a polyhedral cone, and further computes the the affine invariants as the generators of the polyhedral cones in the DNF. A polyhedral cone from a clause in the DNF is shown in Figure~\ref{tab:cs} (where we abbreviate $\fkCoeff_{\tsLoc_{i},j}$, $\fkConst_{\tsLoc_{i}}$ as $\fkCoeff_{ij}$, $\fkConst_{i}$), and the generators of the polyhedral cone is shown in the left part of Figure~\ref{tab:geninv} where "point" means a single vector, "ray" means a vector that can be scaled by an arbitrary positive value, and "line" means a vector that can be scaled by an any positive or negative value. When putting the generators back to invariants, we obtain the invariants shown in the right part of 
Figure~\ref{tab:geninv}. 
%by the generator computation of each polyhedral cone in the DNF PAP. For this example, one clause in the disjunction (treated as a polyhedral cone) 
%from the DNF formula is shown in ; 
%further by computing the generators of the polyhedral cone in Figure~\ref{tab:cs}, we obtain the corresponding generators and their invariants in Figure~\ref{tab:geninv}, where in the left part each row specifies a generator with a type (a point, a ray or a line generator) over the unknown coefficients $\fkCoeff_{ij}$'s and $\fkConst_{i}$'s, and in the right part we instantiate the generator to the unknown coefficients in the template $\tsMap$ to obtain the invariants at location $\tsLoc_{1}$, $\tsLoc_{2}$. 

% Figure environment removed

In Figure~\ref{tab:geninv}, we remove trivial invariants such as $0\ge 0$ and redundant inequalities. %After processing all the disjunctive clauses of the DNF and grouping all the generated invariants together, 
In the end, the overall disjunctive invariant at 
the entry point of the loop body is $\tsMap(\tsLoc_{1})\vee \tsMap(\tsLoc_{2})$, which is 
$(x = y\wedge 50 \leq x \leq 99) \vee  (y = 50\wedge 0 \leq x \leq 49)$. 
Additionally, we can calculate the invariant at the loop exit location, which we denote by \( \tsLoc_{e} \). The calculation formula can be expressed as 
\( \tsMap(\tsLoc_{e})=\bigvee_i (\tsMap(\tsLoc_{i}) \wedge \phi_{ia} \wedge \neg G) \), where \( \phi_{ia} \) is the assignment formula corresponding to the path of \( \tsLoc_{i} \), and \( G \) is the loop guard. Therefore, we can simply calculate \( \tsMap(\tsLoc_{e}):= x=y=100 \).
%\ke{I have removed the part related to $\tsLoc_{e}$ in the table, including the generator associated with $\tsLoc_{e}$ and so on, because $\tsLoc_{e}$ itself does not need to be calculated in this manner. It's sufficient to consider the main body within the loop, which is also in line with the previous sections.}
% the invariant for the termination location $\tsLoc_e$ is derived from the invariants at $\tsLoc_{1}, \tsLoc_{2}$ and the transitions to $\tsLoc$ as 
% $\tsMap(\tsLoc_{e})= (x = y = 100)$. The approach~\cite{oopsla22/scalable} improves the scalability by generating the invariants one location at a time that allows to detect redundant invariants more efficiently. 
\qed 
\end{example}

In the third step, we observe that existing approaches~\cite{DBLP:conf/sas/SankaranarayananSM04,oopsla22/scalable} in Farkas' Lemma is not computationally efficient  since all these approaches require to compute the invariants at all locations of an ATS. Hence, the amount of computation may be huge if the number of locations is considerable. Thus, we propose an invariant propagation technique that computes invariants only at the starting location 
%(projecting the complete PAP in the above example onto template parameters related to the starting location) 
(of a strongly connected component of the ATS) 
and propagates this invariant to other locations through a local topological order. This approach reduces the amount of computation for invariant generation. 
%computational overhead of computing generators and projecting large-dimension polyhedron. 
The following example provides a simple illustration of this technique, with a more detailed treatment to be given in the next section.
% Thus, we propose an \emph{invariant propagation} technique that only computes the invariant at the initial branch location (during which our approach does not compute the invariant at other branch locations) and have a breadth-first propagation of this invariant to other branch locations, when the affine transition system admits a depth-first search tree without cross edges (i.e., edges that go back to a non-ancestor node). The following example illustrates this idea over the ATS in Figure~\ref{fig:The LTS}. 


\begin{example}\label{eg:propagation}
Consider the affine transition system $\Gamma$ in Figure~\ref{fig:ATSforTransformedLoop}. Its underlying directed graph $DG(\Gamma)$ is given in Figure~\ref{fig:ExampleDirectedGraph} 
(here we ignore the termination location $\tsLoc_{e}$).

% Figure environment removed

As we have calculated the invariant 
\(\tsMap(\tsLoc_{2}):= y = 50\wedge 0 \leq x \leq 49\) at the initial location \(\tsLoc_{2}\), we can ignore all transitions leading to \(\tsLoc_{2}\) (the correctness of which will be demonstrated in the next section), transforming it into the form as shown in Figure~\ref{fig:ExampleDirectedGraphEliminateInit}.
By ignoring the self-loop $\tau_1$, we obtain a local topological order \(\tsLoc_{2} < \tsLoc_{1}\). By propagating the invariant $\tsMap(\tsLoc_2)$ along the transition $\tau_4$ to the location $\tsLoc_1$, 
we establish the initial condition $\psi_1$ for the location \(\tsLoc_{1}\). Subsequently, we consider the \LTS{} obtained by removing the location $\tsLoc_1$, corresponding to Figure~\ref{fig:ExampleDirectedGraphAfterCompute}. 
This ATS consists of one location \(\tsLoc_{1}\) with the initial condition \(\psi_{1}\) and the self-loop transition \(\tsTrans_{1}\). By solving this reduced ATS, we obtain the invariant 
%thereby enabling the computation of 
\(\tsMap(\tsLoc_{1})= (x=y \wedge 50 \leq x \leq 99)\). %without projection.
% First, our approach computes the invariant at the initial branch location $\tsLoc_2$ to be $\tsMap(\tsLoc_{2})= (y = 50\wedge 0 \leq x \leq 49)$. Then, our invariant propagation calculates a new initial condition $x = 50\wedge y=50$ for the branch location $\tsLoc_1$ by propagating the invariant $\tsMap(\tsLoc_{2})$ along the transition $\tsGuardcond_{5}$. Next, with the new initial condition, our approach solves the invariant at the branch location $\tsLoc_1$ by  considering only the self-loop transition $\tsGuardcond_{1}$ to obtain $\tsMap(\tsLoc_{1})= (x = y\wedge 50 \leq x \leq 99)$. Note that the back edge from $\tsLoc_1$ to $\tsLoc_2$ does not affect the invariant at $\tsLoc_1$ (even if $\tsGuardcond_{2}$ was feasible). Finally, the invariant at the termination location $\tsLoc_e$ is derived from $\tsMap(\tsLoc_{1})$ and $\tsMap(\tsLoc_{2})$. The key point of invariant propagation over this example is that the invariant at the branch location $\tsLoc_{1}$ is obtained by a propagation from that of $\tsLoc_{2}$, rather than a thorough invariant solving over the whole affine transition system. 
\qed
\end{example}

%\smallskip
%\ke{I ignore the description of loop summary here.}
% \noindent{\em Loop Summaries and Nested Loops.} Besides invariant generation over unnested affine while loops, our approach also generates affine disjunctive loop summary by introducing fresh input variables that represent the inputs of the programs and generating invariants over both the original program variables and the fresh input variables. Furthermore, our approach tackles nested affine while loops by computing the loop summaries of the inner loops and uses these summaries as the abstraction of the inner loops to construct the affine transition system for the outer loop. 


