\section{Methodology}
\label{sec:methodology}

In this section, we present a novel automated approach for producing an accurate and up-to-date set of third-party libraries for use in Android app static analysis.

% Figure environment removed


\noindent
\textbf{Hypotheses:}
Our hypothesis is that:
\dcircle{1} the majority of Android app developers rely on Android Studio and Gradle to build their apps;
\dcircle{2} that Gradle in turn relies on Maven and Google to retrieve libraries~\cite{gradle_maven, gradle_google}; and
\dcircle{3} open-source Android apps can bring valuable information about the library used in apps, thanks to the availability of configuration files (in contrast, APK files considered alone do not contain configuration files).
These 3 points suggest that extracting lists of libraries from the Maven repository, the Google's Android library repository, and open-source Android apps would create, by construction, an accurate set of third-party libraries.


Based on these hypotheses, we set up a straightforward approach that can be seen in Figure~\ref{fig:overview}.
Our approach involves two main steps:
\dcircle{1} extracting lists of libraries from the Maven repository and the Google's Android library repository; and 
\dcircle{2} extracting lists of libraries used in open-source libraries.
Maven is a widely used tool for managing dependencies and building Java-based projects, and the Maven repository is a central location where developers can find and share libraries. 
Maven Central Repository provides an index that is updated weekly. 
Google's Android library repository is a collection of Android libraries available through the Google Maven repository.
In the following sections, we explain in detail how we proceed to build \dataset.

\subsection{Mining repositories}

This section details the process of how we obtained the first portion of our dataset by leveraging public library repositories.
Our process is divided into two steps:
\dcircle{1} obtaining package names from the repositories.
\dcircle{2} gathering transitive dependencies from the previously retrieved package names.

\subsubsection{Package Name Collection}

This section explains how we collect package names from Maven and Google repositories.

\noindent
\textbf{Maven.} 
Our approach to collecting a comprehensive list of third-party libraries for use in Android app static analysis involves extracting package names from the Maven repository. 
To do this, we first download the Maven index file and the Maven Indexer Command Line Interface (CLI) tool which are available publicly.
The Maven index is a file that is created using the Lucene library~\cite{bialecki2012apache} and contains metadata about the artifacts available in the Maven repository. 
The Maven Indexer CLI is a tool that is used to extract this file. 
Once the Maven index file is extracted, we use a Java program of our own, called SearchLuceneIndex, to extract all the \emph{groupIds} from the index.
At the time of writing, our list of package names from the Maven repository contains a total of \libsFromMaven entries.

\noindent
\textbf{Google.}
The next step in our approach involves obtaining a list of package names from the Maven Google repository website (i.e., maven.google.com). 
By accessing this resource, we were able to extract a total of \libsFromGoogle package names.
Once we have obtained the package names from both the Maven repository and the Maven Google repository, we merge the two lists into a single list, eliminating any duplicate entries. This results in a list of \sumWithGoogle package names.

\subsubsection{Transitive Dependency Extraction}

Libraries often rely on other libraries, which are known as transitive dependencies. 
For example, the \texttt{com.android.tools.sdk-common} library in version 22.9.0 has 12 transitive dependencies. 
Figure~\ref{code:tree} illustrates the dependency tree of this library.
In order to create a comprehensive and up-to-date set of third-party libraries, it is important to also consider these transitive dependencies. 

% Figure environment removed

To extract them, we used the Maven utility, which allows building the dependency tree for a project.
However, since we only have a list of libraries and not actual projects, we implemented the following strategy.
First, we obtained, from the maven index, all artifacts in the form of the artifactIds concatenated with groupIds and versions to get the real library names, resulting in a list of \num{10069375} unique libraries.
We considered all available versions for each library because transitive dependencies can differ from one version of a library to another. 
Therefore, to be comprehensive, it was necessary to consider all versions of each library.
Then, for each library, we generated a \texttt{pom.xml} file with a dummy project and the library as a dependency of the project.
We then launched the \texttt{mvn dependency:tree} command to get the list of all transitive dependencies that the library depends on. 
Obtaining transitive dependencies for all libraries in our dataset is a computationally intensive task. 
With a total of \num{10069375} libraries, the process of extracting transitive dependencies for each library would have taken an unreasonable amount of time. 
Therefore, we set a timeout of 30 seconds for each call to the \texttt{mvn dependency:tree} command to ensure that the process would not take an excessively long time. 
Even with this timeout, \num{9312664} (i.e., 92.5\%) dependency trees were successfully built and the process still required 21 days of computation using 70 instances in parallel on a Debian server with an AMD EPYC 7552 48-Core Processor CPU with 96 cores and 630GB of RAM.
This resulted in downloading more than 33 TB of data.
Then, we parsed the dependency trees generated and built a list of \transitiveDependencies additional libraries with any duplicate removed.
It should be note that this number (i.e., \transitiveDependencies) was reached long before the \num{9312664} dependency trees were built.
Indeed, we regularly checked the number of additional libraries (i.e., once per day) and \transitiveDependencies was reached after 10 days, i.e., after that no new libraries were uncovered in the dependency trees.
Finally, we merged this list with the one generated previously, and we removed any duplicates, resulting in a final list of \sumWithTransitiveDependencies package names.


\subsection{Mining open-source Android projects}

This section presents the third part of our approach. 
As previously mentioned, our approach involves extracting lists of libraries from publicly available sources, including open-source Android projects. 
Open-source projects provide valuable information about the libraries, as they often rely on a wide range of third-party libraries to provide specific features and functionality. 
We can obtain a more complete and current set of third-party libraries by mining open-source Android projects.
In the following, we describe the process for extracting lists of libraries from open-source Android projects.

We first obtained a list of open-source Android projects by downloading all apps in \az that were collected from the F-Droid repository, at the time of writing, this represented \num{4464} apps. 
We then used the F-Droid website to crawl the source code links for these apps and attempted to clone the repositories using the \texttt{git clone} command. 
Out of the 4464 apps, we were able to successfully clone the source code of 3425 projects.
Next, we searched through the \texttt{build.gradle} files available in these projects and extracted information about the libraries used by the project. 
Specifically, we searched for the Gradle commands \texttt{implementation}, \texttt{classpath}, and \texttt{compile}, which are commonly used to declare dependencies in projects. 
After parsing the \texttt{build.gradle} files and extracting the relevant information, we obtained a list of \libsOpenSourceProjects unique libraries, which brings our total count of libraries to \sumWithLibsOpenSourceProjects after deduplicating.

To obtain a list of libraries that is as comprehensive as possible, it is not enough to simply consider the libraries explicitly imported in the \texttt{build.gradle} files of the app projects.
It is also necessary to consider library repositories (other than the default Maven and Google) that are declared in the \texttt{build.gradle} files and use this information to search for additional libraries that may be used in the app. 
This process allowed us to discover two additional repositories: jcenter and gradlePluginPortal. 
However, we found that jcenter is deprecated and that all "jcenter" libraries are now available in the Maven repository~\cite{jcenter},  
which we have already mined. 
The gradlePluginPortal website proved to be a valuable resource. 
We conducted a crawl of the gradlePluginPortal website, comprising 656 pages at the time of writing, and were able to obtain an additional list of all package names available on the website.
This led to the discovery of \libsOpenSourceProjectsRepositories libraries, which we added to our list after removing potential duplicates and led to a total of \sumWithLibsOpenSourceProjectsRepositories libraries.

\subsection{Refinement}
We have designed a refinement process to remove unnecessary package names from the list of third-party libraries. This process helps ensure that the list is as concise as possible.
For example, if the list contains the package names "com.example.subpackage" and "com.example", we would only keep "com.example" because this would be sufficient for identifying "com.example.subpackage.MyClass" as a library in an app.
This is done by iterating over the list of package names and checking whether any element $e_1$ in the list starts with another element $e_2$ in the same list. 
If this is the case, the element $e_1$ is removed from the list. This process is repeated until no more changes are made to the list.
Overall, our refinement process yields a list of \libsAfterRefinement package names by discarding \num{55845} of them (i.e., \sumWithLibsOpenSourceProjectsRepositories $-$ \libsAfterRefinement).
Table~\ref{table:steps} shows the detail of all the steps of our methodology with the number of libraries collected.



\begin{table}
    \setlength{\tabcolsep}{1pt}
    \centering
    \caption{Number of libraries after each of our methodology's steps (OS = open-source)}
    \begin{adjustbox}{width=.8\columnwidth,center}
        \begin{tabular}{lccccccccc}
            \hline
            Source &  &  \\ \hline
            Maven & \libsFromMaven &  \\ 
            Google & +\libsFromGoogle &$\rightarrow$& \sumWithGoogle \\ 
            Transitive Dep. && &+\transitiveDependencies & $\rightarrow$ & \sumWithTransitiveDependencies && \\ 
            OS imports & &&&&+\libsOpenSourceProjects & $\rightarrow$ & \sumWithLibsOpenSourceProjects &\\ 
            gradlePluginPortal &&& &&&&+\libsOpenSourceProjectsRepositories & $\rightarrow$ &\sumWithLibsOpenSourceProjectsRepositories \\ \hline
            After Refinement &&&&&&&& & \libsAfterRefinement \\ \hline
        \end{tabular}
    \end{adjustbox} 
    \medskip
    \textit{for each "sum", the result is after removing duplicates}
    \label{table:steps}
\end{table}

\highlight{
The process for generating a large-scale and up-to-date set of third-party libraries is fully automated and uses the latest data from the Maven repository and Google's Android library repository when run as well as data from open-source Android apps.
The resulting list includes \libsAfterRefinement package names, and all of the scripts used in the process are made available to the community.
}