\subsection{Importance of \dataset}
\label{sec:importance}

In this section, we evaluate the importance of \dataset to answer \textbf{RQ3}.
First, we describe the packages extracted from a dataset of apps from 2021 and 2022 and their characteristics. 
Then, we investigate to what extent \dataset can be used to discard libraries for better static analysis.
Eventually, we check if retaining only the packages of the apps' packages declared in the \texttt{AndroidManifest.xml} file is a better approach.
We aim to demonstrate the utility and effectiveness of \dataset for Android app static analysis.

\subsubsection{Description of the 2021--2022 apps dataset}

To evaluate the ability of \dataset in identifying libraries in Android apps, we conducted a study using all apps from \az which dex file date is for the years 2021 and 2022, totaling \num{228540} apps. 
From these apps, we extracted all package names, except the package names of the apps themselves. 
Table~\ref{table:num_packages_2021_2022} presents our results.
A total of \num{18166565495} package names were extracted, with \num{1932371607} (11\%) of these package names classified as obfuscated (in line with Figure~\ref{fig:fqcn_motivation}) and \num{16234193888} (89\%) classified as non-obfuscated. 
The table also presents data on the number of unique package names in the dataset, with a total of \num{1711827} unique package names. 
Of these, 32\% (\num{549113}) are classified as obfuscated, and 68\% (\num{1162714}) are classified as non-obfuscated.

\noindent
\textbf{Types of libraries.}
We examined the top 100 most used unique libraries to gain insights into their purposes.
We found that 65 Android and 35 Google libraries comprised the entirety of these libraries.
Excluding Android and Google libraries from the list revealed that the most commonly used libraries are associated with HTTP communication (e.g., okhttp3 library), Kotlin libraries, framework libraries such as Mono and Xamarin, image libraries like com.bumptech.glide, and Microsoft libraries (e.g., com.microsoft.appcenter).

\begin{table}
    \centering
    \caption{Number of package names extracted from 2021 to 2022 in \az}
    \begin{adjustbox}{width=.9\columnwidth,center}
        \begin{tabular}{lrr}
            \hline
            Packages & Count & Percent\\ \hline
            \# of packages & \num{18166565495} & 100\% \\ 
            \# of non-obfuscated packages & \num{16234193888} & 89\% \\ 
            \# of obfuscated packages & \num{1932371607} & 11\% \\ \hline
            \# of unique packages & \num{1711827} & 100\% \\ 
            \# of unique non-obfuscated packages & \num{1162714} & 68\% \\ 
            \# of unique obfuscated packages & \num{549113} & 32\% \\ 
            \hline
        \end{tabular}
    \end{adjustbox}
    \label{table:num_packages_2021_2022}
\end{table}

Table~\ref{table:num_of_fields_2021_2022} presents the number of fields in package names extracted from our 2021--2022 dataset collected from \az.
We only considered the package names that are not obfuscated, i.e., \num{1162714} package names.
The data shows that the majority of package names have 7 fields or fewer, with the most common number of fields being 4, 5, or 6.

\begin{table}
    \centering
    \caption{Number of fields in package names in apps from 2021 to 2022}
    \begin{adjustbox}{width=1\columnwidth,center}
        \begin{tabular}{lr|lr|lr|lr}
            \hline
            \# Fields & Count & \# Fields & Count & \# Fields & Count & \# Fields & Count \\ \hline
            \num{1} & \num{73487} & \num{5} & \num{285453} & \num{9} & \num{23984} & \num{13} & \num{209} \\ 
            \num{2} & \num{31668} & \num{6} & \num{238861} & \num{10} & \num{7273} & \num{14} & \num{49} \\ 
            \num{3} & \num{82419} & \num{7} & \num{137906} & \num{11} & \num{2455} & \num{15} & \num{34} \\ 
            \num{4} & \num{214377} & \num{8} & \num{63783} & \num{12} & \num{750} & \num{16} & \num{5} \\ 
            \hline
        \end{tabular}
    \end{adjustbox}
    \label{table:num_of_fields_2021_2022}
\end{table}





\subsubsection{To what extent can \dataset discard libraries to speed up Android apps' static analysis?}
To evaluate the effectiveness of \dataset in filtering third-party libraries, we counted the number of unique package names that could be filtered in the 2021--2022 dataset (by considering only the non-obfuscated package names) using our dataset.
\dataset was able to filter out \libraryzoouniq (32.7\%) unique package names out of the \num{1162714} unique package names and a total \libraryzoototal (47.6\%) among a total of \num{16234193888} in the 2021--2022 dataset.
To further evaluate the usefulness of our dataset, we also applied the same analysis with the \textbf{comparison\_dataset} to see if we could filter more libraries.
The \textbf{comparison\_dataset} was able to filter out \liliuniq (14.4\%) unique package names out of the \num{1162714} unique package names and a total \lilitotal (23\%) among a total of \num{16234193888}.
Results indicate that \dataset can filter significantly more third-party libraries (by construction \dataset only contains library package names) than the \textbf{comparison\_dataset} (by construction \textbf{comparison\_dataset} can contain non-library package names).
This indicates that our dataset is more comprehensive and effective in filtering unnecessary libraries for static analysis, leading to improved performance and efficiency.


To further evaluate the \dataset's effectiveness in filtering third-party libraries, we conducted additional experiments using the 2021--2022 dataset.
We extracted the number of statements in the apps and categorized them as being from libraries in \dataset or the \textbf{comparison\_dataset} (note that when we refer to a "statement," we are referring specifically to a Jimple statement~\cite{vallee1998jimple} since our experimental tool, available in the project's repository, is based on the Soot framework).
We conducted this experiment in two ways: considering only the statements reachable from the call graph entry point (for that purpose, we relied on the SPARK~\cite{10.5555/1765931.1765948} call graph construction algorithm) and considering all statements regardless of their reachability.
We have set a 5 min timeout for each app since call graph construction can be time-consuming.
This allowed us to calculate the proportion of statements each list could discard.

The results, shown in Figure~\ref{fig:distrib_all}, confirm the previous findings that our dataset can discard a larger number of statements than the \textbf{comparison\_dataset}.
Specifically, the mean and median values for discarded statements using \dataset are \num{285153} and \num{204449}, respectively, while the corresponding values for the \textbf{comparison\_dataset} are \num{110553} and \num{29778}.
We have performed a Mann-Whitney-Wilcoxon test~\cite{10.1214/aoms/1177730491} to compute the significance of the difference between the distributions.
With a p-value $<= 0.05$, the distributions are confirmed to be significantly different.

Figure~\ref{fig:distrib_reachable} focuses on methods reachable from the call graph entry point to better reflect the actual number of statements discarded during an analysis while excluding dead code.
The results show that \dataset discards more statements than the \textbf{comparison\_dataset}, with a mean and median of 9698 and 454 for statements, respectively for \dataset, compared to a mean and median of 2404 and 0 for statements respectively for the \textbf{comparison\_dataset}.
Again, we performed a Mann-Whitney-Wilcoxon test.
With a p-value $<= 0.05$, the distributions are confirmed to be significantly different.


% Figure environment removed

% Figure environment removed



\highlight{
\textbf{RQ3 answer:}
Our experiments show that \dataset filters a higher proportion of libraries than the state-of-the-art list, \textbf{comparison\_dataset}. 
This is confirmed when considering both the number of unique libraries and the total number of libraries in the 2021--2022 dataset.
We also demonstrate that \dataset filters a higher number of statements in apps, both when considering all methods and statements reachable or not from the call graph entry point.
}

\subsubsection{Effectiveness of discarding all package names except for the app's package name}

In this study, we demonstrated that white lists of third-party libraries are needed for discarding third-party libraries to help Android apps' static analysis. 
However, a simpler approach may exist: discarding all package names in an Android app except for the app's package name declared in the \texttt{AndroidManifest.xml} file. 
To verify this hypothesis, we considered all package names from the 2021--2022 dataset, removed all packages found by \dataset, and only retained the rest.
The remaining package names were then examined to determine if they were solely libraries or if there were other packages present.
If the remaining packages are only libraries, our dataset is not comprehensive enough, and retaining only the package names of the app is a better approach.
On the other hand, if there are packages that are not libraries, it means that there are other packages in apps that are not related to libraries and should be considered during static analysis.
This is important since developers may use different package names within their apps, such as for different departments/apps within a company or from frameworks (e.g., Xamarin~\cite{xamarin}, Flutter~\cite{flutter}, Ionic~\cite{ionic}) to build apps with their package names that are used to implement developer code.

Our manual analysis of the top 20 most used remaining package names revealed that 8 of them were libraries, from position 13 to 20. 
Further investigation revealed that these 8 packages represent only 3 libraries: okhttp3, okio, and com.bumptech.
Indeed, different variations of each of these libraries were found (e.g., okhttp3.internal.http2, and okhttp3.internal.connection).
The three libraries are not found in our dataset (i.e., no package name in \dataset is a prefix of these three libraries). 
However, for both the okhttp3 and okio libraries, the explanation is the following:
To import these libraries using the \texttt{build.gradle} file in an Android app's project, a developer would, for instance, need to use the following strings: "com.squareup.okio:okio:3.3.0" and "com.squareup.okhttp3:okhttps:3.4.1".
Our dataset contains the library com.squareup (since a step of our methodology involves parsing Gradle files), which would have filtered out com.squareup.okio and com.squareup.okhttp3. 
However, once these libraries are imported into apps, the package names of their classes do not follow the naming convention of the imported library.
For instance, in apps using these libraries, classes of these libraries would start with these package names: "okio.MyClass" or "okhttp3.internal.http2.MyClass".
Since \dataset does not contain "okio" or "okhttp3" package names, it cannot consider these classes as libraries.