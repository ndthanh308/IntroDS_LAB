\section{Introduction}
\label{sec:introduction}

According to a recent study, more than 6.5 billion people own a smartphone~\cite{bankmycell} for a variety of personal uses, such as online banking, health monitoring, shopping, social networking, and gaming. Among these users, the majority (72\%)~\cite{market_share} use Android as their mobile operating system, making it the most widely used mobile platform.
Given the widespread use of the Android operating system, the sensitive data stored on mobile devices, and the sensitive operations that mobile devices can perform, Android security and privacy have become a critical concern for practitioners, politicians, and researchers alike. 
In recent years, analysts have identified numerous severe threats to Android security, even in official app markets like the Google Play Store, making it easy for malicious apps to reach millions of users.
These threats can have serious consequences for individuals and organizations, it is essential to develop effective ways to protect against them.

In response to these threats, the research community has developed a wide range of approaches to combat security and privacy threats in Android apps. 
These approaches include static analysis techniques that analyze app code without executing it~\cite{10.1109/NTMS.2016.7792435,doi:10.1155/2015/479174,10.1145/3510003.3512766}, dynamic analysis techniques that execute apps in a controlled environment to observe their behavior~\cite{van2013dynamic,10.1145/2592791.2592796}, and machine learning techniques that use data-driven models to detect and classify malicious behavior~\cite{10.1109/EISIC.2012.34,10.1109/ICTAI.2013.53,10.1007/978-3-030-87839-9_4}.

One popular technique used in the literature to analyze Android apps is static analysis, which involves analyzing app code without executing it. 
This approach has been widely used to uncover security and privacy issues~\cite{10.1016/j.infsof.2017.04.001}. 
For example, researchers have applied static analysis techniques to detect privacy leaks~\cite{10.1145/2666356.2594299,10.5555/2818754.2818791,10.1109/ICSE43902.2021.00126,10.1145/3510003.3512766,10.1145/2660267.2660357} and detect malicious code~\cite{10.1109/SP.2016.30,10.1145/3510003.3510135,10.1007/978-0-387-68768-1_4}. 
Static analysis can provide valuable insights for the security and privacy of Android apps.
However, most of these approaches need to differentiate between developer and library code to focus on the app's functionality, which is the relevant code for finding security problems and avoiding scalability issues (due to the widespread use of polymorphism in libraries and the over-approximation of static analyzers).
This is the same reason why static analyzers do not dive into the Android framework code during analyses (e.g., FlowDroid discards classes that are within the Android framework, cf. lines 64--69 in FlowDroid's SystemClassHandler class~\cite{flowdroidSystemClassHandler}).
Differentiating between developer and library code is therefore a crucial step for static analysis to be effective~\cite{9286020,9542854}, as it allows analyzers to focus on the parts of the app that are most likely to contain security issues and reduce the amount of code needed to be analyzed.

Furthermore, for malware detection, libraries can introduce noise, potentially affecting the detection process.
For example, Mudflow~\cite{10.5555/2818754.2818808} and DroidAPIMiner~\cite{10.1007/978-3-319-04283-1_6} show that discarding libraries in their analysis improves their malware detection performance.
A reliable list of libraries is thus an important artifact for the research community. 

Previous studies have employed white lists containing the package names of libraries to identify third-party libraries in Android apps.
Chen et al.~\cite{10.1145/2568225.2568286} manually compiled a list of 73 package names from commonly used libraries. 
Similarly, Grace et al.~\cite{10.1145/2185448.2185464} randomly selected applications from a dataset of \num{100000} applications that were manually screened to identify the libraries utilized in these applications.
With this approach, they created a white list of 100 libraries. 
However, it should be noted that these lists are ad-hoc and incomplete, %have limited coverage of libraries, 
as they only contain 73 and 100 libraries, respectively.
Another method to build a white list of library package names has been proposed by Li Li et al.~\cite{10.1109/SANER.2016.52}.
Their approach involves using a large dataset of Android apps to identify candidate libraries. 
The process includes ranking all packages by frequency of appearance in apps and using heuristics to retain libraries, such as a package name that should appear at least in ten apps to be considered a candidate, and performing a pairwise comparison of candidate library code within apps.
However, though the approach is still considered as the \emph{state-of-the-art} white list of libraries in the literature~\cite{9713838},
the list provided is outdated, 
the method used to create the list relies on arbitrary heuristics, 
and the hypothesis to consider a package name as a library according to its occurrence can lead to a high rate of false positives (e.g., if numerous versions of the same app are present to compute the list).
Hence, creating a comprehensive white list of libraries to accurately discriminate between the library and developer code remains an open challenge.

In this work, we propose a novel approach to build the first extensive and precise white list of third-party libraries that tends to be comprehensive by mining software dependencies.
Contrary to the research literature, which often uses complex approaches~\cite{10.1145/3324884.3416582},
our method involves mining information from developer habits, i.e., from both commonly used library repositories and project's configuration files used by developers.
Our hypothesis is that 
\dcircle{1} the majority of developers rely on Android Studio and Gradle to build apps;
\dcircle{2} Gradle in turn relies on Maven and Google to retrieve libraries~\cite{gradle_google,gradle_maven}; and
\dcircle{3} open-source Android apps can bring valuable information about the library used in apps (e.g., availability of configuration files).
Therefore, we propose to the research and practitioner communities a dataset called \dataset, which contains \libsAfterRefinement libraries built after mining well-known library repositories and open-source Android apps.
\dataset is thus accurate by construction, i.e., it only contains library package names.
This dataset is meant to evolve and regularly incorporate new libraries added by third-party vendors.
\dataset aims to facilitate the work of static analysis analysts and support more accurate analyses.
We believe this dataset will be a valuable resource for static analysis, and we encourage its use and expansion as new libraries become available.

Overall, this paper makes the following contributions:
\begin{itemize}
    \item We present evidence to demonstrate the ongoing need for white lists of libraries in Android static analysis.
    \item We propose a novel approach to produce an accurate set of third-party libraries for Android static analysis. Fully automated, the approach allows for easily and regularly yielding an up-to-date white list of library package names.
    \item We build \dataset, the first version of the library dataset produced by our approach.
    \item We compare \dataset with the current state-of-the-art list of libraries and LibRadar.
    \item We demonstrate the importance of \dataset for Android static analysis.
    \item We show that existing static analyzers benefit from \dataset.
\end{itemize}

We release \dataset, and our artifacts at:
\url{https://anonymous.4open.science/r/AndroLibZoo-591D/}