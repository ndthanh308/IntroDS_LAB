% !TEX root = main.tex


\section{Saturating automata ($\sata$)}\label{sec:sata}


The automata to be introduced will accept 
the so-called data languages, i.e.
languages over an alphabet of the form $\Sigma\times\D$, where
$\Sigma$ is a finite alphabet
and $\D$ is a infinite alphabet of data values.
In our case, the dataset $\D$ will have the structure of a countably infinite forest.
This structure will be helpful when representing game semantics. In particular, it will be used to encode justification pointers and enforce the WAIT condition.
\begin{definition}
$\D$ is a countably infinite set equipped with a function $\predc:\D\rarr\D\cup\{\bot\}$ (the \emph{parent} function) such that the following conditions hold.
\begin{itemize}
\item Infinite branching: $\predc^{-1}(\{d_\bot\})$ is infinite for any $d_\bot\in\D\cup\{\bot\}$.
\item Well-foundedness: for any $d\in\D$, there exists $i\in\N$, called the \emph{level of $d$}, such that $\predc^{i+1}(d)=\bot$.
Level-$0$ data values are called \emph{roots}.
\end{itemize}
We say that $T\subseteq \D$ is a subtree of $\D$ if and only if $T$ is closed ($\forall x \in T \colon \pred{x}\in T\cup\{\bot\}$) and rooted ($\exists!x\in T\colon\pred{x}=\bot$).
\end{definition}
\begin{example}\label{ex:s2word}
Suppose $\Sigma$ consists of moves used in Figure~\ref{fig:gs2a},
$\pred{d_0}=\bot$, $\pred{d_1}=\pred{d_1'}=d_0$ and $\pred{d_2}=d_1$. The play $s_2$ (Figure~\ref{fig:gs2c}) can be represented by the following 
word over $\Sigma\times\D$: 
$(\mq,d_0)
(\mrun^f,d_1)
(\mrun^{f1}, d_2)
(\mdone^{f1},d_2)
(\mrun^c,d_1')
(\mdone^c,d_1')
(\mdone^f,d_1)
(1,d_0)$. Note that the predecessor relation is used to represent justification pointers. Full details of the representation scheme will be given in Section~\ref{sec:fica2sata}.
\end{example}%\amnote{I don't want to say labelled here, because for many people label = transition label. I started using the word "annotation" instead. I'm also avoiding $\uplus$, because $+$ was already established in the GS section.} 
We use subtrees of $\D$ to represent configurations.
Their nodes will be annotated  with additional information.
We distinguish between odd and even levels to reflect the distinction between the behaviours of the environment (O) and the program (P).
\begin{itemize}
    \item Each even-level node will be annotated
    with a multiset of control states, and zero or more memory cells.
    This information will be allowed to evolve during runs.
    Intuitively, it represents the multiset of states of a group of processes.
    \item Nodes at odd levels will be labelled with single control states, which will not change.
\end{itemize}
% In a single transition, the automaton will be able to add or remove leaves from its configuration, using very limited information:
% so far as access to control states is concerned,
% at most the parent level will be available. \adnote{Idea of ``parent level" is ambiguous on first reading. Parent to the added node, or parent to the node which is gaining a child?}
In a single transition, the automaton will be able to add or remove leaves 
from its configuration using very limited information. 
When adding a leaf as a child of node $n$, only the state at $n$ will be available. When removing a leaf, in addition to the state at the leaf,
only the parent state will be accessed, if at all.
The automaton will also feature $\epsilon$-transitions, which do not modify the shape of the configuration, 
but can be used to update annotations at even levels, 
while possibly accessing memory cells
at ancestor nodes.

The automata will be parameterized by $k$ and $N$.
The parameter $k$ is the maximal depth of the data used by the automaton, 
while $N$ is the maximal number of memory cells at any node. 
A memory cell will store an element from $V=\{0,\ldots,\imax\}$.
The set of control states will be partitioned into sets
$\CS{i}$, for $0\le i\le k$, dedicated to representing run-time information
at the corresponding level $i$.
%Thus, even-level data will be annotated with elements 
%of $\mul{\CS{2i}}\times V^N$, where $\mul{X}$ stands for the set of multisets over $X$.
%Odd-level data will be labelled with elements of $\CS{2i-1}$.
\begin{definition}
A \emph{saturating automaton} ($\sata$) is a tuple $\Aut=\abra{\Sigma,k,N,C,\delta}$, where:
\begin{itemize}
\item $\Sigma=\Sigma_{OQ}+\Sigma_{PQ} + \Sigma_{OA} +\Sigma_{PA}$ is a finite alphabet, partitioned into O/P-questions and O/P-answers (we use $q_O,q_P,a_O,a_P$ respectively to range over the elements of the four components);
\item $k\geq 0$ is the depth parameter and $N\ge 0$ is the local memory capacity;
\item $C = \Sigma_{i=0}^k \CS{i}$ is a finite set of \emph{control states}, partitioned into sets $\cn{i}$ of level-$i$ control states;
\item transitions in $\delta$ are partitioned according to their type ($\add$, $\del$ or $\eps$) and level on which they operate;
their shapes are listed below, where $\cs{i},\ds{i},\es{i}\in \CS{i}$
and $\DS{2i},\ES{2i}\in\mul{\CS{2i}}$, where $\mul{X}$ denotes the set of multisets over $X$.
    \begin{itemize}
    \item $\add(2i)$ transitions have the form $\cs{2i-1}\trans{q_O} \DS{2i}$
    or $\dagger\trans{q_O} \DS{0}$ for the special case of $i=0$;
    \item $\add(2i+1)$ transitions have the form $\cs{2i}\trans{q_P} \ds{2i+1}$;
    \item $\del(2i)$ transitions have the form $\DS{2i}\trans{a_P} \dagger$;
    \item $\del(2i+1)$ transitions have the form $\cs{2i+1}\trans{a_O}\ds{2i}$;
    \item $\eps(2i)$ transitions have the form $\DS{2i}\trans{\epsilon}\ES{2i}$;
    \item $\eps(2j,2i)$ transitions read $v \in V$ from memory cell $h \in \{1, \ldots, N\}$ at level $2j \leq 2i$ and update it to $v' \in V$, but do not read the input:
    $(\mop{2j}{h}{v},\cs{2i})\trans{\epsilon}(v',\ds{2i})$. 
    \end{itemize}
\end{itemize}
\end{definition}
% \begin{remark}
% The $\add(2i)$ transitions (O-questions) could be viewed as spawning a finite number of jobs (hence the use of $\DS{2i}\in\mul{\CS{2i}}$ instead of just a single state).
% The dual $\del(2i)$ transition can then be used to detect
% the moment when all of the jobs have reached their 
% ``terminal conditions'', in order to play  a corresponding answer.
% Each job created via $\add(2i)$ can evolve
% separately via $\add(2i+1)$ or $\eps(2j,2i)$ (internal state change
% plus memory operation) or as part of a group via $\eps(2i)$.
% \end{remark}
\begin{remark}
Observe that O and P can ``act'' only at odd and even levels respectively.
The $\add(2i)$ transitions map exactly onto O-questions from the game semantics. We may view them as spawning a finite number of jobs (hence the use of multisets to represent those jobs' states). Dually, the $\del(2i)$ transition maps onto P-answers which answer those O-questions; correspondingly with WAIT, the $\del(2i)$ transition is only firable when all jobs have reached their ``terminal conditions''. Each job created via $\add(2i)$ can evolve
separately via $\add(2i+1)$ or $\del(2i+1)$, by $\eps(2j,2i)$ (internal state change plus memory operation), or as part of a group via $\eps(2i)$.
\end{remark}
\begin{definition}
A $\sata$ \emph{configuration} is a tuple $(D,E,f,m)$, 
where $D$ is a finite subset of $\D$ (consisting of data values that have been encountered so far),
$E$ is a finite subtree of $\D$ (the shape of the configuration), 
$f:E\rarr \sum\limits_{0<2i-1 \leq k} \CS{2i-1}+ \sum\limits_{0\leq 2i\leq k}\mul{\CS{2i}}$ is  such that
\begin{itemize}
\item if $d$ is a level-$2i$ data value then $f(d)\in \mul{\CS{2i}}$, 
\item if $d$ is a level-$(2i-1)$ data value then $f(d)\in \CS{2i-1}$, 
\end{itemize}
and $m:E\pmor V^N$ is a partial function whose domain is the set of  even-level nodes of $E$.
\end{definition}
A $\sata$ $\Aut$  starts from the empty configuration 
$\kappa_0=(\emptyset,\emptyset,\emptyset,\emptyset)$ 
and proceeds according to its transitions $\delta$, as detailed below.
We write $\kappa=(D,E,f,m)$ and $\kappa'=(D',E',f',m')$
for the current and the successor configurations respectively.

\paragraph*{\rm ADD} We shall have $\kappa\trans{(t,d)} \kappa'$ provided
$t\in\Sigma_{OQ}+\Sigma_{PQ}$, $d\not\in D$, $\pred{d}\in E$,
$D'=D\cup\{d\}$, $E'=E\cup\{d\}$,
and if the transition-specific constraints from the table below
are satisfied\footnote{Given a multiset $(X,\mu:X\rarr\N)$,
we write $x\in_m (X,\mu)$ to mean $\mu(x)>0$. Given
two multisets $(X,\mu_i)$ ($i=1,2$),
we write
$(X,\mu_1)\setminus_m (X,\mu_2)$,
 $(X,\mu_1)\cup_m (X,\mu_2)$ to stand for
$(X,\mu^-)$ and $(X,\mu^+)$ respectively, where
$\mu^-(x)=\max(\mu_1(x)-\mu_2(x),0)$ and
$\mu^+(x)=\mu_1(x)+\mu_2(x)$.
Similarly, $(X,\mu_1)\subseteq (X,\mu_2)$ denotes $\mu_1(x)\le \mu_2(x)$
for all $x\in X$.
}. We write $f[\cdots]$ to extend or update $f$.
\[\begin{array}{c|c|c|c|c}
t&\textrm{transition} & \textrm{pre-condition}  & f' & m'\\
\hline
q_O&\dagger\trans{q_O} \DS{0} & D=\emptyset &\{d\mapsto \DS{0}\} & \{d\mapsto 0^N\}\\
q_O&\cs{2i-1}\trans{q_O}\DS{2i} & f(\pred{d})=\cs{2i-1} &   f [d\mapsto\DS{2i}] & m[d\mapsto 0^N]\\
q_P&\cs{2i}\trans{q_P}\ds{2i+1} & \cs{2i}\in_m f(\pred{d}) &
f \left[\begin{array}{c}\pred{d}\mapsto f(\pred{d})\setminus_m \{\cs{2i}\}\\d\mapsto \ds{2i+1}\end{array}\right] & m\\
\end{array}\]
Note that, in the first two cases, 
memory is initialised at the new node.
In the last case, $\cs{2i}$ is removed from $f(\pred{d})$,
i.e. if a job starts evolving via $\add(2i+1)$, 
it is removed from the list of current jobs.


\paragraph{\rm DEL}
We shall have $\kappa\trans{(t,d)} \kappa'$
provided $t\in\Sigma_{OA}+\Sigma_{PA}$,
$d$ is a leaf in $E$, $D'=D$, $E'=E\setminus\{d\}$, $m'=m$,
and the transition-specific constraints listed below are satisfied.
\[\begin{array}{c|c|c|c}
t&\textrm{transition} & \textrm{pre-condition}  & f' \\
\hline
a_O & \cs{2i+1}\trans{a_O} \ds{2i} & f(d)=\cs{2i+1} &
f [\pred{d}\mapsto f(\pred{d})\cup_m\{\ds{2i}\}]\\
a_P & \DS{2i}\trans{a_P}\dagger & f(d)=\DS{2i} & f\\
\end{array}\]
Note that, in the first case, the leaf will contribute a new state
to the parent node. For simplicity, we do not ``garbage-collect'' $f'$,
since the leaf removal is already recorded via $E'$.


\paragraph{\rm EPS}
We shall have $\kappa\trans{\varepsilon}\kappa'$
provided $D'=D$, $E'=E$ and there exists an even-level datum $d$
satisfying the transition-specific constraints discussed below.
\begin{itemize}
\item For $\DS{2i}\trans{\epsilon}\ES{2i}$,
we require $\DS{2i}\subseteq_m f(d)$,
$f'=f[d\mapsto (f(d)\setminus_m \DS{2i})\cup_m\ES{2i}]$ and $m'=m$.

\item For $(\mop{2j}{h}{v},\cs{2i})\trans{\e}(v',\ds{2i})$,
we require $\cs{2i}\in_m f(d)$ and $m(\mathit{pred}^{2i-2j}(d))(h)=v$,
$f'=f[d\mapsto (f(d)\setminus_m \{\cs{2i}\})\cup_m\{\ds{2i}\}]$
and $m'=m [\mathit{pred}^{2i-2j}(d)(h) \mapsto v' ]$.
\end{itemize}
Note that, in the second case, $m(\mathit{pred}^{2i-2j}(d))(h)$ refers
to the $h$th memory cell of $d$'s ancestor at level $2j$ and only the
content of this cell may be modified by the transition.
\begin{definition}
A \emph{trace} of a $\sata$ $\Aut$ is a word $w \in (\Sigma\times\D)^\ast$ 
such that $\kappa_0\trans{l_1}\kappa_1\dots\kappa_{h-1}\trans{l_{h}}\kappa_{h}$, 
where $\kappa_0=(\emptyset,\emptyset,\emptyset,\emptyset)$,
$l_i\in \{\epsilon\}\cup(\Sigma\times\D)$ ($1\le i\le h$) and
$w=l_1\cdots l_h$. A configuration $\kappa=(D,E,f,m)$  
is \emph{accepting} if $E$ is empty.
A trace $w$ is accepted by $\Aut$ if there is a non-empty sequence of transitions as above with $\kappa_h$  accepting.  
The set of traces (resp. accepted traces) of $\Aut$ is denoted
by $\trace{\Aut}$ (resp. $\lang{\Aut}$).
\end{definition}
It follows that each data value can occur in a trace at most twice. The first occurrence (if any)
must be related to a question, whereas the second one will necessarily be an answer.
The fact that answers can be read only if the corresponding node becomes a leaf 
is analogous to the game-semantic WAIT condition.
Note that $E$ is empty in accepting configurations.
This means that in every word that is accepted,
each question $q_O/q_P$ (corresponding to leaf creation) 
will have a corresponding answer $a_P/a_O$ (corresponding to leaf removal),
and they will be paired up with the same data value. 
Such words resemble complete plays (Theorem~\ref{thm:full})
under the convention that a justification pointer from an answer to a question is represented by using the data value introduced by the question.
Indeed, we will rely on this  when representing plays 
in Section~\ref{sec:fica2sata}.
\begin{example}\label{ex:aut}
{
\newcommand{\ex}[1]{\ensuremath{#1_{\mathsf{ex}}}}
\newcommand{\sset}[1]{\{#1\}}
The $\sata$ $\Aut=\abra{\Sigma, 2, 1, C, \delta}$ specified below recognises complete plays generated by the $\fica$ term from Example~\ref{ex:term} according to the interpretation from \cite{GM08}. 
It is trace- and language-equivalent to the one that would be derived by the translation given in the proof of Theorem~\ref{thm:fica2sata}, though the representation here is made more concise. We use $l$ and $r$ to denote control states corresponding to the left and right subterms of the parallel composition in Example~\ref{ex:term}. The memory value maintained at level 0 corresponds to the value of the variable $x$.



We have
$\Sigma_{OQ} = \{ \mq, \mrun^{f1} \}$, $\Sigma_{PQ}=\{\mrun^f, \mrun^c\}$,
$\Sigma_{OA}=\{ \mdone^f,\mdone^c \}$, $\Sigma_{PA}=\{\mdone^{f1}, 0,\cdots,\imax\}$,
$\CS{0}=\{l_1^{(0)}, l_2^{(0)}, r_1^{(0)}, r_2^{(0)}, r_3^{(0)}, r_4^{(0)} \}$,
$\CS{1} = \{ l_1^{(1)}, r_1^{(1)}\}$, and
$\CS{2} = \{ l_1^{(2)}, l_2^{(2)} \}$.
$\delta$ is given below.

% \renewcommand{\arraystretch}{1.5}
\begin{tabular}{ll}
\textnormal{ ADD(0), DEL(0):}&
$\dagger \trans{\mq} \sset{ l_1^{(0)}, r_1^{(0)} } 
\qquad 
\sset{ l_2^{(0)}, r_4^{(0)} } \trans{1} \dagger
$
\\
\textnormal{ ADD(1), DEL(1):}&
$
l_1^{(0)} \trans{\mrun^{f}} l_1^{(1)}
\qquad
l_1^{(1)} \trans{\mdone^{f}} l_2^{(0)}
\qquad
r_3^{(0)} \trans{\mrun^{c}} r_1^{(1)}
\qquad
r_1^{(1)} \trans{\mdone^{c}} r_4^{(0)}
$
\\
\textnormal{ ADD(2), DEL(2):}&
$
l_1^{(1)} \trans{\mrun^{f1}} \sset{l_1^{(2)}}
\qquad
\sset{l_2^{(2)}} \trans{\mdone^{f1}} \dagger
$
\\
\textnormal{ EPS(0,0):}&
$(0,1,0,r_1^{(0)}) \trans{\varepsilon} (0,r_2^{(0)})\qquad
(0,1,i,r_1^{(0)}) \trans{\varepsilon} (i,r_3^{(0)}) \quad (0 < i\le \imax)$\\
\textnormal{ EPS(0,2):}&
$(0,1,i,l_1^{(2)}) \trans{\varepsilon} (1,l_2^{(2)})\quad (0\le i\le\imax)$
\end{tabular}
}

% \noindent
% In~\cref{apx:sata}, we give a sequence of transitions of $\Aut$
% accepting the word from~\cref{ex:s2word}.

\input{apx-automata}

\end{example}


