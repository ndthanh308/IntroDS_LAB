% !TEX root = main.tex


\section{From $\fica$ to $\sata$}\label{sec:fica2sata}


In this section we provide an inductive translation from $\fica$ to $\sata$. The main result states
that, for terms in normal form, the construction can be carried out in quadratic time and the automata 
have linearly many states and transitions (with respect to term size).

First, we describe how to encode justification pointers in plays using data and a special
indexing scheme. Recall from Section~\ref{sec:gs} that, to interpret base types, game semantics uses moves from the set
\[\begin{array}{rcl}
\moveset &=& M_{\sem{\comt}}\cup M_{\sem{\expt}}\cup M_{\sem{\vart}} \cup M_{\sem{\semt}}\\
&=&\{\, \mrun,\, \mdone,\, \mq,\, \mread,\, \mgrb,\, \mrls,\, \mok\, \} \cup \{\,i,\, \mwrite{i}{}\,|\, 0\le i \le \max\,\}.
\end{array}\]
The game-semantic interpretation of 
a term-in-context $\seq{\Gamma}{M:\theta}$ is a strategy over the arena $\sem{\seq{\Gamma}{\theta}}$,
which  is obtained through product and arrow constructions,  starting from arenas corresponding to base types.
As both constructions rely on the disjoint sum, the moves from $\sem{\seq{\Gamma}{\theta}}$ are derived
from  the base types present in types inside $\Gamma$ and $\theta$.
To indicate the exact occurrence of a base type from which each move originates, we will  annotate elements of $\moveset$ with
a specially crafted scheme of superscripts.
Suppose  $\Gamma=\{x_1:\theta_1,\cdots, x_l:\theta_l\}$.
The superscripts will have one of the two forms,  where $\vec{i}\in\N^\ast$ and $\rho\in\N$:
\begin{itemize}
\item $(\vec{i},\rho)$ will represent moves from $\theta$;
\item $(x_v\vec{i}, \rho)$ will  represent moves from $\theta_v$ ($1\le v\le l$).
\end{itemize}
The annotated moves will be written as $m^{(\vec{i},\rho)}$ or $m^{(x_v\vec{i},\rho)}$, where $m\in\moveset$.
We will sometimes omit $\rho$ on the understanding that this represents $\rho=0$.
Similarly, when $\vec{i}$ is omitted, the intended value is~$\epsilon$, e.g. $m$ stands for $m^{(\epsilon,0)}$
and $m^x$ for $m^{(x,0)}$. The next definition explains how the $\vec{i}$ superscripts are
linked to moves from $\sem{\theta}$.
Given $X\subseteq \{ m^{(\vec{i},\rho)} \,|\, \vec{i}\in\N^\ast,\,\rho\in\N\}$ and $y\in \N\cup \{x_1,\cdots, x_l\}$, 
we let $yX = \{m^{(y\vec{i},\rho)}\,|\, m^{(\vec{i},\rho)}\in X\}$.
\begin{definition}\label{def:tags}
Given a type $\theta$, the corresponding alphabet $\alp{\theta}$ is defined as follows
\[\begin{array}{rcll}
\alp{\beta} &=& \{\, m^{(\epsilon,\rho)}\,|\, m\in M_{\sem{\beta}},\,\rho\in\N\,\}\qquad \beta=\comt,\expt,\vart,\semt\\
\alp{\theta_l\rarr\ldots\rarr\theta_1\rarr\beta} &=& \bigcup_{u=1}^l (u\alp{\theta_u}) \cup \alp{\beta}
\end{array}\]
For $\Gamma=\{x_1:\theta_1,\cdots, x_l:\theta_l\}$,
the alphabet $\alp{\seq{\Gamma}{\theta}}$ is defined to be 
$\alp{\seq{\Gamma}{\theta}}=\bigcup_{v=1}^l (x_v \alp{\theta_v}) \cup \alp{\theta}$.
\end{definition}
\begin{example}
Given $\Gamma=\{f:\comt\rarr\comt, c:\comt\}$, we have
\[\alp{\seq{\Gamma}{\expt}}=
\{ \mrun^{(f1,\rho)}, \mdone^{(f1,\rho)}, \mrun^{(f,\rho)}, \mdone^{(f,\rho)}, \mrun^{(c,\rho)},
\mdone^{(c,\rho)}, \mq^{(\epsilon,\rho)}, i^{(\epsilon,\rho)}\,|\,
0\le i\le\imax,\,\rho\in \N\, \}.
\]
\end{example}
Note that $\alp{\seq{\Gamma}{\theta}}$ admits a natural partitioning into $X$-questions and
$X$-answers ($X\in\{O,P\}$), depending on whether the underlying move is an $X$-question or an $X$-answer.
To represent the game semantics of terms-in-context $\seq{\Gamma}{M:\theta}$,
we will represent plays as words over $\Sigma\times\D$, where $\Sigma$ is a finite subset of $\alp{\seq{\Gamma}{\theta}}$.
Only a finite subset will be needed, because $\rho$ will be bounded.

Next we explain how $\rho$ and data will be used to represent
justification pointers.
%Its role will be to represent justification pointers.
Because no data value can be used twice with a question,
occurrences of questions correspond to unique data values.
A justification pointer from an answer to a question 
can then be represented simply by pairing up the same data value 
with the answer. Pointers from question-moves will be 
represented with the help
of the index $\rho$.
Initial question-moves do not have a pointer and to represent such questions we simply use $\rho=0$.
To represent moves with justification pointers,
we will rely on $\rho$ on the understanding that
$(m^{(y,\rho)},d)$ represents a pointer to the unique 
question-move that introduced $\mathit{pred}^{\rho+1}(d)$.
The reader may wish to check that Example~\ref{ex:s2word} does follow
this convention (therein $m^x$ stands for $m^{(x,0)}$).
Below we give another example involving $\rho>0$, which
may arise in our translation for certain P-moves.
\begin{example}
The play
$\rnode{Z}{\mq}\,\,\,
\rnode{A}{\mrun^f}\justn{A}{Z}{140}\,\,\,
\rnode{B}{\mrun^{f1}}\justn{B}{A}{140} \,\,\,
\rnode{D}{\mrun^{c}}\justn{D}{Z}{140}$
can be represented by
$(\mrun^{(\epsilon,0)},d_0)$ $(\mrun^{(f,0)},d_1)$ $(\mrun^{(f1,0)}, d_2)$ $(\mrun^{(c,2)},d_3)$, given $\pred{d_{i+1}}=d_i$ ($0\le i\le 2$).
\end{example}

Below we state the main result linking $\fica$ with saturating automata.
Question-moves in this translation are handled with ADD transitions:
$\add(2i)$ and $\add(2i+1)$ correspond to O- and P-questions respectively.
Answer-moves are processed with DEL transitions:
$\del(2i)$ for P-answers and $\del(2i+1)$ for O-answers.

\begin{theorem}\label{thm:fica2sata}
For any $\fica$ term $\seq{\Gamma}{M:\theta}$
there exists a $\sata$ $\Aut_M$ 
over a finite subset of $\alp{\seq{\Gamma}{\theta}}$ 
such that the set of plays represented by words from $\trace{\Aut_M}$ 
is $\sem{\seq{\Gamma}{M:\theta}}$, and $\lang{\Aut_M}$ represents $\comp{\sem{\seq{\Gamma}{M:\theta}}}$.
Moreover, when $M$ is in $\beta$-normal $\eta$-long form\footnote{A term is in $\beta$-normal form if none of its subterms is a $\beta$-redex, and it is $\eta$-long if all occurrences of function identifiers inside the term are fully applied. For every term one can obtain a corresponding $\beta$-normal $\eta$-long form by $\beta$-reduction and $\eta$-expansion; these reductions preserve equivalence.}, 
$\Aut_M$ has linearly many states and transitions, 
and can be constructed in quadratic time.
\end{theorem}
\begin{proof}
It follows from analogous results for the simply-typed $\lambda$-calculus that any $\fica$ term can be reduced to an equivalent term in $\beta$-normal $\eta$-long form.  The argument proceeds by induction on the structure of such forms.
When referring to the inductive hypothesis for a subterm $M_i$,
we use the subscript $i$ to refer to the automata components, 
e.g. $\CS{j}_i$,  $\trans{m}_i$ etc.
In contrast, $\CS{j}$, $\trans{m}$ (without subscripts) will refer to the automaton that is being constructed.
Inference lines $\frac{\qquad}{\qquad}$ indicate that the transitions listed under the line should be added
to the new automaton provided the transitions listed above the line are present in the automaton obtained from the inductive hypothesis.

The following three invariants
that strengthen the inductive hypothesis help us establish
correctness and the requisite complexity. They concern labelled
transitions only.
\begin{itemize}
\item $\oa$ (OA determinacy): 
if $\cs{2i+1}\trans{a_O} \ds{2i}_1$ and
$\cs{2i+1}\trans{a_O} \ds{2i}_2$ then $\ds{2i}_1=\ds{2i}_2$.
\item $\pq$ (PQ pre-determinacy):
if $\cs{2i}_1\trans{q_P}\ds{2i+1}$ and $\cs{2i}_2\trans{q_P}\ds{2i+1}$
then $\cs{2i}_1=\cs{2i}_2$.
\item $\fa$ (final readiness): for every $\DS{0}\trans{a_P}\dagger$,
i.e. where $a_P$ is a \emph{final answer},
whenever the automaton reaches a configuration $(D,E,f,m)$ 
with $\DS{0}\subseteq f(r)$, where $r$ is the root, then the transition can be executed, i.e. $r$ has no children and $f(r)=\DS{0}$.
\end{itemize}
Below we discuss a selection of  cases.
In the first three cases, the corresponding automaton merely needs
to respond to the initial question with a suitable answer or not respond at all
(for $\divcom_\theta$).


\paragraph{$\mathbf{M\equiv\skipcom}$:} $k=0$, $N=0$, $\cn{0}=\{0\}$,
$\delta$ consists of $\dagger\trans{\mrun} \{0\}$ and $\{0\}\trans{\mdone} \dagger$.

\paragraph{$\mathbf{M\equiv i}$:} $k=0$, $N=0$, $\cn{0}=\{0\}$, $\delta$ consists of
$\dagger\trans{\mq} \{0\}$ and $\{0\}\trans{i} \dagger$.

\paragraph{$\mathbf{M\equiv \divcom_\theta}$:} $k=0$, $N=0$, $\cn{0}=\{0\}$.
Supposing $\theta\equiv \theta_l\rarr\cdots\rarr\theta_1\rarr\beta$, 
recall that $I_{\sem{\beta}}$ stands for the set of initial questions in $\sem{\beta}$.
$\delta$ is then given by
\[
\frac{x\in I_{\sem{\beta}}}{
\dagger\trans{x} \{0\} 
}\]
$\pq$ and $\oa$ hold vacuously in the above cases, as they do not feature the relevant transitions.
$\fa$ is also clearly satisfied.


\paragraph{$\mathbf{M\equiv \arop{M_1}}$:}
$k=k_1$, $N=N_1$, $\CS{j}=\CS{j}_1$ ($0\le j\le k$).
In this case, we only need to adjust the final answers,
i.e. we take all transitions for $\Aut_{M_1}$ except $\del(0)$,
and modify the $\del(0)$ transitions as follows.
\[
\frac{\DS{0} \trans{i}_1 \dagger}{ \DS{0}\trans{\widehat{\mathbf{op}}(i)} \dagger}
\]
The above relabelling does not concern transitions relevant 
to $\oa$ and $\pq$, so the properties are simply inherited
from $\Aut_{M_1}$.
$\fa$ holds by appeal to IH.


% referring the reader to Appendix~\ref{apx:fica2sata} for other details.
\paragraph{$\mathbf{M \equiv M_1 || M_2}$:}  
In order to match $\sem{\seq{\Gamma}{M_1 || M_2}}$, this construction needs to interleave $\Aut_{M_1}$ and $\Aut_{M_2}$ while gluing the initial and final moves.
Accordingly, we take $k=\max(k_1,k_2)$, $N=N_1+N_2$, 
$\CS{0}= \CS{0}_1 +\CS{0}_2 + \{\circ_1, \circ_2,\bullet_1,\bullet_2\}$,
$\CS{i}= \CS{i}_1 +\CS{i}_2$ 
($0 < i\le k$, assuming $\CS{i}_u=\emptyset$ for $i>k_u$).
All transitions from $\Aut_{M_1}$ and $\Aut_{M_2}$ other than $\add(0)$, $\del(0)$, $\eps(0,2i)$
are simply embedded into the new automaton.
$\add(0)$ and $\del(0)$ need to be synchronised,
as shown below.
\[
\frac{}{\dagger\trans{\mrun}\{\circ_1,\circ_2\}}
\qquad
\frac{\dagger\trans{\mrun}_u \DS{0}_u\quad u\in\{1,2\}}{\{\circ_u\}\trans{\epsilon}\DS{0}_u}
\qquad
\frac{\DS{0}_u\trans{\mdone}_u \dagger\quad u=1,2}{
\DS{0}_u\trans{\epsilon} \{\bullet_u\}}\qquad
\frac{}{\{\bullet_1,\bullet_2\}\trans{\mdone} \dagger}
\]
$N=N_1+N_2$ reflects the need to combine local memories of the two
automata. This need arises only at level $0$, as memory at other
levels will be disjoint. Consequently, we need to adjust memory
indices for $\eps(0,2i)$ transitions from $\Aut_{M_2}$ only:
\[
\frac{(\mop{0}{h}{v}, \cs{2i})\trans{\epsilon}_1 (v',\ds{2i})}{
(\mop{0}{h}{v}, \cs{2i})\trans{\epsilon} (v',\ds{2i})
}\qquad\qquad
\frac{(\mop{0}{h}{v}, \cs{2i})\trans{\epsilon}_2 (v',\ds{2i})}{
(\mop{0}{N_1+h}{v}, \cs{2i})\trans{\epsilon} (v',\ds{2i})
}.
\]
It follows from IH and the construction that $\fa$ will be preserved for $\mdone$.
$\oa$ and $\pq$ are preserved too, because the construction does not
affect the relevant transitions.


\paragraph{$\mathbf{M\equiv M_1;M_2:\comt}$:}

Here we need to let $\Aut_{M_1}$ run to completion
and then direct the computation to $\Aut_{M_2}$.
We take $k=\max(k_1, k_2)$, $N=N_1+N_2$, 
$\CS{0}= \CS{0}_1 + \CS{0}_2 + \{ \circ \}$,
$\CS{i}= \CS{i}_1 + \CS{i}_2$ ($0 < i\le k$).

We modify the $\add(0)$ and $\del(0)$ transitions as follows.
\[
\frac{\dagger\trans{\mrun}_1 \DS{0}}{
\dagger\trans{\mrun}\DS{0}}
\qquad
\frac{
\DS{0}_1 \trans{\mdone}_1 \dagger}{
\DS{0}_1\trans{\epsilon} \{\circ\}}
\qquad 
\frac{\dagger \trans{\mrun}_2 \DS{0}_2}{
\{\circ\} \trans{\epsilon} \DS{0}_2}
\qquad
\frac{\DS{0}_2 \trans{\mdone}_2 \dagger}{
\DS{0}_2 \trans{\mdone} \dagger}
\]
The remaining transitions are simply copies of
other transitions 
from $\Aut_{M_1}$, $\Aut_{M_2}$,
with the proviso that in $\eps(0,2j)$ transitions 
from $\Aut_{M_2}$ we add $N_1$ to the index of the memory cell
that is accessed.

For correctness, we need to appeal to $\fa$ for $M_1$, which
tells us that reaching a configuration in which 
the root is labelled with $\DS{0}_1$ amounts to the termination of $M_1$.
As before, the construction does not modify transitions
relevant to $\oa$, $\pq$, so the properties are simply inherited
from $M_1$ and $M_2$. $\fa$ follows from IH.



\paragraph{$\mathbf{M\equiv f(M_1)}$:}

This case is interesting, because this is where labelled transitions
are created rather than inherited.
According to~\cite{GM08}, the automaton should start with $\mrun\,\mrun^{f}$ and end with $\mdone^f\,\mdone$.
In the meantime, after the first two moves, it should allow for an arbitrary number of $\mrun^{f1}$s, each of which should trigger a separate copy of $\Aut_{M_1}$, which will terminate with $\mdone^{f1}$.
$\mdone^f$ should be read only when all of the copies are finished.

We discuss the simplest instance $f:\comt\rarr\comt$. 
We take $k=2+ k_1$, $N= N_1$,
$\CS{0}= \{0_\mrun,0_\mdone\}$, 
$\CS{1}=\{1_{\mrun}\}$, $\CS{j+2} = \CS{j}_1$ ($0\le j\le k_1$).
First we add transitions corresponding to calling and returning 
from $f$:
\[
\dagger \trans{\mrun^{(\epsilon,0)}} \{0_\mrun\}\qquad
0_{\mrun}\trans{\mrun^{(f,0)}} 1_{\mrun}\qquad
1_{\mrun} \trans{\mdone^{(f,0)}} 0_{\mdone}\qquad
\{0_\mdone\}\trans{\mdone^{(\epsilon,0)}} \dagger.
\]
In state $1_{\mrun}$ we want to allow the environment to spawn an unbounded number of copies of the strategy for  $\seq{\Gamma}{M_1:\comt}$:
\[
\frac{\dagger\trans{\mrun^{(\epsilon,0)}}_1 \DS{0}_1}{ 1_\mrun  \trans{\mrun^{(f 1, 0)}} \DS{0}_1}\qquad
\frac{\DS{0}_1\trans{\mdone^{(\epsilon,0)}}_1 \dagger}{ 
\DS{0}_1\trans{\mdone^{(f 1, 0)}} \dagger}.
\]
Note that the copies will run
two levels lower than in $\Aut_{M_1}$.

The remaining moves
related to $M_1$ originate from $\Gamma$, i.e.
are of the form
$m^{(x_v\vec{i},\rho)}$, where $(x_v : \theta_v)\in\Gamma$.
The associated transitions need to be embedded into 
the new automaton,
but P-question-moves of the form $m^{(x_v,\rho)}$ (corresponding
to initial moves of $\sem{\theta_v}$) 
need to have their pointer adjusted so that they point
at the move tagged with $\mrun^{(\epsilon,0)}$ (leaving $\rho$ unchanged in this case would mean pointing at $\mrun^{(f 1,0)}$).
To achieve this, it suffices to add $2$ to $\rho$ in this case. Otherwise $\rho$ can remain unchanged, because the pointer structure
is preserved. Below we use $\square_L,\square_R$ to refer to arbitrary 
left/right-hand sides of transition rules.
\[
\frac{ \square_L \trans{m^{(x_v,\rho)}}_1 \square_R\qquad 
\textrm{$m\in\Sigma_Q$}}{\square_L \trans{m^{(x_v,\rho+2)}} \square_R}
\qquad
\frac{ \square_L \trans{m^{(x_v\vec{i},\rho)}}_1 \square_R\qquad\textrm{$\vec{i}\neq \epsilon$ or ($\vec{i}=\epsilon$ and $m\in\Sigma_A$)}}{\square_L \trans{m^{(x_v \vec{i},\rho)}}\square_R}
\]
Memory-related transitions are also copied, while adjusting the depth of the level that is being accessed by adding~$2$:
\[
\frac{(\mop{2j}{h}{v},\cs{2i}) \trans{\epsilon}_1 (v',\ds{2i})}{ 
(\mop{2j+2}{h}{v},\cs{2i}) \trans{\epsilon} (v',\ds{2i})}.
\]
The preservation of $\oa$ and $\pq$ follows from the construction and IH,
as the old transitions are simply copied in and 
relabelled injectively. $\fa$ follows from the shape of the new transitions and IH.


\paragraph{$\mathbf{M\equiv\newvar{x}{M_1}}$:} According to~\cite{GM08}, it suffices
to consider plays from $M_1$ in which $\mread^{(x,\rho)}$ and $\mwrite{j}^{(x,\rho)}$ moves are immediately followed by answers, and
the sequences obey the ``good variable'' discipline (a value that is
read corresponds to the most recently written value).
To implement this recipe in an automaton, 
we add an extra cell at level $0$ to store values of $x$
along with explicit initialisation (to facilitate automata re-use in loops).
To this end, we take
$k=k_1$, $N=N_1+1$, 
$\CS{0}=\CS{0}_1+\{\circ,\bullet\}$,
$\CS{i}= \CS{i}_1$ ($0< i\le k$).
All transitions from $\Aut_{M_1}$ can be copied over except 
$\add(0), \del(0)$ and those with superscripts of the
form $(x,\rho)$, i.e. related to $x$.
$\add(0)$ and $\del(0)$ are handled
as specified below.
\[
\frac{m\in I_{\sem{\beta}}}{
\dagger\trans{m} \{\circ\}}
\qquad
\frac{0\le v\le \imax}{
(\mop{0}{N}{v},\circ)\trans{\epsilon} (0,\bullet)}
\qquad
\frac{\dagger\trans{q}_1 \DS{0}_1}{
\{\bullet\}\trans{\epsilon} \DS{0}_1}
\qquad
\frac{\DS{0}_1 \trans{a}_1 \dagger}{\DS{0}_1 \trans{a} \dagger}
\]
Note that in this case $\beta=\comt,\expt$, 
so $I_{\sem{\beta}}=\{\mrun\}$ or $I_{\sem{\beta}}=\{\mq\}$.


For transitions related to $x$ we proceed as follows.
\[
\frac{\cs{2i}\trans{\mwrite{j}^{(x,\rho)}}_1 \ds{2i+1}\trans{\mok^{(x,0)}}_1 \ees{2i}\quad 0\le v\le \imax
}{
(\mop{0}{N}{v}, \cs{2i}) \trans{\epsilon} (j, \ees{2i}) 
}
\qquad
\frac{\cs{2i}\trans{\mread^{(x,\rho)}}_1 \ds{2i+1}\trans{j^{(x,0)}}_1 \ees{2i}
}{
(\mop{0}{N}{j}, \cs{2i}) \trans{\epsilon} (j, \ees{2i})
}
\]
Thanks to $\oa$, the construction will add (at most) 
$\imax+1$ new transitions for each transition 
$\cs{2i}\trans{\mwrite{j}^{(x,\rho)}}_1 \ds{2i+1}$.
Observe that they have the shape
$(\mop{0}{N}{v}, \cs{2i}) \trans{\epsilon} (j, \ees{2i})$ ($0\le v\le \imax$),
and could be represented succinctly by writing
$(\mop{0}{N}{?}, \cs{2i}) \trans{\epsilon} (j, \ees{2i})$,
where $?$ is a wildcard representing an arbitrary value.
So, each $\cs{2i}\trans{\mwrite{j}^{(x,\rho)}}_1 \ds{2i+1}$ gives rise to a single transition with a wildcard.
As the only modifications on $\eps(2j,2i)$ transitions
are of the kind discussed above (adding to
the first two components, but never values), 
this representation
with wildcards can be propagated in further steps.
Similarly, thanks to $\pq$, each transition 
$\ds{2i+1}\trans{j^{(x,0)}}_1 \ees{2i}$ gives rise
to (at most) one new transition 
$(\mop{0}{N}{j}, \cs{2i}) \trans{\epsilon} (j, \ees{2i})$.

Correctness follows from the fact that it suffices to restrict
the work of $M_1$ to traces in which the relevant moves follow each other~\cite{GM08}. Further, by Lemma~\ref{lem:eo}, it suffices to consider scenarios in which the associated transitions follow each other.
$\oa,\pq$ are preserved, because no new relevant transitions are introduced. $\fa$ follows by appealing to IH.

\paragraph{$\mathbf{M\equiv\newsem{s}{M_1}}$:} This case is very similar to the previous one but 
only two values are possible: $0$ (the initial one) or $1$. Transitions corresponding to grabbing change $0$ to $1$, whereas releasing the semaphore does the opposite.
Thanks to $\oa$ and $\pq$, only one transition will be added for each original transition on $\mgrb$ and $\mrls$ respectively.
\[
\frac{\cs{2i}\trans{\mgrb^{(s,\rho)}}_1  \ds{2i+1}\trans{\mok^{(s,0)}}_1 \ees{2i}
}{
(\mop{0}{N}{0}, \cs{2i}) \trans{\epsilon} (1, \ees{2i})
}
\qquad
\frac{\cs{2i}\trans{\mrls^{(s,\rho)}}_1 \ds{2i+1} \trans{\mok^{(s,0)}}_1 \ees{2i}
}{
(\mop{0}{N}{1}, \cs{2i}) \trans{\epsilon} (0, \ees{2i})
}
\]

\cutout{
 \paragraph{$\mathbf{M\equiv\grb{M_1}}:$} Here we want to perform the same transitions as 
the automaton for $M_1$ would when started from $\mgrb$.
At the same time, $\mgrb$ and the corresponding answer $\mok$ have to be relabelled to $\mrun$ and $\mdone$ respectively.
Consequently, it suffices to preserve all transitions from $\Aut_{M_1}$
except $\add(0)$ and $\del(0)$,
which are modified as follows.
\[
\frac{\dagger\trans{\mgrb}_1 \DS{0}}{\dagger \trans{\mrun} \DS{0}}
\qquad
\frac{\DS{0}\trans{\mok}_1 \dagger}{\DS{0} \trans{\mdone} \dagger}
\]
Clearly, $\oa$, $\pq$ and $\fa$ are inherited in this case.
The case $\mathbf{M\equiv\rls{M_1}}$ is the same as the previous one
but $\mrls$ should be used instead of $\mgrb$.}




\subsection*{Complexity analysis} 

The constructions produce an automaton in which 
there are linearly many states, memory cells and transitions,
with respect to term size. For states, it suffices to observe that each construction adds at most a fixed number of new states
to those obtained from IH. The same applies to memory cells.

The case of transitions is harder, as there are several ways
in which transitions are added to the new automaton.
The easiest case is when a transition is simply copied
from an automaton obtained through IH without any changes
to transition labels. Other cases, represented by inference rules,
are based on single premises (old transitions) and generate
new single transitions. As the old ones are not included
in the new automaton, such rules preserve the number of transitions.
$\newvar$ relies on a rule with two premises but,
as discussed, the outcome could still be viewed as 
a single transition with a wildcard.
Finally, when transitions cannot be traced back to old ones,
their number is always bounded by a constant (we regard $\imax$
as a constant too).

Hence, we can conclude that the number of transitions (possibly with
wildcards) will be linear. Because each transition with a wildcard
represents $\imax+1$ transitions without wildcards,
by instantiating them we still obtain a linear number of transitions.
It is also worth noting that each transition involves at most three states:
whenever sets of states are involved in transitions, 
they contain at most two elements.

Finally, we assess the time complexity of the constructions.
A typical case consists of invoking IH and performing 
a bounded number of linear-time operations on the results 
to implement the constructions, such as
retagging to implement the disjoint sum and relabelling.
The combinations of transitions mentioned in $\iaterm{newvar}$
can also be considered in linear time after some preprocessing
that guarantees constant-time access to incoming and outgoing
transition of a given state.
Overall, this could be viewed as a linear number of linear-time operations,
yielding quadratic time complexity. 
Note that the quadratic bound will not extend to the general case, as the conversion to $\beta$-normal $\eta$-long form can induce a significant blowup in the size of the term.
\end{proof}

\section{Conclusion}
We have introduced saturating automata, a new model of computation over infinite alphabets.
Unlike earlier proposals~\cite{DLMW21,DLMW21b},
the automata accept only languages that satisfy a closure property corresponding to saturation, 
a property that naturally emerges in concurrent interactions between programs and their environment.
Consequently, the automata can be claimed to provide a more intrinsic model of such interactions.

We also showed that saturating automata can be used to represent the game semantics of $\fica$,
a paradigmatic language combining higher-order functions, state and concurrency. 
In contrast to previous translations, one does not incur an
exponential penalty for using saturating automata to interpret $\fica$ terms in normal form,
which further confirms their fit with $\fica$. 
Regarding emptiness testing, one can still obtain decidable cases by imposing restrictions analogous to those for leafy~\cite{DLMW21} and split automata~\cite{DLMW21b}.

The opportunity for further exploration of saturating automata remains, with a view to finding verification routines that can
capitalise on saturation.

\begin{ack}
We thank the anonymous reviewers for helpful comments.
\end{ack}



