% !TEX root = main.tex


\section{Introduction}

Game semantics is a versatile modelling theory that interprets computation 
as interaction between two players, called O (Opponent) and P (Proponent).
The two players represent the environment and the program respectively,
so programs can be interpreted as strategies for P.
Although initially game models concerned functional sequential computation, 
notably the language PCF~\cite{AJM00,HO00},
it did not take long for the methodology to be extended 
to other programming constructs such as state~\cite{AM97a,AHM98}, control operators~\cite{Lai97},
and, soon afterwards, concurrency.
Some of the game models were presented in the interleaving tradition of models of concurrency~\cite{Lai01,Lai06,GM08}, 
while others were built in the spirit of partial-order methods (true concurrency)~\cite{CCRW17}.

In the interleaving  approach, the aim is to construct strategies in such a way that
they will contain all possible sequential observations of parallel interactions.
Within game semantics, this led to the realisation that strategies must be closed 
under certain rearrangements of moves, to reflect the limited power of programs
to observe and control the actual ordering of concurrent actions.
Critically, a program can wait until an environment action occurs before proceeding,
but it does not have any influence over environment actions or its own concurrent actions beyond those stipulated by the game.
%it will not be able to force its own actions to occur before other concurrent actions 
%or observe the order in which two consecutive environment actions occur.
To express this constraint, one requires that strategies
should be closed under certain move swaps. More specifically,
consecutive $m_1 m_2$ can be swapped as long as the swap still leads to a valid play and
it is \emph{not} the case that $m_1$ is an O-move and $m_2$ is a P-move.

In game semantics, this condition first appeared in a model of Idealized CSP~\cite{Lai01},
and was named \emph{saturation} in~\cite{GM08}.
In game models based on event structures~\cite{CCRW17}, 
an analogous condition can be expressed more directly using event structures with polarity.
Variants of saturation also occur in other contexts in the theory of concurrency.
For example, they have been used to describe propagation of signals across wires in
delay-insensitive circuits~\cite{Udd86} or to
specify the relationship between input and output in asynchronous
systems with channels~\cite{JJH90}.  

More recently, there have been attempts at defining automata-theoretic formalisms that provide support
for representing plays in concurrent game semantics~\cite{DLMW21,DLMW21b}. At the technical level, plays are
sequences of moves connected by pointers, which poses a challenge for standard automata theory based on
finite alphabets. However, an infinite alphabet is ideal for this purpose,
especially if it has tree structure, so that the parent relation (link from child to parent) can provide 
a means of representing game-semantic pointers.
Although the proposed formalisms were shown to accommodate the game semantics of higher-order concurrent programs, 
notably, that of a finitary version of Idealized Concurrent Algol ($\fica$)~\cite{GM08}, they do not capture natively
the saturation condition: 
in addition to interpretations of $\fica$ terms (which are guaranteed to satisfy saturation),
they are also capable of accepting many other languages, which need not be closed under any kind of swaps.

In contrast, in this paper, we define an automata model over infinite alphabets,
called \emph{saturating automata}, for which any accepted language
is guaranteed to satisfy (a language variant of) the saturation condition.
It is achieved through carefully tailored transitions, which in particular
restrict the way that siblings may communicate with each other through parents,
and minimise direct communication between other generations.

The new design turns out to bring another technical advantage over existing translations.
Saturating automata corresponding to $\fica$ terms in normal form have linearly many states and transitions
(with respect to term size), and can be generated in at most quadratic time.
This is an improvement over the exponential complexity inherent in earlier translations,
which was due to either the fact that memory was modelled through control states~\cite{DLMW21}
or the use of product constructions to handle parallel composition~\cite{DLMW21b}.
In view of the ubiquity of the saturation condition, we believe that this makes
saturating automata into a point of interest in the design space of automata models,
which deserves further study in connection with game semantics or other areas mentioned above.

\subsection*{Related work} 

In addition to the papers already mentioned,
the combination of game semantics and automata theory over infinite alphabets
appeared in research into sequential computation, e.g.
to handle call-by-value computation with state~\cite{CHMO15,CBMO19}, ground references~\cite{MT18} and objects~\cite{MRT15}.
On the concurrent front, Petri-net-like devices have recently been proposed to interpret higher-order concurrency along with a correspondence to game semantics~\cite{CC23}. 

More broadly, our results are related to encodings of higher-order computation
in process calculi~\cite{San93,RS99,BHY01} (where the role of infinite alphabets would be played by a set of names)
and to abstract machines~\cite{LTY17}.
It would also be interesting to find connections between our work and trace theory over 
partially commutative alphabets~\cite{CF69,Maz78}, though there the commutation relation is typically symmetric, 
unlike in our case.






