% !TEX root = main.tex


\section{Finitary Idealised Concurrent Algol ($\fica$)}
\label{sec:fica}

% Figure environment removed


Idealised Concurrent Algol~\cite{GM08} is a paradigmatic 
call-by-name language 
combining higher-order computation with imperative constructs 
in the style of Reynolds~\cite{Rey78}, 
extended to concurrency with parallel composition ($\parc$) and binary semaphores.
We consider its finitary variant, $\fica$,
defined over a finite datatype $\makeset{0,\ldots,\imax}$ ($\imax\ge 0$), with no recursion, but with iteration.
Its types $\theta$ are generated by the grammar 
\[
\theta::=\beta\mid \theta\rarr\theta\qquad\qquad
  \beta::=\comt\mid\expt\mid\vart\mid\semt
\]
where 
$\comt$ is the type of commands;
$\expt$ that of $\makeset{0,\ldots,\imax}$-valued expressions;
$\vart$ that of assignable variables;
and $\semt$ that of semaphores.
The typing judgments are displayed in Figure~\ref{fig:icatypes}.
Here, $\skipcom$ and $\divcom_\theta$ are constants representing termination and divergence respectively,
$i$ ranges over $\{0,\ldots,\imax\}$,
and $\mathbf{op}$ represents unary arithmetic operations, such as successor or predecessor (since we work over a finite datatype, operations of bigger arity can be defined using conditionals).
Variables and semaphores can be declared locally via $\mathbf{newvar}$ and $\mathbf{newsem}$.
Variables are dereferenced using $!M$, and semaphores are manipulated using two (blocking) primitives,
$\grb{s}$ and $\rls{s}$, which  grab and release the semaphore respectively. 
\input{apx-fica}

$\fica$ terms can be compared using a notion of
\emph{contextual (may-)equivalence}, denoted $\Gamma\vdash M_1\cong M_2$.
Two terms of the same type and with the same free variables 
are equivalent if 
they cannot be distinguished with respect to termination by any context:
for all contexts $\ctx$ such that $\seq{}{\ctx[M_1]:\comt}$, we have
$\ctx[M_1]\!\Downarrow$ if and only if $\ctx[M_2]\!\Downarrow$.
Using game semantics, one can reduce $\cong$ to equality of
the associated sets of complete plays (Theorem~\ref{thm:full}).
%However, due to quantification over all contexts, even very simple instances of equivalence are undecidable~\cite{GMO06}.
\begin{example}\label{ex:term}
Consider the term
\[
\seq{f:\comt\rarr\comt, c:\comt}{
\newvar{x}{(f\,( x\,\aasg{1} )\,\,\parc\,\, \cond{\,\deref{x}}{\,c\,}{\,\divcom}_\comt);\, \deref{x}} : \expt}
\]
The free variable $f$ can be viewed as representing an unknown
function, to be bound to concrete code by a context. Since
we work in a call-by-name setting, that function may evaluate
its argument arbitrarily many times, including none.
If  the function does not use its argument, the value of $x$
will always be $0$ (we assume that local variables are initialised to $0$)
and the term will never terminate, because the right term inside $\parc$
will always diverge, preventing the whole term from terminating.
On the other hand, as long as $f$ evaluates its argument at least once and terminates,
and the right-hand side of $\parc$ is scheduled after the assignment $x\aasg 1$ (and code bound to $c$ terminates) then the whole term will terminate too, returning $1$.
\end{example}
In the next section we sketch the game semantics of $\fica$.
