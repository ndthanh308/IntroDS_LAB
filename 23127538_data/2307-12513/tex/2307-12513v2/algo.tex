\section{Correcting the product}
\label{sec:main}

In the following, we use $n$ to denote the row- and column-dimensions of the input matrices, and we let $p$ be a prime number greater than $n$. 

% It is known that $(\mathbb{Z}_p,\cdot)$ is a cyclic group; namely, there is an element $g\in\mathbb{Z}_p$, called the generator of the group, such that 
% \[\{g^{i} \colon\, i\in [p]\} = \mathbb{Z}_p.\]

% \begin{proposition}
%     For $i, j\in \mathbb{N}$, $i\not\equiv j\; (\bmod p)\implies g^i\neq g^j$. 
% \end{proposition}

\subsection{The certificate} 
\label{sec:certificate}

% Let $g$ be a generator of $(\mathbb{Z}_p,\cdot)$. 
Let $m$ be a positive integer, and let $V$ be an $n\times m$ matrix with entries in $[p]$ such that
\[V_{ij}\equiv i^{j-1} \pmod{p}. \]
% For $m\leq n$, the $n\times m$ Vandermonde matrix of $1,2,\dots, n$ 
% \[\left(\begin{array}{ccccc}
%     1 & g^1 & g^{1\cdot2} & \dots & g^{1\cdot (m-1)} \\
%     1 & g^2 & g^{2\cdot 2} & \dots & g^{2\cdot (m-1)} \\
%     \vdots & \vdots & \vdots & \ddots & \vdots \\
%     1 & g^n & g^{n\cdot2} & \dots & g^{n\cdot (m-1)} \\ 
% \end{array}\right)\]
We call $V$ an \textit{$m$-certificate}. 
Given the $m$-certificate $V$, a nonzero row $\vectorbold{u}$ of $AB-C$  is \textit{$V$-detectable} if $\vectorbold{u}V\neq \mathbf{0}$. Similarly,  a nonzero column $\vectorbold{u}$ of $AB-C$ is {$V$-detectable} if $\vectorbold{u}^TV\neq \mathbf{0}$.




\begin{lemma}
\label{lem:detectability}
    Let $V$ be an $m$-certificate. Then every nonzero row or column of $AB-C$ containing at most $m$ nonzeros is $V$-detectable. 
\end{lemma}

\begin{proof}
    Let $\vectorbold{u}=(u_1,\dots, u_n)$ be a nonzero row of $AB-C$, and let $S = \{i\in[n]\colon\, u_i\neq 0\}$. The submatrix $V_S$ of $V$ consisting of the rows indexed by $S$ is an $m\times m$ Vandermonde matrix of $m$ distinct elements over $\mathbb{Z}/p\mathbb{Z}$. By Lemma~\ref{lem:key}, $\vectorbold{u}\neq \mathbf{0}$ iff $\vectorbold{u}_SV_S\neq \mathbf{0}$, where $\vectorbold{u}_S$ is the subvector consisting of entries indexed by~$S$.
\qed\end{proof}

\medskip
In the following,  we assume that $\sqrt{k}$ is an integer to ease the presentation, and $m$ is fixed to be $\sqrt{k}$. For succinctness a $\sqrt{k}$-certificate $V$ is simply called a \textit{certificate}, and a row or a column that is $V$-detectable is simply said to be \textit{detectable}. 
For a certificate  $V$, the matrices $\ind{IC}=(AB-C)^TV$ and $\ind{IR}=(AB-C)V$ are called the \textit{column-indicator} and 
\textit{row-indicator} of $AB-C$, respectively. 

\begin{lemma} \label{lem:both_zero}
    Given three $n\times n$ matrices $A$, $B$ and $C$, let $V$ be a certificate, and let $\ind{IC}$ and $\ind{IR}$ be the \textit{column-indicator} and \textit{row-indicator} of $AB-C$, respectively.  If $\ind{IC}={\bf 0}$ and $\ind{IR}={\bf 0}$, then $AB=C$.
\end{lemma}

\begin{proof}
    Since $\ind{IC}={\bf0}$ and $\ind{IR}={\bf 0}$, by Lemma~\ref{lem:detectability}, every column or row of $AB-C$ that contains a nonzero has more than $\sqrt{k}$ nonzeros. The existence of a nonzero column implies that $AB-C$ contains more than $k$ nonzeros.   
\qed\end{proof}

% \begin{lemma}\label{lem:one_zero}
%     Given that $M=AB-C$ has at most $k$ nonzeros, let $V$ be a $\sqrt{k}$-certificate, and let $I_C$ and $I_R$ be the \textit{column-indicator} and 
% \textit{row-indicator} of $AB-C$ with respect to $V$, respectively. If $I_C={\bf 0}$ and $I_R\neq{\bf 0}$, then 
%     \[M_{ij}\neq 0\implies I_R[{i,*}]\neq {\bf 0}.\] 
%     Similarly, if $C\neq {\bf 0}$ and $R={\bf 0}$, then 
%     \[M_{ij}\neq 0\implies I_C[{*,j}]\neq {\bf 0}.\]
% \end{lemma}

% \begin{proof}
%     We assume that $I_C={\bf 0}$ and $I_R\neq{\bf 0}$. The case where $I_C\neq {\bf 0}$ and $I_R={\bf 0}$ can be proved analogously.   Since $V$ is a $\sqrt{k}$-certificate and $I_C={\bf 0}$, by  Lemma~\ref{lem:detectability} every nonzero column of $M$ contains more than $\sqrt{k}$ nonzeros. By the pigeonhole principle, there are less than $\sqrt{k}$ nonzero columns, which means that every nonzero row of $M$ is $V$-detectable. 
% \end{proof}

 
Observe that for a row of $AB-C$ containing more than $\sqrt{k}$ nonzeros, one of these nonzero entries must be in a column containing less than $\sqrt{k}$ nonzeros, given that $AB-C$ contains at most $k$ nonzeros. As an immediate consequence, we note the following.

\begin{remark}\label{rmk:one_zero}
    Every non-detectable row (respectively, column) contains a nonzero entry residing in a detectable column (respectively, row). 
\end{remark}

We end this section by giving the pseudocode for computing the indicators. Note that the sets, $S$ and $T$, of indices of nonzero rows of $\ind{IR}$ and nonzero columns of $\ind{IC}$ are essential for our algorithm. In the following, we denote the indicators by $(\ind{IR},S)$ and $(\ind{IC},T)$. 

\medskip
\begin{algorithmic}[1]
\Function{RowIndicator}{$A$, $B$, $C$, $V$}
   \State $\ind{IR}\gets A(BV)-CV$
   \State $S\gets \{i\in[n]\colon\, \mbox{row $i$ of \ind{IR} is nonzero}\}$
   \State \textbf{return} $(\ind{IR},S)$
\EndFunction

\medskip
\Function{ColIndicator}{$A$, $B$, $C$, $V$}
   \State $\ind{IC}\gets (V^TA)B-V^TC$
   \State $T\gets \{j\in[n]\colon\, \mbox{column $j$ of \ind{IC} is nonzero}\}$
   \State \textbf{return} $(\ind{IC},T)$
\EndFunction

\end{algorithmic}


\subsection{The algorithm} 
\label{sec:algo}


\begin{algorithm}[t]
\begin{algorithmic}[1]

\Require $AB-C$ contains no more than $k$ nonzeros, $V$ is the certificate
\Ensure $C=AB$
\State $(\ind{IR}, S)\gets${\sc RowIndicator}$(A, B, C, V)$ 
\State $(\ind{IC}, T)\gets$ {\sc ColIndicator}$(A, B, C, V)$
\For{$(i,j)\in (S\times [n]) \cup ([n]\times T)$}
    \State $C_{ij}\gets (AB)_{ij}$ 
\EndFor 
\end{algorithmic}
\caption{An $O(kn^2)$-time algorithm for correcting the matrix product with no more than $k$ errors.}\label{alg:primary}
\end{algorithm}

Once we have the row- and column-indicators $(\ind{IR},S)$ and $(\ind{IC},T)$, all erroneous entries in $C$ can be corrected using $O(kn^2)$ operations (see Algorithm~\ref{alg:primary} below). If $\ind{IC}=\mathbf{0}$ and $\ind{IR}=\mathbf{0}$, then $AB=C$ (Lemma~\ref{lem:both_zero}). Otherwise, we identify nonzero rows and columns, and then recompute all these rows and columns one by one.
 As mentioned in Remark~\ref{rmk:one_zero}, the index $i$ of a nonzero row is either in $S$ or there exists $j\in T$ such that $M_{ij}\neq 0$. Therefore, all nonzero rows can be identified either via $S$, or via computing the columns indexed by $T$; a symmetric procedure can be applied to identify all the nonzero columns. Since there are no more than $k$ nonzero entries in $M$, at most $k$ rows and columns of $AB$ are identified and to be computed. A straightforward computation using $O(n^2)$ operations per row/column leads to an algorithm of $O(kn^2)$ operations.



    
%  \begin{lemma}
% \label{lem:identification}
%     Row $i$ of $M$ is nonzero if and only if one of the following holds:
%     \begin{itemize}
%         \item $i\in S$.
%         \item There exists $j\in T$ such that $M_{ij}\neq 0$.
%     \end{itemize} 
%     Similarly, column $j$ of $M$ is nonzero if and only if one of the following holds:
%     \begin{itemize}
%         \item $j\in T$.
%         \item There exists $i\in S$ such that $M_{ij}\neq 0$.
%     \end{itemize}
% \end{lemma}

% \begin{proof}
%     The sufficiency is straightforward. The necessity follows from the pigeonhole principle. 
% \end{proof}

% \noindent
% By Lemma~\ref{lem:identification}, nonzero rows are either in $S$ or can be identified via computing column $j$ of $M$ for $j\in T$, and nonzero columns can be identified in a symmetric manner. Once nonzero rows and columns are identified, computing these rows and columns of $AB$ gives the correct result. 

\medskip
% a figure illustrating the following situation.


\begin{remark}
    The upper bound of $kn^2$ is tight for the algorithm described above. For instance, if each of the $i$th row and the $j$th column of $AB-C$ contains about $k/2$ nonzeros, then each nonzero entry at row $i$ or column $j$ is located using  $\Theta(n^2)$ operations. 
    
\[\left(\begin{array}{cccccc}
    0 & 0 & \dots & a_{1j} & \dots & 0 \\
    0 & 0 & \dots &a_{2j} & \dots & 0 \\
    \vdots &\vdots &  & \vdots &  & \vdots \\
    a_{i1} & a_{i2} & \dots &a_{ij} & \dots & a_{in} \\ 
        \vdots & \vdots & & \vdots &  & \vdots \\
            0 & 0 &\dots & a_{nj} & \dots & 0 \\
\end{array}\right)\]
\end{remark}


%
% To achieve the bound of $O(k^2n+\sqrt{k}n^2)$ on the number of operations, some ``redundant'' computation has to be avoided; e.g. 
%a nonzero row/column is not identified twice. In addition, we would like to ensure that any row (respectively, column) identified via computing a column in $T$ (respectively, a row in $S$) contains sufficiently many nonzeros. In such a way the corrections of entire rows or columns would not be invoked too many times. 
%

\medskip
Below, we modify Algorithm~\ref{alg:primary} to obtain an $O(k^2 n + \sqrt{k} n^2)$-time algorithm. The algorithm works in two phases. For clarity, let $(\ind{IR}_0, S_0)$ and $(\ind{IC}_0, T_0)$ be the indicators in the very beginning, and let $M_0=AB-C$ be the matrix before the correction on $C$ starts. In the first phase, entries residing in both a detectable row and a detectable column are corrected. Note that right after this phase, nonzero entries are in a row belonging to $[n]\setminus S_0$ or a column belonging to $[n]\setminus T_0$, which means that each of these rows and columns contains more than $\sqrt{k}$ nonzeros in $M_0$. Then, in the second phase the remaining nonzero rows and columns are identified and corrected as in Algorithm~\ref{alg:primary}, except that the indicators are kept up-to-date by the procedure {\sc Update}. An illustration is given in Figure~\ref{fig:algo2}, and the pseudocode of the modified algorithm is given in Algorithm~\ref{alg:main}.

% Figure environment removed


\begin{algorithm}
\begin{algorithmic}[1]
\Function{Update}{$i, j, A, B, C, V, (\ind{IR},S), (\ind{IC},T)$}
   \State $x\gets (AB)_{ij}-C_{ij}$
   \For{$l\in \left[\sqrt{k}\;\right]$}   
        \State $\ind{IR}_{il}\gets \ind{IR}_{il} + x\cdot V_{jl}$
        \State $\ind{IC}_{lj}\gets \ind{IC}_{lj} + x\cdot V_{il}$
   \EndFor  
   \State Update $S$ and $T$ accordingly 
   \State \textbf{return} $(\ind{IR},S), (\ind{IC},T)$
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{An $O(k^2 n + \sqrt{k} n^2)$-time algorithm for correcting the matrix product with no more than $k$ errors.}\label{alg:main}
\begin{algorithmic}[1]

\Require $AB-C$ contains no more than $k$ nonzeros, $V$ is the certificate
\Ensure $C=AB$
% \State $\ind{IR}_0\gets A(BV)-CV$
\State $(\ind{IR}_0, S_0)\gets${\sc RowIndicator}$(A, B, C, V)$ \label{proc:phase1_start}
% \State $S_0\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}_0$ is nonzero}\}$
% \State $\ind{IC}_0\gets (V^TA)B-V^TC$
% \State $T_0\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}_0$ is nonzero}\}$
\State $(\ind{IC}_0, T_0)\gets$ {\sc ColIndicator}$(A, B, C, V)$
\For{$(i,j)\in S_0\times T_0$}
    \State $C_{ij}\gets (AB)_{ij}$ 
\EndFor \label{proc:phase1_end}
% \State $\ind{IR}\gets A(BV)-CV$
% \State $S\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}$ is nonzero}\}$
% \State $\ind{IC}\gets (V^TA)B-V^TC$
% \State $T\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}$ is nonzero}\}$
\State $(\ind{IR}, S)\gets $ {\sc RowIndicator}$(A, B, C, V)$ \label{proc:phase2_start}
\State $(\ind{IC}, T)\gets$ {\sc ColIndicator}$(A, B, C, V)$
\While{$S_0\cap S\neq \emptyset$}  \label{step:row_indicator_loop_start}
    \State $i\gets\mbox{an element of $S_0\cap S$}$  \label{setp:retrieve_row}
    \State $T'\gets \{j'\in[n]\colon\, (AB)_{ij'}\neq C_{ij'} \}$   \Comment{Identify the nonzero columns}
    \For{$(i',j')\in [n]\times T'$}
        \State $(\ind{IR},S), (\ind{IC}, T)\gets ${\sc Update}$(i', j', A, B, C, V, (\ind{IR},S),  (\ind{IC}, T))$
        \State $C_{i'j'}\gets (AB)_{i'j'}$  \label{step:column_update}
    \EndFor \label{step:row_indicator_loop_end}
\EndWhile
\While{$T_0\cap T\neq\emptyset$}  
	\State $j\gets \mbox{an element of $T_0\cap T$}$ \label{setp:retrieve_col}
    \State $S'\gets \{i'\in[n]\colon\, (AB)_{i'j}\neq C_{i'j} \}$ \Comment{Identify the nonzero rows}
    \For{$(i',j')\in S'\times [n]$} 
        \State $(\ind{IR},S), (\ind{IC}, T)\gets ${\sc Update}$(i', j', A, B, C, V, (\ind{IR},S), (\ind{IC}, T))$
        \State $C_{i'j'}\gets (AB)_{i'j'}$  \label{step:row_update}
    \EndFor
\EndWhile
\end{algorithmic}
\end{algorithm}

For the correctness of Algorithm~\ref{alg:main}, first we observe that once a row or a column is detected, it remains detectable during the execution of the algorithm until all erroneous entries in the row or the column are corrected. This observation is an immediate consequence of Lemma~\ref{clm:1st_modification}.

\begin{lemma}
\label{clm:1st_modification}
    Before the execution of line~\ref{proc:phase2_start}, for $i\in S_0\cap S$ row $i$ of $AB-C$ contains at most $\sqrt{k}$ nonzeros in $M_0$. Similarly, for $j\in T_0\cap T$ column $j$ contains at most $\sqrt{k}$ nonzeros in $M_0$. 
\end{lemma}

\begin{proof}
    If row $i$ of $M_0$ contains no more than $\sqrt{k}$ nonzeros, the lemma holds immediately. Otherwise, since the entries that resides in a column containing at most $\sqrt{k}$ nonzeros were corrected at line~\ref{proc:phase1_end}, by the pigeonhole principle less than $\sqrt{k}$ entries remains in row $i$. A similar argument applies for $j\in T_0\cap T$.  
\qed\end{proof}



\begin{lemma}[Correctness of Algorithm~\ref{alg:main}]
\label{lem:correctness}
    All erroneous entries of $C$ are corrected during the execution of Algorithm~\ref{alg:main}.
\end{lemma}

\begin{proof}
    Suppose to the contrary that there exist $i$ and $j$ such that $C_{ij}$ is not corrected during the execution. Clearly, $i\notin S_0$ or $j\notin T_0$. If either $j\in T_0$ or $i\in S_0$, by Lemma~\ref{clm:1st_modification} $M_{ij}$ remains nonzero until $C_{ij}$ is corrected so it would be corrected at line~\ref{step:column_update} or line~\ref{step:row_update}. Thus we may assume that $i\notin S_0$ and $j\notin T_0$. Since $j\notin T_0$ and $M_{ij}\neq 0$, column $j$ of $M_0$ contains more than $\sqrt{k}$ nonzeros. By Remark~\ref{rmk:one_zero}, there is a nonzero entry $M_{i'j}$ such that $i'\in S_0$. If $i'$ is picked at line~\ref{step:row_indicator_loop_start}, then column $j$ of $C$ is corrected; otherwise all erroneous entries in row $i'$ of $C$ have to be corrected before $i'$ is picked during the loop. However, the correction of $C_{i'j}$ implies that all erroneous entries in column $j$ of $C$ are corrected, which leads to a contradiction. 
\qed\end{proof}

\medskip
Regarding the number of operations, keeping the row- and column-indicators up-to-date ensures that the process of identification is performed only if there is an erroneous entry, not corrected yet, in the corresponding row or column. We show this in Theorem~\ref{thm:time}.



\begin{theorem}
\label{thm:time}
    Given three $n\times n$ matrices of integers $A$, $B$, and $C$ with $C$ different from $AB$ by no more than $k$ entries, then all erroneous entries can be corrected by a deterministic algorithm using $O(k^2n+\sqrt{k}n^2)$ operations. In addition, the  values involved in running the algorithm are of $O(\alpha^2n^3)$, where $\alpha$ is the largest absolute value of an entry in $A$, $B$, and $C$. 
\end{theorem}

\begin{proof}
    We claim that Algorithm~\ref{alg:main} is the requested algorithm. The correctness of Algorithm~\ref{alg:main} follows from Lemma~\ref{lem:correctness}. For the number of operations, phase~1 (lines~\ref{proc:phase1_start} to~\ref{proc:phase1_end}) takes $O(k^2n)$ operations. For the remaining nonzero entries $M_{ij}$, clearly $i\notin S_0$ or $j\notin T_0$, and by Lemma~\ref{lem:detectability} each nonzero row or column identified in phase~2 contains at least $\sqrt{k}$ nonzeros in $M_0$. Thus, the number of distinct rows and columns to be corrected in phase~2 is at most $\sqrt{k}$. Since a row or a column is corrected right after being identified and the indicators are kept up-to-date, a row or a column would not be identified twice. Along with the fact that {\sc Update} takes  $O(n+\sqrt{k})$ operations, the total number of operations is of $O(\sqrt{k}n^2)$.

    \medskip
    Last, according to Bertrand's postulate, there exists a prime $p$ with $n<p<2n$. It follows that the value of an entry in the certificate $V$ is of $O(n)$. Consequently, the largest absolute value of an entry in $(AB-C)V$ is of $O(\alpha^2n^3)$. 
    \qed
\end{proof} 


\medskip
As a final remark, in Algorithm~\ref{alg:main} we have to retrieve elements from $S_0\cap S$ at line~\ref{setp:retrieve_row}, which is equivalent to finding an element of $S_0$ and determining whether it is also an element of the present $S$. Since $S_0$ is static and every element of $S_0$ is processed exactly once, this  can be done efficiently by using an array of integers to represent $S_0$ and $S$. Each integer is a counter, recording the number of nonzeros in the corresponding row of $\ind{IR}_0$/$\ind{IR}$. The same implementation can be applied for $T_0$ and $T$, so the expected complexity can be achieved. In addition, the prime $p$ can be found in $O(n^2)$ time, e.g. using the sieve of Eratosthenes, and then the certificate $V$ can be constructed in $O(\sqrt{k}n)$ time.




% \section{old proof}

% %%%%%%%%%%%%%%  ver. 0 %%%%%%%%%%%%%%%%

% \begin{algorithm}
% \caption{An algorithm with caption}\label{alg:cap}
% \begin{algorithmic}[1]
% \Require $AB-C$ contains no more than $k$ nonzeros
% \Ensure $C=AB$
% % \State $\ind{IR}_0\gets A(BV)-CV$
% \State $(\ind{IR}_0, S_0)\gets${\sc RowIndicator}$(A, B, C, V)$
% % \State $S_0\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}_0$ is nonzero}\}$
% % \State $\ind{IC}_0\gets (V^TA)B-V^TC$
% % \State $T_0\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}_0$ is nonzero}\}$
% \State $(\ind{IC}_0, T_0)\gets$ {\sc ColIndicator}$(A, B, C, V)$
% \For{$(i,j)\in S_0\times T_0$}
%     \State $C_{ij}\gets (AB)_{ij}$
% \EndFor
% % \State $\ind{IR}\gets A(BV)-CV$
% % \State $S\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}$ is nonzero}\}$
% % \State $\ind{IC}\gets (V^TA)B-V^TC$
% % \State $T\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}$ is nonzero}\}$
% \State $(\ind{IR}, S)\gets $ {\sc RowIndicator}$(A, B, C, V)$
% \State $(\ind{IC}, T)\gets$ {\sc ColIndicator}$(A, B, C, V)$
% \For{$i\in S_0\cap S$}  
%     \State $T'\gets \{j'\in[n]\colon\, (AB)_{ij'}\neq C_{ij'} \}$   \Comment{Identify the nonzero columns}
%     \For{$(i',j')\in [n]\times T'$}
%         \State $C_{i'j'}\gets (AB)_{i'j'}$
%         % \State Update $C$, $\ind{IR}$, $\ind{IC}$, $S$, and $T$
%     \EndFor
% \EndFor
% \For{$j\in T_0\cap T$}  
%     \State $S'\gets \{i'\in[n]\colon\, (AB)_{i'j}\neq C_{i'j} \}$ \Comment{Identify the nonzero rows}
%     \For{$(i',j')\in S'\times [n]$} 
%         \State $C_{i'j'}\gets (AB)_{i'j'}$
%     \EndFor
% \EndFor
% \end{algorithmic}
% \end{algorithm}

% \begin{lemma}
% \label{lem:correctness}
%     All erroneous entries of $C$ are modified during the execution of Algorithm.
% \end{lemma}

% \begin{proof}
%     Let $M_{ij}\neq 0$. Then $(i,j)\in S_0\times T_0$, $(i,j)\in S_0\times ([n]-T_0)$, $(i,j)\in ([n]-S_0)\times T_0$, or $(i,j)\in ([n]-S_0)\times ([n]-T_0)$. For $(i,j)\in S_0\times T_0$, $C_{ij}$ is update at line~4. Otherwise, assume that $i\in [n]-S_0$. By Lemma~\ref{lem:detectability} row $i$ of $M$ contains more than $\sqrt{k}$ nonzeros; in addition, no entry in row $i$ of $C$ is updated at line~4. By the pigeonhole principle, there exists $j'\in T$ such that $M_{ij'}\neq 0$. Thus, $C_{ij}$ is updated at line~14, when updating row $i$ via $j'$.  The case in which $j\in [n]-T_0$ can be analyzed analogously.
% \end{proof}



% \begin{lemma}
%     Let $S=\{i\in[n]\colon\, \mbox{row $i$ of $\ind{IR}$ is nonzero}\}$ and $T=\{j\in[n]\colon\, \mbox{column $j$ of $\ind{IC}$ is nonzero}\}$. For  $(i, j)\in S\times ([n]-T)$, if $M_{ij}\neq 0$, then column $j$ of $M$ contains more than $\sqrt{k}$ nonzeros. Similarly, for  $(i, j)\in ([n]-S)\times T$, if $M_{ij}\neq 0$, then row $i$ of $M$ contains more than $\sqrt{k}$ nonzeros.
% \end{lemma}

% \begin{proof}
%     Assume that $(i, j)\in S\times ([n]-T)$. Since $M_{ij}\neq 0$, by Lemma~\ref{lem:detectability} column $j$ of $M$ contains more than $\sqrt{k}$ nonzeros. 
% \end{proof}


% The number of operations used by Algorithm~\ref{} is still $O(kn^2)$ since a nonzero row or column may be identified multiple times. To avoid redundant computation of an identical row/column, beside $C$ we also keep the indicators up-to-date. 

% \begin{observation}
% \label{clm:chain_modification}
%     For $i\notin S_0$, let $M_{ij}\neq 0$ with $j\in T_0\cap T$. Entry $(i,j)$ is corrected through $j'\in T_0\cap T$ with $M_{ij'}\neq 0$. 
% \end{observation}

% Note that it is possible that $j=j'$.


% We claim the correctness by showing the following loop invariant. 
% \begin{lemma}
%     Let $C^*$ be a resulting matrix. Then, $AB=C^*$. 
% \end{lemma}

% \begin{proof}
%     Let $S$ and $T$ be the row- and column-indices of $\ind{IR}$ and $\ind{IC}$ when the loop stops. We show that $S_0\cap S= \es$ and $T_0\cap T= \es$ implies $AB=C^*$. Suppose to the contrary that there is a nonzero $M^*_{ij}$ in $AB-C^*$. Clearly $i\notin S_0\cap S$ because of the looping condition. It follows that either $i\in S_0\cap \overline{S}$, $i\in \overline{S_0}\cap {S}$, or $i\in \overline{S_0}\cap \overline{S}$. 
    
%     \medskip 
%     For $i\in S_0\cap \overline{S}$, we may assume that row $i$ of $M_0$ contains more than $\sqrt{k}$ nonzeros since otherwise the absence of $i$ in $S$ shows that erroneous entries in row $i$ of $C_0$ are corrected. However, by claim~\ref{clm:1st_modification} there are at most $\sqrt{k}$ nonzeros in row $i$ so $i\in \overline{S}$ shows that all entries in row $i$ are zero. 

%     \medskip
%     For $i\in \overline{S_0}\cap {S}$, row $i$ of $M_0$ contains more than $\sqrt{k}$ nonzeros. By the pigeonhole principle there exists $j\in T_0$ such that $M_{ij}\neq 0$. Clearly $j\in T'$ for some $T'$ after the first modification. By claim~\ref{clm:chain_modification} $M_{ij}$ is corrected through some nonzero entry in row $i$, and entries in row $i$ are corrected. 
    
%     \medskip
%     For $i\in \overline{S_0}\cap \overline{S}$, there exists $j\in T_0$ such that $M_{ij}\neq 0$. Clearly $j\in T'$ for some $T'$ after the first modification. By claim~\ref{clm:chain_modification} $M_{ij}$ is corrected through some nonzero entry in row $i$, and entries in row $i$ are corrected.
% \end{proof}


% Consider the erroneous entries in row $i$, where
% \begin{itemize}
%     \item $i\in S_0\cap S$: The entries are corrected at line~21.
%     \item $i\in\overline{S_0}\cap S$: impossible; this means that the number of erroneous entries decreases after line~6. However, since $i\in\overline{S_0}$, no entry on this row will be corrected at line~6.
%     \item $i\in{S_0}\cap \overline{S}$: All erroneous entries in row $i$ are corrected after line~6. (Even if $|S_0|>\sqrt{k}$, the entries at detectable columns will be corrected at line~6. The number of remaining erroneous entries is no more than $\sqrt{k}$. )
%     \item $i\in\overline{S_0}\cap \overline{S}$: Either row $i$ contains no erroneous entries at beginning, or row $i$ contains more than $\sqrt{k}$ erroneous entries. Since $i\in\overline{S_0}$, no erroneous entry in row $i$ is corrected at line~6. By the pigeonhole principle, there exists $j\in T_0$ such that $C_{ij}$ is erroneous. Since $C_{ij}$ is not corrected at line~6, $j\in T_0\implies j\in T$. Thus, $j$ will be picked at line~12, and row $i$ is recomputed at line~15. 
% \end{itemize}


% % \claim $|S_0\cap S|\leq \sqrt{k}$. (wrong)

% \begin{observation}
%     If row $i$ of $\ind{IR}$ is nonzero and row $i$ of $AB-C$ contains more than $\sqrt{k}$ nonzero entries, then less than $\sqrt{k}$ entries resides in a column containing more than $\sqrt{k}$ entries.
% \end{observation}

% \claim If row $i$ is zero in $\ind{IR}_x$, for some $x\in[\ell]$, but nonzero in $\ind{IR}_0$, then there is no erroneous entry in row $i$ after the $x$th update. 

% \begin{observation}
%     For $x\in[\ell]$, $\ind{IR}_{x}$ can be obtained using $O(n+\sqrt{k})$ operations given  $\ind{IR}_{x-1}$.
% \end{observation}


% % We correct the erroneous entries iteratively. The matrix is modified either by recomputing the columns that contain nonzeros in a designated row (corrected through row $i$), or, symmetrically, by recomputing the row that contain nonzeros in a designated column (corrected through column $j$). 

% % \begin{algorithm}
% % \caption{An algorithm with caption}\label{alg:cap}
% % \begin{algorithmic}[1]
% % \Require $AB-C$ contains no more than $k$ nonzeros
% % \Ensure $C=AB$
% % \State $\ind{IR}_0\gets A(BV)-CV$, $S_0\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}_0$ is nonzero}\}$
% % \State $\ind{IC}_0\gets (V^TA)B-V^TC$, $T_0\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}_0$ is nonzero}\}$
% % \For{$(i,j)\in S_0\times T_0$}
% %     \State $C_{ij}\gets (AB)_{ij}$
% % \EndFor
% % \State $\ind{IR}\gets A(BV)-CV$, $S\gets \{i\colon\, \mbox{row $i$ of $\ind{IR}$ is nonzero}\}$
% % \State $\ind{IC}\gets (V^TA)B-V^TC$, $T\gets \{j\colon\, \mbox{column $j$ of $\ind{IC}$ is nonzero}\}$
% % \While{$S_0\cap S\neq \es$ or $T_0\cap T\neq \es$}
% %     \If{$S_0\cap S\neq \es$}
% %         \State $i\gets $ an element of $S_0\cap S$
% %         \State $T'\gets \{j'\in[n]\colon\, (AB)_{ij'}\neq C_{ij'} \}$
% %         \For{$(i',j')\in [n]\times T'$}
% %             \If{ $(AB)_{i'j'}\neq C_{i'j'} $}
% %                 \State Update $C$, $\ind{IR}$, $\ind{IC}$, $S$, and $T$
% %             \EndIf
% %         \EndFor
% %     \Else
% %         \State $j\gets $ an element of $T_0\cap T$
% %         \State $S'\gets \{i'\in[n]\colon\, (AB)_{i'j}\neq C_{i'j} \}$
% %         \For{$(i',j')\in S'\times [n]$}
% %             \If{ $(AB)_{i'j'}\neq C_{i'j'} $}
% %                 \State Update $C$, $\ind{IR}$, $\ind{IC}$, $S$, and $T$
% %             \EndIf
% %         \EndFor
% %     \EndIf
% % \EndWhile
% % \end{algorithmic}
% % \end{algorithm}


% \claim For $i\in S_0\cap S$, if $C_{ij}\neq 0$ after line~6 for some $j\in[n]$, then $j\in \overline{T_0}\cap \overline{T}$ (column $j$ contains more than $\sqrt{k}$ nonzeros). By the pigeonhole principle, at most $\sqrt{k}$ such $j$.

% \claim For $i\in \overline{S_0}\cap \overline{S}$, row $i$ is recomputed at line~15 exactly once. 
% (time complexity; no more than $\sqrt{k}$ row/columns are updated)
% \begin{lemma} 
% \label{lem:enough_nonzero}
%     Let $S$ be the set of row indices of a updated matrix $C$. For $i\in S_0\cap S$, $C_{ij}$ is nonzero $\implies$ column $j$ of $M_0$ contains more than $\sqrt{k}$ nonzeros .
% \end{lemma}

% \begin{proof}
    
% \end{proof}



% \begin{lemma}
% \label{lem:update_indicator}
%     Let $M=AB-C$, and let $M'$ be a matrix identical with $M$ except an entry, say the entry at $(i,j)$. Then $\ind{IR}'$ and $\ind{IC}'$ can be obtained using $O(\sqrt{k})$ operations. 
% \end{lemma}

% \begin{remark} The update of an entry of $M$ with $\ind{IR}$ up-to-date takes $O(n+\sqrt{k})$ operations. 
% \end{remark}
