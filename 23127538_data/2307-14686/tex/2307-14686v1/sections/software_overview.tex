\section{Borinot's software}
\label{sec:software}

A robot intended for research purposes should come with the necessary software that enables some basic functionalities such as low-level controllers, basic state estimation, communication protocols, and other essential tools. 
However, developing these functionalities from scratch can be a resource-intensive task for laboratories.
We opted not to take this approach, and we sought hardware that was compatible with software that already provided these functionalities, requiring only some modifications.

% Figure environment removed

In \figref{fig:software_layout} we show the different software packages that are used in Borinot and how they are distributed among its hardware (NUC as the main processor, Pixhawk as the flight controller, and \gls{odri}'s masterboard as the limbs' controller).
They are described in the following sections.

\subsection{Robot Operating System}
We have chosen ROS 2\footnote{\url{www.ros.org}} as the middleware to run in the onboard NUC computer. 
It enables us to easily integrate the different modules contained in Borinot.
The use of ROS is three-fold. 
First, it is used as a tool to easily exchange data between different modules. 
For example, to send \gls{mocap} poses to PX4 to be fused with the IMU, or to gather the estimated state from PX4.
Second, it is used as the interface for the algorithms that we are researching, which for the sake of modularity are implemented in separate stand-alone libraries.
And third, ROS is used to implement tools that are necessary to operate the robot, such as visualization tools or \glspl{gui} to send commands to the robot.
We have gathered all the ROS software tools related to Borinot as ROS 2 packages and placed them in a single repository at \texttt{\url{https://github.com/hidro-iri/eagle_ros2}}: 
%
\begin{enumerate}
    \item \textbf{\texttt{eagle\_ros2\_bag}}: tools to analyze ROS2 bags.
    \item \textbf{\texttt{eagle\_ros2\_bringup}}: launch and configuration files.
    \item \textbf{\texttt{eagle\_ros2\_control}}: a C++ library with base classes that can be derived to implement custom controllers. It already contains two controllers: a controller based on the off-the-shelf PX4 controllers, and the MPC controller that we used to create the experiments in this paper (described in \secref{sec:control_architecture}). %\comment{Don't know if we should mention eagle\_mpc\_lib here}
    \item \textbf{\texttt{eagle\_ros2\_identification}}: tools to identify the motor-propeller system. That is, the algorithms to run the experiments from \secref{subsec:exp_motor_tests} and a ROS2 node to gather data from the thrust stand.
    \item \textbf{\texttt{eagle\_ros2\_interfaces}}: These are messages and services for interfacing with other packages. 
    \item \textbf{\texttt{eagle\_ros2\_tf}}: a ROS2 base class node that collects the PX4 and ODRI data composing the state of the robot, \ie, poses, joint configuration and their corresponding velocities. 
    Since controllers in the package need the robot state, they must all derive from this class. 
    Additionally, this package contains a node that collects \gls{mocap} poses and does the necessary frame conversions to send them to PX4 for their fusion within its \gls{ekf}.
    \item \textbf{\texttt{eagle\_ros2\_viz}}: this package contains two \glspl{gui}: a state visualization \gls{gui} and another one to send commands to the robot.
\end{enumerate}

\subsection{Flight controller firmware: PX4}
\label{subsec:so_px4}
The PX4 firmware provides a comprehensive suite of functionalities for conducting research with multicopters.
In addition to the necessary auxiliary machinery required to operate a multicopter-based robot, such as radio systems, flight modes (including safety flight modes), and configuration tools, PX4 includes a state estimator that is crucial for accurate and reliable system control.
The state estimator%
\footnote{https://github.com/PX4/PX4-ECL}
facilitates the fusion of a wide range of sensors, including \gls{mocap}, and provides researchers with a reliable foundation to focus on other areas of the robot, such as control.
PX4 also provides a rigorously tested set of flight controllers, which can be used as recovery/safety modes or backup when developing and testing other control algorithms.
Furthermore, the microRTPS client in PX4 along with the Ethernet communication in the flight controller allows for high rate data exchange with ROS2.
Besides, as PX4 is an open-source project that has been adopted by a wide community including the industry, commercial application and research makes it suitable for an open-source multicopter-based robotic platform, such as Borinot.

However, the off-the-shelf PX4 firmware lacks some features that are necessary for our control algorithms, requiring modifications.
Notably, direct access to the \gls{esc} inputs, which is crucial for most control algorithms, is not available.
Additionally, the microRTPS client provided by PX4 does not allow for fast data sending to the onboard computer.
To address these limitations, we developed modifications based on PX4 firmware version 1.12. 
These modifications include the creation of a new flight control mode that operates independently of any existing control modes and the introduction of a new uORB message in PX4 that intervenes only when the new flight mode is active.
By completely isolating the direct control pipeline from PX4's existing pipeline of controllers, our modifications ensure that the latter remains untouched and ready to be activated in the event of an emergency situation with experimental algorithms. 
We also modified the microRTPS client to enable higher-rate sensor data sending.

\subsection{ODRI software}
The ODRI initiative provides firmware that runs on both the micro driver and the master board. 
It also provides a C++ library with an API to receive data from the master board.
However, it does not provide a ROS2 package that enables sending and receiving data to/from the master board.
To do that, we have implemented a ROS2 node that uses the C++ API to communicate with the master board. 
This node contains the necessary publishers and subscribers to operate an ODRI-based robot from ROS2.

