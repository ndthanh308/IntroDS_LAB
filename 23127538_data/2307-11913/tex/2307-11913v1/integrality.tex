
\section{An Integrality Gap for the Natural Linear Program}
\label{sec:int-gap}

In this section, we show that the relaxation~\ref{LP:tag} for \wtd has a
large integrality gap, unless we allow for a resource augmentation of
almost $\ell$, the number of distinct server weights.

Recall that the $\ell$ weights are denoted $W_1 \gg \cdots \gg
W_\ell$, and  there are $k_j$ servers of weight $W_j$. 
Our theorem is the following:

\IntGap*

\textbf{An Instance for Two Classes.}
To gain some intuition, we first consider the special case of
$\ell=2$, and prove the result without giving any resource
augmentation. There are $\nf{n}2$ servers of weight $W$ and $\nf{n}4$
servers of weight $1$, thereby giving a total of $k = \nf{3n}{4}$ servers. The input is given in ``phases''. Each phase is
specified by a distinct subset $S$ of $V$, where $|S|=\nf{n}2$. During
the phase corresponding to a subset $S$, we cycle through all subsets
$S'$ of $S$ with $|S'|= \nf{|S|}2 = \nf{n}4$. Given such a subset $S'$
of $S$, we send requests which cycle through the points in $S'$ for
$L$ times, where $L$ is large enough.

One fractional solution for such a sequence is defined as follows: we
assign $\nf12$ unit of weight-$W$ server at each of the $n$
locations. During the phase for a subset $S$, we assign $\nf12$ unit
of server of unit weight at each of the locations in $S$. The cost of
the fractional solution is at most
$Z := {n \choose n/2} \cdot \nf{n}4$ (not accounting for the initial
movement of the servers). However, an integral solution either moves
at least one heavy server, or else pays at least $L$ during one of the
phases, thereby must pay at least $\min(W, L)$. Assuming $W, L \gg Z$
gives an arbitrarily large integrality gap. (We can account for the
initial movement of the fractional servers by repeating the process
some $M$ times: the integral solution would pay at least $\min(W,L)$
in each such iteration and the fractional solution would pay at most
$Z$, so that the initial movement cost would get amortized away.)

\textbf{The Instance for $\ell$ Classes.}
We extend this construction to larger values of $\ell$ by defining
phases in a recursive manner on a nested sequence of subsets of $V$,
with each phase containing several repetitions of the same
sequence. Instead of decreasing by a factor 2, the number of servers
of each weight class now goes down by a factor of $C \geq \ell$. This
allows the integrality gap result to hold even when the integral
solution is allowed a resource augmentation of nearly $\ell$.

For some $r \leq \ell-1$, we call a tuple $(S_0, \ldots, S_r)$
\emph{valid} if (i)~$S_0 = V$ and each $S_j \sse S_{j-1}$, and
(ii)~$|S_j| = |S_{j-1}|/C = \nf{n}{C^j}$.
The request sequence is generated by calling \Cref{fig:proc} with the
trivial valid sequence $(S_0 = V)$. Given a valid tuple
$(S_0, \ldots, S_r)$, the procedure cycles through all subsets
$S \sse S_r$ of size $|S_r|/C$ and recursively calls
$\Gen(S_0, \ldots, S_r, S)$; this process is repeated $L_r$
times. Finally, in the base case when $r = \ell-1$, it cycles through
all the locations in $S_\ell$ for $L_{\ell-1}$ times.
For a suitably large choice of $M$, we define for each $r \in [\ell]$:
\begin{align} 
\label{eq:defWL}
  L_r := M^{r} \qquad \text{and} \qquad W_r := M^{\ell-r}.
\end{align}
Finally, the number of servers of weight $W_r$ is given by
$k_r := \frac{n}{\ell C^{r-1}}$.

\begin{algorithm}[H]
  \caption{Procedure $\Gen(S_0, S_1, \ldots, S_r)$. }
  \label{fig:proc}
  {\bf Input:} A valid tuple $(S_0, S_1, \ldots, S_r)$ \;
  \Repeat{$L_r$ iterations have occurred}{
    \label{l:repeat}
    \If{$r$ is equal to $\ell-1$}{
      Send a request at each location in $S_{\ell-1}$. \label{l:req} \;}
    \Else{
      \For{each subset $S$ of $S_r$ with $|S| = \frac{|S_r|}{C}$}{
        {\color{gray}// Move $\nf1\ell$ mass of servers of weight
        $W_{r+2}$ to $S$} \label{l:move}\;
        Call $\Gen(S_0, \ldots, S_r, S)$. \label{l:rec} \;
      }
    }
    \label{l:until}
  }
\end{algorithm}

\subsection{Analyzing the Integrality Gap}

We bound the cost of the optimal fractional solution for the above input sequence. 

\begin{lemma}
  \label{lem:fractionalcost}
  There is a fractional solution of total cost $O(f(n) M^{\ell-2})$
  for the input sequence constructed by~\Cref{fig:proc}, where $f(n)$
  is a function solely of $n$.
\end{lemma}
\begin{proof}
  Our fractional solution maintains the invariant: when the procedure
  $\Gen(S_0, \ldots, S_r)$ is called, we have $\nf1\ell$ fractional
  mass of servers of weight $W_1, \ldots, W_{r+1}$ respectively at
  each location in $S_r$. For the base case $r=0$, we place $\nf1\ell$
  server mass at each location in $S_0 = V$; recall that
  $k_1 = \nf{n}\ell$. For the inductive step, suppose this invariant
  is satisfied for a certain value of $r$ where $0 \leq r < \ell-1$;
  we need to show that it is satisfied for $r+1$ as well. Indeed, the
  induction hypothesis implies that we have $\nf1\ell$ amount of
  server mass of weight $W_1, \ldots, W_{r+1}$ at each location in
  $S_r$, and hence at each location in $S_{r+1}$.  Moreover, as
  line~\ref{l:move} indicates, we move $\nf1\ell$ fractional mass of
  servers of weight $W_{r+2}$ to each location in $S_{r+1}$ to satisfy
  the invariant condition.  This costs $W_{r+2} \, k_{r+2}/\ell$;
  moreover, this is feasible because the total number of servers of
  weight $W_{r+2}$ needed is
  $\frac{|S_{r+1}|}{\ell} = \frac{n}{\ell C^{r+1}} = k_{r+2}$.
  Finally, when $r=\ell-1$, the invariant shows that $1$ unit of
  server mass is present at each of the locations in $S_\ell$, and
  hence the requests generated in line~\ref{l:req} can be served
  without any additional movement of servers.

  We now account for the movement cost. The total server movement cost
  during $\Gen(S_0, \ldots, S_r)$ (not counting the movement costs in
  the recursive calls) is at most
  $O(L_r \, k_{r+1}\, W_{r+2}) = O(k_{r+1} \, M^{\ell-2})$.  Since
  $k_{r+1} \leq n$ and the number of calls to $\Gen$ is a function
  only of $n$, the overall movement cost can be expressed as
  $O(f(n) \cdot M^{\ell-2})$. (Again, by repeating the entire process
  multiple times we can amortize away the initial movement cost; we
  avoid this step for the sake of clarity.)
\end{proof}

The next lemma shows that any integral solution must have much higher
cost.

\begin{restatable}{lemma}{Integrality}
  \label{lem:integralcost}
  Let $\varepsilon > 0$ be a small enough constant. Assume that the
  integral solution is allowed $(\ell-\varepsilon) k_r$ servers of
  weight $W_r$ for each $r \in [\ell]$.  Any integral solution for the
  input sequence generated by~\Cref{fig:proc} (with
  $C = \nicefrac{\ell}{\varepsilon}$) has movement cost at least
  $M^{\ell-1}.$
\end{restatable}
\begin{proof}%[Proof of \Cref{lem:integralcost}]
  We prove the following more general statement by reverse induction
  on $r$: any integral solution for the sequence generated by
  $\Gen(S_0, \ldots, S_r)$ for a valid tuple $(S_0, \ldots, S_r)$
  which does not use any server of weight class $W_1, \ldots, W_r$ (at
  any location in $S_r$) has cost at least $M^{\ell-1}$. It suffices
  to prove this statement, because the case when $r=0$ implies the
  lemma.

  Consider the base case when $r=\ell-1$. Consider the sequence
  generated by such a procedure $\Gen(S_0, \ldots, S_r)$ such that no
  server of weight $W_1, \ldots, W_{\ell-1}$ is used for serving the
  requests at $S_{\ell-1}$.  Thus all requests generated by this
  procedure must be served by servers of weight $W_{\ell}$. Now,
  $|S_{\ell-1}| = \frac{n}{C^{\ell-1}}$, whereas the number of weight
  $W_{\ell}$ servers available to the algorithm is
  $(\ell-\varepsilon) k_\ell < \frac{n}{C^{\ell-1}}.$ Therefore,
  during each iteration of the {\bf repeat}-{\bf until} loop in
  lines~\ref{l:repeat}--\ref{l:until} in~\Cref{fig:proc}, at least one
  server of weight $W_\ell$ must move. So the overall movement cost
  during this input sub-sequence is at least
  $W_{\ell} \cdot L_{\ell-1} = M^{\ell-1}$. This proves the base case.

  The inductive case is proved in an analogous manner. Suppose the
  statement is true for $r+1$, and now consider the sub-sequence
  generated by $Gen(S_0, \ldots, S_r)$ for some valid tuple
  $(S_0, \ldots, S_r)$. Assume that no server of weight
  $W_1, \ldots, W_r$ is present at any node in $S_r$ during this
  time. We claim that the algorithm must incur movement cost of at
  least $W_{r+1}$ during each iteration of the {\bf repeat}-{\bf
    until} loop. Indeed, fix such an iteration. Two cases arise: (a)
  The algorithm moves a server of weight $W_{r+1}$ then the claim
  follows trivially, or (b) No server of weight $W_{r+1}$ is moved
  during this period. Now observe that $|S_r| = \frac{n}{C^r}$, and
  the number of weight $W_{r+1}$ servers available to the algorithm is
  $(\ell-\varepsilon) k_{r+1} = |S_r| - \varepsilon k_{r+1} = |S_r|
  \left(1 - \frac{1}{C} \right). $ Thus, there is a subset $S_{r+1}$
  of $S$ of size $\frac{|S_r|}{C} = \frac{n}{C^{r+1}}$ where no server
  of weight $W_{r+1}$ appears during this input sub-sequence. Consider
  the recursive call $\Gen(S_0, \ldots, S_r, S_{r+1})$ in
  line~\ref{l:rec}. The induction hypothesis implies that the movement
  cost during this recursive call is at least
  $M^{\ell-1} \geq W_{r+1}$.

  Thus, we have shown that the movement cost during each iteration of
  the {\bf repeat}-{\bf until} loop during $\Gen(S_0, \ldots, S_r)$ is
  at least $W_{r+1}$. Since there are $L_r$ such iterations, the
  overall movement cost is at least $W_{r+1} \cdot L_r = M^{\ell-1}.$
  This completes the proof of the induction hypothesis, and implies
  the lemma.
\end{proof}


%We defer the proof to \Cref{sec:appendixintegrality}; 
Combining \Cref{lem:fractionalcost} and \Cref{lem:integralcost} proves
\Cref{thm:int}.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
