\section{CPS Transformation} \label{sec:cps}

\subsection{Definitions and Properties} \label{sec:cps/def}

This section presents the crux of our CPS transformation that translate the
language defined in Section~\ref{sec:language} to a $\lambda$-calculus without
effect handlers.
%
Readers interested in the complete definitions of the target language and the
CPS transformation are referred to the supplementary material.

% Figure environment removed

The target language of the CPS transformation is a polymorphic
$\lambda$-calculus with records and recursion.
Its program and type syntax are defined as follows:
%
\[\begin{array}{rcl}
 v &::=& x \mid p \mid \exprec{f:\tau_1}{x:\tau_2}{c} \mid \Lambda \rep{X: \rep{B}}. c \mid \{ \repi{\op_i = v_i} \} \mid \Lambda \alpha. c \\
 c &::=& v \mid c~v \mid \expif{v}{c_1}{c_2} \mid c~\rep{A} \mid v\#\op \mid c~\tau \mid (c : \tau) \\
 \tau &::=& \tyrfn{x}{B}{\phi} \mid (x: \tau_1) \rarr \tau_2 \mid \forall \rep{X: \rep{B}}. \tau
        \mid \{ \repi{\op_i : \tau_i} \} \mid \alpha \mid \forall \alpha. \tau
  \end{array}
\]
%
In the target language, values are not strictly separated from computations as
those in the source language; for example, functions in function applications
can be computations.
%
The metavariables $\alpha$ and $\beta$ range over type variables.  Expressions
$\Lambda \alpha. c$ and $c~\tau$ are a type abstraction and application,
respectively.
%
Type polymorphism is introduced to express the pure control effect in the target
language using \emph{answer type polymorphism}~\cite{Thielecke03}.
%
Expressions $\{ \repi{\op_i = v_i} \}$ and $v\#\op$ are a record literal and
projection, respectively.
%
We use operation names as record labels for the target language to encode
handlers using records.
%
Our CPS transformation produces programs with type annotations for proving
bidirectional type-preservation. Recursive functions with type annotations and
type ascriptions $(c : \tau)$ are used to annotate programs.
%
We abbreviate $\exprec{f:T_1}{x:T_2}{c}$ to $\lambda x: T_2. c$ if $f$ does not
occur in $c$.
%
Types are defined in a standard manner.
%
Typing contexts $\Gamma$ are extended to include type variables.
%
The operational semantics is almost standard.
%
Figure~\ref{fig:cps-target-excerpt} shows four evaluation rules.
%
Type ascriptions simply drop the ascribed type $\tau$.
%
Type applications substitute a given type $\tau$ for the bound type variable $\alpha$.
%
Predicate applications are similar.
%
Record projections with $\op_i$ extract the associated field $v_i$.
%
The type
system is also standard,
presented in Figure~\ref{fig:cps-target-excerpt}.  We write $\jdwf{\Gamma}{\tau}$ to
state that all the free variables (including type and predicate ones) in
the type $\tau$ are bound in the typing context $\Gamma$.
%
The subtyping for record types allows supertypes to forget some fields in
subtypes, and the types of each corresponding field in two record types to be in
the subtyping relation (we deem record types, as well as records, to be
equivalent up to permutation of fields).
%
The subtyping rule for type polymorphism is a weaker variant of the containment
rule for polymorphic types~\cite{Mitchell88}.
%
It is introduced to emulate \rulename{S-Embed} in the target language.

% Figure environment removed

We show the key part of the CPS transformation in
Figure~\ref{fig:cps-trans-excerpt}.
%
The upper half presents the transformation of types.
%
The transformation of value types is straightforward.  Operation signatures are
transformed into record types, which means that operation clauses in a handler
are transformed into a record.
%
The transformations of computation types indicate that computations are
transformed into functions that receive two value parameters: handlers and
continuations.
%
If the control effect is pure, the answer types of computations become
polymorphic in CPS.
%
This treatment of control effects is different from that of \citet{Materzok11},
who define CPS transformation for control effects in the
simply typed setting.
%
Their CPS transformation transforms, in our notation,
%
a computation type $\tycompMB{T}{\square}$ into the type $\cps{T}$, and
%
a type $\tycompMB{T}{\tyctlMB{C_1}{C_2}}$ into the type $\tyfunshort{(\tyfunshort{\cps{T}}{\cps{C_1}})}{\cps{C_2}}$ (note that they address neither operation signatures nor dependent typing).
%
Because the latter takes continuations whereas the former does not, CPS
transformation needs to know where pure computations are converted into impure
ones (via subtyping).
%
To address this issue, Materzok and Biernacki's CPS transformation focuses on
typing derivations in the source language rather than expressions.
%
However, because our aim is at reducing the typing of programs with
algebraic effects and handlers to that of programs without them,
we cannot assume typing derivations in the source language to be available.
%
By treating two kinds of control effects uniformly using answer type
polymorphism, our CPS transformation can focus only on expressions (with type
annotations).

The lower half of Figure~\ref{fig:cps-trans-excerpt} shows the key cases of the
transformation of expressions.
%
We separate abstractions and applications in the target language
into \emph{static} and \emph{dynamic} ones, as in the work of \citet{Hillerstrom17},
for proving the preservation of the operational semantics
(Theorem~\ref{thm:cps-sim}).
%
Redexes represented by static applications are known as \emph{administrative redexes}, inserted and reduced at compile (CPS-transformed) time.
By contrast, redexes represented by dynamic applications are reduced at run time because they originate in the source program.
%
Constructors for static expressions are denoted by the overline notation,
like $\stlambda$, $\stLambda$, and $\stapp$.
%
We use the ``at'' symbol explicitly as an infix operator of static applications
for clarification.
%
Non-overlined abstractions and applications are dynamic ones,
which are treated as ordinary expressions.
%
Also, for backward type-preservation (Theorem~\ref{thm:cps-backward-excerpt}), we
extend the source language with type annotations.
%
For example, in an operation call $(\op^{\rep{\mathit{A}}}~v)^{\tycomp{\Sigma}{T}{\tyctl{y}{C_1}{C_2}}}$,
$\rep{\mathit{A}}$ are predicates used to instantiate the type scheme of the operation $\op$,
and
$\tycomp{\Sigma}{T}{\tyctl{y}{C_1}{C_2}}$ is the type of the operation call $\op~v$.
%
Without type annotations, CPS-transformed expressions may have a type that
cannot be transformed back to a type in the source language.
%
An operation call $(\op^{\rep{\mathit{A}}}~v)^{\tycomp{\Sigma}{T}{\tyctl{y}{C_1}{C_2}}}$
is transformed into a function that seeks the corresponding
operation clause in a given handler and then applies it to a given sequence of
predicates, argument, and continuation.
%
Note that the continuation is in the $\eta$-expanded form
because, for the preservation of the operational semantics,
we need a dynamic lambda abstraction that corresponds to the continuation $\expfun{y}{\expwith{h}{K[\expret{y}]}}$
introduced in the rule \rulename{E-HndlOp} of the source language.
%
An expression $\expwith{h}{c}$ is transformed into a function that applies the
CPS-transformed handled computation to the record of the CPS-transformed
operation clauses and the CPS-transformed return clause (because the return
clause works as the continuation of $c$).
%
The transformation preserves operational semantics bidirectionally in the following way:
%
\newcommand{\stappTop}{\stapp \tau \stapp \{\} \stapp (\lambda x: \tau. x)}
\begin{theorem}[simulation] \label{thm:cps-sim}
    Let $\equiv_\beta$ be the smallest congruence relation over expressions in the target language that satisfies $(\stlambda x: \tau. c) \stapp v \equiv_\beta c[v/x]$ and $(\stLambda \alpha. c) \stapp \tau \equiv_\beta c[\tau/\alpha]$.
    If\, $c \eval^* \expret{v}$, then
    $\cps{c} \stappTop \eval^+ v'$ for some $v'$ such that $\cps{v} \equiv_\beta v'$.
    Also, if\, $\cps{c} \stappTop \eval^+ v'$, then
    $c \eval^* \expret{v}$ and $\cps{v} \equiv_\beta v'$ for some $v$.
\end{theorem}
%
\noindent
(Note that $\tau$ can be any type since types are irrelevant to the operational semantics.)
The first half states that
if a computation $c$ in the source language evaluates to a value-return of $v$,
the transformed computation $\cps{c}$ applied to a type, an empty handler $\{\}$,
and a trivial continuation $\lambda x: \tau. x$ evaluates to the transformed value $\cps{v}$.
%
Similarly, the second half states the reverse direction.

Now, we state forward and backward type-preservation of the CPS transformation.
%
\begin{theorem}[Forward type-preservation] \label{thm:cps-forward-excerpt}
    The following holds:
    % \hspace*{10pt}
    % \begin{itemize}
        (1) If\, $\jdty{\Gamma}{v}{T}$ then $\jdty{\cps{\Gamma}}{\cps{v}}{\cps{T}}$.
        (2) If\, $\jdty{\Gamma}{c}{C}$ then $\jdty{\cps{\Gamma}}{\cps{c}}{\cps{C}}$.
    % \end{itemize}
\end{theorem}

\begin{theorem}[Backward type-preservation] \label{thm:cps-backward-excerpt}
    The following holds:
    % \hspace*{10pt}
    % \begin{itemize}
     (1) If\, $\jdty{\emptyset}{\cps{v}}{\tau}$, then
           there exists some $T$ such that
           $\jdty{\emptyset}{v}{T}$ and
           $\jdsub{\emptyset}{\cps{T}}{\tau}$.
     (2) If\, $\jdty{\emptyset}{\cps{c}}{\tau}$, then
           there exists some $C$ such that
           $\jdty{\emptyset}{c}{C}$ and
           $\jdsub{\emptyset}{\cps{C}}{\tau}$.
    % \end{itemize}
\end{theorem}
%
\noindent
Theorem~\ref{thm:cps-backward-excerpt} is implied immediately by backward type
preservation of the CPS transformation for \emph{open} expressions.
See the supplementary material for the statement for open expressions.
%
Theorem~\ref{thm:cps-backward-excerpt} indicates that it is possible to reduce
typechecking in our source language to that in a language without effect
handlers.
%
That is, if ones want to verify whether an expression $c$ has type $C$,
they can obtain the same result as the direct verification
by first applying CPS transformation to $c$ and $C$, and
then checking whether $\cps{c}$ has type $\cps{C}$
with a refinement type verification tool that does not support algebraic effect handlers.

Type annotations in the source language are necessary to restrict the image of the transformation.
Without them, a CPS-transformed program may be of a type $\tau$ that cannot be transformed to a type in the source language inversely (i.e., there exists no type $C$ in the source language satisfying $\cps{C} = \tau$).
For example, consider $\stLambda \alpha. \stlambda h. \stlambda k. k~0$,
the CPS form (without annotations) of expression $\expret{0}$.
Without annotations, we can pick arbitrary types as the type of $h$.
Therefore, it can have type
$\forall \alpha. \tybool \rarr (\tyint \rarr \alpha) \rarr \alpha$.
%
However, there is no type $C$ in the source language such that $\cps{C} = \forall \alpha. \tybool \rarr (\tyint \rarr \alpha) \rarr \alpha$.
Even worse, the source language has no type that is a \emph{subtype} of the type of the CPS form
since $\tybool$ and record types are incomparable with each other.
Another example is $\lambda x. \stLambda \alpha. \stlambda h. \stlambda k. k~x$,
the CPS form (again, without annotations) of expression $\lambda x. \expret{x}$.
Its type can be
$(\tyint \rarr \tyint) \rarr \forall \alpha. \{\} \rarr ((\tyint \rarr \tyint) \rarr \alpha) \rarr \alpha$,
that is, $x$ can be of type $\tyint \rarr \tyint$.
However, there is no value type $T$ in the source language
such that $\cps{T}$ is a subtype of $\tyint \rarr \tyint$.
Note that since a function type in the source language is in the form $(x: T_x) \rarr C$,
the right hand side of the arrow in the CPS-transformed function type must be in the form
$\forall \alpha. \{ \cdots \} \rarr \cdots$, which does not match with $\tyint$.
%
Therefore, without type annotations, Theorem~\ref{thm:cps-backward-excerpt} does not hold.

\newcommand{\er}{\mathit{er}}

While our formalization requires concrete refinement type annotations in the source language,
actually we can relax this restriction
by using predicate variables as placeholders instead of concrete refinements in type annotations.
This is because type annotations are only
for prohibiting occurrences of types with unintended \emph{structures}, not for restricting refinements.
Those predicate variables are instantiated after CPS transformation
with concrete predicates inferred by generating and solving CHC constraints
that contain these predicate variables from the CPS-transformed expression.
%
Formally, by allowing occurrences of predicate variables
in type annotations of both the source and target language,
and introducing predicate variable substitution $\sigma$,
we can state that $\cps{\sigma(c)} = \sigma(\cps{c})$.
This means that,
for an expression $c$ that is annotated with types containing predicate variables,
both of the followings result in the same expression:
(1) first instantiating the predicate variables in $c$ with concrete refinements,
and then CPS-transforming it (i.e., CPS-transforming the concretely-annotated expression),
and
(2) first CPS-transforming $c$,
and then instantiating the predicate variables in the CPS-transformed expression
with the concrete refinements.
In other words, concrete refinements are irrelevant to the CPS transformation.
This irrelevance is ensured by the fact that
refinements can depend only on first-order values because it means that handler variables $h$ and continuation variables $k$,
which occur only in CPS-transformed expressions, cannot be used in instantiated refinements.
% }
The reason why we have defined the CPS transformation with concrete refinements
is just to state Theorem~\ref{thm:cps-forward-excerpt} and Theorem~\ref{thm:cps-backward-excerpt}.

\subsection{Comparison between the Direct Verification and the Indirect Verification} \label{sec:cps/comparison}

In this section, we compare the direct verification using our refinement system
presented in Section~\ref{sec:language}
with the indirect verification via the CPS transformation presented above.
One of the differences is that the direct verification requires
special support of verification tools for algebraic effect handlers,
while the indirect one can be done by existing tools without such support.
On the other hand, the indirect verification has some disadvantages.
%
First, in most cases, CPS-transformed programs tend to be complicated and be in
the forms quite different from the source programs.  This complexity incurred in
the indirect typechecking may lead to confusing error messages when the
typechecking fails.
Transforming the inferred complex types back to the types of the source language would be helpful,
but it is unclear whether we can do this
because the inferred types of the CPS-transformed expressions do not necessarily correspond to
the CPS-transformed types of the source expressions,
as stated in Section~\ref{sec:cps/def}.
By contrast, because the direct typechecking deals with the
structures of the source programs as they are, error messages can be made more
user-friendly.
%
Second, our CPS transformation needs a non-negligible amount of type
annotations---type annotations are necessary in let-expressions, conditional
branches, and recursive functions as well as operation calls and handling
constructs.  In practice, it is desired to infer as many types as possible.
However, it seems quite challenging to define a CPS transformation that
enjoys backward type-preservation and needs no, or few, type annotations.
One of the possible approaches for addressing type annotations in more automated way is
to use the underlying simple type system of our refinement type system
for algebraic effect handlers.
As mentioned in Section~\ref{sec:cps/def},
concrete refinements are not necessary for type annotations.
Therefore, we can generate type annotations for an expression
using its simple type inferred by the underlying type system.

We also compare these two approaches based on an experiment.
We used some direct style (DS) programs
(i.e., programs using algebraic effect handlers),
and for each program, we applied our CPS transformation manually
and ran the verification on both DS one and CPS one.
Additionally, we also compared them with optimized CPS programs
where administrative redexes were reduced.
We used the same implementation as the one in Section~\ref{sec:impl} with the configuration of \textsc{Spacer}.
We added annotations of source programs to only top-level, closed first-order expressions,
but the correctness of the verification can be justified by the preservation of dynamic semantics.

\begin{wraptable}[11]{R}{0.6\textwidth}
    \setlength{\arraycolsep}{2pt}
    \vspace*{-1.8ex}
    \caption{Evaluation results of CPS transformation}
    \label{tab:cps}
    \begin{tabular}{lcrcrcr}
        \toprule
        \multirow[c]{2}{*}{program} & \multicolumn{2}{c}{DS} & \multicolumn{2}{c}{CPS} & \multicolumn{2}{c}{CPS (opt)} \\
        & \checkmark? & time & \checkmark? & time & \checkmark? & time \\
        \midrule
        \texttt{amb-2} &Yes & 1.30 & Yes & 1.32 & Yes & 0.91 \\
        \texttt{choose-easy} &Yes & 0.26 & Yes & 0.27 & Yes & 0.22 \\
        \texttt{choose-sum} &Yes & 2.18 & Yes & 1.79 & Yes & 12.87 \\
        \texttt{io-read-2} &Yes & 0.66 & No & 1.29 & No & 0.62 \\
        \texttt{simple} &Yes & 0.11 & Yes & 0.16 & Yes & 0.14 \\
        \bottomrule
    \end{tabular}
\end{wraptable}

Table~\ref{tab:cps} shows the results of the experiment.
The columns ``\checkmark?'' show whether the verification result is correct.
The columns ``time'' are in seconds.
Some programs have no big difference in verification time
among the three variants,
but there are two notable things.
First, optimized CPS version of \texttt{choose-sum} took more time than the other versions.
This seems because the size of the program became larger by the optimization.
The CPS \texttt{choose-sum} program contains some branching expressions
and each branch uses variables representing its continuation and the outer handler.
By reducing administrative redexes in the program, these variables are instantiated
with a concrete continuation and handler,
that is, the continuation and handler are copied to each branch,
which results in larger size of the program and its constraints generated during the verification.
Second, CPS version of \texttt{io-read-2} could not be verified correctly.
One possible reason is lack of support for higher-order predicate polymorphism.
Since CPS programs explicitly pass around continuations,
their types tend to be higher-order.
Then, in some cases, higher-order predicate polymorphism becomes necessary by CPS transformation.

\endinput
