\section{Overview} \label{sec:overview}

We briefly overview algebraic effects and handlers, ATM, and ARM.

\subsection{Algebraic Effects and Handlers} \label{sec:overview/algeff}

\newcommand{\rmmax}{\mathrm{max}}

Algebraic effects and handlers enable users to define their own effects in a
modular way.  The modularity stems from separating the use of effects from their
implementations: effects are performed via {\em operations} and implemented via
{\em effect handlers} (or handlers for short).  For example, consider the
following program where $h_{\op[d]} \defeq \{ x_r \mapsto x_r, \ 
\op[decide](x, k) \mapsto \rmmax~(k~\exptrue)~(k~\expfalse) \}$:
%
\begin{align}
    \expwith{
		h_{\op[d]}
	}{
        \explet{a}{\expif{\op[decide]~()}{10}{20}}{
            \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                a - b
            }
        }
    }
\end{align}
%
It calls an operation $\op[decide]$, which takes
the unit value $()$ and returns a Boolean value, to choose one of two integer
values and then calculates the difference between the chosen values.
%
Because operation calls invoke effects in algebraic effects, the operations work as interfaces of the effects.

An implementation of an effect is given by an effect handler.
%
The program installs the handler $h_{\op[d]}$ for $\op[decide]$ using the
handling construct.  In general, a handling construct takes the form
$\expwith{h}{e}$, which means that a handler $h$ defines interpretations of
operations performed during the evaluation of the expression $e$; we call the
expression $e$ a \emph{handled expression}.
%
A handler consists of a single \emph{return clause} and zero or more
\emph{operation clauses}.
%
A return clause takes the form $x_r \mapsto e_r$, which determines the value of
the handling construct by evaluating expression $e_r$ with variable $x_r$
that denotes the value of the handled expression.
%
In the example, because the return clause is $x_r \mapsto x_r$, the handling
construct simply returns the value of the handled expression.
%
An operation clause takes the form $\op[op](x, k) \mapsto e$. It defines the
interpretation of the operation $\op[op]$ to be expression $e$ with variable $x$
that denotes the arguments to the operation. When the handled expression calls
the operation $\op[op]$, the remaining computation up to the handling construct
is suspended and instead the body $e$ of the operation clause evaluates.
Therefore, effect handlers behave like exception handlers by regarding operation
calls as raising exceptions.  However, effect handlers are equipped with the
additional ability to resume the suspended computation.
%
The suspended remaining computation, called a \emph{delimited
continuation}, is functionalized, and the body $e$ of the operation clause can
refer to it via the variable $k$.

Let us take a closer look at the behavior of the above example.
%
Because the handled expression starts with the call to $\op[decide]$,
the operation clause for $\op[decide]$ given by $h_{\op[d]}$ evaluates.
%
The delimited continuation $K$ of the first call to $\op[decide]$ is
\[
 \expwith{ h_{\op[d]} }{
        (\explet{a}{\expif{\hole}{10}{20}}{
            \; \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                \; a - b
            }
        })
    }
\]
%
where $\hole$ denotes the hole of the continuation.
%
We write $K[e]$ for the expression obtained by filling the hole in $K$ with expression $e$.
%
Then, the functional representation of the delimited continuation $K$ takes the
form $\lambda y. K[y]$, and it is substituted for $k$ in the body of the
operation clause.
%
Namely, the handling construct evaluates to $\rmmax~(v~\exptrue)~(v~\expfalse)$
where $v = \lambda y. K[y]$.
%
Note that the variable $x$ of the operation clause for $\op[decide]$ is replaced
by the unit value $()$, but it is not referenced.
%
The first argument $v~\exptrue$ to $\rmmax$
reduces to $K[\exptrue]$, that is,
\[
    \expwith{ h_{\op[d]} }{
        (\explet{a}{\expif{\colorbox{gray!50}{$\exptrue$}}{10}{20}}{
            \explet{b}{\expif{\op[decide]~()}{1}{2}}{
              \; a - b
            }
        })
    }
\]
%
(the grayed part represents the value by which the hole in $K$ is replaced).
%
Therefore, the expression $v~\exptrue$ evaluates to
$
    \expwith{ h_{\op[d]} }{
        (
            \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                10 - b
            }
        )
    }
$~.
%
Again, $\op[decide]$ is called and the continuation
$
    K' \defeq \expwith{ h_{\op[d]} }{
		(\explet{b}{\expif{\hole}{1}{2}}{
			10 - b
		})
	}
$
is captured.
%
Then, the operation clause for $\op[decide]$ evaluates
after substituting $\lambda y. K'[y]$ for $k$.
%
The expression $(\lambda y. K'[y])~\exptrue$
evaluates to $K'[\exptrue]$, that is,
$
 \expwith{ h_{\op[d]} }{
    (\explet{b}{\expif{\colorbox{gray!50}{$\exptrue$}}{1}{2}}{10 - b})
 }
$
and then to
$
 \expwith{ h_{\op[d]} }{ 9 }
$~.
%
Here, the handled expression is a value.  Therefore, the return clause in the
handler evaluates after substituting the value $9$ for variable $x_r$. Because
the return clause in $h_{\op[d]}$ just returns $x_r$, the evaluation of
$(\lambda y. K'[y])~\exptrue$ results in $9$. Similarly, $(\lambda
y. K'[y])~\expfalse$ evaluates to $8$ (which is the result of binding $b$ to
$2$). Therefore, $\rmmax~((\lambda y. K'[y])~\exptrue)~((\lambda
y. K'[y])~\expfalse)$ evaluates to $\rmmax~9~8$ and then to $9$. In
a similar way, $v~\expfalse$ calculates $\rmmax~(20-1)~(20-2)$, that is,
evaluates to $19$, because $a$ is bound to $20$ and $b$ is bound to each of $1$
and $2$ depending on the result of the second invocation of $\op[decide]$.
%
Finally, the entire program evaluates to $19$, which is the result of
$\rmmax~(v~\exptrue)~(v~\expfalse)$, that is, $\rmmax~9~19$.

\subsection{Answer Type Modification and Answer Refinement Modification} \label{sec:overview/atm}

An \emph{answer type} is the type of the closest enclosing delimiter,
or the return type of a delimited continuation.
In the setting of algebraic effects and handlers,
delimiters are handling constructs.
For example, consider the following expression:
\begin{align}
 &\explet{x}{
		\expwith{
			\{ x_r \mapsto x_r, \ 
         \op((), k) \mapsto k~0 < k~1 \}
		}{1 + \op~()}
	}{c} ~.
\end{align}
The delimited continuation of $\op~()$ is
$
    K'' \defeq
	\expwith{
		\{ x_r \mapsto x_r, \ 
			\op((), k) \mapsto k~0 < k~1 \}
	}{1 + \hole}
$~.
At first glance, the answer type of $\op~()$ seems to be the integer type $\tyint$
since the handled computation in the continuation returns the integer $1+n$ for an integer $n$ given to fill the hole, and the return clause returns given values as they are.
In other words, from the perspective of $\op~()$,
the handling construct seems to give an integer value to the outer context $\explet{x}{\hole}{c}$.
However, after the operation call, the entire expression evaluates to
$
	\explet{x}{
		v''~0 < v''~1
	}{c}
$ where $v'' \defeq \lambda y. K''[y]$.
Now the handling construct becomes the expression $v''~0 < v''~1$, which gives a Boolean value to the outer context.
That is, the answer type changes to the Boolean type $\tybool$.
\emph{Answer type modification} (ATM) is a mechanism to track this dynamic change on answer types.

ATM is not supported in existing type systems for effect handlers~\cite{Plotkin13,Brady13,Bauer13,Kammar13,Bauer15,Leijen17,Lindley17}, with the exception of the one recently proposed by \citet{Cong22} (see Section~\ref{sec:related} for comparison with their work).
Such type systems require the answer types before and after an operation call to be unified (and so the example above will be rejected as ill-typed).
Nonetheless, useful programming with effect handlers is still possible without ATM (which is why they are implemented in popular languages like OCaml without ATM).\footnote{One could also argue that the absence of ATM is natural for algebraic effects and handlers because they are designed after concepts from universal algebra~\cite{DBLP:conf/fossacs/PlotkinP01,DBLP:journals/corr/abs-1807-05923}, and there, (algebraic) operations are usually expected to preserve types.}
For instance,
the program in Section~\ref{sec:overview/algeff} is well-typed
in existing (non-refinement) type systems for algebraic effects and handlers without ATM,
since the return type of the continuation $k$ in the $\op[decide]$ clause
(i.e., the answer type before the execution) is $\tyint$
and the return type of the $\op[decide]$ clause
(i.e., the answer type after the execution) is also $\tyint$.

However, even if answer types are not modified,
{\em actual values returned by delimited continuations usually change}.
Let us see the program in Section~\ref{sec:overview/algeff} again.
Focus on the first call to $\op[decide]$.
When this is called, the operation clause receives the continuation $v = \lambda y. K[y]$,
which returns $9$ if applied to $\exptrue$ and returns $19$ if applied to $\expfalse$,
as described previously.
Therefore, $v$ can be assigned the refinement type
$(y: \tybool) \rarr \tyrfn{z}{\tyint}{z = (\ternaryif{y}{9}{19})}$,
and thus the precise answer type before the execution is
$\tyrfn{z}{\tyint}{z = (\ternaryif{y}{9}{19})}$
where $y$ is the Boolean value passed to the continuation.
On the other hand, the clause for $\op[decide]$
returns integer $19$. Thus, the precise answer type after the operation call is $\tyrfn{z}{\tyint}{z = 19}$.
Now the refinement in the answer type becomes different before and after the operation call.
The same phenomenon happens in the second call to $\op[decide]$.
When the second call evaluates, the handler receives the continuation $\lambda y. K'[y]$.
It returns $a - 1$ if applied to $\exptrue$ and returns $a - 2$ if applied to $\expfalse$
(where $a$ is either $10$ or $20$ depending on the result of the first call to $\op[decide]$).
Thus, the answer type before the execution is $\tyrfn{z}{\tyint}{z = (\ternaryif{y}{a - 1}{a - 2})}$.
In contrast, the return value of the clause for $\op[decide]$ is $\rmmax~(a - 1)~(a - 2) = a - 1$,
so the answer type after the execution is $\tyrfn{z}{\tyint}{z = a - 1}$.
Here again, the refinement in the answer type changed by the operation call.
We call this change \emph{answer refinement modification} (ARM). Armed with ARM (pun intened), the refinement type system that we propose in this paper is able to assign the precise refinement type $\tyrfn{z}{\tyint}{z = 19}$ to the program, and more generally, the type $\tyrfn{z}{\tyint}{z = v - x}$ when the constants $10$, $20$, $1$, and $2$ are replaced by variables $u$, $v$, $x$, and $y$ respectively with the assumption $u \leq v \wedge x \leq y$ (such an assumption on free variables can be given by refinement types in the top-level type environment).
%
The example demonstrates that ARM is useful for precisely reasoning about programs with algebraic effects and handlers in refinement type systems.  Indeed, without ARM, the most precise refinement type that a type system could assign to the example would be $\tyrfn{z}{\tyint}{z \in \{8,9,18,19\}}$.

As another illuminating example, we show that ARM provides a new approach to the classic \emph{strong update} problem~\cite{DBLP:conf/pldi/FosterTA02}.  It is well known that algebraic effects and handlers can implement mutable references by operations $\op[set]$ and $\op[get]$, that respectively destructively updates and reads a mutable reference, and a handler that implements the operations by state-passing (see, e.g., \cite{Pretnar15}).
On programs with such a standard implementation of mutable references by algebraic effects and handlers, our refinement type system is able to reason flow-sensitively and derive refinement types that cannot be obtained with ordinary flow-insensitive reasoning.
For instance, consider the following program 
where $h \defeq \{
    x_r \mapsto \lambda s. x_r, \ 
    \op[set](x, k) \mapsto \lambda s.k~()~x, \ 
    \op[get](x, k) \mapsto \lambda s. k~s~s \}$:
\begin{gather}
    (\expwith{h}{
        \ (\op[set]~3;\,
        \explet{n}{\op[get]~()}{
            \op[set]~5;\,
            \explet{m}{\op[get]~()}{
                n + m
            }
        })
    })~0
\end{gather}
Thanks to ARM, our type system can give the program the most precise type $\tyrfn{z}{\tyint}{z = 8}$,
which would not be possible in a type system without ARM as it would conflate the two calls to $\op[set]$ and fail to reason that the first $\op[get]~()$ returns $3$ whereas the second $\op[get]~()$ returns $5$.  Roughly, ARM accomplishes the flow-sensitive reasoning about the changes in the state by tracking changes in the refinements in the answer types, albeit in a \emph{backward} fashion as shown in Section~\ref{sec:language/exmaples}.

%
Using this ability of ARM, we can also verify that effectful operations are used
in a specific order. For example, consider operations $\op[open]$,
$\op[close]$, $\op[read]$, and $\op[write]$ for file manipulation being
implemented using effect handlers.
%
The use of these operations should conform to the regular scheme
$(\op[open] \ (\op[read] \mid \op[write])^\ast \ \op[close])^\ast$.
%
Our refinement type system can check if a program meets this requirement. For instance, consider the
following recursive function:
%
\begin{gather}
 \expfun{x}{~\expwhile{\star}{\op[open]~x;~\expwhile{\star}{\explet{y}{\op[read]()}{\op[write]~(y\texttt{\textasciicircum"X"})}};~\op[close]~()}}
\end{gather}
%
where $\expwhile{\star}{c}$ loops computation $c$ and terminates
nondeterministically, and the binary operation $(\texttt{\textasciicircum})$
concatenates given strings (operation $\op[read]$ is supposed to return a string).\footnote{For simplicity, we assume that the clause of $\op[open]$
creates an object for a specified file and stores it in a reference implemented
by an effect handler, and the clauses of the other operations refer to the stored object to
manipulate the file.}
%
The function repeats opening the specified file $x$ and closing it after reading
from and writing to the file zero or more times.
%
Thus, this function follows the discipline of the file manipulation
operations.
%
We will show in Section~\ref{sec:language/exmaples} how ARM enables us to check
it formally and detect the invalid use of the operations if any.
%
