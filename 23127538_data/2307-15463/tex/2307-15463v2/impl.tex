\section{Implementation} \label{sec:impl}

\subsection{Description of Our Implementation} \label{sec:impl/impl}

In this section, we describe our prototype implementation of
a refinement type checking and inference system, \textsc{RCaml}\footnote{available at \url{https://github.com/hiroshi-unno/coar}}.
It takes a program written in a subset of the OCaml 5 language
(including algebraic data types, pattern matching, recursive functions, exceptions, mutable references\footnote{Strong updates~\cite{DBLP:conf/pldi/FosterTA02} are not supported. \label{footnote:strong-update}},
let-polymorphism, and effect handlers)
and a refinement-type specification for the function of interest.
It first (1) obtains an ML-typed AST of the program
using OCaml's compiler library,
(2) infers refinement-free operation signatures and control effects,
(3) generates refinement constraints for the program and its specification as Constrained Horn Clauses (CHCs) (see e.g., the work of \citet{Bjorner2015a}),
and finally (4) solves these constraints
to verify if the program satisfies the specification.
The steps (3) and (4), where the refinement type checking is reduced to CHC solving,
follow existing standard approaches such as those proposed by \citet{Rondon08} and \citet{Unno09}.
The inference of (refinement-free) operation signatures is similar to
that of record types using row variables,
and is mutually recursive with the inference of control effects.
It is based on the inference
of control effects for shift0/reset0~\cite{Materzok11}.
%
As we split the steps of CHC generation and
solving,
we can use different solvers as the backend CHC solver depending on benchmarks.
In this experiment, we used two kinds of CHC solvers:
\textsc{Spacer}~\cite{Komuravelli13} that is based on Property Directed Reachability (PDR)~\cite{Bradley11,Een11},
and \textsc{PCSat}~\cite{Unno2021} that is based on template-based CEGIS~\cite{Solar-Lezama06,Unno2021} with Z3~\cite{Moura2008} as an SMT solver.

Because inputs to the implementation are OCaml programs
that are type-checked by OCaml's type checker which does not allow ATM,
the underlying OCaml types corresponding to the answer types cannot be modified.
However, as remarked before in Section~\ref{sec:intro}, our aim is to verify \emph{existing} programs with algebraic effects and handlers,
and, as remarked before, our ARM, that allows only modification in the refinements, is useful for that purpose.

Our implementation supports several kinds of polymorphism.
In addition to the standard let-polymorphism on types,
it supports refinement predicate polymorphism.
The implementation extends the formal system by allowing {\em bounded} predicate polymorphism in which abstracted predicates can be bounded by constraints on them, and further allows predicate-polymorphic types to be assigned to let-bound terms.
However, because the implementation can infer predicate-polymorphic types only at let-bindings,
we used a different approach, which we will discuss in Section~\ref{sec:impl/eval},
to simulate predicate polymorphism in operation signatures.

%
Another notable point is that our implementation deals with operations and exceptions uniformly.
That is, exception raising is treated as an operation invocation
and it can be handled by a certain kind of effect handlers which have clauses for exceptions
(the exception clauses are included in the effect handlers of OCaml by default).

\subsection{Evaluation} \label{sec:impl/eval}

We performed a preliminary experiments to evaluate our method
on some benchmark programs that use algebraic effect handlers.
The benchmarks are based on example programs
from \citet{Bauer15} and the repository of the Eff language~\cite{Effrepo}.
We gathered the effect handlers in those examples
and created benchmark programs each of which uses one of the effect handlers.
We also added a refinement type specification of the function of interest to each benchmark.
(Other auxiliary functions are not given such extra information,
and so their types are \emph{inferred automatically} even for recursive functions.)
%
Most benchmarks could be solved automatically without the annotations,
but some need them as hints.
We discuss the details at the end of this section.
%
It is also notable that,
although the examples presented in Section~\ref{sec:language/exmaples} focus on
the specifications specialized in concrete, constant values such as
$\tyrfn{z}{\tyint}{z = 19}$ for Example~1, the benchmarks include programs that demonstrate that our type system and
implementation can address more general specifications.%
%
For instance, the specification for the benchmark \texttt{choose-max-SAT.ml},
which is a general version of Example 1
where the constants 10, 20, 1, and 2 are replaced by
parameters $u$, $v$, $x$, and $y$, respectively, of a function \texttt{main} to be verified,
is as follows:
\[
    \jdty{}{\mathtt{main}}{
        (u: \tyint) \rarr (v: \tyrfnshort{z \t: \tyint}{z \ge u})
        \rarr (x: \tyint) \rarr (y: \tyrfnshort{z \t: \tyint}{z \ge x})
        \rarr \tyrfnshort{z \t: \tyint}{z = v - x}
    }
\]
We refer to the supplementary material
for the source code and the specifications of our benchmarks.
%
All the experiments were conducted on
Intel Xeon Platinum 8360Y, 256~GB RAM.

\begin{table}
    \caption{Evaluation results}
    \label{tab:eval}
    \footnotesize
    \begin{tabular}{lcrcr}
        \toprule
        \multirow[c]{2}{*}{file name} & \multicolumn{2}{c}{\textsc{Spacer}} & \multicolumn{2}{c}{\textsc{PCSat}} \\
        & result correct? & time (sec.) & result correct? & time (sec.) \\
        \midrule
        \texttt{amb-1-SAT.ml} & Yes & 0.55 & Yes & 15.30 \\
        \texttt{amb-1-UNSAT.ml} & Yes & 0.72 & Yes & 63.62 \\
        \texttt{amb-2-SAT.ml} & Yes & 2.31 & Yes & 31.48 \\
        \texttt{amb-2-UNSAT.ml} & Yes & 2.26 & - & timeout$^\dagger$ \\
        \texttt{amb-3-SAT.ml} & Yes & 3.20 & Yes & 182.41 \\
        \texttt{amb-3-simpl-SAT.ml} & Yes & 1.71 & Yes & 16.79 \\
        \texttt{bfs-SAT.ml} & No$^{*1}$ & 1.67 & - & timeout$^{*1}$ \\
        \texttt{bfs-UNSAT.ml} & Yes & 2.00 & - & timeout$^\dagger$ \\
        \texttt{bfs-simpl-SAT.ml} & No$^{*1}$ & 2.22 & - & timeout$^{*1}$ \\
        \texttt{choose-all-SAT.ml} & Yes & 16.23 & - & timeout$^\dagger$ \\
        \texttt{choose-all-UNSAT.ml} & Yes & 12.56 & - & timeout$^\dagger$ \\
        \texttt{choose-max-SAT.ml} & Yes & 23.08 & - & timeout$^\dagger$ \\
        \texttt{choose-max-UNSAT.ml} & Yes & 15.97 & - & timeout$^\dagger$ \\
        \texttt{choose-sum-SAT.ml} & Yes & 1.54 & - & timeout$^\dagger$ \\
        \texttt{choose-sum-UNSAT.ml} & Yes & 7.99 & Yes & 15.00 \\
        \texttt{deferred-1-SAT.ml} & Yes & 0.46 & Yes & 4.49 \\
        \texttt{deferred-1-UNSAT.ml} & Yes & 0.27 & Yes & 4.09 \\
        \texttt{deferred-2-SAT.ml} & Yes & 0.43 & Yes & 4.38 \\
        \texttt{distribution-SAT.ml} & Abort$^\div$ & - & - & timeout$^{*2}$ \\
        \texttt{distribution-UNSAT.ml} & Abort$^\div$ & - & - & timeout$^{*2}$ \\
        \texttt{expectation-SAT.ml} & Yes & 0.51 & Yes & 7.25 \\
        \texttt{expectation-UNSAT.ml} & Yes & 1.45 & Yes & 7.33 \\
        \texttt{io-read-1-SAT.ml} & Yes & 0.43 & Yes & 13.90 \\
        \texttt{io-read-1-UNSAT.ml} & Yes & 0.41 & Yes & 12.21 \\
        \texttt{io-read-2-SAT.ml} & Yes & 0.56 & Yes & 21.10 \\
        \texttt{io-read-3-SAT.ml} & Yes & 0.54 & Yes & 14.88 \\
        \texttt{io-write-1-SAT.ml} & Yes & 0.32 & Yes & 8.48 \\
        \texttt{io-write-1-UNSAT.ml} & Yes & 0.32 & Yes & 8.76 \\
        \texttt{io-write-2-SAT.ml} & Yes & 0.46 & Yes & 11.33 \\
        \texttt{io-write-2-UNSAT.ml} & Yes & 0.68 & Yes & 11.65 \\
        \texttt{modulus-SAT.ml} & Yes & 14.23 & Yes & 11.89 \\
        \texttt{modulus-UNSAT.ml} & Yes & 26.56 & Yes & 11.91 \\
        \texttt{queue-1-SAT.ml} & Yes & 0.78 & Yes & 19.22 \\
        \texttt{queue-1-UNSAT.ml} & Yes & 0.52 & Yes & 16.93 \\
        \texttt{queue-2-SAT.ml} & Yes & 0.89 & Yes & 22.63 \\
        \texttt{round-robin-SAT.ml} & Yes & 0.96 & - & timeout$^\dagger$ \\
        \texttt{round-robin-UNSAT.ml} & Yes & 0.73 & - & timeout$^\dagger$ \\
        \texttt{safe-div-1-SAT.ml} & Abort$^\div$ & - & Yes & 2.71 \\
        \texttt{safe-div-1-UNSAT.ml} & Abort$^\div$ & - & Yes & 2.73 \\
        \texttt{safe-div-2-SAT.ml} & Abort$^\div$ & - & Yes & 2.55 \\
        \texttt{safe-div-2-UNSAT.ml} & Abort$^\div$ & - & Yes & 3.58 \\
        \texttt{select-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 13.28 \\
        \texttt{select-UNSAT.ml} & - & timeout$^{\ddagger}$ & Yes & 13.26 \\
        \texttt{shift-SAT.ml} & Yes & 0.28 & Yes & 2.92 \\
        \texttt{shift-UNSAT.ml} & Yes & 1.25 & Yes & 3.93 \\
        \texttt{state-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 33.69 \\
        \texttt{state-UNSAT.ml} & Yes & 0.63 & Yes & 13.56 \\
        \texttt{state-easy-SAT.ml} & Yes & 0.90 & Yes & 35.54 \\
        \texttt{transaction-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 15.36 \\
        \texttt{transaction-UNSAT.ml} & - & timeout$^{\ddagger}$ & Yes & 15.77 \\
        \texttt{yield-SAT.ml} & Yes & 1.51 & Yes & 17.57 \\
        \texttt{yield-UNSAT.ml} & Yes & 1.52 & - & timeout$^\dagger$ \\
        \bottomrule
    \end{tabular}
\end{table}

Table~\ref{tab:eval} shows the results of the evaluation.
The files that are suffixed with \texttt{-SAT} are expected to result in ``SAT'',
that is, the programs are expected to be typed
with the refinement types given as their specifications.
The other files (suffixed with \texttt{-UNSAT}) are expected to result in ``UNSAT'',
that is, the programs are expected not to be typed
with the given refinement types.
For each program, we conducted verification in two configurations
((1) \textsc{Spacer}, and (2) \textsc{PCSat}).
The field ``time'' indicates the time spent in the whole process of the verification.
We set the timeout to 600 seconds.
%
Our implementation successfully answered correct result for most programs.
For instance, we show the benchmark \texttt{io-write-2-SAT.ml} as an example
(where \texttt{@annot\_MB} is an effect annotation written in the underlying OCaml type,
explained in the last paragraph of this section):
\begin{verbatim}
let[@annot_MB "(unit -> ({Write: s} |> unit / s3 => s3)) -> unit * int list"]
  accumulate (body: unit -> unit) = match_with body () {
    retc = (fun v -> (v, []));  exnc = raise;
    effc = fun (type a) (e: a eff) -> match e with
      | Write x -> Some (fun (k: (a, _) continuation) ->
        let (v, xs) = continue k () in (v, x :: xs) ) }
let write_all l = accumulate (fun () ->
  let rec go li = match li with
    | [] -> () | s :: ss -> let _ = perform (Write s) in go ss
  in go l )
\end{verbatim}
It iterates over a list \texttt{l} to pass its elements to the operation \texttt{Write},
and the handler for \texttt{Write} accumulates the passed elements into another list.
It is checked against the following specification:
\[
    \jdty{}{\mathtt{write\_all}}{
        \tyrfn{z}{\kwty{int~list}}{z \ne []} \rarr
        \tyrfn{z}{\tyunit \times \kwty{int~list}}{\forall u, v.\, z = (u, v) \Rarr v \ne []}
    }
\]
That is, if the iterated list is not empty, the accumulated list is not, either.
Our implementation successfully answered that \texttt{write\_all} satisfies the specification,
with the following inferred type:
\begin{align}
    (l: \tyrfn{z}{\kwty{int~list}}{z \ne []}) \rarr
    \tyrfn{z}{\tyunit \times \tyrfn{z'}{\tyint}{l \ne []}~\kwty{list}}{\phi}
\end{align}
where $\phi \defeq \exists t: \kwty{int~list}. (t = [] \lor z.2 \ne []) \land t \ne [] \land l \ne []$ and $z.2$ means the second element of the pair $z$.
%
ARM is indispensable for this example because
the initial answer type of the body of the function \texttt{go} should be
$\tyrfn{z}{\tyunit \times \kwty{int~list}}{z.2 = []}$
(since it should be matched with the type of the return clause of the handler),
while its final answer type should be
$\tyrfn{z}{\tyunit \times \kwty{int~list}}{z.2 \ne []}$~.
%
We also present another interesting example (\texttt{queue-2-SAT.ml}) in detail
in the supplementary material.

The benchmarks that were not verified correctly in both configurations are
\texttt{bfs(-simpl)-SAT.ml} (marked with $*1$)
and \texttt{distribution-(UN)SAT.ml} (marked with $*2$).
They need some specific features which the implementation does not support.
The formers need
an invariant which states that there exists an element of a list
that satisfies a certain property.
The latter needs recursive predicates
in the type of an integer list, which states a property about the sum of the elements of the list.
These issues are orthogonal to the main contributions of this paper;
they are about the expressiveness of the background theory used for refinement predicates, to which our novel refinement type system is agnostic.
Also, \texttt{bfs(-simpl)-SAT.ml} uses mutable references
which our implementation does not handle in a flow-sensitive manner
(as mentioned in the footnote~\ref{footnote:strong-update}).
One solution to this issue is to encode references with an effect handler as in Section~\ref{sec:overview/algeff},
but our implementation does not do such encoding automatically. More advanced support for native effects including references is left for future work, as discussed in Section~\ref{sec:language/discussions}.

We discuss pros and cons between the two configurations.
First, \textsc{Spacer} does not support division operator,
and so it cannot verify some programs that use division (marked with $\div$,
aborting with the message ``\texttt{Z3 Error: Uninterpreted 'div' in <null>}'').
Also, some programs can be solved in one configuration but not in the other.
Among those solved by \textsc{Spacer} but not by \textsc{PCSat} (marked with $\dagger$),
\texttt{round-robin-(UN)SAT.ml} timed out during the simplification of its constraints.
For the remaining programs, their constraints tend to contain predicate variables
that take a large number of arguments,
which makes it hard for \textsc{PCSat} to find solutions.
Conversely, the programs solved by \textsc{PCSat} but not by \textsc{Spacer} (marked with $\ddagger$)
involve constraints where some predicate variables occur many times,
which leads to complicated solutions that are difficult for \textsc{Spacer} to solve.

It is worth noting that
our benchmarks do not rely on refinement type annotation in most places,
even for recursive functions and recursive ADTs.
However, a few kinds of annotations are still needed.
First, as mentioned in Section~\ref{sec:language/discussions},
our type system does not support effect polymorphism.
Therefore, we added effect annotations to function-type arguments
which may perform operations when executed, as the one given to the benchmark \texttt{io-write-2-SAT.ml} using \texttt{@annot\_MB}.
These annotations are written in the underlying OCaml types,
that is, we did not specify concrete refinements in the annotations.
%
Second,
we provided refinement type annotations for two small parts of \texttt{state-SAT.ml},
because otherwise it could not be verified within the timeout period in both configurations.
Third, because our implementation
infers predicate-polymorphic types only at let-bindings,
we added \emph{ghost parameters} to some operations and functions
to
infer precise refinement types of them which are not let-bound
but need some abstraction of refinements.
Ghost parameters are parameters which are used to express dependencies in dependent type checking,
but have no impact on the dynamic execution of the program so they can be removed at runtime.
In automated verification, completely inferring predicate variables requires
higher-order predicate constraints, which are not expressible with CHC.
Therefore, we provided ghost parameters
to make it possible to reduce the verification to CHC solving.
For example, the following is a part of \texttt{state-SAT.ml}:
\begin{verbatim}
let rec counter c =
    let i = perform (Lookup c) in
    if i = 0 then c else (perform (Update (c, i - 1)); counter (c + 1))
in counter 0
\end{verbatim}
which is handled by a handler that simulates a mutable reference
similar to that of Example 2 in Section~\ref{sec:language/examples/state}.
Here, we pass the variable $c$ to the operation \texttt{Lookup} and \texttt{Update}
as the ghost parameter.
In the formal system presented in Section~\ref{sec:language/type-system}
where predicate polymorphism is available in operation signatures,
we can give \texttt{Update} the type
\begin{align}
    \forall X\t: (\tyint, \tyint).\,
        (x\t: \tyint) \rarr (\tyunit &\rarr ((s\t: \tyint) \rarr \tyrfnshort{z\t:\tyint}{X(z, s)}))
    \rarr ((s\t: \tyint) \rarr \tyrfnshort{z\t:\tyint}{X(z, x)})
\end{align}
in the same way as Example 2 in Section~\ref{sec:language/examples/state},
and instantiate the predicate variable $X$ with $\lambda (z, s). z = c + 1 + s$
to correctly verify \texttt{state-SAT.ml}.
On the other hand, in the implementation, since predicate polymorphism is not available in operation signatures,
the handler needs to know the concrete predicate which replaces $X$.
However, the predicate contains $c$, which the handler cannot know
without receiving some additional information.
Therefore, we need to add the ghost parameter $c$ to \texttt{Update}
(and the same for \texttt{Lookup}).
This time we added them manually,
but one possible approach for automating insertion of ghost parameters is
to adopt the technique proposed by \citet{Unno13}.
We conjecture that a similar technique can be used
for our purpose.
