\newcommand{\cbody}{c_{\mathit{body}}}

\subsection{Examples} \label{sec:language/exmaples}

In this section, we demonstrate how our type system verifies programs with
algebraic effects and handlers by showing typing derivations of a few
examples.
%
Here, we abbreviate a pure computation type $\tycomp{\{\}}{T}{\square}$ to $T$
and omit the empty typing context from typing and subtyping judgments.
%
For simplicity, we often write $c_1~c_2$ for an expression
$\explet{x_1}{c_1}{\explet{x_2}{c_2}{x_1~x_2}}$ where $x_1$ does not occur in
$c_2$.
%
Furthermore, we deal with a pure computation as if it is a value.
%
For example, we write $\expret{c}$ for a computation $\explet{x}{c}{\expret{x}}$
if $c$ is pure (e.g., as $\expret{a-b}$).
%

\subsubsection{Example 1: Nondeterministic Computation} \label{sec:language/examples/nondet}
We first revisit the example presented in Section~\ref{sec:overview/algeff}.
In our language, it can be expressed as follows:
\begin{align}
    \expwith{h}{
        (&\explet{a}{(\explet{y}{\op[decide]~()}{\expif{y}{\expret{10}}{\expret{20}}})}{ \\
            &\explet{b}{(\explet{y'}{\op[decide]~()}{\expif{y'}{\expret{1}}{\expret{2}}})}{
                \expret{a - b}
            }
        })
    }
\end{align}
where
$
 h \defeq \{ \expret{x_r} \mapsto \expret{x_r},
         \op[decide](x, k) \mapsto \explet{r_t}{k~\exptrue}{
            \explet{r_f}{k~\expfalse}{\mathrm{max}~r_t~r_f}
            } \}
$ ~.
%
As seen before, executing this program results in $19$.
Our system can assign the most precise type $\tyrfn{z}{\tyint}{z = 19}$ to this program.
We now show the typing process to achieve this.
%
In what follows, we write $\Gamma_{\rep{x}}$ for the typing context binding the
variables $\rep{x}$ with some appropriate types $\rep{B}$.
%
In particular, these variables have these base types:
$x_r : \tyint$, $a : \tyint$, $b : \tyint$, $y : \tybool$, and $y' : \tybool$.

First, consider the types assigned to the clauses in the handler $h$.
%
The return clause can be typed as
$\jdty{\Gamma_{x_r}}{\expret{x_r}}{\tyrfn{z}{\tyint}{z = x_r}}$.
%
The clause for $\op[decide]$ can be typed as follows:
\begin{align} \label{eqn:typ-decide-clause}
    \jdty{
       \Gamma
    }{
        \explet{r_t}{k~\exptrue}{
            \explet{r_f}{k~\expfalse}{\mathrm{max}~r_t~r_f}
        }
    }{\tyrfn{z}{\tyint}{\phi}}
\end{align}
where $\Gamma \defeq X: (\tyint, \tybool), x: \tyunit,
k: (y: \tybool) \rarr \tyrfn{z}{\tyint}{X(z, y)}$,
$\phi \defeq \forall r_t r_f.
X(r_t, \exptrue) \land X(r_f, \expfalse) \implies z = \mathtt{max}(r_t, r_f)$, and $\mathtt{max}$ is a term-level function that returns the larger of given two integers.
%
In this typing judgment, the predicate variable $X$ abstracts over relationships
between inputs $y$ and outputs $z$ of delimited continuations captured by calls to
$\op[decide]$, and the refinement formula $\phi$ summarizes what the operation
clause computes.
%
Therefore, the operation signature $\Sigma$ of the type of the handled
computation, $\cbody$ in what follows, can be given as
follows:
\begin{align}
    \Sigma \,\defeq\, \{ &\op[decide]: \forall X: (\tyint, \tybool).
        (x: \tyunit) \rarr ((y: \tybool) \rarr \tyrfn{z}{\tyint}{X(z, y)})
        \rarr \tyrfn{z}{\tyint}{\phi}
    \} ~. \!
\end{align}
%

Therefore, we can conclude that the program is typable as desired by the following derivation
\begin{prooftree}
 \AxiomC{\Shortstack{
 {$\jdty{\Gamma_{x_r}}{\expret{x_r}}{\tyrfn{z}{\tyint}{z = x_r}}$ \qquad
  (Judgment (\refeq{eqn:typ-decide-clause}))}
 {(I) \ \ %
  $\jdty{}{\cbody}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\tyrfn{z}{\tyint}{z = 19}}}}$}
 }}
 \RightLabel{\rulename{T-Hndl}}
 \UnaryInfC{$\jdty{}{\expwith{h}{\cbody}}{\tyrfn{z}{\tyint}{z = 19}}$}
\end{prooftree}
if the premise (I) for $\cbody$ holds.
%
We derive it by \rulename{T-LetIp}, obtaining a derivation of the form
%f
\begin{prooftree}
 \AxiomC{
   \stackanchor{
     (II) \ \ %
     $\jdty{}{(\explet{y}{\op[decide]~()}{\kw{if} \ y \ \cdots})}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{z = 19}}}}$
   }{
     (III) \ \ %
     $\jdty{\Gamma_{a}}{\explet{b}{\cdots}{\expret{a - b}}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_1}}}$
   }
 }
 \RightLabel{\rulename{T-LetIp}}
 \UnaryInfC{
   (I) \ \ $\jdty{}{\cbody}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }
\end{prooftree}
for some type $C_1$.

We start by examining judgement (III) because its derivation gives the
constraints to identify the type $C_1$.
%
By \rulename{T-LetIp} again, we can derive
\begin{prooftree}
 \AxiomC{\stackanchor{
  (III-1) \ \ %
  $\jdty{\Gamma_{a}}{(\explet{y'}{\op[decide]~()}{\kw{if} \ y' \ \cdots})}{\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_1}}}$
 }{
  (III-2) \ \ %
  $\jdty{\Gamma_{a,b}}{\expret{a - b}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }}
 \RightLabel{\rulename{T-LetIp}}
 \UnaryInfC{
  (III) \ \ %
  $\jdty{\Gamma_{a}}{\explet{b}{\cdots}{\expret{a - b}}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_1}}}$
 }
\end{prooftree}
with the premises (III-1) and (III-2) and some type $C_2$.
%
Judgment (III-2) is derivable by
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdty
   {\Gamma_{a,b}}
   {\expret{a - b}}
   {\tyrfn{z}{\tyint}{z = a - b}}$
 }{
  (III-2-S) \ \ %
  $\jdsub
   {\Gamma_{a,b}}
   {\tyrfn{z}{\tyint}{z = a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }}
 \RightLabel{\rulename{T-Sub}}
 \UnaryInfC{
  (III-2) \ \ %
  $\jdty
   {\Gamma_{a,b}}
   {\expret{a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }
\end{prooftree}
with the derivation of the subtyping judgment (III-2-S):
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdsub{\Gamma_{a,b}}{\Sigma}{\emptyset}$
  \qquad
  $\jdsub{\Gamma_{a,b}}{\tyrfn{z}{\tyint}{z = a - b}}{\tyint}$
 }{
  $\jdsub
   {\Gamma_{a,b} \mid \tyrfn{z}{\tyint}{z = a - b}}
   {\square}
   {\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}$
 }}
 \RightLabel{\rulename{S-Comp}}
 \UnaryInfC{
  (III-2-S) \ \ %
  $\jdsub
   {\Gamma_{a,b}}
   {\tyrfn{z}{\tyint}{z = a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }
\end{prooftree}
%
The first two subtyping premises are derivable trivially.
%
We can derive the third one by letting
$
 C_2 {\,\defeq\,} \tyrfn{z}{\tyint}{z = a - b}
$
because:
\begin{prooftree}
 \AxiomC{
  $\valid
   {\Gamma_{a,b}, x_r: \tyrfn{z}{\tyint}{z = a - b}, z: \tyint}
   {(z = x_r) \implies (z = a - b)}$
 }
 \RightLabel{\rulename{S-Rfn}}
 \UnaryInfC{
  $\jdsub
   {\Gamma_{a,b}, x_r: \tyrfn{z}{\tyint}{z = a - b}}
   {\tyrfn{z}{\tyint}{z = x_r}}
   {\tyrfn{z}{\tyint}{z = a - b}}$
 }
 \RightLabel{\rulename{S-Embed}}
 \UnaryInfC{
  $\jdsub
  {\Gamma_{a,b} \mid \tyrfn{z}{\tyint}{z = a - b}}
  {\square}
  {\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\colorbox{gray!50}{$\tyrfn{z}{\tyint}{z = a - b}$}}}$
 }
\end{prooftree}
where the grayed part is denoted by $C_2$ in the original premise.
%
We note that our type inference algorithm automatically infers such a type by constraint solving (cf.~Section~\ref{sec:impl}).
%
Next, judgment (III-1) is derivable by
\begin{prooftree}
 \AxiomC{\stackanchor{
  (III-1-1) \ \ %
  $\jdty
   {\Gamma_{a}}
   {\op[decide]~()}
   {\tycomp{\Sigma}{\tybool}{\tyctl{y'}{C_3}{C_1}}}$
 }{
  (III-1-2) \ \ %
  $\jdty
   {\Gamma_{a,y'}}
   {\kw{if} \ y' \ \cdots}
   {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_3}}}$
 }}
 \RightLabel{\rulename{T-LetIp}}
 \UnaryInfC{
 (III-1) \ \ %
 $\jdty{\Gamma_{a}}{(\explet{y'}{\op[decide]~()}{\kw{if} \ y' \ \cdots})}{\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_1}}}$
 }
\end{prooftree}
with the premises (III-1-1) and (III-1-2) and some type $C_3$.
%
By letting
$
 C_3 {\,\defeq\,} \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{(a-1)}{(a-2)})}
$,
we can derive judgment (III-1-2):
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdty{\Gamma_{a,y'}}
        {\kw{if} \ y' \ \cdots}
        {\tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}$
 }{
  $\jdsub{\Gamma_{a,y'}}
         {\tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
         {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_3}}}$
 }}
 \RightLabel{\rulename{T-Sub}}
 \UnaryInfC{
 (III-1-2) \ \ %
 $\jdty
  {\Gamma_{a,y'}}
  {\kw{if} \ y' \ \cdots}
  {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_3}}}$
 }
\end{prooftree}
%
It is easy to see that the first typing premise holds.
%
We can derive the second subtyping premise similarly to subtyping
judgment (III-2-S), namely, by \rulename{S-Comp} with the following derivation
for the subtyping on control effects:
%
\begin{prooftree}
 \AxiomC{
  $\valid
   {\Gamma_{a,y'}, b: \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
   {(z = a - b) \implies (z = (\ternaryif{y'}{(a-1)}{(a-2)}))}$
 }
 \RightLabel{\rulename{S-Rfn}}
 \UnaryInfC{
  $\jdsub
   {\Gamma_{a,y'}, b: \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
   {C_2}
   {C_3}$
 }
 \RightLabel{\rulename{S-Embed}}
 \UnaryInfC{$\jdsub{\Gamma_{a,y'} \mid \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}{\square}{\tyctl{b}{C_2}{C_3}}$}
\end{prooftree}
%
Judgment (III-1-1) is derived by \rulename{T-Op}, but for that,
we need to instantiate the predicate variable $X$ in the type scheme of $\op[decide]$ in $\Sigma$ with
a predicate $A$ such that the constraint $C_3 = \tyrfn{z}{\tyint}{A(z, y')}$ imposed by \rulename{T-Op} is met.
%
Let
$
 A \,\defeq\, \lambda (z, y). z = (\ternaryif{y}{(a-1)}{(a-2)})
$, which satisfies the constraint trivially.
%
Then, by letting
$
 C_1 {\,\defeq\,} \tyrfn{z}{\tyint}{\phi}[A/X]~,
$
we have the following derivation:
\begin{prooftree}
 \AxiomC{
 $\jdty
  {\Gamma_{a}}
  {()}
  {\tyunit}$
 }
 \RightLabel{\rulename{T-Op}}
 \UnaryInfC{
 (III-1-1) \ \ %
 $\jdty{\Gamma_{a}}{\op[decide]~()}{\tycomp{\Sigma}{\tybool}{\tyctl{y'}{\tyrfn{z}{\tyint}{A(z, y')}}{\tyrfn{z}{\tyint}{\phi}[A/X]}}}$
 }
\end{prooftree}
%

Finally, we examine judgment (II).
%
It is derivable by
\begin{prooftree}
 \AxiomC{\stackanchor{
  (II-1) \ \ %
  $\jdty
   {}
   {\op[decide]~()}
   {\tycomp{\Sigma}{\tybool}{\tyctl{y}{C_4}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }{
  (II-2) \ \ %
  $\jdty
   {\Gamma_{y}}
   {\kw{if} \ y \ \cdots}
   {\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{C_4}}}$
 }}
 \RightLabel{\rulename{T-LetIp}}
 \UnaryInfC{
 (II) \ \ %
 $\jdty{}{(\explet{y}{\op[decide]~()}{\kw{if} \ y \ \cdots})}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }
\end{prooftree}
with the premises (II-1) and (II-2) and some type $C_4$.
%
Judgement (II-2) is derivable similarly to (III-1-2) by letting
$
 C_4 {\,\defeq\,} \tyrfn{z}{\tyint}{z = (\ternaryif{y}{9}{19})}~.
$
For judgment (II-1), we instantiate the predicate variable $X$ in the first call to $\op[decide]$
with the predicate
$
 A' \,\defeq\, \lambda (z, y). z = (\ternaryif{y}{9}{19}) ~.
$
%
Then, we can derive the judgment by the following derivation:
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdty
   {}
   {\op[decide]~()}
   {\tycomp{\Sigma}{\tybool}{\tyctl{y}{\tyrfn{z}{\tyint}{A'(z, y)}}{\tyrfn{z}{\tyint}{\phi[A'/X]}}}}$
 }{
  $\jdsub
   {}
   {\tycomp{\Sigma}{\tybool}{\tyctl{y}{C_4}{\tyrfn{z}{\tyint}{\phi[A'/X]}}}}
   {\tycomp{\Sigma}{\tybool}{\tyctl{y}{C_4}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }}
 \RightLabel{\rulename{T-Sub}}
 \UnaryInfC{
 (II-1) \ \ %
 $\jdty{}{\op[decide]~()}{\tycomp{\Sigma}{\tybool}{\tyctl{y}{C_4}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }
\end{prooftree}
(note that $C_4 = \tyrfn{z}{\tyint}{A'(z, y)}$)
where the first premise is derived by \rulename{T-Op} and the second one
holds because the formula $\phi[A'/X]$ is semantically equivalent to the formula $z = 19$.

We note that the predicate variable in the type scheme of $\op[decide]$ is important to typing this example.
%
The delimited continuations captured by the two calls to $\op[decide]$ behave differently. Namely, they respectively behave according to the predicates $A(u,v)$ and $A'(u,v)$ where $u$ is the integer output given the Boolean input $v$.
%
By using predicate variables, our type system gives a single type scheme to an operation that abstracts over such different behaviors.\footnote{An alternative approach is to use intersection types (i.e., allow a set of types to be given to an operation).  But, we find our approach more uniform and modular as it is able to give a single compact type scheme and enables operation signatures to be unaware of in which contexts operations are called.}

\subsubsection{Example 2: State} \label{sec:language/examples/state}
%
We next revisit the second example from
Section~\ref{sec:overview/algeff}.
Recall the example, which is the following program:
%
\begin{gather}
    (\expwith{h}{
        \ (\op[set]~3;\,
        \explet{n}{\op[get]~()}{
            \op[set]~5;\,
            \explet{m}{\op[get]~()}{
                n + m
            }
        })
    })~0
\end{gather}
%
where $h \defeq \{
  x_r \mapsto \lambda s. x_r, \ 
  \op[set](x, k) \mapsto \lambda s.k~()~x, \ 
  \op[get](x, k) \mapsto \lambda s. k~s~s \}$~.
For this example, we use
the following syntactic sugars: $c_1;\,c_2 \,\defeq\, \explet{x}{c_1}{c_2}$
(where $x$ does not occur in $c_2$) and $\lambda x. v \,\defeq\, \lambda x. \expret{v}$.
%
Then,
the program is in our language.
%
This program uses two operations: $\op[set]$, which updates the state value, and
$\op[get]$, which returns the current state value. The handling construct returns a function that
maps any integer value to the value $8$;
arguments to the function are initial state values, but they are not used
because the function begins by initializing the state.
Applying the function to the initial state value $0$, the whole program returns $8$.

This program is expected to be of the type
$\tyrfn{z}{\tyint}{z = 8}$.
%
The rest of this section explains how the type system assigns this type
to the program.
%
First, the operation signature $\Sigma$ for the handler $h$ can be defined as follows:
%
\[\begin{array}{@{}l@{\ \ }l@{\ \ }l}
 \Sigma &\defeq&
   \{
        \op[set]: \forall X: (\tyint, \tyint).\,
            (x: \tyint) \rarr (\tyunit \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s)})) \\
    && \qquad\qquad\qquad\qquad\qquad\qquad\qquad      \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, x)}), \\
   && \ \, \op[get]: \forall X: (\tyint, \tyint, \tyint).\,
            \tyunit \rarr ((y: \tyint) \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s, y)})) \\
    && \qquad\qquad\qquad\qquad\qquad\qquad\qquad      \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s, s)})
    \ \}
  \end{array}
\]
%
%
Then, each sub-computation in the handled computation can be typed as follows:
%
%
\[\begin{array}{r@{\ }l}
    \jdty{&}{\op[set]~3}{\tycomp{\Sigma}{\tyint}{
        \tyctl{\_}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = s + 5}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 3 + 5}
        }
    }} \\
    \jdty{&}{\op[get]~()}{\tycomp{\Sigma}{\tyint}{
        \tyctl{n}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + 5}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = s + 5}
        }
    }} \\
    \jdty{n: \tyint&}{\op[set]~5}{\tycomp{\Sigma}{\tyint}{
        \tyctl{\_}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + s}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + 5}
        }
    }} \\
    \jdty{n: \tyint&}{\op[get]~()}{\tycomp{\Sigma}{\tyint}{
        \tyctl{m}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + m}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + s}
        }
    }} \\
    \jdty{n: \tyint, &m: \tyint}{\expret{n + m}}{\\ \tycomp{\Sigma}{\tyrfn{x_r&}{\tyint}{x_r = n + m}}{
        \tyctl{x_r}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = x_r}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + m}
        }
    }}
  \end{array}
\]
The first four judgments are derived by \rulename{T-Op} with appropriate
instantiation of the type schemes of $\op[set]$ and $\op[get]$.
%
The last judgement is derived using \rulename{S-Embed} as in the first example.
The type of the handled computation is derived from these computation types, taking the following form:
\[
    \tycomp{\Sigma}{\tyint}{
        \tyctl{x_r}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = x_r}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 8}
        }
    } ~.
\]
Therefore, by \rulename{T-Hndl}, the type of the handling construct is
$(s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 8}$, and by \rulename{T-App}, the type of the whole program is $\tyrfn{z}{\tyint}{z = 8}$
as promised.

\subsubsection{Example 3: File Manipulation} \label{sec:language/examples/file}
%
Finally, we consider the last example in Section~\ref{sec:overview/algeff} that
manipulates a specified file.
%
Because the example uses nondeterministic while-loop constructs
$\expwhile{\star}{c}$, we informally extend our language with them.\footnote{An
alternative is to encode the while-loop constructs in our language by supposing
that the termination of a while-loop construct is determined by some function
parameter $f : \tyfunshort{\tyunit}{\tybool}$.}
%
The semantics of the while-loop constructs is given by the reduction rules
$\expwhile{\star}{c} \eval c;\, \expwhile{\star}{c}$ and $\expwhile{\star}{c}
\eval \expret{()}$, and the typing rule is given as follows:
%
\begin{prooftree}
 \AxiomC{$\jdty{\Gamma}{c}{\tycomp{\Sigma}{\tyunit}{\tyctlMB{C}{C}}}$}
 \RightLabel{\rulename{T-Loop}}
 \UnaryInfC{$\jdty{\Gamma}{\expwhile{\star}{c}}{\tycomp{\Sigma}{\tyunit}{\tyctlMB{C}{C}}}$}
\end{prooftree}
%
Note that it is easy to adapt the type safety to this extension.

%
Recall that the example for file manipulation is the following function:
\begin{gather}
 v \,\defeq\, \expfun{x}{~\expwhile{\star}{\op[open]~x;\ \expwhile{\star}{\explet{y}{\op[read]()}{\op[write]~(y\texttt{\textasciicircum"X"})}};\ \op[close]~()}} ~.
\end{gather}
%
The regular scheme stipulating the valid use of the file operations is
$(\op[open] \ (\op[read] \mid \op[write])^\ast \ \op[close])^\ast$,
which is equivalent to the automaton to the right.
\begin{wrapfigure}[4]{R}{0.38\textwidth}
\vspace*{-5ex}
\begin{tikzpicture}[>=Stealth,shorten >=1pt,node distance=2cm,on grid,auto]
  \node[state,initial,initial text=,accepting] (q0) {$q0$};
  \node[state,right=of q0]       (q1) {$q1$};
   \path[->]
   (q0) edge[bend left,above] node {$\op[open]$}  (q1)
   (q1) edge[bend left,below] node {$\op[close]$} (q0)
        edge[loop right]      node[align=left] {$\op[read]$\\$\op[write]$} (q1);
\end{tikzpicture}
\end{wrapfigure}

Our idea to verify the correctness of the file manipulation is to encode the
automaton states as program states, simulate the state transitions in the
automaton by state-passing, and check that the file operations are used only in
appropriate states.
%
Let $Q0 \,\defeq\, 0$ and $Q1 \,\defeq\, 1$; they represent the automaton states
$q0$ and $q1$, respectively.
%
We suppose that an effect handler implements the file operations $\op[open]$ ,
$\op[close]$, $\op[read]$, and $\op[write]$ in a state-passing style for states
$Q0$ and $Q1$.
%
Then, the type scheme of each file operation can be given as an instance of the
following template:
\[
 F(T_\mathrm{in}, T_\mathrm{out}, Q_\mathrm{pre}, Q_\mathrm{post}) \defeq T_\mathrm{in} \rarr (T_\mathrm{out} \rarr (\tyrfn{x}{\tyint}{x = Q_\mathrm{post}} \rarr C)) \rarr (\tyrfn{x}{\tyint}{x = Q_\mathrm{pre}} \rarr C)
\]
where the parameters $T_\mathrm{in}$ and $T_\mathrm{out}$ are the input and
output types, respectively, of the operation, and $Q_\mathrm{pre}$ and
$Q_\mathrm{post}$ are the states before and after, respectively, performing the
operation.
%
We do not specify the final answer type $C$ concretely here because it is not
important.
%
Using this template, an operation signature $\Sigma$ of the file operations is
given as
%
\[\begin{array}{l@{\ \ }l@{\ }l@{\ }l@{\ \ }l@{\ }l@{\ }l@{\ \ }l}
 \{ &
   \op[open]  &:& F(\tystr,\tyunit,Q0,Q1),  &
   \op[close] &:& F(\tyunit,\tyunit,Q1,Q0), \\ &
   \op[read]  &:& F(\tyunit,\tystr,Q1,Q1), &
   \op[write] &:& F(\tystr,\tyunit,Q1,Q1)
  & \} ~.
  \end{array}
\]
%
Note that the state transitions represented in $\Sigma$ are matched with those in
the automaton.
%
Let
\[
 S(Q_\mathrm{pre},Q_\mathrm{post}) \,\defeq\, \tyctlMB{(\tyrfn{x}{\tyint}{x = Q_\mathrm{post}} \rarr C)}{(\tyrfn{x}{\tyint}{x = Q_\mathrm{pre}} \rarr C)} ~.
\]
%
Given an effect handler $h$ conforming to $\Sigma$ and
a computation $c$ with control effect $S(n_\mathrm{pre},n_\mathrm{post})$ for some $n_\mathrm{pre}$ and $n_\mathrm{post}$,
if a handling construct $\expwith{h}{c}$ is well typed, the body of $h$'s return clause is typed at
$\tyrfn{x}{\tyint}{x = n_\mathrm{post}} \rarr C$---i.e., the computation $c$
terminates at the state $n_\mathrm{post}$---and the handling construct
$\expwith{h}{c}$ is typed at $\tyrfn{x}{\tyint}{x = n_\mathrm{pre}} \rarr
C$---i.e., it requires $n_\mathrm{pre}$ as the initial state to start the computation $c$.
%
Therefore, if $n_\mathrm{pre} = n_\mathrm{post} = Q0$, then it is guaranteed
that the file operations are used in a valid manner.
%
Furthermore, even if $c$ is non-terminating, our type system can ensure that it
does not use the file operations in an invalid manner.
%
For example, suppose that $c$ is a computation $\op[close]~();\ \Omega$ where $\Omega$ is a
diverging computation. If it is well typed, its final answer type is
$\tyrfn{x}{\tyint}{x = Q1} \rarr C$, which indicates that $\expwith{h}{c}$
requires $Q1$ as the initial state.  It is clearly inconsistent with the
above automation.
%
As another instance, suppose that $c$ involves a computation $\cdots ;\ \op[close]~();\ \op[write]~"X"; \cdots$.
%
This is illegal because it tries to call $\op[write]$ after $\op[close]$ without
$\op[open]$.
%
Our type system rejects it because the initial answer type
$\tyrfn{x}{\tyint}{x = Q0} \rarr C$ of $\op[close]~()$ is not matched with the
final answer type $\tyrfn{x}{\tyint}{x = Q1} \rarr C$ of $\op[write]~"X"$ while
they must be matched for the computation to be well typed.

We end this section by showing that the example function $v$ can be typed at
$\tystr \rarr \tycomp{\Sigma}{\tyunit}{S(Q0,Q0)}$,
which means that $v$'s body uses the file operations appropriately.
%
Note that, for any typing context $\Gamma'$ and file operation $\op$,
if
$\op : F(T_1,T_2,n_\mathrm{pre},n_\mathrm{post}) \in \Sigma$ and
$\jdty{\Gamma'}{v}{T_1}$,
then
$\jdty{\Gamma'}{\op~v}{\tycomp{\Sigma}{T_2}{S(n_\mathrm{pre},n_\mathrm{post})}}$
by \rulename{T-Op}.
%
Let $\Gamma \defeq x: \tystr$.
%
For the inner while-loop construct, we have the following typing derivation:
\begin{prooftree}
     \AxiomC{
       \stackanchor{
         $\jdty{\Gamma}{ \op[read]() }{ \tycomp{\Sigma}{\tystr}{S(Q1,Q1)} }$
       }{
         $\jdty{\Gamma,y:\tystr}{ \op[write]~(y\texttt{\textasciicircum"X"}) }{ \tycomp{\Sigma}{\tyunit}{S(Q1,Q1)} }$
       }
     }
     \RightLabel{\rulename{T-LetIp}}
   \UnaryInfC{$\jdty{\Gamma}{ \explet{y}{\op[read]()}{\op[write]~(y\texttt{\textasciicircum"X"})} }{ \tycomp{\Sigma}{\tyunit}{S(Q1,Q1)} }$}
   \RightLabel{\rulename{T-Loop}}
 \UnaryInfC{$\jdty{\Gamma}{ \expwhile{\star}{\explet{y}{\op[read]()}{\op[write]~(y\texttt{\textasciicircum"X"})}} }{ \tycomp{\Sigma}{\tyunit}{S(Q1,Q1)} }$}
\end{prooftree}
%
Thus, the sub-computations of the outer while-loop construct can be typed as follows:
%
\[\begin{array}{r@{\ }l@{\ }l}
 \jdty{\Gamma&}{\op[open]~x&}{\tycomp{\Sigma}{\tyunit}{S(Q0,Q1)}}
 \\
 \jdty{\Gamma&}{\expwhile{\star}{\explet{y}{\op[read]()}{\op[write]~(y\texttt{\textasciicircum"X"})}}&}{\tycomp{\Sigma}{\tyunit}{S(Q1,Q1)}}
 \\
 \jdty{\Gamma&}{\op[close]~()&}{\tycomp{\Sigma}{\tyunit}{S(Q1,Q0)}} ~.
  \end{array}
\]
%
where the control effects express how the state changes according to the
operation calls.
%
By \rulename{T-LetIp}, \rulename{T-Loop}, and \rulename{T-Fun}, they then imply that $v$ is typed at
$\tystr \rarr \tycomp{\Sigma}{\tyunit}{S(Q0,Q0)}$ as desired.

