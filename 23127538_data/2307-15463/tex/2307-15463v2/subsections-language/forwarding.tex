% \subsection{Typing Rule for Operation Forwarding} \label{sec:language/forwarding}
\section{Typing Rule for Operation Forwarding} \label{sec:language/forwarding}
The typing rule for handling constructs presented in Section 3.2 of the main paper %\ref{sec:language/type-system}
assumes that a handler covers all the operations performed
by the handled expression.
In this section, we present another typing rule for handling constructs
to allow \emph{operation forwarding}, that is, allow unhandled operations to be forwarded to outer handlers automatically.
The idea of the typing rule is simple: we derive it from an implementation of operation forwarding.
As mentioned in Section~3.1 of the main paper, %\ref{sec:language/syntax-semantics},
operation forwarding can be implemented in a calculus without forwarding by adding to a handler
an operation clause $\op(x, k) \mapsto \explet{y}{\op~x}{k~y}$ for each forwarded operation $\op$.
Therefore, we can derive the new typing rule
from the typing of the added clauses. The following is the thus derived new typing rule for handling constructs which natively supports operation forwarding:
\[
\infer{\jdty{\Gamma}{\expwith{h}{c}}{C_2}}
{\begin{gathered}
    h = \{ \expret{x_r} \mapsto c_r, \repi{\op_i(x_i, k_i) \mapsto c_i} \} \quad
    \jdty{\Gamma}{c}{\tycomp{\Sigma}{T}{\tyctl{x_r}{C_1}{C_2}}} \\[-.5ex]
    \jdty{\Gamma, x_r: T}{c_r}{C_1} \quad
    \bigrepi{\jdty{\Gamma, \rep{X_i: \rep{B}_i}, x_i: T_{1i}, k_i: (y_i: T_{2i}) \rarr C_{1i}}{c_i}{C_{2i}}} \\[-.5ex]
    \bigrepi{ \Sigma \ni \op_i: \forall \rep{X_i: \rep{B}_i}. (x_i: T_{1i}) \rarr ((y_i: T_{2i}) \rarr C_{1i}) \rarr C_{2i} }
    \qquad \mathit{Ops}_{\mathrm{fwd}} = \dom(\Sigma) \setminus \dom(h) \\[-.5ex]
    \bigrepi[\op \in \mathit{Ops}_{\mathrm{fwd}}]{\begin{gathered}
        \begin{multlined}
            \Sigma \ni \op : \forall \rep{X^{\op}: \rep{B^{\op}}}. (x^{\op}: T_1^{\op}) \rarr \\
                ((y^{\op}: T_2^{\op}) \rarr
                    \tycomp{\Sigma'}{T_0^{\op}}{\tyctl{z^{\op}}{C_0^{\op}}{C_1^{\op}}}) \rarr
                \tycomp{\Sigma'}{T_0^{\op}}{\tyctl{z^{\op}}{C_0^{\op}}{C_2^{\op}}}
        \end{multlined} \\
        \Sigma' \ni \op : \forall \rep{X^{\op}: \rep{B^{\op}}}. (x^{\op}: T_1^{\op}) \rarr ((y^{\op}: T_2^{\op}) \rarr C_1^{\op}) \rarr C_2^{\op} \quad
        y^{\op} \notin C_0^{\op} \setminus \{ z^{\op} \}
    \end{gathered}
    }
\end{gathered}}
\]
where $\dom(\Sigma)$ denotes the set of the operations associated by $\Sigma$
and $\dom(h)$ denotes the set of the operations handled by $h$,
that is, the set $\{ \repi{\op_i} \}$.
The first two lines are the same as \rulename{T-Hndl}.
The third line is also similar to the last premise of \rulename{T-Hndl},
but here $\Sigma$ is allowed to contain operations other than those handled by $h$.
$\mathit{Ops}_{\mathrm{fwd}}$ is exactly the set of the unhandled (i.e., forwarded) operations.
The last part is the requirement for the forwarded operations,
which can be obtained from the typing derivations of $\op(x, k) \mapsto \explet{y}{\op~x}{k~y}$ as follows.
When we simulate the operation forwarding with the explicit clause,
the operation call $\op~x$ in the clause is handled
by an immediate outer handler (we denote it by $h'$ in what follows).
Therefore, its operation signature is different from $\Sigma$;
in fact, it corresponds to $\Sigma'$ in the rule.
Also, the answer types of the original operation calls of $\op$
(i.e., the answer types of the operation calls of $\op$ in the handled computation $c$)
should have $\Sigma'$ as their operation signatures,
because the final answer type corresponds to the type of the handling construct,
which is handled by the immediate outer handler $h'$.
Therefore, the types of the forwarded operations in $\Sigma$ contains $\Sigma'$
in their answer types.
In addition, the types
$T_0^{\op}$, $T_1^{\op}$, $T_2^{\op}$, $C_0^{\op}$, $C_1^{\op}$, and $C_2^{\op}$
appear multiple times in $\Sigma$ and $\Sigma'$, restricting the type schemes of the operations in $\mathit{Ops}_{\mathrm{fwd}}$.
This restriction can be understood as follows.
First, assume that the original operation call of $\op$ in $c$
has the operation signature $\Sigma$ such that
\[
    \Sigma \ni \op : T_1^{\op} \rarr
        (T_2^{\op} \rarr
            \tycomp{\Sigma'}{T_0^{\op}}{\tyctlMB{C_0^{\op}}{C_1^{\op}}}) \rarr
        \tycomp{\Sigma'}{T_{0A}^{\op}}{\tyctlMB{C_{0A}^{\op}}{C_2^{\op}}}
\]
for some $T_1^{\op}$, $T_2^{\op}$, $T_0^{\op}$, $C_0^{\op}$, $C_1^{\op}$,
$T_{0A}^{\op}$, $C_{0A}^{\op}$, $C_2^{\op}$, and $\Sigma'$, under a context $\Gamma$.
Here we consider only simple types for simplicity,
but a similar argument can be made for dependent and refinement types
by appropriately naming the variables like in the rule above.
Note that its answer types have $\Sigma'$ as described earlier,
and that we do not impose the restriction yet.
From the assumption, the clause $\explet{y}{\op~x}{k~y}$ should be typed
under the context $\Gamma, x: T_1^{\op},
k: T_2^{\op} \rarr \tycomp{\Sigma'}{T_0^{\op}}{\tyctlMB{C_0^{\op}}{C_1^{\op}}}$~.
Then, the input type of $\op$ in the clause should be the type of $x$, namely, $T_1^{\op}$,
and the output type of $\op$ should be the type of the variable $y$,
which turns out to be $T_2^{\op}$ from the type of $k$.
Therefore, the operation signature $\Sigma'$ for $\op~x$ should contain
$\op : T_1^{\op} \rarr (T_2^{\op} \rarr C_{1A}^{\op}) \rarr C_{2A}^{\op}$
for some $C_{1A}^{\op}$ and $C_{2A}^{\op}$~.
Then, according to the typing rules for operation calls and let-expressions,
it is required that $C_{1A}^{\op} = C_1^{\op}$,
and the type of $\explet{y}{\op~x}{k~y}$ is
$\tycomp{\Sigma'}{T_{0}^{\op}}{\tyctlMB{C_{0}^{\op}}{C_{2A}^{\op}}}$~.
Finally, since the type of the clause corresponds to
the final answer type of the operation $\op$ in $\Sigma$
(which is $\tycomp{\Sigma'}{T_{0A}^{\op}}{\tyctlMB{C_{0A}^{\op}}{C_2^{\op}}}$ from the assumption),
it should satisfy
$T_{0}^{\op} = T_{0A}^{\op}$, $C_{0}^{\op} = C_{0A}^{\op}$, and $C_{2A}^{\op} = C_{2}^{\op}$~.

