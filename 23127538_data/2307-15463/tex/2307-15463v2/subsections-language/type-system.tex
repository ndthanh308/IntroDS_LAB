\subsection{Type System} \label{sec:language/type-system}

\begin{wrapfigure}[11]{R}{0.65\textwidth}
    \vspace*{-4ex}
    $\begin{array}{rc@{\ \ }c@{\ }l@{\qquad}rc@{\ \ }c@{\ \ }l}
        \text{term} &
        t &::=& x \mid \ldots
        &
        \text{formula} &
        \phi &::=& A(\rep{t}) \mid \ldots
        \\
        \text{predicate} &
        A &::=& X \mid \ldots
        &
        \text{base type} &
        B &::=& \tybool \mid \ldots
    \end{array}$
    $\begin{array}{rc@{\ \ }c@{\ }l}
        \text{value type} &
        T &::=& \tyrfn{x}{B}{\phi} \mid (x: T) \rarr C
        \\
        \text{computation type} &
        C &::=& \tycomp{\Sigma}{T}{S}
        \\
        \text{operation signature} &
        \Sigma &::=& \{ \repi{\op_i : \forall \rep{X_i: \rep{B}_i}. F_i} \}
        \\
        &
        F &::=& (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2
        \\
        \text{control effect} &
        S &::=& \square \mid \tyctl{x}{C_1}{C_2}
        \\
        \text{typing context} &
        \Gamma &::=& \emptyset \mid \Gamma, x: T \mid \Gamma, X: \rep{B}
    \end{array}$
    \caption{Type syntax.}
    \label{fig:type-syntax}
\end{wrapfigure}

Figure~\ref{fig:type-syntax} shows the syntax of types.
%
As in prior refinement type systems \cite{Bengston11, Rondon08, Unno09}, our type system allows a type
specification for values of base types, ranged over by $B$, such as $\tybool$
and $\tyint$, to be refined using logic formulas, ranged over by $\phi$.
%
Our type system is parameterized over a logic. We assume that the logic is a
predicate logic where: terms, denoted by $t$, include variables $x$;
predicates, denoted by $A$, include predicate variables $X$; and each primitive
value $p$ can be represented as a term.
%
Throughout the paper, we use the over-tilde notation to denote a sequence of
entities.  For example, $\rep{t}$ represents a sequence $t_1, \cdots, t_n$ of
some terms $t_1, \ldots, t_n$, and then $A(\rep{t})$ represents a formula
$A(t_1, \cdots, t_n)$.
%
We also assume that base types include at least the Boolean type $\tybool$.

Types consist of value and computation types, which are assigned to values and
computations, respectively.
%
A value type, denoted by $T$, is either a refinement type $\tyrfn{x}{B}{\phi}$,
which is assigned to a value $v$ of base type $B$ such that the formula
$\phi[v/x]$ is true, or a dependent function type $(x: T) \rarr C$, which is
assigned to a function that, given an argument $v$ of the type $T$, performs
the computation specified by the type $C[v/x]$.
We abbreviate $\tyfun{x}{T}{C}$ as $\tyfunshort{T}{C}$ if $x$ does not occur in $C$, and $\tyrfn{z}{B}{\exptrue}$ as $B$.

A computation type is formed by three components: an operation signature,
which specifies operations that a computation may perform;
a value type, which specifies the value that the computation returns
if any; and a control effect, which specifies how the computation modifies the
answer type via operation call.

Control effects, denoted by $S$, are inspired by the formalism of \citet{Sekiyama23} who extended control effects in simple typing~\cite{Materzok11} to dependent typing.
%
A control effect is either pure or impure.
%
The pure control effect $\square$ means that a computation calls no operation.
%
An impure control effect is given to a computation that may perform operations,
specifying how the execution of the computation modifies its answer type.
%
Impure control effects take the form $\tyctl{x}{C_1}{C_2}$ where variable $x$ is
bound in computation type $C_1$.
%
We write $\tyctlMB{C_1}{C_2}$ when $x$ does not occur in $C_1$.
%
In what follows, we first illustrate impure control effects in the simple,
nondependent form $\tyctlMB{C_1}{C_2}$ and then extend to the fully dependent
form $\tyctl{x}{C_1}{C_2}$ that can specify the behavior of captured
continuations using the input (denoted by $x$) to the continuations.

A control effect $\tyctlMB{C_1}{C_2}$ represents the answer type of a program
changes from type $C_1$ to type $C_2$.
%
When it is assigned to a computation $c$, the initial answer type $C_1$
specifies how the continuation of the computation $c$ up to the closest handing
construct behaves, and the final answer type $C_2$ specifies what can be
guaranteed for the \emph{meta-context}, i.e., the context of the closest
handling construct.
%
To see the idea more concretely, revisit the first example in
Section~\ref{sec:overview/atm}:
\begin{align}
	&\explet{x}{
		\expwith{
			\{ x_r \mapsto x_r, \ 
				\op((), k) \mapsto k~0 < k~1 \}
		}{1 + \op~()}
	}{c}
  ~.
\end{align}
%
Let $h$ be the handler in the example.
%
Focusing on the operation call $\op~()$, we can find that it captures the
continuation $\expwith{h}{1 + \hole}$.
%
Because the continuation behaves as if it is a pure function returning integers,
the initial answer type of $\op~()$ turns out to be the computation type
$\tycompMB{\tyint}{\square}$ (we omit $\Sigma$ for a while; it will be explained shortly).
%
Furthermore, by the operation call, the handling construct
$\expwith{h}{1+\op~()}$ is replaced with the body $k~0 < k~1$ of $\op$'s clause
in $h$ and the functional representation $v$ of the continuation is substituted
for $k$.
%
It means that the meta-context $\explet{x}{\hole}{c}$ of the operation call
takes the computation $v~0 < v~1$, which is of type
$\tycompMB{\tybool}{\square}$ (note that $v~0 < v~1$ is pure because $v$ is a
pure function).
%
Therefore, the final answer type of $\op~()$ is $\tycompMB{\tybool}{\square}$.
%
As a result, the impure control effect of $\op~()$ is
$\tyctlMB{\tycompMB{\tyint}{\square}}{\tycompMB{\tybool}{\square}}$.

\citet{Sekiyama23} extended the simple form of impure control effects to a
dependent form $\tyctl{x}{C_1}{C_2}$, where the initial answer type $C_1$ can
depend on inputs, denoted by variable $x$, to continuations.
%
For instance, consider the continuation $\expwith{h}{1 + \hole}$ captured in the
above example.
%
When passed an integer $n$, it returns $1+n$.
%
Using the dependent form of impure control effects, we can describe such
behavior by the control effect
$\tyctl{x}{\tycompMB{\tyrfn{y}{\tyint}{y=x+1}}{\square}}{\tycompMB{\tybool}{\square}}$,
where $x$ represents the input to the continuation and the refinement type
$\tyrfn{y}{\tyint}{y=x+1}$ precisely specifies the return value of the
continuation for input $x$.
%
The type of $x$ is matched with the continuation's input type.
%
Since the continuation of $\op~()$ takes integers, the type assigned to $x$ is $\tyint$.
%
In general, given a computation type $\tycompMB{T}{\tyctl{x}{C_1}{C_2}}$, the
type $T$ is assigned to the variable $x$ because it corresponds to the input type of
the continuations of computations given that computation type.
%
The type information refined by dependent impure control effects is exploited in
typechecking operation clauses.
%
In the example, our type system typechecks the body of $\op$'s clause by
assigning the function type
$\tyfun{x}{\tyint}{\tycompMB{\tyrfn{y}{\tyint}{y=x+1}}{\square}}$
to the continuation variable $k$.
%
Then, since the body is $k~0 < k~1$, its type---i.e., the final answer
type---can be refined to $\tycompMB{\tyrfn{z}{\tybool}{z=\exptrue}}{\square}$.
%
Hence, the type system can assign  control effect
$\tyctl{x}{\tycompMB{\tyrfn{y}{\tyint}{y=x+1}}{\square}}{\tycompMB{\tyrfn{z}{\tybool}{z=\exptrue}}{\square}}$
to the operation call and ensure that the meta-context takes $\exptrue$ finally
(if the handling construct terminates).
%
We will demonstrate the expressivity and usefulness of dependent control effects
in more detail in Section~\ref{sec:language/exmaples}.
%

Operation signatures, denoted by $\Sigma$, are sets of pairs of an operation
name and a type scheme.
%
We write $\repi{\cdot}$ to denote a sequence of entities indexed by $i$.
%
The type scheme associated with an operation $\op$ is in the form
$\forall \rep{X: \rep{B}}. (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2$,
where the types $T_1$ and $T_2$ are the input and output types, respectively, of the operation and the types $C_1$ and $C_2$ are
the initial and final answer types, respectively, of the operation call for $\op$.
%
Recall that the initial answer type $C_1$ corresponds to the return type
of delimited continuations captured by the call to $\op$, and that the
continuations take the return values of the operation call.
%
Therefore, the function type $(y: T_2) \rarr C_1$ represents the type of the
captured delimited continuations. Note that the variable $y$ denotes values
passed to the continuations.
%
Furthermore, the final answer type $C_2$ corresponds to the type of
the operation clause for $\op$ in the closest enclosing handler.
%
Therefore, the operation clause $\op(x, k) \mapsto c$ in the
handler is typed by checking that the body $c$ is of the type $C_2$ with the assumption that
argument variable $x$ is of the type $T_1$ and the continuation variable $k$ is
of the type $(y: T_2) \rarr C_1$.
%
A notable point of the type scheme is that it can be parameterized over
predicates. The predicate variables $\rep{X}$ abstract over the predicates, and the annotations $\rep{B}$ represent
the (base) types of the arguments to the predicates.
%
This allows calls to the same
operation in different contexts to have different control effects, which is
crucial for precisely verifying programs with algebraic effects and handlers as
we will show in Section~\ref{sec:language/exmaples}.
%
It is also noteworthy that operation signatures include not only operation names
but also type schemes as in \citet{Kammar13} and \citet{Kammar17}.
%
It allows an operation to have different types depending on the contexts
where it is used.
%
Another approach is to include only operation names and assumes that unique types
are assigned to them globally as in, e.g., \citet{Bauer13} and \citet{Leijen17}.
%
We decided to assign types to operations locally because it makes the type
system more flexible in that the types of operations can be refined depending on
contexts if needed.

Typing contexts $\Gamma$ are lists of variable bindings $x: T$
and predicate variable bindings $X: \rep{B}$.
We write $\Gamma, \phi$ for $\Gamma, x: \tyrfn{z}{B}{\phi}$
where $x$ and $z$ are fresh.
The notions of free variables, free predicate variables,
and predicate substitution are defined as usual.

\fullfalse
\iffull{
% Figure environment removed

Well-formedness of typing contexts, value types, and computation types, whose
judgments are in the forms $\jdwf{}{\Gamma}$, $\jdwf{\Gamma}{T}$, and
$\jdwf{\Gamma}{C}$, respectively, are defined straightforwardly as shown in
Figure~\ref{fig:wf}.
%
We write $\dom(\Gamma)$ for the set of variables
and predicate variables bound in the typing context $\Gamma$.
%
The well-formedness of a computation type $\tycomp{\Sigma}{T}{S}$ rests on the
well-formedness of its components, that is, the operation signature $\Sigma$,
the value type $T$, and the control effect $S$.
%
An operation signature $\Sigma$ is well-formed under a typing context $\Gamma$,
written as $\jdwf{\Gamma}{\Sigma}$, if the type schemes associated with
operations in $\Sigma$ are well-formed under $\Gamma$.
%
Note that, for every type scheme $\forall \rep{X_i: \rep{B}_i}. F$, the qualified type $F$ is a function type.
%
The well-formedness of a control effect $S$ in terms of value type $T$, written as $\jdwf{\Gamma \mid T}{S}$ with a typing context $\Gamma$,
is derived by either of the last two rules in Figure~\ref{fig:wf}.
%
When the control effect $S$ is an impure effect $\tyctl{x}{C_1}{C_2}$, the type
$T$ is assigned to the variable $x$ because $x$ denotes values passed to
continuations of computations of the type $\tycomp{\Sigma}{T}{S}$ and the passed
values are the return values of the computations.
%
Additionally, we assume that the logic for refinements is equipped with
well-formedness judgments of formulas $\jdwf{\Gamma}{\phi}$ and of predicates
$\jdwf{\Gamma}{A : \rep{B}}$.
%
The properties assumed on these judgments are stated in the supplementary
material.
%
}\else{
%
Well-formedness of typing contexts, value types, and computation types, whose
judgments are in the forms $\jdwf{}{\Gamma}$, $\jdwf{\Gamma}{T}$, and
$\jdwf{\Gamma}{C}$, respectively, are defined straightforwardly by following \citet{Sekiyama23}.
We refer to the supplementary material for detail.
%
}\fi

% Figure environment removed

Typing judgements for values and computations are in the forms $\jdty{\Gamma}{v}{T}$ and $\jdty{\Gamma}{c}{C}$,
respectively.
Figure~\ref{fig:typing} shows the typing rules.
By \rulename{T-CVar}, a variable $x$ of a refinement type is assigned a type
which states that the value of this type is exactly $x$.
For a variable of a non-refinement type (i.e., a function type in our language),
the rule \rulename{T-Var} assigns the type associated with the variable in the
typing context.
%
The rule \rulename{T-Prim} uses the mapping $\ty$ to type primitive values $p$.
We assume that $\ty$ assigns an appropriate value type to every primitive value.
%
We refer to the supplementary material for the formalization of the assumption.
%
The rule \rulename{T-Fun} for functions, \rulename{T-App} for function
applications, and \rulename{T-If} for conditional branches are standard in
refinement type systems (with support for value-dependent refinements).
%
The rules \rulename{T-VSub} and \rulename{T-CSub} allow values and computations,
respectively, to be typed at supertypes of their types.
%
We will define subtyping shortly.
%
By \rulename{T-Ret}, a value-return $\expret{v}$ has a computation type
where the operation signature is empty, the return value type is the type of $v$,
and the control effect is pure.

To type a let-expression $\explet{x}{c_1}{c_2}$, either the rule \rulename{T-LetP} or \rulename{T-LetIp} is used. Both of them
require that the types of the sub-expressions $c_1$ and $c_2$ have the same
operation signature $\Sigma$ and then assign $\Sigma$ to the type of the entire
let-expression.
%
The typing context for $c_2$ is extended by $x: T_1$ with the value
type $T_1$ of $c_1$, but $x$ cannot occur in $\Sigma$ and $T_2$ (as well as $C_{21}$ in \rulename{T-LetIp}) to prevent
the leakage of $x$ from its scope.
%
On the other hand, the two rules differ in how they treat control effects.
%
When both of the control effects of $c_1$ and $c_2$ are pure, the rule \rulename{T-LetP} is used. It states that the control effect of the entire let-expression is also pure.
%
When both are impure, the rule \rulename{T-LetIp} is used. It states that the control effect of the let-expression results in an impure control effect that is composed of the control effects of $c_1$ and $c_2$.
%
Note that, even when one of the control effects of $c_1$ and $c_2$ is pure and the other is
impure, we can view both of them as impure effects via subtyping
because it allows converting a pure control effect to an impure control
effect, as shown later.
%
We first explain how the composition works in the non-dependent form. Let
the control effect of $c_1$ be $\tyctlMB{C_{11}}{C_{12}}$ and that of $c_2$ be $\tyctlMB{C_{21}}{C_{22}}$,
and assume that a control effect $\tyctlMB{C_1}{C_2}$ is assigned to the
let-expression.
%
First, recall that the type $C_1$ expresses the return type of the continuation
of the let-expression up to the closest handling construct and that the closest
handling construct is replaced by a computation of the type $C_2$.
%
Based on this idea, the types $C_1$ and $C_2$ can be determined as follows.
%
First, because the delimited continuation of the let-expression is matched with
that of the computation $c_2$, the initial answer type $C_{21}$ of $c_2$
expresses the return type of the delimited continuation of the let-expression.
Therefore, the type $C_1$ should be matched with the type $C_{21}$.
%
Second, because the closest handling construct enclosing the let-expression is the same
as the one enclosing the sub-computation $c_1$, the type $C_2$ should be matched
with the final answer type $C_{12}$ of $c_1$.
%
Therefore, the control effect $\tyctlMB{C_1}{C_2}$ should be matched with
$\tyctlMB{C_{21}}{C_{12}}$, as stated in \rulename{T-LetIp}.
%
Furthermore, the rule \rulename{T-LetIp} requires that the
initial answer type $C_{11}$ of $c_1$ to be the same as the final answer type
$C_{22}$ of $c_2$.
%
This requirement is explained as follows.
%
First, the computation $c_1$ expects its delimited continuation to behave as
specified by the type $C_{11}$.
%
The delimited continuation of $c_1$ first evaluates the succeeding computation
$c_2$.
%
The final answer type $C_{22}$ of $c_2$ expresses that the closest
handling construct enclosing $c_2$ behaves as specified by the type $C_{22}$.
%
Because the closest handling construct enclosing $c_2$ corresponds to the
top-level handling construct in the delimited continuation of $c_1$, the
type $C_{11}$ should be matched with the type $C_{22}$.
%
We now extend to the fully dependent form.
%
From the discussion thus far, we can let
the control effects of $c_1$, $c_2$, and the let-expression be
$\tyctl{x_1}{C}{C_{12}}$, $\tyctl{x_2}{C_{21}}{C}$, and
$\tyctl{y}{C_{21}}{C_{12}}$ respectively, for some variables $x_1$, $x_2$, and $y$.
%
Then, the constraints on the names of these variables are determined as follows.
%
First, the input to the delimited continuation of $c_1$, which is denoted by the variable $x_1$,
should be matched with the evaluation result of $c_1$.
%
Then, since the let-expression binds the variable $x$ to the evaluation result of $c_1$,
the variable $x_1$ is matched with $x$.
%
Second, because the delimited continuation of $c_2$ is matched with
that of the let-expression, the inputs to them should be matched with each other.
%
They are denoted by the variables $x_2$ and $y$ respectively, and hence the variable $x_2$ is matched with $y$.

The rule \rulename{T-Hndl} for handling constructs $\expwith{h}{c}$
is one of the most important rules of our system.
%
It assumes that the handled computation $c$ is of a type
$\tycomp{\Sigma}{T}{\tyctl{x_r}{C_1}{C_2}}$, where the control effect is impure.
%
Even when $c$ is pure (i.e., performs no operation), it can have an impure control effect via subtyping.
%
Because the type of the handling construct represents how the expression is
viewed from the context, it should be matched with the final answer type $C_2$
of the handled computation $c$.
%
The premises in the second line define typing disciplines that the clauses in the installed handler $h$ have to satisfy.
%
First, let us consider the return clause $\expret{x_r} \mapsto c_r$.
%
Because the variable $x_r$ denotes the return value of the handled
computation $c$, the value type $T$ of $c$ is assigned to $x_r$.
%
Moreover, since the return clause is executed after evaluating $c$, the body
$c_r$ is the delimited continuation of $c$.
%
Therefore, the type of $c_r$ should be matched with the initial answer type $C_1$
of $c$.
%
Because the variable $x_r$ bound in the return clause can be viewed as the input
to the delimited continuation $c_r$, it should be matched with the
variable $x_r$ bound in the impure control effect $\tyctl{x_r}{C_1}{C_2}$.
%
Operation clauses are typed using the corresponding type schemes in the
operation signature $\Sigma$, as explained above.
%
Note that the rule also requires the installed handler $h$ to include a clause
for each of the operations in $\Sigma$, i.e., those that $c$ may perform.

The rule \rulename{T-Op} for operation calls is
another important rule.
%
Consider an operation call $\op~v$.
%
The rule assumes that an enclosing handler addresses the operation $\op$
by requiring that an operation signature $\Sigma$ assigned to the operation call
include the operation $\op$ with a type scheme
$\forall \rep{X: \rep{B}}. (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2$,
and instantiates the predicate
variables $\rep{X}$ in the type scheme with well-formed predicates $\rep{A}$ to
reflect the contextual information of the operation call.
%
Then, it checks that the argument $v$ has the input type $T_1[\rep{A/X}]$ of the
operation.
%
Finally, the rule assigns the output type $T_2[\rep{A/X}][v/x]$ of the operation
as the value type of the operation call, and $C_1[\rep{A/X}][v/x]$ and
$C_2[\rep{A/X}][v/x]$ as the initial and final answer types of the operation call, respectively
(note that the types $T_2$, $C_1$, and $C_2$ are parameterized over predicates and arguments).

% Figure environment removed

The type system defines four kinds of subtyping judgments:
$\jdsub{\Gamma}{T_1}{T_2}$ for value types,
$\jdsub{\Gamma}{C_1}{C_2}$ for computations types,
$\jdsub{\Gamma}{\Sigma_1}{\Sigma_2}$ for operation signatures, and
$\jdsub{\Gamma \mid T}{S_1}{S_2}$ for control effects.
%
Figure~\ref{fig:subty} shows the subtyping rules.
%
The subtyping rules for control effects are adopted from the work of \citet{Sekiyama23},
which extends subtyping for control effects given by \citet{Materzok11} to
dependent typing.
%
The rules \rulename{S-Rfn} and \rulename{S-Fun} for value types are standard.
%
The judgement $\valid{\Gamma}{\phi}$ in \rulename{S-Rfn} means
the semantic validity of the formula $\phi$ under the assumption $\Gamma$.
%
Subtyping between operation signatures is determined by \rulename{S-Sig}.
%
This rule is based on the observation that an operation signature $\Sigma$
represents the types of operation clauses in handlers, as seen in
\rulename{T-Hndl}.
%
Then, the rule \rulename{S-Sig} can be viewed as defining a subtyping relation between
the types of handlers (except for return clauses): a handler for operations in
$\Sigma_1$ can be used as one for operations in $\Sigma_2$ if every operation
$\op$ in $\Sigma_2$ is included in $\Sigma_1$ (i.e., the handler has an
operation clause for every $\op$ in $\Sigma_2$) and the type scheme of $\op$ in
$\Sigma_1$ is a subtype of the type scheme of $\op$ in $\Sigma_2$ (i.e., the
operation clause for $\op$ in the handler works as one for $\op$ in $\Sigma_2$).
%
Given a computation type $C_1 \defeq \tycomp{\Sigma_1}{T_1}{S_1}$ and its
supertype $C_2 \defeq \tycomp{\Sigma_2}{T_2}{S_2}$, a handler for operations
performed by the computations of the type $C_2$ (i.e., the operations in
$\Sigma_2$) is required to be able to handle operations performed by the
computations of the type $C_1$ (i.e., the operations in $\Sigma_1$) because the
subtyping allows deeming the computations of $C_1$ to be of $C_2$.
%
The safety of such handling is ensured by requiring $\Sigma_2 <: \Sigma_1$.
%
In the rule \rulename{S-Comp}, the first premise represents this requirement.
%
The second premise $\jdsub{\Gamma}{T_1}{T_2}$ in \rulename{S-Comp} allows
viewing the return values of the computations of the type $C_1$ as those of the
type $C_2$.
%
The third premise $\jdsub{\Gamma \mid T_1}{S_1}{S_2}$ expresses that the use of
effects by the computations of the type $C_1$ is subsumed by the use of effects
allowed by the type $C_2$.
%
It is derived by the last three rules: \rulename{S-Pure},
\rulename{S-ATM}, and \rulename{S-Embed}.
%
The rule \rulename{S-Pure} just states reflexivity of the pure control effect.
%
If both $S_1$ and $S_2$ are impure, the rule \rulename{S-ATM} is applied.
%
Because initial answer types represent the assumptions of computations
on their contexts, \rulename{S-ATM} allows strengthening the assumptions by
being contravariant in them.
%
By contrast, because final answer types represent the guarantees of how
enclosing handling constructs behave, \rulename{S-ATM} allows weakening the
guarantees by being covariant in them.
%
Note that the typing context for the initial answer types is extended
with the binding $x : T_1$ because they may reference the inputs to the
continuations via the variable $x$ and the inputs are of the type
$T_1$.
%
Finally, the rule \rulename{S-Embed} allows converting the pure control effect
to an impure control effect $\tyctl{x}{C_1}{C_2}$.
%
Because a computation $c$ with the pure control effect performs no operation,
what is guaranteed for the behavior of the handling construct enclosing $c$
coincides with what is assumed on $c$'s delimited continuation.
%
Because the guarantee and assumption are specified by the types $C_2$ and
$C_1$, respectively, if $C_1$ is matched with $C_2$---more generally, the
``assumption'' $C_1$ implies the ``guarantee'' $C_2$---the pure computation
$c$ can be viewed as the computation with the impure control effect
$\tyctl{x}{C_1}{C_2}$.
%
The first premise in \rulename{S-Embed} formalizes this idea.
%
Note that, because the variable $x$ is bound in the type $C_1$, the rule
\rulename{S-Embed} disallows $x$ to occur in the type $C_2$.

Finally, we state the type safety of our system. Its proof, via progress and subject reduction, is given in the supplementary material.
We define $\eval^*$ as the reflexive, transitive closure of the one-step evaluation relation $\eval$.
\begin{theorem}[type safety] \label{thm:safety}
    If\, $\jdty{\emptyset}{c}{\tycomp{\Sigma}{T}{S}}$ and $c \eval^* c'$, then one of the following holds:
    % \begin{itemize}
    (1) $c' = \expret{v}$ for some $v$ such that $\jdty{\emptyset}{v}{T}$;
    (2) $c' = K[\op~v]$ for some $K$, $\op$, and $v$ such that $\op \in \dom(\Sigma)$; or
    (3) $c' \eval c''$ for some $c''$ such that $\jdty{\emptyset}{c''}{\tycomp{\Sigma}{T}{S}}$~.
    % \end{itemize}
\end{theorem}
