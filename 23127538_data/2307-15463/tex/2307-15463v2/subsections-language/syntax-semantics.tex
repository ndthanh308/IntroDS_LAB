\subsection{Syntax and Semantics} \label{sec:language/syntax-semantics}

The upper half of Figure~\ref{fig:syntax-eval} shows the syntax of our language.
It indicates that expressions are split into values, ranged over by $v$, and computations, ranged over by $c$,
as in the fine-grain call-by-value style of \citet{Levy03}.
Values, which are effect-free expressions in a canonical form,
consist of variables $x$, primitive values $p$,
and (recursive) functions $\exprec{f}{x}{c}$
where variable $f$ denotes the function itself for recursive calls in the body $c$.
If $f$ does not occur in $c$, we simply write $\lambda x. c$.
Computations, which are possibly effectful expressions,
consist of six kinds of constructs.
A value-return $\expret{v}$ lifts a value $v$ to a computation.
An operation call $\op~v$ performs the operation $\op$ with the
argument $v$.
A function application $v_1~v_2$, conditional branch $\expif{v}{c_1}{c_2}$,
and let-expression $\explet{x}{c_1}{c_2}$ are standard.
Note that functions, arguments, and conditional expressions are
restricted to values, but this does not reduce expressivity because, e.g.,
a conditional branch $\expif{c}{c_1}{c_2}$ can be expressed as
$\explet{x}{c}{\expif{x}{c_1}{c_2}}$ using a fresh variable $x$.
A handling construct $\expwith{h}{c}$ handles operations performed during the
evaluation of the handled computation $c$ using the clauses in the handler $h$.
A handler $\{ \expret{x_r} \mapsto c_r, \repi{\op_i(x_i, k_i) \mapsto c_i} \}$
has a return clause $\expret{x_r} \mapsto c_r$ where the variable $x_r$ denotes
the value of the handled computation $c$, and an operation clause
$\op_i(x_i, k_i) \mapsto c_i$ for each operation $\op_i$ where the variables
$x_i$ and $k_i$ denote the argument to $\op_i$ and the continuation from the
invocation of $\op_i$, respectively.
The notions of free variables and substitution are defined as usual.
We write $c[v/x]$ for the computation obtained by substituting the value $v$ for
the variable $x$ in the computation $c$.  We use similar notation to substitute
values for variables in types and substitute types for type variables.

\newif\ifshowsemantics \showsemanticstrue
\ifshowsemantics{
%
% Figure environment removed

The semantics of the language is defined by the evaluation relation $\eval$,
which is the smallest binary relation over computations satisfying the
evaluation rules in the lower half of Figure~\ref{fig:syntax-eval}.
The evaluation of a let-expression $\explet{x}{c_1}{c_2}$ begins by
evaluating the computation $c_1$.
When $c_1$ returns a value, the computation $c_2$ evaluates after substituting
the return value for $x$.
The evaluation rules for conditional branching and function application are
standard.
The result of applying a primitive value relies on the metafunction $\zeta$,
which maps pairs of a primitive value and an argument value to computations.
For a handling construct $\expwith{h}{c}$, the handled computation $c$
evaluates first.
When $c$ returns a value, the body of the return clause in the handler $h$
evaluates with the return value.
If the evaluation of $c$ encounters an operation call $\op_i~v$,
its delimited continuation, which is represented as a pure evaluation context $K$ defined in Figure~\ref{fig:syntax-eval}, is captured.
Then, the body $c_i$
of the operation clause $\op_i(x_i, k_i) \mapsto c_i$ for $\op_i$ in the handler
$h$ evaluates after substituting the argument $v$ and the function
$\lambda y. \expwith{h}{K[\expret{y}]}$ for variables $x_i$ and $k_i$, respectively.
%
Note that the function
substituted for $k_i$ wraps
the delimited continuation $K[\expret{y}]$ by the handling construct
with the handler $h$.
It means that the operation calls in $K[\expret{y}]$ are handled by the handler $h$.
%
Our semantics assumes that the handler $h$
provides operation clauses for all the operations performed by the handled
computation $c$.
%
}
\else{
%
The semantics of the language is defined by the evaluation relation $\eval$,
which is a binary relation over computations.
%
It is mostly identical to the semantics given by \citet{Pretnar15}; we refer to the supplementary material for its definition.
%
The only difference is that Pretnar's semantics allows handlers
that do not involve clauses for operations performed by a handled
computation---a call to such an operation is forwarded to outer
handlers---whereas our semantics assumes handlers to contain clauses for all such operations.
}\fi
%
Our type system ensures that this assumption holds on any well-typed computations.
However, our language can also implement the forwarding semantics by encoding: given a handler
that does not contain an operation clause for $\op$, we add to the handler
an operation clause $\op(x,k) \mapsto \explet{y}{\op~x}{k~y}$.\footnote{We employ the semantics without forwarding in the body of the paper to simplify the typing rule for handling constructs. The supplementary material shows an extended typing rule for handling constructs that natively supports forwarding.}
%
