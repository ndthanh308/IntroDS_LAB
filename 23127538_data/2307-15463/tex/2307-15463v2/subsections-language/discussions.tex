\subsection{Discussion} \label{sec:language/discussions}
In this section, we discuss the current limitations and future extensions of our system.

\subsubsection{Abstraction of Effects}
Our type system has no mechanism for abstraction of effects.
Therefore, if we cannot know possible effects of the handled computation in advance
(e.g., as in $\lambda f. \expwith{h}{(f~())}$, where the effects of the handled computation $f~()$ are determined by function parameter $f$),
we have to fix its effects (both the operation signature and the control effect).
A possible way to address this issue is to incorporate some mechanism to abstract effects.
For operation signatures, effect polymorphism as in the existing effect systems
for algebraic effects and handlers~\cite{Leijen17,Lindley17}, is a promising solution.
%
However, adapting it to our system is not trivial.
%
Effect polymorphism enables specifying a part of an operation signature as a
parameter, and handling constructs implicitly forward operations in the
parameter.
%
The problem is that \emph{our type system modifies the type schemes of forwarded
operations} (see the supplementary material for detail). Therefore, even though
the type schemes are involved in an operation signature parameter, we need to
track how they are modified.
%
We leave addressing this challenge for future work.
%
For control effects, we conjecture that bounded polymorphism can be used
to abstract control effects while respecting the necessary sub-effecting constraints.

\subsubsection{Combination with Other Computational Effects}
Algebraic effects and handlers are sometimes used with other computational effects.
For example, when implementing a scheduler with algebraic effects and handlers,
an imperative queue is often used to keep suspended continuations, like in an example from \citet{MulticoreOCamlrepo}.
Even though some computational effects can be simulated
by algebraic effects and handlers themselves,
it is often convenient to address them as primitive operations for efficiency.
Our system does not support such primitive computational effects.
It is left for future work to combine these features in one system.

\subsubsection{Shallow Handlers}
The handlers we adopt in this work are called \emph{deep handlers}~\cite{Kammar13},
which is the most widely used variant.
Another variant of algebraic effect handlers is \emph{shallow handlers}~\cite{Hillerstrom18},
which
we do not address in the present work.
%
Just as deep handlers are related to shift0/reset0,
shallow handlers are related to control0/prompt0~\cite{Pirog19}.
Therefore, the type system for control0/prompt0 with ATM~\cite{Ishio22} may be adapted
to develop a refinement type system for shallow handlers,
as we have developed our refinement type system for deep handlers
based on the type systems for shift0/reset0 with ATM~\cite{Materzok11, Sekiyama23}.

\subsubsection{Recursive Computation Types}
Some useful programs with algebraic effect handlers are ill typed in our system due to the lack of support for recursive computation types.
For example, consider the following program:
\begin{align}
    \exprec{f}{n}{
        \expwith{
            h
        }
        {\expif{n = 0}{\op[Err]~\text{\texttt{"error"}}}{f~(n - 1)}}
    }
\end{align}
where $h \defeq \{ \op[Err](msg, k) \mapsto
\op[Err]~(\text{\texttt{sprintf "called at \%d. \%s"}}~n~msg) \}$~.
This recursive function handles the error in each function call,
producing its own stack trace.
It cannot be typed without recursive types
because the type of the handled computations appears recursively as its answer type.
To see this, assume that the type of the handled computation (i.e., the conditional branch)
is assigned a type $\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}$
(here we consider only simple types for simplicity).
Then, the type of the handling construct (i.e., the body of the function) is $C_2$,
which implies that the overall function has type $\tyint \rarr C_2$.
And so, the recursive call to the function $f~(n - 1)$ also has type $C_2$.
Then, the type $C_2$ should be a subtype of $\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}$
since $f~(n - 1)$ is the else-branch of the conditional branch.
However, we cannot derive $\jdsub{\Gamma}{C_2}{\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}}$
(for some $\Gamma$) in our system
because while the type on the left-hand side is $C_2$ itself,
$C_2$ appears as the answer type in the control effect of the type on the right-hand side.
On the other hand, using recursive types, we can give this function the following type
(again, we consider only simple types for simplicity):
$\tyint \rarr \mu \alpha. \tycomp{\Sigma_\alpha}{T}{\tyctlMB{T}{\alpha}}$
where $\Sigma_\alpha \defeq \{ \op[Err] : \tystr \rarr (T \rarr T) \rarr \alpha \}$ and $T$ is an arbitrary value type.
Type $\mu \alpha. C$ denotes a recursive computation type
where the type variable $\alpha$ refers to the whole type itself.
The control effect of this type is recursively nested,
which reflects the fact that the handling construct is recursively nested
due to the recursive call to the function.

\subsubsection{Type Polymorphic Effect Operations}
Consider the following program that evaluates to $[[21]]$:
\begin{align}
    &\expwith{\{ x_r \mapsto x_r,
    \op[wrap]((), k) \mapsto [k~()]\}}
    {(\op[wrap]~(); \op[wrap]~(); 21)}
\end{align}
This does not type-check in our current system because a type polymorphic operation signature like $\Sigma \defeq \{ \op[wrap]: \forall \alpha. \tyunit \rarr (\tyunit \rarr \tycompMB{\alpha}{S}) \rarr \tycompMB{\alpha~\tylist}{S'} \}$ is required.  It is, however, easy to extend our type system to support type polymorphic operation signatures to handle such examples. Specifically, in the typing of operation clauses $c_i$ in the \rulename{T-Hndl} rule, one would generalize type variables, and in the \rulename{T-Op} rule, one would instantiate type polymorphism.

\subsubsection{Modularity (or Abstraction) versus Preciseness (or Concreteness)}
In our system, operation signatures are of the form $\op_i : T_i \rarr (T_i' \rarr C_i) \rarr C_i'$ where the types $C_i$ and $C_i'$ represent behavior of the effect handler. In other words, the signature reveals specific implementation details regarding effect handlers. This design, from our perspective of precise specification and verification, is valuable. Indeed, our type system can formally specify and verify the assume-guarantee-like contracts between the handler and operation-call sides.
%
However, from the perspective of modularity and abstraction, this design choice is not the optimal one. In fact, one of the purposes of effect handlers is to abstract away the specifics so that one could later choose a different implementation.

To ensure that the handler implementation details do not leak in the operation signatures, one can introduce computation type polymorphism: The types $C_i$ and $C_i'$ in the operation signature above will be replaced by computation type variables, thus hiding the details.
%
However, completely hiding the information of handler implementations in this way implies that we are not providing and verifying a detailed specification requirement for the handler implementations.

Practically speaking, rather than the two extremes, we believe that it is engineering-wise desirable to allow for a gradient between modularity (abstraction) and preciseness (concreteness) and to describe and verify types at the appropriate level of detail depending on the use case. Introducing all the polymorphisms discussed in this section might achieve this goal, but we plan to investigate whether it is indeed the case by specifying and verifying various real-world programs. In our view, the issue of how to describe types at an appropriate level of abstraction, as discussed above, is an important open problem not just for algebraic effects but for general control operators and, more broadly, for effectful computation.
