\section{Related Work} \label{sec:related}

\subsection{Algebraic Effects and Handlers} \label{sec:related/algeff}
%
Algebraic effect handlers introduced by \citet{Plotkin13} turned out to be
greatly expressive, which have inspired researchers and programming language
designers and leads to a variety of
implementations~\cite{Bauer15,Leijen17,Lindley17,Sivaramakrishnan21,Brady13,Kammar13}.
For advanced verification of algebraic effects and handlers, \citet{Ahman17}
proposed a dependent type system for algebraic effects and
handlers. \citet{Brady13} introduced algebraic effect handlers to Idris, a
dependently typed programming language.
%
In contrast to our system, these systems do not allow initial answer types to depend
on values passed to continuations.  \citet{Ahman15} investigated an algebraic
treatment of computational effects with refinement types, but their language
is not equipped with effect handlers.  To our knowledge, there is no research focusing
on refinement type systems with support for algebraic effect handlers and their
implementations for automated verification.

\citet{Cong22} provided a type system with ATM for algebraic effect handlers
in a simply typed setting.
%
Compared with ours, their system is limited in a few points.
%
First, it allows programs to use only one operation.
%
Second, the operation can be invoked two or more times only when it is handled
by an effect handler where the result types of the return and operation clause
are the same.
%
This limitation is particularly critical for our aim, program verification,
because it means that there is no way to track the state of continuations that
changes with the execution of programs.
%
For instance, the examples presented in Section~\ref{sec:language/exmaples}
cannot be verified under such a restriction because they include multiple calls
to an operation and each call changes the state of continuations.
%
Our type system has none of these limitations---it supports multiple operations
and an unlimited number of calls to operations even under a handler with clauses
of different types.
%
The key idea of our system to allow such a handler is to introduce the
abstraction of operation clauses over predicates.
%
By this abstraction, our type system can represent how the same operation clause
behaves differently under different continuations.
%

Our CPS transformation is based on \citet{Hillerstrom17}. They defined a CPS transformation from a language
with effect handlers but without dependent/refinement types,
and proved that it enjoys forward type-preservation, but they, and others, such
as \citet{Cong22}, who studied CPS transformation for effect handlers, did not
consider the backward direction.
Their transformation also assumes that programs are fully annotated with types.

\subsection{Type Systems for Other Delimited Control Operators} \label{sec:related/control}

ATM was proposed by \citet{Danvy90} to type more expressions
with the delimited control operators shift/reset.
\citet{Cong18} proposed a dependent type system for shift/reset,
where initial answer types cannot depend on
values passed to continuations.
A type system with ATM for another set of delimited control operators shift0/reset0,
is developed by \citet{Materzok11}.
They proposed a new subtyping relation that allow lifting pure expressions to impure ones.
Based on their work,
\citet{Sekiyama23} proposed a refinement type system for shift0/reset0.
Their type system utilizes ATM for reasoning about traces (sequences of events) precisely.
In their system, initial answer types \emph{can} depend on
values passed to continuations.
Our control effects are inspired by their work, but
they use the dependency of control effects mainly for reasoning about traces while we use it for refining properties of values.
Their target operators shift0/reset0 are closely related to
our target operators, algebraic effect handlers~\cite{Forster17,Pirog19}.
%
However, naively applying their approach to algebraic effect handlers does not
enable precise verification.  A critical difference between shift0/reset0 and
algebraic effect handlers is that, while shift0/reset0 allows deciding the usage
of captured delimited continuations per each call site of the
continuation-capture operator shift0, algebraic effect handlers require all the
calls to the same operation under a handler $h$ to be interpreted by the same
operation clause in $h$. This hinders precise verification of the use of
continuations per each operation call. Our type system solves this problem by
abstracting the type schemes of operations over predicates.
