\pdfoutput=1
\newif\iffull \fullfalse

\documentclass[acmsmall, screen, authorversion]{acmart}

%%% The following is specific to POPL '24 and the paper
%%% 'Answer Refinement Modification: Refinement Type System for Algebraic Effects and Handlers'
%%% by Fuga Kawamata, Hiroshi Unno, Taro Sekiyama, and Tachio Terauchi.
%%%
\setcopyright{rightsretained}
\acmDOI{10.1145/3633280}
\acmYear{2024}
\copyrightyear{2024}
\acmSubmissionID{popl24main-p20-p}
\acmJournal{PACMPL}
\acmVolume{8}
\acmNumber{POPL}
\acmArticle{5}
\acmMonth{1}
\received{2023-07-11}
\received[accepted]{2023-11-07}

\citestyle{acmauthoryear}
% \citestyle{acmnumeric}

\usepackage{proof}
\usepackage{mathtools}
\mathtoolsset{showonlyrefs=true}

\usepackage{multirow}
\usepackage{wrapfig}

\usepackage{bussproofs}
\usepackage{stackengine}

\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows.meta}

\usepackage{thelanguage}
% \newcommand*{\defeq}{\stackrel{\text{def}}{=}}
\newcommand*{\defeq}{\triangleq}
\newcommand{\rulename}[1]{(\textsc{#1})}
\newcommand{\infersc}[3][]{\infer[\!\!\text{\rulename{#1}}]{#2}{#3}}


\begin{document}

\title{Answer Refinement Modification: Refinement Type System for Algebraic Effects and Handlers}

\author{Fuga Kawamata}
\orcid{0009-0003-4147-9572}
\affiliation{%
  \institution{Waseda University}
  \city{Tokyo}
  \country{Japan}
}
\email{maple-river@fuji.waseda.jp}

\author{Hiroshi Unno}
\orcid{0000-0002-4225-8195}
\affiliation{%
  \institution{University of Tsukuba}
  \city{Tsukuba}
  \country{Japan}
}
\email{uhiro@cs.tsukuba.ac.jp}

\author{Taro Sekiyama}
\orcid{0000-0001-9286-230X}
\affiliation{%
  \institution{National Institute of Informatics}
  \city{Tokyo}
  \country{Japan}
}
\email{ryukilon@gmail.com}

\author{Tachio Terauchi}
\orcid{0000-0001-5305-4916}
\affiliation{%
  \institution{Waseda University}
  \city{Tokyo}
  \country{Japan}
}
\email{terauchi@waseda.jp}

% \renewcommand{\shortauthors}{Kawamata et al.}

\begin{abstract}
Algebraic effects and handlers are a mechanism to structure
programs with computational effects in a modular way. They
are recently gaining popularity and being adopted in practical languages,
such as OCaml.
%
Meanwhile, there has been substantial progress in program verification via {\em
refinement type systems}.  While a variety of
refinement type systems have been proposed, thus far there has not been a
satisfactory refinement type system for
algebraic effects and handlers.  In this paper, we fill the void by proposing a
novel refinement type system for languages with algebraic effects and handlers.
%
The expressivity and usefulness of algebraic effects and handlers come
from their ability to manipulate \emph{delimited continuations}, but delimited continuations also complicate programs'
control flow and make their verification harder.
%
To address the complexity,
we introduce a novel concept that we call {\em answer refinement modification} (ARM for
short), which allows the refinement type system to precisely track what effects occur and in what order when a program is executed, and reflect such information as modifications to the refinements in the types of delimited continuations.
%
We formalize our type system that supports ARM (as well as answer \emph{type} modification, or ATM) and prove its soundness. Additionally, as a proof of concept, we have
extended the refinement type system to a subset of OCaml 5 which comes with a built-in support for effect handlers,
implemented a type checking and inference algorithm for the extension,
and evaluated it on a number of benchmark programs that use algebraic effects and handlers.
The evaluation demonstrates that ARM is conceptually simple and practically useful.

Finally, a natural alternative to directly reasoning about a program with delimited continuations is to apply a {\em continuation passing style} (CPS) transformation that transforms the program to a pure program without delimited continuations.  We investigate this alternative in the paper, and show that the approach is indeed possible by proposing a novel CPS transformation for algebraic effects and handlers that enjoys bidirectional (refinement-)type-preservation.  We show that there are pros and cons with this approach, namely, while one can use an existing refinement type checking and inference algorithm that can only (directly) handle pure programs, there are issues such as
needing type annotations in source programs and
making the inferred types less informative to a user.
\end{abstract}

%% > The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% > Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10011740</concept_id>
       <concept_desc>Theory of computation~Type theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
       <concept_desc>Software and its engineering~Functional languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011024.10011027</concept_id>
       <concept_desc>Software and its engineering~Control structures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010138.10010142</concept_id>
       <concept_desc>Theory of computation~Program verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010125.10010126</concept_id>
       <concept_desc>Theory of computation~Control primitives</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Type theory}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Control structures}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[500]{Theory of computation~Control primitives}

%% > Keywords. The author(s) should pick words that accurately describe
%% > the work being presented. Separate the keywords with commas.
\keywords{algebraic effects and handlers, type-and-effect system, refinement type system, answer type modification, answer refinement modification, CPS transformation}


\maketitle

\input{intro.tex}

\input{overview.tex}

\input{language.tex}

\input{impl.tex}

\input{cps.tex}

\input{related.tex}

\input{conclusion.tex}

\section*{Data-Availability Statement}
Our artifact is available in the GitHub repository, at \url{https://github.com/hiroshi-unno/coar}.
The experimental results shown in Table~\ref{tab:eval} and Table~\ref{tab:cps}
can be reproduced by following the instructions in \texttt{popl24ae/README.md} of the repository.

\begin{acks}
We are grateful to anonymous reviewers for their helpful and useful comments on the paper,
especially regarding its presentation.
We also thank Yiyang Guo and Kanaru Isoda for their contribution to our implementation.
%
This work was supported by \grantsponsor{JSPS}{JSPS}{} KAKENHI Grant Numbers
\grantnum{JSPS}{JP19K20247}, % Sekiyama Kakenhi 1
\grantnum{JSPS}{JP22K17875}, % Sekiyama Kakenhi 2
\grantnum{JSPS}{JP20H00582}, % Igarashi Kakenhi
\grantnum{JSPS}{JP20H04162}, % Unno Kaken
\grantnum{JSPS}{JP22H03564}, % Tsukada Kaken
\grantnum{JSPS}{JP20H05703}, % Kobayashi Kaken
\grantnum{JSPS}{JP20K20625}, % Terauchi Kaken
and
\grantnum{JSPS}{JP22H03570}  % Terauchi Kaken
as well as
\grantsponsor{JST}{JST}{} CREST Grant Number \grantnum{JST}{JPMJCR21M3}.
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

% \input{appendix.tex}

\end{document}
\endinput
