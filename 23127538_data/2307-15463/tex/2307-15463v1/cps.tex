\section{CPS Transformation} \label{sec:cps}

\subsection{Definitions and Properties} \label{sec:cps/def}

This section presents the crux of our CPS transformation that translate the
language defined in Section~\ref{sec:language} to a $\lambda$-calculus without
effect handlers.
%
Readers interested in the complete definitions of the target language and the
CPS transformation are referred to the supplementary material.

% Figure environment removed

The target language of the CPS transformation is a polymorphic
$\lambda$-calculus with records and recursion.
Its program and type syntax are defined as follows:
%
\[\begin{array}{rcl}
 v &::=& x \mid p \mid \exprec{f:T_1}{x:T_2}{c} \mid \lambda x. c \mid \Lambda \rep{X: \rep{B}}. c \mid \{ \repi{\op_i = v_i} \} \mid \Lambda \alpha. c \\
 c &::=& v \mid c~v \mid \expif{v}{c_1}{c_2} \mid v~\rep{A} \mid v\#\op \mid v~\nmbullet \mid (c : \tau) \\
 \tau &::=& \tyrfn{x}{B}{\phi} \mid (x: \tau_1) \rarr \tau_2 \mid \forall \rep{X: \rep{B}}. \tau
        \mid \{ \repi{\op_i : \tau_i} \} \mid \alpha \mid \forall \alpha. \tau
  \end{array}
\]
%
In the target language, values are not strictly separated from expressions as
those in the source language; for example, functions in function applications
can be expressions.
%
The metavariables $\alpha$ and $\beta$ range over type variables.  Expressions
$\Lambda \alpha. c$ and $v~\nmbullet$ are a type abstraction and application,
respectively. Type arguments in type applications are not given explicitly; they
are assumed to be inferred during the typechecking.
%
Type polymorphism is introduced to express the pure control effect in the target
language using \emph{answer type polymorphism}~\cite{Thielecke03}.
%
Expressions $\{ \repi{\op_i = v_i} \}$ and $v\#\op$ are a record literal and
projection, respectively.
%
We use operation names as record labels for the target language to encode
handlers using records.
%
Our CPS transformation produces programs with type annotations for proving
bidirectional type-preservation. Recursive functions with type annotations and
type ascriptions $(c : \tau)$ are used to annotate programs.
%
We abbreviate $\exprec{f:T_1}{x:T_2}{c}$ to $\lambda x: T_2. c$ if $f$ does not
occur in $c$.
%
Types are defined in a standard manner.
%
Typing contexts $\Gamma$ are extended to include type variables.  The type
system is also standard, except for the typing rule for type applications, which
is presented in Figure~\ref{fig:subty-cps-excerpt}.  We write $\jdwf{\Gamma}{\tau}$ to
state that all the free variables (including type and predicate variables) in
the type $\tau$ are bound in the typing context $\Gamma$.
%
The subtyping for record types allows supertypes to forget some fields in
subtypes, and the types of each corresponding field in two record types to be in
the subtyping relation (we deem record types, as well as records, to be
equivalent up to permutation of fields).
%
The subtyping rule for type polymorphism is a weaker variant of the containment
rule for polymorphic types~\cite{Mitchell88}.
%
It is introduced to emulate \rulename{S-Embed} in the target language.

% Figure environment removed

We show the key part of the CPS transformation in
Figure~\ref{fig:cps-trans-excerpt}.
%
The upper half presents the transformation of types.
%
The transformation of value types is straightforward.  Operation signatures are
transformed into record types, which means that operation clauses in a handler
are transformed into a record.
%
The transformations of computation types indicate that computations are
transformed into functions that receive two value parameters: handlers and
continuations.
%
If the control effect is pure, the answer types of computations become
polymorphic in CPS.
%
This treatment of control effects is different from that of \citet{Materzok11},
who define CPS transformation for control effects in the
simply typed setting.
%
Their CPS transformation transforms, in our notation,
%
a computation type $\tycompMB{T}{\square}$ (note that their computation types do
not involve operation signatures) into the type $\cps{T}$, and
%
a type $\tycompMB{T}{\tyctlMB{C_1}{C_2}}$ (again note that they do not consider
dependent typing) into the type $\tyfunshort{(\tyfunshort{\cps{T}}{\cps{C_1}})}{\cps{C_2}}$.
%
Because the latter takes continuations whereas the former does not, CPS
transformation needs to know where pure computations are converted into impure
ones (via subtyping).
%
To address this issue, Materzok and Biernacki's CPS transformation focuses on
typing derivations in the source language rather than expressions.
%
However, because our aim is at reducing the typing of programs with
algebraic effects and handlers to that of programs without them,
we cannot assume typing derivations in the source language to be available.
%
By treating two kinds of control effects uniformly using answer type
polymorphism, our CPS transform can focus only on expressions (with type
annotations).

The lower half of Figure~\ref{fig:cps-trans-excerpt} shows the key cases of the
transformation of expressions.
%
For backward type-preservation (Theorem~\ref{thm:cps-backward-excerpt}), we
extend the source language with type annotations.
%
For example, in an operation call $\expop[\op^{\rep{\mathit{A}}}]{v}{y^{T_y}}{c^{\tycomp{\Sigma}{T}{\tyctl{z}{C_1}{C_2}}}}$,
$\rep{\mathit{A}}$ are predicates used to instantiate the type scheme of the operation $\op$,
$T_y$ is the output type of $\op$, and
$\tycomp{\Sigma}{T}{\tyctl{z}{C_1}{C_2}}$ is the type of the continuation $c$.
%
Without type annotations, CPS-transformed expressions may have a type that
cannot be transformed back to a type in the source language.
%
An operation call $\expop[\op^{\rep{\mathit{A}}}]{v}{y^{T_y}}{c^{\tycomp{\Sigma}{T}{\tyctl{z}{C_1}{C_2}}}}$
is transformed into a function that seeks the corresponding
operation clause in a given handler and then applies it to a given sequence of
predicates, argument, and continuation.
%
An expression $\expwith{h}{c}$ is transformed into a function that applies the
CPS-transformed handled computation to the record of the CPS-transformed
operation clauses and the CPS-transformed return clause (because the return
clause works as the continuation of $c$).

Now, we state forward and backward type-preservation of the CPS transformation.
%
\begin{theorem}[Forward type-preservation] \label{thm:cps-forward-excerpt}
    \hspace*{10pt}
    \begin{itemize}
        \item If\, $\jdty{\Gamma}{v}{T}$ then $\jdty{\cps{\Gamma}}{\cps{v}}{\cps{T}}$.
        \item If\, $\jdty{\Gamma}{c}{C}$ then $\jdty{\cps{\Gamma}}{\cps{c}}{\cps{C}}$.
    \end{itemize}
\end{theorem}

\begin{theorem}[Backward type-preservation] \label{thm:cps-backward-excerpt}
    \hspace*{10pt}
    \begin{itemize}
     \item If\, $\jdty{\emptyset}{\cps{v}}{\tau}$, then
           there exists some $T$ such that
           $\jdty{\emptyset}{v}{T}$ and
           $\jdsub{\emptyset}{\cps{T}}{\tau}$.
     \item If\, $\jdty{\emptyset}{\cps{c}}{\tau}$, then
           there exists some $C$ such that
           $\jdty{\emptyset}{c}{C}$ and
           $\jdsub{\emptyset}{\cps{C}}{\tau}$.
    \end{itemize}
\end{theorem}
%
\noindent
Theorem~\ref{thm:cps-backward-excerpt} is implied immediately by backward type
preservation of the CPS transformation for \emph{open} expressions.
See the supplementary material for the statement for open expressions.
%
Theorem~\ref{thm:cps-backward-excerpt} indicates that it is possible to reduce
typechecking in our source language to that in a language without effect
handlers.
%
That is, if ones want to verify whether an expression $c$ has type $C$,
they can obtain the same result as the direct verification
by first applying CPS transformation to $c$ and $C$, and
then checking whether $\cps{c}$ has type $\cps{C}$
with a refinement type verification tool that does not support algebraic effect handlers.

Type annotations in the source language are necessary to restrict the image of the transformation.
Without them, a CPS-transformed program may be of a type $\tau$ that cannot be transformed to a type in the source language inversely (i.e., there exists no type $C$ in the source language satisfying $\cps{C} = \tau$).
For example, consider $\Lambda \alpha. \lambda h. \lambda k. k~0$,
the CPS form (without annotations) of expression $\expret{0}$.
Without annotations, we can pick arbitrary types as the type of $h$.
Therefore, it can have type
$\forall \alpha. \tybool \rarr (\tyint \rarr \alpha) \rarr \alpha$.
%
However, there is no type $C$ in the source language such that $\cps{C} = \forall \alpha. \tybool \rarr (\tyint \rarr \alpha) \rarr \alpha$.
Even worse, the source language has no type that is a \emph{subtype} of the type of the CPS form
since $\tybool$ and record types are incomparable with each other.
Another example is $\lambda x. \Lambda \alpha. \lambda h. \lambda k. k~x$,
the CPS form (again, without annotations) of expression $\lambda x. \expret{x}$.
Its type can be
$(\tyint \rarr \tyint) \rarr \forall \alpha. \{\} \rarr ((\tyint \rarr \tyint) \rarr \alpha) \rarr \alpha$,
that is, $x$ can be of type $\tyint \rarr \tyint$.
However, there is no value type $T$ in the source language
such that $\cps{T}$ is a subtype of $\tyint \rarr \tyint$.
Note that since a function type in the source language is in the form $(x: T_x) \rarr C$,
the right hand side of the arrow in the CPS-transformed function type must be in the form
$\forall \alpha. \{ \cdots \} \rarr \cdots$, which does not match with $\tyint$.
%
Therefore, without type annotations, Theorem~\ref{thm:cps-backward-excerpt} does not hold.

\newcommand{\er}{\mathit{er}}

While our formalization requires concrete refinement type annotations in the source language,
actually we can relax this restriction
by using predicate variables as placeholders instead of concrete refinements in type annotations.
This is because type annotations are only
for prohibiting occurrences of types with unintended \emph{structures}, not for restricting refinements.
Those predicate variables are instantiated after CPS transformation
with concrete predicates inferred by generating and solving CHC constraints
that contains these predicate variables from the CPS-transformed expression.
%
Formally, by allowing occurrences of predicate variables
in type annotations of both the source and target language,
and introducing predicate variable substitution $\sigma$,
we can state that $\cps{\sigma(c)} = \sigma(\cps{c})$.
This means that,
for an expression $c$ that is annotated with types containing predicate variables,
both of the followings result in the same expression:
(1) first instantiating the predicate variables in $c$ with concrete refinements,
and then CPS-transforming it (i.e., CPS-transforming the concretely-annotated expression),
and
(2) first CPS-transforming $c$,
and then instantiating the predicate variables in the CPS-transformed expression
with the concrete refinements.
In other words, concrete refinements are irrelevant to the CPS transformation.
This irrelevance is ensured by the fact that
refinements can depend only on first-order values because it means that handler variables $h$ and continuation variables $k$,
which occur only in CPS-transformed expressions, cannot be used in instantiated refinements.
% }
The reason why we have defined the CPS transformation with concrete refinements
is just to state Theorem~\ref{thm:cps-forward-excerpt} and Theorem~\ref{thm:cps-backward-excerpt}.

We do not address whether our CPS transformation is semantics-preserving in this paper
since our CPS transformation is intended to be used only for type checking.
However, the transformation is inspired by that of \citet{Hillerstrom17},
which satisfies the preservation of the dynamic semantics.
The differences between our and their CPS transformation are not so radical,
and therefore we believe that the preservation of the dynamic semantics holds too in our CPS transformation.


\subsection{Comparison between the direct verification and the indirect verification} \label{sec:cps/comparison}

In this section, We compare the direct verification using our refinement system
presented in Section~\ref{sec:language}
with the indirect verification via CPS transformation presented above.
One of the differences is that the direct verification requires
special support of verification tools for algebraic effect handlers,
while the indirect one can be done by existing tools without such support.
On the other hand, the indirect verification has some disadvantages.
%
First, in most cases, CPS-transformed programs tend to be complicated and be in
the forms quite different from the source programs.  This complexity incurred in
the indirect typechecking may lead to confusing error messages when the
typechecking fails.
Transforming the inferred complex types back to the types of the source language would be helpful,
but it is unclear whether we can do this
because the inferred types of the CPS-transformed expressions do not necessarily correspond to
the CPS-transformed types of the source expressions,
as stated in Section~\ref{sec:cps/def}.
By contrast, because the direct typechecking deals with the
structures of the source programs as they are, error messages can be made more
user-friendly.
%
Second, our CPS transformation needs a non-negligible amount of type
annotations---type annotations are necessary in let-expressions, conditional
branches, and recursive functions as well as operation calls and handling
constructs.  In practice, it is desired to infer as many types as possible.
However, it seems quite challenging to define a CPS transformation that
enjoys backward type-preservation and needs no, or few, type annotations.
One of the possible approaches for addressing type annotations in more automated way is
to use the underlying simple type system of our refinement type system
for algebraic effect handlers.
As mentioned in Section~\ref{sec:cps/def},
concrete refinements are not necessary for type annotations.
Therefore, we can generate type annotations for an expression
using its simple type inferred by the underlying type system.

We also compare these two approaches based on an experiment.
We used some direct style (DS) programs
(i.e., programs using algebraic effect handlers),
and for each program, we applied our CPS transformation manually,
and run the verification on both DS one and CPS one.
Additionally, we also compared them with optimized CPS programs
where administrative redexes were reduced.
We used the same implementation as the one in Section~\ref{sec:impl} with the configuration of \textsc{Spacer}.
We added annotations of source programs to only top-level expressions,
but the correctness of the verification can be justified by the preservation of dynamic semantics
which we believe to hold as described in Section~\ref{sec:cps/def}.

\begin{table}
    \caption{Evaluation results of CPS transformation}
    \label{tab:cps}
    \begin{tabular}{lcrcrcr}
        \toprule
        \multirow[c]{2}{*}{program} & \multicolumn{2}{c}{DS} & \multicolumn{2}{c}{CPS} & \multicolumn{2}{c}{CPS (optimized)} \\
        & verified? & time (sec.) & verified? & time (sec.) & verified? & time (sec.) \\
        \midrule
        \texttt{amb-2} &Yes & 1.30 & Yes & 1.32 & Yes & 0.91 \\
        \texttt{choose-easy} &Yes & 0.26 & Yes & 0.27 & Yes & 0.22 \\
        \texttt{choose-sum} &Yes & 2.18 & Yes & 1.79 & Yes & 12.87 \\
        \texttt{io-read-2} &Yes & 0.66 & No & 1.29 & No & 0.62 \\
        \texttt{simple} &Yes & 0.11 & Yes & 0.16 & Yes & 0.14 \\
        \bottomrule
    \end{tabular}
\end{table}

Table~\ref{tab:cps} shows the results of the experiment.
Some programs have no big difference in execution time
among the three variants,
but there are two notable things.
First, optimized CPS version of \texttt{choose-sum} took more time than the other versions.
This seems because the size of the program became larger by the optimization.
The DS \texttt{choose-sum} program contains some branching expressions
and each branch uses variables representing its continuation and the outer handler.
By reducing administrative redexes in the program, these variables are instantiated
with concrete continuation and handler,
that is, the continuation and handler are copied to each branch,
which results in larger size of the program and its constraints generated during the verification.
Second, CPS version of \texttt{io-read-2} could not be verified correctly.
One possible reason is lack of support for higher-order predicate polymorphism.
Since CPS programs explicitly pass around continuations,
their types tend to be higher-order.
Then, in some cases, higher-order predicate polymorphism becomes necessary by CPS transformation.

\endinput
