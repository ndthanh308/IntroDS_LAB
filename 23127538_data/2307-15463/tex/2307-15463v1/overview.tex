\section{Overview} \label{sec:overview}

We briefly overview algebraic effects and handlers, ATM, and ARM.

\subsection{Algebraic Effects and Handlers} \label{sec:overview/algeff}

\newcommand{\rmmax}{\mathrm{max}}

Algebraic effects and handlers enable the user to define their own effects in a
modular way.  The modularity stems from separating the use of effects from their
implementations: effects are performed via {\em operations} and implemented via
{\em effect handlers} (or handlers for short).  For example, consider the
following program.
%
\begin{align}
    &\expwith{
		\{ x_r \mapsto x_r, \ 
        \op[decide](x, k) \mapsto \rmmax~(k~\exptrue)~(k~\expfalse) \}
	}{ \\
        &\quad \explet{a}{\expif{\op[decide]~()}{10}{20}}{
            \; \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                \; a - b
            }
        }
    }
\end{align}
%
The expression in the second line uses an operation $\op[decide]$, which takes
the unit value $()$ and returns a Boolean value, to choose one of two integer
values and then calculates the difference between the chosen values.
%
Because operation calls invoke effects in algebraic effects, the operations work as interfaces of the effects.

An implementation of an effect is given by an effect handler.
%
The first line of the program installs a handler for $\op[decide]$ using the
handling construct.  In general, a handling construct takes the form
$\expwith{h}{e}$, which means that a handler $h$ defines interpretations of
operations performed during the evaluation of the expression $e$; we call the
expression $e$ a \emph{handled expression}.
%
A handler consists of a single \emph{return clause} and zero or more
\emph{operation clauses}.
%
A return clause takes the form $x_r \mapsto e_r$, which determines the value of
the handling construct by evaluating expression $e_r$ with variable $x_r$
that denotes the value of the handled expression.
%
In the example, because the return clause is $x_r \mapsto x_r$, the handling
construct simply returns the value of the handled expression.
%
An operation clause takes the form $\op[op](x, k) \mapsto e$. It defines the
interpretation of the operation $\op[op]$ to be expression $e$ with variable $x$
that denotes the arguments to the operation. When the handled expression calls
the operation $\op[op]$, the remaining computation up to the handling construct
is suspended and instead the body $e$ of the operation clause evaluates.
Therefore, effect handlers behave like exception handlers by regarding operation
calls as raising exceptions.  However, effect handlers are equipped with the
additional ability to resume the suspended computation.
%
The suspended remaining computation, called a \emph{delimited
continuation}, is functionalized, and the body $e$ of the operation clause can
refer to it via the variable $k$.

Let us take a closer look at the behavior of the above example.
%
Let $h_{\op[decide]}$ be the handler given in the program.
%
Because the handled expression starts with the call to $\op[decide]$,
the operation clause for $\op[decide]$ given by $h_{\op[decide]}$ evaluates.
%
The delimited continuation $K$ of the first call to $\op[decide]$ is
\[
 \expwith{ h_{\op[decide]} }{
        (\explet{a}{\expif{\hole}{10}{20}}{
            \; \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                \; a - b
            }
        })
    }
\]
%
where $\hole$ denotes the hole of the continuation.
%
We write $K[e]$ for the expression obtained by filling the hole in $K$ with expression $e$.
%
Then, the functional representation of the delimited continuation $K$ takes the
form $\lambda y. K[y]$, and it is substituted for $k$ in the body of the
operation clause.
%
Namely, the handling construct evaluates to $\rmmax~(v~\exptrue)~(v~\expfalse)$
where $v = \lambda y. K[y]$.
%
Note that the variable $x$ of the operation clause for $\op[decide]$ is replaced
by the unit value $()$, but it is not referenced.
%
The first argument $v~\exptrue$ to $\rmmax$
reduces to $K[\exptrue]$, that is,
\[
    \expwith{ h_{\op[decide]} }{
        (\explet{a}{\expif{\colorbox{gray!50}{$\exptrue$}}{10}{20}}{
            \explet{b}{\expif{\op[decide]~()}{1}{2}}{
              \; a - b
            }
        })
    }
\]
%
(the grayed part represents the value by which the hole in $K$ is replaced).
%
Therefore, the expression $v~\exptrue$ evaluates to
$
    \expwith{ h_{\op[decide]} }{
        (
            \explet{b}{\expif{\op[decide]~()}{1}{2}}{
                10 - b
            }
        )
    }
$~.
%
Again, $\op[decide]$ is called and the continuation
$
 K' \defeq \expwith{ h_{\op[decide]} }{
		(\explet{b}{\expif{\hole}{1}{2}}{
			10 - b
		})
	}
$
is captured.
%
Then, the operation clause for $\op[decide]$ evaluates
after substituting $\lambda y. K'[y]$ for $k$.
%
The expression $(\lambda y. K'[y])~\exptrue$
evaluates to $K'[\exptrue]$, that is,
$
 \expwith{ h_{\op[decide]} }{
    (\explet{b}{\expif{\colorbox{gray!50}{$\exptrue$}}{1}{2}}{10 - b})
 }
$
and then to
$
 \expwith{ h_{\op[decide]} }{ 9 }
$~.
%
Here, the handled expression is a value.  Therefore, the return clause in the
handler evaluates after substituting the value $9$ for variable $x_r$. Because
the return clause in $h_{\op[decide]}$ just returns $x_r$, the evaluation of
$(\lambda y. K'[y])~\exptrue$ results in $9$. Similarly, $(\lambda
y. K'[y])~\expfalse$ evaluates to $8$ (which is the result of binding $b$ to
$2$). Therefore, $\rmmax~((\lambda y. K'[y])~\exptrue)~((\lambda
y. K'[y])~\expfalse)$ evaluates to $\rmmax~9~8$ and then to $9$. In
a similar way, $v~\expfalse$ calculates $\rmmax~(20-1)~(20-2)$, that is,
evaluates to $19$, because $a$ is bound to $20$ and $b$ is bound to each of $1$
and $2$ depending on the result of the second invocation of $\op[decide]$.
%
Finally, the entire program evaluates to $19$, which is the result of
$\rmmax~(v~\exptrue)~(v~\expfalse)$, that is, $\rmmax~9~19$.

\subsection{Answer Type Modification and Answer Refinement Modification} \label{sec:overview/atm}

An \emph{answer type} is the type of the closest enclosing delimiter,
or the return type of a delimited continuation.
In the setting of algebraic effects and handlers,
delimiters are handling constructs.
For example, consider the following expression:
\begin{align}
	&\explet{x}{
		\expwith{
			\{ x \mapsto x, \ 
				\op((), k) \mapsto k~0 < k~1 \}
		}{1 + \op~()}
	}{c}
\end{align}
The delimited continuation of $\op~()$ is
$
    k \defeq
	\expwith{
		\{ x \mapsto x, \ 
			\op((), k) \mapsto k~0 < k~1 \}
	}{1 + \hole}
$~.
At first glance, the answer type of $\op~()$ seems to be $\tyint$
since the handled computation in the continuation returns $1+x$ for an integer value $x$ given to fill the hole, and the return clause returns given values as they are.
In other words, from the perspective of $\op~()$,
the handling construct seems to give an integer value to the outer context $\explet{x}{\hole}{c}$.
However, after the operation call, the entire expression evaluates to
$
	\explet{x}{
		k~0 < k~1
	}{c}
$~.
Now the handling construct becomes a Boolean expression $k~0 < k~1$, which gives a Boolean value to the outer context.
That is, the answer type changes to $\tybool$.
This is called \emph{answer type modification} (ATM).

ATM is not supported in existing type systems for effect handlers~\cite{Plotkin13,Brady13,Bauer13,Kammar13,Bauer15,Leijen17,Lindley17}, with the exception of the one recently proposed by \citet{Cong22} (cf.~Section~\ref{sec:related} for comparison with their work).
Such type systems require the answer types before and after an operation call to be unified (and so the example above will be rejected as ill-typed).
Nonetheless, useful programming with effect handlers is still possible without ATM (which is why they are implemented in popular languages like OCaml without ATM).\footnote{One could also argue that the absence of ATM is natural for algebraic effects and handlers because they are designed after concepts from universal algebra~\cite{DBLP:conf/fossacs/PlotkinP01,DBLP:journals/corr/abs-1807-05923}, and there, (algebraic) operations are usually expected to preserve types.}
For instance,
the program in Section~\ref{sec:overview/algeff} is well-typed
in existing (non-refinement) type systems for algebraic effects and handlers without ATM,
since the return type of the continuation $k$ in the $\op[decide]$ clause
(i.e. the answer type before the execution) is $\tyint$
and the return type of the $\op[decide]$ clause
(i.e. the answer type after the execution) is also $\tyint$.

However, even if answer types are not modified,
{\em actual values returned by delimited continuations usually change}.
Let us see the program in Section~\ref{sec:overview/algeff} again.
Focus on the first call to $\op[decide]$.
When this is called, the operation clause receives the continuation $v = \lambda y. K[y]$,
which returns $9$ if applied to $\exptrue$ and returns $19$ if applied to $\expfalse$,
as described previously.
Therefore, $v$ can be assigned the refinement type
$(y: \tybool) \rarr \tyrfn{z}{\tyint}{z = (\ternaryif{y}{9}{19})}$,
and thus the precise answer type before the execution is
$\tyrfn{z}{\tyint}{z = (\ternaryif{y}{9}{19})}$
where $y$ is the boolean value passed to the continuation.
On the other hand, the clause for $\op[decide]$
returns integer $19$. Thus, the precise answer type after the operation call is $\tyrfn{z}{\tyint}{z = 19}$.
Now the refinement in the answer type becomes different before and after the operation call.
The same phenomenon happens in the second call to $\op[decide]$.
When the second $\op[decide]$ is called, the handler receives the continuation $\lambda y. K'[y]$.
It returns $a - 1$ if applied to $\exptrue$ and returns $a - 2$ if applied to $\expfalse$
(where $a$ is either $10$ or $20$ depending on the result of the first call to $\op[decide]$).
Thus, the answer type before the execution is $\tyrfn{z}{\tyint}{z = (\ternaryif{y}{a - 1}{a - 2})}$.
In contrast, the return value of the clause for $\op[decide]$ is $\rmmax~(a - 1)~(a - 2) = a - 1$,
so the answer type after the execution is $\tyrfn{z}{\tyint}{z = a - 1}$.
Here again, the refinement in the answer type changed by the operation call.
We call this change \emph{answer refinement modification} (ARM). Armed with ARM (pun intened), the refinement type system that we propose in this paper is able to assign the precise refinement type $\tyrfn{z}{\tyint}{z = 19}$ to the program, and more generally, the type $\tyrfn{z}{\tyint}{z = v - x}$ when the constants $10$, $20$, $1$, and $2$ are replaced by variables $u$, $v$, $x$, and $y$ respectively with the assumption $u \leq v \wedge x \leq y$ (such an assumption on free variables can be given by refinement types in the top-level type environment).
%
The example demonstrates that ARM is useful for precisely reasoning about programs that use algebraic effects and handlers in refinement type systems.  Indeed, without ARM, the most precise refinement type that a type system could assign to the example would be $\tyrfn{z}{\tyint}{z \in \{8,9,18,19\}}$.

As another illuminating example, we show that ARM provides a new approach to the classic \emph{strong update} problem~\cite{DBLP:conf/pldi/FosterTA02}.  It is well known that algebraic effects and handlers can implement mutable references by operations $\op[set]$ and $\op[get]$, that respectively destructively updates and reads a mutable reference, and a handler that implements the operations by state-passing (see, e.g., \cite{Pretnar15}).
And, on programs with such a standard implementation of mutable references by algebraic effects and handlers, our refinement type system is able to reason flow-sensitively and derive refinement types that are not possible with ordinary flow-insensitive reasoning.
For instance, consider the following program:
\begin{gather}
    (\expwith{h}{
        \ (\op[set]~3;\,
        \explet{n}{\op[get]~()}{
            \op[set]~5;\,
            \explet{m}{\op[get]~()}{
                n + m
            }
        })
    })~0 \\
    \text{where} \ 
    h \defeq \{
        x_r \mapsto \lambda s. x_r, \ 
        \op[set](x, k) \mapsto \lambda s.k~()~x, \ 
        \op[get](x, k) \mapsto \lambda s. k~s~s \}
\end{gather}
Thanks to ARM, our type system can give the program the most precise type $\tyrfn{z}{\tyint}{z = 8}$,
which would not be possible in a type system without ARM as it would conflate the two calls to $\op[set]$ and fail to reason that the first $\op[get]~()$ returns $3$ whereas the second $\op[get]~()$ returns $5$.  Roughly, ARM accomplishes the flow-sensitive reasoning by tracking the changes in the value stored in the reference by changes in the refinements in the types of the continuations passed to the operation clauses, albeit in a \emph{backward} fashion.
An explanation of the example with a typing derivation is presented in Section~\ref{sec:language/exmaples}.
