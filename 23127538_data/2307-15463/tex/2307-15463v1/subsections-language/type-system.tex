\subsection{Type System} \label{sec:language/type-system}

\begin{wrapfigure}{R}{0.65\textwidth}
    $\begin{array}{rc@{\ \ }c@{\ }l@{\qquad}rc@{\ \ }c@{\ \ }l}
        \text{term} &
        t &::=& x \mid \ldots
        &
        \text{formula} &
        \phi &::=& A(\rep{t}) \mid \ldots
        \\
        \text{predicate} &
        A &::=& X \mid \ldots
        &
        \text{base type} &
        B &::=& \tybool \mid \ldots
    \end{array}$
    $\begin{array}{rc@{\ \ }c@{\ }l}
        \text{value type} &
        T &::=& \tyrfn{x}{B}{\phi} \mid (x: T) \rarr C
        \\
        \text{computation type} &
        C &::=& \tycomp{\Sigma}{T}{S}
        \\
        \text{operation signature} &
        \Sigma &::=& \{ \repi{\op_i : \forall \rep{X_i: \rep{B}_i}. F_i} \}
        \\
        &
        F &::=& (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2
        \\
        \text{control effect} &
        S &::=& \square \mid \tyctl{x}{C_1}{C_2}
        \\
        \text{typing context} &
        \Gamma &::=& \emptyset \mid \Gamma, x: T \mid \Gamma, x: B \mid \Gamma, X: \rep{B}
    \end{array}$
    \caption{Type syntax.}
    \label{fig:type-syntax}
\end{wrapfigure}

Figure~\ref{fig:type-syntax} shows the syntax of types.
%
As in prior refinement type systems \cite{Bengston11, Rondon08, Unno09}, our type system allows a type
specification for values of base types, ranged over by $B$, such as $\tybool$
and $\tyint$, to be refined using logic formulas, ranged over by $\phi$.
%
Our type system is parameterized over a logic. We assume that the logic is a
predicate logic where: terms, denoted by $t$, include variables $x$;
predicates, denoted by $A$, include predicate variables $X$; and each primitive
value $p$ can be represented as a term.
%
Throughout the paper, we use the overline notation to denote a sequence of
entities.  For example, $\rep{t}$ represents a sequence $t_1, \cdots, t_n$ of
some terms $t_1, \ldots, t_n$, and then $A(\rep{t})$ represents a formula
$A(t_1, \cdots, t_n)$.
%
We also assume that base types include at least the Boolean type $\tybool$.

Types consist of value and computation types, which are assigned to values and
computations, respectively.
%
A value type, denoted by $T$, is either a refinement type $\tyrfn{x}{B}{\phi}$,
which is assigned to a value $v$ of base type $B$ such that the formula
$\phi[v/x]$ is true, or a dependent function type $(x: T) \rarr C$, which is
assigned to a function that, given an argument $v$ of the type $T$, performs
the computation specified by the type $C[v/x]$.
We abbreviate $\tyrfn{z}{B}{\exptrue}$ as $B$.

A computation type is formed by three components: an operation signature,
which specifies operations that a computation may perform;
a value type, which specifies the value that the computation returns
if any; and a control effect, which specifies how the computation modifies the
answer type via operation call.

Control effects, denoted by $S$, are inspired by the formalism of \citet{Sekiyama23} who extended control effects in simple typing~\cite{Materzok11} to dependent typing.
%
A control effect is either pure or impure.
%
The pure control effect $\square$ means that a computation calls no operation.
%
An impure control effect is in the form $\tyctl{x}{C_1}{C_2}$, which means that
the answer type of a computation with this effect changes from $C_1$ to
$C_2$.
%
The initial answer type $C_1$ specifies how the
continuation of the computation $c$ up to the closest handing construct behaves.
%
The variable $x$ in the control effect, which is bound in the type $C_1$,
represents values passed to the continuation.
%
Therefore, an impure control effect can specify the behavior of the
continuation using passed values.
%
The final answer type $C_2$ specifies what can be guaranteed for the
context of the closest handling construct.
%
To see the idea of impure control effects more concretely, consider an
expression $\explet{x}{(\expwith{h}{(\explet{y}{c_1}{c_2})})}{c_3}$ and assume that a control effect $\tyctl{y}{C_1}{C_2}$ is assigned to the computation $c_1$.
%
Then, the initial answer type $C_1$ specifies how the delimited
continuation $\expwith{h}{(\explet{y}{\hole}{c_2})}$ of $c_1$ behaves when
passed a value (which can be referenced via variable $y$ in the type $C_1$).
%
Next, assume that the computation $c_1$ calls an operation $\op$.
%
In this case, the handled
computation $\explet{y}{c_1}{c_2}$ evaluates to an operation call
$\expop{v}{z.\explet{y}{c_1'}{c_2}}$ for some $v$ and $c_1'$ (which is the
continuation from the operation call in $c_1$).
%
Then, the handling construct is replaced by the body $c_{\op}$ of the clause
for $\op$ in the handler $h$.
%
It means that the context $\explet{x}{\hole}{c_3}$ of the handling construct
takes the computation $c_{\op}$ in the end.
%
Because the answer type $C_2$ after evaluating $c_1$ specifies the guarantee for
the context of the handling construct, the type system ensures that the type of
$c_{\op}$ is matched with the type $C_2$ and typechecks the entire
let-expression $\explet{x}{(\expwith{h}{(\explet{y}{c_1}{c_2})})}{c_3}$ under
the assumption that the expression $\expwith{h}{(\explet{y}{c_1}{c_2})}$ is of
the type $C_2$.\footnote{If the computation $c_1$ performs no operation, the
type system ensures that the type $C_1$ is matched with the type $C_2$. This is
consistent in that, in such a case, the context of $c_1$
simply receives its evaluation result.}
%
As we will see in Section~\ref{sec:language/exmaples}, allowing this modification of answer types
enables precise tracking of what value is returned to the context of a
handling construct.  Impure control effects summarize what operation is called
and how the call is handled, which determine the value returned to the context.

Operation signatures, denoted by $\Sigma$, are sets of pairs of an operation
name and a type scheme.
%
We write $\repi{\cdot}$ to denote a sequence of entities indexed by $i$.
%
The type scheme associated with an operation $\op$ is in the form
$\forall \rep{X: \rep{B}}. (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2$,
where the types $T_1$ and $T_2$ are the input and output types of the operation, respectively, and the types $C_1$ and $C_2$ are the answer types before and after calling the operation, respectively.
%
Recall that the answer type $C_1$ corresponds to the return type
of delimited continuations captured by the call to $\op$, and that the
continuations take the return values of the operation call.
%
Therefore, the function type $(y: T_2) \rarr C_1$ represents the type of the
captured delimited continuations. Note that the variable $y$ denotes values
passed to the continuations.
%
Furthermore, the answer type $C_2$ corresponds to the type of
the operation clause for $\op$ in the closest enclosing handler.
%
Therefore, the operation clause $\op(x, k) \mapsto c$ in the
handler is typed by checking that the body $c$ is of the type $C_2$ with the assumption that
argument variable $x$ is of the type $T_1$ and the continuation variable $k$ is
of the type $(y: T_2) \rarr C_1$.
%
A notable point of the type scheme is that it can be parameterized over
predicates. The predicate variables $\rep{X}$ abstract over the predicates, and the annotations $\rep{B}$ represent
the (base) types of the arguments to the predicates.
%
This allows calls to the same
operation in different contexts to have different control effects, which is
crucial for precisely verifying programs with algebraic effects and handlers as
seen in Section~\ref{sec:language/exmaples}.
%
It is also noteworthy that operation signatures include not only operation names
but also type schemes as in \citet{Kammar13} and \citet{Kammar17}.
%
It allows an operation to have different types depending on the contexts
where it is used.
%
Another approach is to include only operation names and assumes that unique types
are assigned to them globally as in, e.g., \citet{Bauer13} and \citet{Leijen17}.
%
We decided to assign types to operations locally because it makes the type
system more flexible in that the types of operations can be refined depending on
contexts if needed.

Typing contexts $\Gamma$ are lists of variable bindings $x: T$, $x: B$
and predicate variable bindings $X: B$.
We write $\Gamma, \phi$ for $\Gamma, x: \tyrfn{z}{B}{\phi}$
where $x$ and $z$ are fresh.
The notions of free variables, free predicate variables,
and predicate substitution are defined as usual.

\fullfalse
\iffull{
% Figure environment removed

Well-formedness of typing contexts, value types, and computation types, whose
judgments are in the forms $\jdwf{}{\Gamma}$, $\jdwf{\Gamma}{T}$, and
$\jdwf{\Gamma}{C}$, respectively, are defined straightforwardly as shown in
Figure~\ref{fig:wf}.
%
We write $\dom(\Gamma)$ for the set of variables
and predicate variables bound in the typing context $\Gamma$.
%
The well-formedness of a computation type $\tycomp{\Sigma}{T}{S}$ rests on the
well-formedness of its components, that is, the operation signature $\Sigma$,
the value type $T$, and the control effect $S$.
%
An operation signature $\Sigma$ is well-formed under a typing context $\Gamma$,
written as $\jdwf{\Gamma}{\Sigma}$, if the type schemes associated with
operations in $\Sigma$ are well-formed under $\Gamma$.
%
Note that, for every type scheme $\forall \rep{X_i: \rep{B}_i}. F$, the qualified type $F$ is a function type.
%
The well-formedness of a control effect $S$ in terms of value type $T$, written as $\jdwf{\Gamma \mid T}{S}$ with a typing context $\Gamma$,
is derived by either of the last two rules in Figure~\ref{fig:wf}.
%
When the control effect $S$ is an impure effect $\tyctl{x}{C_1}{C_2}$, the type
$T$ is assigned to the variable $x$ because $x$ denotes values passed to
continuations of computations of the type $\tycomp{\Sigma}{T}{S}$ and the passed
values are the return values of the computations.
%
Additionally, we assume that the logic for refinements is equipped with
well-formedness judgments of formulas $\jdwf{\Gamma}{\phi}$ and of predicates
$\jdwf{\Gamma}{A : \rep{B}}$.
%
The properties assumed on these judgments are stated in the supplementary
material.
%
}\else{
%
Well-formedness of typing contexts, value types, and computation types, whose
judgments are in the forms $\jdwf{}{\Gamma}$, $\jdwf{\Gamma}{T}$, and
$\jdwf{\Gamma}{C}$, respectively, are defined straightforwardly by following \citet{Sekiyama23}.
We refer to the supplementary material for detail.
%
}\fi

% Figure environment removed

Typing judgements for values and computations are in the forms $\jdty{\Gamma}{v}{T}$ and $\jdty{\Gamma}{c}{C}$,
respectively.
Figure~\ref{fig:typing} shows the typing rules.
By \rulename{T-CVar}, a variable $x$ of a refinement type is assigned a type
which states that the value of this type is exactly $x$.
For a variable of a non-refinement type (i.e., a function type in our language),
the rule \rulename{T-Var} assigns the type associated with the variable in the
typing context.
%
The rule \rulename{T-Prim} uses the mapping $\ty$ to type primitive values $p$.
We assume that $\ty$ assigns an appropriate value type to every primitive value.
The rule \rulename{T-Fun} for functions, \rulename{T-App} for function
applications, and \rulename{T-If} for conditional branches are standard in
refinement type systems (with support for value-dependent refinements).
%
The rules \rulename{T-VSub} and \rulename{T-CSub} allow values and computations,
respectively, to be typed at supertypes of their types.
%
We will define subtyping shortly.
%
By \rulename{T-Ret}, a value-return $\expret{v}$ has a computation type
where the operation signature is empty, the return value type is the type of $v$,
and the control effect is pure.

To type a let-expression $\explet{x}{c_1}{c_2}$, the rule \rulename{T-Let}
requires that the types of the sub-expressions $c_1$ and $c_2$ have the same
operation signature $\Sigma$ and then assigns $\Sigma$ to the type of the entire
let-expression.
%
The typing context for $c_2$ is extended by $x: T_1$ with the value
type $T_1$ of $c_1$, but $x$ cannot occur in $\Sigma$ and $T_2$ to prevent
the leakage of $x$ from its scope.
%
The control effect of the entire let-expression is composed of the control effects $S_1$ of $c_1$ and $S_2$ of $c_2$
with variable $x$ that denotes the evaluation result of $c_1$.
%
\begin{defn} \label{defn:composition}
 The composition $\bind{S_1}{x}{S_2}$ of control effects $S_1$ and $S_2$ with variable $x$
 is defined as follows:
 \[\begin{array}{rcl}
  \bind{\square}{x}{\square} &\defeq& \square \\
  \bind{\tyctl{x_1}{C}{C_{12}}}{x_1}{\tyctl{x_2}{C_{21}}{C}} &\defeq&
    \tyctl{x_2}{C_{21}}{C_{12}} \qquad \text{if } x_1 \notin \fv(C_{21}) \setminus \{x_2\}
   \end{array}
 \]
\end{defn}
When both of the control effects $S_1$ and $S_2$ are pure, the composition result is also pure.
%
When both are impure, the composition produces an impure control effect.
%
Note that, even when one of $S_1$ and $S_2$ is pure and the other is
impure, we can view both of $S_1$ and $S_2$ as impure effects via subtyping
because it allows converting a pure control effect to an impure control
effect, as shown later.
%
To see how the composition works in more detail, let
$S_1$ be $\tyctl{x_1}{C_{11}}{C_{12}}$ and $S_2$ be $\tyctl{x_2}{C_{21}}{C_{22}}$,
and assume that a control effect $\tyctl{y}{C_1}{C_2}$ is assigned to the
let-expression.
%
First, recall that the type $C_1$ expresses the return type of the continuation
of the let-expression up to the closest handling construct and that the closest
handling construct is replaced by a computation of the type $C_2$.
%
Based on this idea, the types $C_1$ and $C_2$ can be determined as follows.
%
First, because the delimited continuation of the let-expression is matched with
that of the computation $c_2$, the answer type $C_{21}$ before evaluating $c_2$
expresses the return type of the delimited continuation of the let-expression.
Therefore, the type $C_1$ should be matched with the type $C_{21}$.
%
Also, the input to the delimited continuation---which is matched with the
evaluation result of the let-expression or, equivalently, the computation
$c_2$---is denoted by the variable $x_2$ in $C_{21}$.
%
Second, because the closest handling construct enclosing the let-expression is the same
as the one enclosing the sub-expression $c_1$, the type $C_2$ should be matched
with the answer type $C_{12}$ after evaluating $c_1$.
%
Therefore, the control effect $\tyctl{y}{C_1}{C_2}$ should be matched with
$\tyctl{x_2}{C_{21}}{C_{12}}$, as defined in Definition~\ref{defn:composition}.
%
The composition is well defined only if the variable $x_1$ bound in the
computation $c_2$ does not occur freely in the type $C_{21}$ to prevent $x$ from
escaping its scope.
%
Furthermore, Definition~\ref{defn:composition} requires that the
answer type $C_{11}$ before evaluating $c_1$ to be the same as the answer type
$C_{22}$ after evaluating $c_2$.
%
This requirement is explained as follows.
%
First, the computation $c_1$ expects its delimited continuation to behave as
specified by the type $C_{11}$.
%
The delimited continuation of $c_1$ first evaluates the succeeding computation
$c_2$.
%
The answer type $C_{22}$ after evaluating $c_2$ expresses that the closest
handling construct enclosing $c_2$ behaves as specified by the type $C_{22}$.
%
Because the closest handling construct enclosing $c_2$ corresponds to the
top-level handling construct in the delimited continuation of $c_1$, the
type $C_{11}$ should be matched with the type $C_{22}$.

The rule \rulename{T-Hndl} for handling constructs $\expwith{h}{c}$
is one of the most important rules of our system.
%
It assumes that the handled computation $c$ is of a type
$\tycomp{\Sigma}{T}{\tyctl{x_r}{C_1}{C_2}}$, where the control effect is impure.
%
Even when $c$ is pure (i.e., performs no operation), it can have an impure control effect via subtyping.
%
Because the type of the handling construct represents how the expression is
viewed from the context, it should be matched with the answer type $C_2$ after
evaluating the handled computation $c$.
%
The premises in the second line define typing disciplines that the clauses in the installed handler $h$ have to satisfy.
%
First, let us consider the return clause $\expret{x_r} \mapsto c_r$.
%
Because the variable $x_r$ denotes the return value of the handled
computation $c$, the value type $T$ of $c$ is assigned to $x_r$.
%
Moreover, since the return clause is executed after evaluating $c$, the body
$c_r$ is the delimited continuation of $c$.
%
Therefore, the type of $c_r$ should be matched with the answer type $C_1$ before
evaluating $c$.
%
Because the variable $x_r$ bound in the return clause can be viewed as the input
to the delimited continuation $c_r$, it should be matched with the
variable $x_r$ bound in the impure control effect $\tyctl{x_r}{C_1}{C_2}$.
%
Operation clauses are typed using the corresponding type schemes in the
operation signature $\Sigma$, as explained above.
%
Note that the rule also requires the installed handler $h$ to include a clause
for each of the operations in $\Sigma$, i.e., those that $c$ may perform.

The rule \rulename{T-Op} for operation calls is
another important rule.
%
Consider an expression $\expop{v}{y}{c}$.
%
The rule assumes that an enclosing handler addresses the operation $\op$
by requiring that an operation signature $\Sigma$ assigned to the operation call
include the operation $\op$ with a type scheme
$\forall \rep{X: \rep{B}}. (x: T_1) \rarr ((y: T_2) \rarr C_1) \rarr C_2$,
and instantiates the predicate
variables $\rep{X}$ in the type scheme with well-formed predicates $\rep{A}$ to
reflect the contextual information of the operation call.
%
Then, it checks that the argument $v$ has the input type $T_1[\rep{A/X}]$ of the
operation and that the continuation $c$ is typable.
%
Because $y$ denotes the output of the operation call, it is assumed to have the
type $T_2[\rep{A/X}][v/x]$ in the continuation $c$.
%
Note that the occurrences of $y$ are restricted to prevent it from escaping the
scope.
%
A key point to understand the remaining of the rule is that the expression
$\expop{v}{y}{c}$ first calls the operation and then executes the
computation $c$.
%
It means that the type of $\expop{v}{y}{c}$ and its relationship to the type of
$c$ are determined in a way similar to the typing of let-expressions by
\rulename{T-Let}.
%
Namely, given a computation type $\tycomp{\Sigma}{T_3}{\tyctl{z}{C_0}{C_0'}}$ of
the succeeding computation $c$, because the answer types before and after the
(preceding) operation call are the types $C_1[\rep{A/X}][v/x]$ and
$C_2[\rep{A/X}][v/x]$, respectively (note that the types $C_1$ and $C_2$ are
parameterized over predicates and arguments), the answer types before and after
evaluating $\expop{v}{y}{c}$ should be matched with the types $C_0$ and
$C_2[\rep{A/X}][v/x]$, respectively, and the answer type $C_0'$ after executing
$c$ should be matched with the type $C_1[\rep{A/X}][v/x]$.

% Figure environment removed

The type system defines four kinds of subtyping judgments:
$\jdsub{\Gamma}{T_1}{T_2}$ for value types,
$\jdsub{\Gamma}{C_1}{C_2}$ for computations types,
$\jdsub{\Gamma}{\Sigma_1}{\Sigma_2}$ for operation signatures, and
$\jdsub{\Gamma \mid T}{S_1}{S_2}$ for control effects.
%
Figure~\ref{fig:subty} shows the subtyping rules.
%
The subtyping rules for control effects are adopted from the work of \citet{Sekiyama23},
which extends subtyping for control effects given by \citet{Materzok11} to
dependent typing.
%
The rules for value types (\rulename{S-Rfn} and \rulename{S-Fun}) are standard.
%
The judgement $\valid{\Gamma}{\phi}$ in \rulename{S-Rfn} means
the semantic validity of the formula $\phi$ under the assumption $\Gamma$.
%
Subtyping between operation signatures is determined by \rulename{S-Sig}.
%
This rule is based on the observation that an operation signature $\Sigma$
represents the types of operation clauses in handlers, as seen in
\rulename{T-Hndl}.
%
Then, the rule \rulename{S-Sig} can be viewed as defining a subtyping relation between
the types of handlers (except for return clauses): a handler for operations in
$\Sigma_1$ can be used as one for operations in $\Sigma_2$ if every operation
$\op$ in $\Sigma_2$ is included in $\Sigma_1$ (i.e., the handler has an
operation clause for every $\op$ in $\Sigma_2$) and the type scheme of $\op$ in
$\Sigma_1$ is a subtype of the type scheme of $\op$ in $\Sigma_2$ (i.e., the
operation clause for $\op$ in the handler works as one for $\op$ in $\Sigma_2$).
%
Given a computation type $C_1 \defeq \tycomp{\Sigma_1}{T_1}{S_1}$ and its
supertype $C_2 \defeq \tycomp{\Sigma_2}{T_2}{S_2}$, a handler for operations
performed by the computations of the type $C_2$ (i.e., the operations in
$\Sigma_2$) is required to be able to handle operations performed by the
computations of the type $C_1$ (i.e., the operations in $\Sigma_1$) because the
subtyping allows deeming the computations of $C_1$ to be of $C_2$.
%
The safety of such handling is ensured by requiring $\Sigma_2 <: \Sigma_1$.
%
In the rule \rulename{S-Comp}, the first premise represents this requirement.
%
The second premise $\jdsub{\Gamma}{T_1}{T_2}$ in \rulename{S-Comp} allows
viewing the return values of the computations of the type $C_1$ as those of the
type $C_2$.
%
The third premise $\jdsub{\Gamma \mid T_1}{S_1}{S_2}$ expresses that the use of
effects by the computations of the type $C_1$ is subsumed by the use of effects
allowed by the type $C_2$.
%
It is derived by the last three rules: \rulename{S-Pure},
\rulename{S-ATM}, and \rulename{S-Embed}.
%
The rule \rulename{S-Pure} just states reflexivity of the pure control effect.
%
If both $S_1$ and $S_2$ are impure, the rule \rulename{S-ATM} is applied.
%
Because initial answer types represent the assumptions of computations
on their contexts, \rulename{S-ATM} allows strengthening the assumptions by
being contravariant in them.
%
By contrast, because final answer types represent the guarantees of how
enclosing handling constructs behave, \rulename{S-ATM} allows weakening the
guarantees by being covariant in them.
%
Note that the typing context for the initial answer types is extended
with the binding $x : T_1$ because they may reference the inputs to the
continuations via the variable $x$ and the inputs are of the type
$T_1$.
%
Finally, the rule \rulename{S-Embed} allows converting the pure control effect
to an impure control effect $\tyctl{x}{C_1}{C_2}$.
%
Because a computation $c$ with the pure control effect performs no operation,
what is guaranteed for the behavior of the handling construct enclosing $c$
coincides with what is assumed on $c$'s delimited continuation.
%
Because the guarantee and assumption are specified by the types $C_2$ and
$C_1$, respectively, if $C_1$ is matched with $C_2$---more generally, the
``assumption'' $C_1$ implies the ``guarantee'' $C_2$---the pure computation
$c$ can be viewed as the computation with the impure control effect
$\tyctl{x}{C_1}{C_2}$.
%
The first premise in \rulename{S-Embed} formalizes this idea.
%
Note that, because the variable $x$ is bound in the type $C_1$, the rule
\rulename{S-Embed} disallows $x$ to occur in the type $C_2$.

Finally, we state the type safety of our system. Its proof, via progress and subject reduction, is given in the supplementary material.
We define $\eval^*$ as the reflexive, transitive closure of the one-step evaluation relation $\eval$.
\begin{theorem}[type safety] \label{thm:safety}
    If\, $\jdty{\emptyset}{c}{\tycomp{\Sigma}{T}{S}}$ and $c \eval^* c'$, then one of the following holds:
    \begin{itemize}
        \item $c' = \expret{v}$ for some $v$,
        \item $c' = \expop{v}{y}{c_1}$ for some $\op, v, y, c_1$ such that $\op \in \dom(\Sigma)$, or
        \item $c' \eval c''$ for some $c''$.
    \end{itemize}
\end{theorem}
