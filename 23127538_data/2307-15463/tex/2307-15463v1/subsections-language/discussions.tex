\subsection{Discussion} \label{sec:language/discussions}
In this section, we discuss the current limitations and future extensions of our system.

\subsubsection{Abstraction of effects}
Our type system has no mechanism for abstraction of effects.
Therefore, if we cannot know possible effects of the handled expression in advance
(e.g., as in $\lambda f. \expwith{h}{(f~())}$, where the effects of the handled expression $f~()$ are determined by function parameter $f$),
we have to fix its effects (both the operation signature and the control effect).
A possible way to address the issue is to incorporate some mechanism to abstract effects.
For operation signatures, effect polymorphism as in the existing effect systems
for algebraic effects and handlers~\cite{Leijen17,Lindley17}, is a possible solution.
For control effects, we conjecture that bounded polymorphism can be used
to abstract control effects while respecting the necessary sub-effecting constraints.

\subsubsection{Combination with other computational effects}
Algebraic effects and handlers are sometimes used with other computational effects.
For example, when implementing a scheduler with algebraic effects and handlers,
an imperative queue is often used to keep suspended continuations, like in an example from \citet{MulticoreOCamlrepo}.
Even though some computational effects can be simulated
by algebraic effects and handlers themselves,
it is often convenient to address them as primitive operations for efficiency.
Our system does not support such primitive computational effects.
It is left for future work to combine these features in one system.

\subsubsection{Shallow handlers}
The handlers we adopt in this work are called \emph{deep handlers}~\cite{Kammar13},
which is the most widely used variant.
Another variant of algebraic effect handlers is \emph{shallow handlers}~\cite{Hillerstrom18},
which
we do not address in the present work.
%
Just as deep handlers are related to shift0/reset0,
shallow handlers are related to control0/prompt0~\cite{Pirog19}.
Therefore, the type system for control0/prompt0 with ATM~\cite{Ishio22} may be adapted
to develop a refinement type system for shallow handlers,
as we have developed our refinement type system for deep handlers
based on the type systems for shift0/reset0 with ATM~\cite{Materzok11, Sekiyama23}.

\subsubsection{Recursive computation types}
Some useful programs with algebraic effect handlers are ill typed in our system due to the lack of support for recursive computation types.
For example, consider the following program:
\begin{align}
    \exprec{f}{n}{
        &\expwith{\{ \op[Err](msg, k) \mapsto
            \expop[Err]{(\text{\texttt{sprintf "called at \%d. \%s"}}~n~msg)}{y}{\expret{y}} \}
            \\ & }
        {\expif{n = 0}{\expop[Err]{\text{\texttt{"error"}}}{y}{\expret{y}}}{f~(n - 1)}}
    }
\end{align}
This recursive function handles the error in each function call,
producing its own stack trace.
It cannot be typed without recursive types
because the type of the handled computations appears recursively as its answer type.
To see this, assume that the type of the handled computation (i.e., the if-expression)
is assigned a type $\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}$
(here we consider only simple types for simplicity).
Then, the type of the handling construct (i.e., the body of the function) is $C_2$,
which implies that the overall function has type $\tyint \rarr C_2$.
And so, the recursive call to the function $f~(n - 1)$ also has type $C_2$.
Then, the type $C_2$ should be a subtype of $\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}$
since $f~(n - 1)$ is the else-branch of the if-expression.
However, we cannot derive $\jdsub{\Gamma}{C_2}{\tycomp{\Sigma}{T}{\tyctlMB{C_1}{C_2}}}$
(for some $\Gamma$) in our system
because while the type on the left-hand side is $C_2$ itself,
$C_2$ appears as the answer type in the control effect of the type on the right-hand side.
On the other hand, using recursive types, we can give this function the following type
(again, we consider only simple types for simplicity):
\begin{gather}
    \tyint \rarr \tycomp{\Sigma_c}{T}{\tyctlMB{T}{C_{rec}}} \\
    \text{where} \quad
        C_{rec} := \mu \alpha. \tycomp{\Sigma_\alpha}{T}{\tyctlMB{T}{\alpha}}, \quad
        \Sigma_\alpha := \{ \op[Err] : \tystr \rarr (T \rarr T) \rarr \alpha \}, \quad
        \Sigma_c := \Sigma_\alpha[C_{rec}/\alpha]
\end{gather}
where $T$ is an arbitrary value type,
$\mu \alpha. C$ denotes a recursive computation type
where the type variable $\alpha$ refers to the whole type itself,
and $\Sigma[C/\alpha]$ denotes instantiation of the type variable.
Its control effect is recursively nested,
which reflects the fact that the handling construct is recursively nested
due to the recursive call to the function.
