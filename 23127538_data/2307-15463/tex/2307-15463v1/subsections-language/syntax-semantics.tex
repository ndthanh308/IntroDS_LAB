\subsection{Syntax and Semantics} \label{sec:language/syntax-semantics}

\begin{wrapfigure}[10]{R}{0.5\textwidth}
    $\begin{array}{rcl}
        p &::=& \exptrue \mid \expfalse \mid \ldots \\
        v &::=& x \mid p \mid \exprec{f}{x}{c} \\
        c &::=& \expret{v} \mid \expop{v}{y}{c} \mid v_1~v_2 \\
            &&\mid \expif{v}{c_1}{c_2} \mid \explet{x}{c_1}{c_2} \\
            &&\mid \expwith{h}{c} \\
        h &::=& \{ \expret{x_r} \mapsto c_r, \repi{\op_i(x_i, k_i) \mapsto c_i} \} \qquad
    \end{array}$
    \caption{Program syntax.}
    \label{fig:syntax}
\end{wrapfigure}
%
Figure~\ref{fig:syntax} shows the syntax of our language.
It indicates that expressions are split into values, ranged over by $v$, and computations, ranged over by $c$,
as in the fine-grained call-by-value style of \citet{Levy03}.
Values, which are effect-free expressions in a canonical form,
consist of variables $x$, primitive values $p$,
and (recursive) functions $\exprec{f}{x}{c}$
where variable $f$ denotes the function itself for recursive calls in the body $c$.
If $f$ does not occur freely in $c$, we simply write $\lambda x. c$.
Computations, which are possibly effectful expressions,
consist of six kinds of constructs.
A value-return $\expret{v}$ lifts a value $v$ to a computation.
An operation call $\expop{v}{y}{c}$ performs the operation $\op$ with the
argument $v$.  Once the operation call returns a value, the continuation $c$
will be executed by binding variable $y$ to the return value.  Note that $y$ is
bound in $c$.  The notation $\op~v$ used in Section~\ref{sec:overview/algeff} is
an abbreviation of the expression $\expop{v}{y}{\expret{y}}$ in this language.
A function application $v_1~v_2$, conditional branch $\expif{v}{c_1}{c_2}$,
and let-expression $\explet{x}{c_1}{c_2}$ are standard.
Note that functions, arguments, and conditional expressions are
restricted to values, but this does not reduce expressivity because, e.g.,
a conditional branch $\expif{c}{c_1}{c_2}$ can be expressed as
$\explet{x}{c}{\expif{x}{c_1}{c_2}}$ using a fresh variable $x$.
A handling construct $\expwith{h}{c}$ handles operations performed during the
evaluation of the handled computation $c$ using the clauses in the handler $h$.
A handler $\{ \expret{x_r} \mapsto c_r, \repi{\op_i(x_i, k_i) \mapsto c_i} \}$
has a return clause $\expret{x_r} \mapsto c_r$ where the variable $x_r$ denotes
the value of the handled computation $c$, and an operation clause
$\op_i(x_i, k_i) \mapsto c_i$ for each operation $\op_i$ where the variables
$x_i$ and $k_i$ denote the argument to $\op_i$ and the continuation from the
invocation of $\op_i$, respectively.
The notions of free variables and substitution are defined as usual.
We write $c[v/x]$ for the computation obtained by substituting the value $v$ for
the variable $x$ in the computation $c$.  We use similar notation to substitute
values for variables in types and substitute types for type variables.

\iffull{
%
% Figure environment removed

The semantics of the language is defined by the evaluation relation $\eval$,
which is the smallest binary relation over computations satisfying the
evaluation rules in Figure~\ref{fig:eval}.
The evaluation of a let-expression $\explet{x}{c_1}{c_2}$ begins by
evaluating the computation $c_1$.
When $c_1$ returns a value, the computation $c_2$ evaluates after substituting
the return value for $x$. If $c_1$ evaluates to an operation call
$\expop{v}{y}{c_1'}$, the outer context $\explet{x}{\hole}{c_2}$ is absorbed
into the continuation involved in the operation call.
The evaluation rules for conditional branching and function application are
standard.
The result of applying a primitive value relies on the metafunction $\zeta$,
which maps pairs of a primitive value and an argument value to computations.
For a handling-expression $\expwith{h}{c}$, the handled computation $c$
evaluates first.
When $c$ returns a value, the body of the return clause in the handler $h$
evaluates with the return value.
If $c$ evaluates to an operation call $\expop[\op_i]{v}{y}{c'}$, the body $c_i$
of the operation clause $\op_i(x_i, k_i) \mapsto c_i$ for $\op_i$ in the handler
$h$ evaluates after substituting the argument $v$ and the function
$\lambda y. \expwith{h}{c'}$ for variables $x_i$ and $k_i$, respectively.
%
Note that the function $\lambda y. \expwith{h}{c'}$ substituted for $k_i$ wraps
the delimited continuation $c'$ in the operation call by the handling construct
with the handler $h$.
It means that the operation calls in $c'$ are handled by the handler $h$.
For simplifying the typing rule for handlers, we assume that the handler $h$
provides operation clauses for all the operations performed by the handled
computation $c$.
%
The type system ensures that this assumption holds on any well-typed expression.
An alternative formalism for handlers is allowing handlers to omit operation
clauses for some operations and automatically forwarding calls to the operations
towards outer handlers.
This can be implemented in our formalism: given a handler that does not contain
an operation clause for $\op$, we can add to the handler an operation clause
$\op(x,k) \mapsto \expop{x}{y}{k~y}$, which is an implementation of operation
call forwarding.
}
\else{
%
The semantics of the language is defined by the evaluation relation $\eval$,
which is a binary relation over computations.
%
It is mostly identical to the semantics given by \citet{Pretnar15}; we refer to the supplementary material for its definition.
%
The only difference is that Pretnar's semantics allows handlers
that do not involve clauses for operations performed by a handled
computation---a call to such an operation is forwarded to outer
handlers---whereas our semantics assumes handlers to contain clauses for all such operations.
%
Our type system ensures that this assumption holds on any well-typed expression.
However, our language can also implement the forwarding semantics by encoding: given a handler
that does not contain an operation clause for $\op$, we add to the handler
an operation clause $\op(x,k) \mapsto \expop{x}{y}{k~y}$.\footnote{We use the semantics without forwarding in the body of the paper to simplify the typing rules.  Appendix~\ref{sec:language/forwarding} shows an extended typing rule for handling constructs that natively supports forwarding.
%
}\fi
