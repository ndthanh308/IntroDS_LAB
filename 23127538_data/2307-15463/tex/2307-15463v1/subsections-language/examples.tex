\newcommand{\cbody}{c_{\mathit{body}}}

\subsection{Examples} \label{sec:language/exmaples}

In this section, we demonstrate how our type system verifies programs with
algebraic effects and handlers by showing typing derivations of a few
examples.
%
Here, we abbreviate a pure computation type $\tycomp{\{\}}{T}{\square}$ to $T$
and omit the empty typing context from typing and subtyping judgments.
%
For simplicity, we often write $c_1~c_2$ for an expression
$\explet{x_1}{c_1}{\explet{x_2}{c_2}{x_1~x_2}}$ where $x_1$ does not occur in
$c_2$, and $\expret{c}$ for an expression $\explet{x}{c}{\expret{x}}$ if $c$ is
pure (e.g., as $\expret{a-b}$).


\subsubsection{Example 1: Nondeterministic Computation} \label{sec:language/examples/nondet}
We first revisit the example presented in Section~\ref{sec:overview/algeff}.
In our language, it can be expressed as follows:
\begin{align}
    \expwith{h}{ \;
        (&\explet{a}{\expop[decide]{()}{y}{\expif{y}{\expret{10}}{\expret{20}}}}{ \\
            &\explet{b}{\expop[decide]{()}{y'}{\expif{y'}{\expret{1}}{\expret{2}}}}{ \;
                \expret{a - b}
            }
        })
    }
\end{align}
where
$
 h \defeq \{ \expret{x_r} \mapsto \expret{x_r},
         \op[decide](x, k) \mapsto \explet{r_t}{k~\exptrue}{
            \explet{r_f}{k~\expfalse}{\mathrm{max}~r_t~r_f}
            } \}
$ ~.
%
As seen before, executing this program results in $19$.
Our system can assign the most precise type $\tyrfn{z}{\tyint}{z = 19}$ to this program.
The rest of this section shows the typing process to achieve this type assignment.
%
In what follows, we write $\Gamma_{\rep{x}}$ for the typing context binding the
variables $\rep{x}$ with some appropriate types $\rep{B}$.
%
In particular, these variables have these base types:
$x_r : \tyint$, $a : \tyint$, $b : \tyint$, $y : \tybool$, and $y' : \tybool$.

First, consider the types assigned to the clauses in the handler $h$.
%
The clause for $\op[decide]$ can be typed as follows:
\begin{align} \label{eqn:typ-decide-clause}
    &\jdty{
        X: (\tyint, \tybool), x: \tyunit,
        k: (y: \tybool) \rarr \tyrfn{z}{\tyint}{X(z, y)} \\ &\quad
    }{
        \explet{r_t}{k~\exptrue}{
            \explet{r_f}{k~\expfalse}{\mathrm{max}~r_t~r_f}
        }
    }{\tyrfn{z}{\tyint}{\phi}}
\end{align}
where $\phi \defeq \forall r_t r_f.
X(r_t, \exptrue) \land X(r_f, \expfalse) \implies z = \mathtt{max}(r_t, r_f)$, where $\mathtt{max}$ is a term-level function that returns the larger of given two integers.
%
In this typing judgment, the predicate variable $X$ abstracts over relationships
between inputs to and outputs from delimited continuations captured by calls to
$\op[decide]$, and the refinement formula $\phi$ summarizes what the operation
clause computes.
%
Therefore, the operation signature $\Sigma$ of the type of the handled
computation, which we denote by $\cbody$ in what follows, can be given as
follows:
\begin{align}
    \Sigma \,\defeq\, \{ &\op[decide]: \forall X: (\tyint, \tybool).
        (x: \tyunit) \rarr ((y: \tybool) \rarr \tyrfn{z}{\tyint}{X(z, y)})
        \rarr \tyrfn{z}{\tyint}{\phi}
    \} ~. \!
\end{align}
%
The return clause can be typed as
$\jdty{\Gamma_{x_r}}{\expret{x_r}}{\tyrfn{z}{\tyint}{z = x_r}}$.

Therefore, we can conclude that the program is typable as desired by the following derivation
\begin{prooftree}
 \AxiomC{\Shortstack{
 {$\jdty{\Gamma_{x_r}}{\expret{x_r}}{\tyrfn{z}{\tyint}{z = x_r}}$ \qquad
  (Judgment (\refeq{eqn:typ-decide-clause}))}
 {(I) \ \ %
  $\jdty{}{\cbody}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\tyrfn{z}{\tyint}{z = 19}}}}$}
 }}
 \RightLabel{\rulename{T-Hndl}}
 \UnaryInfC{$\jdty{}{\expwith{h}{\cbody}}{\tyrfn{z}{\tyint}{z = 19}}$}
\end{prooftree}
if the premise (I) for $\cbody$ holds.
%
We derive it by \rulename{T-Let}, obtaining a derivation of the form
%f
\begin{prooftree}
 \AxiomC{
   \stackanchor{
     (II) \ \ %
     $\jdty{}{\expop[decide]{()}{y}{\kw{if} \ y \ \cdots}}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{z = 19}}}}$
   }{
     (III) \ \ %
     $\jdty{\Gamma_{a}}{\explet{b}{\cdots}{\expret{a - b}}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_1}}}$
   }
 }
 \RightLabel{\rulename{T-Let}}
 \UnaryInfC{
   (I) \ \ $\jdty{}{\cbody}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\tyrfn{z}{\tyint}{z = 19}}}}$
 }
\end{prooftree}
for some type $C_1$.
%
Next, we examine judgement (III) first because its derivation gives the
constraints to identify the type $C_2$.
%
By \rulename{T-Let} again, we can derive
\begin{prooftree}
 \AxiomC{\stackanchor{
  (III-1) \ \ %
  $\jdty{\Gamma_{a}}{\expop[decide]{()}{y'}{\kw{if} \ y' \ \cdots}}{\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_1}}}$
 }{
  (III-2) \ \ %
  $\jdty{\Gamma_{a,b}}{\expret{a - b}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }}
 \RightLabel{\rulename{T-Let}}
 \UnaryInfC{
  (III) \ \ %
  $\jdty{\Gamma_{a}}{\explet{b}{\cdots}{\expret{a - b}}}{\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_1}}}$
 }
\end{prooftree}
with the premises (III-1) and (III-2) and some type $C_2$.
%
Judgment (III-2) is derivable by
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdty
   {\Gamma_{a,b}}
   {\expret{a - b}}
   {\tyrfn{z}{\tyint}{z = a - b}}$
 }{
  (III-2-S) \ \ %
  $\jdsub
   {\Gamma_{a,b}}
   {\tyrfn{z}{\tyint}{z = a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }}
 \RightLabel{\rulename{T-Sub}}
 \UnaryInfC{
  (III-2) \ \ %
  $\jdty
   {\Gamma_{a,b}}
   {\expret{a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }
\end{prooftree}
with the derivation of the subtyping judgment (III-2-S):
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdsub{\Gamma_{a,b}}{\Sigma}{\emptyset}$
  \qquad
  $\jdsub{\Gamma_{a,b}}{\tyrfn{z}{\tyint}{z = a - b}}{\tyint}$
 }{
  $\jdsub
   {\Gamma_{a,b} \mid \tyrfn{z}{\tyint}{z = a - b}}
   {\square}
   {\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}$
 }}
 \RightLabel{\rulename{S-Comp}}
 \UnaryInfC{
  (III-2-S) \ \ %
  $\jdsub
   {\Gamma_{a,b}}
   {\tyrfn{z}{\tyint}{z = a - b}}
   {\tycomp{\Sigma}{\tyint}{\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{C_2}}}$
 }
\end{prooftree}
%
The first two subtyping premises are derivable trivially.
%
We can derive the third one by letting
$
 C_2 \defeq \tyrfn{z}{\tyint}{z = a - b}
$
because:
\begin{prooftree}
 \AxiomC{
  $\valid
   {\Gamma_{a,b}, x_r: \tyrfn{z}{\tyint}{z = a - b}, z: \tyint}
   {(z = x_r) \implies (z = a - b)}$
 }
 \RightLabel{\rulename{S-Rfn}}
 \UnaryInfC{
  $\jdsub
   {\Gamma_{a,b}, x_r: \tyrfn{z}{\tyint}{z = a - b}}
   {\tyrfn{z}{\tyint}{z = x_r}}
   {\tyrfn{z}{\tyint}{z = a - b}}$
 }
 \RightLabel{\rulename{S-Embed}}
 \UnaryInfC{
  $\jdsub
  {\Gamma_{a,b} \mid \tyrfn{z}{\tyint}{z = a - b}}
  {\square}
  {\tyctl{x_r}{\tyrfn{z}{\tyint}{z = x_r}}{\colorbox{gray!50}{$\tyrfn{z}{\tyint}{z = a - b}$}}}$
 }
\end{prooftree}
where the grayed part is denoted by $C_2$ in the original premise.
%
We note that our type inference algorithm automatically infers such a type by constraint solving (cf.~Section~\ref{sec:impl}).
%
For judgment (III-1), we instantiate the predicate variable $X$ in the type scheme of $\op[decide]$ in $\Sigma$ with the predicate
$
 A \,\defeq\, \lambda (z, y). z = (\ternaryif{y}{(a-1)}{(a-2)})
$
(again, the type inference algorithm finds such a predicate from the constraints on $A$).
%
Judgment (III-1) is derived by \rulename{T-Op}, but for that, we need to let
$
 C_1 \,\defeq\, \tyrfn{z}{\tyint}{\phi}[A/X]
$
%
because of the typing constraint of \rulename{T-Op}.
%
Then, we have the following derivation:
\begin{prooftree}
 \AxiomC{
 (III-1') \ \ %
 $\jdty
  {\Gamma_{a,y'}}
  {\kw{if} \ y' \ \cdots}
  {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{\tyrfn{z}{\tyint}{A(z, y')}}}}$
 }
 \RightLabel{\rulename{T-Op}}
 \UnaryInfC{
 (III-1) \ \ %
 $\jdty{a: \tyint}{\expop[decide]{()}{y'}{\kw{if} \ y' \ \cdots}}{\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{C_1}}}$
 }
\end{prooftree}
(note that the type $\tyrfn{z}{\tyint}{A(z, y')}$ is the instantiated initial answer type of $\op[decide]$.)
where judgment (III-1') is derived by:
\begin{prooftree}
 \AxiomC{\stackanchor{
  $\jdty{\Gamma_{a,y'}}
        {\kw{if} \ y' \ \cdots}
        {\tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}$
 }{
  $\jdsub{\Gamma_{a,y'}}
         {\tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
         {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{\tyrfn{z}{\tyint}{A(z, y')}}}}$
 }}
 \RightLabel{\rulename{T-Sub}}
 \UnaryInfC{
 (III-1') \ \ %
 $\jdty
  {\Gamma_{a,y'}}
  {\kw{if} \ y' \ \cdots}
  {\tycomp{\Sigma}{\tyint}{\tyctl{b}{C_2}{\tyrfn{z}{\tyint}{A(z, y')}}}}$
 }
\end{prooftree}
%
It is easy to see that the first typing premise holds.
%
We can derive the second subtyping premise similarly to subtyping
judgment (III-2-S), namely, by \rulename{S-Comp} with the following derivation
for the subtyping on control effects:
%
\begin{prooftree}
 \AxiomC{
  $\valid
   {\Gamma_{a,y'}, b: \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
   {(z = a - b) \implies A(z,y')}$
 }
 \RightLabel{\rulename{S-Rfn}}
 \UnaryInfC{
  $\jdsub
   {\Gamma_{a,y'}, b: \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}
   {C_2}
   {\tyrfn{z}{\tyint}{A(z, y')}}$
 }
 \RightLabel{\rulename{S-Embed}}
 \UnaryInfC{$\jdsub{\Gamma_{a,y'} \mid \tyrfn{z}{\tyint}{z = (\ternaryif{y'}{1}{2})}}{\square}{\tyctl{b}{C_2}{\tyrfn{z}{\tyint}{A(z, y')}}}$}
\end{prooftree}
%

Finally, we examine judgment (II).
To apply \rulename{T-Op}, we instantiate the predicate variable $X$ in the first call to $\op[decide]$
with the predicate
$
 A' \,\defeq\, \lambda (z, y). z = (\ternaryif{y}{9}{19}) ~.
$
Then, we can derive the judgment by \rulename{T-Sub}:
%
\begin{prooftree}
 \AxiomC{
 $\jdty{\Gamma_{y}}
       {\kw{if} \ y \ \cdots}
       {\tycomp{\Sigma}{\tyint}{\tyctl{a}{\tyrfn{z}{\tyint}{z = a - 1}}{\tyrfn{z}{\tyint}{A'(z, y)}}}}$
 }
 \RightLabel{\rulename{T-Op}}
 \UnaryInfC{
 $\jdty{}{\expop[decide]{()}{y}{\kw{if} \ y \ \cdots}}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{\phi[A'/X]}}}}$
 }
\end{prooftree}
where the premise is derived similarly to (III-1'); and
\[
 \jdsub{}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{\phi[A'/X]}}}}{\tycomp{\Sigma}{\tyint}{\tyctl{a}{C_1}{\tyrfn{z}{\tyint}{z = 19}}}} ~,
\]
holds because the formula $\phi[A'/X]$ is semantically equivalent to the formula $z = 19$.

We note that the predicate variable in the type scheme of $\op[decide]$ is important to typing this example.
%
The delimited continuations captured by the two calls to $\op[decide]$ behave differently. Namely, they respectively behave according to the predicates $A(u,v)$ and $A'(u,v)$ where $u$ is the integer output given the boolean input $v$.
%
By using predicate variables, our type system gives a single type scheme to an operation that abstracts over such different behaviors.\footnote{An alternative approach is to use intersection types (i.e., allow a set of types to be given to an operation).  But, we find our approach more uniform as it is able to give a single compact type scheme.}

\subsubsection{Example 2: State} \label{sec:language/examples/state}
%
We next revisit the second example from Section~\ref{sec:overview/algeff}.
%
For this example, we use
the following syntactic sugars: $c_1;\,c_2 \,\defeq\, \explet{x}{c_1}{c_2}$
(where $x$ does not occur in $c_2$); $\lambda x. v \,\defeq\, \lambda x. \expret{v}$; and $\op~v \,\defeq\, \expop{v}{y}{\expret{y}}$.
%
Then,
the program given in Section~\ref{sec:overview/algeff} is in our language.
%
This program uses two operations: $\op[set]$, which updates the state value, and
$\op[get]$, which returns the current state value. The handling construct returns a function that
maps any integer value to the value $8$;
arguments to the function are initial state values, but they are not used
because the function begins by initializing the state.
Applying the function to the initial state value $0$, the whole program returns $8$.

This program is expected to be of the type
$\tyrfn{z}{\tyint}{z = 8}$.
%
The rest of this section explains how the type system assigns this type
to the program.
%
First, the operation signature $\Sigma$ for the handler $h$ can be defined as follows:
\[\begin{array}{@{}l@{\ \ }l@{\ \ }l}
 \Sigma &\defeq&
   \{
        \op[set]: \forall X: (\tyint, \tyint).\,
            (x: \tyint) \rarr (\tyunit \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s)})) \\
    && \qquad\qquad\qquad\qquad\qquad\qquad\qquad      \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, x)}), \\
   && \ \, \op[get]: \forall X: (\tyint, \tyint, \tyint).\,
            \tyunit \rarr ((y: \tyint) \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s, y)})) \\
    && \qquad\qquad\qquad\qquad\qquad\qquad\qquad      \rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s, s)})
    \ \}
  \end{array}
\]
%
%
Then, each sub-computation in the handled computation can be typed as follows:
\[\begin{array}{r@{\ }l}
    \jdty{&}{\op[set]~3}{\tycomp{\Sigma}{\tyint}{
        \tyctl{\_}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = s + 5}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 8}
        }
    }} \\
    \jdty{&}{\op[get]~()}{\tycomp{\Sigma}{\tyint}{
        \tyctl{n}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + 5}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = s + 5}
        }
    }} \\
    \jdty{n: \tyint&}{\op[set]~5}{\tycomp{\Sigma}{\tyint}{
        \tyctl{\_}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + s}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + 5}
        }
    }} \\
    \jdty{n: \tyint&}{\op[get]~()}{\tycomp{\Sigma}{\tyint}{
        \tyctl{m}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + m}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + s}
        }
    }} \\
    \jdty{n: \tyint, &m: \tyint}{\expret{n + m}}{\\ \tycomp{\Sigma}{\tyrfn{x_r&}{\tyint}{x_r = n + m}}{
        \tyctl{x_r}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = x_r}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = n + m}
        }
    }}
  \end{array}
\]
The first four judgments are derived by \rulename{T-Op} with appropriate
instantiation of the type schemes of $\op[set]$ and $\op[get]$.
%
The last judgement is derived using \rulename{S-Embed} as in the first example.
The type of the handled computation is derived from these computation types, taking the following form:
\[
    \tycomp{\Sigma}{\tyint}{
        \tyctl{x_r}{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = x_r}
        }{
            (s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 8}
        }
    } ~.
\]
Therefore, by \rulename{T-Hndl}, the type of the handling construct is
$(s: \tyint) \rarr \tyrfn{z}{\tyint}{z = 8}$, and by \rulename{T-App}, the type of the whole program is $\tyrfn{z}{\tyint}{z = 8}$
as promised.
