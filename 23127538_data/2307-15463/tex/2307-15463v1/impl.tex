\section{Implementation} \label{sec:impl}

In this section, we describe our prototype implementation of
a refinement type checking and inference system, \textsc{RCaml}\footnote{available at \url{https://github.com/hiroshi-unno/coar}}.
It takes a program written in a subset of the OCaml 5 language
(including algebraic data types, pattern matching, recursive functions, exceptions, references,
let-polymorphism, and effect handlers)
and a specification of its main function represented as a refinement type.
It first (1) obtains an ML-typed AST of the program
using OCaml's compiler library,
(2) infers refinement-free operation signatures and control effects,
(3) generates refinement constraints for the program and its specification as Constrained Horn Clauses (CHCs) (see e.g., \cite{Bjorner2015a}),
and finally (4) solves these constraints
to verify whether the program satisfies the specifications.
The steps (3) and (4), where the refinement type checking is reduced to CHC solving,
follow existing standard approach such as \cite{Unno09,Rondon08}.
The inference of (refinement-free) operation signatures is similar to
that of record types using row variables,
and is mutually recursive with the inference of control effects.
It is based on the type inference system of control effects for shift0/reset0
proposed by \citet{Materzok11}.
%
As we split the steps of CHC generation and CHC solving,
we can use different kinds of solvers as the backend CHC solver depending on benchmarks.
In this experiment, we used two kinds of CHC solvers:
\textsc{Spacer}~\cite{Komuravelli13} that is based on Property Directed Reachability (PDR)\cite{Bradley11,Een11} and CEGAR\cite{Clarke00},
and \textsc{PCSat}~\cite{Unno2021} that is based on template-based CEGIS\cite{Solar-Lezama06,Unno2021} with Z3~\cite{Moura2008} as an SMT solver.

Because inputs to the implementation are OCaml programs
that are type-checked by OCaml's type checker which does not allow ATM,
the underlying OCaml types of the answer types cannot be modified.
However, as remarked before in Section~\ref{sec:intro}, our aim is to verify \emph{existing} programs with algebraic effects and handlers,
and, as remarked before, our ARM, that is only modification in the refinements, is useful for that purpose.

Our implementation supports several kinds of polymorphism.
In addition to the standard let-polymorphism on types,
it supports refinement predicate polymorphism.
The implementation extends the formal system by allowing {\em bounded} predicate polymorphism in which abstracted predicates can be bounded by constraints on them, and further allows predicate-polymorphic types to be assigned to let-bound terms.
However, because the implementation can infer predicate-polymorphic types only at let-bindings,
we used a different approach, which we will discuss in Section~\ref{sec:impl/eval},
to simulate predicate polymorphism in operation signatures.

%
Another notable point is that our implementation deals with operations and exceptions uniformly.
That is, exception raising is treated as an operation invocation
and it can be handled by a certain kind of effect handlers which have clauses for exceptions
(the exception clauses are included in the effect handlers of OCaml by default).

\subsection{Evaluation} \label{sec:impl/eval}

We performed a preliminary experiments to evaluate our method
on some benchmark programs that use algebraic effect handlers.
The benchmarks are based on example programs
from \citet{Bauer15} and the repository of the Eff language~\cite{Effrepo}.
We gathered the effect handlers in those examples
and created benchmark programs each of which uses one of the effect handlers.
We also added a refinement type specification of the main function to each benchmark.
(Other functions are not given such extra information,
and so their types are \emph{inferred automatically} even for recursive functions.)
Also, we added small amount of  annotations to the benchmarks.
Most benchmarks could be solved automatically without the annotations,
but some needs them as hints.
We discuss the details at the end of this section.
We refer to the supplementary material
for the concrete source codes and the specifications of our benchmarks.
Particularly, an interesting one (\texttt{queue-2-SAT.ml}) is explained in detail in Appendix~\ref{sec:benchmark-details}.
All the experiments were conducted on
Intel Xeon Platinum8360Y, 256GB RAM.

\begin{table}
    \caption{Evaluation results}
    \label{tab:eval}
    \footnotesize
    \begin{tabular}{lcrcr}
        \toprule
        \multirow[c]{2}{*}{file name} & \multicolumn{2}{c}{\textsc{Spacer}} & \multicolumn{2}{c}{\textsc{PCSat}} \\
        & result correct? & time (sec.) & result correct? & time (sec.) \\
        \midrule
        \texttt{amb-1-SAT.ml} & Yes & 0.55 & Yes & 15.30 \\
        \texttt{amb-1-UNSAT.ml} & Yes & 0.72 & Yes & 63.62 \\
        \texttt{amb-2-SAT.ml} & Yes & 2.31 & Yes & 31.48 \\
        \texttt{amb-2-UNSAT.ml} & Yes & 2.26 & - & timeout$^\dagger$ \\
        \texttt{amb-3-SAT.ml} & Yes & 3.20 & Yes & 182.41 \\
        \texttt{amb-3-simpl-SAT.ml} & Yes & 1.71 & Yes & 16.79 \\
        \texttt{bfs-SAT.ml} & No$^{*1}$ & 1.67 & - & timeout$^{*1}$ \\
        \texttt{bfs-UNSAT.ml} & Yes & 2.00 & - & timeout$^\dagger$ \\
        \texttt{bfs-simpl-SAT.ml} & No$^{*1}$ & 2.22 & - & timeout$^{*1}$ \\
        \texttt{choose-all-SAT.ml} & Yes & 16.23 & - & timeout$^\dagger$ \\
        \texttt{choose-all-UNSAT.ml} & Yes & 12.56 & - & timeout$^\dagger$ \\
        \texttt{choose-max-SAT.ml} & Yes & 23.08 & - & timeout$^\dagger$ \\
        \texttt{choose-max-UNSAT.ml} & Yes & 15.97 & - & timeout$^\dagger$ \\
        \texttt{choose-sum-SAT.ml} & Yes & 1.54 & - & timeout$^\dagger$ \\
        \texttt{choose-sum-UNSAT.ml} & Yes & 7.99 & Yes & 15.00 \\
        \texttt{deferred-1-SAT.ml} & Yes & 0.46 & Yes & 4.49 \\
        \texttt{deferred-1-UNSAT.ml} & Yes & 0.27 & Yes & 4.09 \\
        \texttt{deferred-2-SAT.ml} & Yes & 0.43 & Yes & 4.38 \\
        \texttt{distribution-SAT.ml} & Abort$^\div$ & - & - & timeout$^{*2}$ \\
        \texttt{distribution-UNSAT.ml} & Abort$^\div$ & - & - & timeout$^{*2}$ \\
        \texttt{expectation-SAT.ml} & Yes & 0.51 & Yes & 7.25 \\
        \texttt{expectation-UNSAT.ml} & Yes & 1.45 & Yes & 7.33 \\
        \texttt{io-read-1-SAT.ml} & Yes & 0.43 & Yes & 13.90 \\
        \texttt{io-read-1-UNSAT.ml} & Yes & 0.41 & Yes & 12.21 \\
        \texttt{io-read-2-SAT.ml} & Yes & 0.56 & Yes & 21.10 \\
        \texttt{io-read-3-SAT.ml} & Yes & 0.54 & Yes & 14.88 \\
        \texttt{io-write-1-SAT.ml} & Yes & 0.32 & Yes & 8.48 \\
        \texttt{io-write-1-UNSAT.ml} & Yes & 0.32 & Yes & 8.76 \\
        \texttt{io-write-2-SAT.ml} & Yes & 0.46 & Yes & 11.33 \\
        \texttt{io-write-2-UNSAT.ml} & Yes & 0.68 & Yes & 11.65 \\
        \texttt{modulus-SAT.ml} & Yes & 14.23 & Yes & 11.89 \\
        \texttt{modulus-UNSAT.ml} & Yes & 26.56 & Yes & 11.91 \\
        \texttt{queue-1-SAT.ml} & Yes & 0.78 & Yes & 19.22 \\
        \texttt{queue-1-UNSAT.ml} & Yes & 0.52 & Yes & 16.93 \\
        \texttt{queue-2-SAT.ml} & Yes & 0.89 & Yes & 22.63 \\
        \texttt{round-robin-SAT.ml} & Yes & 0.96 & - & timeout$^\dagger$ \\
        \texttt{round-robin-UNSAT.ml} & Yes & 0.73 & - & timeout$^\dagger$ \\
        \texttt{safe-div-1-SAT.ml} & Abort$^\div$ & - & Yes & 2.71 \\
        \texttt{safe-div-1-UNSAT.ml} & Abort$^\div$ & - & Yes & 2.73 \\
        \texttt{safe-div-2-SAT.ml} & Abort$^\div$ & - & Yes & 2.55 \\
        \texttt{safe-div-2-UNSAT.ml} & Abort$^\div$ & - & Yes & 3.58 \\
        \texttt{select-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 13.28 \\
        \texttt{select-UNSAT.ml} & - & timeout$^{\ddagger}$ & Yes & 13.26 \\
        \texttt{shift-SAT.ml} & Yes & 0.28 & Yes & 2.92 \\
        \texttt{shift-UNSAT.ml} & Yes & 1.25 & Yes & 3.93 \\
        \texttt{state-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 33.69 \\
        \texttt{state-UNSAT.ml} & Yes & 0.63 & Yes & 13.56 \\
        \texttt{state-easy-SAT.ml} & Yes & 0.90 & Yes & 35.54 \\
        \texttt{transaction-SAT.ml} & - & timeout$^{\ddagger}$ & Yes & 15.36 \\
        \texttt{transaction-UNSAT.ml} & - & timeout$^{\ddagger}$ & Yes & 15.77 \\
        \texttt{yield-SAT.ml} & Yes & 1.51 & Yes & 17.57 \\
        \texttt{yield-UNSAT.ml} & Yes & 1.52 & - & timeout$^\dagger$ \\
        \bottomrule
    \end{tabular}
\end{table}

Table~\ref{tab:eval} shows the results of the evaluation.
The files that are suffixed with \texttt{-SAT} are expected to result in ``SAT'',
that is, the programs are expected to be typed
with the refinement types given as their specification.
The other files (suffixed with \texttt{-UNSAT}) are expected to result in ``UNSAT'',
that is, the programs are expected not to be typed
with the refinement types given as their specification.
For each program, we conducted verification in two configurations
((1) \textsc{Spacer}, and (2) \textsc{PCSat}).
The field ``time'' indicates the time spent in the whole process of the verification.
We set the timeout to 600 seconds.
%
Our implementation successfully answered correct result for most programs.
The ones that could not be verified in both configurations are
\texttt{bfs(-simpl)-SAT.ml} (marked with $*1$)
and \texttt{distribution-(UN)SAT.ml} (marked with $*2$).
They need some specific features which the implementation does not support.
The formers need
an invariant which states that there exists an element of a list
that satisfies a certain property.
The latter needs recursive predicates
in the type of an integer list, which states a property about the sum of the elements of the list.
These issues are orthogonal to the main contributions of this paper;
they are about the expressiveness of the background theory used for refinement predicates, to which our novel refinement type system is agnostic.


We discuss pros and cons between the two configurations.
First, \textsc{Spacer} does not support division operator,
and so it cannot verify some programs that use division (marked with $\div$,
aborting with the message ``\texttt{Z3 Error: Uninterpreted 'div' in <null>}'').
Also, there are some programs which can be solved by \textsc{Spacer}
but not solved by \textsc{PCSat} in time, and vice versa.
The formers (marked with $\dagger$) seem due to the huge size of generated constraints,
which can be solved by \textsc{Spacer} but not by \textsc{PCSat}.
The latters (marked with $\ddagger$) can be solved
by \textsc{PCSat} but not by \textsc{Spacer}.

It is worth noting that
our benchmark programs do not rely on refinement type annotation in most places,
even for recursive functions and recursive ADTs.
However, a few kinds of annotations are still needed.
First, as mentioned in Section~\ref{sec:language/discussions},
our type system does not support effect polymorphism.
Therefore, we added effect annotations to function-type arguments
which may perform operations when executed.
These annotations are written in the underlying OCaml types,
that is, we did not specify concrete refinements in the annotations.
Second,
we provided refinement type annotations for two small parts of \texttt{state-SAT.ml},
because otherwise it could not be verified within the timeout period in both configurations.
Third, because our implementation
infers predicate-polymorphic types only at let-bindings,
we added \emph{ghost parameters} to some operations and functions
to
infer precise refinement types of them which are not let-bound
but need some abstraction of refinements.
Ghost parameters are parameters which are used to express dependencies in dependent type checking,
but have no impact on the dynamic execution of the program so they can be removed at runtime.
In automated verification, completely inferring predicate variables requires
higher-order predicate constraints, which are not expressible with CHC.
Therefore, we provided ghost parameter annotations
to make it possible to reduce the verification to CHC constraint solving.
For example, the following code is a part of \texttt{state-SAT.ml}:
\begin{verbatim}
let rec counter c =
    let i = perform (Lookup c) in
    if i = 0 then c else (perform (Update (c, i - 1)); counter (c + 1))
in counter 0
\end{verbatim}
which is handled by a handler that simulates a mutable reference
similar to that of Example 2 in Section~\ref{sec:language/examples/state}.
Here, we pass the variable $c$ to the operation \texttt{Lookup} and \texttt{Update}
as the ghost parameter.
In the formal system presented in Section~\ref{sec:language/type-system}
where predicate polymorphism is available in operation signatures,
we can give \texttt{Update} the type
\begin{align}
    \forall X: (\tyint, \tyint).\,
        (x: \tyint) \rarr (\tyunit &\rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, s)})) \\
    &\rarr ((s: \tyint) \rarr \tyrfn{z}{\tyint}{X(z, x)})
\end{align}
in the same way as Example 2 in Section~\ref{sec:language/examples/state},
and instantiate the predicate variable $X$ with $\lambda (z, s). z = c + 1 + s$
to correctly verify \texttt{state-SAT.ml}.
On the other hand, in the implementation, since predicate polymorphism is not available in operation signatures,
the handler needs to know the concrete predicate which replaces $X$.
However, the predicate contains $c$, which the handler cannot know
without receiving some additional information.
Therefore, we need to add the ghost parameter $c$ to \texttt{Update}
(and the same for \texttt{Lookup}).
This time we added them manually,
but one possible approach for automating insertion of ghost parameters is
to adopt the technique proposed by \citet{Unno13}.
We conjecture that a similar technique can be used
for our purpose.
