\section{Introduction} \label{sec:intro}

Algebraic effects \cite{Plotkin03} and handlers \cite{Plotkin09,Plotkin13} are a mechanism
to structure programs with computational effects
in a modular way.
Algebraic effects represent abstracted computational effects
and handlers specify their behaviors using delimited continuations.
The ability to use delimited continuations makes algebraic effects and handlers highly expressive,
allowing them to describe prominent computational effects
such as exceptions, nondeterminism, mutable states, backtracking, and
cooperative multithreading.
Additionally, algebraic effects and handlers are recently gaining quite a recognition in practice
and are adopted in popular programming languages,
such as OCaml \cite{Sivaramakrishnan21}.

Meanwhile, there has been substantial progress in program verification via {\em refinement type systems}~\cite{DBLP:conf/pldi/FreemanP91,DBLP:conf/popl/XiP99,Rondon08,Unno09,DBLP:conf/popl/Terauchi10,Bengston11,DBLP:conf/vmcai/ZhuJ13,DBLP:conf/icfp/VazouSJVJ14,DBLP:conf/popl/SwamyHKRDFBFSKZ16,DBLP:conf/pldi/VekrisCJ16,DBLP:journals/pacmpl/0001ST18,DBLP:conf/lics/Nanjo0KT18,Sekiyama23}. Such type systems allow the user to express a precise specification for a program as a type embedding logic formulas and their type checking (sometimes even type inference) (semi-)algorithms (semi-)automatically check whether the program conforms to the specification.  While a variety of refinement type systems have been proposed for various classes of programming languages and features, including functional languages~\cite{DBLP:conf/pldi/FreemanP91,Rondon08,DBLP:conf/icfp/VazouSJVJ14}, object-oriented languages~\cite{DBLP:conf/pldi/VekrisCJ16}, and delimited control operators~\cite{Sekiyama23}, there has not been a satisfactory refinement type system for programming languages with algebraic effects and handlers.

In this work, we propose a new refinement type system
for algebraic effects and handlers.
A challenge with the precise verification in the presence of algebraic effects and handlers is that the \emph{delimited continuations}, which are the key ingredient of algebraic effect and handlers that give their expressive power, complicate programs' control flow and make it difficult to statically discern what effects occur in what order.
%
To address this challenge,
we propose a novel concept that we call \emph{answer refinement modification} (ARM for short),
inspired by \emph{answer type modification} (ATM) for type systems for delimited control operators such as \texttt{shift} and \texttt{reset} \cite{Danvy90,Asai09}.
%
Similarly to how ATM is used to statically track how the use of delimited control operators influence the types of expressions, our ARM can be used to statically track how the use of algebraic effect operations (and the execution of the corresponding handlers) influence the refinements in the types of expressions, where the latter, as in prior refinement type systems, are used to precisely describe the {\em values} computed by the expressions.  Thus, our novel refinement type sysetm supporting ARM can be used to precisely reason about programs with algebraic effects and handlers.

ATM and ARM are closely related: in fact, our refinement type system supports ATM, that is, our system allows the whole types and not just the refinements in them to be modified.
%
As far as we know, the only prior (ordinary or refinement) type system for algebraic effects and handlers that supports ATM or ARM is a recent system of \citet{Cong22}.
However, their system does not support refinement types (and so, obviously, no ARM), and moreover, even when compared as mechanisms for ordinary type systems, their ATM is less expressive than ours. We refer to Section~\ref{sec:related} for detailed comparison.


While our system supports the full ATM,
from the perspective of program verification, ARM alone, that is, only modification in type refinements, is useful.
Indeed, as in other refinement-type-based approaches, our aim is verification of programs typed in \emph{ordinary} background type systems
(such as the type systems of OCaml 5 and Koka that do not support ATM),
not to make more programs typable by extending the background type systems with ATM.
%
As a proof of concept, we have designed a refinement type system and implemented a corresponding type checking and inference algorithm for a subset of OCaml 5 which comes with a built-in support for effect handlers, and evaluated it on a number of benchmark programs that use algebraic effects and handlers.
The evaluation demonstrates that ARM is conceptually simple and practically useful.

Finally, a natural alternative to directly reasoning about a program with delimited continuations is to apply a continuation passing style (CPS) transformation that transforms the program to a pure program without delimited continuations. We investigate this alternative in the paper, and show that the approach is indeed possible by proposing a novel CPS transformation for algebraic effects and handlers that enjoys bidirectional (refinement-)type-preservation.
Bidirectional type-preservation means that an expression is well-typed in the source language if and only if
its CPS-transformed result is well-typed in the target language.
This implies that we can use existing refinement type systems without support for effect handlers to verify programs with effect handlers by applying our CPS transformation.
However, like other CPS transformations~\cite{Plotkin75,Danvy90,Appel92,Hillerstrom17,Cong18}, ours makes global changes to the program and can radically change its structure, making it difficult for the programmer to recast the type checking and inference results back to the original program. Also, the CPS transformation is type directed and requires the program to be annotated by types conforming to our new type system, albeit only needing type ``structures'' without concrete refinement predicates.
Moreover, in some cases, CPS-transformed expressions need extra parameters or higher-order predicate polymorphism to be typed as precisely as the source expressions, because the CPS transformation introduces higher-order continuation arguments.
Nonetheless, our CPS transformation is novel, and we foresee that it would provide new interesting insights, as CPS transformations often do~\cite{Danvy90}, and be a useful tool for future studies on refinement type systems and effect handlers.

Our main contributions are summarized as follows.
\begin{itemize}
    \item We show a sound refinement type system
        for algebraic effects and handlers,
        where ARM plays an important role.
    \item We have implemented the refinement type system for a subset of OCaml language
        with effect handlers, and evaluate it on a number of programs that use effect handlers.
    \item We define a bidirectionally-type-preserving CPS transformation
        which can be used to verify programs with effect handlers,
        and discuss pros and cons between direct type checking using our system and
        indirect type checking via the CPS transformation.
\end{itemize}

The rest of the paper is organized as follows.
In Section~\ref{sec:overview}, we briefly explain algebraic effects and handlers
and ATM, and then describe the motivation for our system.
Section~\ref{sec:language} presents our language.
We define its syntax, semantics and type system,
present some typing examples, and show type safety of the language.
Section~\ref{sec:impl} explains the implementation of the system.
In Section~\ref{sec:cps}, we provide the CPS transformation
and discuss pros and cons between our direct type system
and the indirect type checking via CPS transformation.
Finally, we describe related works in Section~\ref{sec:related}
and conclude the paper in Section~\ref{sec:conclusion}.
