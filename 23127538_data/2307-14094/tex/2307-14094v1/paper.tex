\documentclass[a4paper,UKenglish,cleveref,autoref,thm-restate]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

%\bibliographystyle{plainurl}% the mandatory bibstyle
%\bibliographystyle{abbrvurl}
\bibliographystyle{abbrv}

%\renewcommand{\baselinestretch}{.989}

%%%% ORIGINAL MACRO %%%%%
\input{mymacro}

%%%%% TITLE %%%%%
\title{On Singleton Self-Loop Removal for Termination of LCTRSs with Bit-Vector Arithmetic} %TODO Please add

\titlerunning{On Singleton Self-Loop Removal for Termination of BV-LCTRSs} %TODO optional, please use if title is longer than one line

%%%%% AUTHORS %%%%%
\author{Ayuka Matsumi}%
{Graduate School of Informatics, Nagoya University, Japan}%
{matsumi@trs.css.i.nagoya-u.ac.jp}%
{}%
{}

\author{Naoki Nishida}%
{Graduate School of Informatics, Nagoya University, Japan}%
{nishida@i.nagoya-u.ac.jp}%
{https://orcid.org/0000-0001-8697-4970}%
{}

\author{Misaki Kojima}%
{Graduate School of Informatics, Nagoya University, Japan}%
{k-misaki@trs.css.i.nagoya-u.ac.jp}%
{https://orcid.org/0000-0001-5194-3947}%
{}

\author{Donghoon Shin}%
{Graduate School of Informatics, Nagoya University, Japan}%
{}%
{}% a4022683@gmail.com
{}

\authorrunning{A. Matsumi, N. Nishida, M. Kojima, and D. Shin} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Ayuka Matsumi, Naoki Nishida, Misaki Kojima, and Donghoon Shin} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

%%%% OTHER INFORMATION %%%%%
\ccsdesc[100]{Theory of computation~Rewrite systems} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{%
constrained rewriting, 
dependency pair framework, 
%rewriting induction,
imperative program
} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

%\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

\funding{This work was partially supported by JSPS KAKENHI Grant Number 18K11160.} %{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering


%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{}
\EventNoEds{1}
\EventLongTitle{}
\EventShortTitle{}
\EventAcronym{}
\EventYear{}
\EventDate{}
\EventLocation{}
\EventLogo{}
\SeriesVolume{}
\ArticleNo{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%%%% ABSTRACT %%%%%
%TODO mandatory: add short abstract of the document
\begin{abstract}
%Logically constrained term rewrite systems with bit-vector arithmetic (BV-LCTRSs, for short) are useful as models of programs written in C or other languages with fixed-width integers.
%During a proof process of rewriting induction for equivalence verification on a given rewrite system, we need to frequently prove termination of rewrite systems obtained by adding rewriting rules for induction hypotheses into the given system.
As for term rewrite systems, the dependency pair (DP, for short) framework with several kinds of DP processors is useful for proving termination of logically constrained term rewrite systems (LCTRSs, for short). %, and several kinds of DP processors are used in the framework.
However, the polynomial interpretation processor %, one of the most powerful processors in proving termination of LCTRSs with integer arithmetic, 
is not so effective against LCTRSs with bit-vector arithmetic (BV-LCTRSs, for short).
In this paper, %we aim at enhancing the power of proving termination of BV-LCTRSs.
%To this end, 
we propose a novel DP processor for BV-LCTRSs to solve a singleton DP problem consisting of a dependency pair forming a self-loop.
The processor is based on an acyclic directed graph such that the nodes are bit-vectors and any dependency chain of the problem is projected to a path of the graph.
We show a sufficient condition for the existence of such an acyclic graph, and simplify it for a specific case.
\end{abstract}

%%%%% MAIN BODY %%%%%
\section{Introduction}
\label{sec:intro}
\emph{Logically constrained term rewrite systems} (LCTRSs, for short)~\cite{KN13frocos} 
% are extensions of term rewrite systems (TRSs, for short) such that logical constraints are attached as guards to rewrite rules, and a rewrite rule is applied to a term if the attached constraint is satisfied by the matching substitution.
% LCTRSs 
are expected to be useful computational models for verifying not only functional but also imperative programs~\cite{FKN17tocl}.
%LCTRSs with bit-vector arithmetic (\emph{BV-LCTRSs}, for short) use bit-vectors to represent primitive data types, structures, and unions in a natural and precise manner~\cite{KNS19ss}, and thus BV-LCTRSs are useful for verification of programs written in C or other languages with \emph{fixed-width integers} such as \texttt{int} of C.
Especially, \emph{LCTRSs with bit-vector arithmetic} (BV-LCTRSs, for short) are useful for programs written in C or other languages with \emph{fixed-width integers} such as \texttt{int} of C because primitive data types, structures, and unions are represented by bit-vectors in a natural and precise manner~\cite{KNS19ss}.
In proving validity of an equation w.r.t.\ a given rewrite system by means of \emph{rewriting induction}~\cite{Red90,FKN17tocl}, we need to \emph{frequently} try to prove termination %---non-existence of infinite reduction sequences---
of rewrite systems obtained by adding rewriting rules for induction hypotheses into the given system.
Therefore, for verification tools based on rewriting induction, the performance of proving termination of rewriting systems has a great influence on the proof power and execution time.

The \emph{dependency pair framework} (DP framework, for short)~\cite{GTS04} equipped with \emph{DP processors} which decompose DP problems is a well investigated technique for proving termination of rewrite systems, and has been extended to many kinds of constrained rewrite systems including LCTRSs \cite{FK08,FGPSF09,Kop13termination,SNSU18eptcs}.
Some fundamental DP processors are applicable to almost all kinds of rewrite systems without any change.
For example, the \emph{dependency graph processor} 
%decomposing a given DP problem into the DP problems, each of which is obtained from an SCC of the dependency graph of the given problem, 
based on SCC decomposition
is applicable to LCTRSs.
On the other hand, the \emph{polynomial interpretation processor}, one of the most powerful processors in proving termination of LCTRSs with integer arithmetic, is applicable to a DP problem of BV-LCTRSs but not so effective against it:
It is ineffective if it contains a dependency pair with a usable rule for an operator of BVs such as addition, which may cause overflow and/or underflow.
To enhance the power of proving termination of BV-LCTRSs, we need to develop DP processors specific to BV-LCTRSs.

In this paper, we propose a novel DP processor, called a \emph{singleton self-loop removal processor} (SSR processor, for short), aiming at developing a method to prove termination of BV-LCTRSs.
Here, a dependency pair is said to \emph{form a self-loop} if it forms a dependency chain of length two or more, and a DP problem is called a \emph{singleton self-loop} problem if it is a singleton set, the pair in which forms a self-loop.
The processor takes a singleton self-loop DP problem as an input and is based on an acyclic directed graph such that the nodes are bit-vectors and any dependency chain of the problem is projected to a path of the graph.
We show a sufficient condition for the existence of such an acyclic graph, and simplify it for a specific case.
Note that the processor returns the empty set---the solved DP problem---if the sufficient condition is satisfied by a given singleton self-loop DP problem.

In the rest of the paper, familiarity with basic notions and notations on term rewriting~\cite{BN98,Ohl02} is assumed.
We follow the definition of LCTRSs in~\cite{KN13frocos,FKN17tocl}.
For brevity, we use the 4-bits bit-vectors for type {\ttfamily int}. % of C. 
We denote the set of bit-vectors of length $n$ by $\BV_n$.
To distinguish bit-vectors from decimal numbers, we follow the SMT-LIB %
%\footnote{\url{http://smtlib.cs.uiowa.edu}}
notation for bit-vectors:
A bit-vector $c\in\BV_n$, which is written as a binary numeral in \textsf{sans-serif} font, is denoted by $\bv{\mathit{c}}$.
%For $v\in\{\symb{0},\symb{1}\}^+$, we abbreviate $\overbrace{v\,v\ldots v}^n$ by $v^n$.
We often use regular expressions for binary numerals, e.g., $\symb{0}^3$ stands for $\symb{0}\symb{0}\symb{0}$.

% \subparagraph*{Related Work}
% \NN{Compare with \cite{FKS12,HGFS18}?}


\section{From C Programs to BV-LCTRSs}

% definition of BV-LCTRS 書かない？
A set $\cS$ of sorts for bit-vectors includes sort $bv_n$ for the $n$-bits bit-vectors ($n\geq 1$): $\cS\supseteq{\{bool\}\cup\{bv_n\mid n\geq1\}}$.
The set $\Valbv$ of values is $\{\symb{true},\symb{false}: bool\}\cup\bigcup_{n\geq1}\{b: bv_n \mid b\in\BV_n\}$.
The set $\Sigmabvtheory$ of theory symbols for bit-vectors is an extension of the \emph{core theory} $\Sigmacoretheory$~\cite{FKN17tocl} for logical connectives ($\lor,\land,\lnot$):
%, which is the signature for logical connectives ($\lor,\land,\lnot$), 
$\Sigmatheory = \Sigmacoretheory\cup\Val\cup
% \{{+_n},{-_n},{\times_n},{/_{n,S}},{/_{n,U}},{\%_{n,S}},{\%_{n,U}},{\&_n},{|_n},{\ll_n},{\gg_n}:bv_n\times bv_n\Rightarrow bv_n\mid n\geq1\}
% %\{ \Xi_n:bv_n\times bv_n\Rightarrow bv_n \mid n \geq 1, ~ \Xi \in \{{+},{-},{\times},{\ll},{\gg}\}\}
% %\cup
% %\{ \Xi_{n,S},\Xi_{n,U}:bv_n\times bv_n\Rightarrow bv_n \mid n \geq 1, ~ \Xi \in \{{/},{\%},{\&}\}\}
% \cup\{{\circ_{m,n}}:bv_m\times bv_n\Rightarrow bv_{m+n},extract_{n,m}:bv_n\times int\times int\Rightarrow bv_m, zext_{n,m},sext_{n,m}:bv_n\Rightarrow bv_m \mid m,n\geq1\}\cup\{{\sim_n}:bv_n\Rightarrow bv_n, rep_n:\{0,1\}\Rightarrow bv_n \mid n\geq1\}\cup\{{=_{bv_n}},{<_{n,S}},{<_{n,U}},{\leq_{n,S}},{\leq_{n,U}}:bv_n\times bv_n\Rightarrow bool\mid n\geq1\}$.
\{ {+_{bv_n}}: bv_n \times bv_n \Rightarrow bv_n, ~ {=_{bv_n}},{<_{bv_n,S}},{<_{bv_n,U}},{\geq_{bv_n,S}},{\geq_{bv_n,U}}:bv_n \times bv_n \Rightarrow bool, ~\ldots \mid n \geq 1\}$.
We drop the subscript $bv_n$ from $+_{bv_n}$, $<_{bv_n,S}$, and so on %$<_{bv_n,U}$, $\geq_{bv_n,S}$, and $\geq_{bv_n,U}$
if it is clear from the context.
The interpretation of theory symbols for bit-vectors follow the usual semantics of bit-vector arithmetic~\cite{KS16}.
%
%In this paper, we focus on BV-LCTRSs that LCTRSs with $\Sigmatheory=\Sigmabvtheory$.
%Additionally, 
%For readability, we use the 4-bits bit-vectors for type {\ttfamily int} of C. 

% Example of BV-LCTRS from C program
% 書換えの例
\begin{example}
\label{ex:bv-lctrs}
    The C program in Listing~\ref{list:cnt} is transformed into the following BV-LCTRS~\cite{KNS19ss}:
    \[
      \cRcnt\!=\!
      \left\{
      \begin{array}{@{}r@{\,}c@{\,}lc@{}}
        \symb{cnt}(x) & \to & \symb{u}_1(x,\bv{0000},\bv{0000}) & \\
        \symb{u}_1(x,i,z) & \to & \symb{u}_1(x,i\,{+}\,\bv{0001},z\,{+}\,\bv{0001}) & [i\,{<_S}\,x] \\
        \symb{u}_1(x,i,z) & \to & z & [i\,{\geq_S}\,x]
      \end{array}	
      \right\}
    \]
    where $\symb{cnt}:bv_{4}\Rightarrow bv_{4}$ and $\symb{u}_1:bv_{4} \times bv_{4} \times bv_{4} \Rightarrow bv_{4}$.
    Note that the above LCTRS is a simplified one by means of \emph{chaining}~(cf.~\cite[Section~7]{FK09}).
    Note also that \emph{calculation rules}~\cite{FKN17tocl} such as $x + y \to z ~ [ z = x + y ]$ are implicitly included in $\cRcnt$.
    For example, we have that %the following reduction sequence starting from $\symb{cnt}(\bv{0010})$:
    % \[
    %     \begin{array}{c@{\>}c@{\>}l}
    %         \symb{cnt}(\bv{0010}) & \to_{\cRcnt} & \symb{u}_1(\bv{0010},\bv{0000},\bv{0000}) \\
    %         & \to_{\cRcnt} & \symb{u}_1(\bv{0010},\bv{0000}+\bv{0001},\bv{0000}+\bv{0001}) \\
    %         & \to_{\cRcnt} & \symb{u}_1(\bv{0010},\bv{0001},\bv{0000}+\bv{0001})
    %         \to_{\cRcnt} \cdots 
    %         \to_{\cRcnt} \bv{0010}
    %     \end{array}
    % \]
    $
            \symb{cnt}(\bv{0010}) \to_{\cRcnt} \symb{u}_1(\bv{0010},\bv{0000},\bv{0000}) 
            \to_{\cRcnt} \symb{u}_1(\bv{0010},\bv{0000}+\bv{0001},\bv{0000}+\bv{0001}) 
            \to_{\cRcnt} \symb{u}_1(\bv{0010},\bv{0001},\bv{0000}+\bv{0001})
            \to_{\cRcnt} \cdots 
            \to_{\cRcnt} \bv{0010}
    $.
\end{example}

\begin{lstlisting}[caption={A C program defining a function to count $x$ times}, label=list:cnt, float=t, abovecaptionskip=\medskipamount]
int cnt(int x){
    int z=0;
    for(int i=0; i<x; i++) z++;
    return z;
}
\end{lstlisting}

\section{The DP Framework for LCTRSs}

The DP framework~\cite{GTS04} for TRSs has been extended for LCTRSs~\cite{Kop13termination}.

% DP framework for LCTRSs
Let $\cR$ be an LCTRS.
The marked symbol of a defined symbol $f:\iota_1\times\cdots\times\iota_n\Rightarrow\iota\in\cD_\cR$ is denoted by $f^\#$ and the set of marked symbols for $\cD_\cR$ is denoted by $\cD^\#_\cR$.
We introduce a fresh basic sort $dpsort$, and $f^\#$ has sort $\iota_1\times\cdots\times\iota_n\Rightarrow dpsort$.
If $t=f(t_1,\ldots,t_n)$ with $f\in\cD_\cR$, then $f^\#(t_1,\ldots,t_n)$ is denoted by $t^\#$.
%For each rule $\ell\to r ~ [\phi]\in\cR$, the \emph{dependency pairs} (DP, for short) of $\cR$ are all rules $\ell^\#\to t^\#\>[\phi]$ where $t$ is a subterm of $r$ and $root(t)\in\cD_\cR$.
For each rule $\ell\to r ~ [\phi]\in\cR$, a constrained rewrite rule $\ell^\#\to t^\#\>[\phi]$ is called a \emph{dependency pair} (DP, for short) of $\cR$ if $t$ is a subterm of $r$ and $root(t)\in\cD_\cR$.
The set of DPs of $\cR$ is denoted by $\DP(\cR)$.
In the following, we use $\cP$ as a set of DPs of $\cR$, i.e., $\cP\subseteq \DP(\cR)$.
A sequence $\rho_1,\rho_2,\ldots$ of DPs in $\cP$ is called a \emph{dependency chain} of $\cP$ ($\cP$-chain, for short) 
if there are substitutions $\gamma_1,\gamma_2,\ldots$ such that for each $i > 0$, $\gamma_i$ \emph{respects} $\rho_i=(s_i^\#\to t_i^\#\>[\phi_i])$---$\Ran(\gamma_i|_{\Var(\phi_i)\cup(\Var(t_i)\setminus\Var(s_i))})\subseteq \Val$ and $[\![ \phi_i\gamma_i]\!]=\top$---and $t_i^\#\gamma_i\to_\cR^*s_{i+1}^\#\gamma_{i+1}$.  
%The chain is said to be minimal if all $t^\#_1\gamma_1,t^\#_2\gamma_2,\ldots$ are terminating with respect to $\cR$.
% \begin{theorem}[\cite{Kop13termination}]
% \label{termination}
%     $\cR$ is terminating if and only if there is no infinite $\DP(\cR)$-chain.
% \end{theorem}
%
%A pair $(\cP,\cR)$ is called a \emph{DP problem}, and we abbreviate $(\cP,\cR)$ to $\cP$.
A \emph{DP problem}  $(\cP,\cR)$, abbreviated to $\cP$, is called \emph{chain-free} if there is no infinite $\cP$-chain.
\begin{theorem}[\cite{Kop13termination}]
\label{termination}
An LCTRS $\cR$ is terminating iff the DP problem $\DP(\cR)$ is chain-free.
\end{theorem}

A DP processor $\Proc$ is a function that maps a DP problem to a finite set of DP problems: $\Proc(\cP) \subseteq 2^\cP$. %, and decomposes DP problem.
We say that $\Proc$ is \emph{sound} if for any DP problem $\cP$, $\cP$ is chain-free, whenever all DP problems in $\Proc(\cP)$ are chain-free.
%We also say that $\Proc$ is \emph{complete} if $\Proc(\cP)$ is infinite whenever there exists an infinite DP problem in $\Proc(\cP)$.
%
%Thanks to Theorem~\ref{termination}, to prove termination of $\cR$, it suffices to prove chain-freeness of the initial DP problem $\DP(\cR)$.
%The DP framework for LCTRSs is a method to prove that DP problems are chain-free.
%In the DP framework, %given an LCTRS $\cR$, 
If the initial problem $\DP(\cR)$ is decomposed into the solved DP problem $\emptyset$ by applying sound DP processors, then the framework succeeds in proving termination of $\cR$.

A \emph{dependency graph} (DG, for short) of $\cP$ is a directed graph $\mathcal{G}=(\cP,\cE)$, denoted by $\DG(\cP)$, such that $\cE=\{(\rho_1,\rho_2) \mid \rho_1,\rho_2\in\cP, ~ \mbox{the seqeunce $\rho_1,\rho_2$ is a $\cP$-chain}\}$.
Moreover, a directed graph $\mathcal{G'}=(\cP,\cE')$ with $\cE'\supseteq \cE$ is called a \emph{DG approximation} of $\cP$.
%In the following, the notation $\EDG(\cP)$ denotes an arbitrary DG approximation of $\cP$.
%Note that a DG approximation of $\cP$ may have additional edges.
%In general, $\DG(\cP)$ is not decidable, and thus, we use $\EDG(\cP)$.
A computation of DG approximations can be seen in~\cite{Kop13termination}.
%We follow the usual definition of \emph{strongly connected components} (SCC, for short) in graph theory, 
%%i.e., an SCC of a directed graph $\mathcal{G}$ is the subgraph of $\mathcal{G}$, the nodes of which are strongly connected.
%i.e., the nodes of an SCC of a directed graph $\mathcal{G}$ are strongly connected in $G$.

% \begin{definition}[\cite{Kop13termination}]
% %    Let $\cP$ be a DP problem.
%     A DP processor $\ProcSCC$, called the SCC processor, is defined as follow:
%     $\ProcSCC(\cP)=\{\cP' \mid \mbox{$\cP'$ are the nodes of an SCC in $EDG(\cP)$}\}$
% \end{definition}
% \begin{theorem}[\cite{Kop13termination}]
%     $\ProcSCC$ is sound and complete.
% \end{theorem}
\begin{theorem}[cf.~\cite{Kop13termination}]
The \emph{dependency graph processor} $\ProcSCC$ such that 
$\ProcSCC(\cP)=\{\cP' \mid$ $\cP'$ are the nodes of an SCC in a DG approximation of $\cP$% %$\EDG(\cP)$
$\}$
is a sound %and complete 
DP processor.
\end{theorem}

\begin{example}
\label{ex:DP}
    Consider $\cRcnt$ in Example~\ref{ex:bv-lctrs} again.
    The following pairs are the DPs of $\cRcnt$:
    \[
      \DP(\cRcnt)=
      \left\{
      \begin{array}{@{\,}c@{~~}r@{\>}c@{\>}l@{\>}c@{\,}}
        (1) & \symb{cnt}^\#(x) & \to & \symb{u}^\#_1(x,\bv{0000},\bv{0000}) & \\
        (2) & \symb{u}^\#_1(x,i,z) & \to & \symb{u}^\#_1(x,i\,{+}\,\bv{0001},z\,{+}\,\bv{0001}) & [i\,{<_S}\,x]
      \end{array}	
      \right\}
    \]
    % % Figure environment removed
    %A DG approximation of $\DP(\cRcnt)$---$\EDG(\DP(\cRcnt))$ ($=\DG(\DP(\cRcnt))$)---%
    % $\DG(\DP(\cRcnt))$
    % is computed as follows:
    % \[
    %     \xymatrix{
    %         (1) \ar[r] & (2) \ar@(ur,dr)
    %     }
    % \]
    Since $\DG(\DP(\cRcnt))=(\DP(\cRcnt),\{ ((1),(2)), ((2),(2))\})$,
    %Thus, 
    we have that $\ProcSCC(\DP(\cRcnt)) = \{\>\{\,(2)\,\}\>\}$.
    In the following, we denote $\{\,(2)\,\}$ by $\cP_1$:
    \[
      \cP_1 =
      \{~
        (2) ~ \symb{u}^\#_1(x,i,z) \to \symb{u}^\#_1(x,i\,{+}\,\bv{0001},z\,{+}\,\bv{0001}) ~ [i\,{<_S}\,x]
      ~\}
    \]
\end{example}


\section{DP Processor for Singleton Self-Loop Removal}

The polynomial interpretation (PI, for short) processor over the integers (cf.~\cite[Theorem~10]{Kop13termination}) is one of the most powerful DP processors in proving termination of LCTRSs with integer arithmetic.
As indicated in Section~\ref{sec:intro}, however, the PI processor is ineffective against DP problems of BV-LCTRSs in the case where a usable calculation rule may cause overflow and/or underflow, because such a rule (e.g., $x + y \to z ~ [\, z = x + y\,]$) cannot be ordered by any meaningful PI order. %is not applicable to proving termination of BV-LCTRSs as it is.
In this section, we propose a DP processor, called an \emph{singleton self-loop removal processor}, that solves singleton self-loop DP problems under a certain condition.

A \emph{singleton self-loop DP problem} in this paper is assumed to be a singleton set of the form 
$\{\>\symb{f}^\#(x_1,\ldots,x_n) \to \symb{f}^\#(t_1,\ldots,t_n) ~ [\phi]\>\}$
%$\{\>\symb{f}^\#(\vec{x}) \to \symb{f}^\#(\vec{t}) ~ [\phi]\>\}$
that forms a chain of length two or more.
For example, $\cP_1$ in Example~\ref{ex:DP} is a singleton self-loop DP problem.
In the rest of this section, we let $\cP = \{\>f^\#(x_1,\ldots,x_n) \to f^\#(t_1,\ldots,t_n) ~ [\phi]\>\}$ be a singleton self-loop DP problem, where $f$ has sort $\iota_1\times\cdots\times\iota_{i-1}\times bv_l\times\iota_{i+1}\times\cdots\times\iota_n \Rightarrow \iota$, $l$ is a natural number, $x_1,\ldots,x_n$ are pairwise distinct variables, and $\phi$ is satisfiable.
    
In rewriting a term by the DP~(2) of $\cP_1$, the first and third arguments of $\symb{u}^\#_1$ do not affect the constraint $i <_S x$, i.e., they preserve the evaluation of the constraint, while the second argument of $\symb{u}^\#_1$ does not preserve the value of $i <_S x$---for a substitution $\theta$ such that $(i <_S x)\theta$ holds, $(i <_S x)\{i\mapsto i+\symb{1}\}\theta$ ($=(i+\symb{1} <_S x)\theta$) may not hold.
We formulate this notion as follows:
A rewrite rule $f^\#(x_1,\ldots,x_n) \to f^\#(t_1,\ldots,t_n) ~[\phi]$ is said to \emph{preserve its constraint w.r.t.\ $\bar{I}$} ($\subseteq \{1,\ldots,n\}$) if all of the following hold:
\begin{bracketenumerate}
    \item %\Enumi{(1)} 
    $\{x_i \mid 1 \leq i \leq n, ~ i \notin \bar{I} \} \subseteq \Var(\phi)$,
    \item %\Enumi{(2)} 
    for each $j\in \{1,\ldots,n\}$, if $x_j\in\Var(\phi)$, then $t_j\in\cT(\Sigmabvtheory,\cV)$,
        and
   \item %\Enumi{(3)} 
    $(\exists y_1,\ldots,y_m.\ \phi) \mathrel{\Leftrightarrow} (\exists y_1,\ldots,y_m.\ \phi)\theta$ is valid, where $\{y_1,\ldots,y_m\} = \Var(\phi) \setminus \{x_1,\ldots,x_n\}$ and $\theta=\{ x_j\mapsto t_j \mid 1 \leq j \leq n, ~ j \in \bar{I}  \}$.
\end{bracketenumerate}
For example, the DP (2) in $\cP_1$ preserves its constraint w.r.t.\ $\{1,3\}$.

%To prove that $\cP_1$ is chain-free, we use the fact that if the directed graph which is constructed by mapping rewriting steps of the dependency pair to bit-vector has no infinite chain, then the given DP problem is solved.
To prove chain-freeness of $\cP_1$, we use the fact that, given a DP problem $\cP$, if there exists an acyclic directed graph such that the nodes are bit-vectors and any $\cP$-chain is projected to a path of the graph, then $\cP$ is solved, i.e., $\cP$ is chain-free.
%Thus, we define a DP processor based on the fact.
%\begin{definition}
%    Assume that a singleton self-looping DP problem $\cP$ has no infinite $\cP$-chain.
%    Then, the singleton self-looping removal processor $\ProcLoop$ returns $\{\emptyset\}$:
%    $\ProcLoop(\cP)=\{\emptyset\}$
%\end{definition}
%\begin{theorem}
%    $\ProcLoop$ is sound and complete.
%\end{theorem}
%To apply $\ProcLoop$, we think about a criterion for non-existence of infinite $\cP$-chain.
%To this end, we show a sufficient condition for the existence such an acyclic graph.

Let us consider the DP~(2) in $\cP_1$.
Let $\pi_1$ be a projection of terms rooted by $\symb{u}^\#_1$ to the second argument of the root symbol, 
%such that $\pi_1(\symb{u}^\#_1)=2$, 
i.e., $\pi_1(\symb{u}^\#_1(t_1,t_2,t_3))=t_2$.
Then, we construct a directed graph such that the nodes are the 4-bits bit-vectors and the edges illustrated in Figure~\ref{fig:graph} are obtained from $\cP_1$ by applying $\pi_1$ to ground instances of the DP~(2) in $\cP_1$.
%The obtained graph is illustrated in Figure~\ref{fig:graph}.
% Figure environment removed
Since the graph is acyclic and any $\cP_1$-chain is projected to a path of the graph, the graph ensures the non-existence of infinite $\cP_1$-chains.
%Any $\cP_1$-chain is projected to a path of the graph;
%the existence of an infinite $\cP_1$-chain contradicts the acyclicity of the graph.
% The above observation is summarized as follows:
% If there exists the term $t$ such that have no out-edge in the rewriting steps of the dependency pairs in $\cP$ and there exists only a finite rewriting sequence to $t$ from any term, then there is no infinite $\cP$-chain.

In the following, we show a sufficient condition for the existence of such an acyclic graph.
\begin{restatable}{theorem}{maintheorem}
\label{teiri2}
    % Assume that $\cP$ is the following set:
    % \[
    %     \cP=\{\>
    %     f^\#(x_1,\ldots,x_n)
    %     \to
    %     f^\#(t_1,\ldots,t_n) ~
    %     [\phi]	
    %     \>\}.
    % \]
    % Let $l,i$ be a natural number,
    % $f$ be a function symbol that has sort $\iota_1\times\cdots\times\iota_{i-1}\times bv_l \times\iota_{i+1}\times\cdots\times\iota_n \Rightarrow \iota$,
    % $x_1,\ldots,x_n$ be variables that differ from each other,
    % and $a$ be a natural number between 0 and $l$.
    % Moreover, suppose that all of the following hold:
    % \begin{itemize}
    %     \item $x_i\in\Var(\phi)$,
    %     \item for each $j\in\{1,\ldots,n\}$, if $x_j\in\Var(\phi)$ then $t_j\in\cT(\Sigmabvtheory,\cV)$,
    %     \item $\phi \mathrel{\Leftrightarrow} \phi[x_1/t_1,\ldots,x_{i-1}/t_{i-1},x_{i+1}/t_{i+1},\ldots,x_n/t_n]$ is valid, and
    %     \item there exists $c\in\BV_{l-a-1}$ such that $[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}0^{\mathit{a}}
    %     %\overbrace{\symb{0}\ldots \symb{0}}^{\mbox{\scriptsize$a$}}
    %     }$.
    % \end{itemize}
    Let $i \in \{1,\ldots,n\}$.
    Suppose that 
    \begin{bracketenumerate}
    \setcounter{enumi}{3}
        \item 
%\Enumi{(4)}
$f^\#(x_1,\ldots,x_n) \to f^\#(t_1,\ldots,t_n) ~ [\phi]$ preserves its constraint w.r.t.\ $\{1,\ldots,i-1,i+1,\ldots,n\}$, 
        \item 
%\Enumi{(5)}
there exists $a \in \{0,\ldots,l\}$ such that 
    %$[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}0^{\mathit{a}}}$ 
    $t_i-x_i =_{bv_l} \bv{\mathit{c}\symb{1}0^{\mathit{a}}}$ is valid
    for some $c\in\{\symb{0},\symb{1}\}^{l-a-1}$,
            and
        \item 
%\Enumi{(6)}
there exists some terms $u,v:bv_l\in\cT(\Sigmabvtheory,\Var(\phi))$ such that % all of the following conditions hold:
    \begin{enumerate}
    \renewcommand{\labelenumi}{\alph{enumi}.}
%        \item $[\![v-u]\!]\in \BV_l$,
        \item $\phi \mathrel{\Rightarrow} (u =_{bv_l} u\theta \land v =_{bv_l} v\theta
        \land v-u\geq_U \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}})$ is valid,
        where $\theta=\{ x_j\mapsto t_j \mid 1 \leq j \leq n\}$,
        and
        \item %the following constraint is satisfiable:
%         $
% %            \begin{array}{@{}l@{}}
%             \forall \overrightarrow{\Var(\phi)\setminus \{x_i\}}.\ %\\
% %            \quad
%             %(%\left(
%             \left(
%             \begin{array}{@{}c@{}}
%                 \forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Uu \lor v\leq_Ux_i)) \land u<_Uv \\
%                 \lor \\
%                 \forall x_i.\ (\phi \mathrel{\Rightarrow} v\leq_Ux_i<_Uu) \\
%             \end{array}
%             \right)
% %             \land \,
% %                 v-u\geq_U 
% % %                \bv{\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{l}-\mathit{a}-1}1\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{a}}}
% %                 \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}}
%             %)%\right)
% %            \end{array}
%         $ is satisfiable.
%         $
% %            \forall \overrightarrow{\Var(\phi)\setminus \{x_i\}}.\ %\\
%             \left(
%             \begin{array}{@{}c@{}}
%                 \forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Uu \lor v\leq_Ux_i)) \land u<_Uv \\
%                 \lor \\
%                 \forall x_i.\ (\phi \mathrel{\Rightarrow} v\leq_Ux_i<_Uu) \\
%             \end{array}
%             \right)
%         either 
% %        $((\forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Uu \lor v\leq_Ux_i))) \land u<_Uv)$
%         $\phi \mathrel{\Rightarrow} ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)$
%         or
% %        $(\forall x_i.\ (\phi \mathrel{\Rightarrow} v\leq_Ux_i<_Uu))$
%         $\phi \mathrel{\Rightarrow} (v\leq_Ux_i \land x_i <_Uu)$
%         is valid.
        $(\forall x_i.\ (\phi \mathrel{\Rightarrow} ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)))
        \lor
        (\forall x_i.\ (\phi \mathrel{\Rightarrow} (v\leq_Ux_i \land x_i <_Uu)))$
        is valid.
    \end{enumerate}
    \end{bracketenumerate}
    Then, $\cP$ is chain-free. %i.e., there is no infinite $\cP$-chain
\end{restatable}

The assumptions in Theorem~\ref{teiri2} mean the following, respectively:
%\begin{bracketenumerate}
%\setcounter{enumi}{3}
%    \item 
\Enumi{(4)}
The evaluation of $\phi$ is only affected by the $i$-th argument of $f$ in applying the DP to terms;
%    \item 
\Enumi{(5)}
the $i$-th argument of $f$ plays a role of a \emph{loop variable}, and $t_i-x_i$ is a fixed amount ($\bv{\mathit{c}\symb{1}0^{\mathit{a}}}$) of the increment or decrement of the $i$-th argument at the application of the DP;
%    \item
\Enumi{(6)}
the terms $u,v$ imply a fixed interval $[u,v)$ that is not affected by the application of the DP and has the length more than $\bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}}$.
Note that if $v <_U u$ holds, then the interval is $\{ b \in \BV_l \mid b <_U v \lor u \leq_U b \}$.
%\end{bracketenumerate}
In applying the DP to a term (i.e., $\phi$ is satisfied), the value of $x_i$ is out of the interval.
In other words, if the value of $x_i$ is in the interval, then $\phi$ is not satisfied and thus, the DP is not applicable.
By repeating the application of the DP, the value of $x_i$ always enter the interval.
This means that a $\cP$-chain can no longer be extended and thus, there is no infinite $\cP$-chain.
\begin{example}
Let us consider the DP (2) in $\cP_1$ again.
Regarding the second argument, the DP (2) satisfies both~\Enumi{(4)} and~\Enumi{(5)}:
$(i+\bv{0001}) - i = \bv{0001}$.
Let $u=x+\bv{1000}$ and $v=x+\bv{1001}$.
Then, $u,v$ satisfy both~\Enumi{(6)\,a} and~\Enumi{(6)\,b}:
$i <_S x \Rightarrow ({x+\bv{1000} =_{bv_4} x+\bv{1000}} \land {x+\bv{1001} =_{bv_4} x+\bv{1001}} \land {(x+\bv{1001})-x =_{bv_4} \bv{0001}}$ 
and
$(\forall i.\ (i <_S x \mathrel{\Rightarrow} ((i<_U x+\bv{1000} \lor x+\bv{1001}\leq_U i) \land x+\bv{1000} <_U x+\bv{1001})))
\lor
(\forall i.\ (i <_S x \mathrel{\Rightarrow} (x+\bv{1001}\leq_U i \land i <_U x+\bv{1000})))$
are valid.
Therefore, by Theorem~\ref{teiri2}, $\cP_1$ is chain-free, i.e., $\cRcnt$ is terminating.
\end{example}

% Note that the constraint in Theorem~\ref{teiri2}~(3) can be replaced by the following:
% \[
% %    \begin{array}{@{}l@{}}
%     \forall \overrightarrow{\Var(\phi)\setminus \{x_i\}}.\ %\\
%     %\quad
%     (%\left(
%     \left(
%     \begin{array}{@{}c@{}}
%         \forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Su \lor v\leq_Sx_i)) \land u<_Sv \\
%         \lor \\
%         \forall x_i.\ (\phi \mathrel{\Rightarrow} v\leq_Sx_i<_Su) \\
%     \end{array}
%     \right)
%     \land \,
%         \bv{0}\circ(v-u)\geq_S 
%         %\bv{\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{l}-\mathit{a}}1\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{a}}}
%         \bv{0^{\mathit{l-a}}10^{\mathit{a}}}
%     )%\right)
% %    \end{array}
% \]

In the assumption~\Enumi{(6)\,b} of Theorem~\ref{teiri2}, theory terms with sort $bv_l$ are interpreted as unsigned integers, but this does not mean that Theorem~\ref{teiri2} only works for BV-LCTRSs obtained from C programs where all \texttt{int} variables are unsigned.
For example, the variable \texttt{x}, \texttt{i}, and \texttt{z} in Listing~\ref{list:cnt} are signed ones.


To prove chain-freeness of $\cP$ by Theorem~\ref{teiri2}, we need to find terms $u,v$ that satisfy~\Enumi{(6)\,a} and~\Enumi{(6)\,b}.
It is not easy to find such terms $u,v$ mechanically, because each of them may be either a variable such as $x$ or a bit-vector expression consisting of variables and constants such as $x+\bv{0111}$.
To overcome this difficulty, we propose another implementable criterion that can be applied in a specific case.

Let us focus on the case where $a=0$ (i.e., increment or decrement of the $i$-th argument is an odd number) in Theorem~\ref{teiri2}.
%As for the constraint of~\Enumi{(6)\,a}, we have that
%$\bv{\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{l}-0-1}1\overbrace{\symb{0}\ldots\symb{0}}^{0}}=\bv{\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{l}-1}1}$,
Since
$\bv{0^{\mathit{l-a-\mathrm{1}}}10^\mathit{a}} = \bv{0^{\mathit{l-\mathrm{1}}}1}$,
%and hence 
the formula $v-u\geq_U 
%\bv{\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{l}-\mathit{a}-1}1\overbrace{\symb{0}\ldots\symb{0}}^{\mathit{a}}}
\bv{0^{\mathit{l-a-\mathrm{1}}}10^\mathit{a}}
$
is equivalent to $u \ne_{bv_l} v$.
%However, neither $u<_Uv$ nor $v\leq_Ux_i<_Uu$ is satisfiable, whenever $u=v$.
If~\Enumi{(6)\,b} holds, then $\phi \mathrel{\Rightarrow} (u \ne_{bv_l} v)$ is valid.
In addition, neither $\forall x_i.\ ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)$ nor $\forall x_i.\ (v\leq_Ux_i \land x_i<_U u)$ is satisfiable.
Thus,~\Enumi{(6)\,b} is equivalent to
% \[
%     \forall \overrightarrow{\Var(\phi)\setminus \{x_i\}}.\ 
%     (%\left(
% %    \begin{array}{@{}c@{}}
%         (\forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Uu \lor v\leq_Ux_i)) \land u<_Uv)  %\\[-4pt]
%         \lor %\\[-4pt]
%         (\forall x_i.\ (\phi \mathrel{\Rightarrow} v\leq_Ux_i<_Uu)) %\\
% %    \end{array}
%     )%\right)
% \]
% \[
%  \forall \overrightarrow{\Var(\phi)\setminus \{x_i\}}.\ 
%  (
%  (\forall x_i.\ (\phi \mathrel{\Rightarrow} (x_i<_Uu \lor v\leq_Ux_i))
%  \lor
%  (\forall x_i.\ \neg\phi)
%  )
% \]
%Since satisifiability of the above constraint is equivalent to unsatisfiability of $\forall x_i.\ \phi$, 
unsatisfiability of $\forall x_i.\ \phi$ which does not contain either $u$ or $v$ and enables us to drop~\Enumi{(6)\,a}.
In summary, Theorem~\ref{teiri2} is simplified in the case where $a=0$.
\begin{theorem}
\label{teiri3}
    % Assume that $\cP$ is the following set:
    % \[
    %     \cP=\{\>
    %     f^\#\left(x_1,\ldots,x_n\right)
    %     \to
    %     f^\#\left(t_1,\ldots,t_n\right) ~
    %     [\phi]	
    %     \>\}.
    % \]
    % Let $l,i$ be a natural number,
    % $f$ be a function symbol that have sort $\iota_1\times\cdots\times\iota_{i-1}\times bv_l \times\iota_{i+1}\times\cdots\times\iota_n \Rightarrow \iota$,
    % and $x_1,\ldots,x_n$ be variables that differ from each other.
    % Moreover, suppose that all of the following hold:
    % \begin{itemize}
    %     \item $x_i:bv_l\in\Var(\phi)$,
    %     \item for each $j\in\{1,\ldots,n\}$, if $x_j\in\Var(\phi)$ then $t_j\in\cT(\Sigmabvtheory,\cV)$,
    %     \item $\phi \mathrel{\Leftrightarrow} \phi[x_1/t_1,\ldots,x_{i-1}/t_{i-1},x_{i+1}/t_{i+1},\ldots,x_n/t_n]$ is valid, and
    %     \item there exists $c\in\BV_{l-1}$ such that $[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}}$.
    % \end{itemize}
    Let $i \in \{1,\ldots,n\}$.
    Suppose that 
    \begin{bracketenumerate}
    \setcounter{enumi}{3}
    \leftskip=1ex
        \item 
%        \Enumi{(4)} 
        $f^\#(x_1,\ldots,x_n) \to f^\#(t_1,\ldots,t_n) ~ [\phi]$ preserves its constraint w.r.t.\ $\{1,\ldots,i-1,i+1,\ldots,n\}$, 
        \item[\Enumi{(5')}]  %$[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}}$ 
%        \Enumi{(5')} 
        $t_i - x_i =_{bl_l} \bv{\mathit{c}\symb{1}}$ is valid
        for some $c\in\{\symb{0},\symb{1}\}^{l-1}$,
            and
        \item[\Enumi{(6')}]
%        \Enumi{(6')} 
        $\forall x_i.\ \phi$ is unsatisfiable.
    \end{bracketenumerate}
    Then, $\cP$ is chain-free. %i.e., there is no infinite $\cP$-chain 
\end{theorem}

Theorem~\ref{teiri3} can be applied only in the case when $a=0$ in Theorem~\ref{teiri2}, but in most practical programs, loop variables are incremented by one.
Thus, Theorem~\ref{teiri3} must be sufficient to prove termination of BV-LCTRSs obtained from such programs.
Besides, %the advantage is that the implementation of Theorem~\ref{teiri3} does not cause the difficulty in Theorem~\ref{teiri2}.
the criterion in Theorem~\ref{teiri3} is more implementable than that in Theorem~\ref{teiri2}.

\begin{example}
%    Consider the DP problem $\cP_1$ again.
    Since $\forall i .\ i<_Sx$ is unsatisfiable, %there is no infinite $\cP_1$-chain 
    by Theorem~\ref{teiri3}, $\cP_1$ is chain-free.
\end{example}

Finally, we propose a DP processor based on Theorems~\ref{teiri2} and~\ref{teiri3}.
\begin{definition}
    Suppose that $\cP$ satisfies the assumptions in Theorems~\ref{teiri2} or~\ref{teiri3}.
    Then, given $\cP$, the \emph{singleton self-looping removal processor} $\ProcLoop$ returns $\{\emptyset\}$:
    $\ProcLoop(\cP)=\{\emptyset\}$.
\end{definition}
By Theorems~\ref{teiri2} and~\ref{teiri3}, it is clear that $\ProcLoop$ is a sound DP processor.
% \begin{theorem}
%     $\ProcLoop$ is sound.
% \end{theorem}

% \section{Conclusion}
% \label{sec:conclusion}
% In this article, we propose the singleton self-looping removal processor as a new DP processor.
% Consequently, we succeeded in proving termination of BV-LCTRS which the existing methods fail to prove.
% A future work is to develop a method for proving termination of BV-LCTRSs transformed from a program with multi loops.

\section{Future Work}
\label{sec:future-work}

% multiple loops

% Future work
The applicability of the SSR processor $\ProcLoop$ is very limited because it works for singleton (self-loop) problems only.
We may make a single loop formed by two or more DPs a self-loop formed by a DP by means of chaining.
On the other hand, we need a device for multiple loops.
An idea for such loops is to extract an innermost loop, decomposing a multiple loop into an innermost one and the others;
for the latter, we overapproximate the innermost loop by replacing the innermost loop-variable and accumulators by fresh variables.
Our future work is to formulate and implement this idea.

In~\cite{FKS12,HGFS18}, bit-vectors and their operators are represented over integer arithmetic, e.g., by case analysis for the finite interval of integers ($[-2^{31},2^{31}-1]$) or \emph{modulo} relations.
In~\cite{CDKSW18}, bit-precise termination is synthesised over lexicographic linear ranking function templates.
We have to compare our method with such approaches from the theoretical and empirical points of view.

% AProVE must have a bug: misproved termination of a non-terminating C program.

%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{biblio}

\end{document}

\newpage
%%%%% APPENDIX %%%%%
\appendix

\section{Proof of Theorem~\ref{teiri2}}

\maintheorem*
\begin{proof}
We proceed by contradiction.
Assume that
\begin{bracketenumerate}
    \setcounter{enumi}{3}
    \item $f^\#(x_1,\ldots,x_n) \to f^\#(t_1,\ldots,t_n) ~ [\phi]$ preserves its constraint w.r.t.\ $\{1,\ldots,i-1,i+1,\ldots,n\}$, i.e.,
    \begin{bracketenumerate}
    \item $x_i \in \Var(\phi)$,
    \item for each $j\in \{1,\ldots,n\}$, if $x_j\in\Var(\phi)$, then $t_j\in\cT(\Sigmabvtheory,\cV)$,
        and
    \item $((\exists y_1,\ldots,y_m.\ \phi) \mathrel{\Leftrightarrow} (\exists y_1,\ldots,y_m.\ \phi)\theta)$ is valid, where $\{y_1,\ldots,y_m\} = \Var(\phi) \setminus \{x_1,\ldots,x_n\}$ and $\theta = \{ x_j\mapsto t_j \mid 1 \leq j \leq n, ~ i \ne j \}$,
    \end{bracketenumerate}
    \item there exists $a \in \{0,\ldots,l\}$ such that 
    %$[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}0^{\mathit{a}}}$ 
    $(t_i-x_i =_{bv_l} \bv{\mathit{c}\symb{1}0^{\mathit{a}}})$ is valid
    for some $c\in\{\symb{0},\symb{1}\}^{l-a-1}$,
    \item there exists some terms $u,v:bv_l\in\cT(\Sigmabvtheory,\Var(\phi))$ such that % all of the following conditions hold:
    \begin{enumerate}
%        \item $[\![v-u]\!]\in \BV_l$,
        \item $(\phi \mathrel{\Rightarrow} u {=_{bv_l}} u\theta \land v {=_{bv_l}} v\theta
        \land v-u\geq_U \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}})$ is valid, 
        where $\theta = \{ x_j\mapsto t_j \mid 1 \leq j \leq n\}$,
            and
        \item 
        $(\forall x_i.\ (\phi \mathrel{\Rightarrow} ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)))
        \lor
        (\forall x_i.\ (\phi \mathrel{\Rightarrow} (v\leq_Ux_i \land x_i <_Uu)))$
        is valid,
    \end{enumerate}
        and
    \item $\cP$ is not chain-free.
\end{bracketenumerate}
W.l.o.g.\ there exists an infinite ground $\cP$-chain
$
f^\#(\vec{x})\theta_1 \mathrel{\to_\cP} f^\#(\vec{t})\theta_1
\mathrel{\to_\cR^*}
f^\#(\vec{x})\theta_2 \mathrel{\to_\cP} f^\#(\vec{t})\theta_2
\mathrel{\to_\cR^*}
f^\#(\vec{x})\theta_3 \mathrel{\to_\cP} f^\#(\vec{t})\theta_3
\mathrel{\to_\cR^*}
\cdots
$, where $\Dom(\theta_j) \supseteq \{x_1,\ldots,x_n\}\cup\Var(\vec{t},\phi)$, $\VRan(\theta_j)=\emptyset$, and $\theta_j$ respects $f^\#(\vec{x}) \to f^\#(\vec{t}) ~ [\phi]$ (i.e., $\Ran(\theta_j|_{\Var(\phi) \cup (\Var(\vec{t})\setminus\{x_1,\ldots,x_n\})}) \subseteq \Val$ and $[\![\phi\theta_j]\!] = \top$) for all $j \geq 1$.
By extracting the $i$-th argument of $f^\#$ from $f^\#(\vec{x})\theta_i$, we obtain the following infinite sequence of bit-vectors in $\BV_l$:
\[
[\![x_i\theta_1]\!], [\![x_i\theta_2]\!], [\![x_i\theta_3]\!],\ldots
\]
It follows from $[\![t_i-x_i]\!]=\bv{\mathit{c}\symb{1}0^{\mathit{a}}}$ that the above sequence is equivalent to the following:
\[
[\![ x_i\theta_1 ]\!],
[\![ x_i\theta_1 + \bv{\mathit{c}\symb{1}0^{\mathit{a}}} ]\!],
[\![ x_i\theta_1 + \bv{\mathit{c}\symb{1}0^{\mathit{a}}} + \bv{\mathit{c}\symb{1}0^{\mathit{a}}} ]\!],
\ldots
\]

It follows from~\Enumi{(6)\,a} that $[\![ (u-v)\theta_1 ]\!] \in \BV_l$.
Let $b \in \Val$ such that $[\![b]\!] = [\![ (u-v)\theta_1 ]\!]$.
In the following, we abuse $b$ as both a value and a bit-vector.
Since $\{x_1\mapsto t_1,\ldots,x_n\mapsto t_n\}$ is more general than $\theta_1,\theta_2,\ldots$, it follows from~\Enumi{(3)} and~\Enumi{(6)\,a} that $[\![ (u-v)\theta_j ]\!] = b$ for all $j \geq 1$.
It follows from~\Enumi{(6)\,a} that 
$b \geq_U \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}}$.
If follows from~\Enumi{(6)\,b} that 
\begin{itemize}
    \item $[\![ \left( \forall x_i.\ (\phi \mathrel{\Rightarrow} ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)) \right)\theta_j ]\!]=\top$ for all $j \geq 1$,
    or 
    \item $[\![ \left( \forall x_i.\ (\phi \mathrel{\Rightarrow} (v\leq_Ux_i \land x_i <_Uu)) \right)\theta_j ]\!]=\top$ for all $j \geq 1$.
\end{itemize}
We make a case analysis depending on which of the above holds.
\begin{itemize}
    \item Case where $[\![ \left( \forall x_i.\ (\phi \mathrel{\Rightarrow} ((x_i<_Uu \lor v\leq_Ux_i) \land u<_Uv)) \right)\theta_j ]\!]=\top$ for all $j \geq 1$.
    Since $b \geq_U \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}}$, there exists $j$ such that $[\![ u \leq_U x_i\theta_j <_U v ]\!] = \top$, and hence $[\![\phi\theta_j]\!]=\bot$.
    
    \item Case where $[\![ \left( \forall x_i.\ (\phi \mathrel{\Rightarrow} (v\leq_Ux_i \land x_i <_Uu)) \right)\theta_j ]\!]=\top$ for all $j \geq 1$.
    $(\phi \mathrel{\Rightarrow} v\leq_Ux_i<_Uu)$ is valid.
    Since $b \geq_U \bv{0^{\mathit{l-a-\mathrm{1}}}10^{\mathit{a}}}$, there exists $j$ such that $[\![ x_i\theta_j <_U v \lor u \leq_U x_i\theta_j ]\!] = \top$, and hence $[\![\phi\theta_j]\!]=\bot$.
\end{itemize}
In both cases above, we have that $[\![\phi\theta_j]\!]=\bot$.
This contradicts the assumption that $[\![\phi\theta_j]\!]=\top$.
\end{proof}
\end{document}
