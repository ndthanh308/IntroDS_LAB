This section briefly introduces the extensions of ASP by difference logic constraints and multi-shot solving functionalities, as well as our semiconductor manufacturing scheduling problem inspired by the SMT2020 simulation scenario.

\subsection{ASP with difference logic}\label{subsec:asp}

We presuppose familiarity with the first-order modeling language of ASP,
incorporating choice rules, aggregate atoms, as well as weak constraints for expressing objective function(s);
see \cite{cafageiakakrlemarisc19a,PotasscoUserGuide19,lifschitz19a}
for elaborate introductions.
The hybrid framework of ASP with \emph{difference logic constraints}~\cite{cotmal06a} allows for expressions % written as
\lstinline|&diff{t|$_1$\lstinline| - t|$_2$\lstinline|} <= t|$_3$ in the head of rules.
With the exception of the constant~\lstinline{0}, which denotes the number zero,
the terms \lstinline|t|$_1$ and \lstinline|t|$_2$ represent \emph{difference logic variables} that can be
assigned integer values.
If the body of a rule with
\lstinline|&diff{t|$_1$\lstinline| - t|$_2$\lstinline|} <= t|$_3$
in the head is satisfied, the difference \lstinline|t|$_1$\lstinline| - t|$_2$ must not exceed the
integer constant~\lstinline|t|$_3$.
That is, the difference logic constraints asserted by rules whose body is satisfied restrict the
feasible values for difference logic variables,
and the \clingodl\ system~\cite{janhunen2017clingo} extends \clingo\ 
\cite{PotasscoUserGuide19,gekakasc17a} by assuring the consistency of difference logic constraints
imposed by an answer set.
% If these DL constraints are satisfiable, a canonical assignment of smallest feasible
% integer values to DL variables can be determined in polynomial time and is output
% together with the answer set.

% Answer Set Programming (ASP) \cite{lifschitz19a} is a knowledge representation and reasoning paradigm geared for the effective 
% modeling and solving of combinatorial (optimization) problems. A (first-order) ASP program consists of \emph{rules} of the form \lstinline{h :- b}$_1$\lstinline{,}$\dots$\lstinline{,b}$_n$\lstinline{.},
% in which the head \lstinline{h} is an atom
% \lstinline{p(t}$_1$\lstinline{,}$\dots$\lstinline{,t}$_m$\lstinline{)} or a
% choice
% \lstinline{{p(t}$_1$\lstinline{,}$\dots$\lstinline{,t}$_m$\lstinline|)}|
% and each body literal \lstinline{b}$_i$ is an atom
% \lstinline{p(t}$_1$\lstinline{,}$\dots$\lstinline{,t}$_m$\lstinline{)},
% possibly preceded by the default negation connective \lstinline{not} and/or
% followed by a condition
% \lstinline|: c|$_1$\lstinline{,}$\dots$\lstinline{,c}$_l$, 
% a built-in comparison \lstinline{t}$_1\circ{}$\lstinline{t}$_2$
% with $\circ\in\{\text{\lstinline{<}},\text{\lstinline{<=}},\text{\lstinline{=}},\text{\lstinline{!=}},\text{\lstinline{>=}},\text{\lstinline{>}}\}$,
% or an aggregate
% \lstinline|t|$_0$\lstinline| = #count{t|$_1$\lstinline{,}$\dots$\lstinline{,t}$_m$%
% 	\lstinline| : c|$_1$\lstinline{,}$\dots$\lstinline{,c}$_l$\lstinline|}|.
% Each \lstinline|t|$_j$ denotes a term, i.e., a constant, variable, tuple,
% or arithmetic expression, and each element \lstinline|c|$_k$ of a condition is
% an atom that may be preceded by \lstinline{not} or a built-in comparison.
% Roughly speaking, an ASP program is a shorthand for its ground instantiation,
% obtainable by substituting variables with all of the available constants
% and evaluating arithmetic expressions,
% and the semantics is given by \emph{answer sets}, i.e.,
% sets of (true) ground atoms such that all rules of the ground instantiation
% are satisfied and allow for deriving each of the ground atoms 
% by % in the head of
% some rule whose body is satisfied.
% The syntax of the considered ASP programs is a fragment of the modeling languages
% described in \cite{cafageiakakrlemarisc20a,gehakalisc15a},
% the ground instantiation process is detailed in \cite{kamsch21a},
% and the answer set semantics is further elaborated in \cite{gehakalisc15a,lifschitz19a}.

% For example, the ASP program
% %
% \begin{lstlisting}[numbers=none,frame=none]
% {p(1..2)}.
% p(0) :- not p(X) : X = 1..2.
% p(X) :- X = #count{Y : p(Y), Y < 2}.
% \end{lstlisting}
% %
% with the variables \lstinline{X} and \lstinline{Y},
% the arithmetic expression \lstinline{1..2} standing
% for the integer interval $[1,2]$, and the
% built-in comparisons \lstinline{X = 1..2} and \lstinline{Y < 2}
% is a shorthand for the following ground instantiation:%

% \begin{lstlisting}[numbers=none,frame=none]
% {p(1)}.
% {p(2)}.
% p(0) :- not p(1) : 1 = 1; not p(2) : 2 = 2.
% p(0) :- 0 = #count{0 : p(0), 0 < 2; 1 : p(1), 1 < 2; 2 : p(2), 2 < 2}.
% p(1) :- 1 = #count{0 : p(0), 0 < 2; 1 : p(1), 1 < 2; 2 : p(2), 2 < 2}.
% p(2) :- 2 = #count{0 : p(0), 0 < 2; 1 : p(1), 1 < 2; 2 : p(2), 2 < 2}.
% \end{lstlisting}
% The two answer sets $\{\text{\lstinline{p(1)}}\}$ and
% $\{\text{\lstinline{p(1)}},\text{\lstinline{p(2)}}\}$
% satisfy all ground rules, where \lstinline{p(1)} and/or
% \lstinline{p(2)} are derivable in view of the choice rules
% \lstinline|{p(1)}.| and \lstinline|{p(2)}.|
% On the other hand, \lstinline{p(0)} does not belong to any
% answer set because the ground rules with \lstinline{#count}
% aggregates in their body then necessitate
% \lstinline{p(1)} and \lstinline{p(2)} to be true as well,
% while the atom \lstinline{p(0)} itself remains underivable. 

In addition, we make use of \emph{multi-shot ASP solving}~\cite{gekakasc17a},
allowing for iterative reasoning processes by controlling and interleaving
the grounding and search phases of \clingo\ and \clingodl. % a stateful ASP system.
For referring to a collection of rules to instantiate,
% the input language of \clingo supports 
\lstinline{#program name(c).}
directives, where \lstinline{name} denotes a \emph{subprogram}
and the parameter~\lstinline{c} is a placeholder for some constant, e.g., an integer value, group the rules below them and enable their selective instantiation w.r.t.\ specific parameter values.
Note that rules not preceded by any \lstinline{#program} directive
belong to an implicit, parameterless subprogram called \lstinline{base}.
Moreover, \lstinline{#external h : b}$_1$\lstinline{,}$\dots$\lstinline{,b}$_n$\lstinline{.}
statements are formed similar to rules, yet declare an atom~\lstinline{h} as
\emph{external} when the body \lstinline{b}$_1$\lstinline{,}$\dots$\lstinline{,b}$_n$ is satisfied.
Such an external atom can be freely set to true or false via the
Python interface of \clingo\ or \clingodl,
so that rules containing \lstinline{h} can be selectively (de)activated in order to control the search.

% ASP modulo DL integrates DL constraints \cite{cotmal06a}, i.e., expressions written as
% \lstinline|&diff{t|$_1$\lstinline| - t|$_2$\lstinline|} <= t|$_3$, in the head of rules.
% With the exception of the constant~\lstinline{0}, which denotes the number zero,
% the terms \lstinline|t|$_1$ and \lstinline|t|$_2$ represent DL variables that can be
% assigned any integer value.
% However, the difference \lstinline|t|$_1$\lstinline| - t|$_2$ must not exceed the
% integer constant~\lstinline|t|$_3$ if the body of a rule with the DL constraint in the
% head is satisfied.
% That is, the DL constraints asserted by rules whose body is satisfied restrict the
% feasible values for DL variables,
% and the \clingodl system extends \clingo by assuring the consistency of DL constraints
% imposed by an answer set.
% If these DL constraints are satisfiable, a canonical assignment of smallest feasible
% integer values to DL variables can be determined in polynomial time and is output
% together with the answer set.


\subsection{Semiconductor manufacturing scheduling}\label{subsec:problem}

We consider a \emph{Semiconductor Manufacturing Scheduling Problem}
(SMSP) inspired by the SMT2020 simulation scenario.
Given a set $P$ of available \emph{products} (the producible types of wafers), the production \emph{route} for each product $p\in P$ is a
finite sequence $p[1],\dots,p[n_p]$ of production \emph{operations}, where
$n_p$ denotes the length of the production route for~$p$.
Each operation $p[i]$ needs to be performed by some machine belonging to a \emph{tool group} $M(p[i])$ and requires a \emph{setup}
$s(p[i])\in\mathbb{N}$, with $s(p[i])=0$ indicating the special case that any (positive) setup can be in place when performing~$p[i]$.
Each setup $s\in\mathbb{N}$ has an associated parameter $\min(s)\in\mathbb{N}$ specifying a
minimum number of % wafer lots 
production operations that should be processed by a machine before changing from $s$ to another setup. % , and we let $\min(0)=0$.
Moreover, \emph{batching} capacities for operations $p[i]$ are expressed
by the parameters $\min(p[i])\in\mathbb{N}$ and $\max(p[i])\in\mathbb{N}$, denoting a minimum and a maximum batch size in terms of wafer lots.
While the maximum batch size is a hard limit on the number of lots that can be processed simultaneously, the minima on batch size and setup changes reflect desiderata for a regular process flow but are not strictly necessary process limitations.
Furthermore, each tool group $M$ has associated \emph{maintenance} operations $c(M)$ and $d(M)$, which must be performed periodically
based on the number of processed lots or accumulated processing time,
respectively.
That is, for each $c\in c(M)$ (or $d\in d(M)$), the parameters
$\min(c)\in\mathbb{N}$ and $\max(c)\in\mathbb{N}$
(or $\min(d)\in\mathbb{N}$ and $\max(d)\in\mathbb{N}$) denote 
the minimum and maximum number of lots (or processing time)
after which the maintenance operation has to be performed.
Finally, for any production operation $p[i]$, setup $s$, and maintenance 
operation $c$ or $d$,
$\mathrm{time}(p[i])\in\mathbb{N}$, $\mathrm{time}(s)\in\mathbb{N}$, $\mathrm{time}(c)\in\mathbb{N}$ or
$\mathrm{time}(d)\in\mathbb{N}$ provide the time required for performing
the respective operation or changing to the machine setup,
respectively.

The general properties above describe production routes and features of machines, and a set~$L$ of wafer lots represents the requested products,
where each lot $l\in L$ belongs to some product $p(l)\in P$.
A \emph{machine assignment} $m(l[1])\in M(p(l)[1]),\linebreak[1]\dots,\linebreak[1]m(l[n_{p(l)}])\in M(p(l)[n_{p(l)}])$
determines a specific machine to perform each operation $l[i]$ in the production route for a lot~$l$.
The \emph{schedule} for a machine $m$ in the tool group $M$ is a finite sequence
$m[1],\dots,m[n_m]$ of sets of operations,
where for each $1\leq j\leq n_m$:\pagebreak[1]
%
\begin{equation*}
m[j]=
\begin{cases}
\{l_1[i],\dots,l_k[i]\} &
\text{for lots } \{l_1,\dots,l_k\}\subseteq L
\text{ with } 
% \\ & 
p(l_1) = \ldots = p(l_k) = p,
{} \\ &
i \leq n_p, m(l_1[i]) = \ldots = m(l_k[i]) = m, k\leq \max(p[i])
\text{;}
\\
\{s\} & 
\text{for some setup } s>0
\text{;} 
\\
\{c\} &
\text{for some maintenance operation } c\in c(M)
\text{; or}
\\
\{d\} &
\text{for some maintenance operation } d\in d(M)
\text{.}
\end{cases}
\end{equation*}
%
Starting from the initial machine setup $s(m)[1]=0$, we define the successor setups
for $1<j\leq n_m$ by $s(m)[j]=\{s\}$ if
$m[j-1]=\{s\}$ indicates a change to the setup $s\in\mathbb{N}$, or
$s(m)[j]=s(m)[j-1]$ otherwise.
Moreover, let $l(m[j])=\{l_1[i],\dots,l_k[i]\}$ if
$m[j]=\{l_1[i],\linebreak[1]\dots,\linebreak[1]l_k[i]\}$ for lots $\{l_1,\dots,l_k\}\subseteq L$ whose $i$-th operation is processed in batch,
or $l(m[j])=\emptyset$ otherwise.
The schedule for $m$ is \emph{feasible} if each $l[i]$ with $m(l[i])=m$ belongs to exactly one set $m[j]$ of operations, and for each $1\leq j\leq n_m$:
%
\begin{itemize}
\item $s(m)[j]=s(p(l)[i])$ if $s(p(l)[i])>0$ for some lot $l\in L$ with $l[i]\in l(m[j])$,
\item $\sum_{\max(\{0\}\cup\{{j_c}<j \mid m[{j_c}]=\{c\})< j' \leq j}|l(m[j'])| \leq \max(c)$
for each $c\in c(M)$, 
\item $\min(c) \leq \sum_{\max(\{0\}\cup\{{j_c}<j \mid m[{j_c}]=\{c\})< j' < j}|l(m[j'])|$
if $m[j]=\{c\}$ for $c\in\nolinebreak c(M)$,
\item $\sum_{\max(\{0\}\cup\{{j_d}<j \mid m[{j_d}]=\{d\})< j' \leq j,l[i]\in l(m[j'])}(\mathrm{time}(p(l)[i])\div|l(m[j'])|) \leq \max(d)$
for each $d\in d(M)$, and
\item $\min(d) \leq \sum_{\max(\{0\}\cup\{{j_d}<j \mid m[{j_d}]=\{d\})< j' < j,l[i]\in l(m[j'])}(\mathrm{time}(p(l)[i])\div|l(m[j'])|)$
if $m[j]=\{d\}$ for $d\in\nolinebreak d(M)$.
\end{itemize}
%
That is, the required (positive) setup must be in place when performing a production operation, and the number of lots (or processing time)
between maintenance operations $c\in c(M)$ (or $d\in d(M)$) must lie
in the range $[\min(c),\max(c)]$
(or $[\min(d),\max(d)]$).

Given a feasible schedule for each machine~$m$,
for each $1\leq j\leq n_m$,
we denote the \emph{operation time} of $m[j]$ by
$o(m[j])=\mathrm{time}(p(l)[i])$ if there is some $l[i]\in l(m[j])$, or
$o(m[j])=\mathrm{time}(o)$ if $m[j]\setminus l(m[j])=\{o\}$. 
Then, starting from $o(m[0])=0$ and $t(m[0])=\nolinebreak 0$,
the earliest \emph{start time} of $m[j]$ is
%
\begin{equation*}
t(m[j])=\max\left(
	         \begin{array}{@{}l@{}}
	         \{t(m[j{-}1])+o(m[j{-}1])\}\cup {} \\
             \{t(m'[j'])+o(m'[j']) \mid l[i]\in l(m[j]),1< i,l[i{-}1]\in l(m'[j'])\}
			 \end{array}
			\right)
\text{.}
\end{equation*}
The start time $t(m[j])$ thus reflects the earliest time at which
% the preceding operation 
$m[j{-}1]$ is completed by machine~$m$ and
the predecessor operations $l[i{-}1]$ (if any) of all $l[i]\in l(m[j])$ 
have been finished as well.
Note that start times become infinite when the schedules for machines induce
circular waiting dependencies between the production operations for lots,
and we say that the (global) schedule of machine assignments for lots and
feasible schedules for machines is \emph{globally feasible} if all start times are finite.

The \emph{makespan} of a globally feasible schedule is the maximum
completion time $t(m[n_m])+o(m[n_m])$ over all machines~$m$.
An operation $m[j]=\{s\}$ constitutes a \emph{setup violation} for
$s\in\mathbb{N}$ if $m[j_s]=\{s\}$ for some $j_s<j$ such that
$|\{j_s<j'<\nolinebreak j \mid l(m[j'])\neq\emptyset\}|<\min(s)$.
Moreover, $m[j]$ amounts to a \emph{batch violation} if we have that
$|l(m[j])| < \min(p(l)[i])$ for some $l[i]\in l(m[j])$.
The makespan, setup and batch violations provide
optimization objectives to be minimized for globally feasible schedules.

\input{schedule_example.tex}
%
For example, an (optimal) schedule for an SMSP instance is displayed in Figure~\ref{fig:schedule}.
The machine in the \emph{diffusion\_fe\_120} tool group is capable of batching and processes the first operation in the route of two lots of the same product simultaneously.
Meanwhile, the setups \emph{su450\_3} and \emph{su128\_1}, required for sequential successor operations on machines in the tool groups \emph{lithotrack\_fe\_95} and \emph{implant\_128}, are brought in place before
processing the second and third production operations for each lot.
The machine in the \emph{lithotrack\_fe\_95} group undergoes a maintenance operation labeled \emph{wk} and then continues with the fourth operation in the production route for both lots.
The fifth and last operation per lot is processed by the machine in the tool group \emph{implant\_128}, where a switch to setup \emph{su128\_2} as well as a maintenance operation labeled \emph{mn} need to be performed in addition.
The makespan $89$ of this schedule is optimal, and likewise the setup and batch operations, the machine assignment of operations is fixed for simplicity, yet revisits of the \emph{lithotrack\_fe\_95} and \emph{implant\_128} machines illustrate re-entrant flow.

% The SMSP is a combinatorial optimization problem that models the production process as a series of operations that are processed on corresponding machines according to a specific flow. The SMSP eliminates some of the constraints of traditional job-shop scheduling, allowing for greater flexibility in machine selection for each operation.

% The recent simulation scenario, SMT2020, outlines two semiconductor fab settings: High-Volume/Low-Mix (HV/LM) and Low-Volume/High-Mix (LV/HM). The former features two product types, while the latter includes ten. However, both share a common characteristic in that each lot's production route consists of a substantial number of operations, ranging from 300 to 600, depending on the product type. Each operation necessitates a machine from a specific tool group, which may require operation-specific setups before it can be performed. Additionally, regular maintenance procedures must be performed after a certain number of operations or after accumulating a specified amount of processing time on a machine. Furthermore, it involves batch machines that concurrently process lots in batches.

% Before solving SMSP, it is necessary to classify it based on the number of machines that can be selected for each operation. Therefore we categorize SMSP as: flexible semiconductor manufacturing scheduling problem and partial flexible semiconductor manufacturing scheduling problem. The flexible SMSP assumes that all operations can be processed by any machine, while partial SMSP allows for the possibility that some operations cannot be processed on certain machines.  


% A problem representation of SMSP is described as follows: \\


% There are 
% ${j}$ independent jobs ${J = \{{J_1, . . . , J_n}\}}$ 
% and set of 
% ${m}$ machines partitioned into tool groups ${M = \{{M_1, . . . , M_m}\}}$, where 

% \begin{itemize}
% 	\item each job $j$ has release and due time represented as ${r_{j}}$ and ${d_{j}}$ respectively,
% 	\item each job $j \in J$ has a sequence of operations ${O_j = \{O_{1_j}, . . . , O_{l_j}\}}$,
% 	\item each tool group is categorized into $g$ sub-group, such as, each tool group contains sub-groups represented as ${G = \{G_{1_m}, . . . , G_{g_m}\}}$,
% 	\item each operation ${o_{i_j}}$ is assigned to a sub-group ${g_{i_m}}$ associated to tool group ${m}$, 
% 	\item each operation has a completion time denoted as ${c_{i_j}}$,
% 	\item each operation has a processing time ${p_{i_j}}$ and a setup time ${s_{i_j}}$,
% 	\item each tool group has $s$ setups ${S = \{{S_1, . . ., S_n}\}}$, 
% 	\item the setup ${s_{i_j}}$ is an operation-dependent, i.e, if ${s_{i_j} = 0}$, operation does not require any setup and if ${s_{i_j} \neq 0}$, requires some time ${u_{i_j}}$, and
% 	\item the machines in tool group ${M_{g}}$ require maintenance ${A = A_{1_g}, . . . , A_{h_g}}$ such that each ${a_{f_g}}$ has a duration ${w_{f_g}}$, a type ${x_{f_g}}$ with upper and lower bounds ${y_{f_g}}$,${z_{f_g}}$ respectively,
% 	\item the machines that process batch ${b_{i_j}}$ has the upper and lower limit ${d_{i_j}}$,${e_{i_j}}$, respectively to form a batch.
% \end{itemize}

% The schedule is characterized by some order $\langle q_{1_j},\dots,q_{k_m} \rangle$ of operations, processing duration ${p_{i_j}}$, sequence-dependent setup times ${u_{i_j}}$, maintenance procedures $\{q_{1_m},\dots,q_{k_m}\}
% \subseteq
% \{o_{i_j}\in\{o_{1_j},\dots,o_{l_j}\} \mid j\in J,m\in M_{i_j}\}
% \cup\linebreak[1]
% \{a_{1_g},\dots,a_{h_g} \mid m\in M_g\}$
% per machine $m\in M$, and batching capacity 
% ${b_{i_j}}$ such that the following conditions hold:

% \begin{itemize}
	
% 	\item the schedule is non-preemptive, i.e., interruption between operations is not allowed,
% 	\item job cannot be started before its release time i.e, ${r_{j}} >= 0$,
% 	\item one machine is selected from set of available machines to process each operation of a job, ${\sum_{i=1}^{m}o_{jk,m} = 1}$ for all ${j, k \in O_j}$,
% 	\item operations $\langle o_{1_j},\dots,o_{l_j} \rangle \in O_{j}$  are performed in a preset processing order,
% 	%\item any two operations of same job cannot be executed simultaneously,
% 	\item for each machine $m \in M$: for given maintenance $a_{f_g}$, and for any set of operations $O_{e_m,f_g}$ of non-maintenance operations performed up to $q_{e_m}$ without applying $a_{f_g}$ in-between, the following must be true:
% 	\begin{itemize}
% 		\item If $q_{e_m} = a_{f_g}$, then $y_{f_g} \leq |O_{e_m,f_g}|$ (or $y_{f_g} \leq \sum_{o_{i_j}\in O_{e_m,f_g}}p_{i_j}$)
% 		\item $|O_{e_m,f_g}| \leq z_{f_g}$ (or $\sum_{o_{i_j}\in O_{e_m,f_g}}p_{i_j}\leq z_{f_g}$) if $x_{f_g}=\mathit{lots}$ (or $x_{f_g}=\mathit{time}$).
% 	\end{itemize}
%     This condition ensures that for any longest subsequence $\langle q_{d_m},\dots,q_{{e-1}m} \rangle$ of $\langle q{1_m},\dots,q_{k_m} \rangle$ in which the maintenance $a_{f_g}$ is not performed, the number of processed operations or their accumulated processing time (determined by the type $x_{f_g}$ of $a_{f_g}$ and disregarding any applications of other maintenance procedures than $a_{f_g}$) must neither exceed the upper bound $z_{f_g}$ nor stay below the lower bound $y_{f_g}$. If $q_{e_m}=a_{f_g}$, it indicates that the maintenance $a_{f_g}$ is scheduled next in the sequence for machine $m$. 
	
% \end{itemize}

% Following assumptions are made for above mentioned model:

% \begin{itemize}
% 	\item all the jobs are available to schedule at time 0,
% 	\item all available machines can start at time 0, 
% 	\item machine failures/breakdown do not occur,
% 	\item transfer between operations are not considered.	
% \end{itemize}

% We aim to minimize following criteria:
% \begin{itemize}
% 	\item makespan of all jobs, 
% 	\item setup on machines,
% 	\item batch creation on respective machines.
% \end{itemize}

% Therefore, the completion time $c_{i_j}$, i.e., makespan of all jobs is defined as: %\pagebreak[1]

% \begin{equation*}
% 	c_{i_j}=p_{i_j}+
% 	\begin{array}[t]{@{}r@{}l@{}}
% 		\max
% 		\big(& 
% 		\{                         
% 		t_{i_j}+
% 		\mbox{$\sum$}_{0< d_m,q_{d_m}=o_{i'_{j'}}} c_{i'_{j'}}+
% 		\mbox{$\sum$}_{a_{f_g}\in\{q_{{d+1}_m},\dots,q_{{e-1}_m}\}} w_{f_g}
% 		\mid {}
% 		\\ & \quad
% 		d_m=\max(\{0\}\cup\{0< d_m< e_m \mid q_{d_m}\notin\{a_{1_g},\dots,a_{h_g}\}\})
% 		\}
% 		\\
% 		{}\cup {} &
% 		\{c_{{i-1}_j} \mid 1 < i\}\big)\text{.}
% 	\end{array}
% \end{equation*}  


