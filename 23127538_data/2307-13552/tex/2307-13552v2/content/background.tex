% ----------------------
\footnotetext[3]{https://www.fast-downward.org/Doc/Evaluator}
\footnotetext[4]{https://jendrikseipp.github.io/scorpion/Evaluator/}
\section{The RC Solving Ecosystem}

\iffalse
\begin{table}[t]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{S.No.} & \textbf{Planner} &  \textbf{Heuristic}  \\ \hline
P-1 & FD & Landmark Count \\ \hline
P-2 & Scorpion & Merge \& Shrink \\ \hline
P-3 & Scorpion & Max Manual PDB \\ \hline
P-4 & Scorpion & Max Systematic PDB \\ \hline \hline
P-5 & DeepCubeA & Custom \\ \hline

\end{tabular}
\caption{Planner configurations considered.}
\label{tab:rc-planners}
\end{table}
\fi

In this section, we describe the RC problem, planners, and heuristics that are used for our study. Table~\ref{tab:notations} summarizes the notations used and Figure \ref{FIG: ecosystem} shows the entire functionality of our designed ecosystem.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Figure environment removed
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% ----
\subsection{RC Problem}
The Rubik's Cube is a 3-D combination puzzle with colored faces made up of 26 smaller colored pieces linked to a central spindle, with the goal of rotating the blocks until each face of the cube is a single color. To solve the puzzle, one can perform certain actions that correspond to the different faces of the cube. The major actions of a Rubik's cube are Up(U), Down(D), Right(R), Left(L), Front(F), and Back(B), which define a rotation of 90 degrees in a clockwise direction of the respective face per action. The inverse of these actions corresponds to a 90-degree rotation in the anti-clockwise direction (suffix 'rev'). The cube is initially rotated by a random sequence of rotations in the puzzle's initial configuration. The goal is to find a series of rotations that results in the solved state, which has all faces displaying the same color. One can solve the RC from a scrambled state to the original solved configuration by performing a set of the above-mentioned actions. 
% ----
\subsection{Domain-Independent Planners and Heuristics}

\subsubsection{Classical Planning Formalism} 
Consider $F$ to be a set of propositional variables or \textit{fluents}. A \textit{state} $s \subseteq F$ is a subset of fluents that are true, while all fluents in $F \setminus s$ are implicitly assumed to be false. A subset of fluents $F^\prime \subseteq F$ holds in a state $s$ if and only if $F^\prime \subseteq s$. A classical planning instance is a tuple $P = \langle F, A, I, G \rangle$, where $F$ is a set of fluents, $A$ is a set of actions, $I \subseteq F$ an initial state, and $G \subseteq F$ a goal condition. Each action $a \in A$ has precondition pre($a$) $\subseteq F$, add effect add($a$) $\subseteq F$, and delete effect del($a$) $\subseteq F$, each a subset of fluents. Action $a$ is applicable in state $s \subseteq F$ if and only if pre($a$) holds in $s$, and applying $a$ in $s$ results in a new state $s \oplus a = (s \setminus$ del($a$)) $\cup$ add($a$). A \textit{plan} for $P$ is a sequence of actions $\prod = \langle a_{1},...,a_{n} \rangle$ such that $a_{1}$ is applicable in $I$ and, for each $2 \le i \le n, a_{i}$ is applicable in $I \oplus a_{1} \oplus ... \oplus a_{i-1}$. The plan $\prod$ solves $P$ if $G$ holds after applying $a_{1},...,a_{n}$, i.e. $G \subseteq I \oplus a_{1} \oplus ... \oplus a_{n}$.


\subsubsection{Abstractions}
Let $\mathcal{T} = \langle S, \mathcal{L}, T, s_{I}, S_{*} \rangle$ be a transition system. An \textit{abstraction} $\alpha : S \rightarrow S^{\alpha}$ maps the states of $\mathcal{T}$ to a set of \textit{abstract states} $S^{\alpha}$. The induced transition system is $\mathcal{T}^{\alpha} = \langle S_{\alpha}, \mathcal{L}, T^{\alpha}, \alpha(s_{I}), \{\alpha(s) | s \in S_{*}\} \rangle$ where $T^{\alpha} = \{\langle \alpha(s),o,\alpha(s^{\prime}) \rangle | \langle s, o, s^{\prime} \rangle \in T\}$. By construction, every path in $\mathcal{T}$ is a path in $\mathcal{T^{\alpha}}$. Consequently, the length of the shortest path between state $\alpha(s)$ and $\alpha(s^{\prime})$ in $\mathcal{T}^{\alpha}$ is a lower bound on the length of the shortest path between state $s$ and $s^{\prime}$ in $\mathcal{T}$. Thus, the abstract goal distance for a given state is an admissible estimate of the true goal distance \citep{buchner2022comparison}. In the later section of the paper, we mention the abstraction heuristics used for our work.
% ---
\subsubsection{PDDL}


The field of planning has seen many representations. For example, in classical planning, there was STRIPS~\cite{strips}, Action Description Language (ADL)~\cite{adl} and SAS+~\cite{comparison-pl-backstorm} before Planning Domain Description Language (PDDL)~\cite{pddl,pddl2.1} standardized the notations. Nowadays, planners routinely use PDDL for problem specification even if they may convert to other representations later for solving  efficiency \cite{pddl-conversion-finite}.  PDDL envisages two files, a domain description file which specifies information independent of a problem like predicates and actions, and a problem description file which specifies the initial and goal states. A problem is characterized by an initial state, together with a goal state that the agent wants to transition to, both states specified as configurations of objects. A planner takes as input the domain and problem file to generate a plan, which can be verified using a plan validator, VAL \cite{plan-verif-val}.



% \subsubsection{Rubik's Cube (RC)}
% The Rubik's Cube is a 3-D combination puzzle with colored faces made up of 26 smaller colored pieces linked to a central spindle, with the goal of rotating the blocks until each face of the cube is a single color. To solve the puzzle, one can perform certain actions that correspond to the different faces of the cube. The major actions of a Rubik's cube are Up(U), Down(D), Right(R), Left(L), Front(B), and Back(B), which define a rotation of 90 degrees in a clockwise direction of the respective face per action. The inverse of these actions corresponds to a 90-degree rotation in the anti-clockwise direction (suffix 'rev'). One can solve the RC from a scrambled state to the original configuration by performing a set of above mentioned actions. 

% While sticking to planning terminology of actions, problems and plans, we want to clarify terminology prevalent in RC literature that we will also refer to. A sequence of actions are called {\em macro-actions} and a collection of macro-actions are called {\em algorithms} in RC parlance. A solver may employ a strategy for sequencing macro-actions to solve the cube. We use the Fast-Downward AI Planner \cite{fd-planner} to solve the RC problem. Fast Downward is a domain-independent classical planning system based on heuristic search. 

% -------------

% \kl{Are you adding more subsections here?}
% --------------

% ----
% \vspace{-0.25cm}
\subsection{Learning-based RC Solver}

There exist specialized solvers for solving the Rubik's Cube, which can be classified as either domain-dependent or domain-independent. DeepCubeA is an example of a domain-independent solver that employs custom representation encoding for RC, as proposed in \cite{mcaleer2018solving,deepcube}. The solver employs a weighted A* search algorithm and learns a domain-dependent heuristic via deep-learning, resulting in state-of-the-art performance. However, interpreting the solutions provided by DeepCubeA remains a challenge \cite{deepcube-iclr}, as does comparing its performance with that of other solvers {\em on identical problem instances}.

% \begin{table*}[!htbp]
% \centering
% \begin{tabular}{c|clcl|clcl|c}
% \multirow{2}{*}{\textbf{Planner}} & \multicolumn{4}{c|}{\textbf{d1}} & \multicolumn{4}{c|}{\textbf{d2}} & \multirow{2}{*}{\textbf{SAS+}} \\ \cline{2-9}
%  & \multicolumn{2}{c|}{\textbf{m1}} & \multicolumn{2}{c|}{\textbf{m2}} & \multicolumn{2}{c|}{\textbf{m1}} & \multicolumn{2}{c|}{\textbf{m2}} &  \\ \hline
% P-2 & \multicolumn{1}{c|}{113} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{105} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & \multicolumn{1}{c|}{82} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{95} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & 90 \\ \hline
% P-1 & \multicolumn{1}{c|}{103} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{88} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & \multicolumn{1}{c|}{75} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{84} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & \textless{}NA\textgreater{} \\ \hline
% P-3 & \multicolumn{1}{c|}{94} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{83} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & \multicolumn{1}{c|}{64} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{78} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & 123 \\ \hline
% P-4 & \multicolumn{1}{c|}{84} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{76} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & \multicolumn{1}{c|}{63} & \multicolumn{1}{l|}{\begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular}} & \multicolumn{1}{c|}{73} & \begin{tabular}[c]{@{}l@{}}Avg. Len: \\ Avg. Time:\end{tabular} & 119 \\ \hline
% \multicolumn{1}{l|}{DeepCubeA} & \multicolumn{4}{l|}{} & \multicolumn{4}{l|}{} & \multicolumn{1}{l}{}
% \end{tabular}
% \caption{Number of problem tasks solved with different Rubik's Cube models compared across different planner configurations (\textsuperscript{*}\citet{buchner2022comparison})}
% \label{tab:exp-results}
% \end{table*}


