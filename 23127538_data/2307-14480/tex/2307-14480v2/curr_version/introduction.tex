\section{Introduction}~\label{sec:intro}
Hardware designs are becoming increasingly complex to meet the rising need for custom hardware and increased performance. However, as the design complexity grows, verification dominates the development lifecycle---over 70\% of resources are spent
to verify the security of a hardware design~\cite{fine2003coverage}. Therefore, a verification technique that can expose design flaws/vulnerabilities as early as possible is critical~\cite{rajendran2015detecting,dessouky2019hardfails,sadeghi2021organizing,chen2022trusting}.

Recent research has shown that coverage feedback-based fuzzers can effectively detect security vulnerabilities in modern processors and achieve coverage faster than traditional hardware verification techniques such as random regression\cite{rfuzz,muduli2020hyperfuzzing,canakci2021directfuzz,hur2021difuzzrtl,fuzzhwlikesw,kande2022thehuzz,ragab_bugsbunny_2022,chen2023hypfuzz}.
Fuzzers start with seed inputs and apply predefined mutation operators on current inputs to generate new inputs.
Fuzzers utilize one or several coverage metrics to track the activity caused by the inputs in the hardware and guide themselves to generate inputs that explore new hardware regions, thereby accelerating vulnerability detection. These fuzzers successfully found vulnerabilities that execute undefined behaviors, compromise memory isolation, lead to privilege escalations, etc., in hardware designs.
Due to their promising potential, semiconductor giants such as Intel and Google are actively developing new and efficient hardware fuzzers for vulnerability detection~\cite{presifuzz,fuzzhwlikesw}.

Though hardware fuzzing is promising, its coverage increment usually stagnates quickly, leaving design spaces unexplored and vulnerabilities undetected. One of the main reasons is that all the existing hardware fuzzers schedule the mutation operators and generate seeds using static schemes, and lack feedback-guided dynamic updates via interaction with the coverage achieved and the complexity of the hardware (more details in Sec.~\ref{sec:rel})~\cite{rfuzz, hur2021difuzzrtl,kande2022thehuzz,fuzzhwlikesw,ragab_bugsbunny_2022,canakci2021directfuzz,muduli2020hyperfuzzing,chen2023hypfuzz}. For example, \cite{hur2021difuzzrtl} generates input instructions with the same operands to verify the renaming strategies in out-of-order processors. However, this strategy is not optimal for processors without renaming strategies. While \cite{kande2022thehuzz} uses profiling to analyze the correlation between the mutation operators and the processor instructions, the scheduling is static throughout fuzzing and does not update with coverage achieved. 
Therefore, to dynamically adjust the schedule of mutation operators and seed generation, we develop an approach to equip any hardware fuzzer with particle swarm optimization~(PSO) targeting faster vulnerability detection and coverage achievement.

PSO is a bio-inspired algorithm that uses a swarm consisting of multiple particles to find the optimal solution in a high-dimensional space~\cite{pso}. 
Since fuzzers usually run multiple threads in parallel to accelerate the design space exploration, we model the scheduler of each thread's mutation operations as a particle. The probability distribution of each mutation operator being selected composes the position of a particle. 
Each particle updates its position based on the highest coverage achieved by itself and the highest coverage achieved by the swarm in the current iteration.

Researchers have used PSO in software fuzzing to find the optimal probability distribution of mutation operators~\cite{lyu2019mopt}. Results show a significant improvement over the fuzzers without PSO. However, one cannot simply use their technique for hardware fuzzing for the following reasons: (i) They assume a static optimal probability distribution of the mutation operators, which is not true for hardware fuzzing. Our experiments show that if a static distribution is used, two critical vulnerabilities are not detected even after using PSO (more details in Sec.~\ref{sec:solution1} and~\ref{sec:exp}). (ii) They use randomly generated programs as seeds, which is not ideal for hardware fuzzing (more details in Sec.~\ref{sec:solution2}).
To successfully apply PSO to hardware fuzzing, we must address two critical challenges: 
\begin{itemize}[leftmargin=*]
    \item \textbf{Challenge 1: Saturation of Particles' Performance.} Naively applying PSO to hardware fuzzing results in the particles converging to a fixed position leading to a lack of coverage improvement and vulnerabilities undetected.
    \item \textbf{Challenge 2: Ineffective Seed Generation.} The seeds from which the fuzzing loop starts strongly affect the coverage achieved. Traditional fuzzers use either statically or randomly generated seeds, which results in slower coverage increments. Moreover, the performance of applying PSO to hardware fuzzing is also subject to the seed: poor quality seeds result in poor coverage.
\end{itemize}
We address these challenges by designing specific solutions (in Sec.~\ref{sec:solution1} and \ref{sec:solution2}) that result in faster vulnerability detection and coverage achievement. In particular, we augment PSO with a reset strategy to schedule mutation operators dynamically. Moreover, we employ PSO to select high-quality seed inputs resulting in faster coverage.
Overall, the main contributions of this work are as follows:
\begin{enumerate}[leftmargin=*]
    \item To the best of our knowledge, we develop the first technique that uses the PSO algorithm to schedule the mutation operators and generate seed inputs in hardware fuzzing.
    \item We overcome challenges in adapting PSO to hardware fuzzers. In particular, we develop optimizations to reset the particles for selecting mutation operators and a novel PSO-based seed generation algorithm for hardware fuzzers.
    \item We evaluate \ourtool{} on three widely-used open-source RISC-V processors and achieve up to \maxVulDetSpd $\times$ speedup in detecting vulnerabilities and up to $2.22\times$ speedup in achieving coverage compared to the state-of-the-art simulation-based fuzzer without PSO.
\end{enumerate}