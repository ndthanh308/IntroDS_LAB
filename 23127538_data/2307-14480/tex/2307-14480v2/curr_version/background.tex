\section{Background}

\subsection{Hardware Processor Fuzzers}~\label{sec:fuzz_bg}
Hardware processor fuzzers iteratively generate testing inputs (i.e., \textbf{inputs} or \textbf{tests}) such as binary executables to detect vulnerabilities in target hardware (i.e., design-under-test~(DUT)). These fuzzers mainly consist of a \textit{seed generator}, \textit{mutation engine}, \textit{feedback engine}, and \textit{vulnerability detector}~\cite{hur2021difuzzrtl, kande2022thehuzz, chen2023hypfuzz, ragab_bugsbunny_2022}.
The \textit{seed generator} generates an initial set of tests called \textbf{seeds}. Fuzzer simulates the hardware with these seeds to generate feedback and output.
The \textit{feedback engine} captures the activity in hardware, such as toggling of the value of flip-flops~\cite{kande2022thehuzz}, as \textbf{coverage} data during simulation.
The \textit{mutation engine} modifies the tests that achieve new coverage (i.e., \textbf{interesting} tests) to create new tests. For example, the \textit{Bitflip} mutation operator flips one random bit in the test~\cite{citeafl}. The \textit{vulnerability detector} detects vulnerabilities in hardware by comparing its output with the output of a \textbf{golden-reference model}~(GRM)~\cite{kande2022thehuzz,hur2021difuzzrtl,chen2023hypfuzz}. 

Existing hardware fuzzers use static mutation operator scheduling and seed generation schemes which cannot dynamically adjust based on the complexity of hardware and the coverage achieved, slowing down vulnerability detection and design space exploration (more details in Sec.~\ref{sec:method} and \ref{sec:rel}).

\subsection{PSO Algorithm}
PSO is a bio-inspired algorithm that allocates multiple particles to iteratively search for an optimal solution~\cite{pso}. The position of a particle is a candidate solution and is updated based on its velocity. The velocity is determined by the best position the particle ever achieved and the best position the entire swarm ever achieved. A particle's velocity, $v_i$, and position, $p_i$, are updated as
\begin{align}\label{eq:up_v}
\begin{split}
    v_i(t+1) &= k\times v_i(t) + r_1\times(l_i^{best}(t)-p_i(t))\\
             &+ r_2 \times (g^{best}(t) - p_i(t))
\end{split}
\end{align}
\begin{equation}\label{eq:up_p}
    p_i(t+1) = p_i(t) + v_i(t+1) \tag{2}
\end{equation}

Here, $l_i^{best}(t)$ represents the best position the particle $i$ ever achieved since the beginning (i.e., $t = 0$), and $g^{best}(t)$ represents the best position ever achieved by any particle in the swarm. $k$ is a pre-defined constant, and $r_1$ and $r_2$ are two random displacement weights that decide how fast the particle $i$ will move toward $l_i^{best}(t)$ and $g^{best}(t)$, respectively. 

PSO has been widely applied to optimize the performance of applications due to its searching efficiency and convergence speed~\cite{zhan2009adaptive}. 
Though the solutions found by PSO are heuristic results, they are usually close to the real global optimum~\cite{shi1998modified}.
The software community has also leveraged PSO~(e.g., \mopt{}~\cite{lyu2019mopt}) to detect vulnerabilities (e.g., memory crashes) in programs. 
However, for hardware fuzzing, the optimal probability distribution of the mutation operators changes with coverage achieved so far, and the quality of seeds greatly affects the performance of the fuzzer. Hence,~\mopt{} cannot be applied for hardware fuzzing directly.