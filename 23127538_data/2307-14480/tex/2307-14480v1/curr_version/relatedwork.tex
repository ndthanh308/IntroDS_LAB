\section{Related Work}\label{sec:rel}
This section describes the existing hardware fuzzers, their limitations, and how \ourtool{} addresses those limitations. 

\textbf{\textit{RFUZZ}}~\cite{rfuzz} uses mux-toggle coverage to capture the activity in the select signals of MUXes. It schedules mutation operators statically, similar to AFL fuzzer~\cite{citeafl}. Also, mux-toggle coverage is not scalable to large designs such as \boom{}~\cite{hur2021difuzzrtl}. \textbf{\textit{HyperFuzzing}}~\cite{muduli2020hyperfuzzing} is an SoC fuzzer that defines security properties and uses AFL fuzzer's static mutation operator scheduling and random seed generation to detect vulnerabilities. \textbf{\textit{DirectFuzz}}~\cite{canakci2021directfuzz} modifies \textit{RFUZZ} to perform directed fuzzing on specific modules of the target hardware. However, it uses similar static schemes as \textit{RFUZZ}. 

Processor fuzzer \textbf{\textit{DIFUZZRTL}}~\cite{hur2021difuzzrtl} uses activity in the control registers as coverage to address the scalability issues of \textit{RFUZZ}. 
It uses grammar-based mutation operators inspired by AFL. But, it generates seeds randomly and uses static mutation operator scheduling schemes. 
\textbf{\textit{BugsBunny}}~\cite{ragab_bugsbunny_2022} fuzzes specific target signals in the hardware using \textit{DIFUZZRTL} as the base fuzzer. Hence, its mutation operator scheduling and seed generation schemes are static. 
\textbf{\textit{Trippel et al.}}~\cite{fuzzhwlikesw} convert hardware to a software model and fuzz using AFL fuzzer with static mutation scheduling. 
\textbf{\textit{TheHuzz}}~\cite{kande2022thehuzz} is another processor fuzzer that uses different types of code coverage metrics to capture activity in the combinational and sequential logic of the hardware. 
It also uses a profiler to optimize the mutation scheduling. However, this optimization is static for a given processor and does not change with the coverage achieved. 

A recent hardware fuzzer \textbf{\textit{HyPFuzz}}~\cite{chen2023hypfuzz} attempts to address the slower coverage speeds of hardware fuzzers by combing formal tools with fuzzing. This optimization to fuzzing is orthogonal to \ourtool{} as \textit{HyPFuzz} also uses static mutation operator scheduling and seed generation schemes which can be optimized through our PSO techniques. 

In summary, all of the existing hardware fuzzers 
use static mutation operator scheduling and seed generation schemes and cannot dynamically adjust their strategies for the target hardware and coverage achieved. In contrast, we propose \ourtool, a PSO-guided fuzzer, to demonstrate how hardware fuzzers can be equipped with PSO optimizations to improve their vulnerability detection and coverage achievement speeds.

\vspace{0.2cm}