\section{Evaluation}\label{sec:exp}


\input{tables/table1}

In this section, we evaluate the speed of~\ourtool{} in detecting vulnerabilities and achieving coverage on three popular open-sourced RISC-V~\cite{riscv_home} processors.  


\subsection{Evaluation Setup}
We use the state-of-the-art simulation-based processor fuzzer, \thehuzz{}~\cite{kande2022thehuzz} as a baseline for all evaluations.\footnote{Following~\cite{kande2022thehuzz}, we implemented~\thehuzz~in Python.} 
To ensure that the enhancements in results exclusively stem from PSO adaptation, we integrate PSO schemes into \thehuzz{}'s \textit{mutation engine} and \textit{seed generator}.
In addition to reporting the results for our final formulation,~\ourtool, which is also denoted as \textbf{PSO+Reset+Seed}, we also report the results for (i) the preliminary formulation, \textbf{PSO}, which includes the PSO-based mutation operator selection, but neither the resetting solution (Solution 1), nor the PSO-based seed generation technique (Solution 2), and (ii) the intermediate formulation, \textbf{PSO+Reset}, which includes the PSO-based mutation operator selection with reset, but not PSO-based seed generation.

Following~\cite{kande2022thehuzz}, we set the number of simultaneous threads and hence the number of particles, $|N|$, as $10$ and the number of instructions in each program, $|O|$, as $20$. To have a balanced impact of exploration (due to velocity) and exploitation (due to local and global bests), we set $k$ (Eq.~(\ref{eq:up_v})) as $0.5$. Based on empirical observations, we set $\beta^M = \beta^T = 3$.

Since most commercial processors are close-sourced, we evaluate \ourtool{} using three widely-used open-sourced processors from RISC-V~\cite{riscv_home} ISA: \cva{}~\cite{cva6}, \boom{}~\cite{boom}, and \rc{}~\cite{rocket_chip_generator}. Existing hardware processor fuzzers use similar open-sourced processors for their evaluation~\cite{hur2021difuzzrtl,kande2022thehuzz,chen2023hypfuzz}. \cva{} supports out-of-order execution~(OoO) and a custom single instruction-multiple data~(SIMD) floating point unit. 
\rc{} is an in-order processor. 
\boom{} is a superscalar processor built using the components of \rc{}. 
Moreover, all of these processors are capable of booting Linux operating system while \cva{} is commercially used to build processors for high-security applications~\cite{migv}.
Therefore, these processors with different complexity form a diverse benchmark set to evaluate \ourtool{}. 

We use Synopsys \vcs{}~\cite{vcs} as the simulation tool and \chipyard{}~\cite{chipyard} as the system-on-chip~(SoC) simulation environment. To ensure a fair comparison, we ran experiments on each benchmark for 24 hours and repeated them thrice. 
We demonstrate our results using the branch coverage metric, which is highly related to vulnerability detection~\cite{mockus2009test}. We use a Linux-based CPU running at 2.6GHz, with 64 threads and 512GB of RAM for our experiments.

\subsection{Vulnerability Detection}
The vulnerability detection strategy used by our techniques (PSO, PSO+Reset, PSO+Reset+Seed) compares the processor's outputs with that of a GRM.
Many existing fuzzers use a similar detection strategy~\cite{kande2022thehuzz,hur2021difuzzrtl,chen2023hypfuzz,ragab_bugsbunny_2022}. 
The strategy compares the architectural states of the processor and the GRM for each executed instruction.
The architectural states include the instructions committed; any exceptions triggered; the general purpose registers~(GPRs) modified; the CSRs modified; the privilege level of the processor; and the memory address and data accesses. A mismatch in architectural states indicates a potential vulnerability in the processor. Similar to \cite{kande2022thehuzz,hur2021difuzzrtl,chen2023hypfuzz,ragab_bugsbunny_2022}, we use \spike{}~\cite{spike}, the RISC-V ISA emulator, as the GRM.

\textbf{Comparison with \thehuzz{}.}
Table~\ref{tb:b_list_v1} shows the number of tests and the speedup of our techniques compared to \thehuzz. 
\ourtool{} detects all the vulnerabilities detected by \thehuzz{} up to \maxVulDetSpd $\times$ faster.
The results also show the necessity of using the reset strategy for PSO. Na\"ive PSO is slower than \thehuzz{} in detecting vulnerabilities because its particles are likely exploring the design spaces that have already been explored, as mentioned in Sec.~\ref{sec:solution1}. 
PSO+Reset performs better than PSO due to resetting the particles, allowing it to dynamically select the optimal mutation operators. It also outperforms PSO+Reset+Seed (\ourtool{}) in detecting some vulnerabilities, such as V3, because \ourtool{} initially spends time exploring the optimal probabilities for seed generation. 
However, \ourtool{} achieves the highest speedup compared to \thehuzz{} and other PSO techniques for most vulnerabilities because it uses the optimal probabilities for both seed generation and instruction mutation, efficiently exploring different regions of the design space. 

\input{tables/table2}

% Figure environment removed

\subsection{Coverage Achievement}
We now compare the capability of our techniques
in achieving coverage against \thehuzz{}, as coverage achieved is a proxy metric to the extent of design verified and determines its readiness to tape out~\cite{verifiwhitepaper}. Across the three processors, PSO optimizations achieve up to \maxSpdupSeed{}$\times$ speedup compared to \thehuzz{} while obtaining up to \maxCovInc\% more coverage after fuzzing for 24 hours with more than 20K tests, as shown in Table~\ref{tab:cov}. Fig.~\ref{fig:tot_branch} shows the mean and standard deviation of coverage achieved with respect to the number of input tests.

\ourtool{} outperforms PSO+Reset on \rc{} and \boom{} because the PSO-based seed generation dynamically adjusts the optimal set of instructions required to cover new points. 
While \ourtool{} is slower than PSO+Reset on \cva{}, it still outperforms \thehuzz{} and PSO techniques. 

Among the three processors, \ourtool{} achieves the fastest speedup (\cvaSpdupSeed{}$\times$) and highest coverage increment (\cvaCovIncSeed{}\%) on \cva{}, which is the complex processor with OoO and SMID features. 
This is because the PSO optimizations aid in covering the hard-to-reach coverage points in the custom floating point unit of \cva{}, which are difficult to cover with static mutation operator scheduling schemes.
Even on the remaining processors, \boom{} and \rc{}, \ourtool{} achieves faster coverage (up to $\rcSpdupSeed{}\times$) compared to \thehuzz{} and covers more points than \thehuzz{}. The speedup on these processors is less than that of \cva{} because \rc{} is a simple processor compared to \cva{} while \boom{} is built by duplicating most of the components of \rc{}. Hence, \thehuzz{} covers more than $87\%$ of their points, resulting in less scope for improvement for \ourtool{}.

In summary, \ourtool{} detects vulnerabilities and achieves coverage faster than \thehuzz{} on all three processors, demonstrating the necessity of dynamic scheduling of mutation operators and seed generation. 