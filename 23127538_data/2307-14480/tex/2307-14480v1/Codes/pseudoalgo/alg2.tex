\begin{algorithm}[t]
\SetFuncSty{textsc}
\SetKwFunction{GenSeed}{GenSeed}
\SetKwProg{Fn}{Function}{:}{}
\DontPrintSemicolon
\caption{\ourtool{}}\label{alg:overall}
\KwIn{
    $DUT,t_{limit},tc,\beta^M,\beta^T,k$
}
\KwOut{$cov$: total coverage achieved}
\tcp{initialization}
$t \gets 0$, $cov \gets 0$, $tests \gets \phi$\; 
% \tcp{initialize particles}
Initialize $P^M, V^M, P^T, V^T$\;
Initialize $L^{best,M}$ to $P^M$ and $g^{best,M}$ to $p_0^M$\;
% Initialize $P^S, V^S$ randomly and normalize $p^S \in P^S$\;
Initialize $L^{best,T}$ to $P^T$ and $g^{best,T}$ to $p_0^T$\;

% Initialize $P^M, V^M$ randomly and normalize $p^M \in P^M$\;
% Initialize $L_{best}^M$ to $P^M$ and $g_{best}^M$ to $p_0^M$\;
% Initialize $P^S, V^S$ randomly and normalize $p^S \in P^S$\;
% Initialize $L_{best}^S$ to $P^S$ and $g_{best}^S$ to $p_0^S$\;

% \tcp*[l]{for particles needs reset}
$Ct^M \gets 0$, $Ct^T \gets 0$\;
$rst\_P^M \gets \phi$, $rst\_P^T \gets \phi$\;
$tests \gets GenSeed(P^T, tests, rst\_P^M)$\;
% \tcp{Enter the fuzzing loop}
\While(\tcp*[f]{main loop}){$(cov < tc)$ and $(t < t_{limit})$} {
    % $COV \gets Simulate(tests)$\;
    $\mathcal{F}^M,  cov \gets Simulate(DUT, tests)$\;
    $L^{best,}, g^{best,M}, rst\_P^M, Ct^M \gets RstMon(P^M, L^{best,M}, \beta^M, Ct^M, \mathcal{F}^M)$\;
    \If(\tcp*[f]{update PSO seed}){$rst\_P^M \neq \phi$}{
        $\mathcal{F}^T \gets CalcFitness(rst\_P^M, P^T)$\;
    
        $L^{best,T}, g^{best,T}, rst\_P^T, Ct^T \gets RstMon(P^T, L^{best,T}, \beta^T, Ct^T, \mathcal{F}^T)$\;        
        
        $P^T, V^T \gets UpdatePV(P^T, V^T, L^{best,T}, g^{best,T}, rst\_P^T, k)$
    }
    $P^M, V^M\gets UpdatePV(P^M, V^M, L^{best,M}, g^{best,M}, rst\_P^M, k)$
    \tcp*[f]{gen. seeds for reset particles}\;
    $tests \gets GenSeed(P^T, tests, rst\_P^M)$\;
    \tcp{mutate tests for other particles}
    % that do not need to be reset}
    $tests \gets Mut(P^M, tests, \{i^M|i^M \notin rst\_P^M\})$\;
}
return $cov$\;

%%%%% version 0  with lbest cov, gbest cov, etc%%%%%%%
% $t \gets 0$, $cov \gets 0$, $tests \gets \{\}$\;
% \tcp{initialize variables related to mutation particles}
% Initialize $P^M, V^M$ randomly and normalize $p^M \in P^M$\;
% Initialize $L_{best}^M$ to $P^M$ and $g_{best}^M$ to $p_i^M$\;
% Initialize $P_{cov}, L_{cov}^M, g_{cov}^M$ to $0$\;

% \tcp{initialize variables related to seed generation}
% Initialize $P^S, V^S$ randomly and normalize $p^S \in P^S$\;
% Initialize $L_{best}^S$ to $P^S$ and $g_{best}^S$ to $p_i^S$\;
% Initialize $P_{srv}, L_{srv}^S, g_{srv}^S$ to $0$\;

% \tcp*[l]{particles needs reset}
% $rst\_P_{mut} \gets \O$, $rst\_P_{seed} \gets \O$\;
% \tcp{Enter the fuzzing loop}
% \While{$(cov < tc)$ and $(t < t_{limit})$}{
%     $tests \gets GenSeed(rst\_P_{mut}, P^S)$\;
%     $P_{cov}, cov \gets Simulate(tests)$\;
%     $L_{best}^M, g_{best}^M, L_{cov}^M, g_{cov}^M, rst\_P_{mut} \gets UpdateBestPos(P_{cov}, L_{cov}^M, g_{cov}^M, \beta_{mut})$\;

%     \tcc{Update or reset seed particles when a mutation particle gets reset}
%     \If{$rst\_P_{mut} \neq \O$}{
%         \tcp{Update iterations with the same seeds as survive time}
%         $P_{srv} \gets CalSurviveIter(rst\_P_{mut}, P_{srv})$\;
    
%         $L_{best}^S, g_{best}^S, L_{srv}^S, g_{srv}^S, rst\_P_{seed} \gets UpdateBestPos(P_{srv}, L_{srv}^S, g_{srv}^S, \beta_{seed})$\;        
        
%         $P^S, V^S \gets UpdatePV(P^S, V^S, L_{best}^S, g_{best}^S, rst\_P_{seed}, c)$\;
%     }
    
%     $P^M, V^M \gets UpdatePV(P^M, V^M, L_{best}^M, g_{best}^M, rst\_P_{mut}, c)$\;
%     \tcp{mutate tests that no need resets}
%     $tests, t \gets Mut(P^M, tests, \{p|p \notin rst\_P_{mut}\})$\;
% }
% return $cov$\;

\end{algorithm}
