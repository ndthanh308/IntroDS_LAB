
\section{Zielonka's Algorithm for \Odd-Fair Parity Games}\label{sec:zielonka}
In this section, we construct a Zielonka-like algorithm that solves \Odd-fair parity games. We call this algorithm \emph{\Odd-fair Zielonka's algorithm}. We first recall the original Zielonka's algorithm in Sec.~\ref{sec:zielonka:orig} and outline the changes imposed for our new \Odd-fair version in Sec.~\ref{sec:zielonka:fair}. We then discuss the correctness of this new algorithm in Sec.~\ref{sec:zielonka:correct}.


For the remainer of this section, we will take $\mathcal{G}^\ell = \ltup{(V, V_\Even, V_\Odd, E, \chi), E^\ell}$ to be an \Odd-fair parity game. 

\subsection{The Original Zielonka's Algorithm}\label{sec:zielonka:orig}
Intuitively, Zielonka's algorithm consists of two nested recursive functions, 
$\SOLVE_{\Even}(n,\mathcal{G})$ and $\SOLVE_{\Odd}(n,\mathcal{G})$ which compute \We and \Wo in a given parity game $\mathcal{G}$ with, respectively, even or odd upper bound priority $n$. Both functions recursively call each other on a sequence of sub-games that is constructed during the run of the algorithm. 

The main difference between the original Zielonka's algorithm \cite{Zielonka98} and our new \Odd-fair version in Alg.~\ref{algo:fair-zielonka-bb}  
is the computation of the safe reachability set, denoted by $\SafeReach^f_\bb$ within the algorithms. 
Intuitively, the safe reachability set of player \bb  
is the set of vertices from which \bb has a strategy to force the game into the reach set $R\subseteq V$, while staying in the safety set $S\subseteq V$. 
% 
In a (normal) parity game $\mathcal{G}$ (without live edges), this set  
can be computed via the single-nested fixed-point formula
\begin{equation}\label{equ:Xsr1}
 \Xsr_\bb:=\mu X~.~(S \cap (R \cup \Cpre_\bb(X))).
\end{equation}
If one interpretes Alg.~\ref{algo:fair-zielonka-bb} over (normal) parity games $\mathcal{G}$, defines $\SafeReach^f_\bb$ via \eqref{equ:Xsr1} for the respective player, and replaces $\SafeReach^f_\Odd(\cdot,X,\cdot)$ in the last return statement with $X$ (so, the algorithm returns $X$ for any $\Lambda$), one gets exactly Zielonka's algorithm for parity games. 


\vspace*{-0.5cm}

% Figure environment removed


\subsection{The \Odd-fair Zielonka's Algorithm}\label{sec:zielonka:fair}
We are now considering an \Odd-fair parity game $\mathcal{G}^\ell$. % with live edges on \Odd player vertices.
As discussed before, the main difference of the \Odd-fair Zielonka's algorithm from the original one lies in the construction of the safe reachability sets denoted by $\SafeReach^f_\bb$ in Alg.~\ref{algo:fair-zielonka-bb}. We therefore start by discussing its computation for both players.

\smallskip
\noindent\textbf{The \Odd Player.}
The first, somehow surprising, observation is that for player \Odd in \Odd-fair parity game $\mathcal{G}^\ell$, the safe reachability set $\Xsr_\Odd$ can still be computed via \eqref{equ:Xsr1}. This is due to the fact that $R$ only needs to be visited once, and 
\Even vertices do not have live outgoing edges that might prevent player \Odd from forcing a visit to $R$. 

In addition, we can extract a \emph{partial strategy template} for player \Odd from the iterative computation of \eqref{equ:Xsr1} via a similar, but much simpler ranking argument as used in Sec.~\ref{sec:strat-templates}. Here, $\rank{v} = 1$ for $v \in R$ and for the remaining vertices, 
$\rank{v}$ is the minimum integer $j$ for which $v \in X^j:=(S \cap (R \cup \Cpre_\Odd(X^{j-1})))$ where $X^0=\emptyset$. The positional strategy of \bb is then to take the minimum ranked successor from each \Odd node. 

Another way to think about this strategy is in the form of an acyclic subgraph of $\mathcal{G}^\ell$ on $\Xsr_\Odd$, where nodes in $R$ have no outgoing edges,
and for the remaining nodes, \Odd nodes have one outgoing edge and \Even nodes have all their outgoing edges. This is because if $v \in X^j\cap \Ve$, all outgoing edges achieve positive progress towards $R$, i.e. for all $(v, w) \in E$, $w \in X^{j-1}$.
Now it is easy to see that this subgraph almost defines a strategy template, i.e., on $\Xsr_\Odd\setminus R$, \Even nodes have all their outgoing edges in the subgraph, no \Odd node lies on a cycle and all of them have one outgoing edge. However, vertices in $R$ are dead-ends. We therefore call the strategy template induced by  \eqref{equ:Xsr1} \emph{partial} and denote it by $sr$. %\AKS{I think we need to properly formalize this template to use it in the next section}


\smallskip
\noindent\textbf{The \Even Player.}
It follows from the results of Banerjee et. al.~\cite{banerjee2022fast} that the safe reachability set $\Xsr_\Even$ of player \Even in \Odd-fair parity games requires the 2-nested fixed-point formula $\nu Y.\mu X.S \cap (R \cup \Apre(Y,X))$, which (via the operators defined in Sec.~\ref{sec:assump:prelim}) equals
%  
\begin{equation}\label{equ:Xsr2}
 \Xsr_\Even: =~\nu Y~.~\mu X~.~S \cap (R \cup (\Cpre_\Even(X) \cup (\Lpre^{\exists}(X) \cap \Pre_\Odd^{\forall}(Y))))
\end{equation}
Intuitively, the necessity of a 2-nested formula arises from the following lack of information: we do not know in advance, which \Odd nodes need to lie on a cycle on a strategy template required for \Odd to win. If any positional strategy that lets \Odd win (i.e., to avoid $R$ or leave $S$) from a $v\in V^\ell$
requires $v$ to lie on a cycle, then \Odd has to take $v$'s live outgoing edges as well, and thus, it can enter $\Xsr_\Even$ and lose.
The calculation of \eqref{equ:Xsr2} starts with $Y^0 := V$, resulting in $\Pre_\Odd^{\forall}(V)=V$, hence 
% \vspace{-0.5cm}
\begin{equation}\label{equ:Xsr2a}
 Y^{1}:=\mu X~.~S\cap (R \cup \Cpre_\Even(X) \cup \Lpre^\exists(X)).
\end{equation}
% \vspace{-0.1cm}
Due to the disappearence of $\Pre^\forall_\Odd(Y)$ in this iteration, intuitively all $v \in V^\ell$ are treated as if they do not have any positional winning \Odd strategy on them, so as if all \Odd strategies have to take all the live edges in the game. 
% 
$Y^1$ includes any \Odd vertex that progresses towards $R$ while staying in $S$ with using either all its edges (due to $\Cpre_\Even(X)$) or through one live edge (due to $\Lpre^\exists(X)$). Thus, any vertex that manages to stay in $V \setminus Y^1$ does so due to being won by \Odd even if \Even could force all the live outgoing edges to be taken. 
Note that due to the monotonicity of fixed-point operators, for all $j$, $V \setminus Y^1 \subseteq V \setminus Y^j$.

Throughout the calculation, $ V \setminus Y^j$ keeps track of the nodes that have managed to escape $S$ or avoid $R$ in the previous iteration, so are `already' won by \Odd in the first $j$ iterations. The inner fixed-point calculation in the $(j+1)^{th}$ iteration treats $V \setminus Y^j$ as a subset of \Odd's winning region and it deems any node that can be forced by \Odd to reach $V \setminus Y^j$, lost by \Even.
When the algorithm saturates, $Y^\infty$ contains only those \Odd nodes that cannot be forced by \Odd to reach $V \setminus Y^\infty$, i.e., are won by \Even. Here it is important to observe that, $V \setminus Y^\infty$ contains some \Odd nodes that are not $V \setminus Y^1$. Since they are in $Y^1$, these nodes inductively %\todo{IS:iteratively? any other word?} 
reach \Even winning vertices through live edges.  
This reveals that, all nodes in $V \setminus Y^j$ but not in $V \setminus Y^1$ win due to a positional \Odd strategy that reaches $V \setminus Y^{j-1}$. 
Iteratively, this reveals that all such nodes have positional \Odd strategies that make them reach $V \setminus Y^1$.

The above alternative interpretation of the computation of $\Xsr_\Even$ in \eqref{equ:Xsr2} is the key insight that we utilize to define our new \Odd-fair Zielonka's algorithm, as discussed next.

\smallskip
\noindent\textbf{The \Odd-fair Zielonka's Algorithm.}
%
Following up on the previous discussion, we use the following insight within the construction of the \Odd-fair Zielonka's algorithm. We assume the existence of a core subset $\Wo' \subseteq \Wo$  
that player \Odd can force all nodes in $\Wo$ %(i.e., the winning region of \Odd in the \Odd-fair parity game $\mathcal{G}^\ell$) 
to, that is winning for \Odd even under the assumption that \Even can force all the live edges in the game to be taken. %\footnote{We note that this is a similar insight used in the proof of winning strategy templates discussed in Sec.~\ref{sec:strat-templates}.}.  
% 
Since Zielonka's algorithm solves parity games by a sequence of nested safe-reachability calculations for alternating players, we apply the following trick:
Instead of computing $\Xsr_\Even$ via \eqref{equ:Xsr2} in each recursive call of Alg.~\ref{algo:fair-zielonka-bb}, we only compute $Y^1$ via \eqref{equ:Xsr2a} and use it as an \emph{overapproximation} of $\Xsr_\Even$ (which it truly is due to the monotonicity of \eqref{equ:Xsr2} in $Y$). 
That is, while we take the \Odd safe reachability set $\SafeReach^f_\Odd$ as the original (linear) \Odd safe reachability computation known for these games (given in~\eqref{equ:Xsr1}), we do not take \Even safe reachability formula $\SafeReach^f_\Even$ to be the (quadratic) \Even safe reachability computation known for these games (given in~\eqref{equ:Xsr2}),
but we instead take it as its (linear) subformula given in~\eqref{equ:Xsr2a} and arrive at an overapproximation of the \Even safe reachability region at the end of each $\SafeReach^f_\Even$ calculation. We finalize the recursive call $\SOLVE_\Odd$ by an extra call of $\SafeReach^f_\Odd$ applied to the (thus) underapproximated \Odd winning region in the sub-game, therefore expanding the returned \Odd winning region of the sub-game.  

By this, it turns out that the recursive call of $\SOLVE_\Odd(n, \mathcal{G}^\ell)$ actually computes $\Wo'$ as the set $X$ and we ensure that $\Wo$ is returned by the additional (linear) computation of $\SafeReach^f_\Odd$ over $X$ in the last return statement of Alg.~\ref{algo:fair-zielonka-bb}.
% 
This instantiation of the safe-reachability computations is formalized next.

\begin{definition}\label{def:safereach}
 Given an \Odd-fair parity game $\mathcal{G}^\ell=\ltup{(V, V_\Even, V_\Odd, E, \chi), E^\ell}$ the safe-reachability procedures $\SafeReach^f_\Odd(S, R, \mathcal{G}^\ell)$ and $\SafeReach^f_\Even(S, R, \mathcal{G}^\ell)$ in Alg.~\ref{algo:fair-zielonka-bb} denote the iterative fixed-point computations in \eqref{equ:Xsr1} for \Odd and \eqref{equ:Xsr2a} for \Even.
\end{definition} 

\subsection{Complexity of the \Odd-fair Zielonka's Algorithm}\label{sec:zielonka:complexity}
The safe-reachability computations defined in Def.~\ref{def:safereach} have the same complexity as their computations via \eqref{equ:Xsr1} in the original Zielonka's algorithm. The only difference is in the number of calculated $\Pre$ operations: while $\SafeReach_\Even$ from original Zielonka's algorithm~\eqref{equ:Xsr1} require the calculation of only one $\Pre$ operator, $\SafeReach_\Even^f$ from~\eqref{equ:Xsr2a} requires the calculation of 2 $\Pre$ operators. The additional final call of $\SafeReach^f_\Odd$ in $\SOLVE_\Odd$ procedure also has linear complexity and requires one $\Pre$ calculation. 
Therefore, not only the worst-case time complexity of Alg.~\ref{algo:fair-zielonka-bb} is equivalent to that of original Zielonka's algorithm (which would be the case even if we used the quadratic safe reachability formula from~\eqref{equ:Xsr2} for \Even since the overall complexity of the algorithm is exponential) but we create almost no additional computational overhead in the algorithm by introducing the fairness assumptions.

We further remark that Alg.~\ref{algo:fair-zielonka-bb} is not a straight-forward interpretation of the nested fixed-point in~\eqref{eq:fp-odd}, and its negation (see~\eqref{eq:fp-even} in App.~\ref{app:fp-proof}) in the form of Zielonka's algorithm. 

Firstly, such a straightforward approach is non-trivial due to $\Apre$ and $\Npre$ operators taking two variables from two different iterations of the fixed-point calculation. 
Furthermore, 
at each \Even safe-reachability call of Alg.~\ref{algo:fair-zielonka-bb}, as mentioned we compute 2 $\Pre$ operators (equation~\ref{equ:Xsr2a}), whereas in each such corresponding step in the fixed-point iteration, we would have to compute 3 $\Pre$ operators due to the expansion of $\Apre$~\eqref{equ:apre} and $\Npre$~\eqref{equ:npre}.

It remains to show that \Odd-fair Zielonka's algorithm solves \Odd-fair parity games. 

\input{SUCCINCTfair-zielonka-5.3.tex}
