
\subsection{Preliminaries on Fixed-Point Algorithms}\label{sec:assump:prelim}
% 

This subsection contains the basic notation used in this section. 

\smallskip
\noindent\textbf{Set Transformers.}  Let $ \gamegraph=(V,\Ve, \Vo, E) $ be a game graph, $ S,T\subseteq V $ and $\bb$ be the player index\footnote{$\bb \in \{\Even,\Odd\} $ where $\bb=\Even$ implies $\neg \bb=\Odd$, and vice versa}. Then we define the following predecessor operators: 
\begin{subequations}\label{equ:Pres}
 \begin{align*}    
    \Pre_\bb^\exists(S) &:= \{ v \in V_\bb \mid E(v) \cap S \neq \emptyset \} && 
        \Lpre^\exists(S) := \{v \in \Vo \mid E^\ell(v) \cap S \neq \emptyset\} \notag \\ 
        \Pre_\bb^\forall(S) &:= \{ v \in V_\bb \mid E(v) \subseteq S  \} &&
    \Lpre^\forall(S) := \{v \in \Vo \mid E^\ell(v) \subseteq S \}\quad  (3)
     \end{align*}
\end{subequations}

The predecessor operators $\Pre_\bb^\exists(S) $ and $\Pre_\bb^\forall(S)$ compute the sets of vertices with \emph{at least one} successor and with \emph{all} successors in $ S $, respectively. The live predecessor operators  $ \Lpre^\exists(S) $ and $\Lpre^\forall(S)$ restrict this analysis to live edges.
We see that 
% 
 \begin{align}    \label{equ:Preseq}
   \neg \Pre_\bb^{\exists}(\neg S)&= V_{\neg \Lambda} \cup \Pre_{\neg \bb}^{\forall}(S)&&\text{and}&&
   \neg \Lpre^{\exists}(\neg S)= \Ve \cup \Lpre^{\forall}(S)%\vspace{-2mm}
 \end{align}
% 
where for a set $X \subseteq V$, $\neg X$ stands for $V \setminus X$. We combine the pre-operators from \eqref{equ:Pres} into the combined set transformer\footnote{Note that $\Apre(S,T)$ and $\Npre(S,T)$ are meaningful only when $T \subseteq S$ and $S \subseteq T$, respectively. Otherwise they are equivalent to $\Cpre_\Even(T)$ and $\Cpre_\Odd(T)$. We note that these preconditions will always be satisfied in our calculations due to the monotonicity of fixed-point computations.}:
\begin{subequations}\label{equ:combindedPres}     
     \begin{align}
    \Cpre_\bb(S) &:= \Pre_\bb^\exists(S) \cup \Pre_{\nb}^\forall(S)\label{equ:cpre}\\
    \Apre(S, T) &:= \Cpre_\Even(T) \cup (\Lpre^{\exists}(T) \cap \Pre_\Odd^{\forall}(S))\label{equ:apre}\\
    \Npre(S,T) &:= \Cpre_\Odd(T) \cap (\Ve \cup \Lpre^\forall(T) \cup \Pre_\Odd^{\exists}(S))\label{equ:npre}       
    \end{align}
\end{subequations}
% 
The \emph{controllable predecessor operator} $\Cpre_\bb(S)$ computes the set of vertices from which player $\bb$ can force visiting $ S $ in \emph{one} step. It immediately follows that 
%
\begin{align}
\neg \Cpre_\Even(\neg S)&:= \Cpre_\Odd(S)\label{equ:cpre_equal}.
\end{align}
% 
The \emph{almost-sure controllable predecessor} operator $\Apre(S,T)$ computes the set of states that can be controlled by Player \Even to stay in $T$ (via $\Cpre_\Even(T ))$ as well as all Player \Odd states in $V^\ell$ that
(a) will eventually make progress towards $T$ if Player \Odd obeys its fairness-assumptions (via $\Lpre^{\exists}$) and (b) will never leave $S$ in the \enquote{meantime} (via $\Pre_\Odd^{\forall}(S))$). Using \eqref{equ:Preseq} and \eqref{equ:cpre_equal} we have 
  $\Npre(S,T):= \neg \Apre(\neg S, \neg T)$.


\smallskip
\noindent\textbf{Fixed-point Algorithms in the $ \mu $-calculus.} 
$ \mu $-calculus offers a succinct representation of symbolic algorithms (i.e., algorithms manipulating sets of vertices instead of individual vertices) over a game graph $ \gamegraph $. 
We omit the (standard) syntax and semantics of $ \mu $-calculus formulas (see \cite{Kozen:muCalculus}) and only discuss their evaluation
%  
on an example fixed-point algorithm given by a 2-nested $ \mu $-calculus formula of the form $Z=\mu Y.~\nu X.~\phi(X,Y)$, where  $ X,Y \subseteq V$ are subsets of vertices
 and $ \mu $ and $ \nu $ denote, respectively, the least and the greatest fixed-point. $\phi$ is a formula composed from the \emph{monotone set transformers} in  \eqref{equ:Pres} and \eqref{equ:combindedPres}. % of the functional defined as $ X\mapsto \phi(X) $. 
 
 Given this formula, first, both formal variables $X$ and $Y$ are initialized. As $Y$ (resp. $X$) is preceded by $\mu$ (resp. $\nu$) it is initialized with $Y^0:=\emptyset$ (resp. $X^0:=V$). Now we first keep $Y$ at its initial value and iteratively compute $X^k=\phi(X^{k-1},Y^0) $ until $X^{k+1}=X^k$. At this point $X$ saturates, denoted by $X^\infty$. We then \enquote{copy} $X^\infty$, to $Y$, i.e., have $Y^1:=X^\infty$, reinitialize $X^0:=\emptyset$, and re-evaluate $X^k=\phi(X^{k-1},Y^1) $ with the new value of $Y$. This calculation terminates if $Y$ saturates, i.e.,  $Y^\infty=Y^{l+1}=X^l$ for some $l\geq 0$, and outputs $Z=Y^\infty$. In order to remember all intermediate values of $X$ we use $X^{l,k}$ to denote the set computed in the $k$-th iteration over $X$ during the computation of $Y^l$. I.e., $Y^l=X^{l,\infty}$.

\smallskip
\noindent\textbf{Additional Notation.} 
We will use the letters $l,m$ and $n$ exclusively to denote \emph{even} positive integers. For $a \leq b \in \mathbb{N}$, we will use the regular set symbol $[a,b]$ to denote the set of all integers between $a$ and $b$, i.e., $[a,b]:=\{a, a+1 , \ldots , b\}$; and $\ev{a}{b}$ to denote all the \emph{even} integers between $a$ and $b$. %, including $a$ or $b$ as well given that it is even,
E.g. $\ev{2}{7} = \{2, 4,  6\}$.
In addition, given an \Odd-fair parity game $\mathcal{G}^\ell$, we define the sets $C_i := \{ v \in V \mid \chi(v) = i\}$ and $\overline{C_i} := V \setminus C_i$ to ease notation. We say $\mathcal{G}^\ell$ has 
the least even upperbound $l$ if $C_l \cup C_{l-1}\neq\emptyset$ and $C_i=\emptyset$ for all $i>l$.
