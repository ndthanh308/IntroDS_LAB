
\subsection{Details on Experimental Results}\label{app:experiments}

We conducted an experimental study to empirically validate the claim that our new \Odd-fair Zielonka's algorithm retains its efficiency in practice. For this, we implemented the following algorithms (non-optimized) in C++:
\begin{itemize}
 \item \texttt{OF-ZL}: \Odd-fair Zielonka's algorithm (Alg.~\ref{algo:fair-zielonka-bb}),
 \item \texttt{N-ZL}: \enquote{normal} Zielonka's algorithm from \cite{Zielonka98} (i.e., Alg.~\ref{algo:fair-zielonka-bb} with the simplifications described in Sec.~\ref{sec:zielonka:orig}),
 \item \texttt{OF-FP}: the fixed-point algorithm for \Odd-fair parity games implementing \eqref{eq:fp-odd} ,
 \item \texttt{N-FP}: the fixed-point algorithm for \enquote{normal} parity games from \cite{EJ91}.
\end{itemize}
Of course, for both \texttt{N-ZL} and \texttt{N-FP} there exist optimized implementations in the tool \texttt{oink}~\cite{oink}. However, the goal of this section is to show a conceptual comparison, rather than evaluating best computation times. We believe that this is better achieved by using similar (non-optimized) implementations for all algorithms. In particular, we run the following three sets of experiments to show that:
\begin{enumerate}
 \item \texttt{OF-ZL}: is largely insensitive to the number of priorities and the number of fair edges (see Fig.~\ref{fig:percentages-colours}),
 \item \texttt{OF-ZL}: significantly outperforms \texttt{OF-FP} on almost all benchmarks (see Fig.~\ref{fig:zoomed_out} (right))
\item the performance of \texttt{OF-ZL} and \texttt{N-ZL} on the given benchmark set is very similar (see Fig.~\ref{fig:zielonkas_comparison}),
 \item the comparative performance of \texttt{OF-ZL} and \texttt{N-ZL} w.r.t.\ their respective fixed-point versions \texttt{OF-FP} and \texttt{N-FP}), respectively, is very similar (see Fig.~\ref{fig:logscale}).
\end{enumerate}
All experiments where run on a large benchmark suite explained in Sec.~\ref{app:experiments:benchmarks}. To perform our experiments we used a machine equipped with Intel(R) Core(TM) i5-6600 CPU @ 3.30GHz and 8GB RAM. We declare a timeout when the calculation of an example exceeds 1 hour.

\subsubsection{Benchmark}\label{app:experiments:benchmarks}
We generated \Odd-fair parity game instances manipulating $286$ benchmark instances of PGAME$\_$Synth$\_$2021 dataset of the SYNTCOMP benchmark suite~\cite{syntcomp} and $51$ benchmark instances of the PGSolver dataset of Keiren's benchmark suite~\cite{keirens}. Within the latter, we restricted ourselfs to instances with $\leq 5000$ nodes.
Both datasets contain examples of normal parity games. For each selected
example, we generate \Odd-fair parity game instances for a particular liveness percentage $\alpha$. For a $\alpha\%$-liveness instant, we fix $\alpha\%$ of the \Odd nodes in the game, and turn $\alpha\%$ of each of their outgoing edges to live edges. %, where $\alpha$ is either $30$ or $50$. 
In addition, we also generated \Odd-fair parity game instances with varying number of priorities $p$ by partitioning the nodes of the games uniformly at random according to the number of priorities.

%
Detailed run-times of all algorithms on a representative selection of examples from the instances fenerated from SYNTCOMP benchmark suite are listed in Table~\ref{table:FPvsOddfairzlk}. 
% 
On the \Odd-fair instances with $50\%-$liveness generated from the SYNTCOMP benchmark suite, there are 204 instances where neither of the algorithms \texttt{OF-FP}, \texttt{OF-ZL}, \texttt{N-FP} or \texttt{N-ZL} timed out. On these instances, \texttt{OF-ZL} gives an average computation time of $4.6$ seconds while \texttt{OF-FP} took $122.7$ seconds on average. 
On the same examples, \texttt{N-ZL} takes on average $3.6$ seconds to compute while \texttt{N-FP} gives an average of $45.2$ seconds. 
For the PGSolver dataset \texttt{OF-FP} timed out on all generated instances, whereas \texttt{OF-ZL} took $24.9$ seconds on average to terminate.




% In order to compare the algorithmic advantage Zielonka's algorithm posesses over the fixed-point implementation, 
% we have implemented a naive fixed-point algorithm in the same fashion with \texttt{OF-FP} and our own version of Zielonka's algorithm for regular parity games in the same fashion with \texttt{OF-ZL}.
% We call these these algorithms \texttt{N-FP} and \texttt{N-ZL} respectively, where \texttt{R} stands for `regular'.  
% We do not use any efficient online parity solvers and instead use our 'non-optimal' code that is written similarly to their fair-parity counterparts in order for the comparison to be meaningful.


\subsubsection{Sensitivity}\label{app:experiments:sensitivity}
To monitor the sensitivity of \texttt{OF-ZL} to the change in number of priorities as well as the percentage of live edges in the game, we picked $12$ parity game instances from the SYNTCOMP dataset which did not timeout (after one hour). %\AKS{are those also depicted in the table? if so, could we mark the rows?}\IS{They are mostly not in the table.}
With priorities $3-4-5-6$ and liveness degrees 0$\%$\footnote{regular parity game}-30$\%$-50$\%$-80$\%$ we get 192 different \Odd-fair parity instances. Fig.~\ref{fig:percentages-colours} shows the runtime of \texttt{OF-ZL} on these instances.

We can see that the runtimes of instances with different priority and liveness percentages are distributed in a seemingly random manner.
This tells us that \Odd-fair Zielonka's algorithm is highly insensitive to a change in the percentage of live edges and the number of priorities. %\todo{IS:whereas fixed-point algorithm...?} 
This observation is inline with the known insensitivity of Zielonka's algorithm for the number of priorities.

% Figure environment removed




\subsubsection{Comparative Evaluation}\label{app:experiments:comparison}
In order to validate the computational advantage of \texttt{OF-ZL} over \texttt{OF-FP}, we have run both algorithms on all 50$\%$-liveness instances generated from the SYNTCOMP benchmark dataset. On 58 of these instances, both algorithms time out. The run-times for all other instances are depicted in Fig.~\ref{fig:zoomed_out} (right),~\ref{fig:zoomed_in} (right) and~\ref{fig:logscale} (right). The left plots in Fig.~\ref{fig:zoomed_out}-\ref{fig:logscale} show the same comparison for the \enquote{normal} parity algorithms \texttt{N-ZL} and \texttt{N-FP}. 
In both cases, Fig.~\ref{fig:zoomed_in} shows the zoomed-in version of the respective plot in Fig.~\ref{fig:zoomed_out}. Fig.~\ref{fig:logscale} shows the data-points from the respective plot in Fig.~\ref{fig:zoomed_in} as a scatter plot in log-scale. 
The examples on which only \texttt{x-FP} times out, can be seen as the dots on the ceiling of the plots in Fig.~\ref{fig:zoomed_out}. In all plots, points above the diagonal correspond to instances where Zielonka's algorithm outperforms the fixed-point algorithm.

We clearly see in Fig.~\ref{fig:zoomed_out}-\ref{fig:logscale} that Zielonka's algorithm performs significantly better than the fixed-point version, both in the \Odd-fair (right) and in the normal (left) case. More importantly, the overall performance comparison between  \texttt{OF-ZL} over \texttt{OF-FP} (right plots) mimics the comparison between \texttt{N-ZL} over \texttt{N-FP}. This allows us to conclude that our new \Odd-fair Zielonka's algorithm retains the computational advantages of Zielonka's algorithm. % and handling fairness only introduces a mild overhead. 

In addition, Table~\ref{table:FPvsOddfairzlk} shows that \texttt{OF-ZL} results in almost the same run-time as \texttt{N-ZL}, showing that our changes in the algorithm incur almost no computational disadvantages over the original algorithm. This allows us to handle transition fairness for almost free in practice.



% Figure environment removed

% Figure environment removed

% Figure environment removed

% Figure environment removed

% 
% 
% 
% 
% %TABLE
% In Table~\ref{table:FPvsOddfairzlk}, we aim to make two different comparisons visible, on generated instances from 20 representative examples we selected from PGAME$\_$Synth$\_$2021 dataset. First comparison is between the performance of the two algorithms, \texttt{OF-FP} and \texttt{OF-ZL} for fair parity games and 
% the second comparison is between the speed-up provided by Zielonka's algorithm in regular parity games and the speed-up provided by fair Zielonka's algorithm in fair parity games with respect to their respective fixed-point algorithms. 
% 
% A generated instance is prefixed by \enquote{30$\%$-} (\enquote{50$\%$-}) if it's a fair-parity instance with 30$\%$-(50$\%$-)-liveness, created from the representative example with the original name. The listed runtimes for \texttt{FP} and \texttt{ZL} correspond to the runtimes of \texttt{OF-FP} and \texttt{OF-ZL} on these instances.  
% 
% %with 30$\%$-liveness or "50$\%$-" to the original example's name for the first instance (that turns $30\%$ of the \Odd nodes and edges to live), and the second instance (that do the same for $50\%$), respectively. We run the \Odd-fair fixed-point (our naive implementation of the fixed-point algorithm from~\eqref{eq:fp-odd}) and \Odd-fair Zielonka (Alg.~\ref{algo:fair-zielonka-odd}-\ref{algo:fair-zielonka-even}) on these instances and the listed runtimes for \texttt{FP} and \texttt{ZL} correspond to the runtimes of \texttt{OF-FP} and \texttt{OF-ZL}, respectively.  
% If an instance is listed without any prefix, it corresponds to the original representative example, which is as a parity game without live edges. The listed runtimes for \texttt{FP} and \texttt{ZL} correspond to the runtimes of \texttt{N-FP} and \texttt{N-ZL} on these instances.  
% 
% \IS{change the numbers according to results:} On 3 of these instances, the fixed-point algorithm timed out whereas Zielonka's algorithm took on average 90 seconds to terminate. 



\smallskip
\textbf{Conclusion:}
The results show that Zielonka's algorithm is significantly faster in solving \Odd-fair parity games compared to the calculation performed by the fixed-point algorithm, as is the case in normal parity games. 
The fixed-point algorithm started timing out as soon as the examples became more complex, being especially sensitive to  
the increase in the number of priorities. Whereas, Zielonka's algorithm preserves its performance considerably in the face of the increase in the same parameters. These 
outcomes match the known comparison results between the naive fixed-point calculation versus Zielonka's algorithm, on normal parity games.  



\newpage
% \begin{center}

     \begin{longtable}{||c |c |c |c |c |c ||} %begin{table}
     \caption{Detailed run-time comparison of \texttt{N-FP} and \texttt{N-ZL} on the original parity game instances (yellow rows) with \texttt{OF-FP} and \texttt{OF-ZL} on their respective $30\%$- and $50\%$-liveness \Odd-fair parity game instances (white rows). The instance name is taken from the original benchmark suite.
%      parity examples (the rows with the original example's names)
% and \Odd-fair instances of these examples with 30$\%$- and 50$\%$-liveness (the rows with the original example's names prefixed by \enquote{30$\%$-} or \enquote{50$\%$-})
% solved via a naive implementation of their corresponding fixed point and Zielonka's algorithms. For the regular parity examples \texttt{FP} and \texttt{ZL} correspond to \texttt{N-FP} and \texttt{N-ZL}, and for \Odd-fair parity instances they correspond to \texttt{OF-FP} and \texttt{OF-ZL}, respectively.
}\label{table:FPvsOddfairzlk}\\
     
    %      \begin{tabular}{||c |c |c |c |c |c ||}
 \hline
 Name &  $\#$  &  $\#$  &  $\#$  & \texttt{FP} & \texttt{ZL}  \\ [0.5ex] 
      &    nodes    &   edges     &   priorities &     (sec.)       & (sec.)  \\
 \hline  \hline \rowcolor{Highlight}
 EscalatorCountingInit & 99 & 148 & 3 & 0.064 & 0.012  \\ 
 \hline
 $30\%$-EscalatorCountingInit & 99 & 148 & 3 & 0.075 & 0.018  \\ 
 \hline
 $50\%$-EscalatorCountingInit & 99 & 148 & 3 & 0.072 & 0.02 \\
 \hline \rowcolor{Highlight}
 KitchenTimerV1 & 80 & 124 & 3 & 0.055 & 0.008 \\
 \hline
 $30\%$-KitchenTimerV1 & 80 & 124 & 3 & 0.068 & 0.012 \\
 \hline
 $50\%$-KitchenTimerV1 & 80 & 124 & 3 & 0.21 & 0.009  \\
 \hline \rowcolor{Highlight}
 KitchenTimerV6 & 4099 &  6560 & 3 & 87 & 11 \\
 \hline
 $30\%$-KitchenTimerV6 & 4099 &  6560 & 3 & 88 & 11 \\
 \hline
 $50\%$-KitchenTimerV6 & 4099 &  6560 & 3 & 352 & 18 \\
 \hline \rowcolor{Highlight}
 MusicAppSimple & 344 &  562 & 3 & 0.488 & 0.073 \\
 \hline
 $30\%$-MusicAppSimple & 344 &  562 & 3 & 0.496 & 0.082 \\
 \hline
 $50\%$-MusicAppSimple & 344 &  562 & 3 & 0.799 & 0.089 \\
 \hline \rowcolor{Highlight}
 TwoCountersRefinedRefined & 1933 & 3140 & 3 & 14.9 & 2.5 \\
 \hline
 $30\%$-TwoCountersRefinedRefined & 1933 & 3140 & 3 & 15 & 1.2 \\
 \hline 
 $50\%$-TwoCountersRefinedRefined & 1933 & 3140 & 3 & 74 & 3.72 \\
 \hline \rowcolor{Highlight}
 Zoo5 & 479 & 768 & 3 & 0.96 & 0.135 \\
 \hline
 $30\%$-Zoo5 & 479 & 768 & 3 & 0.981 & 0.152 \\
 \hline 
 $50\%$-Zoo5 & 479 & 768 & 3 & 1.57 & 0.172 \\
 \hline \rowcolor{Highlight}
 amba$\_$decomposed$\_$lock$\_$3 & 1558 & 2336 & 3 & 72 & 1.5  \\
 \hline
 $30\%$-amba$\_$decomposed$\_$lock$\_$3 & 1558 & 2336 & 3 & 73 & 1.5  \\
 \hline 
 $50\%$-amba$\_$decomposed$\_$lock$\_$3 & 1558 & 2336 & 3 & 56 & 2.9 \\
 \hline \rowcolor{Highlight}
 full$\_$arbiter$\_$2 & 204 & 324 & 3 & 0.59 & 0.049 \\
 \hline
 $30\%$-full$\_$arbiter$\_$2 & 204 & 324 & 3 & 0.602 & 0.047 \\
 \hline 
 $50\%$-full$\_$arbiter$\_$2 & 204 & 324 & 3 & 5 & 0.059 \\
 \hline \rowcolor{Highlight}
 full$\_$arbiter$\_$3 & 1403 & 2396 & 3 & 21.18 & 2 \\
 \hline
 $30\%$-full$\_$arbiter$\_$3 & 1403 & 2396 & 3 & 21.5 & 2 \\
 \hline 
 $50\%$-full$\_$arbiter$\_$3 & 1403 & 2396 & 3 & 93 & 3.46 \\
 \hline \rowcolor{Highlight}
 lilydemo06 & 369 & 548 & 3 & 8.1 & 0.18 \\
 \hline 
 $30\%$-lilydemo06 & 369 & 548 & 3 & 8.13 & 0.206 \\ 
 \hline 
 $50\%$-lilydemo06 & 369 & 548 & 3 & 18 & 0.212 \\
 \hline \rowcolor{Highlight}
 lilydemo07 & 78 & 108 & 3 & 0.27 & 0.01 \\ 
 \hline
 $30\%$-lilydemo07 & 78 & 108 & 3 & 0.284 & 0.017 \\ 
 \hline 
 $50\%$-lilydemo07 & 78 & 108 & 3 & 0.33 & 0.008 \\ 
 \hline \rowcolor{Highlight}
 simple$\_$arbiter$\_$unreal1 & 2178 & 3676 & 3 & 22.8 & 3 \\
 \hline
 $30\%$-simple$\_$arbiter$\_$unreal1 & 2178 & 3676 & 3 & 23 & 3 \\
 \hline 
 $50\%$-simple$\_$arbiter$\_$unreal1 & 2178 & 3676 & 3 & 254 & 7 \\ 
 \hline \rowcolor{Highlight}
 amba$\_$decomposed$\_$arbiter$\_$2 & 141 & 212 & 4 & 0.72 & 0.03  \\
 \hline
 $30\%$-amba$\_$decomposed$\_$arbiter$\_$2 & 141 & 212 & 4 & 0.73 & 0.06  \\
 \hline
 $50\%$-amba$\_$decomposed$\_$arbiter$\_$2 & 141 & 212 & 4 & 1 & 0.035  \\
 \hline \rowcolor{Highlight}
 loadfull3 & 1159 & 2030 & 4 & 5.62 & 0.609 \\
 \hline
 $30\%$-loadfull3 & 1159 & 2030 & 4 & 5 & 0.614 \\
 \hline 
 $50\%$-loadfull3 & 1159 & 2030 & 4 & 5 & 0.754 \\
 \hline \rowcolor{Highlight}
 ltl2dba01 & 101 & 152 & 4 & 0.074 & 0.031  \\
 \hline
 $30\%$-ltl2dba01 & 101 & 152 & 4 & 0.075 & 0.030  \\
 \hline 
 $50\%$-ltl2dba01 & 101 & 152 & 4 & 1.4 & 0.028 \\
 \hline \rowcolor{Highlight}
 ltl2dba14 & 97 & 144 & 4 & 0.18 & 0.016 \\
 \hline
 $30\%$-ltl2dba14 & 97 & 144 & 4 & 0.181 & 0.013 \\
 \hline 
 $50\%$-ltl2dba14 & 97 & 144 & 4 & 0.574 & 0.012 \\
 \hline \rowcolor{Highlight}
 ltl2dba22 & 21 & 30 & 4 & 0.037 & 0.002 \\
 \hline
 $30\%$-ltl2dba22 & 21 & 30 & 4 & 0.036 & 0.002 \\
 \hline 
 $50\%$-ltl2dba22 & 21 & 30 & 4 & 0.03 & 0.0009 \\
 \hline \rowcolor{Highlight}
 prioritized$\_$arbiter$\_$unreal2 & 851 & 1412 & 4 & 15.8 & 0.73 \\
 \hline
 $30\%$-prioritized$\_$arbiter$\_$unreal2 & 851 & 1412 & 4 & 16 & 0.759 \\
 \hline 
 $50\%$-prioritized$\_$arbiter$\_$unreal2 & 851 & 1412 & 4 & 126 & 1.2 \\
 \hline \rowcolor{Highlight}
 lilydemo17 & 3102 & 5334 & 7 & 1237 & 41 \\
 \hline
 $30\%$-lilydemo17 & 3102 & 5334 & 7 & Timeout & 41 \\
 \hline 
 $50\%$-lilydemo17 & 3102 & 5334 & 7 & Timeout & 24 \\
 \hline \rowcolor{Highlight}
 lilydemo18 & 449 & 728 & 9 & 220 & 0.6 \\
 \hline
 $30\%$-lilydemo18 & 449 & 728 & 9 & 224 & 0.621 \\
 \hline 
 $50\%$-lilydemo18 & 449 & 728 & 9 & Timeout & 0.552 \\[1ex] 
 \hline
%\end{tabular}
%\caption{Performance comparison between parity examples solved via \texttt{N-FP} and \texttt{N-ZL} (the rows with the original example's names),
%and \Odd-fair instances of the example with 30$\%$- and 50$\%$-liveness solved via \texttt{OF-FP} and \texttt{OF-ZL} (the rows with the original example's names prefixed by \enquote{30$\%$-} or \enquote{50$\%$-}).}


\end{longtable} %\end{table}
% \end{center}
     
% 2 figures side-byy-side using minipages:
%% Figure environment removed
