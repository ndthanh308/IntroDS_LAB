
\subsection{Preliminaries on Fixed-Point Algorithms}\label{sec:assump:prelim}
% 

This subsection contains the basic notation used in this section. % to define and evaluate the fixed-point algorithms for computing $\Wo$.

\smallskip
\noindent\textbf{Set Transformers.}  Let $ \gamegraph=(V,\Ve, \Vo, E) $ be a game graph, $ S,T\subseteq V $ and $\bb$ be the player index.\footnote{$\bb \in \{\Even,\Odd\} $ where $\bb=\Even$ implies $\neg \bb=\Odd$, and vice versa.} Then we define the following predecessor operators: 
\begin{subequations}\label{equ:Pres}
 \begin{align*}    
    \Pre_\bb^\exists(S) &:= \{ v \in V_\bb \mid E(v) \cap S \neq \emptyset \} && 
        \Lpre^\exists(S) := \{v \in \Vo \mid E^\ell(v) \cap S \neq \emptyset\} \notag \\ 
        \Pre_\bb^\forall(S) &:= \{ v \in V_\bb \mid E(v) \subseteq S  \} &&
    \Lpre^\forall(S) := \{v \in \Vo \mid E^\ell(v) \subseteq S \}\quad  (3)
     \end{align*}
\end{subequations}

The predecessor operators $\Pre_\bb^\exists(S) $ and $\Pre_\bb^\forall(S)$ compute the sets of vertices with \emph{at least one} successor and with \emph{all} successors in $ S $, respectively. The live predecessor operators  $ \Lpre^\exists(S) $ and $\Lpre^\forall(S)$ restrict this analysis to live edges.
We see that 
% \vspace{-2mm}
% \begin{subequations}
 \begin{align}    \label{equ:Preseq}
   \neg \Pre_\bb^{\exists}(\neg S)&= V_{\neg \Lambda} \cup \Pre_{\neg \bb}^{\forall}(S)&&\text{and}&&
   \neg \Lpre^{\exists}(\neg S)= \Ve \cup \Lpre^{\forall}(S)%\vspace{-2mm}
 \end{align}
% \end{subequations}
% \vspace{-1.5mm}
where for a set $X \subseteq V$, $\neg X$ stands for $V \setminus X$. We combine the pre-operators from \eqref{equ:Pres} into the combined set:\footnote{Note that $\Apre(S,T)$ and $\Npre(S,T)$ are meaningful only when $T \subseteq S$ and $S \subseteq T$, respectively. Otherwise they are equivalent to $\Cpre_\Even(T)$ and $\Cpre_\Odd(T)$. We note that these preconditions will always be satisfied in our calculations due to the monotonicity of fixed-point computations.} 
\begin{subequations}\label{equ:combindedPres}     
     \begin{align}
    \Cpre_\bb(S) &:= \Pre_\bb^\exists(S) \cup \Pre_{\nb}^\forall(S)\label{equ:cpre}\\
    \Apre(S, T) &:= \Cpre_\Even(T) \cup (\Lpre^{\exists}(T) \cap \Pre_\Odd^{\forall}(S))\label{equ:apre}\\
    \Npre(S,T) &:= \Cpre_\Odd(T) \cap (\Ve \cup \Lpre^\forall(T) \cup \Pre_\Odd^{\exists}(S))\label{equ:npre}       
    \end{align}
\end{subequations}
% \vspace{-1mm}
The \emph{controllable predecessor operator} $\Cpre_\bb(S)$ computes the set of vertices from which player $\bb$ can force visiting $ S $ in \emph{one} step. It immediately follows that 
%\begin{subequations}\label{equ:combindedPreseqal}   
%\vspace{-0.5cm}
\begin{align}
\neg \Cpre_\Even(\neg S)&:= \Cpre_\Odd(S)\label{equ:cpre_equal}.
\end{align}
% 
% $\neg \\Cpre_\Even(\neg S):= \Cpre_\Odd(S)~\refstepcounter{equation}(\theequation)\label{equ:cpre_equal}$.
% 
%$~\refstepcounter{\neg \Cpre_\Even(\neg S)&:= \Cpre_\Odd(S)}(\theequation)\label{equ:cpre_equal}$
The \emph{almost-sure controllable predecessor} operator $\Apre(S,T)$ computes the set of states that can be controlled by Player \Even to stay in $T$ (via $\Cpre_\Even(T ))$ as well as all Player \Odd states in $V^\ell$ that
(a) will eventually make progress towards $T$ if Player \Odd obeys its fairness-assumptions (via $\Lpre^{\exists}$) and (b) will never leave $S$ in the \enquote{meantime} (via $\Pre_\Odd^{\forall}(S))$). Using \eqref{equ:Preseq} and \eqref{equ:cpre_equal} we have 
  $\Npre(S,T):= \neg \Apre(\neg S, \neg T)$.
%\end{subequations}

%
%Sometimes we will need to apply the controllable predecessor operators multiple times, hence we define some multi-step operators.
% In the following, we introduce the attractor operator $ \textsf{attr}^a_{\gamegraph}(U) $ that computes the set of vertices from which $ \p{a}$ can force at least a single visit to $ U $ in \emph{finitely many but nonzero}\footnote{In existing literature, usually $ U\subseteq\mathsf{attr}^a(U) $, i.e.\ $\attra{}{U}$ contains vertices from which $U$ is visited in zero steps. We exclude $U$ from $\attra{}{U}$ for a minor technical reason.} steps: 
% \improvement{\KM{If we don't use the $\textsf{cpre*}$ operator, I would remove it and only keep $\attra{}{}$. The $*$ is a bit confusing because it gives the impression that we are just applying $\cpre{}{}{}$ some number of times.} \\ \AAn{Fixed.}}
% \begin{eqnarray}
%	\cpre{\gamegraph}{U}{a,0}=&U\\
%	\cpre{\gamegraph}{U}{a,i}=&\cpre{\gamegraph}{\cpre{\gamegraph}{U}{a,i-1}}{a}\\
	%	\attr{\gamegraph}{U}{} =& \textsf{pre*}_{\gamegraph}(U) \coloneqq \cup_{k\geq 0}\pre{\gamegraph}{\pre{\gamegraph}{\ldots\pre{\gamegraph}{U}}}  \\
% 	\attra{\gamegraph}{U} =& \cup_{i\geq 1}\cpre{\gamegraph}{U}{a,i}
% \end{eqnarray}
% 
%The $ i $-\emph{step} control operator $ \textsf{cpre}^{a,i}_{\gamegraph} $ gives the set of vertices from which player $ a $ can force visiting $ U $ in $ i $-steps.
%  
% 
% 
%\KM{I do not think the definition of attractor matches with what is written in the text. This is what you need: Let $\textsf{pre}^1_{\gamegraph}(U) \coloneqq \pre{\gamegraph}{U}$ and $\textsf{pre}^{k+1}_{\gamegraph}(U) \coloneqq \pre{\gamegraph}{\textsf{pre}^k_{\gamegraph}(U)}$. Then $\attr{\gamegraph}{U}{}\coloneqq \cup_{k\geq 0} \textsf{pre}^k_{\gamegraph}(U)$.}
% 
% When clear from the context, we drop the subscript $ \gamegraph $ from these operators.


\smallskip
\noindent\textbf{Fixed-point Algorithms in the $ \mu $-calculus.} 
The $ \mu $-calculus offers a succinct representation of symbolic algorithms (i.e., algorithms manipulating sets of vertices instead of individual vertices) over a game graph $ \gamegraph $. 
% The formulas of the $ \mu $-calculus, interpreted over a 2-player game graph $ \gamegraph $, are given by the grammar %\vspace{-2mm}
% % \[ 
% $\phi\coloneqq p \mid X \mid \phi\cup\phi \mid \phi\cap\phi \mid \mathit{pre}(\phi) \mid \mu X.\phi \mid \nu X.\phi %\vspace{-1mm}
% $
% % \]
% where $ p $ ranges over subsets of $ V $, $ X $ ranges over a set of formal variables, $ pre $ ranges over the monotone set transformers in  \eqref{equ:Pres} and \eqref{equ:combindedPres}, %$ \{\textsf{pre}, \textsf{cpre}^a, \textsf{attr}^a  \} $, 
% and $ \mu $ and $ \nu $ denote, respectively, the least and the greatest fixed-point of the functional defined as $ X\mapsto \phi(X) $. 
% Since the operations $ \cup, \cap $, and the set transformers are all monotonic, the fixed-points are guaranteed to exist, due to Knaster-Tarski Theorem \cite{KnasterTarski:TraskiKnasterTheorem}.
We omit the (standard) syntax and semantics of $ \mu $-calculus formulas (see \cite{Kozen:muCalculus}) and only discuss their evaluation
%  
% \smallskip
% \noindent\textbf{Evaluating Fixed-point Algorithms.} 
% A $ \mu $-calculus formula evaluates to a set of vertices over $ \gamegraph $, and the set can be computed by induction over the structure of the formula, where the fixed-points are evaluated by iteration. 
% The reader may note that $ \textsf{pre} $ and $ \textsf{cpre} $ can be computed in time polynomial in number of vertices, and since the game graph is finite, $ \textsf{attr} $ is also computable in polynomial time. %: by applying the respective predecessor operators repeatedly until the set stabilizes. %Hence, $ \textsf{tpre} $ is computable in polynomial time as well.
% 
on an example fixed-point algorithm given by a 2-nested $ \mu $-calculus formula of the form $Z=\mu Y.~\nu X.~\phi(X,Y)$, where  $ X,Y \subseteq V$ are subsets of vertices
 and $ \mu $ and $ \nu $ denote, respectively, the least and the greatest fixed-point. $\phi$ is a formula composed from the \emph{monotone set transformers} in  \eqref{equ:Pres} and \eqref{equ:combindedPres}. % of the functional defined as $ X\mapsto \phi(X) $. 
 
 Given this formula, first, both formal variables $X$ and $Y$ are initialized. As $Y$ (resp. $X$) is preceded by $\mu$ (resp. $\nu$) it is initialized with $Y^0:=\emptyset$ (resp. $X^0:=V$). Now we first keep $Y$ at its initial value and iteratively compute $X^k=\phi(X^{k-1},Y^0) $ until $X^{k+1}=X^k$. At this point $X$ saturates, denoted by $X^\infty$. We then \enquote{copy} $X^\infty$, to $Y$, i.e., have $Y^1:=X^\infty$, reinitialize $X^0:=\emptyset$, and re-evaluate $X^k=\phi(X^{k-1},Y^1) $ with the new value of $Y$. This calculation terminates if $Y$ saturates, i.e.,  $Y^\infty=Y^{l+1}=X^l$ for some $l\geq 0$, and outputs $Z=Y^\infty$. In order to remember all intermediate values of $X$ we use $X^{l,k}$ to denote the set computed in the $k$-th iteration over $X$ during the computation of $Y^l$. I.e., $Y^l=X^{l,\infty}$.

\smallskip
\noindent\textbf{Additional Notation.} 
We will use the letters $l,m$ and $n$ exclusively to denote \emph{even} positive integers. For $a \leq b \in \mathbb{N}$, we will use the regular set symbol $[a,b]$ to denote the set of all integers between $a$ and $b$, i.e., $[a,b]:=\{a, a+1 , \ldots , b\}$; and $\ev{a}{b}$ to denote all the \emph{even} integers between $a$ and $b$. %, including $a$ or $b$ as well given that it is even,
E.g. $\ev{2}{7} = \{2, 4,  6\}$.
In addition, given an \Odd-fair parity game $\mathcal{G}^\ell$, we define the sets $C_i := \{ v \in V \mid \chi(v) = i\}$ and $\overline{C_i} := V \setminus C_i$ to ease notation. We say $\mathcal{G}^\ell$ has 
the least even upper bound $l$ if $C_l \cup C_{l-1}\neq\emptyset$ and $C_i=\emptyset$ for all $i>l$.
