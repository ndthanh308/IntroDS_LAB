
\vspace*{-0.3cm}
\section{Introduction}
\vspace{-1mm}

\emph{Parity games} are a canonical representation of $\omega$-regular two-player games over finite graphs, which arise from many core computational problems in the context of correct-by-construction synthesis of reactive software or hardware. In particular, two player games on graphs have been extensively used in the context of cyber-physical system design \cite{Tabuada2009,belta2017formal}, showing their practical importance. 
% 
% On the other hand, parity games are interesting from a theoretical point of view as they lie in the complexity class  $UP \cap coUP$, which is contained in $NP \cap coNP$~\cite{JurdzinskiUPcoUP,EmersonJutlaModelCheckingMuCalculus}. %It is widely believed that there exists a polynomial time algorithm to solve them, but non is known so far. 
% Further, parity games are polynomial-time equivalent to the model checking problem of modal $\mu-$calculus \cite{EmersonJutlaModelCheckingMuCalculus,ColinModelChecking,Walukiewicz_muCalculusMSOL}. 
% \vspace{-1mm}
% 
\emph{Fairness}, on the other hand, is a property that widely occurs in this context - both as a desired property to be enforced (e.g., requiring a synthesized scheduler to fairly serve its clients), as well as a common assumption on the behavior of other components (i.e., assuming the network to always eventually deliver a data packet). 
While \emph{strong fairness} encoded by a Streett condition necessarily incurs a high additional cost in synthesis \cite{EJ99}, it is known that the general reactivity(1) (GR(1)) fragment of linear temporal logic (LTL)~\cite{BJPPS2006} allows for efficient synthesis in the presence of very restricted fairness conditions. Due to its efficiency, it is extensively used in the context of cyber-physical system design, e.g.~\cite{WEK18,AMT2013,MR2015,KFP2007,KFP2009,SKCCB2015}. %The GR(1) fragment was particularly well received in the robotics and cyber-physical systems community and was extensively used to synthesize controllers for physical systems \cite{}.
% \vspace{-1mm}

\begin{comment}

Despite the omnipresence of fairness in synthesis problems and the success of the GR(1) fragment, not much else is known about tractable fairness constraints in synthesis. A notable exception is the recent work by Banerjee et. al.~\cite{banerjee2022fast} which shows that the sub-class of \emph{strong transition fairness assumptions}~\cite{QS83,Francez,baierbook} can be handled efficiently in synthesis. In particular, they consider Rabin games where the environment player has to obey additional strong transition fairness constraints on its vertices  -- i.e., if the environment player vertex $v$ is visited infinitely often, a particular subset of the outgoing edges (called \emph{live edges}) of $v$ has to be taken infinitely often.

Banerjee et. al.~\cite{banerjee2022fast} show that such games can be solved via a symbolic fixed-point algorithm in the $\mu$-calculus that has almost the same computational worst case complexity as the algorithm for (normal) Rabin games. %This makes strong transition fairness a promising candidate for a tractable class of fairness constraints in synthesis. 
% The \emph{main contribution} of this paper is to show that this insight caries over to \emph{Parity games under strong transition fairness assumptions}. Here, player \Odd has to obey the additional strong transition fairness constraint. We call such games \emph{\Odd-fair Parity games}.
% \todo{we repeat \emph{the main contribution} twice and say different things. Maybe we should use something else here... Or express it in some other way.}
% 
The interesting insight that Banerjee et. al.~\cite{banerjee2022fast} exploit, is that the required modification of the symbolic algorithm are very local and syntactic. In particular, Banerjee et. al. also show that this intuition carries over to symbolic fixed-point algorithms for many other games. In particular, this provides a symbolic algorithm for \Odd-fair parity games.\todo{IS : I think we can make this paragraph. An alternative is below}
\end{comment}

% \todo{AKS:changed the below paragraph, please check. Checked, looks good.}
%\begin{comment}
Despite the omnipresence of fairness in such synthesis problems and the success of the GR(1) fragment, not much else is known about tractable fairness constraints in synthesis via two player games on graphs. A notable exception is the recent work by Banerjee et.\ al.~\cite{banerjee2022fast} which considers the sub-class of \emph{strong \textbf{transition} fairness assumptions}~\cite{QS83,Francez,baierbook} which require that whenever the environment player vertex $v$ is visited infinitely often, a particular subset of the outgoing edges (called \emph{live edges}) of $v$ has to be taken infinitely often. In other words, \emph{strong \textbf{transition} fairness assumptions} limit \emph{strong fairness assumptions} to individual transitions.
% The work by Banerjee et. al.~\cite{banerjee2022fast} shows that this limitation allows to handle them efficiently in synthesis.
% While this result makes these fairness conditions theoretically interesting, they are also practically important as they are known to
Despite their limited expressive power, such restricted fairness constrains do naturally arise in resource management \cite{CAFMR13}, in abstractions of continuous-time physical processes for planning \cite{CPRT03, DTV99, PT01, DIRS18, RS14, AGR20} and controller synthesis \cite{thistle1998control, NOL17, MMSS2021}, which makes them interesting to study.
% \todo{I filled in citations and cited that work you recommended. In planning we have plenty papers, hoerver on resource management I only have Rupak's paper. And about that I have the concerns I texted you about from mattermost. should we still cite it? }
%In particular, Banerjee et. al.~\cite{banerjee2022fast} consider $\omega$-regular games where the environment player has to obey additional \emph{strong transition fairness constraints} on its vertices  -- i.e., if the environment player vertex $v$ is visited infinitely often, a particular subset of the outgoing edges (called \emph{live edges}) of $v$ has to be taken infinitely often.
 
Concretely, Banerjee et.\ al.~\cite{banerjee2022fast} show that \emph{parity games} with strong transition fairness assumptions on player \Odd\ -- which we call \emph{\Odd-fair parity games} -- can be solved via a symbolic fixed-point algorithm in the $\mu$-calculus with almost the same computational worst case complexity as the algorithm for the \enquote{normal} version of the same game. %This makes strong transition fairness a promising candidate for a tractable class of fairness constraints in synthesis. 
% In particular, this provides a nested fixed-point equation for \Odd-fair parity games. 
The existence of quasi-polynomial time solution algorithms for \Odd-fair parity games then follows as a corollary of their nested fixed-point characterization~\cite{HS21, ANP21, JMT22}. %\todo{IS : Here, I have removed the intuition behind Banerjee et al.'s construction (syntactic and local change)}
%\end{comment}
% 
%Here, player \Odd has to obey the additional strong transition fairness constraint. We call such games \emph{\Odd-fair Parity games}. While Banerjee et. al.'s work allows to compute the winning region and a winning strategy of player \Even in such games, 
Unfortunately, it is well known that symbolic fixed-point computations become cumbersome very fast for parity games, as the number of priorities in the game graph increases, leading to high computation times in practice. 
Given the known inefficiency of existing quasi-polynomial algorithms for parity games \cite{oink, Parys19}, despite their theoretical advantages, they are not viable candidates for adoption in the development of efficient solution algorithms for \Odd-fair parity games either.
%The failure of existing quasi-polynomial algorithms for parity games to provide efficiency, despite their theoretical superiority remove them from the candidacy  %fail to meet the efficiency of the mentioned exponential algorithms in practice\todo{citation}, the most celebrated one being Zielonka's algorithm.
% IS: I removed the sentence below, because I din't see how it contributes to our point
%While Banerjee et. al. \cite{banerjee2022fast} provide a tool called \texttt{FairSyn} which exploits multi-threaded executions to allow for efficient synthesis over Rabin games with fairness constrains, this multi-threading has no effect on Parity games (which could be interpreted as special Rabin games), as the nesting of their $\mu$-calculus formula only allows for a single thread in \texttt{FairSyn}. 
% 
For (normal) parity games, computational tractability can be achieved by other algorithms, such as Zielonka's algorithm \cite{Zielonka98}, tangle learning \cite{van-Dijk-tangle-learning} or strategy-improvement \cite{Schewe-strategy-improvement}, implemented in the state-of-the-art tool \texttt{oink}~\cite{oink}, with Zielonka's algorithm being widely recognized as the most prominent approach.

% \todo{IS: I changed the following paragraph, can you check? I cemmented out the previous version below}
The \emph{\textbf{main contribution}} of this paper is a Zielonka-type algorithm, referred to as \enquote{\emph{\Odd-fair Zielonka's algorithm}}, for solving \Odd-fair parity games. This novel algorithm meets the efficiency of Zielonka's algorithm while maintaining the same computational worst-case complexity (which is exponential just like the worst-case complexity of the fixed-point algorithm from \cite{banerjee2022fast}).
%Using a prototype implementation, we experimentally verify that it retains the algorithmic advantage Zielonka's algorithm holds over fixed-point algorithms for classical parity games. %exhibits similar advantages to Zielonka's algorithm over fixed-point algorithms for classical parity games,
Using a prototype implementation, we experimentally verify its efficiency, demonstrating that it matches Zielonkaâ€™s algorithm in speed, thereby highlighting its comparable performance to fixed-point algorithms for classical parity games.
\begin{comment}
The \emph{\textbf{main contribution}} of this paper is a Zielonka-type algorithm, referred to as \enquote{\emph{\Odd-fair Zielonka's algorithm}}, for solving \Odd-fair parity games %Most surprisingly, this new algorithm has the same computational worst-case complexity as Zielonka's algorithm for (normal) parity games, handling strong transition fairness almost for free. In contrast, the symbolic fixed-point algorithm by Banerjee et. al.~\cite{banerjee2022fast} requires a mild computational overhead.
which meets the efficiency of Zielonka's algorithm. While it has \emph{the same} worst case (exponential) time complexity as Zielonka's algorithm (which is close to the worst-case complexity of the fixed-point algorithm from \cite{banerjee2022fast}), it retains the algorithmic advantage Zielonka's algorithm holds over fixed-point algorithms for classical parity games, which we experimentally verify with a prototype implementation. 
\end{comment}
% While complexity-wise this algorithm is very close to the fixed-point algorithm from \cite{banerjee2022fast}, we leverage Zielonka's algorithm's fame of being recognized as the `best' generic algorithm for practical synthesis problems.
% % , whereas Banerjee et al.'s algorithm introduces a mild computational overhead. 
% % However, the reason behind the strength of Zielonka's algorithm is not its worst case time complexity as there are many parity solvers with exponential worst case time, a naive implementation of the fixed-point algorithm being one of them.
% Even though the reason behind Zielonka's algorithm's success is not completely understood, it is thought to be related to some consistence
% between a common underlying structure of practical parity games with the algorithm's simultaneous \emph{one-step-ahead} attractor calculations for both players.\todo{Irmak: may attempt to change here}
% In our \Odd-fair Zielonka's algorithm, we preserve this algorithmic structure and we experimentally verify that the algorithmic advantage Zielonka's algorithm holds over the fixed-point algorithm carries over to our new \Odd-fair variant. %\todo{Irmak: Maybe try to emphasize this does not follow trivially from the fixed-point calculation}


\begin{comment}
Intuitively, our \Odd-fair Zielonka's algorithm  mimics the syntactic change in the fixed-point algorithms advocated by Banerjee et. al. \cite{banerjee2022fast}\todo{IS: Does it still do this? Should we maybe remove this?}. Its correctness proof, however, turns out to be rather involved and very different from \cite{banerjee2022fast}. This is rooted in the difference between the computational flow of Zielonka's algorithm and the fixed-point algorithm -- while the latter computes the winning region for a single player repeatedly over the entire game graph, Zielonka's algorithm is based on one-step-ahead attractor calculations where winning regions of both players are incrementally constructed at the same time. %\todo{In this sentence I don't want to argue that all efficient algorithms adopt this symmetric technique. Because I don't know if this is the case. I would like to say 'Zielonka-like efficient algorithms' or 'many efficient algorithms' or 'efficient algorithms that are similar to Zielonka' instead. }
% 
Due to this symmetry, the correctness proof of the \Odd-fair Zielonka's algorithm requires the understanding (and formalization) of player \Odd strategies. Unfortunately, player \Odd strategies are substantially more complex than \Even strategies in such games, as they are not positional -- while player \Even strategies still are. This is due to the fact that live edges are only originating from \Odd player vertices. 
\todo{IS: Maybe we can really shorten this paragraph by only saying 'the correctness proof differs from Zielonka's original algorithm mainly due to the attractor composition being more involved due to live edges / or, from another perspective due to \Odd player not having positional strategies. }
\end{comment}

In contrast to the work by Banerjee et. al.~\cite{banerjee2022fast}, the adaptation and the correctness proof of \Odd-fair \emph{Zielonka's algorithm} requires the understanding of \Odd player strategies, while \cite{banerjee2022fast} studies the solution of such games solely from the \Even player's perspective. Unfortunately, \Odd strategies are substantially more complex than \Even strategies in such games, as they are not positional -- while player \Even strategies still are (see \cite[Thm.3.10]{banerjee2022fast}). %Positionality of \Even strategies is due to live edges only originating from \Odd vertices, and can be achieved as... . 
The \emph{\textbf{second contribution}} of this paper is therefore the formalization of \Odd player strategies in \Odd-fair parity games, via so called \emph{strategy templates}, which was unexplored prior to this work.
%We note that this is the first time \Odd player strategies are explored in these games since in~\cite{banerjee2022fast} the game is studied only from \Even player's perspective. 
We give a constructive proof for the existence of strategy templates winning for \Odd from all vertices in the winning region of \Odd.
This serves dual purposes: firstly, it enables us to prove the correctness of the \Odd-fair Zielonka's algorithm; secondly, it stands as a noteworthy contribution in its own right, augmenting our understanding of additional fairness assumptions in two-player games which are currently only unsatisfactorily adressed in various practically motivated synthesis problems.

% With this formal result, the proof for Zielonka's algorithm follows almost identically to the original proof of .... 
%The correctness proof of \Odd-fair Zielonka's algorithm requires the understanding of \Odd player strategies. Unfortunately, \Odd strategies are substantially more complex than \Even strategies in such games, as they are not positional -- while player \Even strategies still are. Positionality of \Even strategies is due to live edges only originating from \Odd vertices, and is presented in~\cite{banerjee2022fast}. The second contribution of this paper is therefore the formalization of \Odd player strategies in \Odd-fair parity games, via so called \emph{strategy templates}. We note that this is the first time \Odd player strategies are explored in these games since in~\cite{banerjee2022fast} the game is studied only from \Even player's perspective. We give a constructive proof for the existence of such strategy templates from all vertices in the winning region of \Odd.  % With this formal result, the proof for Zielonka's algorithm follows almost identically to the original proof of .... 
% We use the strategy templates as a formalization of both players' strategies, in order to prove \Odd-fair Zielonka's algorithm.
% We expect this formalization to prove useful on potential future work concerned on related fairness constrains in synthesis and think it offers valuable insight regarding the resolution of fairness in such games.
%with \Odd-fair parity games, in particular, the ones aiming at adopting other efficient algorithms to solve such games. 
%We expect that this insight also allows to modify other efficient algorithms for Parity games in a similarly straight forward manner.


% , we exploit the fixed-point formula given by Banerjee et. al. \cite{banerjee2022fast} computing the winning region of \Even. 
% We negate this formula to get a fixed-point formula computing the winning region of \Odd. We then extract progress measures from this formula, and combine the
%  \emph{minimum-ranked successor} strategy provided by the progress measures with the resolution of fairness constraints to get a subgraph, namely the strategy template, that represents a winning \Odd strategy from all nodes in its winning region.
% Strategy templates are introduced in Section 3 as well as the theorem that states the existence of \Odd-winning strategy templates from the winning region of \Odd. However, the theorem's 
% proof is postponed until Section 5,\IS{ in order not to distract the reader's attention from the extension of Zielonka's algorithm, which is the main goal of this paper.?}
% 
%  In Section 4, we give a modification of Zielonka's algorithm for \Odd-fair parity games and use the strategy templates to prove the correctness of the algorithm.
%  This algorithm do not theoretically add additional complexity to Zielonka's algorithm \IS{look at it, it should add a little.}
%  and in the last section, we show empirically that the expected computational advantage of this algorithm compared to the known fixed-point version remains significant, re-emphasizing the tractability of strong transition fairness constraints in synthesis. 




%The main contribution of this paper is the formalization of player \Odd strategies in \emph{\Odd-fair Parity games} via so-called \emph{strategy templates}. Intuitively, strategy templates do not explicitly specify \emph{how} strong transition fairness ts are resolved, but only indicate which of them need to be rendered valid by player \Odd. We then use these templates to prove that Zielonka's algorithm can indeed be used to solve \emph{\Odd-fair Parity games} under very minor modifications.
%We additionally show empirically that the expected computational advantage of this algorithm compared to the known fixed-point version remains significant, re-emphasizing the tractability of strong transition fairness constraints in synthesis. 




% The \emph{strategy templates} we construct, collect an infinite number of winning strategies player \Odd. Intuitively, strategy templates do not explicitly specify \emph{how} strong transition fairness constrains are resolved, but only indicate which of them need to be rendered valid by player \Odd. Conceptually, this shows that knowing \emph{how} a strong transition fairness constraint is obeyed by the strategy is irrelevant for winning and can be left unspecified. In this sense, our templates are related to work on permissive strategies for parity games \cite{bernet_janin_walukiewicz_2002,NEIDER2014219,10.1007/978-3-642-15643-4_10,10.1007/978-3-642-23217-6_34}. However, in all these works, a single parity objective is given, and a collection of winning strategies is constructed by a potentially repeated solution of increasingly complex games. In contrast, our strategy templates are targeted to their permissiveness being only w.r.t.\ \emph{additional} transition fairness constrains. In addition, the computation of our strategy templates does not increase the complexity of solving the game w.r.t.\ the non-constrained version.



% This modification barely affect the complexity of the algorithm.

% Furthermore, our contributions extend the understanding of winning strategies in \emph{fair Parity games}, which has the potential of being of use on its own in real world applications, for example for debugging purposes.

% In this paper, however, we extend the understanding of winning strategies in \emph{fair Parity games} by looking at the dual problem. We are interested in computing winning strategies for the system player if its own moves are restricted by additional strong transition fairness constrains.



% This remaining flexibility in strategies can be used to allow the underlying physical system to determine its satisfaction or to employ randomization over remaining strategy choices.
% We show that strategy templates can be computed by a symbolic fixed-point algorithm in the $\mu$-calculus which takes the same number of symbolic steps as the fixed-point algorithm for solving normal two-player games with the same global objective. This is surprising as other classes of fairness, e.g., strong fairness encoded by a Streett condition, are known to necessarily incur a large computational cost when additionally taken into account during synthesis.



% In this setting, one is interested in automatically synthesizing control software which restricts a given technical system such that it meets a desired behavioral specification besides external disturbances and uncertainties .



% 
% If the desired specification is given as an $\omega$-regular property, the outlined control design problem for CPS can be solved by computing a winning strategy in a two-player game on a finite graph. In contrast to classical reactive synthesis problems from computer science, the game graph for these CPS controller synthesis problems is usually determined by the dynamics of the underlying physical system, while the given specification is often naturally interpretable over predicates which correspond to subsets of vertices of this game graph. 
% 
% An example is a mobile drone navigating in a 3D environment with the specification to never collide with (possibly moving) obstacles and to always visit a target if it is active (e.g.\ blinking red). In this context, the resulting game arena consists of the discretized 3D workspace of the robot, annotated with boolean variables indicating active targets and obstacles. It is easy to see that the actuation capabilities of the controller and the dynamics of the drone determine the moves of the system player in this arena -- given a particular time discretization and a particular rotor actuation, the drone will move to a particular adjacent cell in the workspace. On the other hand, the environment player is able to choose which target is active and to move obstacles in a restricted (physically feasible) way. The system player wins the game if there exists an 
% actuation sequence for the rotors of the drone s.t.\ the drone moves from grid cell to grid cell in a way that the specification is fulfilled despite the actions of the environment. 
% % 
% Such applications, where the game graph is  given by the synthesis problem, also motivated the introduction of particular specification classes for reactive software synthesis, such as GR(1) \cite{piterman2006synthesis}, where the game graph is implicitly defined by the $\omega$-regular property given to the reactive synthesis problem.  
% % Over the years, the GR(1) fragment has been extensively applied as a useful logical fragment for reactive synthesis, especially in the cyber-physical
% % and robotics domains due to its tractability,  %\cite{kress2007s,kress2009temporal,DBLP:conf/fmcad/AlurMT13,maoz2015synthesizing,Belta17}. 
% %  In fact, there are several reactive synthesis tools which only support the GR(1) fragment for its tractability, which partially comes from the fact that the game graph is already given
% % %\cite{finucane2010ltlmop,DBLP:conf/hybrid/WongpiromsarnTOXM11,ehlers2016slugs}.
% 
% 
% Within this outlined context of controller synthesis for CPS via two-player games on graphs, it was recently shown that interesting properties for the underlying dynamical system \cite{nilsson2017augmented}, or its dynamic environment \cite{Majumdar2021} are naturally encoded as additional \emph{strong transition fairness constrains} over the induced game graph. A strong transition fairness constraint classifies a subset of edges -- called \emph{live edges} -- with the following property: if the source vertex of a live edge is seen always again, the respective live edge also needs to be taken always eventually again. We call games with additional live edges \emph{fair games}. 
% 
% Given a \emph{fair Parity game}, recent work answered the question how winning strategies can be computed for the \emph{system} player, if only the \emph{environment} player is restricted by strong transition fairness constrains \cite{banerjee2022fast}. It was shown that, in this case, the resulting winning strategies for the system player are memoryless and can be computed with the same number of symbolic steps as for \enquote{normal} games via a symbolic fixed-point algorithm in the $\mu$-calculus. This particular instance of winning in a fair game focuses on problems where the environment is known to be additionally restricted by strong transition fairness constrains which eases winning for the system player. 





% Coming back to our drone example, strategy templates allow us to compute control strategies that utilize the fact that every physical system will eventually move if actuated. I.e., given a particular grid cell and rotor actuation, we know that the drone will eventually reach a particular adjacent cell, but the exact time point when this happens depends on the exact interplay of the time and space discretization and the drone dynamics. I.e., the strategy templates we compute allow for the underlying physics to resolve \emph{how} strong transition fairness constrains are resolved. Similarly, one can employ randomization or a particular circulation over life edges to fulfill the remaining constrains. Our result shows that this information can be left unspecified during the computation of winning strategies. 

% \textbf{Related Work}

% Our strategy templates are related to work on permissive strategies for parity games \cite{bernet_janin_walukiewicz_2002,NEIDER2014219,10.1007/978-3-642-15643-4_10,10.1007/978-3-642-23217-6_34}. In all these works, a single parity objective is given, and a collection of winning strategies is constructed by a potentially repeated solution of increasingly complex games. Our strategy templates differ from these works as they are targeted to their permissiveness being only w.r.t.\ \emph{additional} transition fairness constrains. In addition, the computation of our strategy templates does not increase the complexity of solving the game w.r.t.\ the non-constrained version.

% In conclusion our contributions are four-fold:
% % 
% \begin{itemize}
%  \item We formalize strategy templates as a particular form of permissive winning strategies for player $\Odd$ in a fair parity game where only the player $\Odd$ is restricted by additional strong fairness constrains -- called $\Odd$-fair parity games.
%  \item We give a fixed-point algorithm to compute the winning region of player \Odd in  $\Odd$-fair parity games with the same complexity as the known algorithm for \enquote{normal} Parity games.
%  \item We extract strategy templates from the computation steps of this fixed-point algorithm.
%  \item We show that all player \Odd strategies compliant with such extracted strategy templates are winning in the $\Odd$-fair parity games.
%  \item \IS{Using these strategy templates, we show that Zielonka's algorithm work for \emph{fair Parity games} under minor modification.} 
% \end{itemize}


