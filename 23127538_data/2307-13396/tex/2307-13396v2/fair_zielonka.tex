
\section{Zielonka's Algorithm for \Odd-Fair Parity Games}\label{sec:zielonka}
In this section, we construct a Zielonka-like algorithm that solves \Odd-fair parity games. We call this algorithm \emph{\Odd-fair Zielonka's algorithm}. We first recall Zielonka's original algorithm in Sec.~\ref{sec:zielonka:orig} and outline the changes imposed for our new \Odd-fair version in Sec.~\ref{sec:zielonka:fair}. We then discuss the correctness of this new algorithm in Sec.~\ref{sec:zielonka:correct}.

% and preview it for player \Even and \Odd, respectively, in Alg.~\ref{algo:fair-zielonka-odd} and Alg.~\ref{algo:fair-zielonka-even}.
% The differences between Zielonka's algorithm and \Odd-fair Zielonka's algorithm very minor and will be illustrated in Sec.~\ref{}.

% are small in sight. Namely, if one slightly changes the definition of $\SafeReach^f_\Even$ in Alg.~\ref{alg:fair-zielonka} and 
% replace the $\SafeReach^f_\Odd(V, G, \mathcal{G}^\ell)$ with $G$ on the last line of procedure $\SOLVE_\Odd(l, \mathcal{G}^\ell)$, one gets Zielonka's original algorithm.
% 
% The changes in the algorithm are actually small enough not to alter its worst-case computational complexity at all. However, the proof of one recursive call  of $\SOLVE_\Odd$ becomes substantially more complex with the involvement of live edges. 
% Due to space concerns, we only try to convey the main idea of the proof here and give the full proof in the appendix (App.~\ref{app:zielonka-proof}).


%  \vspace{0.5cm}
From now on we take $\mathcal{G}^\ell = \ltup{(V, V_\Even, V_\Odd, E, \chi), E^\ell}$ to be an \Odd-fair parity game. 

\subsection{Zielonka's Original Algorithm}\label{sec:zielonka:orig}
Intuitively, Zielonka's algorithm consists of two nested recursive functions, 
$\SOLVE_{\Even}(n,\mathcal{G})$ and $\SOLVE_{\Odd}(n,\mathcal{G})$ which compute \We and \Wo in a given parity game $\mathcal{G}$ with, respectively, even or odd upper bound priority $n$. Both functions recursively call each other on a sequence of sub-games that is constructed during the run of the algorithm. 

The main difference between Zielonka's original algorithm \cite{Zielonka98} and our new \Odd-fair version in Alg.~\ref{algo:fair-zielonka-bb} %(note that they are symmetrical except for the different \textbf{return} conditions) 
is the computation of the safe reachability set, denoted by $\SafeReach^f_\bb$ within the algorithms. 
%\footnote{Note that Alg.~\ref{algo:fair-zielonka-odd} and Alg.~\ref{algo:fair-zielonka-even} are symmetrical except for the different \textbf{return} conditions. In Alg.~\ref{algo:fair-zielonka-even} the last line can be changed to `\textbf{return} $\SafeReach_\Even^f(V, X, \mathcal{G}^\ell)$' to make the algorithms symmetrical, since it is equal to $X$ in this algorithm. However, we did not want to make this visual change to emphasize that the algorithm for \Even is slightly simpler than the one for \Odd, and to make it more visible that it mimics the original Zielonka's algorithm except for the definition of safe reachability sets.}. 
Intuitively, the safe reachability set of player \bb %in a (normal) game $G$ with safety set $S\subseteq V$ and reach set $R\subseteq V$, 
is the set of vertices from which \bb has a strategy to force the game into the reach set $R\subseteq V$, while staying in the safety set $S\subseteq V$. 
% 
In a (normal) parity game $\mathcal{G}$ (without live edges), this set %the safe reachability set $\Xsr_\bb$ for player \bb 
can be computed via the single-nested fixed-point formula
\begin{equation}\label{equ:Xsr1}
 \Xsr_\bb:=\mu X~.~(S \cap (R \cup \Cpre_\bb(X))).
\end{equation}
If one interpretes Alg.~\ref{algo:fair-zielonka-bb} over (normal) parity games $\mathcal{G}$, defines $\SafeReach^f_\bb$ via \eqref{equ:Xsr1} for the respective player, and replaces $\SafeReach^f_\Odd(\cdot,X,\cdot)$ in the last return statement with $X$ (so, the algorithm returns $X$ for any $\Lambda$), one gets exactly Zielonka's algorithm for parity games. 

%\begin{algorithm}
%    \centering
%    \caption{\Odd-Fair-Zielonka's Algorithm for player \Odd}\label{algo:fair-zielonka-odd}
%    \begin{algorithmic}\fontsmall
%  \Procedure{$\SOLVE_{\Odd}$}{$n$, $\mathcal{G}^\ell$}
%    \State $X \gets V$
%    \State $Z_\Even \gets G$ \label{lineo:Z_Odd_initialize}
%    \While{$Z_\Even \neq \emptyset$}\label{lineo:while_start}
%    \State $N \gets \{ v \mid v \in X \text{ with } \chi(v) = n\}$ \label{lineo:N}
%    \State $Z \gets X \setminus \SafeReach^f_\Odd(X, N, \mathcal{G}^\ell)$ \label{lineo:Z}
%    \State $Z_\Even \gets \SOLVE_{\Even}(n-1,\mathcal{G}^\ell[Z])$ \label{lineo:Z_Odd}
%    \State $X \gets X \setminus \SafeReach^f_\Even(X, Z_\Even, \mathcal{G}^\ell)$\label{lineo:G_update}
%    \EndWhile \label{lineo:while_end}
%    \State \Return $\SafeReach_\Odd^f(V, X, \mathcal{G}^\ell)$
%    \EndProcedure
%    \end{algorithmic}
%\end{algorithm}
%\begin{algorithm}
%    \centering
%    \caption{\Odd-Fair-Zielonka's Algorithm for player \Even}
%    \label{algo:fair-zielonka-even}
%    \begin{algorithmic} \fontsmall
%    \Procedure{$\SOLVE_{\Even}$}{$n$, $\mathcal{G}^\ell$}
%    \State $X \gets V$
%    \If{$n = 0$} \Return $\emptyset$\EndIf
%    \State $Z_\Odd \gets X$ \label{line:Z_Odd_initialize}
%    \While{$Z_\Odd \neq \emptyset$}\label{line:while_start}
%    \State $N \gets \{ v \mid v \in X \text{ with } \chi(v) = n\}$ \label{line:N}
%    \State $Z \gets X \setminus \SafeReach^f_\Even(X, N, \mathcal{G}^\ell)$ \label{line:Z}
%    \State $Z_\Odd \gets \SOLVE_{\Odd}(n-1,\mathcal{G}^\ell[Z])$ \label{line:Z_Odd}
%    \State $X \gets X \setminus \SafeReach^f_\Odd(X, Z_\Odd, \mathcal{G}^\ell)$\label{line:G_update}
%    \EndWhile \label{line:while_end}
%    \State \Return $X$
%    \EndProcedure
%    \end{algorithmic}
%\end{algorithm}

%ANNE'S Version
%    \begin{algorithmic}\fontsmall
%  \Procedure{$\SOLVE_{\bb}$}{$n$, $\mathcal{G}^\ell$}
%    \State $X \gets V$
%    \State $Z_{\neg \bb} \gets G$ \label{lineo:Z_bb_initialize}
%   \While{$Z_{\neg \bb} \neq \emptyset$}\label{lineo:while_start}
%    \State $N \gets \{ v \mid v \in X \text{ with } \chi(v) = n\}$ \label{lineo:N}
%    \State $Z \gets X \setminus \SafeReach^f_\bb(X, N, \mathcal{G}^\ell)$ \label{lineo:Z}
%    \State $Z_{\neg \bb} \gets \SOLVE_{\neg \bb}(n-1,\mathcal{G}^\ell[Z])$ \label{lineo:Z_bb}
%    \State $X \gets X \setminus \SafeReach^f_{\neg \bb}(X, Z_{\neg \bb}, \mathcal{G}^\ell)$\label{lineo:G_update}
%    \EndWhile \label{lineo:while_end}
%    \State \Return $\SafeReach_\bb^f(V, X, \mathcal{G}^\ell)$
%    \EndProcedure
%    \end{algorithmic}
 %\end{minipage}
%\begin{minipage}{0.4\textwidth}
%    % Figure removed
%\end{minipage}

\vspace*{-0.5cm}

% Figure environment removed

 %  \vspace*{-0.5cm}

\subsection{The \Odd-fair Zielonka's Algorithm}\label{sec:zielonka:fair}
We are now considering an \Odd-fair parity game $\mathcal{G}^\ell$. % with live edges on \Odd player vertices.
As discussed before, the main difference of the \Odd-fair Zielonka's algorithm from the original one lies in the construction of the safe reachability sets denoted by $\SafeReach^f_\bb$ in Alg.~\ref{algo:fair-zielonka-bb}. We therefore start by discussing its computation for both players.

\smallskip
\noindent\textbf{The \Odd Player.}
The first, somehow surprising, observation is that for player \Odd in \Odd-fair parity game $\mathcal{G}^\ell$, the safe reachability set $\Xsr_\Odd$ can still be computed via \eqref{equ:Xsr1}. This is due to the fact that $R$ only needs to be visited once, and 
\Even vertices do not have live outgoing edges that might prevent player \Odd from forcing a visit to $R$. 

In addition, we can extract a \emph{partial strategy template} for player \Odd from the iterative computation of \eqref{equ:Xsr1} via a similar, but much simpler ranking argument as used in Sec.~\ref{sec:strat-templates}. Here, $\rank{v} = 1$ for $v \in R$ and for the remaining vertices, 
$\rank{v}$ is the minimum integer $j$ for which $v \in X^j:=(S \cap (R \cup \Cpre_\Odd(X^{j-1})))$ where $X^0=\emptyset$. The positional strategy of \bb is then to take the minimum ranked successor from each \Odd node. 

Another way to think about this strategy is in the form of an acyclic subgraph of $\mathcal{G}^\ell$ on $\Xsr_\Odd$, where nodes in $R$ have no outgoing edges,
and for the remaining nodes, \Odd nodes have one outgoing edge and \Even nodes have all their outgoing edges. This is because if $v \in X^j\cap \Ve$, all outgoing edges achieve positive progress towards $R$, i.e. for all $(v, w) \in E$, $w \in X^{j-1}$.
Now it is easy to see that this subgraph almost defines a strategy template, i.e., on $\Xsr_\Odd\setminus R$, \Even nodes have all their outgoing edges in the subgraph, no \Odd node lies on a cycle and all of them have one outgoing edge. However, vertices in $R$ are dead-ends. We therefore call the strategy template induced by  \eqref{equ:Xsr1} \emph{partial} and denote it by $sr$. %\AKS{I think we need to properly formalize this template to use it in the next section}


\smallskip
\noindent\textbf{The \Even Player.}
It follows from the results of Banerjee et. al.~\cite{banerjee2022fast} that the safe reachability set $\Xsr_\Even$ of player \Even in \Odd-fair parity games requires the 2-nested fixed-point formula $\nu Y.\mu X.S \cap (R \cup \Apre(Y,X))$, which (via the operators defined in Sec.~\ref{sec:assump:prelim}) equals
%  
\begin{equation}\label{equ:Xsr2}
 \Xsr_\Even: =~\nu Y~.~\mu X~.~S \cap (R \cup (\Cpre_\Even(X) \cup (\Lpre^{\exists}(X) \cap \Pre_\Odd^{\forall}(Y))))
\end{equation}%=&~\nu Y~.~\mu X~.~S \cap (R \cup \Apre(Y,X))\\
% \vspace{-0.1cm}
%with all predecessor operators defined in Sec.~\ref{sec:assump:prelim}.
% We denote this formula by $\SafeReach^l(S, R, \mathcal{G}^\ell)$. 
Intuitively, the necessity of a 2-nested formula arises from the following lack of information: we do not know in advance, which \Odd nodes need to lie on a cycle on a strategy template required for \Odd to win. If any positional strategy that lets \Odd win (i.e., to avoid $R$ or leave $S$) from a $v\in V^\ell$
requires $v$ to lie on a cycle, then \Odd has to take $v$'s live outgoing edges as well, and thus, it can enter $\Xsr_\Even$ and lose.
The calculation of \eqref{equ:Xsr2} starts with $Y^0 := V$, resulting in $\Pre_\Odd^{\forall}(V)=V$, hence
% 
% \vspace{-0.5cm}
\begin{equation}\label{equ:Xsr2a}
 Y^{1}:=\mu X~.~S\cap (R \cup \Cpre_\Even(X) \cup \Lpre^\exists(X)).
\end{equation}
% 
% \vspace{-0.1cm}
Due to the disappearence of $\Pre^\forall_\Odd(Y)$ in this iteration, intuitively all $v \in V^\ell$ are treated as if they do not have any positional winning \Odd strategy on them, so as if all \Odd strategies have to take all the live edges in the game. 
%This is due to the triviality of $\Pre^\forall_\Odd(Y) = V$ in this iteration. 
%When  $\Pre^\forall_\Odd(Y)$ vanishes from the equation, 
$Y^1$ includes any \Odd vertex that progresses towards $R$ while staying in $S$ with using either all its edges (due to $\Cpre_\Even(X)$) or through one live edge (due to $\Lpre^\exists(X)$). Thus, any vertex that manages to stay in $V \setminus Y^1$ does so due to being won by \Odd even if \Even could force all the live outgoing edges to be taken. 
Note that due to the monotonicity of fixed-point operators, for all $j$, $V \setminus Y^1 \subseteq V \setminus Y^j$.

Throughout the calculation, $ V \setminus Y^j$ keeps track of the nodes that have managed to escape $S$ or avoid $R$ in the previous iteration, so are `already' won by \Odd in the first $j$ iterations. The inner fixed-point calculation in the $(j+1)^{th}$ iteration treats $V \setminus Y^j$ as a subset of \Odd's winning region and it deems any node that can be forced by \Odd to reach $V \setminus Y^j$, lost by \Even.
When the algorithm saturates, $Y^\infty$ contains only those \Odd nodes that cannot be forced by \Odd to reach $V \setminus Y^\infty$, i.e., are won by \Even. Here it is important to observe that, $V \setminus Y^\infty$ contains some \Odd nodes that are not $V \setminus Y^1$. Since they are in $Y^1$, these nodes inductively %\todo{IS:iteratively? any other word?} 
reach \Even winning vertices through live edges. %(or, reach some vertices that have this property\IS{how to put this?}). 
This reveals that, all nodes in $V \setminus Y^j$ but not in $V \setminus Y^1$ win due to a positional \Odd strategy that reaches $V \setminus Y^{j-1}$. 
Iteratively, this reveals that all such nodes have positional \Odd strategies that make them reach $V \setminus Y^1$.%, and this is the key observation we will explot in the next section. 

%The key observation from the previous discussion is the following: if $v$ is won by \Odd even under the assumption that all the live edges in the game have to be taken by \Odd (which is an assumption that increases \Even's power), then $v$, or any node that can be forced by \Odd to reach $v$, is won by \Odd. Also, note that these nodes are exactly the nodes in $V \setminus Y^1$ as explained above.
The above alternative interpretation of the computation of $\Xsr_\Even$ in \eqref{equ:Xsr2} is the key insight that we utilize to define our new \Odd-fair Zielonka's algorithm, as discussed next.
% This is the key observation we will utilize within our new \Odd-fair Zielonka's algorithm as discussed next. %, and show that it carries over from \Odd-fair safe-reachability games to \Odd-fair parity games.
% \todo{IS: maybe we can get rid of the 'and show that it carries over...' part.}
%We utilize this key observation within our new \Odd-fair Zielonka's algorithm as discussed next, and thereby show that it carries over from \Odd-fair safe-reachability games to \Odd-fair parity games.

%As Banerjee et. al.~\cite{banerjee2022fast} have shown that this intuition carries over from safe-reachability games to different $\omega$-regular games under strong transition fairness, including Rabin and Parity games, we can utilize this observation for our \Odd-fair Zielonka's algorithm as follows.

\smallskip
\noindent\textbf{The \Odd-fair Zielonka's Algorithm.} %\todo{IS:I made some changes starting from here - until the end of this subsection}
% It remains to formally define the safe-reachability procedures used in Alg.~\ref{algo:fair-zielonka-odd} and Alg.~\ref{algo:fair-zielonka-even}. 
% 
Following up on the previous discussion, we use the following insight within the construction of the \Odd-fair Zielonka's algorithm. We assume the existence of a core subset $\Wo' \subseteq \Wo$ %\todo{this was in the text, I am not sure if it should be..: (actually corresponding to $ V \setminus Y^j$ in the above argumentation for \Odd-fair safe-reachability games)} 
that player \Odd can force all nodes in $\Wo$ %(i.e., the winning region of \Odd in the \Odd-fair parity game $\mathcal{G}^\ell$) 
to, that is winning for \Odd even under the assumption that \Even can force all the live edges in the game to be taken. %\footnote{We note that this is a similar insight used in the proof of winning strategy templates discussed in Sec.~\ref{sec:strat-templates}.}.  
% 
% We exploit this observation as follows: 
% \emph{Any $v \in \Wo$ can be made by \Odd to reach a core subset $\Wo' \subseteq \Wo$, that is won by \Odd even if all $v \in V^\ell \cap \Wo'$ have to take all their live edges.} 
% In $\SafeReach^l(S, R, \mathcal{G}^\ell)$, the first iteration of the $Y$ variable calculates this $\Wo'$. 
Since Zielonka's algorithm solves parity games by a sequence of nested safe-reachability calculations for alternating players, we apply the following trick:
Instead of computing $\Xsr_\Even$ via \eqref{equ:Xsr2} in each recursive call of Alg.~\ref{algo:fair-zielonka-bb}, we only compute $Y^1$ via \eqref{equ:Xsr2a} and use it as an \emph{overapproximation} of $\Xsr_\Even$ (which is indeed the case due to the monotonicity of \eqref{equ:Xsr2} in $Y$). 
That is, while we take the \Odd safe reachability set $\SafeReach^f_\Odd$ as the original (linear) \Odd safe reachability computation known for these games (given in~\eqref{equ:Xsr1}), we do not take \Even safe reachability formula $\SafeReach^f_\Even$ to be the (quadratic) \Even safe reachability computation known for these games (given in~\eqref{equ:Xsr2}),
but we instead take it as its (linear) subformula given in~\eqref{equ:Xsr2a} and arrive at an overapproximation of the \Even safe reachability region at the end of each $\SafeReach^f_\Even$ calculation. We finalize the recursive call $\SOLVE_\Odd$ by an extra call of $\SafeReach^f_\Odd$ applied to the (thus) underapproximated \Odd winning region in the sub-game, therefore expanding the returned \Odd winning region of the sub-game.  

By this, it turns out that the recursive call of $\SOLVE_\Odd(n, \mathcal{G}^\ell)$ actually computes $\Wo'$ as the set $X$ and we ensure that $\Wo$ is returned by the additional (linear) computation of $\SafeReach^f_\Odd$ over $X$ in the last return statement of Alg.~\ref{algo:fair-zielonka-bb}.
% 
This instantiation of the safe-reachability computations is formalized next.

\begin{definition}\label{def:safereach}
 Given an \Odd-fair parity game $\mathcal{G}^\ell=\ltup{(V, V_\Even, V_\Odd, E, \chi), E^\ell}$ the safe-reachability procedures $\SafeReach^f_\Odd(S, R, \mathcal{G}^\ell)$ and $\SafeReach^f_\Even(S, R, \mathcal{G}^\ell)$ in Alg.~\ref{algo:fair-zielonka-bb} denote the iterative fixed-point computations in \eqref{equ:Xsr1} for \Odd and \eqref{equ:Xsr2a} for \Even.
\end{definition}
% 
% \noindent\textbf{The reason behind the computational advantage of Alg~\ref{algo:fair-zielonka-bb}.}\todo{One of the reviewers suggested that we highlight this part, since we have this part as the 'main achievement' of this technique. I think maybe we can add a small title like this one, or maybe some other title like just "computational advantage", or "reason of efficiency" or "computational succinctness" or something like this. }

\subsection{Complexity of the \Odd-fair Zielonka's Algorithm}\label{sec:zielonka:complexity}
The safe-reachability computations defined in Def.~\ref{def:safereach} have the same complexity as their computations via \eqref{equ:Xsr1} in Zielonka's original algorithm. The only difference is in the number of calculated $\Pre$ operations: while $\SafeReach_\Even$ from Zielonka's original algorithm~\eqref{equ:Xsr1} require the calculation of only one $\Pre$ operator, $\SafeReach_\Even^f$ from~\eqref{equ:Xsr2a} requires the calculation of 2 $\Pre$ operators. The additional final call of $\SafeReach^f_\Odd$ in $\SOLVE_\Odd$ procedure also has linear complexity and requires one $\Pre$ calculation. 
Therefore, not only the worst-case time complexity of Alg.~\ref{algo:fair-zielonka-bb} is equivalent to that of Zielonka's original algorithm (which would be the case even if we used the quadratic safe reachability formula from~\eqref{equ:Xsr2} for \Even since the overall complexity of the algorithm is exponential) but we create almost no additional computational overhead in the algorithm by introducing the fairness assumptions.

We further remark that Alg.~\ref{algo:fair-zielonka-bb} is not a straight-forward interpretation of the nested fixed-point in~\eqref{eq:fp-odd}, and its negation (see (14) in App. A.1 of~\cite{extended}) in the form of Zielonka's algorithm. 
\begin{comment}
%Such a straight forward approach would increase the number of $\Pre$ calls in each recursive step polynomially in the number of priorities, whereas in Alg.~\ref{algo:fair-zielonka-bb} we have at most 2 times (plus 1 extra for $\SOLVE_\Odd$) as many $\Pre$ calls compared to Zielonka's original algorithm.
Such a conversion would require the nested fixed-point formula to be turned into a fixed-point parity game \cite{}, which would basically be equivalent to the gadget-enhanced parity game from \cite{} and the state space of the resulting parity game would be polynomially increased with respect to the state space of the \Odd-fair parity game. More precisely, an efficient fixed-point parity game would have $\frac{3}{2}\cdot l \cdot|V|$-many states where $l$ is the number of priorities and $|V|$ is the number of states of the original \Odd-fair parity game, while keeping the same number of priorities. This approach would not only require a precomputation, but would also require a polynomial increase in the total number of $\Pre$ calculations performed by the resulting Zielonka's algorithm. However, in Alg.~\ref{algo:fair-zielonka-bb} we require at most 2 times (plus 1 extra for $\SOLVE_\Odd$) as many $\Pre$ calls compared to Zielonka's original algorithm at each recursive call.
\end{comment}
%\begin{comment}
%Such a conversion would be non-trivial due to $\Apre$ and $\Npre$ taking 2 different variables from 2 different iterations of the fixed-point calculation. 
Firstly, such a straightforward approach is non-trivial due to $\Apre$ and $\Npre$ operators taking two variables from two different iterations of the fixed-point calculation. 
Furthermore, 
at each \Even safe-reachability call of Alg.~\ref{algo:fair-zielonka-bb}, as mentioned we compute 2 $\Pre$ operators (equation~\ref{equ:Xsr2a}), whereas in each such corresponding step in the fixed-point iteration, we would have to compute 3 $\Pre$ operators due to the expansion of $\Apre$~\eqref{equ:apre} and $\Npre$~\eqref{equ:npre}.
%\end{comment}

%This is slightly surprising given that even the algorithm by Banerjee et. al. in \cite{banerjee2022fast}  %introduces a small overhead from $|V|^n$ (the complexity of \enquote{normal} parity fixed-point) to $|V|^{n+1}$ (the complexity of \Odd-fair parity fixed-point) where $n$ is the number of colors.
%\AKS{we should give the actual complexity here.}
% 
% As in the original Zielonka's algorithm, the Alg.~\ref{algo:fair-zielonka-odd} and Alg.~\ref{algo:fair-zielonka-even}
% 
% We first recall that the determinacy of \Odd-fair parity games follows from the results of Banerjee et. al.~\cite{banerjee2022fast}. 
% 
% We use two recursive calls to calculate \We and \Wo in an \Odd-fair parity game.
% $\SOLVE_\Odd(n,\mathcal{G}^\ell)$ takes an \Odd-fair parity game $\mathcal{G}^\ell$ with an \emph{odd} upper bound $n$ on the priorities of $V$ and returns $\Wo$ of $\mathcal{G}^\ell$.
% $\SOLVE_\Even(n,\mathcal{G}^\ell)$ returns \We for a $\mathcal{G}^\ell$ and an \emph{even} priority upper bound $n$ on $V$. Two calls recursively call each other, from a subgame $\mathcal{G}^\ell[X]$ that has priorities at most $ n - 1$.
% Since in the base cases $n = 0$ and $G = \emptyset$, the calls correctly return $\emptyset$, in order to prove the correctness of the algorithm, it is enough to 
% prove the correctness of each procedure, assuming the correctness of the other. 

It remains to show that \Odd-fair Zielonka's algorithm solves \Odd-fair parity games. 


%This captures the assumption that 'all the live edges in the game have to be taken by \Odd'. The correctness of the new Zielonka's algorithm then relies on the fact that 

% $\SafeReach_\Even(S, R, \mathcal{G})$ in Zielonka's original algorithm, we use a formula $\SafeReach^f_\Even(S, R, \mathcal{G}^\ell) = \mu X. p_s \wedge (p_r \vee \Cpre_\Even(X) \vee \Lpre^\exists(X))$ that corresponds to the first iteration of $\SafeReach^l_\Even(S, R, \mathcal{G}^\ell)$.
% This calculation does not give us the \Even safe reachability set, but an over-approximation of it. We leave $\SafeReach_\Odd$ calculations the same by assigning $\SafeReach^f_\Odd(S, R, \mathcal{G}^\ell) = \SafeReach_\Odd(S,R,\mathcal{G})$.





% By using $\SafeReach^f_\Even(S, R, \mathcal{G})$, at each recursive call of $\SOLVE_\Odd(n, \mathcal{G}^\ell)$ we make the algorithm calculate \Wo' as $G$. Then by taking $\SafeReach^f_\Odd(V, \Wo', \mathcal{G}^\ell)$ we reach \Wo.

%In other words, we can use only the calculation from the first iteration of $\SafeReach^l(S, R, \mathcal{G}^\ell)$, i.e. $\mu X. p_s \wedge (p_r \vee \Cpre_\Even(X) \vee \Lpre^\exists(X))$ as the safe reachability set for \Even.
%This calculation will not give us a precise set, but an over approximation of the \Even winning region everytime we use it. 
%However, 


%safe reachability set computation for player \Even, called $ \SafeReach_\Even(S, R, \mathcal{G}^\ell)$. The computation of the safe reachability set for player $\Odd$ is the same as the computation of it in "normal" parity games. However, 
%the safe reachability set computation for \Even player is different. For this computation, we use the 2-nested fixed-point formula from \cite{banerjee2022fast}.
%\begin{align}
%    & \SafeReach^f_\Even(S, R, \mathcal{G}^\ell) := \mu X. (p_s \wedge (p_r \vee \Cpre_\Odd(X) \vee \Lpre^\exists(X))) \label{eq:safereacheven}\\
%    & \SafeReach^f_\Odd(S, R, \mathcal{G}^\ell) := \mu X. (p_s \wedge (p_r \vee \Cpre_\Odd(X))) \notag
%\end{align}
%\vspace{-0.2cm}

%\vspace*{-0.3cm}

\input{SUCCINCTfair-zielonka-5.3.tex}
