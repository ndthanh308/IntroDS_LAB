
\begin{document}
%
\section{Proof of Type Progress}
%
\input{tex/figs/types/syntax.tex}
\input{tex/figs/types/rule_formation.tex}
%
\input{tex/figs/configs/rule_iso.tex}
%
\subsubsection*{Summary}
Types constructed using the syntax of~\cref{eq:types_syntax} are judged against the rules given in~\cref{fig:types_rule}.
Types are well-formed against a valuation \ValClocks*\ as in~\cref{def:types_wf}.

A simple/isolated configuration \CIso*\ is well-formed following~\cref{def:configs_wf}.
A social configuration \CSoc*\ extends an isolated configuration with a queue \Queue*\ that stores messages \Msg*.

Configurations may transition as specified in~\cref{fig:typesemantics} using any of the actions described in~\cref{eq:type_labels}.
\CIso*\ may be written as \VIso*, and \CSoc*\ as \VSoc*.
\begin{minieq}\label{eq:type_labels} \ProgAction::=\TypComm\Msg
    \mid\,\ValTime
    \mid\SiltAction
    %
    \qquad
    %
    \Msg::=\DefMsgType
    %
    \qquad \TypComm ::=!\mid?
    %
\end{minieq}
%
A configuration is said to be live if there is an amount of time that can be waited for an action to be viable to be taken.
A configuration that is live can be described by a future enabled action \FutureEn*, where \TypComm*\ can be used to specify which kind of actions are viable in the future.

Systems are composed of two social configurations in parallel \CSys*.
Two social configurations are compatible \Compat*\ if either
\begin{inline}*|
    \item one has a message in their queue that is able to be received at the current moment which results in a new compatible system configuration
    \item both configurations have matching clock valuations, empty queues, and dual types
\end{inline}

\input{tex/defs/types/duality.tex}
%
\input{tex/defs/types/well_formed.tex}
%
\input{tex/defs/configs/iso/future_en.tex}
%
\input{tex/defs/configs/iso/live.tex}
%
\input{tex/defs/configs/iso/well_formed.tex}
%
\input{tex/defs/configs/sys/compat.tex}
%
\input{tex/defs/types/progress.tex}
\input{tex/proofs/progress/thm.tex}

\subsubsection*{Overview of proof}
%
The proof culminates in~\cref{lem:configs_sys_progress} which states that the progress of a system in its initial state \Parl*{\CSoc[\ValClocks_0];:{\emptyset},\CSoc[\ValClocks_0];[\Dual]:{\emptyset}}\ is guaranteed to \emph{enjoy progress} (see~\cref{def:types_progress}).
%
The initial system configuration is well-formed by~\cref{def:types_wf} and compatible by~\cref{def:configs_compat}.



\Cref{lem:configs_trans_compat_wf_preserved} combines~\cref{lem:configs_trans_compat_preserved,lem:cfgs_trans_wf_preserved} proving that compatibility and well-formedness are preserved across an arbitrary number of transitions.
%
\Cref{lem:configs_compat_wf_fe} proves that system that is compatible and well-formed behaves as defined in~\cref{def:types_progress} (extending the notion of liveness of single configurations of~\cref{def:configs_live} proven in~\cref{lem:wf_then_live}).
%
\Cref{lem:wf_then_live} proves that a well-formed configuration is live, and~\cref{lem:init_wf_then_live} proves that initial configurations are well-formed and live inherently.



\Cref{lem:sys_compat_time_trans} proves that all queues must be empty when time passes over the whole system \Trans*{\VSys}:{\ValTime}\ (or $\ValTime=0$ when a queue is non-empty).
%
\Cref{lem:configs_iso_trans,lem:configs_soc_trans} are similar to the "inversion lemma" of~\cite[Lemma~30, Page~51]{Bocchi2019} and highlight how configurations relate before and after a transitions (useful when reasoning how a resulting configuration is live).

Currently omitted from the proof are~\cite[Lemmas~1~to~5, Pages~31~to~34]{Bocchi2019} which regard recursive types. They clarify the meaning of typing judgements, provide detail on how recursive types are evaluated, and defined "capture avoiding" for recursive variables (stating that all types within an unfolding are "capture avoiding" if they do not correspond to the recursive call).


\subsubsection*{Remaining work}
I need to finish the recursive cases of~\cref{lem:wf_then_live,lem:cfgs_trans_wf_preserved}.
I need to decide if I will include the current missing lemmas (\cite[Lemmas~1~to~5, Pages~31~to~34]{Bocchi2019}), or if it is enough to do a co-inductive proof ( i think ).

\input{tex/proofs/progress/progress.tex}

\newpage
\section{Proof of Subject Reduction}
%
\input{tex/figs/processes/calculus.tex}
\input{tex/figs/processes/typing.tex}
%
\input{tex/figs/processes/reduction.tex}
%
\input{tex/figs/processes/func/time_passing.tex}
%
\input{tex/figs/processes/rule_typing.tex}
%
% \subsubsection*{Summary}

\subsubsection*{Overview of proof}
In~\cite{Bocchi2019} the subject reduction proof has the following structure
\begin{enumerate}
    \item implications of a well-typed process
    \item typing processes
    \item typing environment variables
    \item typing messages received processes
    \item delaying processes
    \item delaying sessions
    \item typing delayed sessions against delayed sessions
    \item any reduction of a well-typed process is also well-typed
\end{enumerate}
The proof then continues by proving that well-typed processes never reduces to a failed state, and that fail-free processes are always well-typed.
Processes are proven to always be fully-reducible using the \emph{untimed calculus}. Processes without time are always able to perform their next action, and are live.

% %
% \input{tex/defs/processes/domain_clocks.tex}
% \input{tex/defs/processes/t_reading.tex}
% %
% \input{tex/defs/processes/free_queues.tex}
% \input{tex/defs/processes/well_formed.tex}
% \input{tex/proofs/reduction/thm.tex}
% %
% \input{tex/defs/processes/session/balanced.tex}
% \input{tex/defs/processes/session/fully_balanced.tex}
% \input{tex/defs/processes/session/free_queues.tex}
% \input{tex/defs/processes/session/delayable.tex}
% \input{tex/defs/processes/session/reduction.tex}

% \subsubsection{*Overview of proof}


% \input{tex/proofs/reduction/reduction.tex}

% \newpage
% \section*{Question/Feedback LIST}
% \begin{itemize}
%     %
%     \item updated~\cref{fig:prc_func_time} to not remove "after Q" from infinite receptions as then it cannot be typed, and added \PFuncTime*\ to set(x).P
%           %
%     \item is there anywhere "nice" to explain that \LblPrcRedDelay*\ applies \PFuncTime* ?
%           %
%     \item tweaked~\cref{lem:configs_wf_timestep_fe} to reflect mixed-choice and the new \LblCfgSocTime*
%           %
%     \item rule \LblPrcTypRes*\ depends on \emph{compatibility}, which has been moved to the appendix.
%     \item include \LblPrcRedIfT*\ in reduction rules? how do i write that true is dependant on a clock existing to satisfy a \Const*?
%           %
% \end{itemize}

% \section*{Todo LIST}
% \begin{itemize}
%     %
%     \item update proof of progress
%           \begin{itemize}
%               \item recursive cases
%               \item update for new \LblCfgSocTime*\ rule for social configuration transitions
%           \end{itemize}
%           %
%     \item proof of subject reduction
%           \begin{itemize}
%               \item avoid fail-free by proving if-then-else and recv-after always hold, similarly as proof of progress
%           \end{itemize}
%           %
%     \item make sure \LblTypChoice*\ is correct
%     \item change future-enabled definition \& symbol to be directionless
%     \item move live definition to appendix
%     \item change semantic rules to be symmetric (not $i\neq j\{1,2\}$)
%     \item change notes about configuration notations to be paragraph
%     \item define configuration transitions
%     \item move compatibility to proof
%     \item make Andy new packaged-proof-paper with fixes and updates
%     \item update \ITypeAct*\ used in examples to better reflect \IMsgType*
%           %
% \end{itemize}


% % \pagebreak
% \appendix
% \section{Auxiliary Functions}
% % \FigPrcFuncTime*
% \input{tex/figs/processes/func/wait.tex}
% \input{tex/figs/processes/func/nonempty.tex}

\bibliographystyle{IEEEtran.bst}
\bibliography{bib_library.bib,time.bib}

\end{document}

\endinput