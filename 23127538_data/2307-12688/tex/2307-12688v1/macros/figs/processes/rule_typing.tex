
% ~ branch
\NewDocumentCommand{\PTypRuleBranch}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypBranch]{% * judgement
%
% \TmpPrcJudge2{\PCalcRecv}3{2{2{2{\TypInteract[j][j]}}}}
\VarEnv%
~\Entails~%
\PCalc{\On{p}\Recv{l}[\pl]_{i}[i]~\After<{n}:{\Qrc}}%
~\PrcTyped~%
\SesEnv,%
~\PrcP:\CIso;[\TypInteract[j][j]]%
%
}{% * premise
%
\begin{array}[t]{c}
    %
    \Delta \textit{ not $n$-reading}
    \\[0.5ex]
% \begin{array}[t]{l}
    \forall j\in\SetJ:
    \ValClocks\models\Const_j
    ~\Implies~
    % \\%
    \begin{array}[t]{l}
        (1)~\TypComm_j=\TypRecv
        \qquad\qquad (2)~\forall  t \leq n: \ValClocks+\ValTime\models\Const_j
        \\[0.5ex] (3)~\exists i\in\SetI:{\VarEnv%
    ~\Entails~%
    \PCalc{\On{p}\Recv*<{n}{l}[\pl]_{i}}%
    ~\PrcTyped~%
    \SesEnv,%
    ~\PrcP:\CIso;[\TypInteract|_[j][j]]}%
    \end{array}
    %
% \end{array}
    \\[0.5ex]
    % \CIso+{+n};[\simplechoice_{j}[j]]\isWF%
    {\mathtt{AE}(p,n)%{\exists t>n,\exists \Const_j:\ValClocks+t\models\Past_j}
    ~\Implies~
    {\VarEnv+n%
    ~\Entails~%
    \Qrc%
    ~\PrcTyped~%
    \SesEnv+n,%
    ~\PrcP:\CIso+{+n};[\TypInteract[j][j]]}}%
    %
\end{array}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

\NewDocumentCommand{\PTypRuleVRecv}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypVRecv]{% * judgement
%
\VarEnv%
~\Entails~%
\PCalc{\On{p}\Recv*<{n}{l}[\pl]}%
~\PrcTyped~%
\SesEnv,%
~\PrcP:\CIso;[\IType?{\IMsgType}[\Const][\RSet].{\TypeS}]%
%
}{% * premise
%
\begin{array}[t]{c}
    \DataType \textit{ base type }
    %
    \\
    %
    \forall t \leq n:
    {\ValClocks+\ValTime\models\Const}
    ~\land~
    %
    {\VarEnv+\ValTime,~{\pl:\DataType}%
    ~\Entails~%
    \Prc%
    ~\PrcTyped~%
    \SesEnv+\ValTime,%
    ~\PrcP:\CIso+{+\ValTime\ReSet[]};}%
\end{array}
%
%
}
\IfBooleanT{#1}{$}% mm wrap
}

\NewDocumentCommand{\PTypRuleDRecv}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypDRecv]{% * judgement
%
\VarEnv%
~\Entails~%
\PCalc{\On{p}\Recv*<{n}{l}[q]}%
~\PrcTyped~%
\SesEnv,%
~\PrcP:\CIso;[\IType?{\IMsgType}[\Const][\RSet].{\TypeS}]%
%
}{% * premise
%
\begin{array}[t]{c}
    \DataType = \CIso[\Const]'
    ~\land~%
    \ValClocks'\models\Const'
    %
    \\
    %
    \forall t \leq n:
    {\ValClocks+\ValTime\models\Const}
    ~\land~
    %
    {\VarEnv+\ValTime%
    ~\Entails~%
    \Prc%
    ~\PrcTyped~%
    \SesEnv+\ValTime,%
    ~\PrcP:\CIso+{+\ValTime\ReSet[]};,
    ~q:\CIso'}%
\end{array}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ VSend
\NewDocumentCommand{\PTypRuleVSend}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypVSend]{% * judgement
%
% \TmpPrcJudge2{\PCalcSend}3{2{2{2{\TypInteract[i][i]}}}}
\VarEnv%
~\Entails~%
\PCalc{\On{p}\Send{l}[\pl]}%
~\PrcTyped~%
\SesEnv,%
~\PrcP:\CIso;[\TypInteract[i][i]]%
%
}{% * premise
%
\begin{array}[t]{l}
    %
    \exists i\in I: 
    \TypComm_i=\TypSend
    ~\land~
    \ValClocks\models\Const_i
    ~\land~
    \PrcLabel=\MsgLabel_i
    ~\land~
    \DataType_i \textit{ base type }
    ~\land~
    {\VarEnv~\Entails~{\pl:\DataType_i}}
    \\[0.5ex]\qquad\qquad
    ~\land~
    {\VarEnv%
    ~\Entails~%
    \Prc%
    ~\PrcTyped~%
    \SesEnv,%
    ~\PrcP:\CIso+{\ReSet[]_i};[\TypeS_i]}%
%
%     \forall i\in\SetI: 
%     %
%     \DataType_i\neq\TmpTypBTDelegate''
%     ~\land~
%     \ValClocks\models\Const_i
%     %
%     ~\implies~
%     %
%     \TypComm_i=\TypSend
%     % ~\land~
%     % i \in K
%     %
%     \\[0.5ex]\qquad\qquad
%     %
%     % \exists k\in K:
%     %
% ~\land~
%     \PrcLabel=\MsgLabel_j
%     ~\land~
%     {\VarEnv~\Entails~{\pl:\DataType_j}}
%     ~\land~
%     {\VarEnv%
%     ~\Entails~%
%     \Prc%
%     ~\PrcTyped~%
%     \SesEnv,%
%     ~\PrcP:\CIso+{\ReSet[]_j};[\TypeS_j]}%
    % \TmpPrcJudge2{\Prc}3{2{2{1{\Resets1{\ValClocks}2{\RSet_k}}2{\TypeS_k}}}}
    %
\end{array}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ DSend
\NewDocumentCommand{\PTypRuleDSend}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypDSend]{% * judgement
%
% \VarEnv
% ~\Entails~
% \PCalcSend2{\PrcMsg}
% ~\PrcTyped~
% \SesEnv,
% ~\PSesRole1{\PrcP}2{2{\TypInteract[i][i]}},
% ~\PSesRole1{\PrcMsg}2{1{\ValClocks'}2{\TypeS'}}
\VarEnv%
~\Entails~%
\PCalc{\On{p}\Send{l}[\pl]}%
~\PrcTyped~%
\SesEnv,%
~\PrcP:\CIso;[\TypInteract[i][i]],%
~\pl:\CIso'%
%
}{% * premise
%
\begin{array}[t]{l}
    %
    \exists i\in I: 
    \TypComm_i=\TypSend
    ~\land~
    \ValClocks\models\Const_i
    ~\land~
    \PrcLabel=\MsgLabel_i
    ~\land~
    \DataType_i= \CIso[\Const]'
    ~\land~
    \ValClocks'\models\Const'
    \\[0.5ex]\qquad\qquad
    ~\land~
    {\VarEnv%
    ~\Entails~%
    \Prc%
    ~\PrcTyped~%
    \SesEnv,%
    ~\PrcP:\CIso+{\ReSet[]_i};[\TypeS_i]}%
%
%
%     \forall i\in\SetI:
%     %
%     \DataType_i=\TmpTypBTDelegate''
%     ~\land~
%     \ValClocks\models\Const_i
%     %
%     ~\implies~
%     %
%     \TypComm_i=\TypSend
%     % ~\land~
%     % i \in K
%     %
%     \\[0.5ex]\qquad\qquad
%     %
%     % \exists k\in K:
%     ~\land~
%     %
%     \PrcLabel=\MsgLabel_j
%     ~\land~
%     \ValClocks'\models\Const'
% ~\land~
%     {\VarEnv%
%     ~\Entails~%
%     \Prc%
%     ~\PrcTyped~%
%     \SesEnv,%
%     ~\PrcP:\CIso+{\ReSet[]_j};[\TypeS_j]}%
    % \TmpPrcJudge2{\Prc}3{2{2{1{\Resets1{\ValClocks}2{\RSet_k}}2{\TypeS_k}}}}
    %
\end{array}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ IfTrue
\NewDocumentCommand{\PTypRuleIfTrue}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcTypIfTrue]{% * judgement
        %
        \VarEnv%
        ~\Entails~%
        \PCalcIf%
        ~\PrcTyped~%
        \SesEnv%
        %
    }{% * premise
        %
        \VarEnv\models\Const%
        &
        \VarEnv%
        ~\Entails~%
        \Prc%
        ~\PrcTyped~%
        \SesEnv%
        %
    }
    \IfBooleanT{#1}{$}% mm wrap
}

% ~ IfFalse
\NewDocumentCommand{\PTypRuleIfFalse}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcTypIfTrue]{% * judgement
        %
        \VarEnv%
        ~\Entails~%
        \PCalcIf%
        ~\PrcTyped~%
        \SesEnv%
        %
    }{% * premise
        %
       \neg \VarEnv\models\Const%
        &
        \VarEnv%
        ~\Entails~%
        \Qrc%
        ~\PrcTyped~%
        \SesEnv%
        %
    }
    \IfBooleanT{#1}{$}% mm wrap
}

% ~ Timer
\NewDocumentCommand{\PTypRuleTimer}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypTimer]{% * judgement
%
\TmpPrcJudge2{\PCalcSetTimer1{\Tix}}|3{\SesEnv}
%
}{% * premise
%
\Gamma\, [x\mapsto 0] \vdash P \triangleright \Delta
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ DelDelta
\NewDocumentCommand{\PTypRuleDelDelta}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypDelDelta]{% * judgement
%
\TmpPrcJudge2{\PFuncDelay}|3{\SesEnv}
%
}{% * premise
%
\forall\ValTime\in\Const:
\TmpPrcJudge2{\PFuncDelay[\ValTime]}|3{\SesEnv}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ DelTime
\NewDocumentCommand{\PTypRuleDelTime}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypDelTime]{% * judgement
%
\TmpPrcJudge2{\PFuncDelay[\ValTime]}|3{\SesEnv}
%
}{% * premise
%
{\VarEnv+\ValTime%
        ~\Entails~%
        \Prc%
        ~\PrcTyped~%
        \SesEnv+\ValTime}%
& % ~\land~%
\Delta \textit{ not $t$-reading}
%\forall \ValTime'\leq\ValTime:%
%\Trans{\SesEnv+\ValTime'}|:{\RecvMsg}%
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ Res
\NewDocumentCommand{\PTypRuleRes}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\IEval:{%[\LblPrcTypRes]{% * judgement
%
\IPJudgement<[\PCalcScope]>
%
}:{\Premise[% * premise
\Compat[\CSoc_1][\CSoc_2],
\IPJudgement<[\Prc]>:{%
\PrcP:\CIso_1,
\PrcQ:\CIso_2,
\PrcQ\PrcP:\Queue_1,%
\PrcP\PrcQ:\Queue_2%
}
]}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ Var
\NewDocumentCommand{\PTypRuleVar}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcTypVar]{% * judgement
        %
        % \TmpPrcJudge1{\PVarEnvTypeRecVars}2{\PCalcRecVar|}|3{\SesEnv}
        \VarEnv,~\RecVar:\EnvPrcVar%
        ~\Entails~%
        \RecPrcCall%
        ~\PrcTyped~%
        \SesEnv%
        %
    }{% * premise
        %
        \SesEnv\in\SesSet
        &
        \forall i: {\VarEnv~\Entails~{%
        \RecSetMsg_i:\RecPrcMsg_i%
        }}
        &
        \forall j: {\VarEnv~\Entails~{%
        \RecSetTimers_j\models\RecPrcTimers_j%
        }}
% \DataType\in\RecPrcMsg,\exists v\in\RecSetMsg: %
%         \VarEnv~\Entails~{v:\DataType}%
%         &
%         \forall \Const\in\RecPrcTimers,\exists x\in\RecSetTimers: %
%         x\models\Const%
        %
    }
    \IfBooleanT{#1}{$}% mm wrap
}

% ~ Par
\NewDocumentCommand{\PTypRulePar}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcRedPar]{% * judgement
%
\TmpPrcJudge2{\Par[\Prc][\Qrc]}|3{\SesEnv_1,\SesEnv_2}
%
}{% * premise
%
\TmpPrcJudge2{\Prc}|3{\SesEnv_1}
&
\TmpPrcJudge2{\Qrc}|3{\SesEnv_2}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ Rec
\NewDocumentCommand{\PTypRuleRec}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcRedPar]{% * judgement
        %
        \VarEnv%
        ~\Entails~%
        \PrcRecDef%
        ~\PrcTyped~%
        \SesEnv%
        %
    }{% * premise
        %
\begin{array}[t]{r}
        \forall \PSesSetCfgs\in\SesSet:%
        \VarEnv,~\RecSetMsg:\RecPrcMsg,~\RecSetTimers:\RecPrcTimers,~\RecVar:\EnvPrcVar%
        ~\Entails~%
        \Prc%
        ~\PrcTyped~%
        \RecSetRoles:\PSesSetCfgs%
        %
        \quad% \qquad\qquad\mbox{}\\[0.5ex]%\qquad\qquad%
        %
        \VarEnv,~{\RecVar:\EnvPrcVar}%
        ~\Entails~%
        \Qrc%
        ~\PrcTyped~%
        \SesEnv%
        %
        \end{array}
    }
    \IfBooleanT{#1}{$}% mm wrap
}

% % ~ Subt
% \NewDocumentCommand{\PTypRuleSubt}{s}{%
%     \IfBooleanT{#1}{$}% mm wrap
%     \infer{%[{\RName[Subt]}]{% * judgement
%         %
%         \TmpPrcJudge
%         %
%     }{% * premise
%         %
%         %
%     }
%     \IfBooleanT{#1}{$}% mm wrap
% }

% ~ Weak
\NewDocumentCommand{\PTypRuleWeak}{s}{%
\IfBooleanT{#1}{$}% mm wrap
\infer{%[\LblPrcTypWeak]{% * judgement
%
\TmpPrcJudge3{2{2{2{\TypeEnd}}}}
%
}{% * premise
%
\TmpPrcJudge|3{\SesEnv}
%
}
\IfBooleanT{#1}{$}% mm wrap
}

% ~ EmptyQ
\NewDocumentCommand{\PTypRuleEmptyQ}{s}{%
\IfBooleanT{#1}{$}% mm wrap
%
\TmpPrcJudge2{\PCalcBuffer2{\emptyset}}|3{\PCalcBuffer2{\emptyset}}
%
% {\RName[EmptyQ]}
%
\IfBooleanT{#1}{$}% mm wrap
}

% ~ VQue
\NewDocumentCommand{\PTypRuleVQue}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcTypVQue]{% * judgement
        %
        \VarEnv%
        ~\Entails~%
        {{pq}:{l\pl}\cdot\QHead}%
        ~\PrcTyped~%
        \SesEnv,~{{pq}:{{l'\left\langle T \right\rangle};\Queue}}%
        %
    }{% * premise
        %
        \DataType \neq \CIso[\Const]
        %
        & l=l'%
        &
        %
        \VarEnv%
        ~\Entails~%
        {\pl:\DataType}%
        %
        &
        %
        \VarEnv%
        ~\Entails~%
        {\PrcP\PrcQ:\QHead}%
        ~\PrcTyped~%
        \SesEnv,~{\PrcP\PrcQ:\Queue}%
        %
        %
        %
    }%
    \IfBooleanT{#1}{$}% mm wrap
}

% ~ DQue
\NewDocumentCommand{\PTypRuleDQue}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[\LblPrcTypDQue]{% * judgement
        %
        \VarEnv%
        ~\Entails~%
        {{pq}:{lp}\cdot\QHead}%
        ~\PrcTyped~%
        \SesEnv,~{{pq}:{{l'\left\langle T \right\rangle};\Queue}},~{p:\CIso}%
        %
    }{% * premise
        %
        \DataType = \CIso[\Const]
        %
        & l=l'%
        &
        %
        \VarEnv%
        ~\Entails~%
        {pq:\QHead}%
        ~\PrcTyped~%
        \SesEnv,~{pq:\Queue}%
        %
        &
        %
        \ValClocks\models\Const
        %
    }
    \IfBooleanT{#1}{$}% mm wrap
}

% ~ End
\NewDocumentCommand{\PTypRuleEnd}{s}{%
\IfBooleanT{#1}{$}% mm wrap
%
\TmpPrcJudge2{\PrcEnd}|3{\emptyset}
%
% \LblPrcTypEnd
%
\IfBooleanT{#1}{$}% mm wrap
}

\endinput

% ~
\NewDocumentCommand{\PTypRule}{s}{%
    \IfBooleanT{#1}{$}% mm wrap
    \infer{%[{\RName[]}]{% * judgement
        \TmpPrcJudge
    }{% * premise
    }
    \IfBooleanT{#1}{$}% mm wrap
}

