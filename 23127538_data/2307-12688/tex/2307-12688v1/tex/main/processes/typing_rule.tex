
The rules for typing processes are given in~\Cref{fig:prc_typ_rule}.
%
\input{tex/figs/processes/rule_typing.tex}
%
%Rules \begin{inline}/+.
%    \item \LblPrcTypEnd*
%    \item \LblPrcTypEmptQ*
%    \item \LblPrcTypPar*
%    \item \LblPrcTypRes*
%    \item \LblPrcTypWeak*
%    \item \LblPrcTypVQue*
%    \item \LblPrcTypDQue*
%    \item \LblPrcTypDelDelta*
%\end{inline} are unchanged from~\cite{Bocchi2019}.
%
We have highlighted the rules that were changed (orange) or added (green) with respect to~\cite{Bocchi2019}.
%
Terminated processes and empty channel buffers are typed using axioms \LblPrcTypEnd*\ and \LblPrcTypEmptQ*, respectively. Rule \LblPrcTypPar*\ divides the session environment in two, $\Delta_1$ and $\Delta_2$, so that each session is carried by only one of $P$ and $Q$. 
%
Rule \LblPrcTypRes*\ ensures scoped processes are well-typed against binary sessions composed of compatible configurations. Compatibility $\bot$ has been discussed after \Cref{thm:progress}.
%
Non-empty buffers and queues are typed by \LblPrcTypVQue*\ or rule \LblPrcTypDQue*. The former is for payloads containing \emph{base types}, while the latter is for delegated sessions.
%
%
Rule \LblPrcTypTimer*\ adds or resets timer $x$ in \VarEnv*.
%
Rule \LblPrcTypDelDelta*\ checks that $P$ is well-typed against all solutions of \Const*.
%
Rule \LblPrcTypDelTime*\ reflects time passing  on  \VarEnv*\ and the session \SesEnv*. The left-hand side premise enforces \emph{receive urgency} (see rule \LblCfgSocTime*\ in~\Cref{fig:typesemantics}) in processes.

Rule \LblPrcTypBranch*\ is checks that a \texttt{receive\text{-}after} process is well-typed against a choice type.
%
The first line in the premise checks that other ongoing sessions in $\Delta$ allow time passing (i.e., that the process can wait $n$ time units to receive). If this is not the case, rules for checking other sessions should be applied first. The second line in the premise checks that all actions $j$ that are viable in $\nu$: (1) are receiving actions, (2) are viable until the timeout of $n$ expires, (3) have a corresponding branch $i$ can be well-typed against option $j$. In (3) we use an intermediate process (used only for typing) of the form \PCalc*{\On{p}\Recv*<{n}{l}[\pl]:{P}_{i}}\ that allows for modular typing of each single branch via \LblPrcTypVRecv*\ or \LblPrcTypDRecv*.
%
The final line of the premise checks if the type has (send or receive) future-enabled actions in $\nu+n$ and, if so, checks that these are correctly implemented by timeout process $Q$.  
%
Rule \LblPrcTypVRecv*\ is applied when evaluating individual base-type receptions.
The premise ensures a process adheres to the types timing constraints and maps the received message $b$ to \DataType*\ within \VarEnv*, and checks that the continuation process $P$ is well-typed against the continuation type $S$, with any clock resets applied, for the entire duration of $n$.
%
Rule \LblPrcTypDRecv*\ is similar, but for reception of delegated sessions, which is added to the session environment.

Rule \LblPrcTypVSend*\ and \LblPrcTypDSend*\ are for typing processes that send messages against a choice type, by finding a matching pair of labels in the process and type.
%
Rule \LblPrcTypVSend*\ applies for sending base-types, requiring that $v$ is well-typed against \DataType*, and the continuation process $P$ is well-typed against the continuation $S$, with any clock resets applied.
%
Rule \LblPrcTypDSend*\ is similar, but for sending session delegations, and removes role $d$ from the session environment.

Rule \LblPrcTypIfTrue*\ is for typing time-sensitive conditional statements. If the timers in $\Gamma$ satisfy the condition $\delta$, then the evaluation continues with $P$.
%
Likewise, if $\delta$ is not met by the contents of \VarEnv*\ the evaluation continues with $Q$, by rule \LblPrcTypIfFalse*.
%
%In other works where processes cannot branch using time, both $P$ and $Q$ can be typed against the same environment.
%However, by branching depending on values of time, we can encode richer processes more tightly aligned to the types, by ensuring that processes are well-typed against session environments with a certain range of clock valuations.
%


Rules \LblPrcTypRec*\ and \LblPrcTypVar*\ are essentially unchanged from~\cite{Bocchi2019}, only extended to accommodate process timers.
%
Rule \LblPrcTypRec*\ handles recursive definitions by first exploring all of $P$, collecting within the triple $(\RecPrcMsg;\RecPrcTimers;\SesSet)$ all messages, timers and session environments which lead to a recursive corresponding call.
%
This triple containing the ``valid traces'' is mapped to a process variable assigned to $P$, and added to \VarEnv*\ as the evaluation continues with $Q$.
%
Rule \LblPrcTypVar*\ determines if a call is well-typed by checking that the provided messages, timers and channels correspond to those in the process variable.
%
\marginpar{This needs to be reworded. More punch and precision. --Jonah}

\endinput
Rule \LblPrcTypRec*\ handles recursive processes \Prc*\ by first unfolding the remainder of the process before continuing as \Qrc*.
%
During this unfolding \SesSet*\ collects all of the \SesEnv*\ that \Prc*\ and its continuation are typed against until reaching a recursive call \RecPrcCall*.
%
Additionally, both \RecSetMsg*\ and \RecSetTimers*\ are added to the environment \VarEnv*\ to ensure that any recursive calls encountered provide the necessary messages and process timers, as specified by \RecPrcVar*.
%
Rule \LblPrcTypVar*\ handles recursive calls, requiring that it has been defined and that all of the expected messages and clocks are present.
%
\subsubsection{Handling Receptions}
Rule \LblPrcTypBranch*\ first collects all of the viable receiving actions defined by the type in the set $K$, and enforces \emph{receive urgency} by requiring that there are no messages currently waiting to be received.
%
Next, every reception in the type and process are individually matched together to be evaluated and typed by either \LblPrcTypVRecv*\ or \LblPrcTypDRecv*.
%
The \TTPrcAft*\ branch (timeout branch) is evaluated against a session environment and process timers which have been incremented by \PrcAfter*.

\emph{Rule} \LblPrcTypVRecv*\ handles the reception of non-delegation messages. The type must specify that the message can be received for the entire duration of \PrcAfter*.
For every possible reception within \PrcAfter*, the continuation \Prc*\ is typed against the proceeding \TypeS*, with the received message added to \VarEnv*.

\emph{Rule} \LblPrcTypDRecv*\ handles the reception of delegations, and is similar to \LblPrcTypVRecv*, but instead of the received message being added to \VarEnv*, a new role is created within \SesEnv*\ for the received delegation.

\subsubsection{Outgoing Messages}
Rule \LblPrcTypVSend*\ and \LblPrcTypDSend*\ handle outgoing messages.

\endinput
Due to the number of rules, they will be discussed in groups.
\begin{note}
    Message labels \MsgLabel*\ and data-types \DataType*\ are distinguished as pertaining to a \emph{type} or a \emph{process} by writing either
    \begin{inline}|
        \item \MsgLabel*_{\MsgType}\ and \DataType*_{\MsgType}\ to indicate those corresponding to \emph{types}
        \item \MsgLabel*_{\PrcMsg}\ and \DataType*_{\PrcMsg}\ correspond \emph{processes}
    \end{inline}
\end{note}
\input{tex/figs/processes/rule_typing.tex}

\subsubsection{Handing Receptions}\hfill\ \LblPrcTypBranch*\ \par%
The \LblPrcTypBranch*\ rule does not explicitly evaluate that the given process is well-typed against the given type itself.
Instead, a set \mkSet*[k]\ collects all viable receiving actions specified by the type within the time frame \PrcAfter*.
The final condition requires that \SesEnv*\ is not \ValTime*-reading, which ensures that there is not a message already waiting to be received. This is to ensure that all messages are received before the evaluation continues.
The second line of the premise requires that every reception specified by the types within \mkSet*[k]\ has a corresponding reception defined in the process. This is achieved with $\PrcMsg_i=\MsgType_k$ on the second line of the premise. Given that this holds, the evaluation of each pair of process reception and type is passed onto either \LblPrcTypVRecv*\ or \LblPrcTypDRecv*, to be evaluated depending on the message type.

Additionally, in the case that no message is received within \PrcAfter*\ units of time, the final line of the premise for \LblPrcTypBranch*\ initiates the evaluation of the \TTPrcAft*\ branch (timeout branch) against a session environment and process timers which have been incremented by \PrcAfter*.

\paragraph*{Receiving Messages}\hfill\ \LblPrcTypVRecv*\ \par%
The premise ensures that this particular interaction type is not a delegation.
It is required that the message expected by the process \PrcMsg*\ adheres to the data-type specified by the type \DataType*_{\MsgType}.
Continuing, the evaluation of the proceeding process \Prc*\ against the continuation type \TypeS*\ ensues, for each possible time \ValTime*\ permitted within the limit of \PrcAfter*.
For each instance of evaluation, the value of \ValTime*\ is incremented over the timers previously set within the processes, along with the clocks within the session environment \SesEnv*. Any clocks declared to be reset by the type are also enacted within \SesEnv*.

\paragraph*{Receiving Delegations}\hfill\ \LblPrcTypDRecv*\ \par%
Similarly to \LblPrcTypVRecv*\, but conversely the premise requires that the data-type \DataType*_{\MsgType}\ specified by the types is a delegation type \TmpTypBTDelegate*.
Given that this is true, a new role \PrcMsg*\ is added to the session environment \SesEnv*, comprised of a new valuation of clocks that adheres to the constraints specified in the delegation message, and the corresponded delegated session type.

\subsubsection{Ordering Transmissions}\hfill\ \LblPrcTypIfTrue*\ \par%
Given the absence of a \emph{selection} construct in the calculus, outgoing transmissions are deterministic, and it is always known what has been communicated.
Instead, outgoing transmissions are to be structured using the \TTIf*\ structure included in the calculus. The conditions of these \TTIff*\ statements differs from other work by only permitting constraints on timers within the process to be used. This is for simplicity, but should be somewhat straightforward to implement this approach with other work that allows for the traditional approach of using any (non-delegation) data received for conditional control flow of the process.
Similarly to receptions, sending messages are handled separately to sending delegations.
\begin{note}
    Once a given evaluation branch is known to take either the \Prc*\ branch pertaining to a given sending action, any opportunities for reception after this point, given in the type, do not need to be evaluated as it is known this sending action will always occur here.
\end{note}

\paragraph*{Sending Messages}\hfill\ \LblPrcTypVSend*\ \par%
The first line of the premise ensures that there exists a viable sending action which corresponds to the message the process will send. This rule only handles the evaluation of \emph{non-delegating} sending actions.
The second line ensures that the message \PrcMsg*\ is well-typed against \DataType*_{a_{i}}, and initiates the evaluation of the continuation process \Prc*\ being well-typed against the proceeding type \TypeS*.

\paragraph*{Sending Delegations}\hfill\ \LblPrcTypDSend*\ \par%
The first line of the premise is identical to \LblPrcTypVSend*, except that the message being sent \emph{must} be a delegation.
An additional role \PrcMsg*\ must exist within the session environment \SesEnv*, which corresponds to the message to be sent, and that will subsequently be removed from \SesEnv*\ once it has been sent.

\subsubsection{Timers, Delays and Variables}\hfill\ \ \par%

\endinput
