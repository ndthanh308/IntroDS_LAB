
% Processes are considered modulo structural equivalence, where ${P}\equiv {Q}$ denotes $P$ and $Q$ to be structurally congruent, and as in~\cite{Bocchi2014,Bocchi2019} ${\mathtt{delay}(0).{P}}\equiv {P}$.
% %
% \marginpar{i'm not sure how to rephrase "modulo structural equivalence" from the same as in '19 paper --Jonah}

%Let \TimerSet*\ be a finite set timers denoted $x, y, z$ and $n\in \RatSet$. 
% % https://math.stackexchange.com/questions/1323823/linear-maps-and-basis-of-domain
A \emph{timer environment} $\RedTimers$ is a map from a set of timer names \TimerSet* to \RatSet*.
We define $\RedTimers+\ValTime = \{ x\mapsto\RedTimers(x)+\ValTime \mid x\in\TimerSet \}$ and ${\RedTimers} [x\mapsto 0]$ to be the map ${\RedTimers} [x\mapsto 0](y) = ~\text{if\ } (x = y)~0 ~\text{else\ } \RedTimers(y)$.
% $\RedTimers$ is a map from timers, ranged over by $x, y, z$, to values in $\RatSet$ defined as ${\RedTimers}::= \emptyset ~\mid ~  x:n, {\RedTimers}$. 
% %
% We denote the domain of $\RedTimers$ with $\mathtt{dom}(\RedTimers)$. We define  $\RedTimers+\ValTime = \{ x\mapsto\RedTimers(x)+\ValTime \mid x\in\RedTimers \}$ and 
% $\RedTimers{}{} [x\mapsto0] = \begin{cases}
%     \RedTimers, x:0 & \textit{if }x\not\in\mathtt{dom}(\RedTimers)\\
%     \RedTimers', x:0 & \textit{if }\RedTimers = \RedTimers', x:n \text{ for some }n\in\RatSet\text{.}\\
% \end{cases}$

The semantics of processes are given in~\Cref{fig:prc_reduc}, as a reduction relation on pairs of the form \RedPrc*{\Prc}.
%
The reduction relation is defined on two kinds of reduction: instantaneous communication actions $\ARed$, and time-consuming actions $\TRed$. We write $\PrcRed$ to denote a reduction that is either by $\ARed$ or $\TRed$.
%

\input{tex/figs/processes/reduction.tex}
% Figure environment removed
% %
% % Figure environment removed
%\input{tex/figs/processes/func/time_passing.tex}
%
% The reduction rules for processes are defined in~\cref{fig:prc_reduc}.

Rule $\LblPrcRedSetTimer$ creates a new timer $x$ if $x$ is undefined, and otherwise resets $x$ to 0.
% resets a timer $x$ to 0 if $x$ is already defined, and otherwise creates a new timer $x$.
% sets a timer $x$ if $x$ is new, and resets $x$ if already defined. 
Rule $\LblPrcRedIf$ selects a branch $P$ depending on time-sensitive condition $\delta$. The symmetric rule selects branch $Q$ if the condition is not met, and is omitted. 
%
Rules $\LblPrcRedRecv$ and $\LblPrcRedSend$ are standard~\cite{Milner1999}.
%
Rule \LblPrcRedDet*\ determines the actual duration $t$ of the delay $\delta$ (which is a constraint on a single clock).
%
Rule \LblPrcRedDelay*\ outsources time-passing to function \PFuncTime*\ (see~\Cref{fig:prc_func_time}), which returns process $P$ after the elapsing of $t$ units of time, and updates \RedTimers*\ accordingly.
%
Rules $\LblPrcRedScope$ and $\LblPrcRedParL$ are as standard and the only instant reductions, which may update $\RedTimers$, if any timers are introduced by \LblPrcRedSetTimer*.
% the reduction in the premise. 
We omit the symmetric rule for $\LblPrcRedParL$.
%
The rule for structural congruence \LblPrcRedAStr*\ applies to both instantaneous and time-consuming actions. 
%
Structural equivalence of $P$ and $Q$, denoted $P\equiv Q$ is as standard with the addition of rule 
${\mathtt{delay}(0).{P}}\equiv {P}$ following~\cite{Bocchi2019,Bocchi2014}.

\begin{definition}\label{fig:prc_func_time}
The time-passing function \PFuncTime*\ is a partial function on process terms, defined only for the cases below, where we use $\mathtt C_I$ as a short notation for $\{l_i(\pl_i):P_i\}_{i\in I}$:  
\small\[
\begin{array}[t]{lll}
%
 \PFuncTime[\PCalc{\On{p}~\PrcRecv{~\mathtt C_I}~\After<{e}:{Q}}]= 
    \begin{cases}
               % infty
               \PCalc{\On{p}~\PrcRecv{~\mathtt C_I}~\After<{e}:{Q}}
                &
               { e = \infty}
               %
               \\[0.5ex]
               %
               \PCalc{\On{p}~\PrcRecv{~\mathtt C_I}~\After<{e-t}:{Q}}
                &
               {e\in\RatSet \textit{ and  } e \geq t}
               %
               \\[0.5ex]
               \PFuncTime_{t-e}[Q]
                &
               \text{otherwise}
               %
\end{cases}
\\[0.8cm]
%
               \PFuncTime[\PFuncDelay[\ValTime']]=
               \begin{cases}
               \PFuncDelay[\ValTime'-\ValTime]
               & 
               \text{if\ }\ValTime'\geq\ValTime
               \\[0.5ex]
               \PFuncTime_{t-t'}[P]
               & 
               \text{otherwise}
               \end{cases}
            % \end{array}
            %
\\[0.55cm]
    %
               \PFuncTime[\Par[\Prc_1][\Prc_2]]=
               \Par[\PFuncTime[\Prc_1]][\PFuncTime[\Prc_2]]
               \qquad
               \text{if}\;
               \PFuncWait[\Prc_i]\cap\PFuncNEQ[\Prc_j]=
               \emptyset,
               i\neq j\in\left\{1,2\right\}%
\\[0.3cm]
\PFuncTime[\PrcEnd]=\PrcEnd 
\qquad
\PFuncTime[\PrcErr]=\PrcErr
\\[0.3cm]
%
\PFuncTime[\PCalcBuffer]= \PCalcBuffer
\qquad
\PFuncTime[\PCalcScope]= \PCalcScope|\;\PFuncTime[\Prc]
\\[0.3cm]
            {%\ColBoxMod{%
            \PFuncTime[\PrcRecDef]=
            \PrcRecDef>{\PFuncTime[\Qrc]}
            }
            %
         \end{array}
\]
%
\end{definition}

\noindent The first case in~\Cref{fig:prc_func_time} models the effect of time passing on timeouts. The second case is for time-consuming processes. The third case distributes time passing in parallel compositions and ensures that time passes for all parts of the system equally. 
The auxiliary functions \PFuncWait*\ and \PFuncNEQ*\
ensure time does not pass while a process is waiting to receive a message already in their queue, similar to rule \LblCfgSocTime*\ in~\Cref{fig:typesemantics_triple} for configuration transitions. Informally, \PFuncWait*\ returns the set
of channels on which P is waiting to receive
a message, and \PFuncNEQ*\ returns the set of endpoints with a non-empty inbound queue.
% (See~\cref{fig:prc_func_wait,fig:prc_func_neq} for full definitions.)
Full definitions are given in~\Cref{fig:prc_func_neq_wait}.
The remaining cases allow time to pass. 


%shown in~\cref{fig:prc_func_time} (Note: the final case $\PFuncTime[\PCalc{\On{p}\Recv*<{n}{l}[b]:{P}_{i}[i]}]$ is only relevant when typing processes).
%
%\marginpar{The final case in~\cref{fig:prc_func_time} is not a real process, but used in type checking. Feel free to remove if we don't need to address this. --Jonah}
%


%


\begin{example}
%You may notice how the \PCalc*{\After<{n}:{Q}}\ portion of rule \LblPrcRedRecv*\ appears redundant.
%If participant $p$ is unable to reduce via rule \LblPrcRedRecv*\ and no other reduction is possible via \LblPrcRedARed*\ in ${Q'}$, then some time-consuming reduction is taken by \PFuncTime*.
%
Consider the process below:
%
\[
   P = (\nu pq) \left(\Parl{\PCalc{\On{p}\Recv{l}[\pl]:{P}_{i}[i]~\After<{e}:{Q}},{{qp}:\emptyset},{Q'}}\right)%
\]
%
For a time-consuming action of $t$ to occur on $P$ it is required that $\Phi_t$ is defined for all parallel components in $P$. Note that, if  ${qp}$ was not empty, then time could not pass since $\PFuncNEQ[P] = \PFuncWait[P] = \{p\}$. 
%
Set $t = n+1$ so that we can observe the expiring of the timeout. The evaluation of \PFuncTime*_{t}[{\PCalc{\On{p}\Recv{l}[\pl]:{P}_{i}[i]~\After<{e}:{Q}}}]\ results in the evaluation of \PFuncTime*_{1}[Q]. 
If $Q= \PrcEnd$ (or similarly $\PrcErr$, a delay, or a timeout with $n>0$) and \PFuncTime*_{t}[Q'] is defined then time passing of $t$ is possible and: 
 \[\PFuncTime_{t}[P]{}{} = (\nu pq) (\PrcEnd \mid {{qp}:\emptyset}\mid \PFuncTime_{t}[Q'] )\]
If $Q$ is a sending process then \PFuncTime*_{t}[Q]\ would be undefined, and hence \PFuncTime*_{t}[P]. 
\end{example}
\endinput

% \paragraph*{Process Reductions}
There are two kinds of reductions: instant are by \LblPrcRedARed*, and time-consuming are by \LblPrcRedTRed*\ which applies \PFuncTime*\ (defined in~\cref{ssec:prc_func_time}) by \LblPrcRedDelay*.
%
Structural equivalence is also split by these two kinds: \LblPrcRedAStr*\ and \LblPrcRedTStr*.
The remaining rules standard to similar works utilising the asynchronous reduction
\begin{inline}+
   \item \LblPrcRedScope*
   \item \LblPrcRedPar*
   \item \LblPrcRedSend*
   \item \LblPrcRedRecv*
\end{inline}

The reduction \LblPrcRedSend*\ describes a message \PrcMsg*\ being sent via the channel of role \SesP*, leading to the message being added to the end of the channel buffer, and the process proceeding to its continuation.
Respectively, \LblPrcRedRecv*\ describes a process waiting \PrcAfter*\ time to receive a message from its role's channel buffer. Receiving the message successfully removes it from the channel buffer, and the process proceeds as its corresponding continuation.

The changes to \LblPrcRedDef*\ and \LblPrcRedRec*\ allow timers within a process to be captured and recalled in recursive definitions and calls.
In the standard way, a processes may first be reduced by \LblPrcRedDef*\ before any \LblPrcRedRec*\ is possible. A process can be reduced by \LblPrcRedDef*\ any amount of times, with each establishing a recursive call to that point.
In \LblPrcRedDef*, it may be that $\Prc=\Qrc$, for instance, on the exact reduction a recursive call is defined; otherwise, \Qrc*\ is some process after a definition, but before a call.
Reductions proceeding a definition will omit the definition itself, for the sake of conciseness.
%
Rule \LblPrcRedDet*\ picks a value of time to wait that adheres to the \Const*\ provided, allowing some degree of randomness and variation to the delays exhibited by processes.
% This is expanded upon in~\cref{ssec:prc_func_time}.
