
Processes are validated against types using judgements of the form: $\VarEnv~\Entails~{P}~\PrcTyped~\SesEnv$
% using the environments as defined in~\Cref{eq:prc_typ_env}.
%
% \input{tex/figs/processes/typing.tex}
\begin{minieq}*%\label{eq:prc_typ_env}
    \begin{array}[t]{lcl p{8ex} lcl}
        %
        \VarEnv & ::= & \mathrlap{\emptyset%
        ~\mid~{\VarEnv,~{\pl:T}}
        ~\mid~{\VarEnv,~{x:n}}
        ~\mid~{\VarEnv,~{\RecVar:{(\RecPrcMsg;\RecPrcTimers;\SesSet)}}}}
        %
        \\[-1ex]\\
        \SesEnv & ::= & \emptyset%
        ~\mid~{\SesEnv,~{p:\CIso}}
        ~\mid~{\SesEnv,~{pq:\Queue}}
        %
        & & %
        \SesSet & ::= & \emptyset%
        ~\mid~{\SesSet\cup\left\{\SesEnv\right\}}
        %
    \end{array}
\end{minieq}
%
\emph{Session Environments} \SesEnv* map roles \PrcP*\ to configurations and session endpoints $\PrcQ\PrcP$ to queues \Queue*.
%
\emph{Variable Environments} \VarEnv* map values $\pl$ to data types \DataType*, process timers $x$ to values $n$, and process variables \RecVar*\ to triples \EnvPrcVar*, where
\begin{inline}+
    \item \RecPrcMsg*\ is a vector of messages (consisting of labels and data types)
    \item \RecPrcTimers*\ is a vector of process timers valuations
    \item \SesSet*\ is a set of session environments used for typing recursive processes
\end{inline}
With respect to usual formulations of session types, we use the mapping of timers as a virtual state to correctly type check time-sensitive conditional statements.  

\subsubsection*{Auxiliary definitions \& notation}
%The following definitions are largely unchanged from~\cite{Bocchi2019}.
%We only include those relevant to this work, while definitions such as ``disjoint union of clocks'' still carry over but are omitted for brevity.
%\marginpar{I've tried to only include the bits important for this work/proof without plagiarising Laura. There isn't anything new to add. --Jonah}
%
We write $\mathtt{dom}(\SesEnv)$ for the domain of \SesEnv*, and $\SesEnv_1,\SesEnv_2$ for $\SesEnv_1 \cup \SesEnv_2$ when $\mathtt{dom}(\SesEnv_1)\cap\mathtt{dom}(\SesEnv_2)=\emptyset$.
%
%Given a role $p$, a configuration \CIso*\ and a session environment \SesEnv*, 
We define $\SesEnv(p)=\CIso$ iff $p\in\SesEnv$ and $\exists \SesEnv'$ such that $\SesEnv=\SesEnv',~{p:{\CIso}}$, and define $\mathtt{val}(p)=\ValClocks$ and $\mathtt{type}(p)=\TypeS$.
%
Given a time offset $t\in\RatSet$, we define: 
(1) ${p+t}={({\mathtt{val}(p)+t},~{\mathtt{type}(p)})}$, (2) 
$\SesEnv+t=\{ {p+t} \mid {p\in\mathtt{dom}(\SesEnv)} \}$, (3) $\VarEnv+\ValTime=\{ x+\ValTime \mid x\in\VarEnv\}$. 
%
We say that $\Delta$ is \emph{$t$-reading} iff there exist
$p\in\mathtt{dom}(\Delta)$ and $t'<t$ such that $\Delta+t'(p)$ can make a reading action. 
%
We define $\Gamma [x\mapsto 0]$ similarly to $\RedTimers{}{} [x\mapsto0]$. 

Given a role $p$, $\mathtt{wf}(p)$ holds iff $\exists\delta: \mathtt{val}(p)\models\delta$ and $\emptyset;~\delta~\Entails~\mathtt{type}(p)$.
%
Given a role $p$ and $t\in\RatSet$, we define $\mathtt{AE}(p,t)=\mathtt{true}$ iff $\exists{t'}>t:\mathtt{wf}(p+{t'})$.
% We write $\mathtt{LE}(\mathtt{}p)=$.
%
\endinput
In a given session, a processes performs a single role; roles specify the different actions able to be performed by a process, and are defined by a configuration. Two processes performing different roles exchange data via asynchronous channels, each with a \texttt{FIFO} buffer. The session environment \SesEnv*\ contains all of the information relevant to the ongoing session, accumulating any roles received through delegated sessions.

\paragraph*{Variable Environment (\VarEnv*)}
All of the variables available during the runtime execution of a process is contained within the variable environment \VarEnv*; including:
\begin{inline}+
    \item received messages \PrcMsg*\ against a type \DataType*
    \item set timers \Tix*\ with their known values \Const*
    \item recursive variables, a triple comprised of the following sets
    \begin{inline}*+.{}
        \item \PrcSorts*\ containing all \PrcMsg*\ against types \DataType*
        \item \RecPrcTimers*\ containing all timers \Tix*\ and valuations \Const*
        \item \SesSet*\ containing all session environments \SesEnv*\ possible given that this point is recalled back to via recursion
    \end{inline}
\end{inline}

\paragraph*{Set of Session Environments (\SesSet*)}
Contains all of the possible entry points to a recursive definition, which is necessary for ensuring that all possible instances of a recursive call on a given recursive definition are considered and evaluated.

% \subsection{Notions and Assumptions}
\paragraph*{Session Domains}
\TODO[session domains etc]
% \input{tex/defs/processes/domain_clocks.tex}
%
\input{tex/defs/processes/t_reading.tex}
\begin{note}
    \ValTime*-reading \SesEnv*\ can be denoted by \PSesEnvTRead*, and non-\ValTime*-reading \SesEnv*\ by \PSesEnvTRead*|.
\end{note}
