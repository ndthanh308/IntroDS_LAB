
In this section we discuss the properties of our typing system, most importantly \emph{time safety}, building on the usual property of subject reduction. 

Time safety without mixed choices in Timed Session Types~\cite{Bocchi2019} relies on a property called receive-liveness. Receive-liveness is defined on untimed counterpart of a timed process $P$, obtained by removing all timing aspect from $P$. Intuitively, receive-liveness ensures that if a process is waiting to receive a message, the other (parallel) processes will provide with that message. This property, on the untimed counterpart of the processes in~\cite{Bocchi2019} can be checked with the techniques for global progress in~\cite{Bettini2008} that can prevent deadlocks due to circular dependencies in interleaved sessions. 
%
It might seem that receive-liveness is an unusually strong requirements for error-freedom, compared with untimed formulation of session types which use it only to prove progress. We argue that, when considering time and punctuality, the distinction between progress and safety is not clear-cut, since deadlocks may cause violation of time constraints. 

Unfortunately, since out processes feature mixed choice, techniques similar to the ones in~\cite{Bettini2008} are not available to us. We rely on a simplifying assumption that each process in a system is \emph{single session}, namely that it implements a single session at a time. This constraint was introduced in~\cite{Honda2008} in the context of Multiparty Session Types. 


%

%
%This provides the guarantee that a process that is both \emph{well-typed} and \emph{live} was also free from circular dependencies of interleaved sessions.

%We are unable to define \emph{untimed processes}, due to the unique structuring of our \texttt{receive\text{-}after} process, and therefore unable to follow the approach of~\cite{Bocchi2019}.
%, and therefore take a different approach when defining \emph{receive liveness}.
%
%Instead, we define receive liveness over tuples ${(\RedTimers,~P)}$ and utilise skip reductions (defined below) to filter out any immediate delays such that a process can reduce instantly.
%We apply this to the non-waiting process in a waiting binary session such that some reduction can be made instantly to provide the message being waited upon, which is analogous to the underlying mechanism for receive liveness in~\cite{Bocchi2019}.
%
%We define $\mathtt{skip}(P)=\mathtt{skip}(P')$ if $P=\mathtt{delay}(t).P'$ else $P$.
%
%We define ${(\RedTimers,~P)}~{{\ARed}_{\scriptstyle \mathtt{skip}}}~{(\RedTimers',~P')}$ which is equivalent to ${(\RedTimers,~\mathtt{skip}(P))}~{\ARed}~{(\RedTimers',~P')}$.
%
% Receive liveness is defined as follows:
%
%\begin{definition}[Receive Liveness]\label{def:receive_liveness}
    %
%    ${(\RedTimers,~P)}$ is said to be \emph{live} if for all $\RedTimers',P'$ such that ${(\RedTimers,~P)}~{\PrcRed}^{*}~{(\RedTimers',~P')}:
    %
    % \begin{minieq}*
        %
        % \begin{array}[t]{l}
 %       {P'}\equiv%
  %      {(\nu pq){(\Parl{P'',Q})}}%
   %     ~\land~%
    %    {p\in\PFuncWait[P'']}%
     %   ~\implies~%
        %
        % \\[0.5ex]\qquad\qquad\qquad%
      %  \exists {\RedTimers}',{Q'}:%
       % {(\RedTimers,~Q)}~{{\ARed}_{\mathtt{skip}}^{*}}~{(\RedTimers',~Q')}%
        % \\[0.5ex]\qquad\qquad\qquad\qquad\qquad\qquad%
        %~\land~%
        %{p\in\PFuncNEQ[{(\nu pq){(\Parl{P'',Q'})}}]}%
        %
        % \end{array}
        %
    $.% \end{minieq}
    %
%\end{definition}
%
%A process is said to be \emph{live} if a non-waiting sub-process %can provide another that is waiting with a suitable message by %only making instant reductions.

Subject reduction,~\cref{thm:subject_reduction}, proves if a process \emph{well-typed} and \emph{single-session}, then any reduction of that process is also \emph{well-typed}.
%
Time safety,~\cref{thm:time_safety}, builds upon Subject Reduction, specifying that any reduction reached by a well-typed process is not the \PrcErr*\ process; that all reductions are \emph{error-free}.



\input{tex/proofs/reduction/thm.tex}

%\subsubsection*{Time Safety}
Building upon the proof of subject reduction,~\cref{thm:time_safety} states that for a \emph{well-typed} process that is \emph{single-session}, any reduction is \emph{error-free}.

\begin{theorem}[Time-Safety]\label{thm:time_safety}
    %
    If ${\Prc}$ is \emph{single-session}
    and $\emptyset~\Entails~\Prc~\PrcTyped~\emptyset$
    and \Trans*{\Prc}*[\Prc'],
    then \Prc*'\ is \emph{error-free}.
    %
\end{theorem}




\endinput
We follow the approach in~\cite{Bocchi2019}. First we define \emph{untimed processes} (by erasing all time-related information) and define an assumption on the interaction structures, called \emph{receive liveness}~\cref{def:receive_liveness}, which is easily attainable by existing techniques and simplifies our theory.  
%
%Receive liveness is restricted to processes at the outer scope of a binary session.
A process is said to be \emph{live} if their \emph{untimed} counterpart can provide any process waiting to receive with a suitable message in the queue. 
%
Subject Reduction,~\cref{thm:subject_reduction}, proves if a process \emph{well-typed}, and its untimed counterpart is \emph{live}, then any reduction of that process is also \emph{well-typed}.
% Formally given in~\cref{thm:subject_reduction}.
%
Time Safety,~\cref{thm:time_safety}, builds upon Subject Reduction, specifying that any reduction reached by a well-typed process is not the \PrcErr*\ process; that all reductions are \emph{error-free}.

% Formally given in~\cref{thm:time_safety}.
%
%Following~\cite{Bocchi2019,Honda2008,Bettini2008,Bocchi2014}, cyclic dependencies of interleaved sessions in malformed processes are not checked by our typing system.

%\subsubsection*{Untimed Calculus}
%Following~\cite{Bocchi2019}, 
We define the untimed calculus by \emph{erasing} any error, delays or timing constraints in a process.
%
Given a timed process \Prc*\ we its untimed counterpart $\hat{\Prc}$ is obtained from $\mathtt{erase}(P)$.
%
Naturally, an untimed process can only reduce instantaneously, and not via any \emph{time-consuming} reductions.

\begin{definition}[Receive Liveness]%\label{def:receive_liveness}
    %
    $\hat{\Prc}$ is said to be \emph{live} if for all $\hat{\Prc'}$ such that $\Trans{\hat{\Prc}}*[\hat{\Prc'}]:
    %
    % \begin{minieq}*
        %
        \hat{\Prc}%
        \equiv%
        {(\nu pq)\hat{\Qrc}}%
        ~\land~%
        {p\in\PFuncWait[\hat{\Qrc}]}%
        \implies%
        {\exists {\hat{\Qrc'}}:%
        \Trans{\hat{\Qrc}}*[\hat{\Qrc'}]%
        ~\land~%
        {p\in\PFuncNEQ[\hat{\Qrc'}]}%
        }%
        %
    $.% \end{minieq}
    %
\end{definition}

\input{tex/proofs/reduction/thm.tex}

\subsubsection*{Time Safety}
Building upon the proof of subject reduction,~\cref{thm:time_safety} states that for a \emph{well-typed} process that is \emph{live}, any reduction is \emph{error-free}.

\begin{theorem}\label{thm:time_safety}
    %
    If $\hat{\Prc}$ is \emph{live}
    and $\emptyset~\Entails~\Prc~\PrcTyped~\emptyset$
    and \Trans*{\Prc}*[\Prc'],
    then \Prc*'\ is \emph{error-free}.
    %
\end{theorem}

