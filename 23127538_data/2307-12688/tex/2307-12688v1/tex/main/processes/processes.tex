
We present a new calculus for timed processes which extends existing timed session calculi~\cite{Bocchi2015,Bocchi2019} with: (1) timeouts, and (2) time-sensitive conditional statements. 
Timeouts are defined on receive actions and may be immediately followed by sending actions, hence providing an instance of mixed-choice -- which is normally not supported. 
Time-sensitive conditional statements (i.e., \texttt{if\text{-}then\text{-}else} with conditions on program clocks/timers) provide a natural counterpart to the timeout construct and enhance the expressiveness of the typing system in~\cite{Bocchi2019}. By counterpart, we intend a construct to be used by the process communicating with the one that sets the timeout. 
% as explained in~\cref{expressive}.
% \marginpar{need to }
% \begin{example}\label{expressive}
%    %
%    Consider the following type:
%    \[ \begin{array}[c]\{{c}\}
%          {!~\text{ping}~({x\leq 3,~\emptyset}).{S}},
%          ~{!~\text{pong}~({x> 3,~\emptyset}).{S'}}
%       \end{array} \]
%    %
%    Although it's behaviour appears to be trivial, it was unable to be fully expressed by processes in earlier work~\cite{Bocchi2019}, which did not support timer-based branching.
%    %
%    Such a type would have been modelled by a non-deterministic selection, which would only ensure that either ping or pong we're sent on time.
%    %
%    However, our processes are able to fully express this type:
%    \begin{processcalculus}*
%       \If{y\leq 3}~\Then{\On{p}\Send{ping}.{P}}
%       ~\Else{\On{p}\Send{pong}.{P'}}
%    \end{processcalculus}
%    %
% \end{example}

% Our calculus introduces process timers and features a new \texttt{receive\text{-}after} process in order to model timeouts.
% We introduce a process calculus with timeouts, which extends existing timed extensions of with timeout branches. 

%
%Arguably, there may be other ways to concretize mixed choices with programming language primitives. Our focus on timeouts is justified by their practical relevance.
%
%Moreover, we have extended the calculus in~\cite{Bocchi2019} with the ability of selecting branches depending on time (via \texttt{if\text{-}then\text{-}else} statements with conditions on program timers). This extension is valuable for two reasons. First, it provides a natural counter-part to the timeout construct. 

% In this paper we focus on a simple yet powerful idiom used for timeouts, similar to the \texttt{receive\text{-}after} pattern in Erlang.
% %  or the \texttt{select\text{-}after} pattern in Golang.
% %
% An example of a timeout in Erlang is shown in~\cref{fig:timeout_snippets_erlang}, and is modelled by process \Prc*\ in~\cref{fig:timeout_snippets_process}.
% %
% % Figure environment removed

% The counterpart to a timeout is delicate and requires the a process to know if it is early enough to send, or late enough to expect to receive a timeout.
% %
% % The counterpart to a timeout is delicate and non-trivial in that a process must know if it is early enough to send, or if it is late enough to receive a timeout message.
% % The implementation of the dual type of a timeout is delicate
% % \TODO[add dual of above timeout]
% % in what we have to provide the process with sufficient knowledge to decide whether to send or receive. 
% To this aim, we introduce another new feature in the calculus common to many programming languages: \emph{process timers}.
% A process is now able to create, reset and read simple timers.
% A process can use these timers in \texttt{if\text{-}then\text{-}else} statements to determine the selection from different branches.
% % These timers can be used by a process for branch selection 
% % A process is now able to set and read timers and, consequently, use their values to determine how branches are selected.
% % the possibility for a process to set and read clocks and, consequently, the possibility of choosing branches depending on the values of clocks. 
% An example of a counterpart is modelled by \Qrc*\ in~\cref{fig:timeout_snippets_process}, where $x$ is some pre-existing timer.
% % One possible implementation of process corresponding to a timeout could be \Qrc*\ in~\cref{fig:timeout_snippets_process} (where $x$ is a process timer set at an earlier point in the process).

% Note that the use of process timers alone yields more expressive calculus than~\cite{Bocchi2019} where a process could only take branches whose constraints were always satisfied.
% % Note that the use of clocks in the processes, alone, yield a more expressive typing than~\cite{Bocchi2019} where, basically, a process could only take branches whose constraints were satisfied in all possible executions. 
% Process timers allow for more responsive and dynamic branch selection during execution.
% % Process clocks add the option of choosing branches that are correct in (only) the current execution.
% %
% Remarkably, mixed-choice can easily be more complex than standard timeouts.
% Given a safe mixed-choice with interleaved sending and receiving actions, such as \TypeS*\ in~\cref{eq:complex_mixed_choice_type}, and it becomes clear that there is no straightforward equivalent for our processes.
% %
% \begin{minieq}\label{eq:complex_mixed_choice_type}
%    \begin{array}[c]{lll}
%       \TypeS & = & %
%       \begin{array}[c]\{{l}\}
%          %
%          %
%          ?~{done}\left(x<1,~\emptyset\right).{%
%          \TypeEnd%
%          }\\
%          %
%          %
%          !~{stop}\left(x=1,~\emptyset\right).{%
%          \TypeEnd%
%          }\\
%          %
%          %
%          ?~{data}~\text{<}\BTypeString\text{>}%
%          \left(1<x\leq 8,~\{x\}\right).{%
%          {\TypeS}'%
%          }\\
%          %
%          %
%          !~{timeout}\left(x>8,~\emptyset\right).{%
%          {\TypeS}''%
%          }
%          %
%       \end{array}
%    \end{array}
%    %
% \end{minieq}%
% %
% For mixed-choice with a more than one distinct region of sending and receiving actions that are interleaved, a corresponding process must consist of a combination of nested \texttt{receive\text{-}after} and \texttt{if\text{-}then\text{-}else} processes, such as \Prc*\ in~\cref{eq:complex_mixed_choice_prc}.
% \begin{processcalculus}\label{eq:complex_mixed_choice_prc}
%    \begin{array}[c]{lll}
%       %
%       \Prc & = & %
%       \PSet{y}.{%
%       \begin{array}[t]{l}
%          \On{p}\Recv*{done}:{\PrcEnd}%
%          \\%
%          \After<{1}:{%
%          \begin{array}[t]{l}
%             \If{y=1}%
%             % \\%
%             ~\Then{\On{p}\Send{stop}.{\PrcEnd}}%
%             \\
%             \Else{%
%                \begin{array}[t]{l}
%                   \On{p}\Recv*{data}[STR]:{\PSet{y}.{{\Prc}'}}%
%                   \\%
%                   \After<{7}:{%
%                   \On{p}\Send{timeout}.{{\Prc}''}%
%                   }
%                \end{array}
%             }
%          \end{array}
%          }
%       \end{array}
%       }
%    \end{array}
% \end{processcalculus}%
% %
% % Remarkably, mixed-choice can easily be more complex than standard timeouts, as discussed in~\cref{ex:complex_mixed_choice}.
% % %  a choice type can be more complex than a simple timeout as shown in~\cref{ex:complex_mixed_choice}.
% % %  the example below, which can be implemented using nested timeouts:
% % %
% % \begin{example}[Complex Mixed-choice]\label{ex:complex_mixed_choice}
% %    %
% %    Type \TypeS*\ as defined in~\cref{eq:complex_mixed_choice_type} is a mixed-choice.
% %    \begin{minieq}\label{eq:complex_mixed_choice_type}
% %       \begin{array}[c]{lll}
% %          \TypeS & = & %
% %          \begin{array}[c]\{{l}\}
% %             %
% %             %
% %             ?~{done}\left(x<1,~\emptyset\right).{%
% %             \TypeEnd%
% %             }\\
% %             %
% %             %
% %             !~{stop}\left(x=1,~\emptyset\right).{%
% %             \TypeEnd%
% %             }\\
% %             %
% %             %
% %             ?~{data}~\text{<}\BTypeString\text{>}%
% %             \left(1<x\leq 8,~\{x\}\right).{%
% %             {\TypeS}'%
% %             }\\
% %             %
% %             %
% %             !~{timeout}\left(x>8,~\emptyset\right).{%
% %             {\TypeS}''%
% %             }
% %             %
% %          \end{array}
% %       \end{array}
% %       %
% %    \end{minieq}%
% %    %
% %    Process \Prc*\ as defined in~\cref{eq:complex_mixed_choice_prc} is \emph{well-typed} against \TypeS*. 
% %    %
% %    \begin{processcalculus}\label{eq:complex_mixed_choice_prc}
% %       \begin{array}[c]{lll}
% %          %
% %          \Prc & = & %
% %          \PSet{y}.{%
% %          \begin{array}[t]{l}
% %             \On{p}\Recv*{}{done}:{\PrcEnd}%
% %             \\%
% %             \After<{1}:{%
% %             \begin{array}[t]{l}
% %                \If{y=1}%
% %                % \\%
% %                ~\Then{\On{p}\Send{stop}.{\PrcEnd}}%
% %                \\
% %                \Else{%
% %                   \begin{array}[t]{l}
% %                      \On{p}\Recv*{}{data}[\BTypeString]:{\PSet{y}.{{\Prc}'}}%
% %                      \\%
% %                      \After<{7}:{%
% %                      \On{p}\Send{timeout}.{{\Prc}''}%
% %                      }
% %                   \end{array}
% %                }
% %             \end{array}
% %             }
% %          \end{array}
% %          }
% %       \end{array}
% %    \end{processcalculus}%
% %    %
% %    % Similarly, \texttt{recv\text{-}after} processes can be nested for choices with cascading overlapping constraints.
% % \end{example}
% %
% It is important to note that it is intended for the conditions of \texttt{if\text{-}then\text{-}else} statements to specify the minimum requirement for selecting a branch; such as $\mathtt{if\ }(y=1)$ in~\cref{eq:complex_mixed_choice_prc}.
% In practice, a program may supplement these minimum conditions to control the flow of the system further.

% \subsection{Process Calculus}
% In accordance with TOAST our processes do not distinguish between sending and selecting, or receiving and branching.
% Processes communicate both a label $l$ and some value $v$.
% %
% Processes are defined by the following grammar:
\newcommand{\pl}[0]{\mathtt v}
Processes are defined by the grammar below.
%given in~\cref{eq:prc_calc}.
To better align processes with TOAST, send and select actions have been streamlined by each message consisting of both a label $l$ and some message value $\pl$, which is either data or a delegated session; the same holds for receive/branch actions where $q$ is a variable for data or delegated sessions. We assume a set of timer names \TimerSet*, ranged over by $x,y$ and $z$.
% A message $b$ is either a value $v$ or a delegated session $d$.

%
% V V V V V more compact version V V V V 
%
\begin{processcalculus}\label{eq:prc_calc}
   \begin{array}[c]{l}\begin{array}[t]{lcl p{2ex} lcl}
      %
      {\Prc,\Qrc} %
      & ::= & {\PSet{\mathit{x}}.{P}}%
      & & & \mid & {\RecPrcCall}%
      %
      \\
      & \mid & {\On{p}\Send{l}[\pl].{P}}% send
      & & & \mid & {\PrcEnd}%
      %
      \\
      & \mid & {\On{p}\Recv{l}[\mathit{q}]:{P}_{i}~\After<{e}:{Q}}% receive after 
      & & & \mid & {\PrcErr}%
      %
      \\
      & \mid & {\If*{\Const}~\Then{P}~\Else{Q}}% 
      & & & \mid & {(\nu pq)\Prc}%
      %
      \\
      & \mid & {\PFuncDelay[\Const]}%
      & & & \mid & {\Parl{P,Q}}%
      %
      \\
      & \mid & {\PFuncDelay[\ValTime]}%
      & & & \mid & {{qp}:{h}}
      %
      \\
      & \mid & {\PrcRecDef}%
      & & %& {h} & {::=} & {\emptyset~\mid~{h\cdot {lv}}~\mid~{h\cdot {lb}}}%
      %
     % \\[0.5ex]%\\
      {h} & {::=} & {\emptyset~\mid~{h\cdot {l\pl}}}
  %    & & {\pl} & {::=} & {v~\mid~d}%
      %
   \end{array}\end{array}
\end{processcalculus}
%
% \begin{processcalculus}\label{eq:prc_calc}
%     \begin{array}[t]{lcl p{2ex} lcl}
%         %
%         \Prc,\Qrc %
%         & ::= & \On{p}\Send{l}[v].{P}% send
%         & & {h} & {::=} & {\emptyset~\mid~{h\cdot v}~\mid~{h\cdot b}}%
%         %
%         \\
%         & \mid & \On{p}\Recv{l}[b]:{P}_{i}~\After<{n}:{Q}% receive after 
%         %
%         \\
%         & \mid & \PSet{x}.{P}%
%         %
%         \\
%         & \mid & \If{\Const}~\Then{P}~\Else{Q}%
%         %
%         \\
%         & \mid & \PFuncDelay[\Const]%
%         %
%         \\
%         & \mid & \PFuncDelay[\ValTime]%
%         %
%         \\
%         & \mid & \PrcRecDef%
%         %
%         \\
%         & \mid & \RecPrcCall%
%         %
%         \\
%         & \mid & \PrcEnd%
%         %
%         \\
%         & \mid & \PrcErr%
%         %
%         \\
%         & \mid & {(\nu pq)\Prc}%
%         %
%         \\
%         & \mid & \Parl{P,Q}%
%         %
%         \\
%         & \mid &  {{qp}:{h}}%
%         %
%     \end{array}
% \end{processcalculus}
%
\noindent Process $\PSet{\mathit{x}}.{P}$ creates a timer $x$, initialises it to 0 and continues as $P$. If $x$ already exists it is reset to $0$.
For simplicity, we assume that the timers set by each process $P$ and $Q$ in a parallel composition $P\mid Q$ are pair-wise disjoint.

Process \PCalc*{\On{p}\Send{l}[\pl]}\ is the select/send process: it selects label $l$ and sends payload $\pl$ to endpoint $p$, and continues as $P$.
%
Its dual is the branch/receive process \PCalc*{\On{p}\Recv{l}[\pl]:{P}_{i}[I]~\After<{e}:{Q}}. It receives one of the labels $l_i$, instantiates $\mathit{q}_i$ with the received payload, and continues as $P_i$. 
%
(Note that a similar construct has been used to model timeouts in the Temporal Process Language~\cite{Bocchi2022a}, outside of session types.) 
%
Parameter $e$ is a linear expression over the timers and numeric constants drawn from $\mathbb{N}_{\geq 0} \cup \{\infty\}$.
The expression $e$ determines the duration of a timeout, after which $Q$ is executed.
%
Once a process with an \texttt{after} branch is reached, its expression $e$ is evaluated against the values of the timers, to derive a timeout value $n$ where $n\in\mathbb{N}_{\geq 0} \cup \{\infty\}$.
%
Setting $e=\infty$ models a blocking receive primitive that waits potentially forever for a message. Setting $e=0$ models a non-blocking receive action. 
%
To retain expressiveness from~\cite{Bocchi2019} where non-blocking receive actions would trigger an exception (i.e., modelling deadlines that must not be missed) we allow $Q$ to be $\PrcErr$.
%
For simplicity: (i) we write \PCalc*{\On{p}\Recv{l}[\mathit{q}]:{P}_{i}[I]} when $e=\infty$; (ii) we omit the brackets in the case of a single  option; (iii) for options with no payloads we omit $q_i$.
%
The advantage of using an expression $e$ to express the value of a timeout, rather than a fixed constant, is illustrated in~\Cref{ex:delayed_timeout}.

Process \PCalc*{\If*{\Const}~\Then{P}~\Else{Q}}\ is a conditional statement, except that the condition $\delta$ is on timers. 
Syntactically, the condition is expressed as a time constraint $\delta$ in~\cref{eq:types_constraints}, but instead of clocks, defined on the timers previously set by that process.
%
%As a simplification we only consider \Const*\ conditions and not boolean variables.
%
Process $\PFuncDelay$ models time passing for an unknown duration described by $\delta$, and is at runtime reduced to process $\PFuncDelay[t]$ if $\models\Const\Subst[\ValTime][x]$. 
% In $\PFuncDelay$ we assume $\delta$ to have only one free name $x$.
In $\PFuncDelay$ we assume $\delta$ is a constraint on a single clock $x$. 
The name of the clock here is immaterial, where $x$ is a syntactic tool used to determine the duration of a time-consuming (delay) action at run-time. 
In this sense, assume $x$ is bound within $\PFuncDelay$.
%Constraint $\delta$ is a constraint on single clock, used here just to define : this is not one of the clocks set by the process, used here just for the pur of a non-deterministically determined, albeit constraint, amount of time $t$, where $t$ is any solution of $\delta$, which is a constraint on a single clock. For example, $\mathtt{delay}(X<3).P$ may consume any amount of time $t$ which is a solution of $x<3$. 
%
%Recursive definitions and recursive calls are standard mostly unchanged from~\cite{Bocchi2019}, where a process \Prc*\ is defined as a process variable $\RecPrcCall$ in \Qrc*.
Recursive processes are defined by a process variable $\RecVar$ and parameters \RecSetMsg*, \RecSetTimers*\ and \RecSetRoles*\ containing \emph{base type} values, timers and session channels, respectively.  
% In recursive definitions and recursive calls, a process variable $\RecVar$ takes 3 lists as parameters: \RecSetMsg*\ containing values $\pl$ of \emph{base types}, \RecSetTimers*\ containing timers and their valuations, and \RecSetRoles*\ containing channels.
%
% Process $(\nu pq)\Prc$ is the outer-most scope of a (binary) session between endpoints $p$ and $q$, where all communication is defined within \Prc*.
%
% As standard, within a session participant $p$ sends messages over $pq$ and receives messages from $qp$ (and visa versa for $q$).
%
% In our calculus \PCalc*{\On{p}\Send{l}[v]}\ describes $p$ sending $lv$ on channel $pq$ and \PCalc*{\On{p}\Recv{l}[b]}\ describes $p$ receiving $lb$ on channel $qp$.
%
The end process is \PrcEnd*.
The error process is \PrcErr*.

As standard~\cite{Bocchi2014,Honda2008,Yoshida2007}, the process calculus allows parallel processes \Parl*{\Prc,\Qrc} and scoped processes $(\nu pq)\Prc$ between endpoints $p$ and $q$. 
Endpoints communicate over pairs of channels $pq$ and $qp$, each with their own unbounded FIFO buffers $h$.\footnote{Similar to the queues used by configurations in~\Cref{ssec:types_semantics}.}
%
Within a session, $p$ sends messages over $pq$ and receives messages from $qp$ (and vica versa for $q$). 
We have adopted the simplifying assumption in~\cite{Bocchi2019} that sessions are already instantiated. 
Therefore, rather than relying on reduction rules to produce correct session instantiation, we rely on a syntactic well-formedness assumption. 
A \emph{well-formed process} consists of sessions of the form  $(\nu pq)(\Parl{{P},{Q},{{pq}:{h}},{{qp}:{h'}}})$, which can be checked syntactically as in~\cite{Bocchi2019}.

\begin{example}[Parametric Timeouts]\label{ex:delayed_timeout}
%
Consider the process below:
% The value of a parametric timeout is best illustrated by considering the following:
\[\PCalc{%
    {\mathtt{delay}(z<2)}.%
    % {\mathtt{set}(x)}.%
    \On{p}~\Recv{msg}:{P}~\After<{3}:{Q}%
}\]
It expresses a timeout of $3$ after a delay with a duration between $0$ and $2$ time units (whatever this delay turns out to be). To express a timeout of $3$ \emph{despite} prior execution of a time-consuming action, we need a way to tune the timeout with the actual delay of the time-consuming action. 
% At runtime, there will be a delay with a duration between 0 and 6 time units, which will affect the duration the process is able to receive a message.
% Observe that the process will wait to receive longer than intended.
%
A \emph{parametric timeout} can model this behaviour:
% This can be remedied by setting a process timer before such delays, and using it in a parametric timeout:
% This can be remedied by reversing the ordering of the set and delay processes, as follows:
\[\PCalc{%
    {\mathtt{set}(x)}.%
    {\mathtt{delay}(z<2)}.%
    \On{p}~\Recv{msg}:{P}~\After<{3-z}:{Q}%
}\]
By setting the timeout as an expression, $3-x$, with parameter $x$ reflecting the passage of time, we allow the process to compensate for the exact delay occurred. 
%
% In the process above, the process can immediately continue as $Q$ when appropriate.
%
%Best practice is therefore to set any timers before any immediately proceeding $\mathtt{delay}(\Const).P$ process.
%
\end{example}

%A process can have more than one ongoing session. We expect a process to have all necessary queues (present and well placed) for each session it implements. 
%, as in~\cite{Bocchi2019}.% is a \emph{well-formed} process modelling a session between endpoints $p$ and $q$, where $P$ and $Q$ may communicate over channels $pq$ and $qp$.
% A binary session is comprised of two endpoints each fulfilling a role \PrcP*, \PrcQ*.
% Messages are exchanged over pairs of directed channels denoted by their direction (e.g., endpoint \PrcP*\ sends to \PrcQ*\ over channel $\PrcP\PrcQ$, and vice versa).
%
% Messages are added to the channel's buffer \PCalcBuffer*\ as they arrive.
% Messages \PrcMsg*\ exchanged by processes can either consist of a label and a data-type as in~\cref{eq:types_syntax}, or a role \PrcP*\ during delegation.
%
%Recursive processes \RecVar*\ are comprised of 
%\begin{inline}+;
%   \item \RecSetMsg*\ containing messages 
%   \item \RecSetChan*\ containing channels 
%   \item \RecSetTimers*\ containing process timers
%\end{inline}
%
%Process \PrcRecDef*\ associates a recursive variable \RecPrcVar*\ to a given %\Prc*, which can be called by \RecPrcCall*\ within \Qrc*.
%
%
%
% \TODO[example of process with mixed-choice from earlier in section or~\cref{ex:weak_persistency}]
\endinput

\paragraph*{Sending Messages}\hfill\ \PCalcSend*\par
Describes a message \PrcMsg*\ being sent as role \PrcP*\ along the channel corresponding to this session, before continuing as the process \Prc*.
Notably, there does not exist a means of non-deterministic selection, and therefore all messages sent are explicitly intended.
Instead, the \TTIf*\ structure should be used to determine which message should be sent in a scenario where several are possible.
A set of competing sending actions would therefore need to be separated into a series of cascading \TTIff*\ statements, which can be ordered by priority.

\paragraph*{Receiving Messages}\hfill\ \PCalcRecv*\par
Describes a set of messages \PrcMsg*_i\ waiting to be received by a role \PrcP*\ along the appropriate incoming channel for this session, within \PrcAfter*\ units of time. In the case where \PrcAfter*\ units of time does elapse without a message being received, the process can continue as process \Qrc*.
In the case that message \PrcMsg*_i\ is received within the given amount \PrcAfter*, the process continues as \Prc*_i.
\begin{note}
   This is an extension to the corresponding construct in~\cite{Bocchi2019}, which would instead yield a \emph{runtime error} if \PrcAfter*\ were exceeded, and the process would fail.
\end{note}
%
\begin{note}
   If $\PrcAfter=\infty$, then \PCalcRecv*\ may be written as \PCalcRecv*|.
\end{note}

\paragraph*{Recursive Processes}\hfill\ \RecPrcVar*\par
Recursion variables \RecVar*\ are a triple comprised of the following sets
\begin{inline}+;
   \item \RecSetMsg*\ containing all messages \PrcMsg*\ received
   \item \RecSetChan*\ containing all channels available to the process
   \item \RecSetTimers*\ containing all timers set by the process along with their current values
\end{inline}
These sets are determined when a recursive point is defined by \PrcRecDef*, which associates a recursive variable \RecPrcVar*\ to a given \Prc*. Recursion occurs when a recursive call of the form \RecPrcCall*\ is reached.

\paragraph*{Delaying Processes}\hfill\ \PFuncDelay*\par
Processes are able to express a degree of delay caused by time-consuming actions outside the scope of modelling their communication. While the function \PFuncTime*\ will wait the exact value of \ValTime*, the function \PFuncDelay*\ will wait some value of time that satisfies the constraint given by \Const*; as shown by \LblPrcRedDelay*\ and \LblPrcRedDet*\ in~\cref{fig:prc_reduc}.

\paragraph*{Process Timers}\hfill\ \PCalcSetTimer*\par
Processes may set timers locally. The names used for process timers are the same as the ones used for types, but are distinctly different, and not at all related. The function \PCalcSetTimer*\ will sets the value of timer \Tix*\ to 0, instantiating it if necessary.
This feature allows clock constraints and resets found in the types to be more closely adhered to by processes, which becomes important when considering timeouts and mixed-choice.

\subsubsection{Interleaving Mixed-Choices}
Together, the sending and receiving constructs expressed in this calculus, along with the \TTIf*\ structure, allow \TODO[example?]
