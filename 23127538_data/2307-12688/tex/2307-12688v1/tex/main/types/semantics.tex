
We present the semantics of TOAST, building on those given in~\cite{Bocchi2019}; any changes are highlighted.
%
Following~\cite{Bocchi2019}, we define the semantics using three layers: (1) \emph{configurations}, (2) \emph{configurations with queues} that model asynchronous interactions, and (3) \emph{systems} that model the parallel composition of configurations with queues.
% Any changes from~\cite{Bocchi2019} are highlighted.
% \footnote{Any changes from~\cite{Bocchi2019} are highlighted.}
%
% The semantics, for all layers, are defined over the labels $\ell$ given below:
The semantics are defined over the labels $\ell$ given below:
% in~\cref{eq:type_labels}, which distinguish between communication, time, and silent actions:
%
% A message \Msg*\ consists of a label $l$ and a data type \DataType*.%, similar to~\cref{eq:types_syntax}.
%
\begin{minieq}\label{eq:type_labels}
  \ProgAction::=\TypComm\Msg
  ~\mid~\ValTime
  ~\mid~\SiltAction
  %
  \qquad
  \Msg::=\DefMsgType
  %
  \qquad
  \TypComm ::= \TypSend~\mid~\TypRecv
  %
  % \qquad
  % \Queue ::= \emptyset~\mid~\Msg;\Queue
  %
\end{minieq}
% \vspace{-2ex}
\noindent where $\ell$ is either a communication, time, or silent action, and $\Msg$ is a message.

\subsubsection{Configurations} 
A configuration \VIso*\ is a pair $(\nu, \TypeS)$. 
% The valuation models the change in clocks values during a virtual executions of a type.
%
The semantics for configurations are defined by a Labelled Transition System (LTS) over configurations, the labels in~\cref{eq:type_labels}, and the rules given in~\Cref{fig:typesemantics_tuple}.
%
% A transition \Trans*{\VIso}:{\ValTime,\CommMsg}[\VIso']\ indicates the composition \Trans*{\Trans{\VIso}:{\ValTime}[{\VIso}'']}:{\CommMsg}[\VIso']\ where ${\VIso}''$ is some intermediate configuration.
% \marginpar{``where ${\VIso}''$ is intermediary.''}
% \marginpar{Review change here:}
%
\input{tex/figs/configs/rule_iso.tex}

Rule \LblCfgIsoInteract*\ deviates from~\cite{Bocchi2019} and handles choice types. By this rule, a configuration performs one action with index $j\in I$ provided that the constraint $\delta_j$ is satisfied in the current valuation $\nu$ ($\nu\models\delta_j$).
All clocks in $\lambda_j$ are reset to 0 in the resulting configuration's valuation of clocks.
Rule \LblCfgIsoUnfold*\ unfolds recursive types.
Rule \LblCfgIsoTick*\ describes time passing.
%
A transition \Trans*{\VIso}:{\ValTime,\CommMsg}[\VIso']\ indicates \Trans*{\Trans{\VIso}:{\ValTime}[{\VIso}'']}:{\CommMsg}[\VIso'], where ${\VIso}''$ is some intermediate configuration. We write \Trans*{\VIso}:{\ValTime,\CommMsg}[] if there exists $\VIso'$ such that \Trans*{\VIso}:{\ValTime,\CommMsg}[\VIso']. 

\subsubsection{Configurations with queues}
A configuration with queues \VSoc*\ is a triple $(\nu, \TypeS, \Queue)$ where $\Queue$ is a FIFO queue of messages which have been received but not yet processed.
A queue takes the form $\Queue ::= \emptyset \mid \Msg;\Queue$ thus is either empty, or has a message at its head.
%
% The semantics of configurations with queues is defined by an LTS over the labels in~\cref{eq:type_labels} and the rules in~\cref{fig:typesemantics_triple}. 
%
The transition \Trans*{\VSoc}:{\ValTime,\CommMsg}[{\VSoc}']\ is defined analogously to \Trans*{\VIso}:{\ValTime,\CommMsg}[\VIso'].
% implies $\exists {\VSoc}'', \ValTime, \VSoc', \SendMsg: \Trans{\Trans{\VSoc}:{\ValTime}[{\VSoc}'']}:{\SendMsg}[\VSoc']$.
%
The semantics of configurations with queues is defined by an LTS over the labels in~\cref{eq:type_labels} and the rules in~\Cref{fig:typesemantics_triple}. 

\input{tex/figs/configs/rule_soc.tex}

Rule \LblCfgSocSend*\ is for sending a message. Message reception is handled by two rules: \LblCfgSocEnqu*\ inserts a message at the back of \Queue*, and \LblCfgSocRecv*\ removes a message from the front of the queue.
%
Rule \LblCfgSocTime*\ is for time passing which is formulated in terms of a future-enabled configuration, given in~\Cref{def:configs_fe}.
The second condition in the premise for rule \LblCfgSocTime*\ ensures the latest-enabled action is never missed by advancing the clocks.
%
The third condition models an urgent semantics, ensuring messages are processed as they arrive.
Urgency is critical for reasoning about progress.

\begin{definition}[Future-enabled Configurations (\isFE*)]\label{def:configs_fe}
For some $\Msg$, a configuration \VIso*\ (resp. a configuration with queues \VSoc*) is \emph{future-enabled (\isFE*)} if
  $\exists\ValTime\in\RatSet : %
  \Trans{\VIso}:{\ValTime,\CommMsg}$ 
  (resp. \Trans*{\VSoc}:{\ValTime,\CommMsg}).
\end{definition}

\subsubsection{Systems} Systems are the parallel composition of two configurations with queues,
% (as we consider binary types), 
written as \Parl*{\CSoc_1,\CSoc_2} or \VSys*.
The semantics of systems is defined by an LTS over the labels in~\cref{eq:type_labels} and the transition rules in~\Cref{fig:typesemantics_sys}.
%
\input{tex/figs/configs/rule_sys.tex}

Rule \LblCfgSysLComm*\ handles asynchronous communication where \VSoc*_1\ sends a message \Msg*\ via rule \LblCfgSocSend*, which arrives at the queue of \VSoc*_2\ via rule \LblCfgSocEnqu*.
Rule \LblCfgSysRComm*\ is symmetric, allowing for \VSoc*_2\ to be the sending party, and is omitted.
% silent communications when a sending action matches the insertion of a message in the receiver's queue.
%
Rule \LblCfgSysLPar*\ allows \VSoc*_1\ to process the message at the head of \Queue*_1\ via \LblCfgSocRecv*.
Rule \LblCfgSysRPar*\ is symmetric, allowing \VSoc*_2\ to receive messages, and is omitted.
% component \CSoc*_1\ to make a silent action, namely process a message in the queue.
%
%
By rule \LblCfgSysWait*\ time passes consistently across systems.
%
% Together, these rules provide a clear loop-style behaviour, such as:
% $\LblCfgSysWait \rightarrow \LblCfgSysLComm \rightarrow \LblCfgSysRPar \rightarrow \dots$.

\begin{example}[Weak Persistency]\label{ex:weak_persistency}
  %
In language-based approaches to timed semantics~\cite{Krcal2006}, time actions are always possible, even if they bring the model into a stuck state by preventing available actions. Execution traces are then filtered a posteriori, removing all ‘bad’ traces (defined on the basis of final states). 
%
In contrast, and to facilitate the reasoning on process behaviour, we adopt a process-based approach, e.g.,~\cite{Bartoletti2018,Bocchi2019}, that only allows for actions that characterise \emph{intended} executions of the model.
%
Precisely, we build on the semantics in~\cite{Bartoletti2018} for asynchronous timed automata with mixed-choice, where time  actions are possible only if they do not disable: (1) the latest-enabled sending action, and (2) the latest-enabled receiving action if the queue is not empty. This ensures that time actions preserve the viability of at least one action (\emph{weak-persistency)}. In our scenario, constraint (1) is too strict. Consider type $S$ and its dual below:
% \footnote{The clocks names used in a constraint are immaterial to their duality.}
  %
  \begin{minieq}*%\label{eq:ex_weak_persistency}
    % \resizebox{\textwidth}{!}{$%
    \begin{array}[c]{c p{0.5ex} c}
      \begin{array}[c]{lcl}
        \TypeS & = & %
        \IChoice[%
        \IType!{data\text{<}String\text{>}}[x<3].{\TypeS'},%
        \IType?{timeout}[x>4]%
        ]%
      \end{array}
      &  & %
      \begin{array}[c]{lcl}
        \Dual & = & %
        \IChoice[%
        \IType?{data\text{<}String\text{>}}[y<3].{\Dual'},%
        \IType!{timeout}[y>4]%
        ]%
      \end{array}
    \end{array}
    % $}%
  \end{minieq}
  %
  \noindent According to (1), it would never be possible for $S$ to take the timeout branch since a time action of $t\geq 3$ would disable the latest-enabled send. 
  This is reasonable in~\cite{Bartoletti2018} because, in their general setting, there is no guarantee that a timeout will indeed be received. 
  Unlike~\cite{Bartoletti2018}, we can rely on duality of $\overline{S}$ (introduced later in this section),  which guarantees that $\overline{S}$ will send a timeout message when $y>4$. 
  Our new rule \LblCfgSocTime*\ -- condition (persistency) --  implements a more general constraint than (1), requiring that one latest-enabled (send or receive) action is preserved. 
  Constraint (2) remains to implement urgency and, e.g., prevents $\overline{S}$ from sending a timeout if a message is waiting in the queue when $y<3$.
  %
  %The previous semantics requires that \ITypeAct*![data\text{<}String\text{>}]\ is not missed and effectively disables \ITypeAct*?[timeout], even when viable.
  %
  % This yields behaviour where the possibility of performing one choice is inversely dependent on the viability of another, which is not behaviour described by the types.
 % Options in a choice should be independent from each other~\cite{NEEDED}, but in the case of \Dual*, \ITypeAct*?[timeout]\ is dependent on \ITypeAct*![data\text{<}String\text{>}]\ never having been viable.
  % \marginpar{Ask Laura for cite}
  %
  % The message $\mathtt{timeout}$ is analogous to a timeout message in a real system that should follow when $\mathtt{data\text{<}String\text{>}}$ is not sent.
  %
  % generalises this condition, only requiring that the latest possible action is never missed, regardless of direction.
  % rather than latest possible \emph{sending action}.
  %
\end{example}
