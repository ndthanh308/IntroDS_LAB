
%Here, by correct protocol we intend a protocol that does not get stuck: all reachable are either final (e.g., $\tend$) or allow for further communication actions.\footnote{
%Correctness is critical to ensure, via type-checking, that a protocol implementation enjoys progress and lack of communication mismatches.}
%}

In the untimed scenario, the composition of a binary type with its dual characterises a \emph{protocol}, which specifies the ``correct'' set of interactions between a party and its co-party. The dual of a type, formally defined below, is obtained by swapping the directions ($!$ or $?$) of each interaction:
% The duality of TOAST is formally given in~\cref{def:types_dual}.
%
\input{tex/defs/types/duality.tex}
%
\noindent Unfortunately, when annotating session types with time constraints, one may obtain protocols that are infeasible, as shown in~\Cref{ex:junk_types}.
%
This is a known problem, which has been addressed by providing additional conditions or constraints on timed session types, for example compliance~\cite{Bartoletti2017}, feasibility~\cite{Bocchi2014}, interaction enabling~\cite{Bocchi2015}, and well-formedness~\cite{Bocchi2019}.
%[Bartoletti,Cimoli,Murgiaâ€™16]

Building upon~\cite{Bocchi2019}, well-formedness is given as a set of formation rules for types. The rules check that in every reachable state (which includes every possible clock valuation) it is possible to perform the next action immediately or at some point in the future, unless the state is final. (This is formalized as the progress property in~\Cref{def:types_progress}.) By these rules, the type in~\Cref{ex:junk_types} would not be well-formed.
%
% \marginpar{Review change here:}
% The use of mixed-choice with asynchronous communications may lead to protocols that are not feasible or, more concretely, to systems (or types) that get stuck, even if they are well-formed in the sense of~\cite{Bocchi2019}.
% This is discussed in~\cref{ex:mixed_bad}.
The use of mixed-choice in asynchronous communications may result in infeasible protocols or, more concretely, systems (or types) that get stuck, even if they are well-formed in the sense of~\cite{Bocchi2019} (discussed in~\Cref{ex:mixed_bad}).

\begin{example}[Junk Types]\label{ex:junk_types}
   % Add a system that is not well formed in the sense of the old paper
   %
   Consider the \emph{junk type} defined below: %in~\cref{eq:ex_junk_types}.
   % \TypeS*\ is a \emph{junk type}.
   %
   \begin{minieq}*%\label{eq:ex_junk_types}
      % \begin{array}[c]{c p{2ex} c}
      \begin{array}[c]{lcl}
         \TypeS & = & %
            % {}.\left\{%
            % \right\}%
        !a~(x>3,~\emptyset).~\{%
        !b~(y=2,~\emptyset).\TypeEnd,~%
        ?c~(2<x<5,~\emptyset).\TypeEnd%
        \}
      \end{array}
      % &  & %
      % \begin{array}[c]{lcl}
      %    \TypeS' & = & %
      %    \IType!{a}[3<x<5][y].{%
      %    \IChoice[%
      %    \IType!{b}[y=2],%
      %    \IType?{c}[x<5]%
      %    ]%
      %    }%
      % \end{array}
      % \end{array}
   \end{minieq}
   %
   Assume all clocks are 0 before $a$ is sent.
   After $a$ is sent, all clocks hold values greater than 3.
   The constraint on sending $b$ is never met, and the one on receiving $c$ may not be met.
   % The constraints on receiving $c$ 
   % Message $b$ is never able to be sent as the constraint of $y=2$ is impossible given that after $a$ is sent the clocks may hold any value greater than 3.
   % Message $c$ can only be received \emph{sometimes}, depending on how urgently $a$ is sent.
   Types with unsatisfiable constraints are called \emph{junk types}~\cite{Bocchi2019}.
   \TypeS*\ can be amended to obtain, for example, $S'$ or $S''$ below.
\begin{minieq}*%\label{eq:ex_junk_types_fixed}
      % \begin{array}[c]{c p{2ex} c}
      % \begin{array}[c]{lcl}
      %    \TypeS & = & %
      %    \IType!{a}[x>3].{%
      %    \IChoice[%
      %    \IType!{b}[y=2],%
      %    \IType?{c}[x<5]%
      %    ]%
      %    }%
      % \end{array}
      % &  & %
      \begin{array}[c]{lcl}
         S' & = & %
        !a~(x>3,~\{y\}).~\{%
        !b~(y=2,~\emptyset).\TypeEnd,~%
        ?c~(2<x<5,~\emptyset).\TypeEnd%
        \}\\
        S'' & = & %
        !a~(3<x<5,~\emptyset).~\{%
        !b~(y=2,~\emptyset).\TypeEnd,~%
        ?c~(2<x<5,~\emptyset).\TypeEnd%
        \}
      \end{array}
      % \end{array}
   \end{minieq}
   %
   $S'$ makes both options of the choice satisfiable by resetting clock $y$, while $S''$ makes at least one option ($?c$) always satisfiable by changing the first constraint.   
\end{example}

\begin{example}[Unsafe Mixed-choice]\label{ex:mixed_bad}
   % Add a system that get stuck because of mixed-choice
   A mixed-choice is considered \emph{unsafe} if actions of different directions compete to be performed (i.e., they are both viable at the same point in time). 
   %
   Consider system \VSys*, where $\VSoc_1 = (\nu_0,~{S_1},~\emptyset)$, $\VSoc_2=(\nu_0,~{S_2},~\emptyset)$, and types $S_1$ and $S_2$ are dual as defined below:
   %
   %  sending and receiving actions overlap and different 
   % These types describe an \emph{unsafe mixed-choice}, where sending or receiving actions have overlapping constraints and compete to be performed at the same instant.
   % These types describe a choice where a participant is able to send and receive a message at the same time due to both $\mathtt{a}$ and $\mathtt{b}$ having overlapping constraints.
   %
   \begin{minieq}*%\label{eq:ex_mixed_bad}
      \begin{array}[c]{c p{4ex} c}
         \begin{array}[c]{lcl}
            \TypeS_1 & = & %
            \IChoice[%
            \IType?{a}[x<5],%
            \IType!{b}[x=0].{\TypeS'_1}%
            ]%
         \end{array}
         &  & %
         \begin{array}[c]{lcl}
            S_2 & = & %
            \IChoice[%
            \IType!{a}[y<5],%
            \IType?{b}[y=0].{\TypeS'_2}%
            ]%
         \end{array}
      \end{array}
   \end{minieq}
   
   \noindent In the system \VSys*\ it is possible for both \Trans*{\VSoc_1}:{!,b}[\VSoc'_1]\ and \Trans*{\VSoc_2}:{!,a}[\VSoc'_2]\ to occur at the same time.
   %
   In the resulting system \Parl*{{(\nu_0,~{S'_1},~{a})},{(\nu_0,~{\TypeEnd},~{b})}}
    neither message can be received, and $S'_1$ may be stuck waiting for interactions from $S'_2$ indefinitely. % violates the notion of \emph{communication safety}~\cite{NEEDED}.
   % violates the notion of communication safety~\cite{NEEDED} by neither \VSoc*'_1\ or \VSoc*'_2\ are able to receive the message sent by the other. 
   % \VSoc*'_1\ and \VSoc*'_2\ are \emph{incompatible}.
   %
   % Such a system is unable to make progress and has reached \emph{deadlock}.
   %
   % The \emph{fairness} of such choices is also a concern, as in practice a priority must be given to competing actions with different directions.
   % sending or receiving actions.
   % Additionally, the \emph{fairness} of such choices is not clear, and requires either sending or receiving actions to be given priority when both are viable at the same time.
   %
\end{example}

\subsubsection*{Well-formedness}
In this work we extend well-formedness of~\cite{Bocchi2019} so that progress is guaranteed in the presence of mixed-choice. 
The formation rules for types are given in~\Cref{fig:types_rule}; rules differing from \cite{Bocchi2019} are highlighted.
%
Types are evaluated against judgements of the form: \TypEnvCond*:{\RecEnv;\,\Const}\ where
\RecEnv*\ is an environment containing recursive variables, and \Const*\ is a constraint over all clocks characterising the times in which state \TypeS*\ can be  reached.
%
\input{tex/figs/types/rule_formation.tex}

Rule \LblTypChoice*\ checks well-formedness of choices with three conditions:
the first and third conditions are from the branching and delegation rules in~\cite{Bocchi2019}, respectively; the second condition is new and critical to ensure progress of mixed-choice.
%
By using the weakest past of all constraints ($\downarrow \bigvee_{i \in I}{\delta_i}$) only one of the options within the choice is required to be \emph{always} viable, for the choice to be well-formed.
%
The first condition (feasibility) ensures that, for each option in a choice, there exists an environment $\gamma$ such that the continuation $\TypeS_i$ is well-formed, given the current constraints on clocks $\delta_i$ (updated with resets in $\lambda_i$).
% This ensures that the proceeding type of each option can continue to be checked for well-formedness, even if itself is not \emph{always} viable in the current choice.
% By the first condition (feasibility) a choice is well-formed with respect to the weakest past among all options ($\downarrow \bigvee_{i \in I}{\delta_i}$), given that each continuation $\TypeS_i$ is well-formed in an environment $\gamma_i$, which includes the corresponding guard 
%
This ensures that in every choice, there is always at least one viable action; it would, for example, rule out the type in~\Cref{ex:junk_types}.
% This condition rules out types in which all subsequent actions can only be performed in the past; it would, for example, rule out the type in~\cref{ex:junk_types}.
%
The second condition (mixed-choice) requires all actions that can happen at the same time to have the same (send/receive) direction.
This condition allows for types modelling timeouts, as in~\Cref{ex:weak_persistency}, and rules out scenarios as the one in~\Cref{ex:mixed_bad}.
%
The third condition (delegation) checks for well-formedness of each delegated session with respect to their corresponding initialization constraint $\delta'$.
%
Rule \LblTypEnd*\ ensures termination types are \emph{always} well-formed.
Rule \LblTypRec*\ associates, in the environment, a variable $\alpha$ with an invariant $\delta$.
%
% \TODO[An algorithm to derive such invariant can be find in ... -- Shall we put it here?!?.]
%
% The other rules are straightforward.
% ; see the commentary~\cite{Bocchi2019}.
Rule \LblTypVar*\ ensures recursive calls are defined.
%
\begin{definition}[Well-formedness]\label{def:types_wf}
   %
   % A type $\TypeS$ is well-formed with respect to $\nu$ if $\exists\delta:{\nu\models \delta}$ and $\emptyset;\delta\vdash \TypeS$. A type $\TypeS$ is well-formed if it is well-formed with respect to $\nu_0$.
   A type $\TypeS$ is well-formed with respect to $\nu$ if there exists $\delta$ such that $\nu\models \delta$ and $\emptyset;\delta\vdash \TypeS$. A type $\TypeS$ is well-formed if it is well-formed with respect to $\nu_0$.
\end{definition}
%
\noindent Well-formedness, together with the urgent receive features of the semantics (rule $\LblCfgSocTime$ in~\Cref{fig:typesemantics_triple}) ensures that the composition of a well-formed type $\TypeS$ with its dual $\overline \TypeS$ enjoys progress.
%
A system enjoys progress if its configurations with queues can continue communicating until reaching the end of the protocol, formally:
%
\begin{definition}[Type Progress]\label{def:types_progress}
   %
   A configuration with queues $\SocCfg$ is \emph{final} if $\VSoc=\CSoc;[\TypeEnd]:{\emptyset}$.
   A system \VSys*\ \emph{satisfies progress} for all \VSys*'\ reachable from \VSys*, either:
   \begin{itemize}
       \item \VSoc*'_1\ and \VSoc*'_2\ are \emph{final}, or
       \item there exists a $t\in\RatSet$ such that \Trans*{\VSys'}:{\ValTime,\SiltAction}.
   \end{itemize}
\end{definition}
%

% Formally defined in~\cref{def:configs_compat}.
%
% \marginpar{Rule \LblPrcTypRes*\ uses the compatibility notation! Should we move the definition back in the the main paper, and replace this? --Jonah}
% : (1) the types in $\mathbf{S}_1$ and $\mathbf{S}_2$ are dual (stable state), or (2) one of the two buffers is empty (equivalently to a half duplex automaton) and the type in the configuration with a non-empty buffer is eventually able to process the message. 
%
\begin{restatable}[Progress of Systems]{theorem}{ThmProgress}\label{thm:progress}
   %
   If $\TypeS$ is \emph{well-formed} against \ValClocks*_0\ then
   \linebreak
   \CSys*[\CSoc[\ValClocks_0]:{\emptyset}][\CSoc[\ValClocks_0];[\Dual]:{\emptyset}]\ \emph{satisfies progress}.
   % \vspace{-1ex}
\end{restatable}

\noindent The main result of this section is that, for a system composed of \emph{well-formed} and dual types, any state reached is either \emph{final}, or allows for further progress.
%
By ensuring a system will make progress, it follows that such a system is free from communication mismatches and will not reach deadlock.

% \CSys*[\CSoc[\ValClocks_0]:{\emptyset}][\CSoc[\ValClocks_0];[\Dual]:{\emptyset}], any state reached is either \emph{final}, or allows for further communication.
%
The main differences with~\cite{Bocchi2019} is not in the formulation of the theory (e.g., \Cref{def:types_progress,def:configs_compat}, and the statement of~\Cref{thm:progress} are basically unchanged) but in the proofs that, now, have to check that the conditions of rule \LblTypChoice*\ are sufficient to ensure progress of asynchronous mixed-choice.
%
Additionally, the proof of progress in~\cite{Bocchi2019} relies on receive urgency. Because of mixed-choice, it is necessary to reformulate (and relax) urgency in the semantic rule \LblCfgSocTime*\ in~\Cref{fig:typesemantics_triple}. 
Despite generalising the notion of urgency the desired progress property can still be attained (see~\Cref{ex:weak_persistency} for a discussion).  


The proof of~\Cref{thm:progress} proceeds by showing that system \emph{compatibility}~\cite{Bocchi2019} is preserved by transitions. The formal definition of compatibility is given in~\Cref{def:configs_compat}.
%
\input{tex/defs/configs/sys/compat.tex}
\noindent Informally, $\VSoc_1\bot~ \VSoc_2$ if:
(1) at most one of their queues is non-empty (equivalent to a half-duplex automaton),
(2) if both queues are empty, then $\VSoc_1$ and $\VSoc_2$ have dual types and same clock valuations, 
and (3) and (4) a configuration is always able to receive any message that arrives in its queue.
% \noindent The proof of progress in~\cite{Bocchi2019} relies on receive urgency. Because of mixed-choice, it is necessary to reformulate (and relax) urgency in the semantic rule \LblCfgSocTime*\ in~\cref{fig:typesemantics_triple}. 
% Despite generalising the notion of urgency the desired progress property can still be attained (see~\cref{ex:weak_persistency} for a discussion).  
%and builds upon the \emph{synchronous semantics} of asynchronous systems of~\cite{Krcal2006} to ensure that sending actions are never missed.
%
%As discussed in~\cref{ex:weak_persistency} our semantics elevate this from individual configurations to allow time to pass such that the latest possible  action is never missed.
%
%Therefore, our proof of progress takes a more system-wide perspective, and more relies on more that systems are composed of dual types to ensure that that such systems are free from communication-mismatches and enjoy progress.
%
% a system guaranteed to satisfy progress, 
% Progress is critical to ensure for a system, via type-checking, that 
% that a protocol implementation does not reach deadlock and is free from communication mismatches.