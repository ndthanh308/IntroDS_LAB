
The syntax of TOAST (or just \emph{types}) is given in~\cref{eq:types_syntax}.
%
A type \TypeS*\ is a choice $\simplechoice$, recursive definition $\TypRecDef.\TypeS$, call $\TypRecCall$, or termination type $\TypeEnd$.
%
\input{tex/figs/types/syntax.tex}

\noindent Type $\simplechoice$ models a choice among options $i$ ranging over a non-empty set $I$. Each option $i$ is a selection/send action if $\TypComm=\TypSend$, or alternatively a branching/receive action if $\TypComm=\TypRecv$. 
An option sends (resp. receives) a label $l$ and a message of a specified data type \DataType*\ is delineated by $\langle\cdot\rangle$.
The send or receive action of an option is guarded by a time constraint \Const*. After the action, the clocks within \RSet*\ are reset to 0.
%
Data types, ranged over by $T$, $T_i$, $\ldots$ can be sorts (e.g., natural, boolean), or higher order types $(\delta,S)$ to model session delegation.
Only the message label is exchanged when the data type is \BTypeNone*.
%
Labels of the options in a choice are pairwise distinct.
%
Recursion and terminated types are standard.

\paragraph{Remarks on the notation}
One convention is to model the exchange of payloads as a separated action with respect to the communication of branching labels. 
%
In this paper we follow~\cite{Bocchi2015,Yoshida2021}, and model them as unique actions. 
When irrelevant, we omit the payload, yielding a notation closer to that of timed automata.
% blur the distinction between labels and data, abbreviating the pair $\IMsgType$ with \texttt{a} or \texttt{b}.
%
% This yields a notation closer to that of timed automata, simplifying the encoding of examples.
%
% The notation $\IMsgType$ is still when we do type checking of payloads and handle higher order types.
%
% In the paper we often abstract from the distinction between labels and data, and identify the pair $\IMsgType$ with \texttt{a} or \texttt{b}, as in the time automata notation. 
% We omit the payload when not relevant; e.g.: an action $!~{\mathtt{hello\text{<}None\text{>}}}$ may be written as $!~\mathtt{hello}$.
%% $\mathtt{\text{<}None\text{>}}$
%
% We write $\TypInteract|$, omitting the label, in choices with one option, and omit the payload whenever not relevant.

\endinput
The syntax of Timeout Session Types is as in~\cref{eq:types_syntax}; where
\begin{inline}+
  %
  \item \TypeS*\ is a session type
  \item \DataType*\ is a data type
  \item \TypComm*\ is a communication direction
  \item \MsgType*\ is a message type
  %
\end{inline}
Hereafter, a \emph{type} refers to a session type \TypeS*.
% Session types are defined recursively, and specify how a participant may behave and communicate as part of a session.
A type of \TypeEnd*\ describes a termination point of the session; no more types may follow.
\input{tex/figs/types/syntax.tex}

\newcommand{\choice}{\mathtt c}

\newcommand{\simplechoice}{ \{ \choice_i.S_i \}_{i\in I} }

\[        \begin{array}[c]{lcl p{2ex} lcl p{4ex} lcl}
    %
    \TypeS %
    & ::= &                                                                % * 
    \simplechoice    \mid ~
    %
    \TypRecDef.\TypeS   ~\mid ~
    %
    \TypRecCall    ~ \mid ~
    %
    \TypeEnd
    \\[0.3cm]
    \choice & ::= & \TypComm \IMsgType (\delta,\gamma)\qquad \TypComm \in \{
    \TypSend, \TypRecv \
    \}
    \\[0.3cm]
    \DataType            % 
    & ::= & \BTypeNat \mid  \BTypeBool \mid   \ldots\mid \TmpTypBTDelegate
  \end{array}
\]

A type \TypeS\ can be a choice type $\simplechoice$, a recursive definition $\TypRecDef.\TypeS$, a recursive call $\TypRecCall$, and the terminated type $\TypeEnd$.

Type $\simplechoice$ models a choice among a number of options $i$ over a non-empty set $I$. Each option $i$ can be either a selection/send action, if $\square = \, !$, or a branching/receive action, if $\square = \, ?$. An option sends (resp. receives) a label $l$ and a message of a specified data type $T$. The send or receive action of an option is guarded by a time constraint $\delta$. After the action, the clocks within $\lambda$ are reset to 0.
Data types, ranged over by $T$, $T_i$, $\ldots$ can be  sorts (e.g., natural, boolean) or higher order types $(\delta,S)$ to model session delegation.
Labels of the options in a choice are pairwise distinct.
%
Recursion and terminated types are standard.

\paragraph{Remarks on the notation} It is often the case that the exchange of payload is modelled as a separated action with respect to the communication of branching labels. In this paper we model them as a unique action as in ~\cite{}. This yields a notation that is closer to time automata, hence making the encoding of examples more straightforward.
%
In the paper we often abstract from the distinction between labels and data, and identify the pair $\IMsgType$ with $\MsgType$, as in the time automata notation. The notation $\IMsgType$ is still useful in this paper when we do type checking of payloads and handle higher order types.
%
We write $\TypInteract|$, omitting the label, in choices with one option, and omit the payload whenever not relevant.

