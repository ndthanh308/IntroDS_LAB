In this section we reflect on the expressiveness of our mixed-choice extension, particularly in regard to \cite{Bocchi2019}, using examples to illustrate differences.
%
Furthermore, given the increase in expressiveness, we discuss how type-checking becomes more interesting with the inclusion of \texttt{receive\text{-}after}.


\subsection{Missing deadlines}
% Examples with an error in Q (timeout branch) to show we can encode missed deadlines as in ESOP 19 would be good. Also some illustration of NEQueue and WAIT maibe in relation to the occurrence of a timeoutÂ 
The process corresponding to $?a~(\mathtt{true},\emptyset).S$ is merely \PCalc*{\On{p}~\Recv{a}:{P}}\!, which waits to receive $a$ forever.
%
By way of contrast, $?a~(x<3,~\emptyset).S$, cannot receive when $x\geq 3$, requiring the process to take the form: $\PCalc{\On{p}~\Recv{a}:{P}~\After<{3}:{Q}}$, where $Q=\PrcErr$.
%
More generally, if an action is enabled when $x\geq 3$: \[\{?a~(x<3,~\emptyset).S,~?b~(3< x<5,~\emptyset).{S}'\}\] then, amending the previous process, \PCalc*{Q=\On{p}~\Recv{b}:{{P}'}~\After<{2}:{\PrcErr}}.

% \subsection{Retrying something}

% \marginpar{look into example of retyring something}
% Also an example of retry strategies to show we can do more than ESOP 19 (having a Q that does something interesting like retrying something or restarting) -- we can take inspiration from COORDINATION 22 (our paper on failures)



\subsection{Ping-pong protocol}
The example in this section illustrates the usefulness of time-sensitive conditional statements. The ping-pong protocol consists of two participants exchanging messages between themselves on receipt of a message from the other~\cite{Lagaillardie2022}.
%
One interpretation of the protocol is the following:
\[
\mu\alpha.%
\begin{array}[c]\{{l}\}
    {!ping(x\leq3,~\{x\})}.
    \begin{array}[c]\{{l}\}
        ?ping(x\leq3,~\{x\}).\alpha\\
        ?pong(x>3,~\{x\}).\alpha
    \end{array} \\[-1ex]\\
    {!pong(x>3,~\{x\})}.
    \begin{array}[c]\{{l}\}
        ?ping(x\leq3,~\{x\}).\alpha\\
        ?pong(x>3,~\{x\}).\alpha
    \end{array} 
\end{array}
\]
where each participant exchanges the role of sender, either sending ping early, or pong late.
%
Without time-sensitive conditional statements, the setting in~\cite{Bocchi2019} only allows implementations where the choice between the `ping' and the `pong' branch are hard-coded. 
In presence of non-deterministic delays (e.g., $\mathtt{delay}(z<6)$), the hard-coded choice can only be for the latest branch to `expire', and the highlighted fragment of the ping-pong protocol above could be naively implemented as follows (omitting $Q$ for simplicity):
%
\[
\mathtt{def\ }{\RecVar\left(\RecSetMsg;\RecSetTimers;\RecSetRoles\right)}={P}~\mathtt{in\ } P \qquad
P = \PCalc{\mathtt{delay}(z<6).~\On{p}\Send{pong}.{Q}}
\]
%
The choice of sending ping is \emph{always} discarded as it may be unsatisfied in \emph{some} executions. 
%
The calculus in this paper, thanks to the time-awareness deriving from a program timer $y$, allows us to \emph{potentially} honour each branch, as follows:
\[
\mathtt{def\ }{\RecVar\left({\RecSetMsg;\RecSetTimers;\RecSetRoles}\right)}={P}~\mathtt{in\ } P%
\qquad 
P = {\mathtt{set}(y)}.\PCalc{\mathtt{delay}(z<6).\begin{array}[t]{l}\If{y\leq 3}\\\Then{\On{p}\Send{ping}.{Q}}\\\Else{\On{p}\Send{pong}.{Q'}}\end{array}}
\]


\subsection{Mixed-choice Ping-pong protocol}\label{ssec:mixed-choice_ping_pong}
An alternative interpretation of the ping-pong protocol can result in an implementation with mixed-choice, as shown below:
\[
\mu\alpha.%
\begin{array}[c]\{{l}\}
    ?ping(x\leq3,~\{x\}).
    \begin{array}[c]\{{l}\}
        !pong(x\leq3,~\{x\}).\alpha
        \\ ?timeout(x>3,~\emptyset).end
    \end{array} \\[-1ex]\\
    !pong(x>3,~\{x\}).
    \begin{array}[c]\{{l}\}
        ?ping(x\leq3,~\{x\}).\alpha
        \\ !timeout(x>3,~\emptyset).end
    \end{array} \\
\end{array}
\]
where pings are responded by pongs and vica versa.
Notice that if a timely ping is not received, a pong is sent instead, which if not responded to by a ping, triggers a timeout.
Similarly, once a ping has been received, a pong must be sent on time to avoid a timeout.
%
Such a convoluted protocol can be fully implemented:
% \marginpar{crucial details:\begin{itemize} \item delays must only be inserted after any timers are set \item process timers can be used to make sure receive-after do not receive for too long: $n-x$, where the value of $x$ is used once the receive process is reached\end{itemize}}
\[\resizebox{\textwidth}{!}{$\PCalc{%
    \begin{array}[t]{l}%
       \mathtt{def\ }{\RecVar\left({\RecSetMsg;\RecSetTimers;\RecSetRoles}\right)}={P}~\mathtt{in\ } P%
\\\qquad%
P =  {\mathtt{set}(x)}.%
        \begin{array}[t]{l}%%
            \On{p}~\Recv*{ping}:{%
                {\mathtt{set}(x)}.%
                \begin{array}[t]{l}%
                    \If{x\leq 3}%
                    \\\Then{%
                        \On{p}~\Send{pong}.{\RecVar\left\langle{\RecSetMsg';\RecSetTimers';\RecSetRoles'}\right\rangle}%
                    }\\\Else{%
                        \On{p}~\Recv*{timeout}:{\PrcEnd}%
                    }%
                \end{array}}%
            \\\After<{3-x}:{%
                \On{p}~\Send{pong}.{%
                    \begin{array}[t]{l}%
                        {\mathtt{set}(x)}.%
                        \begin{array}[t]{l}%
                            \On{p}~\Recv*{pong}:{\RecVar\left\langle{{\RecSetMsg}'';{\RecSetTimers}'';{\RecSetRoles}''}\right\rangle}%
                            \\\After<{3-x}:{%
                                \On{p}~\Send{timeout}.{\PrcEnd}%
                            }%
                        \end{array}%  
                    \end{array}%  
                }%
            }%
        \end{array}%
    \end{array}%
}$}\]
%
% Observe \PCalc*{\After<{3-x}:{P}} which ensures that a process only waits the specified amount of time, taking into account any delays inserted into the process captured by the timer $x$.



\subsection{Message throttling}
% Figure environment removed
%
A real-world application of the previous example is \emph{message throttling}.
%
The rationale behind message throttling is to cull unresponsive processes, which do not keep up with the message processing tempo set by the system.
This avoids a server from becoming overwhelmed by a flood of incoming messages.
%
In such a protocol, upon receiving a message, a participant is permitted a grace period to respond before receiving another.
%
The grace period is specified as a number of unacknowledged messages, rather than a period of time.
%
Below we present a fully parametric implementation of this behaviour, where $m$ is the maximum number of messages that can go unacknowledged before a timeout is issued.
\[
\begin{array}[c]{lcl}
%
S_0 & = & \mu\alpha^{0}.!msg(x \geq 3, \{x\}). S_1
%
\\[-1ex]\\ %
S_i & = & \mu\alpha^{i}.
\begin{array}[c]\{{l}\}
?ack(x < 3, \{ x \}). \alpha^{i-1},
~!msg(x \geq 3, \{ x \}) . S_{i+1}
\end{array}
%
\\[-1ex]\\ %
S_m & = &
\begin{array}[c]\{{l}\}
?ack(x < 3, \{ x \}). \alpha^{m-1},
~!tout(x \geq 3,~\emptyset) . \TypeEnd
\end{array}
%
\end{array}
\]

\noindent which has the corresponding processes:
\begin{processcalculus}*
    \begin{array}{lclcl}
    %
    \mathtt{def\ }{\RecVar_0\left({\RecSetMsg_0;\RecSetTimers_0;\RecSetRoles_0}\right)}
    & = & {P_0} & \mathtt{in\ } & \On{p}~\Send{msg}.{P_1}
    %
    \\[-1.5ex]\\ %
   \mathtt{def\ }{\RecVar_i\left({\RecSetMsg_i;\RecSetTimers_i;\RecSetRoles_i}\right)}
   & = & {P_i} & \mathtt{in\ } & % P_i%
        % \\\qquad%
        % P_i = 
        \begin{array}[t]{l}
            \On{p}~\Recv*{ack}:{\RecVar_{i-1}\left\langle{\RecSetMsg_{i-1};\RecSetTimers_{i-1};\RecSetRoles_{i-1}}\right\rangle}%
         \\\After<{3}:{%
            \On{p}~\Send{msg}.{P_{i+1}}%
            }
        \end{array}
    \\[-2ex]\\ %
    & & P_m & = &
    \begin{array}[t]{l}
        \On{p}~\Recv*{ack}:{P_{m-1}}
         \\\After<{3}:{\On{p}~\Send{tout}.{\PrcEnd}}
    \end{array}
    %
    \end{array}
\end{processcalculus}\vspace{-0.5ex}

\noindent The system shown in~\cref{fig:message_throttling} illustrates the system for the $m=2$ instance. 
%
Arguably, instead of sending the message $tout$, it would also be equally valid for the system to simply reach an error state:
\PCalc*{P_m = \On{p} ~\Recv*{ack}:{P_{m-1}} ~\After<{3}:{\PrcErr}}.
