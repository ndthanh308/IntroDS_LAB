We have shown how timing constraints provide an intuitive way of integrating mixed-choice into asynchronous session types. 
The desire for mixed-choice has already prompted work in (untimed) synchronous session types~\cite{Vasconcelos2020}.
Further afield, coordination structures have been proposed that overlap with mixed-choice, for example, fork and join~\cite{Denielou2012a}, which permit messages within a fork (and its corresponding join) to be sent or received in any order; reminiscent of mixed-choice.
Affine sessions~\cite{Lagaillardie2022,Mostrous2018} support exception handling by enabling an end-point to perform a subset of the interactions specified by their type, but there is no consideration of time, hence timeouts.
Before session types gained traction, timed processes~\cite{Berger2007} were proposed for realising timeouts, but lacked any notion of a counterpart for timeouts.

We have integrated the notion of mixed-choice with that of time-constraints.
There are many conceivable ways to realise mixed-choice using programming primitives. 
However, our integration with time, embodied in TOAST, offers new capabilities for modelling timeouts which sit at the heart of protocols and are a widely-used idiom in programming practice. To provide a bridge to programming languages, we provide a timed session calculus enriched with a \texttt{receive\text{-}after} pattern and process timers, the latter providing a natural counterpart to the former. Taken altogether, we have lifted a long-standing restriction on asynchronous session types by allowing for safe mixed-choice, through the judicious application of timing constraints.




Future work will provide type checking against TOAST for our new processes, and establish time-safety (a variant of type-safety which ensures punctuality of interactions via subject reduction) for well-typed processes.
%
Time-safety for timed session types~\cite{Bocchi2019,Bocchi2014} (without mixed-choice) relies on a progress property called receive-liveness, which is defined on the untimed counterpart of a timed process. Receive-liveness that can be checked with existing techniques for global progress \cite{Bettini2008,DezaniCiancaglini2007}. 
%
A progress property may seem too strong a precondition for ensuring time-safety. In untimed formulations of session types, type-safety and subject reduction do not depend on progress. Arguably, when considering time and punctuality, the distinction between progress and safety is no longer clear-cut, since deadlocks may cause violation of time constraints. 


% Unfortunately, techniques similar to the ones in~\cite{Bettini2008,DezaniCiancaglini2007} are not available to us due to the use of mixed-choice.
% Instead, direct proof will be applied for timed processes, and similar assumptions on the structure of processes. This makes time-safety for TOAST interesting in itself. 


%Receive-liveness is defined on untimed counterpart of a timed process $P$. Intuitively, receive-liveness ensures that if a process is waiting to receive a message, the other (parallel) processes will provide with that message. This property, on the untimed counterpart of the processes in~\cite{Bocchi2019} can be checked with the techniques for global progress in~\cite{Bettini2008} that can prevent deadlocks due to circular dependencies in interleaved sessions. 




%The results of this paper assume single sessions. This is a considerable limitation in a binary setting. Extension of this work to the multiparty setting and investigation of techniques to ensure global progress in presence of mixed choice with asinchrony and time are promising future directions. 
%Whatever the approach, the elegance of its integration is arguably as important as its expressive power.
%
