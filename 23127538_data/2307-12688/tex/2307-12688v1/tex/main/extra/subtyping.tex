% !TEX root = main.tex

%\subsection{Subtyping}

\def\myend{\texttt{end}}

\begin{lemma}\label{lemma-zero}
    $\delta[x/0] = \vee \{ \delta' \mid \delta'[x \mapsto 0] \models \delta \}$
\end{lemma}

\begin{proof}[For Lemma~\ref{lemma-zero}] \mbox{}
    \begin{itemize}
        \item Observe
              \[
                  \begin{array}{rcl}
                      \delta[x/0][x \mapsto 0] & =      & \exists_x(\delta[x/0]) \wedge (x = 0) \\
                                               & =      & \delta[x/0] \wedge (x = 0)            \\
                                               & \equiv & \delta \wedge (x = 0) \models \delta
                  \end{array}
              \]
        \item Let $\delta'[x \mapsto 0] \models \delta$.
              Then
              \[
                  \begin{array}{rcl}
                      \delta' \models \exists_x(\delta') & = & \exists_x(\delta') \wedge true                  \\
                                                         & = & (\exists_x(\delta') \wedge (x = 0))[x/0]        \\
                                                         & = & (\delta'[x \mapsto 0])[x/0] \models \delta[x/0]
                  \end{array}
              \]

    \end{itemize}
\end{proof}

%\begin{definition}
%$\delta_1 \multimap \delta_2 = 
%\vee \{ \delta \mid \delta \wedge \delta_1 \models \delta_2, (\delta \wedge \delta_1) \not\models %false \}$
%\end{definition}

% Figure environment removed

\begin{definition}
Suppose $vars(\delta_1) \subseteq vars(\vec{x})$,
$vars(\delta_2) \subseteq vars(\vec{y})$
and
$vars(\vec{x}) \cap vars(\vec{y}) = \emptyset$.
Then
\[
\delta_1 \multimap \delta_2 = 
\vee \{ \vec{x} = \vec{x_1} \wedge \vec{y} = \vec{x_1} \wedge x_1 \in I \mid I \in C^{*} \}
\]
where
\[
T = \{ t \in \mathbb{Q}^{+} \mid \vec{x} = \vec{t} \wedge \vec{y} = \vec{t} \wedge \delta_1 \models \delta_2 \}
\]
\[
C = \{ I \in Int \mid I \subseteq T \}
\qquad
C^{*} = \{ I \in C \mid \forall J \in C . I \subseteq J \rightarrow I = J \}
\]

\end{definition}

\begin{lemma}
Let $\nu \in \llbracket \delta_1 \multimap \delta_2 \rrbracket$.
Then 
$\nu + t \in \llbracket \delta_1 \multimap \delta_2 \rrbracket$
iff
$\nu + t \in \llbracket \delta_1 \rightarrow \delta_2 \rrbracket$.
\end{lemma}

\begin{proposition}[soundness and optimality]\label{lemma-implication} \mbox{}
    \begin{itemize}
        \item $\delta_1 \wedge (\delta_1 \multimap \delta_2) \models \delta_2$
        \item Let $\delta = \vee_{i=1}^n \pi_i$. If $\delta_1 \wedge \delta \models \delta_2$ then $\delta_1 \wedge \delta \models \delta_1 \wedge (\delta_1 \multimap \delta_2)$
    \end{itemize}
\end{proposition}

\begin{proof}[for proposition~\ref{lemma-implication}] \mbox{}
    \begin{itemize}
        \item
              %Let $\nu \in \llbracket \delta_1 \wedge (\delta_1 \multimap \delta_2) \rrbracket$.
              Observe $\delta_1 \wedge \neg \delta_2 \models ch(\delta_1 \wedge \neg \delta_2) \models core(ch(\delta_1 \wedge \neg \delta_2), \delta_2)$
              and therefore $\delta_1 \multimap \delta_2 = \neg core(ch(\delta_1 \wedge \delta_2), \delta_2) \models \neg (\delta_1 \wedge \neg \delta_2) \equiv (\neg \delta_1) \vee \delta_2$.
              It thus follows $\delta_1 \wedge (\delta_1 \multimap \delta_2) \models \delta_1 \wedge ((\neg \delta_1) \vee \delta_2) \equiv false \vee (\delta_1 \wedge \delta_2) \equiv \delta_1 \wedge \delta_2 \models \delta_2$.

        \item Let $\delta_1 \wedge \delta \models \delta_2$.
              Then
              $\delta_1 \wedge \pi_i \models \delta_2$ for all $i \in \{ 1, \ldots, n \}$.
              \begin{itemize}
                  \item Suppose $\delta_1 \wedge \pi_i \models false$. Then $\delta_1 \wedge \pi_i \models \delta_1 \wedge (\delta_1 \multimap \delta_2)$.

                  \item Suppose $\delta_1 \wedge \pi_i \not\models false$.
                        Let $\nu \in \llbracket \delta_1 \wedge \pi_i \rrbracket$.
                        Since $\delta_1 \wedge \pi \models \delta_2$ it follows that $\nu \in \llbracket \delta_2 \rrbracket$ but
                        $\nu \not\in \llbracket \neg \pi_i \rrbracket$.
                        Thus $\delta_2 \not\models \neg \pi_i$ and $core(\{ \neg \pi_i \}, \delta_2) = \{ \neg \pi_i \}$.
                        Observe $(\delta_1 \wedge \neg \delta_2) \wedge \pi_i \models false$
                        thus $\delta_1 \wedge \neg \delta_2 \models \neg \pi_i$.
                        Therefore
                        $\neg \pi_i \in ch(\delta_1 \wedge \neg \delta_2)$
                        and by Lemma~\label{lemma-mono}
                        $\wedge core(ch(\delta_1 \wedge \neg \delta_2), \delta_2) \models \neg \pi_i$.
                        It follows that
                        $\pi_i \models \neg \wedge core(ch(\delta_1 \wedge \neg \delta_2), \delta_2) \equiv \delta_1 \multimap \delta_2$ and
                        $\delta_1 \wedge \pi_i \models \delta_1 \wedge (\delta_1 \multimap \delta_2)$.
              \end{itemize}
              Therefore $\delta_1 \wedge \delta \models \delta_1 \wedge (\delta_1 \multimap \delta_2)$
    \end{itemize}
\end{proof}

% Figure environment removed

\begin{example}\label{exam-snd}
    Consider $S_i = ! t(\delta_i, \lambda_i) . \myend$
    where
    \[
        \delta_1 = (2 \leq x) \wedge (x \leq 4)
        \qquad
        \delta_2 = (3 \leq x) \wedge (x \leq 5)
        \qquad
        \lambda_1 = \lambda_2 = \emptyset
    \]
    Then $d \wedge true[\emptyset /0] \wedge true[\emptyset / 0] =
        d \vdash S_1 \leq S_2$ where
    \[
        \begin{array}{rcl}
            d & = & \delta_1 \rightarrow \delta_2                                        \\
              & = & \neg (2 \leq x) \vee \neg (x \leq 4) \vee (3 \leq x \wedge x \leq 5) \\
              & = & (x < 2) \vee (4 < x) \vee (3 \leq x \wedge x \leq 5)                 \\
              & = & (x < 2) \vee (3 \leq x)
        \end{array}
    \]
    Observe
    $d \wedge \delta_1 = (3 \leq x \wedge x \leq 4) \models \delta_2$
    hence
    $d \wedge \delta_1 \models d \wedge \delta_2$.  Note that hand-cranking the algorithm at the back gives the above simplification.  But maybe it could also give $(x < 2) \vee (4 < x) \vee (3 \leq x)$ depending on selection of the truth assignment.
\end{example}

\begin{example}\label{exam-rcv}
    Now consider $S_i = ? t(\delta_i, \lambda_i) . \myend$
    where
    \[
        \delta_1 = (2 \leq x \wedge 2 \leq y)
        \qquad
        \delta_2 = (3 \leq x \wedge 1 \leq y)
        \qquad
        \lambda_1 = \lambda_2 = \emptyset
    \]
    Then $d' \wedge true[\emptyset /0] \wedge true[\emptyset / 0] =
        d' \vdash S_1 \leq S_2$ where
    \[
        \begin{array}{rcl}
            d' & = & \delta_2 \rightarrow \delta_1                      \\
               & = & (\neg \delta_2) \vee \delta_1                      \\
               & = & (x < 3 \vee y < 1) \vee (2 \leq x \wedge 2 \leq y) \\
               & = & \ldots                                             \\
               & = & 2 \leq y
        \end{array}
    \]
    Observe
    $d' \wedge \delta_2 = (3 \leq x \wedge 2 \leq y) \models \delta_1$
    hence $d' \wedge \delta_2 \models d' \wedge \delta_1$.
\end{example}

\begin{example}
    Now suppose $\square = \; !$ and
    $\lambda_1 = \lambda_2 = \{ x \}$.
    Then $true[\{ x \} /0]$ = $true$,
    hence $\lambda_i$ has no impact when
    $S_1 \leq S_2$ holds. Likewise for $\square = \; ?$.
\end{example}

\begin{example}
    Continuing with example~\ref{exam-snd}, now consider
    $S'_i = ! t'(\delta'_i, \lambda'_i) . S_i$ where
    \[
        \delta'_1 = (2 \leq x)
        \qquad
        \delta'_2 = (x \leq 1)
        \qquad
        \lambda'_1 = \lambda'_2 = \{ x \}
    \]
    Then
    \[
        \begin{array}{rcl}
            d' & = & \delta_1 \rightarrow \delta_2 \\
               & = & (\neg \delta_1) \vee \delta_2 \\
               & = & (x < 2) \vee (x \leq 1)       \\
               & = & (x \leq 1)
        \end{array}
        \qquad
        \begin{array}{rcl}
            d' \wedge d[\{ x \} / 0] \wedge d[\{ x \} / 0] & = & d' \wedge d[\{ x \} / 0]            \\
                                                           & = & d' \wedge ((0 < 2) \vee (3 \leq 0)) \\
                                                           & = & d' \wedge (true \vee false) =       \\
                                                           & = & d'
        \end{array}
    \]
    thus $d' \vdash S'_1 \leq S'_2$.
\end{example}

\begin{example}
    Developing the examples further, now suppose
    $\lambda'_1 = \lambda'_2 = \emptyset$.
    Then
    \[
        \begin{array}{rcl}
            d' \wedge d[\emptyset / 0] \wedge d[\emptyset / 0] & = & d' \wedge d[\emptyset / 0]              \\
                                                               & = & (x \leq 1) \wedge (x < 2 \vee 3 \leq x) \\
                                                               & = & (x \leq 1)
        \end{array}
    \]
    thus again $d' \vdash S'_1 \leq S'_2$.
\end{example}

\begin{example} Consider
    \[
        \begin{array}{rcllll}
            S                                & = & \{ !t(\delta_1, \emptyset) . \myend,  &
            !t(\delta_2, \emptyset). \myend, &
            !t(\delta_3, \emptyset). \myend \}
            \\
            S'                               & = & \{ !t(\delta'_1, \emptyset) . \myend, &
            !t(\delta'_2, \emptyset). \myend \}
        \end{array}
    \]
    where
    %\[
    %\begin{array}{rrr}
    %\delta_1 = (x \leq 1) & \delta_2 = (x \leq 1) \\ 
    %\delta'_1 = (x \leq 1) & \delta'_2 = (x \leq 1) & \delta_1 = (x \leq 1) & \delta_2 = (x \leq 1) \\
    %\]
\end{example}

\begin{proposition}[soundness]\label{prop-soundness}
Suppose $vars(S_1) \subseteq vars(\vec{x})$,
$vars(S_2) \subseteq vars(\vec{y})$ and $vars(\vec{x}) \cap vars(\vec{y}) = \emptyset$.
%Suppose $vars(S_1) \cap vars(S_2) = \emptyset$. 
The relation
\[
{\cal R}^{*} = \{  ((\nu \downarrow \vec{x}, S_1), (\nu \downarrow \vec{y}, S_2)) \mid d \vdash S_1 \leq S_2 \wedge 
\nu \in \llbracket d \rrbracket 
\}
\]
is a timed type simulation.
\end{proposition}


\begin{proof}[for proposition~\ref{prop-soundness}]
Let $((\nu \downarrow \vec{x}, S_1), (\nu \downarrow \vec{y}, S_2)) \in {\cal R}^{*}$.
\begin{itemize}

\item
Suppose $S_1 = \myend$.  Then $S_2 = \myend$ as required.

\item 
Suppose $(\nu \downarrow \vec{x}, S_1) \xrightarrow{t!m_1} (\nu_1, S'_1)$.
Put $\mu = \nu + t$.
Then 
$\mu \in \llbracket d \rrbracket$
where $d \vdash S_1 \leq S_2$.

Then $(\mu \downarrow \vec{x}, S_1) \xrightarrow{!m_1} ((\mu \downarrow \vec{x})[\lambda_1 \mapsto 0], S'_1)$
where $S_1 = !m_1(\delta_1, \lambda_1).S'_1$
and
$\mu \downarrow \vec{x} \in \llbracket \delta_1 \rrbracket$.

Since $d \vdash S_1 \leq S_2$ it follows
$S_2 = !m_2(\delta_2, \lambda_2).S'_2$
where $m_2 \sqsubseteq m_1$.

Furthermore $d = (\delta_1 \multimap \delta_2) \wedge d'[\lambda_1 \cup \lambda_2 / 0]$
where $d' \vdash S'_1 \leq S'_2$.

Since $vars(\delta_1) \subseteq vars(\vec{x})$
it follows $\mu \in \llbracket \delta_1 \rrbracket$.

Moreover, $d \models \delta_1 \multimap \delta_2 \models \delta_1 \rightarrow \delta_2$
hence $\mu \in \llbracket \delta_1 \wedge (\delta_1 \rightarrow \delta_2) \rrbracket$
whence $\mu \in \llbracket \delta_2 \rrbracket$
and $\mu \downarrow \vec{y} \in \llbracket \delta_2 \rrbracket$
because $vars(\delta_2) \subseteq vars(\vec{y})$.

Therefore $(\mu \downarrow \vec{y}, S_2) \xrightarrow{m_2} ((\mu \downarrow \vec{y})[\lambda_2 \mapsto 0], S'_2)$.

Put $\theta = \mu[\lambda_1 \cup \lambda_2 \mapsto 0]$
and observe
$\theta \downarrow \vec{x} = (\mu \downarrow \vec{x})[\lambda_1 \mapsto 0]$
and
$\theta \downarrow \vec{y} = (\mu \downarrow \vec{y})[\lambda_2 \mapsto 0]$.

Since $d \models d'[\lambda_1 \cup \lambda_2/0]$ it follows
$\mu \in \llbracket d'[\lambda_1 \cup \lambda_2/0] \rrbracket$
hence $\theta \in \llbracket d' \rrbracket$.

Therefore
$((\theta \downarrow \vec{x}, S'_1), (\theta \downarrow \vec{y}, S'_2)) \in {\cal R}^{*}$ as required.

\item 
Suppose $(\nu \downarrow \vec{x}, S_1) \xrightarrow{t?m_1} (\nu_1, S'_1)$.
Analogous to the previous case.
\end{itemize}
\end{proof}

Note that ${\cal R} = \emptyset$ is a timed type simulation.

\newpage

\begin{proposition}[completeness]\label{prop-completeness}
${\cal R}^{*}$ is the greatest timed type simulation.
\end{proposition}

\begin{proof}[for proposition~\ref{prop-completeness}]
Let ${\cal R}$ be a timed type simulation
and $((\nu_1, S_1), (\nu_2, S_2)) \in {\cal R}$.
\begin{itemize}

\item Suppose $S_1 = \myend$. Then $S_2 = \myend$
hence $true \vdash S_1 \leq S_2$.

Put $\nu = \lambda v . \nu_1(v)$ else $\nu_2(v)$ 
so that $\nu_1 = \nu \downarrow \vec{x}$,
$\nu_2 = \nu \downarrow \vec{y}$.
Since $\nu \in \llbracket true \rrbracket$ it follows
$((\nu_1, S_1), (\nu_2, S_2)) \in {\cal R}^{*}$ as required.

\item Suppose $(\nu_1, S_1) \xrightarrow{t!m_1} (\nu'_1, S'_1)$.
Then $(\nu_2, S_2) \xrightarrow{t!m_2} (\nu'_2, S'_2)$ and moreover
$((\nu'_1, S'_1), (\nu'_2, S'_2)) \in {\cal R}$.

Put $\nu = \lambda v . \nu_1(v)$ else $\nu_2(v)$ and $\mu = \nu + t$.

It follows that 
$S_1 = !m_1(\delta_1, \lambda_1) . S'_1$
and
$S_2 = !m_2(\delta_2, \lambda_2) . S'_2$
where
$\mu \downarrow \vec{x} \in \llbracket \delta_1 \rrbracket$
and
$\mu \downarrow \vec{y} \in \llbracket \delta_2 \rrbracket$.

Now suppose $((\nu_1, S_1), (\nu_2, S_2)) \in {\cal R}^{*}$.

Then $\nu + t' \in \llbracket d \rrbracket$
for some $t' \geq 0$
where $d = (\delta_1 \multimap \delta_2) \wedge d'[\lambda_1 \cup \lambda_2 / 0]$
and $d' \vdash S'_1 \leq S'_2$.

Since $\delta_1 \wedge \delta_2 \wedge diagonal \models \delta_1 \multimap \delta_2$ it follows $\mu \in \llbracket
\delta_1 \multimap \delta_2 \rrbracket$.

To show $\mu \in \llbracket d \rrbracket$.

Since $d \models d'[\lambda_1 \cup \lambda_2 / 0]$
it follows $\mu \in \llbracket d'[\lambda_1 \cup \lambda_2 / 0] \rrbracket$.

Therefore $\nu' = \mu[\lambda_1 \cup \lambda_2 \mapsto 0] \in \llbracket d' \rrbracket$.
It follows that $((\nu'_1, S'_1), (\nu'_2, S'_2)) \in {\cal R}^{*}$ as required.
    
\item Analogous to the previous case.

\end{itemize}
It follows ${\cal R} \subseteq {\cal R}^{*}$.
\end{proof}

Conspicuous by its absence is any [\text{rec}] rule but it is not clear how the timing constraints can generate an infinite decending chain of constraints.

