
\subsection{Impact \& Applications}
While session types provide a means of designing a system guaranteed to enjoy progress via tools such as Scribble~\cite{Scribble,Yoshida2013}, or assisting with code generation~\cite{Neykova2013,Neykova2018,Miu2020}, they also have been shown to be an effective means of verifying the behaviour of existing systems~\cite{Neykova2013a,Lange2019}, and even generating runtime monitors~\cite{Neykova2014a}.



Large scale concurrent systems that consist of smaller systems communicating asynchronously with each other, such as web and cloud-services, often depend on runtime monitors for their reliability.
%
Unintended behaviour, such as deadlocks, becomes inevitable at such scales~\cite{Huang2017}\TODO[reread this paper~\cite{Huang2017}].
Such systems commonly follow the \emph{let is crash model}, where crashed nodes are simply restarted once detected (with any nodes dependant on the now restarted node often restarted too).
%
Session types have been used to improve this method~\cite{Neykova2017}, by automatically recovering all of the states that the crashed node depends on, and is a dependency of, to an earlier point in the process.
%
This method uses session types to ensure that the recovered process is sound, able to continue from a point before the error occurred.
%
However, methods such as these can only provide a benefit to those systems which can be modelled by session types.



However, reliability is still not guaranteed, and deadlocks can still occur in systems that utilise these techniques.
%
\emph{Gray failures} are instances where a system is unable to recover due to the failure of its monitors, or their detectors.
%
Gray failures appear to resist detection, and are often unrecoverable due to being detected far too late, requiring a total system restart.
%
Such large systems cannot be verified, and fall outside the scope of decidable \CFSM, and therefore are currently unable to be completely modelled by session types.
%
By expanding session types to include mixed-choice, a greater range of asynchronous communicating systems will be able to benefit from the guaranteed progress session types provide.



\endinput



A system that \emph{enjoys progress} describes a system free from deadlocks.
%
A system that is not in deadlock is called \emph{live}, and has either terminated successfuly or may still peform an action.
%
System compatibility specifies that for every sending action, there exists a corresponding receiving action (and vice versa).
%
Communication safety requires freefom from orphaned messages and unspecified receptions.
%
Together, \emph{liveness}, \emph{compatibility} and \emph{communication safety} have been proven to guarantee progress~\cite{Honda2008,Denielou2012a}.





\TODO[SMTP, producer/consumer, ring protocol (message throttling)]

% ~ examples

\paragraph*{Simple Mail Transfer Protocol}
The Internet Standards specify in {RFC 5321}~{\cite[Section~4.5.3.2]{RFC5321}}:
\begin{quote}
    An \SMTP\ client MUST provide a timeout mechanism
\end{quote}
and proceed to detail various cases and their minimum required timeout duration for each (ranging from 2 to 10 minutes).

\paragraph*{Producers \& Consumers} (shown in~\cref{par:example_producer_consumer})
As in~\cite{Vasconcelos2020}

\paragraph*{Message Throttling} (shown in~\cref{par:example_message_throttling})
Referred to as \emph{ring protocol} in~\cite{Lagaillardie2022}




