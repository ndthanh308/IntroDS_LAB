
Mixed-choice is an inherent feature of models of communications such as communicating finite-state machines (CFSM)~\cite{Brand1983} where actions are classified as either send or receive. In this setting, a state of a machine is said to be mixed if there exist both a sending action and a receiving action from that state.
%
When considering an asynchronous model of communication, absence of deadlocks is undecidable in general~\cite{Gouda1984} but can be guaranteed in presence of three sufficient and decidable conditions: determinism, compatibility, and \emph{absence} of mixed-states~\cite{Gouda1984,Denielou2013}. Intuitively, determinism means that it is not possible, from a state, to reach two different states with the same kind of action, and compatibility requires that for each send action of one machine, the rest of the system can eventually perform a complementary receive action.

In the desire to ensure deadlock freedom, mixed-choice has been given up, even though this curtails the descriptive capabilities of CFSM and its derivatives. Despite the rapid evolution of session types, even to
the point of deployment in Java~\cite{Hu2008}, Python~\cite{Neykova2013,Neykova2013a},
Rust~\cite{Lagaillardie2020},
{F\#}~\cite{Neykova2018} and {Go}~\cite{Castro2019}, thus far mixed-choice has only been introduced into the synchronous binary setting~\cite{Vasconcelos2020}. 
%
In fact, the exclusion of mixed-choice pervades work on asynchronous communication which guarantee deadlock-freedom, both for
communicating timed automata~\cite{Bocchi2015,Krcal2006} and session types~\cite{Bettini2008,Carbone2008,Honda2008,Yoshida2007}.
%
Determinism and the absence of mixed-states is baked into the very syntax of session types (the correspondence between session types and so-called safe CFSM is explained in~\cite{Denielou2013}).

Timed session types~\cite{Bartoletti2014,Bocchi2019,Bocchi2014}, which extend session types with time constraints, inherit the same syntactic restrictions of session types, and hence rule out mixed-states.
This is unfortunate since in the timed setting, mixed-states are a useful abstraction for timeouts. 
Illustrated in~\Cref{fig:timeout_snippets}, the mixed-state CFSM (right) can be realised using a \texttt{receive-after} statement in Erlang (left).
In the Erlang snippet, the process waits to receive either a `data' or `done' message. If neither are received within 3 seconds, then a timeout message is issued.
% sends a timeout message, if neither a `data' or `done' message are received within 3 seconds.
% To illustrate, figure~\ref{fig:timeout_snippets} shows how a \texttt{receive-after} statement of Erlang can be rendered as a mixed-state CFSM: 
% if neither a `data' nor a `done' message are received within 3 time units, a timeout message is issued. 

Timeouts are important for handling failure and unexpected delays, for instance, the SMTP protocol stipulates:
\emph{``An SMTP client \emph{must} provide a timeout mechanism''}~\cite[Section~4.5.3.2]{RFC5321}.
Mixed-states would allow, for example, states where a server is waiting to \emph{receive} a message from the client and, if nothing is received after a certain amount of time, \emph{send} a notification that ends the session.
Current variants of timed session types allow deadlines to be expressed but cannot, because of the absence of mixed-states, characterise (and verify) the behaviour that should follow a missed deadline, e.g., a restart or retry strategy.
In this paper, we argue that time makes mixed-states more powerful (allowing timeouts to be expressed), while just adding sufficient synchonisation to ensure that mixed-states are safe in an asynchronous semantics (cannot produce deadlocks).

%
% Figure environment removed

%\marginpar{ToDo List:
%\begin{itemize}\item timed automata example %\item erlang counterpart example \item example %of processes for each in section 3, before %reduction rules \end{itemize}}
%
%The counterpart to a timeout is delicate and %requires the a process to know if it is early %enough to send, or late enough to expect to %receive a timeout.
%
% The counterpart to a timeout is delicate and non-trivial in that a process must know if it is early enough to send, or if it is late enough to receive a timeout message.
% The implementation of the dual type of a timeout is delicate
% \TODO[add dual of above timeout]
% in what we have to provide the process with sufficient knowledge to decide whether to send or receive. 
%To this aim, we introduce another new feature in the calculus common to many programming languages: \emph{process timers}.
%A process is now able to create, reset and read simple timers.
%A process can use these timers in \texttt{if\text{-}then\text{-}else} statements to determine the selection from different branches.
% These timers can be used by a process for branch selection 
% A process is now able to set and read timers and, consequently, use their values to determine how branches are selected.
% the possibility for a process to set and read clocks and, consequently, the possibility of choosing branches depending on the values of clocks. 
%An example of a counterpart is modelled by \Qrc*\ in~\cref{fig:timeout_snippets_process}, where $x$ is some pre-existing timer.
% One possible implementation of process corresponding to a timeout could be \Qrc*\ in~\cref{fig:timeout_snippets_process} (where $x$ is a process timer set at an earlier point in the process).

\paragraph{Contributions}
This work makes three orthogonal contributions to the theory of binary session types, with a focus on improving their descriptive capabilities:
\begin{itemize}
      \item We introduce TimeOut Asynchronous (binary) Session Types (TOAST) to support timeouts.
            Inspired by asynchronous timed binary session types~\cite{Bocchi2019}, TOAST shows how timing constraints provide an elegant solution for guaranteeing the safety of mixed-choice. Technically, we provide a semantics for TOAST and a well-formedness condition. We show that well-formedness is sufficient to guarantee progress for TOAST (which may, instead, get stuck in general). 
            %
      \item We provide a new process calculus whose functionality extends to support programming motifs such as the widely used \texttt{receive\text{-}after} pattern of Erlang for expressing timeouts. 
            %
    \item We introduce timers in our process calculus to structure the counterpart of a timeout (i.e., a process that interacts with one other process displaying a timeout), as well as time-sensitive conditional statements, where the selection of a branch may be determined by timers. Time-sensitive conditional statements provide processes with knowledge that can be used to decide which branch should be followed e.g., helping understanding whether the counterpart may have timed out or not. 
            %
    \item We provide an informal discussion on the correspondence between TOAST and the aforementioned primitives of our new process calculus. 
\end{itemize}
%In this work we focus only on binary sessions.
%For simplicity, we relegate all proofs to an appendix.

\endinput

, and .
%
The new types, Timeout Session Types (\ToSTs), are guaranteed to enjoy progress; preserving the notions of communication safety and liveness, and extending the notions of compatibility and duality~\cite{Gay2020}.
%
This work presents \ToSTs\ in a binary setting, and as standard with session types, communication is half-duplex over pairs of unbounded channels.
%
\TODO[provided overview of paper with links to each section (needs lauras changes)].

\endinput

\input{tex/main/intro/motivation.tex}
\input{tex/main/intro/existing_work.tex}
\input{tex/main/intro/contribution.tex}

\TODO[intro], \TODO[contribution outline]

\paragraph*{Motivating Examples}
\TODO[SMTP, producer/consumer, ring protocol (message throttling)]

\endinput
% \item \cite{Gouda1984} prove safety of asynchronous communications is undecidable and give sufficient decidable conditions.
Asynchronous communication is practically relevant (e.g, web programming) but increases the complexity of a system and introduces undecidability of properties such as progress and freeness from
communication-mismatches.
More precisely, it is undecidable to check if, in general, two~\cite{Gouda1984} or more~\cite{Denielou2013} communicating processes may receive unexpected or ill-typed messages (unspecified reception), or that they will not receive the messages they expect (deadlock).

It has been proven~\cite{Gouda1984} that systems with states without \emph{mixed-receptions} (being a choice where both \emph{sending} and \emph{receiving} actions are considered) are decidable, and can be guaranteed to exhibit progress.
\TODO\lnote{Not just mixed-choice, but a number of sufficient conditions, which you should mention briefly, also citing the multiparty version of the works like Denielou's paper.}

Mixed-choice are a behaviour often excluded from asynchronous definitions in both the timed~\cite{NEEDED}, and un-timed~\cite{NEEDED} setting; mainly due to issues that arise surrounding communication safety and fairness.
Given a situation where two compatible participants have their respective choice between a sending and receiving action. The issue of communication safety arises when both participants perform the incompatible sending actions, before they can know what action the other has performed; commonly referred to as a \emph{communication-mismatch}. Fairness is an issue when sending and receiving actions are considered together, as either the non-blocking sending action is nearly always performed, or the receiving action must be allowed to wait its full duration which can lead to missing a viable sending action.

There are several recent works~\cite{NEEDED} that have explored the use of mixed-choice in the un-timed setting.\TODO

\subsection*{Motivating Examples for Timeouts and Mixed-Choices}
Applications of both mixed-choice and timeouts are varying and form distinct patterns.
Drawing from both existing systems and the literature, several of these timeout idioms have been identified and showcased below, such as
\begin{inline}
      \item simple timeouts
      \item producers and consumers
      %
      \item other application specific examples
\end{inline}

\subsubsection{Simple Timeout Protocols}
It is common for web services to implement timeouts \TODO

\paragraph{Simple Mail Transfer Protocol}
The Internet Standards specify in {RFC 5321}~{\cite[Section~4.5.3.2]{RFC5321}}:
\begin{quote}
      An \SMTP\ client MUST provide a timeout mechanism
\end{quote}
and proceed to detail various cases and their minimum required timeout duration for each (ranging from 2 to 10 minutes).

\paragraph{Alternating-Bit Protocol}~\cite{Gouda1984,Boigelot1999,Annichini2001}

\subsubsection{Producers \& Consumers}
As in~\cite{Vasconcelos2020}

% Figure environment removed

\begin{example}[Producer and Consumer Types]
      Types of each individual as shown in~\cref{fig:motiv_example_producer_consumer_diagram}
      %
      \input{tex/figs/example_producer_consumer_type.tex}
\end{example}

\subsubsection{Message Throttling}
% Another application of both mixed-choice and timeouts 
Referred to as \emph{ring protocol} in~\cite{Lagaillardie2022}

Consider a system comprised of two participants, where one repeati

% Figure environment removed

\begin{example}[Message Throttling Types]
      Below is the type for the message sender, as shown in~\cref{fig:motiv_example_message_throttling_diagram}.
      %
      \input{tex/figs/example_message_throttling_type.tex}
\end{example}

\endinput % old stuff about cta

% \item Cite some work that rules out mixed-choice. The work at CAV of Julien Lange is a recent one. Explain that session types embed naturally such constraints in their syntax, and in fact a correspondence was established between 'safe' CFSM and binary and multiparty session types. Also in the timed scenario.

CFSM~\cite{Brand1983} and MPST~\cite{Honda2008} connection in~\cite{Denielou2012a,Denielou2013}

CTA~\cite{Krcal2006} and Timed MPST~\cite{Bocchi2014} connection in~\cite{Bocchi2015}

% \item All that work builds on condition that rule out mixed-choice.

% \item We argue mixed-choice is useful in practice (e.g., show timeout pattern). 

% \item Time not only makes mixed-choice practically relevant, but adds a dimension where mixed-choice can be attained safely. 

\rule{0pt}{2ex}\hrule

\endinput

\begin{itemize}
      \item Gouda, Manning, etc. (\cite{Gouda1984}) prove safety of asynchronous communications is undecidable and give sufficient decidable conditions.
            %
      \item In parallel work on session types provided sound verification for asynchronous communication. Link between session types and safe CFSM~\cite{Brand1983} has been established even in the multiparty~\cite{Denielou2012a,Denielou2013} and timed~\cite{Krcal2006,Bocchi2015} setting.
            %
      \item All that work builds on condition that rule out mixed-choice.
            %
      \item We argue mixed-choice is useful in practice (e.g., show timeout pattern).
            %
      \item Time not only makes mixed-choice practically relevant, but adds a dimension where mixed-choice can be attained safely.
            %
      \item \emph{skipping:} In this paper we give a new sufficient decidable condition for safety for binary communications: for timed session types and for CTA (timed extension of CFSM)
            %
      \item \emph{skipping:} We also prove a sound and complete correspondence of the two. The correspondence is practically relevant as the two notations are used in different contexts: session types for checking statically against programs and corresponding automata notations for runtime monitoring.
            %
      \item \emph{skipping:} We focus on binary as multiparty would add technical complexity making it hard to stay in the space of the paper. Also, the usual condition of multiparty safety is directedness (all interactions in a choice are to/from  the same participant) which would not change much our mixed-choice condition.
            %
\end{itemize}

% HERE ANDY

Note that the use of process timers alone yields more expressive calculus than~\cite{Bocchi2019} where a process could only take branches whose constraints were always satisfied.
% Note that the use of clocks in the processes, alone, yield a more expressive typing than~\cite{Bocchi2019} where, basically, a process could only take branches whose constraints were satisfied in all possible executions. 
Process timers allow for more responsive and dynamic branch selection during execution.
% Process clocks add the option of choosing branches that are correct in (only) the current execution.
%
Remarkably, mixed-choice can easily be more complex than standard timeouts.
Given a safe mixed-choice with interleaved sending and receiving actions, such as \TypeS*\ in~\cref{eq:complex_mixed_choice_type}, and it becomes clear that there is no straightforward equivalent for our processes.
%
\begin{minieq}\label{eq:complex_mixed_choice_type}
      \begin{array}[c]{lll}
            \TypeS & = & %
            \begin{array}[c]\{{l}\}
                  %
                  %
                  ?~{done}\left(x<1,~\emptyset\right).{%
                  \TypeEnd%
                  }\\
                  %
                  %
                  !~{stop}\left(x=1,~\emptyset\right).{%
                  \TypeEnd%
                  }\\
                  %
                  %
                  ?~{data}~\text{<}\BTypeString\text{>}%
                  \left(1<x\leq 8,~\{x\}\right).{%
                  {\TypeS}'%
                  }\\
                  %
                  %
                  !~{timeout}\left(x>8,~\emptyset\right).{%
                  {\TypeS}''%
                  }
                  %
            \end{array}
      \end{array}
      %
\end{minieq}%
%
For mixed-choice with a more than one distinct region of sending and receiving actions that are interleaved, a corresponding process must consist of a combination of nested \texttt{receive\text{-}after} and \texttt{if\text{-}then\text{-}else} processes, such as \Prc*\ in~\cref{eq:complex_mixed_choice_prc}.
\begin{processcalculus}\label{eq:complex_mixed_choice_prc}
      \begin{array}[c]{lll}
            %
            \Prc & = & %
            \PSet{y}.{%
            \begin{array}[t]{l}
                  \On{p}\Recv*{done}:{\PrcEnd}%
                  \\%
                  \After<{1}:{%
                  \begin{array}[t]{l}
                        \If{y=1}%
                        % \\%
                        ~\Then{\On{p}\Send{stop}.{\PrcEnd}}%
                        \\
                        \Else{%
                              \begin{array}[t]{l}
                                    \On{p}\Recv*{data}[STR]:{\PSet{y}.{{\Prc}'}}%
                                    \\%
                                    \After<{7}:{%
                                    \On{p}\Send{timeout}.{{\Prc}''}%
                                    }
                              \end{array}
                        }
                  \end{array}
                  }
            \end{array}
            }
      \end{array}
\end{processcalculus}%
%
It is important to note that it is intended for the conditions of \texttt{if\text{-}then\text{-}else} statements to specify the minimum requirement for selecting a branch; such as $\mathtt{if\ }(y=1)$ in~\cref{eq:complex_mixed_choice_prc}.
In practice, a program may supplement these minimum conditions to control the flow of the system further.