
\ThmSubjectReduction*

% ~ wf config actions

% * 23
\begin{lemma}
    %
    If \CIso*\ is \emph{well-formed}
    and $\exists\TypComm,\Msg,\Const$ such that $\ValClocks\models\Const$
    and \Trans*{\CIso}:{\CommMsg},
    then $\forall\TypComm',\Const':
        \TypComm\neq\TypComm'
        ~\implies~
        \ValClocks\not\models\Const'$.
    %
\end{lemma}
\begin{proof}
    %
    By~\cref{lem:cfg_wf_then_live} \CIso*\ is \emph{live}.
    We proceed by induction on the transition \Trans*{\CIso}:{\CommMsg}, analysing the last rule applied:
    \begin{inductivecase}
        %
        %
        % ~ act
        \item\NewCase[\LblCfgIsoInteract*]
        then $\TypeS=\simplechoice$. By the premise of \LblTypChoice*\ the hypothesis holds.
        %
        %
        % ~ unfold
        \item\NewCase[\LblCfgIsoUnfold*]
        then $\TypeS=\mu\alpha.\TypeS'$ and \Trans*{\CIso;[\TypeS']}:{\CommMsg}. The hypothesis holds depending on \TypeS*'; similar to~\cref{itm:cfg_wf_then_live_choice} of~\cref{lem:cfg_wf_then_live} and in~\cref{lem:cfgs_trans_wf_pres,lem:configs_trans_compat_pres}.
        %
    \end{inductivecase}
    %
\end{proof}

% * 31
\begin{lemma}\label{lem:cfg_fe_timepass_wf_fe}
    %
    If \VIso*\ is \isFE*\
    and \Trans*{\VSoc}:{\ValTime}[\VSoc']\
    and \VIso*'\ is \emph{well-formed}
    then \VIso*'\ is \isFE*.
    %
\end{lemma}
\begin{proof}
    %
    By~\cref{lem:cfg_wf_then_live} \VIso*'\ is \emph{live} and either $\TypeS=\TypeEnd$ or \VIso*'\ is \isFE*.
    By induction hypothesis $\exists\ValTime,\TypComm,\Msg$ such that \Trans*{\VSoc}:{\ValTime,\CommMsg}[\VSoc']\ and therefore by the premise of \LblCfgSocTime*\ (persistency) $\exists\ValTime',\TypComm',\Msg'$ such that \Trans*{\VSoc'}:{\ValTime',\TypComm',\Msg'}[\VSoc''].
    %
\end{proof}

% ~ delayed processes
% * 35
\begin{lemma}
    %
    If \PFuncTime*\ is defined
    then $\PFuncWait~\cap~\PFuncNEQ=\emptyset$.
    %
\end{lemma}
\begin{proof}
    %
    Suppose by contradiction that $\PFuncWait~\cap~\PFuncNEQ\neq\emptyset$, then \Prc*\ must be structured such that $\Prc\equiv{\PCalcRecv~\mid~\ISes:\QHead~\mid~\Prc'}$, and by~\cref{fig:prc_func_time} \PFuncTime*\ cannot be defined which contradicts with they hypothesis.
    Therefore $\PFuncWait~\cap~\PFuncNEQ=\emptyset$.
    %
\end{proof}

% * 53
\begin{lemma}\label{lem:timepass_func_defined_t}
    %
    For all \Prc*:
    \begin{enumerate}
        \item\label{itm:timepass_func_defined_t_forall} either \PCalc*{\TimePass_{\ValTime}{\Prc}}\ is defined for all \ValTime*,
        \item\label{itm:timepass_func_defined_t_exists} or, $\exists\ValTime'<\ValTime$ such that \PCalc*{\TimePass_{\ValTime'}{\Prc}}\ is defined for.
    \end{enumerate}
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the structure of \Prc*\ such that \PCalc*{\TimePass_{\ValTime'}{\Prc}}\ being defined is determined by the value of \ValTime*.
    \begin{inductivecase}
        %
        \item\NewCase[\PCalc*{\TimePass_{\ValTime}{\mathtt{delay}({\ValTime}''').\Prc'}}] then $\ValTime\leq{\ValTime}'''$ and~\cref{itm:timepass_func_defined_t_exists} holds.
        %
        \item\NewCase[\PCalc*{\TimePass_{\ValTime}{\PCalcRecv}}] if $\PrcAfter=\infty$ then~\cref{itm:timepass_func_defined_t_forall} holds;
        else $\ValTime\leq\PrcAfter$~\cref{itm:timepass_func_defined_t_exists} holds.
        %
    \end{inductivecase}
    %
\end{proof}

% * 52
\begin{lemma}
    %
    If \PCalc*{\TimePass_{\ValTime}{\Prc}}\ is defined then \PCalc*{\TimePass_{\ValTime+\ValTime'}{\Prc}=\TimePass_{\ValTime}{\TimePass_{\ValTime'}{\Prc}}}.
    %
\end{lemma}
\begin{proof}
    %
    \TODO[check?]
    %
\end{proof}

% ~ typing processes
% * 36
\begin{lemma}\label{lem:typ_prc_role_wf}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,~\ISes:\CIso$
    then \CIso*\ is \emph{well-formed}.
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the typing derivation analysing the last rule applied
    \begin{inline}|
        \item \LblPrcTypDQue*\
        \item \LblPrcTypBranch*\
        \item \LblPrcTypVRecv*\
        \item \LblPrcTypDRecv*\
        \item \LblPrcTypVSend*\
        \item \LblPrcTypDSend*\
    \end{inline}
    Each requires as a premise that $\ValClocks\models\Const$.
    By~\cref{def:types_wf} it follows that \CIso*\ is \emph{well-formed}.
    %
\end{proof}

% * 48
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    and $\Prc\equiv\Qrc$
    then $\VarEnv~\Entails~\Qrc~\PrcTyped~\SesEnv$.
    %
\end{lemma}
\begin{proof}
    %
    It follows as standard, with the addition that $\mathtt{delay}(0).P\equiv\Prc$.
    %
\end{proof}

% * 58
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,\ISes:\Queue$
    then $\exists\QHead,\Prc'$ such that $\Prc\equiv\ISes:\QHead~\mid~\Prc'$.
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the typing derivation of \Prc*, analysing the last rule applied
    \begin{inline}|
        \item \LblPrcTypEmptQ*\
        \item \LblPrcTypVQue*\
        \item \LblPrcTypDQue*\
    \end{inline}
    The hypothesis holds for each, and by the \emph{well-formedness} of processes \Prc*'\ does not contain any other \emph{free-queues}.
    \TODO[check]
    %
\end{proof}

% ~ well-formed processes
\input{tex/defs/processes/free_queues.tex}
\input{tex/defs/processes/well_formed.tex}

% ~ inversion lemma
% * 30
\begin{lemma}[Inversion Lemma]\label{lem:typ_prc_inversion}
    %
    The following claims hold:
    %
    % ~ send
    \begin{claim}
        %
        If $\VarEnv~\Entails~\PCalcSend~\PrcTyped~\SesEnv$
        then $\exists p, \SesEnv'$
        such that $\SesEnv=\SesEnv',~{p:\CIso;[\TypInteract[i][i]]}$
        and $\exists i\in I$
        such that $\ValClocks\models\Const_i$
        and $\TypComm_i=\TypSend$
        and $\PrcLabel=\MsgLabel_i$
        and $\PFuncNEQ[\SesEnv]=\emptyset$
        and either:
        \begin{enumerate}
            %
            % ~ value
            \item $\DataType_i\neq\CIso[\Const]'$
                  and $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv',~{p:\CIso+{\ReSet[]_i};[\TypeS_i]}$.
                  %
                  % ~ delegation
            \item $\DataType_i=\CIso[\Const]'$
                  and $\ValClocks'\models\Const'$
                  and $\exists{\SesEnv}''$ \begin{tabular}[t]{rl}
                      such that & $\SesEnv'={\SesEnv}'',\PrcVal:\CIso'$                                             \\
                      and       & $\VarEnv~\Entails~\Prc~\PrcTyped~{\SesEnv}'',~{p:\CIso+{\ReSet[]_i};[\TypeS_i]}$.
                  \end{tabular}
                  %
        \end{enumerate}
        %
    \end{claim}
    %
    % ~ branch
    \begin{claim}
        %
        If $\VarEnv~\Entails~\PCalcRecv~\PrcTyped~\SesEnv$
        then $\PFuncNEQ[\SesEnv]=\emptyset$
        and $\exists p, \SesEnv'$
        such that $\SesEnv=\SesEnv',~{p:\CIso;[\TypInteract[j][j]]}$
        and $\forall i \in I, \exists j\in j$
        such that $\TypComm_j=\TypRecv$
        and $\PrcLabel_i=\MsgLabel_j$
        and $\forall\ValTime\leq\PrcAfter$
        such that $\ValClocks+\ValTime\models\Const_j$
        and \Trans*{\SesEnv'+\ValTime}|:{\RecvMsg}\
        and:
        \begin{itemize}
            %
            % ~ typing
            \item $\VarEnv+\ValTime~\Entails~\PCalcRecvSingle2{\PrcAfter-\ValTime}_{i}~\PrcTyped~\SesEnv'+\ValTime,~{p:\CIso+{+\ValTime};[\TypInteract|_[j][j]]}$.
                  %
                  % ~ after
            \item $\PrcAfter\neq\infty~\Implies~\VarEnv+\PrcAfter~\Entails~\Qrc~\PrcTyped~\SesEnv'+\PrcAfter,~{p:\CIso+{+\PrcAfter};[\TypInteract[j][j]]}$.
                  %
                  % ~ error
            \item $\Qrc=\PrcErr$ if $\CIso+{+\PrcAfter};[\TypInteract[i][i]]$ is not \emph{well-formed}.
                  %
        \end{itemize}
        %
    \end{claim}
    %
    % ~ recv
    \begin{claim}
        %
        If $\VarEnv~\Entails~\PCalcRecvSingle~\PrcTyped~\SesEnv$
        then $\exists p, \SesEnv'$
        such that $\SesEnv=\SesEnv',~{p:\CIso;[\TypInteract|]}$
        and $\TypComm=\TypRecv$
        and $\PrcLabel=\MsgLabel$
        and $\forall\ValTime\leq\PrcAfter$
        such that $\ValClocks\models\Const$
        and \Trans*{\SesEnv'+\ValTime}|:{\RecvMsg}\
        and $\PFuncNEQ[\SesEnv]=\emptyset$
        and either:
        \begin{enumerate}
            %
            % ~ value
            \item $\DataType\neq\CIso[\Const]'$
                  and $\VarEnv+\ValTime~\Entails~\Prc~\PrcTyped~\SesEnv'+\ValTime,~\PrcMsg:\DataType,~{p:\CIso+{+\ValTime\ReSet[]};[\TypeS]}$.
                  %
                  % ~ delegation
            \item $\DataType=\CIso[\Const]'$
                  and $\ValClocks'\models\Const'$
                  and $\VarEnv+\ValTime~\Entails~\Prc~\PrcTyped~\SesEnv'+\ValTime,~{p:\CIso+{+\ValTime\ReSet[]};[\TypeS]},~\PrcMsg:\CIso'$.
                  %
        \end{enumerate}
        %
    \end{claim}
    %
    % ~ parl
    \begin{claim}
        %
        If $\VarEnv~\Entails~\Parl{\Prc,\Qrc}~\PrcTyped~\SesEnv$
        then $\SesEnv=\SesEnv_1,\SesEnv_2$
        and $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv_1$
        and $\VarEnv~\Entails~\Qrc~\PrcTyped~\SesEnv_2$.
        %
    \end{claim}
    %
    % ~ scope
    \begin{claim}
        %
        If $\VarEnv~\Entails~{(\nu q p)\Prc}~\PrcTyped~\SesEnv$
        then $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,
            ~{p:\VIso_1},
            ~{q:\VIso_2},
            ~{qp:\Queue_1},
            ~{pq:\Queue_2}$
        and \Compat*.
        %
    \end{claim}
    %
    % ~ rec var
    \begin{claim}
        %
        If $\VarEnv~\Entails~\RecPrcCall~\PrcTyped~\SesEnv$
        then $\exists\VarEnv'$
        such that $\VarEnv=\VarEnv',~\EnvPrcVar$
        and $\SesEnv\in\RecSetRoles$
        \linebreak
        and $\forall \DataType\in\RecPrcMsg,\exists \PrcMsg\in\RecSetMsg$
        such that $\VarEnv~\Entails~\PrcMsg:\DataType$
        and $\forall \Const\in\RecPrcTimers,\exists x\in\RecSetTimers$
        such that $x\models\Const$.
        %
    \end{claim}
    %
    % ~ rec def
    \begin{claim}
        %
        If $\VarEnv~\Entails~\PrcRecDef~\PrcTyped~\SesEnv$
        then $\forall \PSesSetCfgs\in\SesSet$
        such that
        \linebreak
        $\VarEnv,~\RecSetMsg:\RecPrcMsg,~\RecSetTimers:\RecPrcTimers,~\RecVar:\EnvPrcVar%
            ~\Entails~%
            \Prc%
            ~\PrcTyped~%
            \RecSetRoles:\PSesSetCfgs$
        and $\VarEnv,~\RecVar:\EnvPrcVar%
            ~\Entails~%
            \Qrc%
            ~\PrcTyped~%
            \SesEnv$.
        %
    \end{claim}
    %
    % ~ par rec
    \begin{claim}
        %
        If $\VarEnv~\Entails~\PrcRecDef>{\Parl{\Qrc,\Qrc'}}~\PrcTyped~\SesEnv$
        then $\SesEnv=\SesEnv_1,\SesEnv_2$
        and $\VarEnv,~\EnvPrcVar~\Entails~\Qrc~\PrcTyped~\SesEnv_1$
        and $\VarEnv,~\EnvPrcVar~\Entails~\Qrc'~\PrcTyped~\SesEnv_2$.
        %
    \end{claim}
    %
    % ~ empty buffer
    \begin{claim}
        %
        If $\VarEnv~\Entails~{qp:\emptyset}~\PrcTyped~\SesEnv$
        then $\exists \SesEnv'$
        such that $\SesEnv=\SesEnv',~{qp:\emptyset}$
        %
    \end{claim}
    %
    % ~ buffer
    \begin{claim}
        %
        If $\VarEnv~\Entails~{qp:\PrcLabel\PrcMsg\cdot\QHead}~\PrcTyped~\SesEnv$
        then $\exists \SesEnv'$
        such that $\SesEnv=\SesEnv',~{qp:\IMsgType[\MsgLabel'];\Queue}$
        and $\PrcLabel=\MsgLabel'$
        then $\PFuncNEQ[\SesEnv]=\emptyset$
        and either:
        \begin{enumerate}
            %
            % ~ value
            \item $\DataType\neq\CIso[\Const]'$
                  and $\VarEnv~\Entails~{\PrcMsg:\DataType}$
                  and $\VarEnv~\Entails~{qp:\QHead}~\PrcTyped~\SesEnv',~{qp:\Queue}$.
                  %
                  % ~ delegation
            \item $\DataType=\CIso[\Const]'$
                  and $\ValClocks'\models\Const'$
                  and $\PrcMsg=q$
                  and $\exists {\SesEnv}''$
                  such that $\SesEnv'={\SesEnv}'',~{q:\CIso'}$
                  and $\VarEnv~\Entails~{qp:\QHead}~\PrcTyped~\SesEnv',~{qp:\Queue}$.
                  %
        \end{enumerate}
        %
    \end{claim}
    %
    % ~ delay
    \begin{claim}
        %
        If $\VarEnv~\Entails~{\mathtt{delay}(\ValTime).\Prc}~\PrcTyped~\SesEnv$
        then $\PFuncNEQ[\SesEnv]=\emptyset$
        and $\forall \ValTime'<\ValTime$
        such that \Trans*{\SesEnv+\ValTime}|:{\RecvMsg}\
        and $\VarEnv+\ValTime~\Entails~\Prc~\PrcTyped~\SesEnv+\ValTime$.
        %
    \end{claim}
    %
\end{lemma}
\begin{proof}
    %
    By inspection of the typing rules for processes in~\cref{fig:prc_typ_rule}, given the structure of \Prc*\ each claim holds.
    %
\end{proof}

% ~ fail free processes
\input{tex/defs/processes/fail_free.tex}

% ~ balanced sessions
In~\cref{def:session_balanced} the notion of compatibility (\cref{def:configs_compat}) is extended from individual system configurations, across all \SesEnv*\ in the balanced set \BalSes*.
%
\input{tex/defs/processes/session/balanced.tex}
\input{tex/defs/processes/session/fully_balanced.tex}

% ~ free queues of session
\input{tex/defs/processes/session/free_queues.tex}

% ~ typing environmental variables
% * 45
\begin{lemma}
    %
    The following hold:
    \begin{enumerate}
        %
        % ~ DRecv
        \item If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,~{p:\CIso}$
              and $\PrcMsg\not\in\SesDomain$
              then $\VarEnv~\Entails~\Prc\Subst[\PrcMsg][p]~\PrcTyped~\SesEnv,~\PrcMsg:\CIso$.
              %
              % ~ VRecv
        \item If $\VarEnv_1,~{\PrcMsg:\DataType}~\Entails~\Prc~\PrcTyped~\SesEnv$
              and $\VarEnv_2~\Entails~{\PrcVal:\DataType}$
              and $\SesDomain[\VarEnv_1]\cap\SesDomain[\VarEnv_2]=\emptyset$
              then \hspace*{\fill}\begin{tabular}[t]{l}\\\llap{$\VarEnv_1,\VarEnv_2~\Entails~\Prc\Subst[\PrcVal][\PrcMsg]~\PrcTyped~\SesEnv$}.\end{tabular}
              %
              % ~ Var
        \item If $\VarEnv_1,~{x:n}~\Entails~\Prc~\PrcTyped~\SesEnv$
              and $\VarEnv_2~\Entails~{y\models\Const}$
              and $\SesDomain[\VarEnv_1]\cap\SesDomain[\VarEnv_2]=\emptyset$
              then \hspace*{\fill}\begin{tabular}[t]{l}\\\llap{$\VarEnv_1,\VarEnv_2~\Entails~\Prc\Subst[y][x]~\PrcTyped~\SesEnv$}.\end{tabular}
              %
    \end{enumerate}
    %
\end{lemma}
\begin{proof}
    %
    By the premise of the relevant typing rule in~\cref{fig:prc_typ_rule}
    \begin{inline}|
        \item \LblPrcTypDRecv*\
        \item \LblPrcTypVRecv*\
        \item \LblPrcTypVar*\
    \end{inline}
    %
\end{proof}

% * 46
\begin{lemma}
    %
    If $\VarEnv~\Entails~{\PrcVal:\DataType}$
    then \DataType*\ is a \emph{base type}.
    %
\end{lemma}
\begin{proof}
    %
    Follows~\cref{fig:prc_typ_rule} that \DataType*\ is not a \emph{delegation type} by inspecting the premise of the relevant typing rule
    \begin{inline}|
        \item \LblPrcTypVSend*\
        \item \LblPrcTypVQue*\
    \end{inline}
    %
\end{proof}

% * 47
\begin{lemma}
    %
    Let $\VarEnv~\Entails~{qp:\QHead}~\PrcTyped~\SesEnv,~{qp:\Queue}$.
    The following hold:
    \begin{itemize}
        %
        % ~ val
        \item If $\VarEnv~\Entails~{\PrcVal:\DataType}$
              then $\VarEnv~\Entails~{qp:\QHead\cdot\PrcVal}~\PrcTyped~\SesEnv,~{qp:\Queue;\DataType}$.
              %
              % ~ delegation
        \item If $\DataType=\CIso[\Const]$
              and $\ValClocks\models\Const$
              and $p\not\in\SesDomain$
              then $\VarEnv~\Entails~{qp:\QHead\cdot p}~\PrcTyped~\SesEnv,~{qp:\Queue;\DataType},~{p:\CIso}$.
              %
    \end{itemize}

    %
\end{lemma}
\begin{proof}
    %
    Follows~\cref{fig:prc_typ_rule} by inspecting the premise of the relevant typing rule
    \begin{inline}|
        \item \LblPrcTypDQue*\
        \item \LblPrcTypVQue*\
    \end{inline}
    %
\end{proof}

% ~ typing receptions
% * 32
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,~{p:\CIso}$
    and \PCalc*{\TimePass{\Prc}}\ is defined and \emph{error-free}
    and $\exists \Msg$
    such that \Trans*{\CIso}:{\RecvMsg}\
    then $p\in\PFuncWait$.
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the transition \Trans*{\CIso}:{\RecvMsg}\ via either
    \begin{inline}|
        \item \LblCfgIsoInteract*\
        \item \LblCfgIsoUnfold*\
    \end{inline}
    \begin{inductivecase}
        %
        % ~ choice
        \item\NewCase[\LblCfgIsoInteract*] then $\TypeS=\simplechoice$.
        By~\cref{lem:typ_prc_role_wf} \CIso*\ is \emph{well-formed} and by~\cref{lem:cfg_wf_then_live} is also \isFE*.
        By inner induction on the typing derivation of the hypothesis.
        \begin{inductivecase}
            %
            % ~ branch
            \item\NewCase[\LblPrcTypBranch*] then $\Prc=\PCalcRecv$ and the hypothesis holds.
            %
            % ~ d recv
            \item\NewCase[\LblPrcTypDRecv*] then $\Prc=\PCalcRecvSingle$ and the hypothesis holds. \LblPrcTypVRecv*\ is similar.
            %
            % ~ rec
            \item\NewCase[\LblPrcTypRec*] then $\Prc=\PrcRecDef$ and the hypothesis depends on the structure of \Qrc*\ (see other cases).
            %
        \end{inductivecase}
        % Cases \LblPrcTypRes*\ and \LblPrcTypPar*\ are straightforward.
        %
    \end{inductivecase}
    We omit case \LblCfgIsoUnfold*\ as $\TypeS=\mu\alpha.\TypeS'$ as it follows~\cref{lem:cfg_wf_then_live,lem:cfgs_trans_wf_pres,lem:configs_trans_compat_pres} that there exist some continuation of \TypeS*\ such that case \LblCfgIsoInteract*\ applies.
    %
\end{proof}

% * 33
\begin{lemma}\label{typ_prc_ses_que_then_neq}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,~{qp:\Msg;\Queue}$
    then $p\in\PFuncNEQ$.
    %
\end{lemma}
\begin{proof}
    %
    By induction on the typing derivation the last rule applied is either
    \begin{inline}|
        \item \LblPrcTypVQue*\
        \item \LblPrcTypDQue*\
    \end{inline}
    \Prc*\ must be structured such that $\VarEnv~\Entails~{qp:\PrcMsg\cdot\QHead}~\PrcTyped~\SesEnv,~{qp:\Msg;\Queue}$ and $\PFuncNEQ[qp:\PrcMsg\cdot\QHead]=\{p\}$.
    %
\end{proof}

% * 34
\begin{lemma}\label{typ_prc_neq_then_ses_que}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    and $p\in\PFuncNEQ$
    then $\exists \SesEnv'$
    such that $\SesEnv=\SesEnv',~{qp:\Msg;\Queue}$.
    %
\end{lemma}
\begin{proof}
    %
    \Prc*\ must be structured such that $\Prc\equiv\Parl{qp:\PrcMsg\cdot\QHead,\Qrc}$.
    The hypothesis follows~\cref{typ_prc_ses_que_then_neq}.
    %
\end{proof}

% ~ delaying processes
% * 37
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,
        ~{p:\VIso_1},
        ~{q:\VIso_2},
        ~{qp:\Queue_1},
        ~{pq:\Queue_2}$
    and \Compat*\
    and \SesEnv*\ is \emph{balanced}
    and \PCalc*{\TimePass{\Prc}}\ is defined and \emph{error-free}
    then $p\not\in\PFuncNEQ$
    and $q\not\in\PFuncNEQ$.
    %
\end{lemma}
\begin{proof}
    %
    We only show the case of $p:\CIso_1$.
    By~\cref{lem:typ_prc_inversion} and \LblPrcTypRes*\ the structure of \Prc*\ must be such that $\Prc\equiv\Parl{\Prc',\Qrc,{qp:\QHead},{pq:\QHead'}}$.
    By the induction hypothesis \PCalc*{\TimePass{\Parl{\Prc',\Qrc,{qp:\QHead},{pq:\QHead'}}}}\ is defined and therefore $p\not\in\PFuncNEQ$.
    %
\end{proof}

% * 39
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv,~{p:\CIso}$
    and \CIso*\ is \isFE*\
    and $\PFuncNEQ=\emptyset$
    and \PCalc*{\TimePass{\Prc}}\ is defined and \emph{error-free}
    then \CIso*+{+\ValTime}\ is \isFE*.
    %
\end{lemma}
\begin{proof}
    %
    By~\cref{lem:cfg_wf_then_live} $\TypeS=\simplechoice$
    and $\exists \Const_i$
    such that $\ValClocks\models\Past[\Const_i]$
    and $\emptyset;\Past[\Const_i]~\Entails~\TypInteract[i][i]$.
    We proceed by induction on the structure of \Prc*\ such that \PCalc*{\TimePass{\Prc}}\ is defined and the value of \ValTime*\ is relevant.
    \begin{inductivecase}
        %
        %
        % ~ delay
        \item\NewCase[$\Prc=\mathtt{delay}(\ValTime').\Prc'$] then $\ValTime\leq\ValTime'$.
        By~\cref{lem:typ_prc_inversion} $\VarEnv+\ValTime'~\Entails~\Prc'~\PrcTyped~\SesEnv+\ValTime',~{p:\CIso+{+\ValTime'}}$ and by~\cref{lem:typ_prc_role_wf} \CIso*+{+\ValTime'}\ is \emph{well-formed}. It follows~\cref{lem:cfg_fe_timepass_wf_fe} that the hypothesis holds.
        %
        %
        % ~ receive
        \item\NewCase[$\Prc=\PCalcRecv$] By~\cref{lem:typ_prc_inversion} and \LblPrcTypBranch*\ $\forall\ValTime'\leq\PrcAfter$ it holds that $\VarEnv+\ValTime'~\Entails~\Prc~\PrcTyped~\SesEnv+\ValTime',~{p:\CIso+{+\ValTime'}}$.
        If $\ValTime>\PrcAfter$ then \PCalc*{\TimePass{\Prc}=\TimePass{\Qrc}}\ and by the hypothesis $\Qrc\neq\PrcErr$.
        By~\cref{lem:typ_prc_role_wf,lem:timepass_func_defined_t} the hypothesis holds.
        Case $\Prc=\PCalcRecvSingle$ is similar.
        %
    \end{inductivecase}
    %
\end{proof}

% ~ delayable sessions
\input{tex/defs/processes/session/delayable.tex}
% * 40
\begin{lemma}
    %
    If \SesEnv*\ is \emph{balanced} and \emph{delayable}
    and $\SesEnv+\ValTime$ is \emph{well-formed}
    then $\SesEnv+\ValTime$ is \emph{balanced}.
    %
\end{lemma}
\begin{proof}
    %
    By~\cref{def:session_balanced} $\SesEnv=\SesEnv',%
        ~{\PrcP:\VIso_1},
        ~{\PrcQ\PrcP:\Queue_1},%
        ~{\PrcQ:\VIso_2},%
        ~{\PrcP\PrcQ:\Queue_2}$
    and \Compat*\ and by~\cref{def:prc_typ_sesenv_delayable} $\Queue_1=\emptyset=\Queue_2$.
    By~\cref{lem:cfgs_trans_wf_pres,lem:configs_trans_compat_pres} if \Compat*\ and \Trans*{\VSoc_1}:{\ValTime}[\VSoc'_1]\ and \Trans*{\VSoc_2}:{\ValTime}[\VSoc'_2]\ then \Compat*'.
    %
\end{proof}

% * 41
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    and \PCalc*{\TimePass{\Prc}}\ is defined
    and \SesEnv*\ is \emph{balanced}
    then \SesEnv*\ is \emph{delayable}.
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the structure of \Prc*\ such that \PCalc*{\TimePass{\Prc}}\ is defined and \emph{well-typed} against a \emph{balanced} \SesEnv*.
    % ~ parl
    If $\Prc=\Parl{\Prc',\Qrc}$ then \PCalc*{\TimePass{\Prc'}}\ and \PCalc*{\TimePass{\Qrc}}\ are defined.
    Suppose by contradiction that \PCalc*{\TimePass{\Prc}}\ is \emph{not} defined. \Prc*'\ and \Qrc*\ must be structured such that $\PFuncWait[\Prc']\cup\PFuncNEQ[\Qrc]\neq\emptyset$ and it must be that $\Prc'=\PCalcRecv[i][i][\Qrc']$ and $\Qrc={qp:\PrcMsg\cdot\QHead}$.
    By~\cref{def:session_balanced} $\exists \SesEnv'$ such that $\SesEnv=\SesEnv',~{p:\CIso_1},~{qp:\Msg;\Queue_1}$ and $\exists \Msg:\Trans{\CIso_1}:{\RecvMsg}$. However as \PCalc*{\TimePass{\Prc}}\ is defined, there are no messages able to be received by \Prc*\ which is \emph{well-typed} against \SesEnv*. Therefore follows that \SesEnv*\ is \emph{delayable} by~\cref{def:prc_typ_sesenv_delayable}.
    %
\end{proof}

% * 42
\begin{lemma}\label{lem:well_typed_delayed_prc}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    and \PCalc*{\TimePass{\Prc}}\ is defined and \emph{error-free}
    and $\PFuncNEQ=\emptyset$
    and $\SesEnv+\ValTime$ is \emph{well-formed}
    then $\VarEnv+\ValTime~\Entails~\PCalc{\TimePass{\Prc}}~\PrcTyped~\SesEnv+\ValTime$.
    %
\end{lemma}
\begin{proof}
    %
    We proceed by induction on the structure of \Prc*\ such that \PCalc*{\TimePass{\Prc}}\ is defined and \emph{error-free}.
    \begin{inductivecase}
        %
        %
        % ~ recv
        \item\NewCase[$\Prc=\PCalcRecv$] By~\cref{lem:typ_prc_inversion} $\SesEnv=\SesEnv',~{p:\CIso;[\simplechoice_{j}]}$.
        By inner induction on the typing derivation analysing the last rule applied: \LblPrcTypBranch*\ %(and \LblPrcTypDRecv*, \LblPrcTypVRecv*)
        \begin{inductivecase}
            %
            % ~ t <= n
            \item\NewCase[If $\ValTime\leq\PrcAfter$ then] $\forall \ValTime'\leq\PrcAfter-\ValTime$~\cref{eq:well_typed_delayed_prc_branch} holds and $\forall {\ValTime}''\leq\ValTime:\Trans{\SesEnv+\ValTime'+{\ValTime}''}|:{\RecvMsg}$ and $\forall j\in J$ such that $\ValClocks+\ValTime+\ValTime'\models\Const_j~\implies~\TypComm_j=\TypRecv$ and $\exists i\in I$ such that $\PrcLabel_i=\MsgLabel_j$ and:
            \begin{itemize}
                %
                % ~ val
                \item$\DataType_j\neq\CIso[\Const]~\implies~\VarEnv+\ValTime+\ValTime',\PrcMsg_i:\DataType_j~\Entails~\Prc_i~\PrcTyped~\SesEnv+\ValTime+\ValTime',~{p:\CIso+{+\ValTime+\ValTime'\ReSet[]_j};[\TypeS_j]}$.
                %
                % ~ delegation
                \item$\DataType_j=\CIso[\Const]~\implies~\VarEnv+\ValTime+\ValTime'~\Entails~\Prc_i~\PrcTyped~\SesEnv+\ValTime+\ValTime',~{p:\CIso+{+\ValTime+\ValTime'\ReSet[]_j};[\TypeS_j]},~{\PrcMsg_i:\CIso'}$ %\linebreak \hspace*{\fill} 
                and $\ValClocks'\models\Const'$.
                %
            \end{itemize}
            \begin{minieq}\label{eq:well_typed_delayed_prc_branch}
                \VarEnv+\ValTime+\ValTime'~\Entails~\PCalcRecv2{\PrcAfter-(\ValTime+\ValTime')}~\PrcTyped~\SesEnv+\ValTime+\ValTime',~{p:\CIso+{+\ValTime+\ValTime'};[\simplechoice_{j}]}
            \end{minieq}\vspace{-4ex}%
            %
            % ~ t > n
            \item\NewCase[If $\ValTime>\PrcAfter$ then] \PCalc*{\TimePass{\Prc}=\TimePass_{\ValTime-\PrcAfter}{\Qrc}}\ and $\Qrc\neq\PrcErr$ and $\VarEnv+\PrcAfter~\Entails~{\Qrc}~\PrcTyped~\SesEnv+\PrcAfter$. It follows by induction hypothesis $\VarEnv+\ValTime~\Entails~\PCalc{\TimePass_{\ValTime-\PrcAfter}{\Qrc}}~\PrcTyped~\SesEnv+\ValTime$.
            %
        \end{inductivecase}
        %
        %
        % ~ delay
        \item\NewCase[$\Prc=\mathtt{delay}(\ValTime').\Prc'$] then $\ValTime\leq\ValTime'$ and $\forall {\ValTime}''\leq\ValTime':\Trans{\SesEnv+{\ValTime}''}|:{\RecvMsg}$. By induction hypothesis $\VarEnv+\ValTime~\Entails~{\mathtt{delay}(\ValTime'-\ValTime).\Prc'}~\PrcTyped~\SesEnv+\ValTime$.
        %
        %
        % ~ parl
        \item\NewCase[$\Prc=\Parl{\Prc',\Qrc}$] By~\cref{lem:typ_prc_inversion} $\SesEnv=\SesEnv_1,\SesEnv_2$.
        %
        %
        % ~ scope
        \item\NewCase[$\Prc=(\nu qp)\Prc'$] By~\cref{lem:typ_prc_inversion} $\SesEnv=\SesEnv',~{p:\CIso;[\simplechoice_{j}]}$.
        %
    \end{inductivecase}
    %
\end{proof}

% ~ typing delayed processes
% * 43
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    then
    %
\end{proof}

% * 44
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    then
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% ~ typing reduction steps
% * 49
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    then
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 50
\begin{lemma}
    %
    If $\VarEnv~\Entails~\Prc~\PrcTyped~\SesEnv$
    then
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% ~ fail-free processes
% * 51
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 52
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 54
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% ~ fail free reduction
% * 55
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 56
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 57
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 62
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 61
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% ~ untimed processes
% * 60
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% * 63
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

% ~ subject reduction
% * 64
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

\endinput

% * 
\begin{lemma}
    %
    %
\end{lemma}
\begin{proof}
    %
    %
\end{proof}

\begin{definition}[Future-enabled Actions (\isFE*$\TypSend/\TypRecv$)]\label{def:fe_actions}
    %
    A configuration \VIso*\
    is \isFE*\
    if $\exists\ValTime,\TypComm,\Msg$
    such that \Trans*{\VIso}:{\ValTime,\CommMsg}[\VIso'];
    \VIso*\ is \isFE*!\ if $\TypComm=\TypSend$,
    and is \isFE*?\ if $\TypComm=\TypRecv$.
    %
\end{definition}

\input{tex/defs/processes/fail_free.tex}

In~\cref{def:session_balanced} the notion of compatibility (\cref{def:configs_compat}) is extended from individual system configurations, across all \SesEnv*\ in the balanced set \BalSes*.
%
\input{tex/defs/processes/session/balanced.tex}
\input{tex/defs/processes/session/fully_balanced.tex}

\input{tex/defs/processes/session/free_queues.tex}

% ~ future enabled
\input{tex/proofs/reduction/lem/configs_viable_actions.tex} % 23
\input{tex/proofs/reduction/lem/configs_wf_timestep_fe.tex} % 31

% ~ typing judgements
\input{tex/proofs/reduction/lem/typing/inversion.tex} % 30
\input{tex/proofs/reduction/lem/typing/iso_wf.tex} % 36
% 48

% ~ substitution lemma
% 45
% 46

% ~ delaying processes
\input{tex/proofs/reduction/lem/typing/prc_role_waiting.tex} % 32
\input{tex/proofs/reduction/lem/typing/prc_buff_nonempty.tex} % 33
\input{tex/proofs/reduction/lem/delay_defined.tex} % 35

% ~ typing delayed processes
\input{tex/proofs/reduction/lem/typing/delay_defined.tex} % 37
\input{tex/proofs/reduction/lem/typing/delayed_fe.tex} % 39

% * time passing sesenv
% A \SesEnv*\ is delayable given that for every non-empty queue, there does not exist a role capable of receiving from it.
\input{tex/defs/processes/session/delayable.tex}

\input{tex/proofs/reduction/lem/delayable/delayed_balanced.tex} % 40
\input{tex/proofs/reduction/lem/delayable/defined_delayable.tex} % 41
\input{tex/proofs/reduction/lem/delayable/typing_delayed_prc.tex} % 42

% 43
% 44

% 47

% ~ typing preserved across session reduction
\input{tex/figs/processes/session_reduction.tex}
% 49
% 50

% ~ fail free delay
% 51
% 52
% 53
% 54

% ~ fail free session
% 55

% ! TODO: untimed ? ? ? ? ?

% ! (lemma 43) : timestep preserve balanced sesenv
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ? (lemma 44) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 45) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 46) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 47) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 49) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 50) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 52) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 54) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 55) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 56) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 57) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 58) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 59) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 60) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 61) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 62) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 63) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ! (lemma 64) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

\endinput

% ! (lemma ) : 
\begin{lemma}%\label{lem:}
    %
    \TODO
    %
\end{lemma}
\begin{proof}
    %
    \TODO
    %
\end{proof}

% ~ () 
\begin{claim}
    %
    \TODO
    %
\end{claim}
