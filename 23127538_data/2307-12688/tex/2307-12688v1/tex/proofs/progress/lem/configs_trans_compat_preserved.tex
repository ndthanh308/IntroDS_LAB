%
% ! (lemma 15) : compat, single transition -> compat
\begin{lemma}\label{lem:configs_trans_compat_pres}
	%
	If \VIso*_1\ and \VIso*_2\ are both \emph{well-formed} 
    and \Compat*[\VSoc_1][\VSoc_2]\ 
    and \Trans*{\Parl{\VSoc_1,\VSoc_2}}[\Parl{\VSoc'_1,\VSoc'_2}], 
	then \Compat*[\VSoc'_1][\VSoc'_2].
	%
\end{lemma}
\begin{proof}
	%
	We proceed by induction on the depth of the derivation tree, analysing each case of the last rule applied for the transition \Trans*{\Parl{\VSoc_1,\VSoc_2}}[\Parl{\VSoc'_1,\VSoc'_2}]:
	% \begin{inline}+
	% 	\item \LblCfgSysWait*
	% 	\item \LblCfgSysLComm*
	% 	\item \LblCfgSysLPar*
	% \end{inline}
	%
	\begin{inductivecase}
		%
		%
		%
		%
		%
		% ~ wait
		\item\NewCase[\LblCfgSysWait*]\label{case:configs_trans_compat_pres_wait}
		Then both \VSoc*_1\ and \VSoc*_2\ make a \ValTime*\ transition via \LblCfgSocTime*\ as shown in~\Cref{eq:configs_trans_compat_pres_wait_trans}.
		%
        If $\ValTime=0$ then by~\Cref{lem:configs_iso_trans,lem:configs_soc_trans} $\VSoc_1=\VSoc'_1$ and $\VSoc_2=\VSoc'_2$ and the hypothesis holds; \Compat*[\VSoc'_1][\VSoc'_2].
        %
        \begin{minieq}\label{eq:configs_trans_compat_pres_wait_trans}
            \infer[\LblCfgSysWait]{%
                \Trans{\Parl{\VSoc_1,\VSoc_2}}:{\ValTime}[\Parl{\VSoc'_1,\VSoc'_2}]
            }{%
                \infer[\LblCfgSocTime]{%
                    \Trans{\VSoc_1}:{\ValTime}[\VSoc'_1]
                }{\dots}
                & %
                \infer[\LblCfgSocTime]{%
                    \Trans{\VSoc_2}:{\ValTime}[\VSoc'_2]
                }{\dots}
            }
        \end{minieq}
        
        \noindent If $\ValTime>0$ then by~\Cref{lem:configs_iso_trans,lem:configs_soc_trans} $\ValClocks'_1=\ValClocks_1+\ValTime$ and $\TypeS'_1=\TypeS_1$ and $\Queue'_1=\Queue_1$ (and the same for \ValClocks*'_2, \TypeS*'_2\ and \Queue*'_2).
		%
        By~\Cref{lem:cfgs_trans_wf_pres} \VIso*'_1\ and \VIso*'_2\ are both \emph{well-formed}.
		%
		By~\Cref{lem:sys_compat_time_trans} $\Queue_1=\emptyset=\Queue_2$ and by~\Cref{itm:configs_compat_dual_types} of~\Cref{def:configs_compat} $\ValClocks_1=\ValClocks_2$ and $\TypeS_1=\Dual[\TypeS_2]$.
		%
		Therefore \Compat*[\CSoc[\ValClocks_1]+{+\ValTime};[\TypeS_1]:{\emptyset}][\CSoc[\ValClocks_2]+{+\ValTime};[\Dual[\TypeS_2]]:{\emptyset}].
		%
		%
		%
		%
		%
		% ~ comm
		\item\NewCase[\LblCfgSysLComm*]\label{case:configs_trans_compat_pres_comm}
		By~\cref{lem:cfgs_trans_wf_pres} both \VIso*'_1\ and \VIso*'_2\ are \emph{well-formed}.
        The transition is as shown below: %in~\cref{eq:configs_trans_compat_pres_comm_trans}.
		%
		\begin{minieq}*\label{eq:configs_trans_compat_pres_comm_trans}
			% \begin{array}{c}%\mathllap{%
			\resizebox{\linewidth}{!}{$%
				\infer[\LblCfgSysLComm]{%
					\Trans{\Parl{\CSoc[\ValClocks_1];[\TypeS_1]:{\emptyset},\CSoc[\ValClocks_2];[\TypeS_2]:{\Queue_2}}}:{\SiltAction}[\Parl{\CSoc[\ValClocks'_1];[\TypeS'_1]:{\emptyset},\CSoc[\ValClocks_2];[\TypeS_2]:{\Queue_2;\Msg}}]
				}{%
					\infer[\LblCfgSocSend]{%
						\Trans{\CSoc[\ValClocks_1];[\TypeS_1]:{\emptyset}}:{\SendMsg}[\CSoc[\ValClocks_1]+{\ReSet[]_j};[\TypeS_j]:{\emptyset}]
					}{%
						\infer[\LblCfgIsoInteract]{%
							\Trans{\CIso[\ValClocks_1];[\TypInteract]}:{\SendMsg}[\CIso[\ValClocks_1]+{\ReSet[]_j};[\TypeS_j]]
						}{%
                        \ValClocks_1\models\Const_j
                        & %
                        {m}={l_j\left\langle T_j \right\rangle}
                        & % 
                        {\TypSend=\TypComm_j}
                        & % 
                        j\in I
						}
					}
					& %
					% \infer[\LblCfgSocEnqu]{%
						\Trans{\VSoc_2}:{\RecvMsg}[\CSoc[\ValClocks_2];[\TypeS_2]:{\Queue_2;\Msg}]
						\quad \LblCfgSocEnqu
					% }{\dots}
				}
			$}%
	%	}\end{array}
		\end{minieq}
		
        \noindent We proceed by inner induction on each combination of the contents of queues:
		\begin{inductivecase}
			%
			%
			% ~ comm -> e e
			\item\NewCase[$\Queue_1=\emptyset$, $\Queue_2=\emptyset$]\label{case:configs_trans_compat_pres_comm_ee}
			By~\Cref{itm:configs_compat_dual_types} of~\Cref{def:configs_compat} $\ValClocks_1=\ValClocks_2$ and $\TypeS_1=\Dual[\TypeS_2]$.
			%
			The resulting system is no longer \emph{dual}.
			%
			By~\cref{lem:cfgs_trans_wf_pres,lem:sys_compat_time_trans} time cannot pass if $\Queue_2\neq\emptyset$.
			%
			By~\Cref{def:types_dual} the message \Msg*\ sent by \VSoc*_1\ must have a corresponding receiving action in \VSoc*_2\ as in~\Cref{itm:configs_compat_expected_receive} of~\Cref{def:configs_compat}.
			%
			Therefore \Compat*[\CSoc[\ValClocks'_1];[{\TypeS}'_1]:{\emptyset}][\CSoc;+{\Msg}_2].
			%
			%
			%
			% ~ comm -> e m
			\item\NewCase[$\Queue_1=\emptyset$, $\Queue_2\neq\emptyset$]\label{case:configs_trans_compat_pres_comm_en}
			By~\Cref{itm:configs_compat_expected_receive} of~\Cref{def:configs_compat} $\exists\Msg',{\ValClocks}'',{\TypeS}''$ such that $\Queue_2=\Msg';\Queue_2$ and \Trans*{\CIso_2}:{\TypRecv,\Msg'}[\CIso[{\ValClocks}''_2];[{\TypeS}''_2]]\ and \Compat*[\CSoc[\ValClocks'_1];[{\TypeS}'_1]:{\emptyset}][\CSoc[{\ValClocks}''_2];[{\TypeS}''_2]:{{\Queue}_2}]\ and by \LblCfgSocTime*\ (urgency) time cannot pass.
			%
			If a system has a configuration with sequence of outgoing sending actions and each has constraints that are satisfiable immediately after the other, then the system can both receive the messages as they arrive, or accumulate the messages and instantly receive each in succession and become \emph{dual} again (by inspection of~\Cref{def:types_dual,def:configs_compat} and~\Cref{fig:types_rule,fig:typesemantics_tuple,fig:typesemantics_triple}).
			%
			Therefore \Compat*[\CSoc[\ValClocks'_1];[{\TypeS}'_1]:{\emptyset}][\CSoc[{\ValClocks}''_2];[{\TypeS}''_2]:{\Msg';{\Queue}_2;\Msg}].
			%
			%
			% ~ comm -> m e
			\item\NewCase[$\Queue_1\neq\emptyset$, $\Queue_2=\emptyset$]\label{case:configs_trans_compat_pres_comm_ne}
			Contradicts the hypothesis by~\Cref{itm:configs_compat_expected_receive} of~\Cref{def:configs_compat} as by \LblCfgSocTime*\ (urgency) messages must be removed from a queue immediately, and by \LblTypChoice*\ of~\Cref{fig:types_rule} sending and receiving actions cannot be performed at the same time.
			%
			%
			% ~ comm -> m m
			\item\NewCase[$\Queue_1\neq\emptyset$, $\Queue_2\neq\emptyset$]\label{case:configs_trans_compat_pres_comm_nn}
			Contradicts the hypothesis by~\Cref{itm:configs_compat_non_empty_queues} of~\Cref{def:configs_compat}.
			%
		\end{inductivecase}

		\noindent Therefore, compatibility is preserved across \LblCfgSysLComm*\ transitions.
		%
		%
		%
		%
		%
		% ~ dequ
		\item\NewCase[\LblCfgSysLPar*]\label{case:configs_trans_compat_pres_dequ}
		By~\Cref{lem:configs_soc_trans} $\Queue_2=\Msg;\Queue_2$ and by~\Cref{itm:configs_compat_expected_receive} of~\Cref{def:configs_compat} \Compat*[\VSoc'_1][\VSoc'_2], the hypothesis holds.
		%
	\end{inductivecase}

	\noindent Therefore, it holds that any transition made by a compatible system composed of well-formed types will result in configurations that are \emph{compatible}.
	%
\end{proof}
% 