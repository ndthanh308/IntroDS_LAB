% process reduction rules

% timer
\newcommand{\mpreducttimer}[0]{%
   \mprctimerset[x].\,\left(\mprc\right)%
   \mid%
   \mqrc%
   %
   \mareduce%
   %
   \mprctimer[x:0]\left(\mprc\right)%
   \mid%
   \mqrc%
}

% reset
\newcommand{\mpreductreset}[0]{%
   \mprctimer[x]\left(\mprctimerset[x].\,\mprc\right)%
   \mid%
   \mqrc%
   %
   \mareduce%
   %
   \mprctimer[x:0]\left(\mprc\right)%
   \mid%
   \mqrc%
}

% reduce
\newcommand{\mpreductareduce}[0]{%
   \infer{%
      \mprc\mreduce\mqrc%
   }{%
      \mprc\mareduce\mqrc%
   }
}

% time reduce
\newcommand{\mpreducttreduce}[0]{%
   \infer{%
      \mprc\mreduce\mqrc%
   }{%
      \mprc\mtreduce\mqrc%
   }
}

% delay
\newcommand{\mpreductdelay}[0]{%
   \mprc%
   %
   \mtreduce%
   %
   \mptimefunc[\mprc]%
}

% scope
\newcommand{\mpreductscope}[0]{%
   \infer{%
      \left(\nu\mepointp\mepointq\right)\mprc%
      \mreduce%
      \left(\nu\mepointp\mepointq\right)\mprc'%
   }{%
      \mprc\mareduce\mprc'%
   }
}

% structural congruence
\newcommand{\mpreductastr}[0]{%
   \infer{%
      \mprc\mreduce\mqrc%
   }{%
      \mprc\equiv\mprc'%
      \quad%
      \mprc'\mareduce\mqrc'%
      \quad%
      \mqrc'\equiv\mqrc%}
   }
}

% timed structural congruence
\newcommand{\mpreducttstr}[0]{%
   \infer{%
      \mprc\mreduce\mqrc%
   }{%
      \mprc\equiv\mprc'%
      \quad%
      \mprc'\mtreduce\mqrc'%
      \quad%
      \mqrc'\equiv\mqrc%}
   }
}

% det
\newcommand{\mpreductdet}[0]{%
   \infer{%
      \mathtt{delay}(\mconstr).\mprc%
      \mareduce%
      \mathtt{delay}(\mtval).\mqrc%
   }{%
      \mtval\models\mconstr\left[\sfrac{\mtval}{x}\right]%
   }
}

% par
\newcommand{\mpreductpar}[0]{%
   \infer{%
      \mprc\mid\mqrc%
      \mareduce%
      \mprc'\mid\mqrc%
   }{%
      \mprc\mareduce\mprc'%
   }
}

% def
\newcommand{\mpreductdef}[0]{%
   \infer{%
      \mpsetrec\mprc%
      \mareduce%
      \mpsetrec\mprc'%
   }{%
      \mprc\mareduce\mprc'%
   }
}

% cont
\newcommand{\mpreductcont}[0]{%
   \infer{%
      \mpsetrec\mqrc%
      \mareduce%
      \mpsetrec\mqrc'%
   }{%
      \mqrc\mareduce\mqrc'%
   }
}

% rec
\newcommand{\mpreductrec}[0]{%
   \mpsetrec%
   \mpcallrec[\msetLabel';\msetChan']\mid\mqrc%
   \mareduce%
   \mpsetrec%
   \mprc\left[\sfrac{\msetLabel';\msetChan'}{\msetLabel;\msetChan}\right]\mid\mqrc%
}

% ift
\newcommand{\mpreductift}[0]{%
   \mifthenelse\mareduce\mprc%
}

% iff
\newcommand{\mpreductiff}[0]{%
   \mifthenelse\mareduce\mqrc%
}


% send
\newcommand{\mpreductsend}[0]{%
   \infer{%
      \mpsendalways%
      \mid%
      \mepointp\mepointq:\mpbuffer%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mprequeue\right\}%
      \mid%
      \left\{\mprecallcache\right\}%
      \right)%
      %
      \mareduce%
      %
      \mprc%
      \mid%
      \mepointp\mepointq:\mpbuffer\cdot a%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mprequeue\right\}%
      \mid%
      \left\{\mprecallcache'\right\}%
      \right)%
   }{%
      \forall \of{a}{k},\of{\mpbuffer}{k}\in%
      \left\{\mprecallcache\right\}:%
      \quad%
      \mprecallcache'=\of{a}{k}:\of{\mpbuffer}{k}\cdot a%
   }
}

% listen
\newcommand{\mpreductlisten}[0]{%
   \infer{%[\rulem{AddListen}]{%
      \mpsendlisten%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mprequeue\right\}%
      \mid%
      \left\{\mprecallcache\right\}%
      \right)%
      %
      \mareduce%
      %
      \mpsendalways[\mqrc]%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mprequeue'\right\}%
      \mid%
      \left\{\mprecallcache,\mprecallcache'\right\}%
      \right)%
   }{%
      \begin{array}{c}
         \forall\elemofset{i}{i}:%
         \quad%
         \mathtt{def}\;\mpvar\left(\msetLabel;\msetChan\right)=\of{\mprc}{i}\,\mathtt{in}\;\mqrc%
         %
         \qquad%
         %
         \mprecallcache'=\of{b}{i}:\emptyset%
         %
         \\%
         \mprequeue'=\mprequeue,\,\of{b}{1}:\of{\mprc}{1},\dots,\of{b}{i}:\of{\mprc}{i}%
         %
         %
      \end{array}
   }
}

% recv 
\newcommand{\mpreductrecv}[0]{%
   \mprecvuntil%
   \mid%
   \mepointp\mepointq:\mmsg\cdot\mpbuffer%
   \mid%
   \left(\nu\mepointp\right)%
   \left(%
   \mpchan\,\mprecv\,\left\{\mprequeue\right\}%
   \mid%
   \left\{\mprecallcache\right\}%
   \right)%
   %
   \mareduce%
   %
   \of{\mprc}{i}\left[\sfrac{\mmsg}{\of{a}{i}}\right]%
   \mid%
   \mepointp\mepointq:\mpbuffer%
   \mid%
   \left(\nu\mepointp\right)%
   \left(%
   \mpchan\,\mprecv\,\left\{\mathtt{tidy}:\mpbuffer\right\}%
   \mid%
   \left\{\emptyset\right\}%
   \right)%
}

% recall
\newcommand{\mpreductrecall}[0]{%
   \infer{%
      \mprc%
      \mid%
      \mepointp\mepointq:\mmsg\cdot\mpbuffer%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{e:\mqrc,\,\mprequeue\right\}%
      \mid%
      \left\{\mprecallcache\right\}%
      \right)%
      %
      \mareduce%
      %
      \mqrc\left[\sfrac{\mmsg}{e}\right]%
      \mid%
      \mepointp\mepointq:\mpbuffer\cdot(\mathtt{tidy}:\mpbuffer')%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mathtt{tidy}:\mpbuffer\right\}%
      \mid%
      \left\{\emptyset\right\}%
      \right)%
   }{%
      \forall \of{a}{k},\of{\mpbuffer}{k}\in%
      \left\{\mprecallcache\right\}:%
      \quad%
      \exists\of{a}{k}=e:\of{\mpbuffer}{k}=\mpbuffer'%
   }
}

% tidy
\newcommand{\mpreducttidy}[0]{%
   \infer{%
      \mpchan\,\mprecv\,(\mathtt{tidy}:\mpbuffer').\mprc%
      \mid%
      \mepointp\mepointq:(\mathtt{tidy}:\mpbuffer')\cdot\mpbuffer%
      \mid%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mprequeue\right\}%
      \mid%
      \left\{\mprecallcache\right\}%
      \right)%
      %
      \mareduce%
      %
      \mprc%
      \mid%
      \mepointp\mepointq:\mpbuffer''%
      \left(\nu\mepointp\right)%
      \left(%
      \mpchan\,\mprecv\,\left\{\mathtt{tidy}:\mpbuffer\right\}%
      \mid%
      \left\{\emptyset\right\}%
      \right)%
   }{%
      \forall a\in\mpbuffer:%
      \quad%
      a\notin\mpbuffer'\implies a\in\mpbuffer''%
   }
}

\newcommand{\prcredrules}[0]{$\mprcredrules$}

\newcommand{\mprctimefuncrecv}[0]{%
   \left\{\begin{array}{l} %
      %
      {\mpchan}^{n-t}\,\mprecv\,\of{\left\{\of{a}{i}:\of{\mprc}{i}\right\}}{\elemofset{i}{i}}\,.\,\mqrc %
      %
      \\[2ex]
      \mqrc %
      %
   \end{array}\right. %
}

\newcommand{\mprctimefuncpar}[0]{\mptimefunc[\of{\mprc}{1}]\mid\mptimefunc[\of{\mprc}{2}]}

\newcommand{\mprctimefuncparcondition}[0]{\text{if}\;\mwaitfunc{\of{\mprc}{i}}\cap\mnequeuefunc{\of{\mprc}{j}}=\emptyset,i\neq j\in\{1,2\}}

\newcommand{\mprctimefunctimer}[0]{\mprctimer[x+\mtval]\mptimefunc[\mprc]}

% time passing definition
\newcommand{\mprctimedef}[0]{%
   \resizebox{\textwidth}{!}{$%
         %
         %
         \begin{array}{rcl c rcl c l}
            %
            %
            \mptimefunc[0] %
             & =                              %
             & 0                              %
            %
             & \mbox{ }                     & %
            \mptimefunc[\mpsetrec\mprc] %
             & =                              %
             & \mpsetrec\mptimefunc[\mprc]    %
            %  
            %
            %
            \\[2ex] %
            \mptimefunc[\mepointp\mepointq:\mpbuffer] %
             & =                              %
             & \mepointp\mepointq:\mpbuffer   %
            %
             & \mbox{ }                     & %
            %
            \mptimefunc[\mdelayfunc[t'].\mprc] %
             & =                              %
             & \mdelayfunc[t'-t].\mprc        %
            %
             & \mbox{ }                     & %
            \text{if\;}t'\geq t                                      %
            %              
            %     
            %
            %
            \\[3ex] %
            \mptimefunc[\mpscope\mprc] %
             & =                              %
             & \mpscope\mptimefunc[\mprc]     %
            %     
             & \mbox{ }                     & %
            %
            \mptimefunc[\mprecvuntil] %
             & =                              %
             & \mprctimefuncrecv              %
            %
             & \mbox{ }                     & %
            \begin{array}{l}n\geq t \\[2ex] \text{otherwise}\end{array}   %
            %
            %
            \\[6ex] %
            \mptimefunc[\mprcfail] %
             & =                              %
             & \mprcfail                      %
            %
             & \mbox{ }                     & %
            %
            \mptimefunc[{\mprecvalways}] %
             & =                              %
             & \mprecvalways                  %
            %
            %
            %
            % par process
            \\[4ex] %
            \mptimefunc[\mprcpar] %
             & =                              %
             & \mprctimefuncpar               %
            % 
             & \mbox{ }                       %
            %
            \mathrlap{\mbox{\hspace{2ex}}\mprctimefuncparcondition}
            %
            %
            %
            % timer progress
            \\[4ex] %
            \mptimefunc[\mprctimer[x]\mprc] %
             & =                              %
             & \mprctimefunctimer             %
         \end{array}
         %
         %
      $}%
}