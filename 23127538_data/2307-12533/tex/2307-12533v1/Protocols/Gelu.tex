\subsection{Protocol for Secure GeLU}\label{sec:gelu}
Most of the current approaches view the $\gelu$ function as a composition of smaller functions and try to optimize each piece of them, making them to miss the
chance of optimizing the private $\gelu$ as a whole. Given the $\gelu$ function:
\begin{equation}\label{eq:gelu}
\begin{split}
    \gelu(x) &= \frac{x}{2} \cdot \left(1 + \tanh \left( \sqrt{\frac{2}{\pi}} \cdot \left(x + 0.044715 \cdot x^3 \right) \right) \right)\\
    &\approx x\cdot \mathsf{sigmoid}(0.071355\cdot x^3 + 1.595769\cdot x) 
\end{split},
\end{equation}
these approaches~\citep{hao2022iron,characmpctranformer} focus either on designing efficient protocols for function $\tanh$
or using the existing MPC protocols of exponentiation and reciprocal for $\mathsf{sigmoid}$. 

However, none of current approaches have utilized the fact that $\gelu$ function is almost linear on the two sides (\ie, $\gelu(x)\approx 0$ for $x<-4$ and $\gelu(x)\approx x$ for $x>3$). 
Within the short interval $[-4,3]$ of $\gelu$,
we suggest a piece-wise approximation of low-degree polynomials is a more efficient and easy-to-implement choice for its secure protocol. Concretely, our piece-wise low-degree polynomials are shown as equation~(\ref{eq:geluapprox}):
\begin{equation}\label{eq:geluapprox}
\gelu(x)=
\begin{cases}
0, & x<-4 \\
F_0(x), & -4 \le x < -1.95 \\
F_1(x), & -1.95 \le x \le 3 \\
x, & x >3
\end{cases},
\end{equation}
where polynomials $F_0()$ and $F_1()$ are computed by library $\mathsf{numpy.ployfit}$\footnote{\url{https://numpy.org/doc/stable/reference/generated/numpy.polyfit.html}} as equation~(\ref{eq:f0f1}). Surprsingly, the above simple poly fit works very well and our $\mathsf{max\ error}< 0.01403$, $\mathsf{median\ error}< 4.41e-05$, and $\mathsf{mean\ error}< 0.00168$.
\begin{equation}\label{eq:f0f1}
\begin{cases}
F_0(x) &= -0.011034134030615728 x^3 -0.11807612951181953 x^2 \\
&- 0.42226581151983866 x -0.5054031199708174\\
F_1(x) &= 0.0018067462606141187x^6 -0.037688200365904236 x^4 \\
&+ 0.3603292692789629x^2 + 0.5x + 0.008526321541038084
\end{cases}
\end{equation}

Formally, given secret input $\share{x}$, our secure $\gelu$ protocol $\Pi_{\gelu}$ is constructed as algorithm~\ref{protocol:gelu}. 
\iffalse
\begin{itemize}
    \item The parties jointly compute
$\share{b_0}^2 = \Pi_{\mathsf{LT}}(\share{x}, 4)$,
$\share{b_1}^2 = \Pi_{\mathsf{LT}}(\share{x}, -1.95)$, and
$\share{b_2}^2 = \Pi_{\mathsf{LT}}(3, \share{x})$.

\item  Then, each $P_i$ locally compute
$\share{b_3}^2 = \share{b_1}^2 \oplus \share{b_2}^ \oplus 1$ and
$\share{b_4}^2 = \share{b_0}^2 \oplus \share{b_1}^2$

\item Finally, the parties compute and return 
$\share{b_2}^2 \cdot \share{x} + \share{b_4}^2 \cdot F_0(\share{x}) + \share{b_3}^2 \cdot F_1(\share{x})$, where polynomials $(F_0, F_1)$ can be computed easily using secure addition and multiplication (and its variants, \eg, secure square)~\citep{spu}. 
\end{itemize}
\fi 

\input{Protocols/geluprotocol}


