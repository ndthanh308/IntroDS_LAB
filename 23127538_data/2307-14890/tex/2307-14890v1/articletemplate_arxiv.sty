\ProvidesPackage{articletemplate}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{bbm}
%\usepackage{luacode}

\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}
%\DeclareSymbolFont{CMletters}{OML}{cmm}{m}{it}
%\DeclareMathSymbol{\xi}{\mathord}{CMletters}{"19}

\newcommand{\cbrt}[1]{\sqrt[3]{#1}}
\newcommand{\ol}{\overline}
\newcommand{\ul}{\underline}
\newcommand{\wt}{\widetilde}
\newcommand{\wh}{\widehat}
\newcommand{\eps}{\varepsilon}
\newcommand{\bs}{\backslash}




\def\conj{\overline}
\def\mf{\mathfrak}
\def\mc{\mathcal}
\renewcommand{\AA}{\mathbb A}
\newcommand{\CC}{\mathbb C}
\newcommand{\DD}{\mathbb D}
\newcommand{\EE}{\mathbb E}
\newcommand{\FF}{\mathbb F}
\newcommand{\HH}{\mathbb H}
\newcommand{\NN}{\mathbb N}
\newcommand{\PP}{\mathbb P}
\newcommand{\QQ}{\mathbb Q}
\newcommand{\RR}{\mathbb R}
\newcommand{\TT}{\mathbb T}
\newcommand{\ZZ}{\mathbb Z}
\newcommand{\charin}{\text{ char }}
\newcommand{\charf}[1]{\mathbbm 1_{#1}}
\newcommand{\mop}{\operatorname}

\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\Syl}{Syl}
\DeclareMathOperator{\Gal}{Gal}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\Nm}{Nm}
\DeclareMathOperator{\rad}{rad}
\DeclareMathOperator{\res}{res}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\PGL}{PGL}
\DeclareMathOperator{\PSL}{PSL}
\DeclareMathOperator{\SO}{SO}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Ann}{Ann}
\DeclareMathOperator{\Irr}{Irr}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator{\sym}{sym}
\DeclareMathOperator{\sgn}{sgn}


\let\delim@autol\left  \let\delim@autor\right \let\delim@autom\middle
\let\delim@basel\relax \let\delim@baser\relax \let\delim@basem\relax
\let\delim@bigl\bigl   \let\delim@bigr\bigr   \let\delim@bigm\big
\let\delim@Bigl\Bigl   \let\delim@Bigr\Bigr   \let\delim@Bigm\Big
\let\delim@biggl\biggl \let\delim@biggr\biggr \let\delim@biggm\bigg
\let\delim@Biggl\Biggl \let\delim@Biggr\Biggr \let\delim@Biggm\Bigg

% default definitions
\newcommand\ldelim{\relax}
\newcommand\rdelim{\relax}
\newcommand\mdelim{\relax}

% the actual command
\newcommand\delim@command[4]{{%   #1 size #2 ldelim #3 rdelim #4 content
  \def\ldelim{\csname delim@#1l\endcsname}%
  \def\rdelim{\csname delim@#1r\endcsname}%
  \def\mdelim{\csname delim@#1m\endcsname}%
  \ldelim#2#4\rdelim#3}}

% a factory to define new delimiter commands
\newcommand{\newdelimcommand}[3]{% #1 name #2 ldelim #3 rdelim
  \expandafter\newcommand\csname delim@#1@st\endcsname[1]{% ##1 content
    \delim@command{base}{#2}{#3}{##1}}%
  \expandafter\newcommand\csname delim@#1@ns\endcsname[2][auto]{%
    % ##1 size ##2 content
    \delim@command{##1}{#2}{#3}{##2}}%
  \expandafter\DeclareRobustCommand\csname#1\endcsname{%
    \@ifstar{\csname delim@#1@st\endcsname}{\csname delim@#1@ns\endcsname}%
  }%
}

\DeclarePairedDelimiter\bra{\langle}{\rvert}
\DeclarePairedDelimiter\ket{\lvert}{\rangle}
\DeclarePairedDelimiterX\braket[2]{\langle}{\rangle}{#1 \delimsize\vert #2}
% syntactically named delimiters
\newdelimcommand{braces}{\lbrace}{\rbrace}
\newdelimcommand{angles}{\langle}{\rangle}
\newdelimcommand{verts}{\lvert}{\rvert}
\newdelimcommand{Verts}{\lVert}{\rVert}
\newdelimcommand{brackets}{[}{]}
\newdelimcommand{ceil}{\lceil}{\rceil}
\newdelimcommand{floor}{\lfloor}{\rfloor}
\newdelimcommand{prn}{(}{)}

% semantically named delimiters
\newcommand{\set}{\braces}
\newcommand{\abs}{\verts}
\newcommand{\size}{\verts}
\newcommand{\norm}{\Verts}
\newcommand{\tuple}{\angles}
\newcommand{\pfrc}[2]{\prn{\frac{#1}{#2}}}
\newcommand{\npfrc}[2]{\prn{-\frac{#1}{#2}}}
\newcommand{\efr}[2]{^{\frac{#1}{#2}}}
\newcommand{\nefr}[2]{^{-\frac{#1}{#2}}}

% Automagic `such that' for set comprehension. Inside an automagic
% delimiter command, the vertical bar will resize appropriately
% Example:
%   \set{ x \in W \st x > 0 }
\newcommand{\st}{\;\mdelim\vert\;}

%\DeclarePairedDelimiterX{\inp}[2]{\langle}{\rangle}{#1, #2}
%\DeclarePairedDelimiterX{\floor}[2]{\lfloor}{\rfloor}{#1, #2}
%\DeclarePairedDelimiterX{\ceil}[2]{\lceil}{\rceil}{#1, #2}



\def\bfa{{\mathbf a}}
\def\bfb{{\mathbf b}}
\def\bfc{{\mathbf c}}
\def\bfd{{\mathbf d}} 
\def\bfe{{\mathbf e}}
\def\bfg{{\mathbf g}}
\def\bfh{{\mathbf h}}
\def\bfj{{\mathbf j}}
\def\bfm{{\mathbf m}}
\def\bfn{{\mathbf n}}
\def\bfp{{\mathbf p}}
\def\bfq{{\mathbf q}}
\def\bfu{{\mathbf u}}
\def\bfv{{\mathbf v}}
\def\bfw{{\mathbf w}}
\def\bfx{{\mathbf x}}
\def\bfy{{\mathbf y}}
\def\bfz{{\mathbf z}}


\def\calA{{\mathcal A}} \def\calAbar{{\overline \calA}} 
\def\calAtil{{\widetilde \calA}}
\def\calB{{\mathcal B}} \def\calBtil{{\widetilde \calB}}
\def\calC{{\mathcal C}} \def\calCbar{{\overline \calC}}
\def\calCtil{{\widetilde \calC}}
\def\calD{{\mathcal D}}
\def\calE{{\mathcal E}}
\def\calF{{\mathcal F}}
\def\cG{{\mathcal G}}
\def\cH{{\mathcal H}}
\def\calI{{\mathcal I}}
\def\calJ{{\mathcal J}}
\def\calL{{\mathcal L}}
\def\calK{{\mathcal K}} \def\Ktil{{\widetilde K}}
\def\calM{{\mathcal M}}
\def\calN{{\mathcal N}}
\def\calO{{\mathcal O}}
\def\calP{{\mathcal P}}
\def\calQ{{\mathcal Q}}
\def\calR{{\mathcal R}} \def\calRbar{{\overline \calR}}
\def\calS{{\mathcal S}}
\def\calT{{\mathcal T}}
\def\calU{{\mathcal U}}
\def\calV{{\mathcal V}}
\def\calX{{\mathcal X}}
\def\calZ{{\mathcal Z}}

\def\setmin{{\setminus\!\,}}

\def\tx{\tilde{x}}\def\ty{\tilde{y}}
\def\tz{\tilde{z}}\def\tw{\tilde{w}}
\def\tbz{\tilde{\z}}\def\tbw{\tilde{\w}}
\def\tS{\tilde{S}}\def\tT{\tilde{T}}
\def\tq{\tilde{q}}\def\tp{\tilde{p}}
\def\tu{\tilde{u}}\def\tv{\tilde{v}}
\def\tM{\tilde{M}}\def\tH{\tilde{H}}
\def\tC{\tilde{C}}\def\tQ{\tilde{Q}}
\def\tg{\tilde{g}}\def\th{\tilde{h}}
\def\dtil{\widetilde{d}}\def\te{\tilde{e}}
\def\tc{\tilde{c}}\def\tb{\tilde{b}}
\def\tF{\tilde{F}}\def\ftil{\widetilde{f}}
\def\Gtil{\widetilde G}
\def\ctA{\tilde{{\cal A}}}\def\ctB{\tilde{{\cal B}}}

\def\gra{{\mathfrak a}}\def\grA{{\mathfrak A}}
\def\grb{{\mathfrak b}}\def\grB{{\mathfrak B}}
\def\grc{{\mathfrak c}}\def\grC{{\mathfrak C}}
\def\grd{{\mathfrak d}}\def\grD{{\mathfrak D}}
\def\grf{{\mathfrak f}}\def\grF{{\mathfrak F}}
\def\grG{{\mathfrak G}}
\def\grJ{{\mathfrak J}}
\def\grl{{\mathfrak l}}\def\grL{{\mathfrak L}}
\def\grm{{\mathfrak m}}\def\grM{{\mathfrak M}}\def\grN{{\mathfrak N}}
\def\grn{{\mathfrak n}}\def\grS{{\mathfrak S}}\def\grP{{\mathfrak P}}
\def\grW{{\mathfrak W}}\def\grB{{\mathfrak B}}\def\grC{{\mathfrak C}}
\def\grK{{\mathfrak K}}\def\grL{{\mathfrak L}}\def\grp{{\mathfrak p}}
\def\grs{{\mathfrak s}}\def\grT{{\mathfrak T}}
\def\grx{{\mathfrak x}} \def\grX{{\mathfrak X}}
\def\gru{{\mathfrak u}}\def\grU{{\mathfrak U}}
\def\grv{{\mathfrak v}}\def\grV{{\mathfrak V}}
\def\grw{{\mathfrak w}}\def\grW{{\mathfrak W}}
\let\Re\relax
\DeclareMathOperator{\Re}{Re}

\let\Im\relax
\DeclareMathOperator{\Im}{Im}


\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

%\newcommand{\abs}[1]{\left\lvert #1 \right\rvert}
\newcommand{\abS}[1]{\bigg| #1 \bigg|}
%\newcommand{\norm}[1]{\left\lVert #1 \right\rVert}
\newcommand{\sumCp}{\mathop{\mathop{\sideset{}{^*}\sum}}}
\newcommand{\sumSf}{\mathop{\mathop{\sideset{}{^\flat}\sum}}}
\newcommand{\sumE}{\mathop{\mathop{\EE}}}
\newcommand{\ssum}[1]{\sum_{\substack{ #1 }}}
\newcommand{\sumd}{\mathop{\mathop{\sum\sum}}}
\DeclareMathOperator*{\sumEE}{\text{\Large $\EE$}}

%\newcommand{\ssum}[1]{\sum_{\substack{ #1 }}}
%\newcommand{\ssumCp}[1]{\sumCp_{\substack{ #1 }}}
%\newcommand{\ssumSf}[1]{\sumSf_{\substack{ #1 }}}

\newcommand{\tensor}{\otimes}
\newcommand{\Set}[1]{\left\{ #1 \right\}}
%\newcommand{\projlim}{\lim_{\leftarrow}}

\newcommand{\id}{\mathrm{id}}
\newcommand{\taking}[1]{\xrightarrow{#1}}
\newcommand{\inv}{^{-1}}
 
\def\le{\leqslant} \def\ge{\geqslant}
\def\leq{\leqslant} \def\geq{\geqslant}


\def\overto{\overrightarrow}
\newcommand\restr[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|} % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}


\newtheorem{theorem}{Theorem}
\newtheorem{thm}[theorem]{Theorem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{prop}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}{Conjecture}
\newtheorem{remark}{Remark}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\numberwithin{theorem}{section}


%\begin{luacode*}
%local mathchar = node.id'math_char'
%local transform
%local function kernel_transform(list)
%  if list and list.id == 25 then
%    list.head = transform(list.head)
%  end
%end
%function transform(list)
%  node.slide(list)
%  for n in node.traverse(list) do
%    local cur = n
%    if n.nucleus and n.nucleus.id == mathchar and n.nucleus.fam == 1 and n.nucleus.char == 61 then
%      local prev, next = node.getboth(n)
%      if prev and next then
%        if next.nucleus and next.nucleus.id == mathchar and next.nucleus.fam == 1 and next.nucleus.char == 61 then
%           prev.next = next
%           n.next = next.next
%        else
%          local new = node.new'fraction'
%          new.num = node.new'sub_mlist'
%          new.denom = node.new'sub_mlist'
%          new.num.head = prev
%          new.denom.head = next
%          new.width = 0x40000000
%          new.attr = node.copy_list(n.attr)
%          local noad = new
%          noad.prev = n.prev.prev
%          noad.next = n.next.next
%          if prev.prev then
%            prev.prev.next = noad
%          else
%            list = noad
%          end
%          if next.next then
%            next.next.prev = noad
%          end
%          prev.next = nil
%          next.next = nil
%          n.next = noad.next
%          cur = new
%        end
%      end
%    end
%    kernel_transform(cur.nucleus)
%    kernel_transform(cur.sub)
%    kernel_transform(cur.sup)
%    kernel_transform(cur.num)
%    kernel_transform(cur.denom)
%    kernel_transform(cur.accent)
%    kernel_transform(cur.bot_accent)
%    kernel_transform(cur.display)
%    kernel_transform(cur.text)
%    kernel_transform(cur.script)
%    kernel_transform(cur.scriptscript)
%    kernel_transform(cur.degree)
%  end
%  return list
%end
%luatexbase.add_to_callback('mlist_to_hlist', function(list, type, pen)
%  list = transform(list)
%  return node.mlist_to_hlist(list, type, pen)
%end,
%'fraction_slash')
%\end{luacode*}
