\section{Dataset}
In this section, we introduce the data source of this dataset in subsection~\ref{sec:datasource}, the collection approach in subsection~\ref{sec:collectApproach}, the collection tool in subsection~\ref{sec:tool}, the format of a GUI pair in subsection~\ref{sec:pairFormat}, the statistics of the dataset in subsection~\ref{sec:statistics}, and how to access the dataset in subsection~\ref{sec:accessDb}.
We also illustrate the advantages of our dataset compared to other current datasets in subsection~\ref{sec:dataCompare}.


\input{tables/dataSource.tex}


\subsection{Data Source}
\label{sec:datasource}
We first crawl 6,456 tablet apps from Google Play.
Then we match their corresponding phone apps by their app names and app developers.
Finally, we collect 5,593 valid phone-tablet app pairs from 22 app categories.
Table~\ref{tab:appSource} shows the top 15 categories of 5,593 app pairs.
% Due to the effect of the data's long tail disctribution, we only display the top 15 categories.
The column \emph{Category} represents the category of these apps.
The column \emph{\#Count} and \emph{Percentage(\%)} denote the number of apps in this category and their percentage of the overall number of apps, respectively.
These 5,593 phone-tablet app pairs are the data source for this dataset.
The three most common categories of apps in the data source are: \emph{Entertainment} (8.87\%), \emph{Social} (7.04\%) and \emph{Communication} (5.83\%).
As shown in Table~\ref{tab:appSource}, the categories of apps in our data source are scattered and balanced.
Most of the categories occupy between 4\% and 6\% of the total dataset.
This balanced distribution ensures the dataset's generalizability and diversity.




\subsection{Data Collection Procedure}
\label{sec:collectApproach}
During the data collection process, we collect data in two stages: performing algorithms to automatically pair phone-tablet GUI pages and manually validating collected pairs.

In this section, we first introduce the current GUI data format in subsection~\ref{sec:GUIformat}.
Second, we illustrate two ways we use to match GUI pairs: by dynamically adjusting the resolution of the device (illustrated in subsection~\ref{sec:resolution} ) and by calculating the similarities (illustrated in subsection~\ref{sec:GUISim}).
We then develop data collecting tools based on these methodologies and use them to automatically collect GUI pairs.
After the automatic collection, three volunteers with at least one year of GUI development experience will manually check and eliminate invalid pairs from the automatically collected pairs.


\subsubsection{GUI Data Format} 
\label{sec:GUIformat}
We install and run phone-tablet app pairs on the Pixel6 and Samsung Galaxy tab S8, respectively.
We use uiautomator2~\cite{uiautomator2} to collect screenshots and GUI metadata of the dynamically running apps.
Figure~\ref{fig:metaExp} shows an example of a collected GUI screenshot and metadata of some UI components inside the GUI.
This example is from the app 'duolingo'~\cite{duolingo}.
The metadata is a documentary object model (DOM) tree of current GUIs, which includes the hierarchy and properties (e.g., class, bounding box, layout) of UI components. 
We can infer the GUI hierarchy from the DOM tree hierarchy in metadata.


% Figure environment removed


\subsubsection{Match GUI Pairs by Dynamically Adjusting the Device Resolution}
\label{sec:resolution}



Android's Responsive/Adaptive layouts provide an optimized user experience regardless of screen size, allowing Android apps to support phones, tablets, foldable, ChromeOS devices, portrait/landscape orientations, and resizable configurations~\cite{adpLay}.
Therefore, some apps define layout files that support different devices and call the corresponding layout file depending on the resolution of the installed device. 

These apps share the same APK files on both mobile and tablet devices.
We first deal with this type of apps.
According to Android's official guidelines for supporting different screen sizes~\cite{supportDifScr}, Android developers can provide alternate layouts for displays with a minimum width measured in density-independent pixels (dp or dip) by using the smallest width screen size qualifiers.
For example, developers can define two layout files for the \emph{MainActivity}: \emph{res/layout/main\_activity.xml} and \emph{res/layout-sw600dp/main\_activity.xml} for smartphones and tablets with 600 density-independent pixels, respectively.
The smallest width qualifier (sw600dp) specifies the smallest of the screen's two sides, regardless of the device's current orientation. 
This layout file allows us to determine that the current app's \emph{MainActivity} is optimal for the tablet's layout.
Two types of the smallest width qualifier: 600dp and 720dp specifically develop for the 7'' and 10'' tablets currently on the market~\cite{supportDifScr}.

% Figure environment removed

Figure~\ref{fig:alg1} shows the pipeline of matching GUI pairs by dynamically adjusting device resolutions.
Based on the above analysis, we first decompile the collected app pairs and then search for the presence of layout files for 600dp tablets and 720dp tablets in the source files (step 1 \& 2 in Figure~\ref{fig:alg1}).
In 5,593 app pairs, 1,214 pairs are found in the layout files of the smallest width qualifiers for the tablet device and share the same app on their phones and tablets.
Therefore, these 1,214 pairs use Responsive/Adaptive layouts to dynamically change GUI layout based on the installed device.

For these app pairs, we use the Windows Manager Command of ADB (\emph{adb shell wm size})~\cite{adb} to dynamically adjust the device's resolution.
We sequentially simulate the tablet and phone resolutions on a tablet device and allow the GUIs collected before and after the simulations to automatically pair up (steps 4 \& 5 in Figure~\ref{fig:alg2}).





\subsubsection{Match GUI Pairs by Comparing UI Similarities}
\label{sec:GUISim}

% Figure environment removed

With the exception of 1,214 apps that share the same file on tablet and phone, the remaining 4,379 phone-tablet pairs all have independent app files.
After dynamically launching the mobile and tablet apps, we match the corresponding GUI page pairs by comparing the similarity of their GUI pages.

Figure~\ref{fig:alg2} shows the pipeline of matching GUI pairs by comparing UI similarities.
Each app has many GUI pages, and a simple comparison of all pages between the mobile app and the tablet app would be time-consuming.
An Android activity provides the window in which the app draws its UI~\cite{activity}.
We first find the corresponding Android activity pairs of app pairs. 
Then we compare each GUI page on the basis of the corresponding Android activity pairs.
To match Android activity pairs, we extract activity names from each GUI and encode them into numerical semantic vectors using a pre-trained BERT~\cite{devlin2019bert} model.
We match the activity-level pairs by comparing their semantically close activity vectors  (Step 3 in Figure~\ref{fig:alg2}).
For example, the GUI in activity \textit{homeActivity} and \textit{mainActivity} are matched by close semantic vectors.
One Android activity may have multiple Android fragments~\cite{fragment} and GUI pages~\cite{machiry2013dynodroid, GUIstate} with different UI components and layouts in current industrial apps.
We compare the attributes of GUI components between phones and tablets to pair phone-tablet GUI pairs at lower granularity (Step 4 in Figure~\ref{fig:alg2}).
In pairing, UI components are identified by their types and properties.
UI components between phones and tablets  with the same types and properties are considered paired GUI components.
For example, two \emph{TextViews} with the same texts, two \emph{ImageViews} with the same images, two \emph{Buttons} with the same texts are considered the paired components.
If more than half of the UI components in two GUIs are paired, they are considered a phone-tablet GUI pair (Step 5 in Figure~\ref{fig:alg2}).

\subsubsection{Manual GUI Pair Verification}
\label{sec:manualPair}
Due to the limitations of ADB, current data collection tools cannot get the metadata of UI type \emph{WebView} and some user-defined third-party UI components.
Meanwhile, when some fragments and UIs of Android are covered, we only need the metadata of the UI at the front end (because the covered UI is not rendered and displayed on the current screen). However, the present data collection tools~\cite{adb, uiautomator2} capture information for both the viewable displayed and the covered UI, resulting in the collection of erroneous data.
Therefore, three volunteers with at least one year of Android development experience perform a second round of manual data validation.
Volunteers check each pair and then apply two criteria to evaluate the data quality: the data's reliability and the rationality of the pairs. 
Volunteers verify the validity of collected pairs and remove pairs with inaccurate metadata.
Volunteers also check the rationality of matched pairs and remove GUI pairs that do not correspond to each other.
In this process, our volunteers also manually match some phone-tablet GUI pairs.

\subsection{Data Collection Tool}
\label{sec:tool}
Based on the above-described two collection strategies, we develop two distinct collecting tools: the adjust resolution collector and the similarity matching collector.

The first tool dynamically adjusts the resolution of the current device using ADB instructions. 
When the running app detects a change in the screen's resolution, it will call the layout file designed for the tablet and change the layout of the current GUI.


The second tool concurrently runs two apps of one app pair on a mobile phone and a tablet.
The tool dynamically evaluates the similarity of the GUIs presented on two devices, and automatically collects the matched GUI page pair when the similarity exceeds a predetermined threshold.

These two data collection tools are also included in the repository of the publicly accessible dataset. 
With the installation instructions provided, more researchers can utilise our tools to collect more customised GUI datasets for future research.


\subsection{Format of A GUI Pair}
\label{sec:pairFormat}
In this section, we introduce the format of each GUI pair.

% Figure environment removed

Figure~\ref{fig:elem} shows an example of pairwise GUI pages of the app 'Spotify' in our dataset.
All GUI pairs in one phone-tablet app pair are placed in the same directory.
Each pair consists of four elements: a screenshot of the GUI running on the phone (\emph{phone\_1676189565\_-MainActivity.png}), the metadata data corresponding to the GUI screenshot on the phone (\emph{ phone\_1676189565\_MainActivity.xml
}), a screenshot of the GUI running on the tablet (\emph{tablet\_1676189565\_-MainActivity.png}
), and the metadata data corresponding to the GUI screenshot on the tablet (\emph{tablet\_1676189565\_MainActivity.xml
}).
The naming format for all files in the dataset is \emph{Device\_Timestamp\_Activity Name}.
As shown in Figure~\ref{fig:elem}, The filename \emph{tablet\_1676189565\_-MainActivity.xml} indicates that this file was obtained by the tablet and was collected with the timestamp \emph{1676189565}, this GUI belongs to \emph{MainActivity} and this file is a metadata file in XML format.
We use timestamps and activity names to distinguish phone-tablet GUI pairs.

\subsection{Statistics of the Database}
\label{sec:statistics}
We collect a total of 10,035 valid phone-tablet GUI pairs.
For a more comprehensive presentation of our dataset, we statistically analyze the collected pairs from two perspectives: the distribution of UI view types within the dataset in subsection~\ref{sec:disUI} and the distribution of GUI similarity between GUI pairs in subsection~\ref{sec:disSim}.

\subsubsection{Distribution of UI View Types}
\label{sec:disUI}
In Android development, a UI view is a basic building block for creating user interfaces. 
Views are responsible for drawing and handling user interactions for a portion of the screen~\cite{AndroidView}. 
For example, a button, a text , an image, and a list are all a type of view.

Figure~\ref{fig:uiDis} illustrates the distribution of UI View types in the dataset.
Considering the data's long-tail distribution, we only display the top 15 types.
We can see that the \emph{TextView} and \emph{ImageView} types, including all their derived categories such as \emph{AppCompatTextView}, \emph{AppCompatCheckedTextView}, and \emph{AppCompatImageView}, are the most common UI view types in the dataset. 
Their numbers (73,349 and 68,496) significantly outnumber all other view types.
The GUI primarily presents information via text and images, so text and image-related views are the most prevalent in the database.
\emph{ImageButton} (10,366) and \emph{Button} (10,235) are the third and fourth most UI views.
Users interact with the GUI mainly through clicks and click operations rely heavily on button views, so button-related views are also common in GUI datasets.


% Figure environment removed


\subsubsection{Distribution of GUI Pair Similarity}
\label{sec:disSim}
The similarity analysis between phone-tablet GUI pairs is important for downstream tasks.
Given a GUI pair, there are a total of $M$ and $N$ GUI views in the GUIs of the phone and tablet, respectively.
Suppose there are $L$ the same views in the GUIs of the phone and the tablet.
The similarity of their GUIs is calculated as
\begin{equation}
    Sim(M, N) = \frac{2 * L}{M+N}
\end{equation}

% In GUI pairs where the kind of UI views and their contents are the same, we presume that the two views are the same regardless of their size and position attributes.

% Figure environment removed


Figure~\ref{fig:simiDis} shows the frequency histogram of GUI similarities of our phone-tablet GUI pairs in the dataset.
The similarity between the GUIs of phone and tablet in most pairs is between 0.5 and 0.7.
Considering the difference in screen size between tablets and phones, the current phone GUI page can only contain part of the UI views in the corresponding tablet GUI page, and the current data reminds us that when performing downstream tasks such as GUI layout generation, search, etc., we should consider filling in the contents that are not available in the mobile phone GUI page.

\subsection{Accessing the Dataset}
\label{sec:accessDb}
The dataset is made accessible to the public in accordance with the criteria outlined in the attached license agreements\footnote{\url{https://github.com/huhanGitHub/papt}}.
The pairs in the dataset are contained in separate folders according to the app.
Most of the app folders are named after the package name of the app's APK, for example, \emph{air.com.myheritage.mobile} , and a few are named after the app's name, for example, \emph{Spotify}.
In each app folder, as described in Section~\ref{sec:pairFormat}, each pair contains four elements: the phone GUI screenshot, the XML file of the phone GUI metadata, the corresponding tablet GUI screenshot, and the XML file of the tablet GUI metadata.
% The current GUI page's activity name and a unique timestamp are used to identify different GUI page pairs.
We also shared the script for loading all GUI pairs in the open source repository.


