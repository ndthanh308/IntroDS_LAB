\vspace{-2mm}
\section{Preliminary and Problem}
\label{sec:preliminary}


%\begin{comment}
% Figure environment removed
%\end{comment}



In this section, we will introduce the table-restructuring operators considered in this work, and  describe our synthesis problem.
\vspace{-2mm}
\subsection{Table-restructuring operators}
We consider 8 table-restructuring operators in our DSL, which are listed in Table~\ref{tab:dsl}. Based on our analysis of tables in the wild (in user spreadsheets and on the web), these operators cover a majority of scenarios required to relationalize tables. Note that since our synthesis framework uses self-supervision for training that is not tied to the specific choices of operators, our approach can be easily extended to include additional operators for new functionalities.
%\kr{can you add more explanation on why these operators were selected? it is easy to extend your method to other operators that have an inverse right? }


In this section, we  will introduce the first 4 operators and their parameters shown in Table~\ref{tab:dsl}. We will leave an exact specification of the remaining operators to our technical report~\cite{full} in the interest of space, since they are all similar in spirit.

% \iftoggle{fullversion}
% {
%     We will give details of the remaining operators in Appendix~\ref{apx:additional-op}, which are all similar in spirit.
% }
% {
%     We will leave an exact specification of the remaining operators to our technical report~\cite{full} in the interest of space, since they are all similar in spirit.
% }




\textbf{Stack.}  \code{Stack} is a Pandas operator~\cite{op-stack} (also known as \code{melt} and \code{unpivot} in other contexts), that collapses contiguous blocks of homogeneous columns into two new columns. Like shown in Figure~\ref{fig:combined-ex}(a), column headers of the homogeneous columns  (``\code{19-Oct}'', ``\code{20-Oct}'', etc.) are converted into values of a new column called ``\code{Date}'', making it substantially easier to query (e.g., to filter using a range-predicate on the ``\code{Date}'' column).

\underline{Parameters.} In order to properly invoke \code{stack}, one needs to provide two important parameters, \code{start\_idx} and \code{end\_idx} (listed in the third column of Table~\ref{tab:dsl}), which specify the starting and ending column index of the homogeneous column-group that needs to be collapsed. In the case of Figure~\ref{fig:combined-ex}(a), we should use \code{start\_idx}=3 (corresponding to column D) and \code{end\_idx}=12 (column M).

Note that because in \at we aim to synthesize complete transformation steps that can execute on input tables, which requires us to predict not only the operators (e.g., \code{stack} for the table in Figure~\ref{fig:combined-ex}(a)), but also the exact parameters values correctly (e.g., slightly different parameters such as \code{start\_idx}=4  and \code{end\_idx}=12 would fail to produce the desired transformation). 

\textbf{Wide-to-long.} \code{Wide-to-long} is an operator in Pandas~\cite{op-wide-to-long}, that collapses repeating column groups into rows (similar functionality can also be found in R~\cite{op-R-wide-to-long}). Figure~\ref{fig:combined-ex}(b) shows such an example, where ``\code{Revenue/Units Sold/Margin}'' from different years form  column-groups that repeat once every 3 columns. All these repeating column-groups can collapse into 3 columns, with an additional ``\code{Year}'' column for year info from the original column headers, as shown on the right in Figure~\ref{fig:combined-ex}(b). Observe that \code{wide-to-long} is similar in spirit to \code{stack} as both collapse homogeneous columns, although \code{stack} cannot produce the desired outcome when columns are repeating in groups, as is the case in this example.
%-- when all columns to collapse repeat once every 1 column, \code{wide-to-long} degenerates into the \code{stack} operator.


\underline{Parameters.} \code{wide-to-long} has 3 parameters, where \code{start\_idx} and \code{end\_idx} are similar to the ones used in \code{stack}. 
It has an additional parameter called ``\code{delim}'', which is the delimitor used to split the original column headers, to produce new column headers and data-values. For example, in the case of Figure~\ref{fig:combined-ex}(b),  ``\code{delim}'' should be specified as ``\code{ - }'' to produce: (1) a first part corresponding to values for the new ``\code{Year}'' column (``\code{2018}'', ``\code{2019}'', etc.); and (2) a second part corresponding to the new column headers in the transformed table (``\code{Revenue}'', ``\code{Units Sold}'', etc.). Like in \code{stack}, all 3 parameters here need to be instantiated correctly, before we can synthesize the desired transformation.


\textbf{Transpose.} \code{Transpose} is a table-restructuring operator that converts rows to columns and columns to rows, which is also used in other contexts such as in matrix computation.  Figure~\ref{fig:combined-ex}(c) shows an example input table on the left, for which \code{transpose} is needed to produce the output table shown on the right, which would become relational and easy to query.

\underline{Parameters.} Invoking \code{transpose} requires no parameters, as all rows and columns will be transposed.

\textbf{Pivot.} Like \code{transpose}, \code{pivot} also converts rows to columns, as the example in Figure~\ref{fig:combined-ex}(d) shows. However, in this case rows show repeating-groups (whereas in \code{wide-to-long} columns show repeating-groups), which need to be transformed into columns, like shown on the right of Figure~\ref{fig:combined-ex}(d). 

\underline{Parameters.} 
\code{Pivot} has one parameter, ``\code{repeat\_frequency}'', which specifies the frequency at which the rows repeat in the input table. In the case of Figure~\ref{fig:combined-ex}(d), this parameter should be set to 4, as the color pattern of rows would suggest.

% removed in revision
%\revised{}
%\begin{comment}
\textbf{Additional operators.}
Table~\ref{tab:dsl} has 4 additional table-restructuring operators, which we will briefly mention here. These include (1): ``\code{\textbf{explode}}''~\cite{op-explode}, which converts columns with composite values (violating the First Normal Form~\cite{codd1990relational}) into atomic values, so that the table can be queried using standard SQL; (2): ``\code{\textbf{ffill}}''~\cite{op-ffill} that fills values in structurally empty cells so that the table can be queried;  (3): ``\code{\textbf{subtitle}}'' that converts  rows representing table sub-titles into separate columns for ease of queries; and finally (4): a ``\code{\textbf{none}}'' operator for input tables that are already relational, for which no transformation is needed, which is needed explicitly so that we do not ``over-trigger'' on tables that require no transformation. 
% \iftoggle{fullversion}
% {
%     We leave details of these operators to Appendix~\ref{apx:additional-op}, as they are similar in nature to the operators we already described.
% }
% {
%     We leave details of these operators to a technical report~\cite{full} in the interest of space, as they are similar in nature to the operators we already described.
% }
% %\end{comment}



\begin{comment}
\stitle{DSL.} We consider the following 8 operators in our experiments. 
\begin{table}[!h]
\scalebox{0.6}{
\begin{tabular}{l|l|l}
\toprule
Operator & Pandas API & \at{} DSL \\
\midrule
Transpose & df.T & dsl\_transpose(df) \\
Stack & pd. melt(df, id\_vars, value\_vars) & dsl\_stack(df, start\_idx, end\_idx) \\
Wide to long & pd.wide\_to\_long(df, stubnames, i) & dsl\_wide\_to\_long(df, start\_idx, end\_idx) \\
Explode & df.explode(column) & dsl\_wide\_to\_long(df, column\_idx) \\
Ffill & df{[}column{]}.ffill() & dsl\_wide\_to\_long(df, end\_idx) \\
Pivot & df.pivot(index, columns, values) & dsl\_pivot(df, row\_frequency) \\
Subtitles & - & dsl\_subtitle(df) \\
None & df\_out = df & dsl\_none(df) \\
\bottomrule
\end{tabular}
}
\end{table}
\end{comment}


\subsection{Problem statement}

Given these table-restructuring operators  listed in Table~\ref{tab:dsl}, we now introduce our synthesis problem as follows.
\vspace{-1mm}
\begin{definition}
\label{def:problem}
%[\at] 
Given an input table $T$, and a set of operators $\mathbf{O} = \{stack, transpose, pivot, \ldots \}$, where each operator $O \in \mathbf{O}$ has a parameter space $P(O)$. Synthesize a sequence of multi-step transformations $M = (O_1(p_1), O_2(p_2), \ldots, O_k(p_k))$, with  $O_i \in \mathbf{O}$ and $p_i \in {P(O_i)}$ for all $i \in [k]$, such that applying each step $O_i(p_i) \in M$  successively on $T$ produces a relationalized version of $T$.
\end{definition}

Note that in our task, we need to predict both the operator $O_i$ and its exact parameters $p_i$ correctly, each step along the way. This is challenging as the search space is large --
even for a single-step transformation, there are thousands of possible operators/parameters to choose from (e.g., a table with 50 columns that requires ``\code{stack}'' will have 50x50 = 2500 possible parameters of start\_idx and end\_idx); for two-step transformations the search space is already in the millions (e.g., for ``\code{stack}'' alone it is $2500^2 \approx 6M$). Given the large search space, even
a small difference in parameters can render the resulting transformation incorrect, as shown below.

%\yeye{mention almost unique here}
%\kr{did you discuss/introduce the no-op option?}
\vspace{-1mm}
\begin{example} 
\label{ex:multi-step}
Given the input table $T$ shown on the left of Figure~\ref{fig:multi-step-ex}, the ground-truth transformation $M$ to relationalize $T$ has two-steps: $M = (\text{transpose()},$ $\text{stack(start\_idx:``2015'',}$ 
 $\text{end\_idx:``2020''}) )$. Here the first step ``\code{transpose}'' swaps the rows with columns, and the second step ``\code{stack}''  collapses the homogeneous columns (between column ``\code{2015}'' and ``\code{2020}''). Note that this is the only correct sequence of steps -- reordering the two steps, or using slightly different parameters (e.g., start\_idx=``2016'' instead of ``2015''), will all lead to incorrect output, which makes the  problem challenging. 
 
 Also note that although we show synthesized programs using our DSL syntax, the resulting programs can be easily translated into different target languages, such as Python Pandas or R, which can then be directly invoked.
 We should also note that two syntactically different programs $M_1$ and $M_2$ may be semantically equivalent, which can be verified under a set of algebraic rules.  \footnote{For example, pivot is equivalent to transpose followed by wide-to-long, and wide-to-long is equivalent to stack-split-pivot. Furthermore, the order of ffill and stack/wide-to-long can be swapped, as long as they operate on disjoint subsets of columns, etc. In our synthesis, we consider synthesized programs that are semantically equivalent to the ground-truth program also correct.}

 %\yeye{see if we need to add actual synthesized code} 
 
 %\yeye{Peng: please remind me why we call this Stack and not Melt again? The API \url{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.stack.html} does not seem to have start-idx, end-idx (unlike Melt). If we need to translate this into Pandas, do we need to first promote the column-headers between start-idx and end-idx, into column-index in Pandas, and then apply Stack? (I was thinking about writing out the translated Python code, but found this to be difficult...)}
\end{example}