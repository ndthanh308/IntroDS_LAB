\subsection{Transaction Layer}

The transaction layer is responsible for payment to servers and intermediaries for delivering their service. 

\subsubsection{Necessity of an integrated transaction layer}

Decentralized platforms generate supply by incentivizing and compensating an extensive network of parties - termed suppliers. The platform can be considered a marketplace for the service supply chain, with service flowing from suppliers (servers) to intermediaries and finally to consumers and compensation flowing the other way. A compensation system is, therefore, a critical part of a decentralized service-oriented platform. 

Compensation for providing services is already an integral part of existing centralized platforms such as Uber, AirBnB, and Amazon; however, the billing systems used for their decentralized counterpart need to be composable with the trustless and programmable service framework that decentralized platforms enable. Decentralized platforms need the billing system to support automated smart contract-initiated dispute resolution and high-speed dispersion of funds, as we will see next. The transaction layer incorporates the web3 equivalent of a billing system. The transaction layer ties the billing of a service with a Service Level Agreement (SLA) that codifies the terms of service and payment, and ensures that metering for the SLA is consistent with the service delivered.

\subsubsection{Scalability solutions}
Decentralized AI platforms cannot rely on the assumption of trust between a server and a client since either party may be too small to be bound by the principles of reputation maintenance or legal agreements. Thus, they need to be constantly in consensus about the amount of inference service delivered and payment for such service. A requirement for achieving this consensus is that it must be achieved per delivery of an inference service unit - a query. All parties involved in service delivery must agree on the service delivered and settle payment for that service delivered at frequent intervals. This requirement necessitates a high throughput, low latency payment system. 

Consensus literature is rich in solutions to scale payment p ranging from sharding, rollups, and sidechains to payment channels. Our payment system should ideally satisfy the following properties:
\begin{itemize}
    \item High throughput of payments 
    \item Low latency between payment initiation and confirmation 
    \item Scale throughput with the number of supply or demand side participants 
    \item Payment per service delivery is not public information and may only be shared between the supplier, consumer, and the chosen intermediaries. 
\end{itemize}

State channels and payment channels satisfy all the above requirements. 
Modeling a decentralized AI platform, we observe that a single client will interact with multiple servers to query for different models and use different suppliers for inter-session privacy. The requirement for managing a state channel across multiple servers is not scalable. Hence we choose a payment channel approach to build the transaction layer’s payment system. We will have a payment channel between a client and an aggregator intermediary and another between the aggregator intermediary and server, enabled by SLA chaining. Figure \ref{fig:transactionLayer} depicts the interaction of transaction layer components with other layers, with details on the architecture below:

% Figure environment removed

\subsubsection{Architecture overview}

The transaction layer encompasses SLAs that any two parties agree on, an SLA manager that converts service measurements to payments using SLA, SLA clients running on machines of both parties fetching data from the measurement gateway, and a blockchain wrapper for posting transactions. These components are described in detail below:

\noindent {\bf Service contracts:} Service contracts consist of two components: A SLA that both the transacting parties agree on and a unidirectional payment channel with funds flowing from the service consumer to the supplier. For the AI platform there exists two consumer - supplier pairs: (i) Client - Aggregator and (ii) Aggregator - Server. The SLA is codified based on a SLA4OpenAPI standard \cite{sla4openAPI} and maps service usage to a payment. SLAs for AI application maps (model type, input size, output size) to token payment amount. The unidirectional payment channel is set up with an escrow from the consuming party to supplying party and set’s terms of delegation of payment keys to an intermediary SLA manager. 
\looseness=-1 

\noindent {\bf SLA manager:} SLA manager
end clients are given to run a codebase that signs micropayments or delegate it to an application running on the cloud: SLA manager. SLA manager receives signed measurements from the consumer and supplier’s SLA client and converts that to an appropriate payment amount by signing a micropayment and sending funds on the payment channel on behalf of the consumer.\\

\noindent {\bf SLA client and measurement gateway:} SLA client and measurement gateway are components that run on the end devices of the consumer and supplier. The measurement gateway interprets the service messages and converts them into service units. For AI applications, these would be the model requested, input size, and output size. The SLA client fetches this information from the measurement gateway, signs it with the key codified in the service contract, and sends it to the SLA manager; optionally, the SLA client (on the consumer end) can convert the measurement to a micropayment themselves and forward it to the supplier. \\
\looseness=-1

\noindent {\bf Blockchain wrapper} This component runs on the SLA manager and SLA client. It is responsible for broadcasting and listening to on-chain transactions such as payment channel start, termination, and dispute messages on-chain. The blockchain wrapper is compatible with multiple blockchains such as Ethereum, Polygon, Solana, and all EVM-compatible rollups. \\

\subsubsection{Dispute-compatibility}

\sakshi utilizes a post-service payment model - Payment disputes can emerge when a supplier claims non-receipt of payment for a service unit (a single AI inference). The associated micropayment can serve as a proof of payment to resolve such disputes. Micropayments in unidirectional payment channels typically consist of a signed commitment of the total payable amount. To render these payment channels to be dispute-compatible, we need to augment them with additional parameters. Firstly, the micropayment should include a unique ‘requestID’ that corresponds to the disputed inference. Secondly, it should contain the hash of the preceding micropayment, which can be validated using a nonce - a counter incremented with each successive micropayment. 
To resolve a payment dispute raised by the server, the payer can commit the associated micropayment. Additionally, the preceding micropayment must also be committed, to calculate the amount payable for the disputed service unit. Depending on who is deemed to be correct, the dispute can be settled on-chain from the existing balance in the payment channel. Our dispute resolution protocol also addresses other scenarios, such as disputes raised by a malicious server without providing service, and inconsistent micropayment commitments. Figure \ref{fig:TLDisputeResolution} depicts an example flow of utilizing payment channel commitments for service dispute resolution.

% Figure environment removed
