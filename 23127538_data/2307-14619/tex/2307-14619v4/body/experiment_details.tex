\section{Experiment Details}
\label{app:exp_details}
% Figure environment removed

\subsection{Compute and Codebase Details}

\paragraph{Code.} For our experiments we build on the existing PyTorch-based codebase and standard environment set provided by \citet{chi2023diffusion} as well as the robomimic demonstration dataset \citet{mandlekar2021matters}.
\footnote{The modified codebase with instructions for running the experiments is available at the following anonymous link: \url{https://www.dropbox.com/s/vzw0gvk1fd3yadw/diffusion_policy.zip?dl=0}. We will provide a public github repository for the final release.}
\paragraph{Compute.} We ran all experiments using 4 Nvidia V100 GPUs on an internal cluster node. For each environment running all experiments depicted in \Cref{fig:noise_sweep} took 12 hours to complete with 20 workers running simultaneously for a total of approximately 10 days worth of compute-hours. Between all 20 workers, peak system RAM consumption totaled about 500 GB.

\subsection{Environment Details}
For simplicity the stabilizatin oracle $\synth$ is built into the environment so that the diffusion policy effectively only performs positional control. See \cref{fig:environments} for visualizations of the environments.

\paragraph{PushT.} The PushT environment introduced in \cite{chi2023diffusion} is a 2D manipulation problem simulated using the PyMunk physics engine. It consists of pushing a T-shaped block from a randomized start position into a target position using a controllable circular agent. The synthesis oracle runs a low-level feedback controller at a 10 times higher to stabilize the agent's position towards a desired target position at each point in time via acceleration control. Similar to \citet{chi2023diffusion}, we use a position-error gain of $k_p = 100$ and velocity-error gain of $k_v = 20$. The observation provided to the DDPM model consists of the x,y oordinates of 9 keypoints on the T block in addition to the x,y coordinates of the manipulation agent, for a total observation dimensionality of 20.

For rollouts on this environment we used trajectories of length $T = 300$. Policies were scored based on the maximum coverage between the goal area and the current block position, with > 95 percent coverage considered an ``successful'' (score = 1) demonstration and the score linearly interpolating between $0$ and $1$ for less coverage. A total of 206 human demonstrations were collected, out of which we use a subset of 90 for training.

\paragraph{Can Pick-and-Place.} This environment is based on the Robomimic \citep{mandlekar2021matters} project, which in turn uses the MuJoCo physics simulator. For the low-level control synthesis we use the feedback controller provided by the Robomimic package. The position-control action space is $7$ dimensional, including the desired end manipulator position, rotation, and gripper position, while the observation space includes the object pose, rotation in addition to position and rotation of all linkages for a total of $23$ dimensions. Demonstrations are given a score of $1$ if they successfully complete the pick-and-place task and a score of $0$ otherwise. We roll out 400 timesteps during evaluation and for training use a subset of up to 90 of the 200 ``proficient human" demonstrations provided.

\paragraph{Square Nut Assembly.} For Square Nut Assembly, which is also Robomimic-based \citep{mandlekar2021matters}, we use the same setup as the Can Pick and Place task in terms of training data, demonstration scoring, and low-level positional controller. The observation, action spaces are also equivalent to the Can Pick-and-Place task with $23$ and $7$ dimensions respectively.

\subsection{DDPM Model and Training Details.}

For our DDPM we use the same 1-D convolutional UNet-style \citep{ronneberger2015u} architecture employed by \citep{chi2023diffusion}, which is in turn adapted from \citet{janner2022planning}. This principally consists of 3 sets of downsampling 1-dimensional convolution operations using Mish activation functions \citep{misra2019mish}, Group Normalization (with 8 groups) \citep{wu2018group}, and skip connections with 64, 128, and 256 channels followed by transposed convolutions and activations in the reversed order. The observation and timestep were provided to the model with Feature-wise Linear Modulation (FiLM)  \citep{perez2018film}, with the timestep encoded using sin-positional encoding into a $64$ dimensional vector. 

During training and evaluation we utilize a squared cosine noise schedule \citep{nichol2021improved} with 100 timesteps. For training we use the AdamW optimizer with linear warmup of 500 steps, followed by an initial learning rate of $1 \times 10^{-4}$ combined with cosine learning rate decay over the rest of the training horizon. For PushT models we train for 800 epochs and evaluate test trajectories every 200 epochs while for Can Pick-and-Place and Square Nut Assembly we evaluate performance every 250 epochs and train for a total of 1500 epochs.

In both environments the diffusion models are conditioned on the previous two observations trained to predict a sequence of $16$ target manipulator positions, starting at the first timestep in the conditional observation sequence. The $2$rd (corresponding to the target position for the current timestep) through $9$th generated actions are emitted as the $\tau_c = 8$ length action sequence and the rest is discarded. Extracting a subsequence of a longer prediction horizon in this manner has been shown to improve performance over just predicting the $H=8$ action sequence directly \citep{chi2023diffusion}.

For $\sigma > 0$ we generate new perturbed observations per training iteration, effectively using $N_{\textrm{aug}} = N_{\textrm{epoch}}$ augmentations. We find this to be easier than generating and storing $N_{\textrm{aug}}$ augmentations with little impact on the training and validation error. Noise is injected after the observations have been normalized such that all components lie within $[-1, 1]$ range. Performing noise injection post normalization ensures that the magnitude of noise injected is not affected by different units or magnitudes.