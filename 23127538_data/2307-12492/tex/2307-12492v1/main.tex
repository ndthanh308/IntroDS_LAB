\documentclass[11pt,a4]{article}

\input{preamble}
\pdfoutput=1
 
\usepackage{graphicx} % Required for inserting images
\title{Exponential speedup of quantum algorithms for the pathfinding problem}
 
\author{ 
Jianqiang Li\thanks{Department of Computer Science and Engineering, Pennsylvania State University, PA, USA {\tt jxl1842@psu.edu}}
}
\date{ }

\begin{document}

\maketitle




\begin{abstract}
Given $s, t$ in an unweighted undirected graph $G$, the goal of the pathfinding problem is to find an $s$-$t$ path. In this work, we first construct a graph $G$ based on welded trees and define a pathfinding problem in the adjacency list oracle $O$. Then we provide an efficient quantum algorithm to find an $s$-$t$ path in the graph $G$. Finally, we prove that no classical algorithm can find an $s$-$t$ path in subexponential time with high probability. The pathfinding problem is one of the fundamental graph-related problems. Our findings suggest that quantum algorithms may potentially offer advantages in more types of graphs to solve the pathfinding problem and open up new possibilities for practical applications of quantum computations in various fields.
\end{abstract}

\section{Introduction}

Quantum algorithms can exploit the superposition and interference properties of quantum mechanics to solve certain problems significantly faster than classical algorithms, achieving super-polynomial speedup. However, the list of such problems is limited. The most well-known problems demonstrating this advantage include Simon's problem, factoring, discrete logarithms, the Pell equation, and other related algebraic problems. Efficient quantum algorithms \cite{simon1997SimonsAlgorithm, shor1994Factoring, hallgren2007polynomial} exist for these problems, while no known classical algorithms can solve them. Additionally, there are graph-related problems, such as the welded tree problem \cite{Childs2002} and the graph property testing problem \cite{benDavid2020SymmetriesGraphPropertiesQSpeedups}, where exponential separations can be achieved relative to the adjacency list oracle.

Identifying problems that can be leveraged by quantum algorithms to achieve superpolynomial speedup over classical algorithms remains one of the major challenges in the field of quantum computation. These challenges arise from two aspects. First, the problem needs to be believed to be classically hard. Second, the problem also needs to be quantumly easy. Several previous attempts to identify such problems have failed due to these constraints. For example, hopes of achieving exponential speedup with quantum algorithms in various machine learning problems, including recommendation systems, principal component analysis, supervised clustering, support vector machines, low-rank regression, and solving semidefinite programs, were later refuted by Tang's breakthrough results \cite{tang2018QuantumInspiredRecommSys} and subsequent work \cite{tang2018QInspiredClassAlgPCA,chia2019SampdSubLinLowRankFramework}. Moreover, although quantum algorithms \cite{chen2018quantum, ding2021LimitationsOfMacaulayMatApproachForHHL} that utilize the HHL algorithm \cite{HHL09} as a subroutine show potential to achieve superpolynomial speed-up in solving certain multivariate polynomial systems, it remains unknown how to find such special polynomial systems to demonstrate this quantum speedup. 

 %Although the HHL-based quantum algorithm for polynomial equations has the potential to demonstrate superpolynomial speedup for specific polynomial systems, finding such systems poses significant difficulty.


The welded tree pathfinding problem in the adjacency list oracle is one of the top open problems in the field of quantum query complexity \cite{aaronson2021open}. A welded tree graph consists of two balanced binary trees of height $n$ with roots $s$ and $t$ and a random cycle that alternates between the leaves of the two binary trees. Given the name of the two roots $s$ and $t$, the goal of the welded tree pathfinding problem is to output the names of vertices of an $s$-$t$ path.  While there is an efficient quantum algorithm to solve the welded tree problem, that is, finding the name of the root $t$ given the name of the root $s$, it has been shown that a natural class of quantum algorithms cannot solve the welded tree pathfinding problem \cite{childs2022quantum}. 

% The difficulty comes from the fact the exponential number of edge-disjoint s-t paths are of the length.


Moreover, the pathfinding problem in isogeny graphs plays an important role in the security of isogeny-based cryptosystems \cite{eisentrager2020computing, Charles2009, Costache2018,wesolowski2022supersingular}. An isogeny graph is constructed with vertices as isomorphism classes of elliptic curves and edges as isogenies (maps) between two elliptic curves. The size of the graph is exponentially large, making it difficult to find a path (map) between two vertices (elliptic curves) of polynomial length.
Depending on the constraints on the isogenies, there will be different types of graphs, such as volcano graphs, Cayley graphs, and supersingular graphs. So far, the best quantum algorithm takes exponential time to solve the pathfinding problem in supersingular isogeny graphs \cite{jaques2019quantum,tani2009claw}. Notably, given a vertex in an isogeny graph, one can efficiently compute its neighbors. This makes isogeny graphs a natural instantiation of the adjacency list oracle of an abstract graph. 




In this paper, we show that the pathfinding problem in some graphs admits an exponential separation between the quantum algorithm and the classical algorithm under the adjacency list oracle. Instead of solving the welded tree pathfinding problem and the isogeny graph pathfinding problem directly, we construct a graph $G$ by associating $n$ distinct welded trees with a path of length $n$ as in Figure \ref{fig:expweldedtree}. Given the name of two vertices $s$,$t$ in $G$, the goal of the pathfinding problem is to output the names of vertices of an $s$-$t$ path. Similarly to the welded tree pathfinding problem, there is an exponential number of $s$-$t$ paths in the graph $G$. On the other hand, the shortest $s$-$t$ path is unique in the graph $G$, while there is an exponential number of shortest paths in the welded tree graph. By using the differences and the distinctness of the welded trees in graph $G$, we show that there is an efficient quantum algorithm that solves this pathfinding problem in polynomial time. This quantum algorithm works by finding the edges of the $s$-$t$ shortest path step-by-step. For each step, the polynomial time continuous quantum walk algorithm \cite{Childs2002} for the welded tree problem is used to select one edge of the shortest $s$-$t$ path. Repeat $n$ steps, the quantum algorithm outputs the shortest $s$-$t$ path.


 
Finally, we show that no classical algorithm can solve the path-finding problem in subexponential time. Observe that any paths between the two vertices $s$ and $t$ have to go through a vertex of degree at least $4$, or pass the vertex $p_{n/2}$ as indicated in Figure \ref{fig:expweldedtree}. To establish the classical lower bound, we show that it is classically hard to output the name of the vertex $p_{n/2}$ or vertices that have a degree of at least $4$. The proof uses the result of the classical lower bound of the welded tree problem, which informally states that, given the name of one root, it is classically hard to traverse through the welded tree to find the other root.


To the best of our knowledge, this is the first example that exhibits the exponential speedup of quantum algorithms for the pathfinding problem. Previous quantum algorithms have achieved at most a polynomial speedup for solving the pathfinding problem in both general and specific graphs. For example, quantum algorithms based on amplitude amplification \cite{durr2006quantum} can solve the pathfinding problem in a general graph using $O(N^{3/2})$ queries to the adjacency matrix oracle, where $N$ is the number of vertices in the graph. By restricting the class of graphs and under the same query model, a quantum algorithm \cite{jeffery2023quantum} based on the span program for generating the optimal $s$-$t$ flow slightly improves the query complexity to solve the pathfinding problem. Furthermore, there exist quantum algorithms \cite{reitzner2017finding,hillery2021finding,koch2018finding} that utilize quantum walks to solve the pathfinding problem in specific graph structures such as a chain of star graphs and a regular tree graph, providing a quadratic speedup compared to classical algorithms.

%\subsection{Future direction}



\paragraph{Organization.} In Section \ref{sec:qaweldedtree}, we introduce the main results of the continuous quantum walk for the welded tree problem, which will be a key subroutine of our quantum pathfinding algorithm. In Section \ref{sec:gralg}, we construct the graph $G$ from the welded trees and use it to define the pathfinding problem. Then we present the quantum algorithm that solves the pathfinding problem. In Section \ref{sec:claslower}, we establish the classical lower bound of the pathfinding problem showing that no classical algorithm can solve this problem with a polynomial number of queries. Finally, we give a discussion and provide some open problems in Section \ref{sec:concu}.

 
 




%\newpage
%Simon's algorithm inspired Shor's algorithm for factoring and discrete logarithmic problem. One of the biggest challenges in the field of quantum computing is identifying and finding problems where quantum algorithms can exhibit exponential advantages over classical algorithms. Shor's There are many attempts on showing the HHL for machine learning-related problems has been dequantized.One of the potential areas for finding such problems is post-quantum cryptography, which is already believed to be classically hard.Limited progress on showing for lattice/code-related problems.Limitations of the HHL algorithm for multivariate polynomial equations.isogeny pathfinding problem.The most well-known quantum techniques that achieve exponential speedups are quantum Fourier transform, quantum convolution, and Hamiltonian simulation. Exponential speedups are rare. ore targets for exponential speedup?Hamiltonian simulation, HHL algorithm, factoring, SimonsPathfinding problem is important. Isogeny graphs used in cryptosystems are volcano graphs, Cayley graphs, and expander graphs.Given one elliptic cure, one can compute its adjacency elliptic cure with isogeny of a small degree, which is a natural instantiation of the adjacency list oracle of graph problem.The best algorithms still take subexponential time.On the other hand, under the adjacency list oracle, there are many quantum speedups for graph-related problems, for exampleAn immediatBy putting a constraint on isogeny\cite{simon1997SimonsAlgorithm} Welded tree exit finding problem exhibits an exponential speedup under the adjacency list oracle.graph property testing problemand Later, based on this result, it was shown that graph property testing problems can also show exponential speedup.  But all those separations do not lead to any practical usage. Unlike the exit finding or graph property testing problem, the pathfinding problem is closely related to isogeny-based cryptosystems.  Although there are an exponential number of paths between the two endpoints of the welded tree, it seems difficult to find one of them using the quantum computer. It seems that The welded tree pathfinding problemDespite many efforts on showing the advantages of quantum algorithms for the pathfinding problem, it is still an open problem whether the quantum algorithm can provide a superpolynomial speedup for the pathfinding problem compared with classical algorithms.
 
%Given one root of the two binary trees, the welded tree problem is to find the other root $t$ under the adjacency list oracle. Arguably, the welded tree problem is the most well-known example of showing the exponential speedup of quantum algorithms relative to the adjacency list oracle. On the other hand, even though there are an exponential number of $s$-$t$ paths, finding an $s$-$t$ path is notoriously difficult. Three types of isogeny graphs, volcano, Cayley graph, and expander graphIn this work, we answer this question affirmatively.Open proble One might be able to instantiate the oracle by using considering isogeny graphs.

\section{Quantum algorithms for the welded tree problem} \label{sec:qaweldedtree}
In this section, we introduce the main results of the continuous quantum walk approach for the welded tree problem, which will be a key subroutine of our quantum algorithm for the pathfinding problem.

It is worth noting that several quantum algorithms have been developed to solve the welded tree problem, encompassing techniques such as continuous quantum walks \cite{Childs2002}, multidimensional quantum walks \cite{jeffery2022multidimensional}, discrete quantum walks \cite{luo2023striving} and the coupled classical oscillator approach \cite{babbush2023exponential}. However, in this paper, we specifically focus on the original continuous quantum walk approach for the welded tree problem.


A welded tree graph $W$ consists of two balanced binary trees of height $n$ with roots $s$ and $t$ and a random cycle that alternates between the leaves of the two binary trees. The number of vertices in $W$ is $2^{n+2}-2$ and the name of the vertices are randomly assigned from the set $\{0,1\}^{2n}$. To access the neighbors of a particular vertex, we use an adjacency list oracle denoted as $O$ for the graph $G$.  Given a $2n$-bit string $u \in \{0,1\}^{2n}$, the adjacency list oracle $O$ provides the neighboring vertices of $u$, or it returns $\perp$ if $u$ is not a valid vertex name in the graph.

\begin{problem}[The welded tree problem] Given an adjacency list oracle $O$ of the welded tree $W$ and the name of the starting vertex $s \in \{0,1\}^{2n}$, the goal is to output the name of the other root $t$.
\end{problem}


Let $A$ be the adjacency matrix of a graph $G$, $\tau$ be a real number and $\ket{\psi_0} =\ket{s}$ as the initial input state, the continuous-time quantum walk is defined as

\[ 
\ket{\psi_\tau} = e^{-iA\tau}\ket{\psi_0}.\]


%Given a graph $G$ Hamiltonian simulation and block encoding: Continuous quantum walk.



\begin{lemma}[Theorem 3 in \cite{Childs2002}] \label{lem:weldedcqw}
Let $A$ be the adjacency matrix of the welded tree graph $W$. With the adjacency list oracle $O$ of the welded tree $W$, the name of the starting vertex $s\in \{0,1\}^{2n}$ and let $\ket{\psi_0}=\ket{s}$, running the continuous quantum walk $\ket{\psi_\tau} = e^{-iA\tau}\ket{\psi_0}$ for a time $\tau$ chosen uniformly in $[0, n^5]$ and then measuring in the computational basis yields a probability of finding the name of the other root vertex $t$ that is greater than $\Omega(\frac{1}{n})$.
\end{lemma}

  By measuring a vertex's degree through querying the adjacency list oracle $O$, one can determine whether it has a degree of $2$ or not. Since only two vertices, $s$ and $t$, have a degree of $2$ in the welded tree $W$, repeating the quantum algorithm multiple times can find the other root $t$ in poly($n$) time. On the other hand, no  classical algorithm can solve the welded tree problem in subexponential time by the following lemma. 
% When the classical algorithm makes $t \leq 2^{n/6}$ queries, the winning probability of finding a vertex with a degree at least $4$ or a cycle is exponentially small by the following lemma.
\begin{lemma}[Theorem 6 in \cite{Childs2002}] \label{lem:weldedlowerbound} 
 For the welded tree problem,  
any classical algorithm that makes at most $2^{n/6}$ queries to the oracle finds the ending vertex or a cycle with probability at most $4\cdot 2^{-n/6}$.
\end{lemma} 

Note that the exact statement of Theorem 6 in \cite{Childs2002} does not mention finding a cycle, but the classical lower bound result holds for this easier case.


\section{The pathfinding problem and the quantum algorithm} \label{sec:gralg}
In this section, we construct a graph $G$ based on welded trees and provide an efficient quantum algorithm that outputs an $s$-$t$ path. 
The key idea is to construct the graph $G$ by associating an $s$-$t$ path $P_n$ of length $n$ with  $n$ distinct welded trees. The quantum algorithm finds the $s$-$t$ path step by step. For each step, we use the quantum algorithm for the welded tree problem \cite{Childs2002} to detect and select the edge $(s,u_i)$ that is in the path $P_n$. Then we remove the selected edge and update the starting vertex $s = u_i$. Repeat until $s=t$ and output all the selected edges as an $s$-$t$ path.
%Note that when constructing the graph $G$, we associate $n$ disjoint and distinct welded trees with a path $P_n$ of length $n$. 


%{\color{red}Adding more edges and a description of the graph $G$}\\

Without loss of generality, assume $n$ is an even positive integer. Given $n$ disjoint welded trees $W^i$ with roots $s_i$ and $t_i$, the graph $G$ is constructed as follows:

\begin{enumerate}
    \item For each $i\in [n]$, adding $i+1$ new isolated edges $e_k=(m^i_k,n^i_k), k \in [i+1]$,   then adding $i+1$ new edges between $t_i$ and vertices $m^i_k$  such that the root vertex $t_i$ has degree $i+3$. 
    
 
    %\item Adding 
    %For each $i\in [n]$, adding a new vertex to be the neighbors of the root vertex $s_i$ of the welded tree.
    %Denote the resulting graph as $W_i$.
    
    \item Given a path graph $P_n$ with $n$ vertices $p_1, \cdots, p_n$, for each $i\in [n]$, add an edge between $p_i$ and $s_{i}$ . 

    \item Adding a random cycle between all vertices $n^i_k$ for each $i\in [n]$ and $k\in [i+1]$.
     Denote the resulting graph as $G$.
\end{enumerate}

% Figure environment removed

%{\color{blue} Describe the graph in more detail. like the degree of the vertices $t_i$}


 
Let $s=p_1$ be the starting vertex, $t=p_n$ be the ending vertex, and given the names of $s$ and $t$, the goal is to find an $s$-$t$ path in the graph $G$.
 \begin{problem}[Pathfinding problem] Given the adjacency list oracle $O$ of the graph $G$ and the name of the starting, ending vertices $s, t\in \{0,1\}^{2n}$, the goal is to output an $s$-$t$ path in $G$.\end{problem}

\begin{algorithm}
\caption{Quantum algorithm for finding an $s$-$t$ path in the graph $G$}
\begin{algorithmic}\label{alg:weldedqwpath}
\REQUIRE Graph $G=(V,E)$, $s, t\in V$ and $i=1$.
\ENSURE  an $s$-$t$ path
\begin{enumerate}
% \item For each $i\in [n]$
 
  \STATE Given the name of the vertex $s \in \{0,1\}^{2n}$, the adjacency list oracle $O$  returns the names of the two neighbors of $s$, that is $u_1, u_2 \in \{0,1\}^{2n}$.  Without loss of generality, pick one of the two neighbors $u_1$ as the initial state $\ket{u_1}$. 
  
 \STATE \label{ite:algroithm} Let $A'$ be the modified adjacency matrix of the adjacency matrix $A$ of $G$ by removing all the edges adjacent to a degree $2$ vertex. Let $O'$ be $O$ except it returns no edge if one endpoint of the edge is a degree $2$ vertex. Run the continuous quantum walk  $e^{-iA'\tau}\ket{u_1}$ for a uniform random time $\tau \in [0, n^5]$.
 Measure the resulting state in the computational basis and get the name of an outcome vertex $v \in \{0,1\}^{2n}$. Compute the degree of the vertex $v$ by querying the adjacency list oracle $O$ of $G$. 
 
 \STATE Repeat Step ~\ref{ite:algroithm} $n^2$ times or until the degree of the measured vertex equals $i+3$. 
  
  \STATE   If the degree of the measured vertex $v$ equals $i+3$, then collect the edge $(s,u_2)$ as an $s$-$t$ path edge and let $s=u_2$.  Otherwise, collect the edge $(s,u_1)$ as an $s$-$t$ path edge and let $s=u_1$. 
  
 \STATE Let i=i+1 and update the graph $G$ by deleting the selected edge.  Repeat all the above steps until $s=t$, then output all the selected edges as an $s$-$t$ path.
   \end{enumerate}
\end{algorithmic}
  \end{algorithm} 
\begin{theorem} With high probability, Algorithm \ref{alg:weldedqwpath} outputs an $s$-$t$ path in poly($n$) time.  
\end{theorem}
\begin{proof}
 For the $i$-th iteration, the key subroutine is to implement the continuous quantum walk $e^{-iA'\tau}$ for $\tau \in [0,n^5]$ in Step 2.  The adjacency list oracle $O'$ can be done by removing all the edges that are adjacent to a degree $2$ vertex. Then use the adjacency list oracle $O'$ to construct a block encoding of the modified adjacency matrix $A'$. With this block encoding, we can perform the Hamiltonian simulation  $e^{-iA'\tau} \ket{u_1}$ in poly($n$) time by implementing polynomials of $A'$ \cite[Theorem 58]{gilyen2018quantum}. 
%The idea is to do block encoding of the modified adjacency matrix $A'$ using the adjacent list oracle $O'$ as follows:
%\[\]

Recall that the only vertex that has degree $i+3$ is the root $t_i$ of the welded tree $W^i$ in the graph $G$. If $u_1$ is the same as the root vertex $s_i$ of the welded tree $W^i$, then by Lemma \ref{lem:weldedcqw}, the success probability of measuring a vertex of degree $i+3$ is $\Omega(1/n)$. The probability of success is $1 - \exp(-\Omega(n))$ by repeating Step 2 $n^2$ times. Otherwise, the probability of measuring a vertex of degree $i+3$ is $0$. This is true because the initial starting vertex $\ket{u_1}$ is disconnected from the welded tree $W^1, \cdots, W^i$ and connected to the welded trees $W^{i+1},\cdots W^{n}$ in the modified graph associated with the adjacency list oracle $O'$. Therefore, for each iteration, Algorithm \ref{alg:weldedqwpath} outputs an edge of the $s$-$t$ path with probability $1 - \exp(-\Omega(n))$ in poly($n$) time.


The length of the $s$-$t$ path outputted by Algorithm \ref{alg:weldedqwpath} is $n$, the same as the total number of iterations. Therefore, with high probability, Algorithm \ref{alg:weldedqwpath} outputs an $s$-$t$ path in poly($n$) time. 
\end{proof}
%it is sufficient to construct an adjacency list oracle $O'$ for a bounded degree graph, which contains the $n$ disjoint welded trees as connected components. 




 

\section{Classical Lower bound}\label{sec:claslower}
In this section, we show that no classical randomized algorithm $\mathcal{R}$ can solve the pathfinding problem in subexponential time. To prove the lower bound, we analyze the difficulty of $\mathcal{R}$ winning a game where it needs to output the vertices of an $s$-$t$ path in the graph $G$.  Note that $\mathcal{R}$ winning the game is equivalent to solving the pathfinding problem. Since every $s$-$t$ path has to go through a vertex of degree at least $4$ or pass through the vertex $p_{n/2}$ as indicated in Figure \ref{fig:expweldedtree}, we can define a new game that is easier to win, where $\mathcal{R}$ needs to output the name of a vertex of degree at least 4 or the name of the vertex $p_{n/2}$, or a cycle. Finally, using the classical lower bound result of the welded tree problem, we show that $\mathcal{R}$ cannot win this new game in subexponential time.  


\noindent The pathfinding problem is equivalent to the following game:
\paragraph{Game A} 
The oracle $O$ contains a random set of names for the vertices of the randomly chosen graph $G$ such that each vertex has a distinct $2n$- bit string as its name and the starting vertex $s$ has the name $0^{2n}$ and the ending vertex $t$ has the name $1^{2n}$. At each step, $\mathcal{R}$ sends a $2n$-bit string to $O$, and the oracle $O$ returns the names of the neighbors of that vertex if the given vertex name is valid. $\mathcal{R}$ wins if it outputs the names of the vertices of an $s$-$t$ path.

The total number of vertices in the graph $G$ is $n2^{n+2}+\frac{n(n+1)}{2}$ and the total number of potential names is $2^{2n}$. If $\mathcal{R}$ makes at most $2^{n/6}$ queries, the probability of querying the name of a vertex that has not been previously returned by the oracle $O$ is at most $2^{n/6} (n2^{n+2}+\frac{n(n+1)}{2})/2^{2n} = O(2^{-n/6})$. Therefore, we can restrict $\mathcal{R}$ to traverse two connected subgraphs starting with vertices $s$ and $t$, respectively.  

%Furthermore, other than $s$ and $t$, these two subgraphs do not contain a vertex of degree $2$ because other vertices of degree $2$  are connected to some vertices $t_i$ in the welded trees as indicated in Figure \ref{fig:expweldedtree}.

To obtain an upper bound on the success probability of Game A, we compare it with a simpler game by relaxing the condition needed for $\mathcal{R}$ to win. Every $s$-$t$ path contains at least one vertex of degree at least $4$ passing through some $t_i$ or the vertex $p_{n/2}$. Thus, the following Game B is easier to win and it suffices to show that $\mathcal{R}$ cannot win this easier game in subexponential time. 

\paragraph{Game B} Let Game B be the same as Game A, except that $\mathcal{R}$ wins if it outputs the name of a vertex of degree at least $4$ or the name of the vertex $p_{n/2}$, or if the vertices visited by $\mathcal{R}$ contain a cycle.

Following \cite{Childs2002}, the additional cycle condition that allows $\mathcal{R}$ to win in Game B allows us to analyze the success probability of $R$ winning. This analysis involves determining whether a random embedding of a random rooted binary tree into the random graph $G$ contains a cycle, a vertex of degree at least $4$, or the vertex $p_{n/2}$. 




%$\mathcal{R}$ cannot find the name of a degree $2$ vertex other than $s$ and $t$. This is true because $\mathcal{R}$ has to find the name of some vertex $t_i$ first, without loss of generality, we can assume that $\mathcal{R}$ 



%Following \cite{Childs2002},the extra cycle condition that allows $\mathcal{R}$ to win allows us to analyze the success probability of $R$ winning Game B using the success probability that a random embedding of a random rooted binary tree into the random graph $G$ contains a cycle, or a vertex of degree at least $4$, or the vertex $p_{n/2}$. 



%This information is crucial in evaluating the probability of $R$ successfully finding a path between the vertices $s$ and $t$ in $G$.




Given the name of the starting vertex $s$, the random embedding of a rooted binary tree $T$ into the graph $G$ is defined as a function $\pi$ from the vertices of $T$ to the vertices of $G$ such that $\pi(\textit{ROOT}) = s$ \cite[Section IV]{Childs2002}. We say that an embedding $\pi$ is proper if $\pi(u)\neq \pi(v)$ for $u\neq v$ and we say that $T$ eixts under $\pi$ if the degree of $\pi(v)$ is at least $4$ or $\pi(v)$ is $p_{n/2}$. The random embedding can be obtained as follows: 

\begin{enumerate}
    \item Let $i$ and $j$ be the two neighbors of $ROOT$ in $T$ and let $u$ and $v$ be the neighbors of $s$ in $G$. With probability $1/2$ set $\pi(i)= u$ and $\pi(j)=v$, and with probability $1/2$ set $\pi(i)= v$ and $\pi(j)=u$. 
    \item For any vertex $i$ in $T$, if $i$ is not a leaf, and $\pi(v)$ is not $p_{n/2}$ or the degree of $\pi(v)$ is $3$. Then let $j$ and $k$ denote the children of vertex $i$, and let $\ell$ denote the parent of vertex $i$. Let $u$ and $v$ be the two neighbors of $\pi (i)$ in $G$ other than $\pi (\ell)$. With probability $1/2$ set $\pi(i)= u$ and $\pi(j)=v$, and with probability $1/2$ set $\pi(i)= v$ and $\pi(j)=u$.
\end{enumerate}

%\begin{enumerate}
    %\item Label the ROOT of $T$ as $0$, and label the other vertices of $T$ with consecutive integers so that if vertex $i$ lies on the path from the root to vertex $j$, then $i\leq j$.
    %\item Set $\pi(0) = s$.
    %\item Let $i$ and $j$ be the neighbors of $ROOT$ in $T$.
   % \item Let $u$ and $v$ be the neighbors of $s$ in $G$.
   % \item With probability $1/2$ set $\pi(i)= u$ and $\pi(j)=v$, and with probability $1/2$ set $\pi(i)= v$ and $\pi(j)=u$.
  %  \item For $i=1,2,3, \cdots,$ if vertex $i$ is not a leaf, and $\pi(i)$ is not $m$ or $s$,
    %   \begin{enumerate}
    %       \item let $j$ and $k$ denote the children of vertex $i$, and let $\ell$ denote the parent of vertex $i$.
    %       \item Let $u$ and $v$ be the neighbors of $\pi (i)$ in $G$ other than $\pi (\ell)$.
    %       \item With probability $1/2$ set $\pi(i)= u$ and $\pi(j)=v$, and with probability $1/2$ set $\pi(i)= v$ and $\pi(j)=u$.
  %     \end{enumerate}
%\end{enumerate}

%same as the proof of the classical lower bound result for the welded tree problem. 


 %similar to , the probability of $\mathcal{R}$ winning Game $B$ can be expressed as the probability that a random embedding of the random rooted binary tree with root $s$ into the random graph $G$ contains a cycle, or a vertex of degree at least $4$, or the vertex $p_{n/2}$. 

%For completeness, we introduce the following definitions of the rooted binary tree, and random embedding follows the definitions provided in \cite[Section IV]{Childs2002}.

%and the randomness of the embedding corresponds to the randomness of the vertex name and the randomness of the rooted binary tree corresponds to the randomness of $\mathcal{R}$. 

% In the work of \cite{Childs2002}, we define a random embedding of a rooted binary tree. 

%We will show that the subgraph seen by the algorithm must be a random embedding of two rooted, disjoint binary trees. 






%The success probability of $\mathcal{R}$ winning Game $X$ is defined as

%\[ \mathcal{P}^G_X(\mathcal{R}) = Pr_{\textit{names}}[\text{ algorithm $\mathcal{R}$ wins game $X$ on graph G}],
%\] where $Pr_{\textit{names}}[\cdot]$ means the probability is taken over the random naming of vertices.








%\begin{lemma}\label{lem:AB} For all classical randomized algorithms $\mathcal{R}$ for Game A, 
%\[\mathcal{P}^G_A(\mathcal{R}) \leq \mathcal{P}^G_B(\mathcal{R}).\]    \end{lemma}

%Note that the total number of vertices in graph $G$ is $n2^{n+2}+n^2+n$ while the total number of potential names is $2^{2n}$. If $\mathcal{R}$ makes at most $2^{n/6}$ queries, the probability of querying the name of a vertex that is not told by the oracle is at most $2^{n/6} (n2^{n+2}+n^2+n)/2^{2n} = O(2^{-n/6})$. Therefore, we can restrict $\mathcal{R}$ to traverse two connected subgraphs starting with vertices $s$ and $t$ respectively.


%Similar to \cite{Childs2002}, the form of the subgraphs of vertices visited by $R$ can be further restricted to two random embeddings of two rooted binary trees. Furthermore, the probability that $\mathcal{R}$ makes $t$ queries wins Game $B$ can be bounded by two times the probability that a random embedding $\pi$ of a random rooted binary tree $T$ with $t$ vertices into the random graph $G$ contains a cycle, the vertex $p_{n/2}$, or a vertex with a degree at least $4$. 





\begin{lemma}\label{lem:clascilowGameC} 
 If $\mathcal{R}$ uses $2^{n/6}$ queries to the oracle $O$, then its probability of winning Game A is at most $2(n+1)\cdot 4\cdot 2^{-n/6}$.  
\end{lemma}
\begin{proof}
 To obtain an upper bound of the winning probability of $\mathcal{R}$ for Game A, it suffices to show that the probability of $\mathcal{R}$ winning Game B is at most $2(n+1)\cdot 4\cdot 2^{-n/6}$.

 

%It is worth noting that $\mathcal{R}$ cannot find the name of a degree $2$ vertex other than $s$ and $t$. This is true because $\mathcal{R}$ has to find the name of some vertex $t_i$ first, which 
%Observe that the path $P_n$ and the $n$ welded trees form a tree structure. Notice that in order to Although $G$ contains degree $2$ vertices $m_k^i$, 

 

Let $T$ be a random rooted binary tree with $2^{n/6}$ vertices and $\pi(T)$ be the image in the graph $G$ under the random embedding $\pi$. Given the name of the starting vertex $s$, similar to \cite{Childs2002}, the probability of $\mathcal{R}$ winning Game $B$ can be expressed as the probability that $\pi(T)$ contains a cycle, or a vertex of degree at least $4$, or the vertex $p_{n/2}$. %Here, the randomness of the rooted binary tree $T$ corresponds to the randomness of $\mathcal{R}$.
 
 %Here the definitions of the rooted binary tree and random embedding follow the definitions provided in \cite[Section IV]{Childs2002} and the randomness of the embedding corresponds to the randomness of the vertex name and the randomness of the rooted binary tree corresponds to the randomness of $\mathcal{R}$. 
% {\color{blue}expalin the graph a little bit}
 %All other vertices  The root vertex $t_i$ has degree $i+3$ for each $i\in [n]$.




 First, $\mathcal{R}$ has to enter a welded tree graph to find a vertex with a degree at least $4$ or find a cycle. This is true because, as indicated in Figure \ref{fig:expweldedtree}, the vertices that have a degree at least $4$ are the roots $t_i$, and the path $P_n$ and the $n$ welded trees form a tree structure. Lemma~\ref{lem:weldedlowerbound} states that, in a welded tree graph, any classical algorithm that makes at most $2^{n/6}$ queries to the oracle and finds the other root or a cycle with probability at most $n \cdot 4\cdot 2^{-n/6}$. There are $n$ welded trees and $n$ vertices of degree at least $4$. Therefore, by the union bound, the probability of $\mathcal{R}$ finding a cycle or a vertex with a degree at least $4$ using $2^{n/6}$ queries to the oracle is at most $n \cdot 4\cdot 2^{-n/6}$. 
 
 Second, the probability of $\mathcal{R}$ finds the name of the vertex $p_{n/2}$ can be expressed as the probability that a random embedding $\pi$ of a random rooted binary tree $T$ with root $s$ into random $G$ contains the vertex $p_{n/2}$. Consider a path in $T$ from the root to a leaf. To reach the vertex $p_{n/2}$, $\pi$ must follow the path $P_n$ $\frac{n}{2}$ times, which has probability $2^{-n/2}$. Since there are at most $2^{n/6}$ tries on each path of $T$ and there are at most $2^{n/6}$ paths. The probability of finding the name of the vertex $p_{n/2}$ is at most $2^{-n/6}$.  Therefore, given the name of the starting vertex $s$, the probability of $\mathcal{R}$ finding the vertex $p_{n/2}$, a cycle, or a vertex of degree at least $4$ is at most $ (n+1) \cdot 4\cdot 2^{-n/6}$ 
 

 

 
The same result also holds if the only given name is the ending vertex $t$. Hence, given the names of $s$ and $t$, the probability of $\mathcal{R}$ uses  $2^{n/6}$ queries to the oracle to find a cycle, the vertex $p_{n/2}$, or a vertex with a degree at least $4$ is at most $2(n+1) \cdot 4\cdot 2^{-n/6}$. Therefore, $\mathcal{R}$ cannot win Game A in subexponential time.

%In other words, the two connected subgraphs visited by $\mathcal{R}$ are disjoint with high probability.

%Thus,  this is true because the two subgraphs of vertices visited by $\mathcal{R}$ are disjoint when both the name of $s$ and $t$ are given. 



\section{Discussion} \label{sec:concu}
In this paper, we show that the pathfinding problem in the graph $G$ admits an exponential separation between quantum and classical algorithms under the adjacency list oracle. The key idea is to encode the path information into $n$ distinct welded trees, in which quantum algorithms can extract the path information efficiently by distinguishing the $n$ distinct welded trees but no classical algorithm can do this in polynomial time. In fact, there are more types of graphs to show an exponential separation of the pathfinding problem as long as they satisfy this property, for example, replacing the random cycle at the top of the graph $G$ with an arbitrary graph. 
%More abstractly, if we can encode the path information into a decision problem such that


Moving forward, we provide several open problems related to the quantum advantages of pathfinding problems in more types of graphs that do not have the properties used in this paper.

\begin{enumerate}
    \item The graph $G$ we constructed in our paper is not regular, which is the structure that our quantum algorithm exploits to run efficiently. However, isogeny graphs, such as the Cayley graph and supersingular graphs, are examples of regular graphs. It would be intriguing to explore whether there exist regular graphs that exhibit exponential separations between quantum and classical algorithms.

   \item In addition to achieving exponential speedups, exploring and characterizing polynomial speedups of quantum algorithms for the pathfinding problem in various types of graphs is also a promising and exciting future direction.
   
   %This will provide a more comprehensive understanding of the potential applications and limitations of quantum algorithms 

%   \item Another open question is investigating the possibility of implementing the adjacency list oracle of the graph $G$ using an isogeny graph. 
 \end{enumerate}
 


%Following the result of \cite{childs2022quantum}, 



%Since the subgraphs generated by $\mathcal{R}$ are disjoint,  without loss of generality, we can assume that $\mathcal{R}$ only queries the vertices that are connected with the starting vertex $s$. 
%Similar to \cite{Childs2002}, $\mathcal{P}^G_B(\mathcal{R})$ can be upper bounded by two times the probability that a random embedding $\pi$ of a random rooted binary tree with $2^{n/6}$ vertices. 




%Similar to \cite{Childs2002}, the winning probability of any classical algorithm of Game $B$ can be expressed as the probability that a random embedding $\pi$ of a random rooted binary tree with $2^{n/6}$ vertices.

%The same result holds if the name of the ending vertex $t$ is given.  Thus, given the name of $s$ and $t$, any classical algorithm that uses $2^{n/6}$ queries to the oracle finds a vertex of degree greater than $4$ is at most $2n\cdot 4\cdot 2^{-n/6}$.      
\end{proof}

\section*{Acknowledgements}
J.L.\ would like to thank Sean Hallgren, Andrew Childs, Yikai Liu, Daochen Wang, and Sebastian Zur for their valuable feedback and conversations and Mingming Chen for assistance in drawing the figure. Part of this work was done while the author visited Quantum Information and Computer Science (QuICS) and the Simons Institute for the Theory of Computing.


\bibliographystyle{alphaurl} 
\bibliography{pathfinding2,Texport,qc_gily}

\end{document}
