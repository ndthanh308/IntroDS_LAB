% !TEX root = marangoz23humanoids.tex
% Figure environment removed
In this section, we present our approach for a decentralized collision-aware inverse kinematics solver based on Ceres\cite{agarwal2022ceres}, an open source C++ non-linear optimization solver. 
%We consider the case that we have multiple robot arms independently working in close proximity. 
Our approach does not use perception to avoid collisions with other arms nor does it consider whole-body control approaches which view multi-arm systems as a single system for pose optimization. 
Instead, we address the problem of finding the inverse kinematics for the controlled arm, while being aware of the robot model and joint configurations of the external arms. 
Our approach consists of the robot parser module (\secref{subsec:robot_parser}) to compute offline static code from the robot description, the state broadcaster module (\secref{subsec:robot_state_br}) that computes the link states, collision distances, and command history, the proximity monitor (\secref{subsec:proximity}) that checks and computes the collisions distances, and the constraint solver module (\secref{subsec:optim}) that uses non-linear optimization to solve the objective function composed of the weighted cost functions formed from the different constraints. 



\subsection{Robot Model Parser}
\label{subsec:robot_parser}
The robot parser module parses the robot description file and generates a header only file in C++ for the different robot variables: position, velocity and acceleration limits, link transformations, and allowed collision matrix. This allows for compile time optimization of the static transform calculation and other parameters. 
It also creates a simplified representation of the links using multiple spheres, as explained in \secref{subsec:proximity}.

\subsection{State Broadcaster}
\label{subsec:robot_state_br}
For the controlled arm as well as the obstacle arms, the states of all the links are calculated using the joint state information and the optimized robot model information generated by the parser module \secref{subsec:robot_parser}. 
Furthermore, the state of the collision objects for each link is computed.
For calculating the velocities, accelerations, and jerks, the command history for the last three iterations is stored.
The robot state, collision object information and command history are calculated and shared with all the objective functions in the solver module. 

\subsection{Proximity Monitor}
\label{subsec:proximity}
For collision-aware inverse kinematics, an efficient method for distance computation between different objects in the environment is essential. 
In general, there are three types of collision objects namely, the controlled arm's own links, the external arms' links, and other environment obstacles. 
In this work, although only the first two types are modeled, it is possible to add environment obstacles by fitting primitive shapes to the perception data.
The links of the controlled robot arm as well as the obstacle arms are modeled as a series of spheres. We use spheres as it is easy to calculate the collision distance. 
Furthermore, in addition to individual sphere surfaces being smooth, the spheres close to each other merge to provide a smooth differentiable surface, in comparison to boxes or capsules which have discontinuities at the boundaries.  
%% Figure environment removed 

However, with an average of three spheres required to represent each link, the number of collision pairs can exponentially increase for multi-arm systems like the HortiBot \figref{fig:cover_fig}, leading to decrease in performance for the collision avoidance cost function. 
Hence, we first modify the allowed collision matrix (ACM), as for example provided by MoveIt\cite{coleman2014reducing}, that filters out collisions among external obstacle arms themselves in addition to adjacent or never colliding links of the controlled arm. 
Thus, collision checks are performed only for pairs that include the controlled arm's links, and any other collision is ignored.

The broad-phase collision manager provided by HPP-FCL\cite{montaut2022differentiable} is used for initial collision checking as it provides an efficient implementation of the GJK algorithm \cite{gilbert1988fast} for maintaining the bounding volume hierarchies. 
Furthermore, we use the axis-aligned bounding box (AABB) dynamic collision manager to filter out the collision objects that are not in close proximity to the controlled arm. 
The collision objects in proximity to the controlled arm are marked as active and the pairs are indicated using red lines in \figref{fig:cover_fig}.
For the active collision objects, the actual distance between the collision pairs using the link transformations derived from the joint states is computed and stored. 
The collision distances are then forwarded to the state broadcaster. 
\subsection{Constraint Solver}
\label{subsec:optim}
The inverse kinematics problem is formulated as a non-linear optimization problem with $p$ different constraints formulated as cost functions contributing to the overall objective function based on their respective weights. 
\begin{eqnarray}
	&\mathbf{q^{\mathit{cmd}}} = &\argmin_{q_i} \sum_{k=1}^{p}{ w_k \cdot f_k(q_i, \dot{q}_i, q_j, t)} \\
	&s.t. \hspace{0.1cm} &{q}^{l}_i < {q}_i < {q}^{u}_i
\end{eqnarray}
where $q_i$ and $\dot{q_i}$ represent the current joint position and velocities of the arm under consideration, $q_j$ represents the joint positions of the other arms, ${q}^{l}$ and ${q}^{u}$ represent lower and upper position limits, and $w_k$ represents the weight for the objective function $f_k$.
For each cost function $f_k$, the residuals $r_k$ are calculated first.
These residuals are then used to compute the loss function $\rho_{k}(s)$ where $s = \|r_k\|^{2}$.
For the individual cost functions, automatic differentiation (AutoDiff) is used to calculate the gradients. The non-linear optimization problem is solved using the trust region method\cite{conn2000trust} with the Levenberg-Marquardt algorithm\cite{levenberg1944method,marquardt1963algorithm}. 
The joint command variables are initialized using the current joint states $q^{\mathit{curr}}_i$. 
In addition, noise is added to the joint command variables to prevent the robotic arm from getting stuck in singularities like outstretched configurations.
The following different constraints are considered in our non-linear optimization framework.
\subsubsection{End-effector Constraint}
As stated earlier, the problem of reaching the desired end-effector pose is formulated as a cost function to the solver. The goal can be either the end-effector position, orientation or both. The capability to specify the type of goal is provided in the command being sent and the weights are adjusted accordingly. 
\begin{equation}
	\label{eq:ee_pose}
	\resizebox{.95\columnwidth}{!}
	{% 
		$f_{\mathit{ee}} = w_{11}\cdot {f}^{\mathit{pos}} _{11}+  w_{12}\cdot {f}^{\mathit{orient}}_{12} \\
		\begin{cases}
		w_{12} = 0  & \text{position goal}  \\
		w_{11} = 0  & \text{orientation goal}   \\
		w_{11} \simeq  w_{12} & \text{pose goal}
		\end{cases}$
	}
\end{equation}
For example, if the task at hand needs only a specified position to be reached without orientation constraints, the current orientation is specified as the desired orientation and the weight $w_{11}$ associated with the position cost function is only specified whereas, $w_{12}$ associated with the orientation cost function is set to zero.

\subsubsection{Collision Avoidance Constraint} 
The proximity monitor described in \secref{subsec:proximity} forwards all the active collision pairs to the solver via the state broadcaster. As the collision objects are modeled as spheres, the residuals for collision avoidance goal function is calculated as follows:
\begin{equation}
\label{eq:collision_residuals}
r^{\mathit{coll}}_{ab} = \frac{\epsilon_{\mathit{coll}}}{\normx{d_{ab} -r_a -r_b}} 
\end{equation} 
where $r_a$ and $r_b$ are the radii of the collision spheres and $d_{ab}$ is the distance between the centers. \figref{fig:collision} shows how the residuals increase inversely to the distance between spheres. 
\subsubsection{Preferred Joint Positions Constraint} 
Each joint $i$ has a preferred configuration $q^{\mathit{pref}}_i$ that can be updated during runtime.
Deviation of the joint states from the preferred joint positions is penalized using a Cauchy loss function.
In practice, for joints with position limits, we use the center joints, i.e., $\frac{q^{l}_i + q^{u}_i}{2}$ as the preferred joint positions.
\begin{equation}
f_{\mathit{pref}} = log(1+ \| r^{\mathit{pref}}_i \|)
\end{equation}
where $r^{\mathit{pref}}_i $ is the residual between the joint variables $q_i$ and the preferred joint positions $q^{\mathit{pref}}_i$.

%\subsubsection{Kinodynamic Limits Constraint} \todo{Check with Salih} 
% Figure environment removed 
\subsubsection{Avoid Joint Position Limits Constraint} 
A shortcoming of many inverse kinematics algorithms, e.g., Orocos KDL's methods \cite{smits_orocoskdl} is the inability to enforce joint position limits at each iteration.
In addition to setting the lower and upper parameter bounds, $q^{l}_i$ and $q^{u}_i$, we penalize the joint commands approaching close to the joint position limits as can been seen in \figref{fig:joint_limits}, by calculating the residuals as follows: 
\begin{eqnarray}
\label{eq:joint_limits}
r^{l}_i = \frac{\epsilon}{q_i - q^{l}_i - \epsilon}, \hspace{0.1cm}
r^{u}_i = \frac{\epsilon}{q_i - q^{u}_i - \epsilon} \\
f_{\mathit{poslim}} = \sum_{1}^{n}(\normx{r^{l}_i} + \normx{r^{u}_i})
\end{eqnarray}
where $\epsilon$ is a small non-zero number. 

\subsection{Kinodynamic Constraints}
The velocity, acceleration, and jerk that will be generated by the target joint position command $\mathbf{q^{\mathit{cmd}}}$  are calculated using backward differences  as shown in \eqref{eq:vel_acc_cmd}:
\begin{eqnarray}
\label{eq:vel_acc_cmd}
	\dot{q_t} = \frac{q_t - q_{\mathit{t-1}}}{\Delta t}, \hspace{0.2cm}
	\ddot{q_t} = \frac{\dot{q}_t - \dot{q}_{\mathit{t-1}}}{\Delta t} \hspace{0.2cm}
	\dddot{q_t} = \frac{\ddot{q}_t - \ddot{q}_{\mathit{t-1}}}{\Delta t}
\end{eqnarray}
The values  are filtered to minimize the noise caused by numeric differentiation. 
With a maximum jerk of 10 $rad/{seconds}^{3}$, we calculate the maximum permissible displacement in joint values and use that as the step size for the trust region.
Furthermore, the joint displacements are limited by calculating the residuals between the current joint states and new joint commands. 
Tukey loss, which aggressively attempts to suppress large errors, is used as the loss function.
%\subsubsection{Kinodynamic Constraints}
%% Figure environment removed 
%We mimimize the velocity, acceleration and jerk that will generated by the target joint position command $\mathbf{q^{\mathit{cmd}}}$. Using backward differences we calculate the residuals for velocity $\dot{q_t}$, acceleration $\ddot{q_t}$ and jerk $\dddot{q_t}$ commands as shown in \eqref{eq:vel_acc_cmd}:
%\begin{eqnarray}
%\label{eq:vel_acc_cmd}
%	\dot{q_t} = \frac{q_t - q_{\mathit{t-1}}}{\Delta t}, \hspace{0.2cm}
%	\ddot{q_t} = \frac{\dot{q_t} - \dot{q_{\mathit{t-1}}}}{\Delta t} \hspace{0.2cm}
%	\dddot{q_t} = \frac{\ddot{q_t} - \ddot{q_{\mathit{t-1}}}}{\Delta t}
%\end{eqnarray}
%We use the tolerant loss function \eqref{eq:tolerant} for each of the cost functions we formulate for the velocity, acceleration and jerk constraints. 
%\begin{equation}
%\label{eq:tolerant}
%	\rho(s) = b \cdot log(1+ e^{(s-a)/b}) - b \cdot log(1+e^{-a/b})
%\end{equation} 
%The tolerant loss function as can been seen from \figref{fig:tolerant_fig} has a loss close to zero when the residuals are minimum and increases exponentially beyond a certain threshold, set using $a$ and $b$ in \eqref{eq:tolerant}. Â´ 