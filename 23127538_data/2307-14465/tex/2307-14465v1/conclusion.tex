\section{Conclusion and Future Work}

\ML~has been applied in many software systems, including critical systems. However, like non-\ML software, \ML~software can also be buggy.
The presence of bugs gives rise to the problem of improving the reliability of software that uses \ML libraries. 
\ML software can suffer degradation of reliability in a statistical sense that may not cause obvious failures, thus detecting improper use of \ML APIs can help improve its reliability.
This motivated us to perform a comprehensive study to understand the types of contracts needed for \ML~APIs.
Our study provides a taxonomy for \ML~API contracts and for violation location of these contracts. In this study, the question posts provided us with the \ML API contract violations and the accepted answer posts contained the contracts. The frequent contract violations by the \ML API users indicates the type of contracts that require immediate support. We have extracted 413 informal \ML API contracts. End-users, including people teaching the application of \ML~libraries, can directly use the informal contracts from our study, as informal API documentation. The \SO~questions indicate a need for such contracts. Additionally, language designers can use these informal contracts as examples. The extracted contracts are labeled with the taxonomy presented in this paper. To help \ML API users, libraries can be released with contracts enforced leveraging this taxonomy.

Our study has presented several key insights.
First, many required contracts for \ML~libraries are not different than traditional contracts. However, \ML API users struggle to maintain these contracts due to lack of domain knowledge, incomplete or ambiguous documentation, etc.
Second, there are distinct ML-specific contracts, e.g., ML type checking.
Additionally, \ML~APIs demonstrate a coupling between behavioral contracts and temporal contracts.
Moreover, the uniqueness of these contracts allow the client to choose either temporal ordering or a state change.
Third, \ML API users struggle with maintaining temporal method orders (especially ``eventually'' constraints) 
for \ML~APIs. 
Fourth, \ML API users often fail to satisfy input-related contracts of \ML~APIs, making input violations the most frequent root cause of contract violations in \ML~APIs.
Fifth, when the \ML~contract violations lead to system failures, the error
messages are often inadequate.
Finally, a high percentage of contract violation occurs at early ML pipeline stages. In essence, the contract violation in an \ML~API that is used in early pipeline stages may delegate the effect in subsequent pipelines. The \ML~APIs from model construction, data preprocessing, etc. can benefit more from supporting contract checking compared to \ML~APIs that are used in later pipeline stages.

From this study, we envision several future directions.  
The classification described in our study could be used to design \ML~contract specification and verification tools. Such tools could help avoid or detect API-related bugs in \ML programs or certify that an \ML~program is correct. 
An understanding of contract violations' root causes and effects described in this paper could enable better debugging mechanisms and help detect contract violations. Comprehending the difficulty of resolving certain \ML~contract violations can help in designing a recommendation system for \ML API users. For instance, a recommendation system to automatically assign difficult contract violation related questions to expert users can be designed. Finally, understanding why \ML API users make contract violations can help the designers of \ML~libraries to develop APIs that are easier to use and less prone to error.