\section{Related Work}
\label{related}

No previous empirical studies have investigated the requirements for \ML~API contracts, but some prior work studied related issues.

{\textbf{Studies of Bugs in \ML~Programs}}.
\cite{10.1145/3213846.3213866}  and \cite{islam19} 
have studied bugs for different DNN
libraries using two sources: \emph{Github} and \SO. They have studied frequent bugs found in DNN libraries, root causes, 
and effects of these bugs. \cite{dfaults} presented a broad taxonomy of faults that occur in \ML~systems. To that end, they have surveyed \ML~developers in addition to studying code from \emph{Github} and \SO. Their taxonomy contains a category \emph{API} that broadly categorizes usage faults of \ML APIs. However, this category is too general to apprehend different types of API contracts. 
A recent work by~\cite{islam20repairing} studied the 
challenges DNN developers face as they debug and subsequently examined the adopted bug fix patterns. \cite{10.1109/ISSRE.2012.22} performed an empirical study on general \ML libraries. 
In addition to this, the study by~\cite{jia2020tfbugs} examines the bugs found in \tf programs. 
However, all of these prior works only
present a classification for bugs; they do not identify the types of contracts that would prevent such bugs.
In contrast, we focus on the contracts that the APIs from these libraries require
and present a classification to identify different types of contracts.
Contracts differ from bug patterns in that contracts do not just 
document incorrectness; they capture conditions needed to ensure 
correct behavior. 
Contracts can also be used to assign blame: if the client violates 
the contract for an API, then the client is to blame for incorrectness/bug 
in the software. 
On the other hand, if the client satisfies its part of an API contract, 
but the API does not satisfy its part, then the API's implementation itself is buggy.

{\textbf{Classification of Contracts}}.
The notion of contracts for APIs is well-established. 
Essentially two kinds of contracts, behavioral and temporal, are most often discussed in the literature
\cite{10.1109/ASE.2009.60, 10.1145/1858996.1859035, nguyen2014mining, khairunnesa2017exploiting, 10.1145/1831708.1831723, 10.1145/1595696.1595767, 10.1145/1287624.1287632}. 
These two classes are behavioral and temporal contracts. 
In our work, we build upon these classes of contracts and 
explored their application to \ML library APIs. 
Building on an existing classification scheme helped us not to reinvent known ideas \cite{10028142446} related to API contracts. We also highlighted the new categories of specifications that are different than the non-ML APIs.

A recent study~\cite{leavens2022further} points out the lessons we have learned in the course of the JML projects. It helps to design specification languages and tools for object-oriented languages such as Java and other languages. However, this work does not provide insight into the classes of contracts that Machine learning APIs require and their similarity and dissimilarity to traditional contracts that our work focuses on.
Another research~\cite{inferICSE} proposes a technique to infer formal contracts from the natural language text of API documents. Such methodology will not suffice for \ML APIs as we illustrate that most \ML software exhibits crashes, and includes bad performance and incorrect functionality not obtained in the API documentation. Hence, we studied \SO posts and characterized the types of \ML contracts. Recently, \cite{inferISTAA} proposed a technique to extract DL-specific input constraints from API documentation and to test APIs guided by such input constraints. However, our study pointed out that there are other kinds of contracts specific to \ML, such as temporal contracts found in model architecture or other inter and intra-argument contracts, which could still be investigated further in the \ML domain.