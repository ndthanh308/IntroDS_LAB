\subsection{Classification of \ML~Contracts and Violation Root Causes}
\label{subsec:con}

To label the contracts for \ML~APIs found in our dataset, we developed a classification 
scheme that categorizes different types of contracts originating from these APIs.

As mentioned earlier, the literature mainly discusses two types of contracts: behavioral and temporal. 

Typically, behavioral contracts for APIs consist of assertions that are required to be true before calling the API (preconditions) and assertions that must be valid upon exiting the API method (postconditions).
In contrast, temporal contracts are those that capture the required 
order of API calls to ensure proper behavior. Both types of contracts are also observed in non-ML APIs, and we build our classification on top of this well-established classification. Building on an existing classification scheme helped us to not reinvent known ideas \cite{10028142446} related to API contracts. Student authors in this work used open coding to build the extension appropriate for \ML~APIs. 

{\bf Process:\ } Researchers advocate using open coding to
create any taxonomy~\cite{926934}; it is best that the researchers perform the
task themselves rather than rely on a third party. The authors worked as a group 
initially to perform the coding and sampled 10\% data to that purpose. 
This strategy had several advantages, e.g., a consistent decision to choose between existing concepts and create a new one; categories became more exact while differences became more evident than individually proposed taxonomy categories, and it also provided an opportunity to properly train the two labelers. We used \emph{axial coding} \cite{Corbin2008BasicsOQ}, a technique that helps to collapse core themes involving qualitative data. In other words, it organizes the codes developed during open coding. This technique is used for cases where conceiving sub-categories seems necessary for any central component inside the classification schema. To elaborate, in our study, as we analyzed and labeled the SO posts with identified contracts, we looked at how these sub-categories could be grouped into central categories, so that the central category could encompass a number of different posts. In some cases, these central categories (axes) are from the state-of-the-art taxonomy, e.g., data type-related contracts, but in other cases, a new abstract category seemed appropriate, e.g., selection. For instance, the codes such as \emph{Primitive Type}, \emph{Built-in Type}, etc., are well-established codes that describe different categories of type-related contracts. We used axial coding to identify that these contracts can be collapsed into the sub-core theme of checking \emph{Data Type}-related contracts. Similarly, we organized sub-core core categories eventually into core categories. For instance, \emph{Data Type} is organized under the core category \emph{Single API Method}.
We further use relational and variational sampling~\cite{GroundedTheoryResearchProceduresCanonsandEvaluativeCriteria} 
using \SO~data to support or contradict the relationship between 
sub-categories and core categories. 
These sampling techniques facilitated explaining relations between theoretically 
relevant categories through gathering data (depending on the frequency of 
similarity or variation) on each group, e.g., considering conditions, 
consequences, etc., on a case-by-case basis. For example, we located instances of the leaf category \emph{\ML type} in our dataset that describes special type-related contracts that is only present in \ML APIs. The multiple samples we collected indicated that the reason behind this contract violation is the \emph{input of an unacceptable input type}, and the effect, if explicitly present in the samples, is \emph{crash}. The frequency of such similarity confirmed the relationship between the category \emph{\ML type} and the category \emph{Data Type}. This is an example of relational sampling, precisely.

{\bf New Categories:\ } We found four new categories during our initial study (marked with $\tikzcircle[fill=olive]{3pt}$ in Table \ref{tab:class1}). 
After the initial study, the labelers individually 
studied the rest of the posts and were at liberty to suggest additional categories if 
the need arose (detail on labeling in \S{\ref{subsec:label}}). 
The labelers conducted an in-person meeting under the supervision of a moderator 
to discuss the suggested additional categories and these reconciliation effort resulted 
in one additional category (marked with %$\Diamond$ 
${\LARGE \tikztriangleright[red,fill=orange!50]}$ in Table \ref{tab:class1}).

{\bf Classification Scheme:\ }
Next, we described our obtained classification schema in detail. 
Furthermore, all categories included in this classification are shown in 
Table \ref*{tab:class1}. 
At the top level, 
we presented three central contract component levels: contracts involving \emph{Single API Method}, 
contracts involving \emph{API Method Order}, and contracts that 
required a \emph{Hybrid} of preceding categories. The first fundamental category, \emph{Single API Method (SAM)}, in our classification scheme captures preconditions/postconditions involving a single API method. This core category is based on behavioral contracts. Next, \ML~APIs often require particular call orderings to demonstrate normal behavior;  we classify contracts specifying such order as {\bfseries API Method Order (AMO)}. This category is based on temporal contracts.
Subsequently, we classified these categories into sub-classes until we could find a leaf category that denoted the contract of a particular type for \ML~APIs. For each such class, we explained the root cause of that contract violation subsequently.

\begin{table}[]
    \centering
	\captionof{table}{Type of Contracts for \ML APIs (Symbols ${\tikzcircle[fill=olive]{3pt}}$ and ${\LARGE \tikztriangleright[red,fill=orange!50]}$ at the end of leaf components designate novel categories)}
	\label{tab:class1}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|c|cl|}
\hline
\rowcolor[HTML]{EFEFEF} 
\multicolumn{1}{|l|}{\cellcolor[HTML]{EFEFEF}Level 1} & \multicolumn{1}{l|}{\cellcolor[HTML]{EFEFEF}Level 2} & Level 3 \\ \hline
\rowcolor[HTML]{32CB00} 
\cellcolor[HTML]{32CB00} & \multicolumn{1}{c|}{\cellcolor[HTML]{32CB00}} & Primitive Type (PT) \\ \cline{3-3} 
\rowcolor[HTML]{32CB00} 
\cellcolor[HTML]{32CB00} & \multicolumn{1}{c|}{\cellcolor[HTML]{32CB00}} & Built-in Type (BIT) \\ \cline{3-3} 
\rowcolor[HTML]{32CB00} 
\cellcolor[HTML]{32CB00} & \multicolumn{1}{c|}{\cellcolor[HTML]{32CB00}} & Reference Type (RT) \\ \cline{3-3} 
\rowcolor[HTML]{32CB00} 
\cellcolor[HTML]{32CB00} & \multicolumn{1}{l|}{\multirow{-4}{*}{\cellcolor[HTML]{32CB00}Data Type (DT)}} & ML Type (MT) ${\tikzcircle[fill=olive]{3pt}}$ \\ \cline{2-3} 
\rowcolor[HTML]{32CB00} 
\multirow{-5}{*}{\cellcolor[HTML]{32CB00}Single API Method (SAM)} & \multicolumn{1}{c|}{\cellcolor[HTML]{32CB00}} & Intra-argument Contract (IC-1) \\ \cline{3-3} 
\rowcolor[HTML]{32CB00} 
\multicolumn{1}{|l|}{\cellcolor[HTML]{32CB00}} & \multicolumn{1}{l|}{\multirow{-2}{*}{\cellcolor[HTML]{32CB00}Boolean Expression Type (BET)}} & Inter-argument Contract (IC-2) \\ \hline
\rowcolor[HTML]{68CBD0} 
\cellcolor[HTML]{68CBD0} & \multicolumn{2}{l|}{\cellcolor[HTML]{68CBD0}Always (G)} \\ \cline{2-3} 
\rowcolor[HTML]{68CBD0} 
\multirow{-2}{*}{\cellcolor[HTML]{68CBD0}API Method Order (AMO)} & \multicolumn{2}{l|}{\cellcolor[HTML]{68CBD0}Eventually (F)} \\ \hline
\rowcolor[HTML]{FFC702} 
\multicolumn{1}{|l|}{\cellcolor[HTML]{FFC702}} & \multicolumn{1}{l|}{\cellcolor[HTML]{FFC702}SAM-AMO Interdependency (SAI)} & SAM (Level 3) $\land$ AMO(Level 2) ${\tikzcircle[fill=olive]{3pt}}$ \\ \cline{2-3} 
\rowcolor[HTML]{FFC702} 
\multicolumn{1}{|l|}{\cellcolor[HTML]{FFC702}} & \multicolumn{1}{c|}{\cellcolor[HTML]{FFC702}} & SAM (Level 3) ${\LARGE \tikztriangleright[red,fill=orange!50]}$ \\ \cline{3-3} 
\rowcolor[HTML]{FFC702} 
\multicolumn{1}{|l|}{\cellcolor[HTML]{FFC702}} & \multicolumn{1}{c|}{\cellcolor[HTML]{FFC702}} & AMO (Level 2) ${\tikzcircle[fill=olive]{3pt}}$ \\ \cline{3-3} 
\rowcolor[HTML]{FFC702} 
\multicolumn{1}{|l|}{\multirow{-4}{*}{\cellcolor[HTML]{FFC702}Hybrid (H)}} & \multicolumn{1}{l|}{\multirow{-3}{*}{\cellcolor[HTML]{FFC702}Selection (SL)}} & Comb. of SAM(Level 3) and AMO(Level 2) $\tikzcircle[fill=olive]{3pt}$ \\ \cline{3-3} 
\end{tabular}%
}
	\footnotesize * %\textbf{\textcolor{green}{Green}}
		\colorbox{lightgreen}{Green} cells indicates the behavioral contract. \colorbox{lightblue}{Blue} denotes temporal contract and \colorbox{lightorange}{Orange} cells indicate the hybrid respectively.
\end{table}


\subsubsection{Type of Contracts involving Single API Method (SAM)}

The first sub-category of Single API Method (SAM) contract concerns type checking 
that is required {\bfseries Data Type (DT)} of API arguments.

This subclass consists of four types of contract: 
\begin{description}[leftmargin=*]
	\item[\bfseries Primitive Type (PT):] This represents the \ML~API argument type 

can be a primitive type, e.g., \texttt{float},  \texttt{int},  \texttt{bool},  \texttt{number},  \texttt{None}, and the rest. For instance, in \SO post \ref{fig:postPT}, the \texttt{decode()} method from the \tf library expects a \texttt{byte string}. The root cause of this contract violation is an input of an unacceptable type.  

\hspace*{0.2cm}
{
	\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
hello = tf.constant('Hello, TensorFlow!')
sess = tf.Session()
print(sess.run(hello))
\end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
		Use sess.run(hello).decode() because it is a bytestring, decode method will return the string.
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/40904979/the-print-of-string-constant-is-always-attached-with-b-intensorflow}{Example post with contract} \label{fig:postPT}}}
\hspace*{0.2cm}
{
\begin{lrbox}{\mybox}%
 \begin{lstlisting}[language=iPython]
conv2 = conv2d(conv1, wts['conv2'])
conv2 = maxpool2d(conv2)
conv2 = tf.reshape(conv2, shape=[-1,158*117*64])
frame = tf.placeholder('float', [None, 640-10, 465, 3])
controls_at_each_frame = tf.placeholder('float', [None, 4]) 
conv2 = tf.concat(conv2, controls_at_each_frame, axis=1)
\end{lstlisting}
\end{lrbox}%
\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
%	\begin{lstlisting}[language=iPython]
    \texttt{conv2 = tf.concat((conv2, controls\_at\_each\_frame), axis=1)} ;
   % \end{lstlisting}
Note we need two frames that are required to concatenate within parentheses, as specified
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/45175469/typeerror-concat-got-multiple-values-for-argument-axis}{Example post with contract} \label{fig:postBIT}}}

\item[\bfseries Built-in Type (BIT):] The contracts involving more complex 
built-in types (such as \texttt{dict}, \texttt{list}, \texttt{tuple}, and \texttt{array}). For example, in \SO post \ref{fig:postBIT}, \texttt{concat()} from the \tf library expects the first argument to be of \texttt{array} type. The root cause of this contract violation is an input of unacceptable type.
\end{description}

\begin{description}[leftmargin=*]
	\item[\bfseries Reference Type (RT):] This category of   contracts can involve either internal class object, i.e., referenced class objects within the API class, or external class object, i.e., external variable referenced from separate modules of the ML library. For example, in \SO post \ref{fig:post3}, a contract for the API \texttt{KerasRegressor()} from \keras is shown. The argument accepts a function, an instance of a class that implements the call method or \texttt{None}. As the argument \texttt{build\_fn} of this API accepts reference type as one of its expected argument types, we classify this under the reference type category. 
 The root cause of this contract violation is that an input of unacceptable  type is supplied to the method. 
\end{description}

{
	\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
model = nn_model()
model = KerasRegressor(build_fn=model, nb_epoch=2) \end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
		Herein lies the issue. Rather than passing your \texttt{nn\_model} function as the \texttt{build\_fn}, you pass an actual instance of the \texttt{Keras} Sequential model. One of the following three values could be passed to \texttt{build\_fn}: \newline
		\textbullet~A function \newline
		\textbullet~An instance of a class that implements the call method. \newline
		\textbullet~None
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/39467496/error-when-using-keras-sk-learn-api}{Example post with contract} \label{fig:post3}}}
\hspace*{0.2cm}

\begin{description}[leftmargin=*]
	\item[\bfseries ML Type (MT):] This final contract component of data type 
contains \ML types. ML types are a multidimensional array with a uniform type (\texttt{float16}, \texttt{float32}, \texttt{complex16}, etc.), particularly designed for ML pipelines to achieve accelerated performance (i.e., ease of use with GPU).

For instance, in \SO post~\ref{fig:post2}, an \emph{ML Type} 
related contract is captured stating that the \texttt{matmul()} API from the \tf library 
requires that both of the arguments should be a \texttt{Tensor} with one of the following types: 
\texttt{float16}, \texttt{float32}, \texttt{float64}, \texttt{int32}, \texttt{complex64}, \texttt{complex128}. \\

\hspace*{0.2cm}
{
	\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
layer_1 = tf.nn.relu(tf.add(tf.matmul(_X, _weights['h1']), _biases['b1'])) 
layer_2 = tf.nn.relu(tf.add(tf.matmul(layer_1, _weights['h2']), _biases['b2'])) 
return tf.matmul(layer_2, weights['out']) + biases['out'] 
\end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
	The \texttt{tf.matmul()} op does not perform automatic type conversions, so both of its inputs must have the same element type. The error message you are seeing indicates that you have a call to \texttt{tf.matmul()} where the first argument has type \texttt{tf.float32}, and the second argument has type \texttt{tf.float64}. You must convert one of the inputs to match the other, for example using \texttt{tf.cast(x, tf.float32)}.
\end{mytbox2} 
\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/36210887/how-to-fix-matmul-op-has-type-float64-that-does-not-match-type-float32-typeerror}{Example post with contract} \label{fig:post2}}
}
Another example of this type of contract \ref{fig:postMT} 
is that the first two arguments for the  \texttt{fit()} API should have the type of a \texttt{numpy} \texttt{array} or a \texttt{list} of  \texttt{numpy}  \texttt{arrays}. The root cause of this contract violation is an input of unacceptable type supplied to the method. 
This post also shows that the API has a supplementary contract concerning argument dependency, as discussed below. \\

\hspace*{0.2cm}
{
	\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
padded_model.fit(train_X, train_y, epochs=50, verbose=1)
\end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
If \texttt{train\_x} and \texttt{train\_y} are normal \textit{Python} lists, they don't have the attribute .ndim. Only Numpy arrays have this attribute representing the number of dimensions.
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/48699954/keras-attributeerror-int-object-has-no-attribute-ndim-when-using-model-fi}{Example post with contract} \label{fig:postMT}}}


\end{description}

The API method can also involve Boolean assertions related to its argument values,
{\bfseries Boolean Expression Type (BET)}, instead of only type related checks.
We classify these types of contracts into two subclasses: 

\begin{description}[leftmargin=*]
\item 
[\bfseries Intra-argument contracts (IC-1):] IC-1 specifies preconditions related to a single argument of the API. These contracts may involve both comparisons and logical combinations. 

{\quad\begin{lrbox}{\mybox}%
\begin{lstlisting}[language=iPython, numbers=none]
a_shuf = tf.random_shuffle(a)
\end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
That only sets the graph-level random seed. If you execute this snippet several times in a row, the graph will change, and two shuffle statements will get different operation-level seeds.
		To get deterministic \texttt{a\_shuf} you can either \newline
		\textbullet~Call \texttt{tf.reset\_default\_graph()} between invocations or \newline
		\textbullet~Set operation-level seed for shuffle: \texttt{a\_shuf = tf.random\_shuffle(a, seed=42)}
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/36096386/tensorflow-set-random-seed-not-working}{Example post with contract} \label{fig:post1}}}
\hspace*{0.2cm}

An example of an IC-1 contract is given in \SO post~\ref{fig:post1}, which shows an \ML API users trying
to use the \tf~API \texttt{random\_shuffle()} to shuffle a Tensor, \texttt{a}, 
with some set seed value. 
One of the solutions mentioned in the accepted answer says that to do that, one should specify the argument \texttt{seed} with the desired value, e.g., the argument \texttt{seed} gets the value \texttt{42}. 
The root cause of this contract violation is that acceptable input value is not supplied to (the \texttt{random\_shuffle()}) method. 
\end{description}

\begin{description}[leftmargin=*]
\item [\bfseries Inter-argument contracts (IC-2):] 
IC-2 contracts involve more than one argument to an API method, possibly using comparisons or logical expressions.
For example, in \SO post~\ref{fig:post2}, the \texttt{matmul()} API from  \tf requires that
the type of the second argument should match the type of the first argument. A comparison expression can express this contract, so it belongs to IC-2. 
The root cause of this contract violation is that the (\texttt{matmul()}) API is missing input value/type dependency between arguments. Another example \ref{fig:postIC2}

for this category is \texttt{nn.softmax\_cross\_entropy\_with\_logits()}, an API from \tf, which requires that the logits and labels arguments must have the same shape (i.e., [batch\_size, num\_classes]). \\

\hspace*{0.2cm}
{
	\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
tf.nn.softmax_cross_entropy_with_logits(
    logits=b, labels=a).eval(feed_dict={b:np.array([[0.45]]), a:np.array([[0.2]])})
\end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
Like they say, you can't spell \texttt{"softmax\_cross\_entropy\_with\_logits"} without \texttt{"softmax"}. \texttt{Softmax} of [0.45] is [1], and log(1) is 0. \texttt{logits} and \texttt{labels} must have the same shape \texttt{[batch\_size, num\_classes]} and the same dtype (either \texttt{float16, float32, or float64}).
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/42521400/calculating-cross-entropy-in-tensorflow}{Example post with contract} \label{fig:postIC2}}}

\end{description}

\subsubsection{Type of Contracts involving API Method Order (AMO)}

Multiple APIs can be involved in an AMO contract. There are two sub-categories as follows:

\begin{description}[leftmargin=*]
	\item [\bfseries Always (G):] Always contracts are AMO contracts that hold at each point of history. %must hold in all program states. 
	For example, as shown in \SO post~\ref{fig:post5}, for \tf, the call to the method, \texttt{tf.wholeFileReader()} must be followed by another method call, \texttt{tf.train.start\_queue\_runners()} to avoid hanging. 
The root cause of this contract violation is that the \emph{always} required order between these calls is not followed. \\
\end{description}

{\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
def read_image(filename_queue):
reader = tf.WholeFileReader()
key,value = reader.read(filename_queue) \end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
		If you're not using feeding—i.e. using the \texttt{tf.WholeFileReader} as shown in your program—you will need to call \texttt{tf.train.start\_queue\_runners()} to get started. Otherwise your program will hang, waiting for input.
	\end{mytbox2}
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/35673874/tensorflow-error-shape-tensorshape-must-have-rank-1}{Example post with contract} \label{fig:post5}}
	\hspace*{0.2cm}}

{\begin{lrbox}{\mybox}%
		\begin{lstlisting}[language=iPython]
model = Sequential()
model.add(LSTM(100, input_dim = num_features))
model.add(Dense(1, activation='sigmoid')) \end{lstlisting}
	\end{lrbox}%
	\scalebox{0.92}{\usebox{\mybox}}
	
	\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
The solution to this: you need to enable the \texttt{LSTM} layer to return a sequence instead of only the last element. Since the \texttt{Dense} layer is not able to handle sequential data you need to apply it to each sequence element individually which is done by wrapping it in a \texttt{TimeDistributed} wrapper.
	\end{mytbox2} 
	\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/41863921/how-can-i-use-categorical-one-hot-labels-for-training-with-keras}{Example post with contract} \label{fig:post6}}}
	
\begin{description}[leftmargin=*]
	\item [\bfseries Eventually (F):] Eventually contracts are AMO contracts where the ordering is 
	only required at some point in history. In other words, this specifies that a required API ordering must be true at some point in this program's execution history far enough in the future. 
For instance, in \SO~post~\ref{fig:post6}, the author is trying to solve a sequential classification (input data where order matters) task. In the model, they used the \texttt{LSTM()} API to return a sequence and then output it as a \texttt{Dense()} object. The activation function has a one-to-one correspondence with the type of classification being performed. For that reason, the \texttt{sigmoid} function is rightly used. However, in the model, they used the \texttt{LSTM()} API to return a sequence and then output it as a \texttt{Dense()} object. This method order of APIs demonstrates an incorrect API method order, as the order in the question post is missing a \texttt{TimeDistributed()} API call.

Note that the code is correct for a many-to-one task in natural language processing (NLP). However, in this question, the user asks for a many-to-many solution, in which case it becomes mandatory to apply \texttt{TimeDistributed()}.
Therefore, using the \texttt{TimeDistributed()} API only becomes a requirement after the \texttt{LSTM()} API is used to return a sequence. The root cause of this contract violation is that in a state where a call to a method (\texttt{LSTM()}) returns (a sequence), another call to a method (\texttt{TimeDistributed()}) should have occurred. Thus, in this \SO~post~\ref{fig:post6}, this \emph{eventually} contract is violated because the author did not know that the \texttt{TimeDistributed()} API is a requirement to be called eventually after the \texttt{LSTM()} API is used to \emph{return a sequence}. \\

\end{description}

\subsubsection{Type of Contracts involving Hybrid (H) of SAM and AMO}
The {\bfseries  Hybrid (H)} category involves a blend of behavioral and temporal contracts. This category has two subclasses: \newline 
	 
\begin{lrbox}{\mybox}%
\begin{lstlisting}[language=iPython,numbers=none]
clf = GridSearchCV(SVC(C=1), tuned_parameters, score_func=auc_score)\end{lstlisting}
\end{lrbox}%
\scalebox{0.92}{\usebox{\mybox}}

\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
	As noted already, for \texttt{SVM}-based Classifiers (as \texttt{y == np.int*}) \textbf{preprocessin}g is a must, otherwise the ML-Estimator's prediction capability is lost right by skewed features' influence onto a decission [\emph{sic}] function.
\end{mytbox2}
\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/17455302/gridsearchcv-extremely-slow-on-small-dataset-in-scikit-learn}{Example post with contract} \label{fig:post4}}
\hspace*{0.3cm}

\begin{description}[leftmargin=*]
\item [\bfseries SAM-AMO Inter-dependency (SAI):] SAI contracts have a dependency between behavior and method orders. This dependency could be in either direction, i.e., the program's state could determine the order of API calls, or the order of API calls could require that some condition must hold. For example, in \SO post~\ref{fig:post4}, if an \ML API users uses the SVM-based classifier \texttt{SVC} as the \emph{estimator} parameter for \texttt{GridSearchCV()} with \scikit, then \texttt{preprocessing.scale()} must precede this call. Since the order of the method calls \texttt{GridSearchCV()} and \texttt{preprocessing.scale()} APIs is dependent upon the value given to the parameter of \texttt{GridSearchCV()}, it belongs to the \emph{SAI} contract category.
The root cause of this contract violation is that the value being passed to one method call (\texttt{GridSearchCV()}) requires a temporal ordering between the two (\texttt{GridSearchCV()} and \texttt{preprocessing.scale()}) methods. 
\end{description}

The leaf components of this subclass contain all contract cases that we derived individually for the \emph{SAM and AMO} categories. For example, if an \emph{intra-argument contract, IC-1} of an API determines an \emph{always (G),} order of two APIs like the example above then, it belongs to \textbf{SAM (Level 3) $\land$ AMO (Level 2)}. 

Any dependency between SAM related leaf nodes, e.g., primitive type, built-in type, \ML~type, etc. and AMO related leaf nodes, i.e., G and F, belong to this category. 

\begin{description}[leftmargin=*]
	\item [\bfseries Selection (SL):] The final subclasses in our classification are those contracts that involve a choice when it comes to enforcing an API related contract. If the choices only belong to the contract components of \emph{SAM} or \emph{AMO}, then we categorize the contracts into either \textbf{SAM (Level 3)} or \textbf{AMO (Level 2)}, respectively. For instance, in \SO post \ref{fig:postSL1}, 
	the author wants to convert two \texttt{numpy} arrays to \texttt{Tensor}s and uses \texttt{TensorDataset()} from the \torch library. The arguments of this API must either be of \texttt{Double} or \texttt{Float} type. The API then confirms \texttt{DoubleTensor} conversion upon exiting. Hence, there are two choices of category SAM (specifically IC-2) to maintain the contract for this API, and we mark this with \textbf{SAM (Level 3) category}. The root cause of this contract violation is that the client did not follow one of the two choices (providing arguments of \texttt{Double} or \texttt{Float} types). \\
	\hspace*{0.2cm}
	\begin{lrbox}{\mybox}%
\begin{lstlisting}[language=iPython,numbers=none]
train = data_utils.TensorDataset(torch.from_numpy(X).double(), torch.from_numpy(Y))
train_loader = data_utils.DataLoader(train, batch_size=50, shuffle=True)
for batch_idx, (data, target) in enumerate(train_loader):
    data, target = Variable(data), Variable(target)
    optimizer.zero_grad()
    output = model(data)               # error occurs here
\end{lstlisting}
\end{lrbox}%
\scalebox{0.92}{\usebox{\mybox}}

\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
The \texttt{numpy} arrays are \texttt{64-bit} floating point and will be converted to torch. \texttt{DoubleTensor} standardly. Now, if we use them with our model, we'll need to make sure that your model parameters are also Double. Or we need to make sure, that your \texttt{numpy} arrays are cast as \texttt{Float}, because model parameters are standardly cast as \texttt{float}.
\end{mytbox2}
\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/44717100/pytorch-convert-floattensor-into-doubletensor} {Example post with contract} \label{fig:postSL1}}
\hspace*{0.3cm}
	
	Another example can be seen in the \SO post \ref{fig:postSL2},  
	where the author of the post is using the \keras library to create a neural network. Then they want to initialize and fit the neural network weights and save these weights. Next, they want to use these saved weights and predict some output values given the inputs. However, they had issues using the \texttt{load\_weights()} API to collect the saved weights. The answer post explains that as one uses the \texttt{load\_weights()} API, one has to maintain an order between two other related APIs (\texttt{compile} and \texttt{predict}). One expected order is calling \texttt{load\_weights()}, \texttt{compile()}, \texttt{predict()}. The order alternative is calling \texttt{compile()}, \texttt{load\_weights()}, and \texttt{predict()} at some point in history. As both choices involve AMO, this belongs to the \textbf{AMO (Level 2)} category. The root cause of this contract violation is that the client did not make one of the two choices (maintaining the method order between the related APIs). \\
 %\newpage
	\hspace*{0.2cm}
	\begin{lrbox}{\mybox}%
\begin{lstlisting}[language=iPython,numbers=none]
model = Sequential()
...
model.load_weights('keras_w') 
y_pred = model.predict(X_nn)
\end{lstlisting}
\end{lrbox}%
\scalebox{0.92}{\usebox{\mybox}}

\begin{mytbox2}[colback=green!15,fontupper=\scriptsize,flushleft upper,boxrule=0pt,arc=5pt,left=2pt,right=2pt,after=\ignorespacesafterend\par\noindent]{\checkmark Accepted Answer}
We need to call \texttt{model.compile}. This can be done either before or after the \texttt{model.load\_weights} call but must be after the model architecture is specified and before the \texttt{model.predict} call.
\end{mytbox2}
\captionof{Stack Overflow post}{\href{https://stackoverflow.com/questions/33474424/keras-load-weights-of-a-neural-network-error-when-predicting} {Example post with contract} \label{fig:postSL2}}
\hspace*{0.3cm}
	

In comparison, if the choices involve both SAM and AMO, then we categorize the contract as a combination type contract \textbf{Comb. of SAM and AMO}. For example, in \SO~post \ref{fig:post1}, we observe such a combination. The accepted answer respondent mentions two alternative ways to maintain correctness when using the \texttt{tf.random\_shuffle} API. The first choice is setting the argument \texttt{seed} for this API to some desired value. The second is maintaining an order between invocations of \texttt{tf.random\_shuffle()} and \texttt{tf.reset\_default\_graph()}. Since the same contract breach can be resolved through either a behavioral or temporal contract that involves \texttt{tf.random\_shuffle()} API, there is a selection involved as to which one to be adopted. 
	Documentation should include all choices to maintain contracts for an API method. The root cause of this contract violation is that the client did not make one of the two choices (providing an acceptable \texttt{seed} value or using an acceptable method ordering) for the API to function properly.
	Researchers should emphasize the need to be able to express such requirements to users, who can choose to satisfy the requirements of a library either by maintaining a temporal order or by some state-based change. Therefore, the practitioners can design and develop a contract checking mechanism for ML API calling orders to facilitate the end-users.
	
\end{description}