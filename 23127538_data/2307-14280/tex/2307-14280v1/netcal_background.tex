
\section{Deterministic Network Calculus}
\label{sec:dncintro}

\acf{DNC} is built around two concepts \cite{LeBoudec2001}:
\begin{enumerate*}[label=\textit{\alph*)}] 
	\item the network of deterministic queueing locations crossed by constrained data flows, and
	\item resource modeling with cumulative functions in interval time.
\end{enumerate*}
Based on a fully specified model, a traditional \ac{DNC} analysis derives an upper bound on an analyzed flow's end-to-end delay.

We are interested in networks with point-to-point connections between devices, such as IEEE Ethernet and its extensions \ac{TSN} and \ac{AFDX}.
A model of such a network usually consists of the devices, e.g., switches, that are connected by undirected links.
I.e., an undirected graph $\mathcal{G}_{\text{device}} = (\mathcal{D}, \mathcal{L})$ is formed from devices $d\in\mathcal{D}$ and links $l\in\mathcal{L}$.
Most relevant for the \ac{NC} queueing analysis is the behavior at the devices' output ports.
Given the point-to-point connection, we therefore split the undirected links into directed ones such that there is one queueing location per directed link.
For convenience, we create the edge-to-vertex dual of this graph such that these queueing locations are represented by vertices.
The behavior at queueing locations can be defined by a wide range of scheduling policies, ranging from single \ac{FIFO} queues, over round robin schedulers (e.g., WRR, DRR) to a combination priority queues, shaping, time-triggered scheduling etc. as, for example, defined by \ac{TSN}.
For schedulers with static configurations to seperate service provision, the respective vertex is split into the defined number of priority levels or round robin class etc.
We call these vertices the servers and the resulting graph the server graph $\mathcal{G} = (\mathcal{S}, \mathcal{E})$ where each server $s\in\mathcal{S}$ forwards queued data.
The guaranteed service is expressed by non-negative, non-decreasing functions
$\mathcal{F}^{+}_{0}\!=\!\left\{ f:\mathbb{R}^{+}\rightarrow\mathbb{R}^{+}\,|\,f(0)\!=\!0,\;\forall s\le t\,:\,f(t)\!\geq\!f(s)\right\}$
called service curves.
\begin{definition}[Service Curve]
	If a server receives a data input $A\in\mathcal{F}^{+}_{0}$ and produces an output $A'\in\mathcal{F}^{+}_{0}$,
	then it is said to offer service curve $\beta \in \mathcal{F}_0$ iff
	\begin{equation}
	\label{eq:service_curve}
	\forall t : A'(t) \geq \inf_{0 \leq d \leq t} \{ A(t - d) + \beta(d) \}.
	\end{equation}
\end{definition}
The \ac{NC} literature provides a rich set of results to derive the service curves for different schedulers' service classes, e.g., \ac{TSN} \cite{Zhao2018,Zhao2020}.

Data flows cross the graph~$\mathcal{G}$ from a source server to a given number of destination servers, both in~$\mathcal{S}$.
The unicast or multicast flow path/s are subgraphs of $\mathcal{G}$ and a restriction on the data sent by a flow is assumed to be known at its source.
\begin{definition}[Arrival Curve]
	\label{def:Arrival-Curve}
	Given a flow $f$ described by $A\in\mathcal{F}^{+}_{0}$, 
	a function $\alpha\in\mathcal{F}_{0}$ is an arrival curve for $f$ iff
	\begin{equation}
	\label{eq:arrival_curve}
	\forall\,0\leq d\le t\,:\,A(t)-A(t-d)\leq\alpha(d).
	\end{equation}
\end{definition}

A traditional \ac{NC} analysis takes as input a fully specified queueing network model, i.e., a server graph with its service curves as well as flows, their paths and arrival curves.
It aims at deriving the end-to-end delay bound of a specific flow of interest (foi).
To do so, it needs to derive worst-case bounds on the mutual impact of flows at shared servers -- the queueing aspects not quantified by the model itself.
Our work is based on traditional (min,plus)-algebraic \ac{NC} analyses that assume the absence of cyclic dependencies between flows as well as the arbitrary multiplexing assumption.
These analyses derive a (min,plus)-algebraic term that bounds the end-to-end delay, consisting of the following operations:
\begin{definition}[Operations]%
	\label{def:MinPlusOperations}
	Given $\beta_1,\beta_2,\alpha_1,\alpha_2$, we can
	\begin{eqnarray}
	\text{aggregate:} &  & \hspace{-6.5mm}\left(\alpha_1+\alpha_2\right)\left(d\right) = \alpha_1\left(d\right)+\alpha_2\left(d\right)\!,\\
	\text{concatenate:} &  & \hspace{-6.5mm}\left(\beta_1\otimes \beta_2\right)(d) = {\displaystyle \inf_{0\leq u\leq d}}\left\{ \beta_1(d-u)+\beta_2(u)\right\}\!,\\
	\hspace{-5.5mm}\text{output bound:} &  & \hspace{-6.5mm}\left(\alpha_1\oslash \beta_1\right)(d) = \sup_{u\geq0}\left\{ \alpha_1(d+u)-\beta_1(u)\right\}\!,\\
	\text{left-over:} &  & \hspace{-6.5mm}\left(\beta_1\ominus \alpha_1\right)(d) = \sup_{0\leq u \leq d} \left\{\beta_1(u) - \alpha_1(u)\right\}\!, \\
	\text{delay bound:} &  & \hspace{-6.5mm} h(\alpha_1 ,\beta_1) = \inf\left\{ d\geq0|\!\left(\alpha_1\oslash\beta_1\right)(-d)\leq0\right\}\!\hspace{4mm}
	\end{eqnarray}
	flows and servers, respectively, in a worst-case manner.
\end{definition}

In this article, we will apply the \ac{SFA} \cite{LeBoudec2001} as the set of rules to derive the (min,plus)-algebraic, delay-bounding term from the server graph. %
