\section{Stripe parametrizations}
\label{sec:Stripe_parametrizations}


We describe steps (1)-(3) of the pipeline, where we first design a directional field and then integrate it into a parameterization suitable for our framework. 

\subsection{Transversal parametrizations}
\label{sec:stripe-parameterization}


We work with a triangular mesh $\MM = \left\{\VV,\EE,\FF\right\}$. 
We denote by $\mathcal{C}$ the set of \emph{corners} $(v,f)$, where $v \in \VV$ denotes a vertex and $\ f \in \FF$ a face adjacent to this vertex. We begin by constructing two transversal parameterizations $U$ (displayed throughout  in blue), and $V$ (displayed in green) on $\MM$ that represent the two strip networks. 


% Since printing a path can be done in both directions, 
Since strips are \emph{sign-invariant}, i.e., they can be traversed in both directions without any difference in the result, the parameterization must also be sign-invariant. To achieve that, we design a strip network as a branched $2$-function \cite{vaxman2016_directional-field-synthesis-design-and-processing}, which admits singularities of indices $\pm \frac{k}{2},\ k \in \ZZ$. Formally, a $2$-function $U:\mathcal{C} \rightarrow \RR$ is defined as the assignment of a scalar per corner, linearly interpolated inside each triangle. Furthermore, on every edge $e$ between vertices $i, j$ and adjacent to faces $f,g$, we have:
$$
U_{f,i}-U_{f,j} = s_e (U_{g,i}-U_{g,j}),\quad\text{for some } \, s_e = \pm 1.
$$
The specific choice of the sign $s_e$ is called the \emph{matching} on the edge $e$.
A regular patch $\mathcal{P} \subset \MM$ is a sub-mesh where a function $U$ can be ``combed'' into a single (1-)function without any sign ambiguity. Combing means re-signing all corner values on the patch so that they agree on all $e \in \mathcal{P}$ with $s_e=1$. Patches where this is not possible, are called \emph{singular}; they contain branching points, or \emph{singularities}, of the parameterization (\figref{fig:green_blue}, \ref{fig:vec_sings_to_mesh_sings}). 

The output of this stage is two $2$-functions $U$ and $V$, each representing one strip network. We design those functions by optimizing their gradients, which we denote with small case letters $u=\nabla U,v=\nabla V$. This is a common modus operandi to construct such \emph{seamless} parameterizations (eg.,~\cite{sageman-furnas2019_chebyshev-nets-from-commuting,meekes2021_unconventional-patterns-on-surfaces,verhoeven2022_dev2pq:-planar-quadrilateral-strip-remeshing}). $u$ and $v$ are the \emph{guiding fields} through which we can incorporate the objectives listed above. 


\subsection{Guiding fields}
\label{subsec:guiding-fields}

The gradient of a $2$-function is a $2$-vector field (\figref{fig:vec_sings_to_mesh_sings}), which is also sign-invariant and has  the same singularities. Furthermore, the field is \emph{face-based} and \emph{piecewise-constant}, with a single $2$-vector in each face $f \in \FF$, and it is curl-free; that means on edge $e$ shared by faces $f$, $g$ we have:
 \begin{equation}
\langle u_f, e \rangle = s_e \langle u_g,e \rangle,\ \ \langle v_f, e \rangle = s_e \langle v_g,e \rangle.
\label{eq:curl_conditions}
 \end{equation}

 
Our main variables are two $2$-fields $X, Y$, piecewise constant per face,  that represent the \emph{candidate gradient fields}  $u, v$ of the parameterizations.
The $2$-fields are expressed in the \emph{power} representation~\cite{knoppel2013_globally-optimal-direction} to achieve sign invariance: we represent $u_f$ and $v_f$ as complex numbers in an arbitrary local basis in each face $f$, and then define:
$$
X_f = (u_f)^2,\ Y_f = (v_f)^2.
$$


\subsubsection{Energies}
\label{subsec:energies}

 A useful energy term is a generic \emph{closeness} energy for power fields with the structure:
 $$
 E_C(K,R,M) = (K - R)^H M (K - R). %{\mathbf{1}^T M \mathbf{1}}.
 $$
 This energy measures how close the field $K$ is to an input field $R$ in a metric defined via the mass matrix $M$. $(.)^H$ denotes the conjugate transpose of $(.)$. With this, we set the following optimization energy terms.

\paragraph{\textbf{Alignment} - objective \ref{obj:aligned}} 
\label{par:alignment}
This energy term aims to keep the two 2-vector fields aligned with the input directional constraints.
Each constrained face $f_S$ in the set of constrained faces $\FF_S$ has a constraint tangent alignment $2$-vector given in the power representation $\alpha_f$, and a confidence weight $\omega_f$. We collect the confidence weights in a confidence matrix $W = \text{diag}(\omega_f)$, and also compute an orthogonal tangent constraint $2$-vector $\beta_f = -\alpha_f$ for the transversal direction $Y$. Then the alignment energy is written as closeness energy to the directional constraints. 

 \begin{equation}
 E_A(X, Y) = E_C(X_S, \alpha, W\cdot M_{\FF|S}) + E_C(Y_S, \beta, W\cdot M_{\FF|S}).
 \label{eq:soft-alignment-term}
 \end{equation}
$M_{\FF|S}$ is the diagonal mass matrix of triangle areas restricted to the alignment faces $\FF_S$, as this energy is only applied to the constrained faces in $\FF_S$. 

We employ three presets of input alignment constraints, each beneficial in a different context: %Throughout the  document we depict the $U$ direction with blue, and the $V$ direction with green color.
\begin{itemize}
    \item \emph{Curvature alignment.} We use principal curvature directions for alignment, with confidence value (Eq.~\ref{eq:soft-alignment-term}) for each face $\omega = \kappa_{\text{max}}-\kappa_{\text{min}}$, where $\kappa_{(\cdot)}$ are the principal curvatures.  We then choose as the  constrained faces $\FF_S$ those with the highest confidence values (by default: top $\% 10$). We set $\alpha$ and to $\beta$ be the square of the minimum and maximum principal curvature vectors respectively (\figref{fig:different_input_constraints}a).
    \item \emph{Boundary constraints.} We add each boundary face with one boundary edge $e$ to the constrained faces and set $\alpha$ and $\beta$ to be exactly orthogonal and parallel to $e$ respectively (\figref{fig:different_input_constraints}b), with confidence values $\omega = 1$ on all constrained faces.
    \item \emph{User-drawn directions.} The user draws a curve on the surface from which we extract constrained faces. We then set $\alpha$ to be orthogonal and to the curve and $\beta$ parallel (\figref{fig:different_input_constraints}c), with confidence values $\omega = 1$ on all constrained faces.
\end{itemize}


\paragraph{\textbf{Unit length} - objective \ref{obj:uniform}} This energy term aims to keep the 2-vector fields as close as possible to unit norm, and can be written as a closeness energy to 
$\hat{X}=\frac{X}{|X|}$ and $\hat{Y}=\frac{Y}{|Y|}$ (normalized $X$ and $Y$). 
    \begin{equation}
    E_U(X, Y) = E_C(X,\hat{X},M_\FF) + E_C(Y,\hat{Y},M_\FF)
    \end{equation}
where $M_{\FF}$ is the diagonal mass matrix of triangle areas. We note the use of the auxiliary variables $\hat{X}$ and $\hat{Y}$ that are ``snapshot'' (to a previous iteration in our algorithm), keeps this energy quadratic.


 \paragraph{\textbf{Smoothness} - objective \ref{obj:smooth}} 
 This energy term aims to keep the 2-vector fields as smooth as possible.
 For smoothness, we consider the $|\EE_I|\times|\FF|$ discrete \emph{covariant derivative} matrix $D$ for power $2$-fields (with the weights of ~\cite{brandt2018_modeling-in/i-symmetry-vector-fields-using}), which for every internal (non-boundary) edge $e \in \EE_I$ on adjacent faces $f$ and $g$ computes:
 $$
 (DX)_{|e} = \left(X_f\cdot (\overline{e}_f)^2 - X_g\cdot (\overline{e}_g)^2\right),
 $$
 where $\overline{e}_f$ (resp. $\overline{e}_g$) is the \emph{normalized} conjugate edge vector $e$ in the basis of $f$ (resp. $g$). We also need the $|\EE_I| \times |\EE_I|$ diagonal \emph{mass matrix} $M_D$, where $M_D(e,e) = \frac{3|e|^2}{A(f) + A(g)}$, and $A(\cdot)$ denotes the area operator. Then, the smoothness energy is:
 \begin{equation}
     E_S(X,Y) = X^H (D^H M_D D) X + Y^H (D^H M_D D) Y 
 \end{equation}


 \paragraph{\textbf{Orthogonality} - objective \ref{obj:orthogonal}} This energy is the only term that links $X$ with $Y$. It aims to keep the two 2-fields as orthogonal as possible.
 \begin{equation}
     E_O(X,Y) = (X+Y)^H M_\FF (X+Y) % {\mathbf{1}^T M_\FF \mathbf{1}}.
 \end{equation}
 When $X=-Y$ we get $u = \pm i\cdot v$, which implies that the vectors are perfectly orthogonal (and with equal magnitudes). 



 \paragraph{Normalization of energies}
 We normalize all energy terms to make them of comparable magnitudes with each other. The energies have the from $E = P^H \mathcal{A}P$. To normalize them, we divide by $\mathbf{1}^T \mathcal{A} \mathbf{1}$, where $\mathbf{1}$ is the vector of all $1$'s.

\subsubsection{Constraints}

 \paragraph{\textbf{Integrability}} 
 As described above, the guiding fields must be curl-free to represent the gradients of the parametrization functions. The curl reduction strategy aims to keep the curl of the fields $u$ and $v$ to zero during the optimization. Note that, unlike all previous energy terms, the curl of a field is not sign-invariant. Therefore we need to compute an explicit matching $s_e$ on every inner edge $e \in \EE_I$, as per \eqref{eq:curl_conditions}. 
 
 
\paragraph{Matching}
\label{par:matching}
To find the matching (i.e. the sign of each vector) we first compute $u_f = \sqrt{X_f}$ and $v_f = \sqrt{Y_f}$ in each face. Note that the solution to this has arbitrary signs. 
We then find the sign for one of the 2-fields, say $u$; namely for each edge $e$ between faces $f$, $g$, we find the sign $s_e \in \left\{-1,0,1\right\}$ per edge $e \in \EE_I$ so that it minimizes rotation effort between $\left\{u,-u\right\}_f$ and $\left\{u,-u\right\}_g$ (also known as the \emph{principal} matching~\cite{diamanti2014_designing-n-polyvector-fields-with}). We then update the signs of the other field to have the same matching. This results in two positively-oriented fields with the same topology by design.
 
\paragraph{Curl elimination} 
Equipped with the matching, we build the $|\EE_I|\times |\FF|$ \emph{curl matrix} $C_s$ which, on every edge $e$ between faces $f$ and $g$, computes, for the $u$ field:
 \begin{equation}
     (C_s\cdot u)_{|e} = \langle s_e u_g - u_f, e\rangle,
 \end{equation}
 and similarly for $v$. To eliminate curl, we solve a projection problem to the nearest curl-free field with the given matching $\mathbf{s}$, namely:
\begin{align*}
    (u,v)^* &= \text{argmin}|u^*-u|^2+|v^*-v|^2\ s.t.\\ C_s\begin{pmatrix}u^*\\v^*\end{pmatrix}&=0
\end{align*}
via the minimum $2$-norm projection on the null space of $C_s$ \cite{verhoeven2022_dev2pq:-planar-quadrilateral-strip-remeshing}.
 

\subsubsection{Optimization problem}
With these, our full optimization problem for the fields is:

\begin{align}
    (X, Y,u, v,s) = &\text{argmin}( \lambda_S E_S+ \lambda_OE_O + \lambda_U E_U+ \lambda_A E_A)        \label{equ:optimizationproblem}\\
    \text{subject to \quad} & C_s\cdot u_f = 0,\ C_s\cdot v_f = 0   ,\quad \forall f \in \FF
    \tag{\small curl-free} \\
    &X_f = u_f^2,\ Y_f = v_f^2, \quad \forall f \in \FF \tag{\small compatibility}
\end{align}



\subsection{Optimization}
\label{subsec:optimization}
\subsubsection*{Optimization algorithm}
The directional-field optimization problem in \eqref{equ:optimizationproblem} is nonlinear, due to the normalized compatibility and unit-length term, and discrete, because of the matching variable $s$. We use an alternating optimization scheme, summarized in Alg.~\ref{alg:full-optimization-directional-field}, where we alternate between reducing a quadratic energy $E^k$ with an implicit step, principal matching (in closed-form),  curl-elimination (another quadratic energy), and closed-form projection to the compatiblity constraints. To encourage convergence, we introduce a factor $\lambda_E$ that attenuates the objective terms in every iteration. 


\begin{algorithm}[h!]
\SetAlgoLined
 Initialize $k\leftarrow 0$, \\
 $\left(X^0,Y^0, E^0\right)\leftarrow \text{argmin} (\lambda_SE_S+\lambda_AE_A+\lambda_OE_O)$\hfill \emph{(variables initialization)}\\
$\forall f\in \FF,\ X_f^0\leftarrow \frac{X_f^0}{|X_f^0|},\ Y_f^0\leftarrow \frac{Y_f^0}{|Y_f^0|}\  $\hfill \emph{(normalization of initial solution)} \\
$\lambda_E^0 = 1$\\
 $\mu = \text{smallestEigenValue}(E^0,M_\FF),\ dt = \nicefrac{1}{\mu}$\\
 \Repeat{$ \|E^k-E^{k-1}\| < 10^{-4}$ \text{or} $k=100$}{
 	
    $(X^{k+1}, Y^{k+1}, E^{k+1}) \rightarrow \text{ImplicitStep}\left(X^k, Y^k,  E^k, M_\FF, dt\right)$\\

    $\hat{X}_f^{k+1}\leftarrow \frac{X_f^{k+1}}{|X_f^{k+1}|},\ \hat{Y}_f^{k+1}\leftarrow \frac{Y_f^{k+1}}{|Y_f^{k+1}|}$\hfill \emph{(re-normalization)} \\
    
    $(u^{k+1},v^{k+1},s)\leftarrow\text{PrincipalMatching}(X^{k+1},Y^{k+1})$\\

    $(u^{k+1},v^{k+1})\leftarrow\text{CurlElimination}(u^{k+1},v^{k+1},s)$ \\
    $X^{k+1}=(u^{k+1})^2$, $Y^{k+1}=(v^{k+1})^2$\hfill \emph{(compatibility)}\\
    $\lambda_E^{k+1} \leftarrow 0.8\lambda_E^k$\hfill \emph{(dampening)}\\
    $k \leftarrow k+1$\\
 }
 \caption{Directional-Field Optimization}
 \label{alg:full-optimization-directional-field}
\end{algorithm}


\paragraph{Implicit Step} The generic function $$y=\text{ImplicitStep}(x, A, M, dt)$$ performs an implicit step to minimize an objective of the type $E = x^TAx$ with the a $M$. It returns $y$ (and the energy) as the solution to the linear system:
$$
(M + dt\cdot A)y = Mx.
$$
Our time step $dt$ is inversely proportional to the scaling of the energy by the Fiedler value $\mu$, as explained in~\cite{sageman-furnas2019_chebyshev-nets-from-commuting}. 


\subsubsection*{Choice of parameters.}
\label{sec:directional_constraints}

We use the following energy weights: 
     smoothness $\lambda_S = 10.0$,
     orthogonality $\lambda_O = 2.0$,
     alignment  $\lambda_A = 0.1$,
     and unit $\lambda_U = 1.0$.
     % and previous $\lambda_P = 0.1$. \ioanna{verify}
$\lambda_E$ has an initial value of 1.0, which is multiplied by 0.8 after every iteration to encourage convergence to the constraints.


% Figure environment removed



\subsection{Integration and Meshing}
\label{subsec:integration-and-meshing}

Having optimized the two coupled fields $u$ and $v$, we integrate them into parameterization functions $U$ and $V$. 
To do that, we combine $u$ and $v$ in one 4-field so that the vectors in each face are arranged in the order $\left\{u,v,-u,-v\right\}$ in CCW fashion around the normal. The matching of the 4-field on every edge $\mathbf{s_e}$ equals $2 s_e$, i.e. it has values in $\left\{-2,0,2\right\}$ so that $u$ and $v$ never intermix in the 4-field. We can then use a standard frame-field integration and meshing algorithm to integrate the 4-field into the  functions $U$ and $V$. These functions result in two coupled transversal strip networks (Fig. \ref{fig:green_blue}) that are overlaid into a single quad mesh $\MM_\QQQ = \left\{\VV_\QQQ, \EE_\QQQ, \FF_\QQQ\right\}$ that is strip-decomposable by design. The singularities of the field are directly translated into singular vertices of $\MM_\QQQ$ (~\figref{fig:vec_sings_to_mesh_sings}). Integration and meshing are done using the library \texttt{Directional}~\cite{amir_vaxman_and_others_2021_5746726}.


Note that we use the same notation ($U$, $V$) for the parameterization functions and for resulting strips, as they essentially refer to the same geometry. $U$-strips (blue) are bounded by $U$-edges which are isolines of the integration of the $u$ vectors, i.e., always orthogonal to the $u$-field. Similarly, $V$-strips (green) are bounded by $V$-edges orthogonal to the $v$-field. 
$\MM_\QQQ$ has non-quad faces only on the boundaries, where the strips are cut by the boundary. 


% Figure environment removed



 \paragraph{Discussion} Our directional-field framework is inspired by  similar frameworks for integrable aligned parameterization. Specifically, there is considerable similarity with integrable $4$-fields (``frame fields'') since we create the combined field $\left\{u,v,-u,-v\right\}_f$ in each face. The overlay of our resulting parameterizations is technically a $4$-function (of the kind used for quad-meshing). However, existing algorithms for integrable frame fields also allow both directions to interchange in a way that permits $\pm \frac{1}{4}$ singularities, leading to a general quad mesh that does not necessarily separate into transversal strips without cuts or discontinuities (see \figref{fig:comparison-with-cross-field}). To the best of our knowledge, no existing algorithm specifically treats our case of SDQ meshes with directional fields.

 % Figure environment removed