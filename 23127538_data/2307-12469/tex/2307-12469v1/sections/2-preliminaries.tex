\section{Preliminaries}
\label{sec:preliminaries}

% Figure environment removed
\noindent

\noindent
\textbf{Fuzz Driver Basics} \tab 
% key aspects of a fuzz driver
% The prerequisites can include the initialization of the target API arguments and the setup of the correct execution context.
The key components of a fuzz driver are illustrated in Figure~\ref{fig:fuzz-driver-internal}.
A typical fuzz driver includes at least three components: prerequisites initialization, execution, and post-cleaning of the target API, as mentioned in lines 3, 4, and 7.
In addition, there are three optional components listed in lines 2, 5, and 6 that can improve a driver's effectiveness.
The component mentioned in line 2 allows the driver to reject inputs with large sizes to reduce execution costs, or to split input data into several parts for testing multiple arguments of the target API.
The component mentioned in line 5 enables the driver to call additional APIs to trigger more program behaviors, which helps reveal more bugs.
Finally, the component mentioned in line 6 allows the driver to add semantic oracles to find more logical bugs.
These oracles are similar to \texttt{assert} statements used in unit tests, which abort execution when certain properties of the program are not satisfied.
Since the fuzz drivers are extensively executed with randomly mutated input data, there is a high requirement on the correctness and robustness of its API usage.
The incorrect or unrobust usage can lead to both false positives and negatives.
For instance, if a driver failed to feed the mutated data into the API, it can never find any bug inside the target.
Or if a driver passed an incorrectly initialized argument to the API, false crashes may be raised.
% In this paper, an effective fuzz driver represents the drivers which have correct API usage and produce no false positives.
% Precisely validating the effectiveness of fuzz drivers is crucial for evaluating fuzz driver generation methods.
% However, general validation techniques do not work well due to the diverse semantics on the API usages.

\noindent
\textbf{Minimum Requirements of an Effective Fuzz Driver} \tab 
% what is an effective fuzz driver
To be effective, a fuzz driver must correctly use the API and produce no false positive results.
The minimal requirements for an effective fuzz driver includes satisfying the necessary control flow dependencies and initializing the arguments correctly.
Argument initialization can be one of the following cases (in the order of simplicity):
\ding{182} \textbf{C1}: If the argument value is irrelevant or should be a naive value such as \texttt{0} or \texttt{NULL}, a variable is declared or a literal constant is used directly;
\ding{183} \textbf{C2}: If the argument is supposed to be a macro or a global variable that is already defined in common libraries or the target API's project, it is located and used;
\ding{184} \textbf{C3}: If creating the argument requires the use of common library APIs, such as creating a file and writing specific content, common practices are followed;
\ding{185} \textbf{C4}: If initializing the argument requires the output of other APIs within the project, those APIs are initialized first following the above initialization cases.

\noindent
\textbf{LLM-Based Code Generation} \tab 
LLMs provide a natural language interface that allows users to generate code through conversational queries and answers.
With this interface, code generation tasks can be completed more efficiently and with less technical expertise required.
In this study, prompt represents the content of a single query while the conversation represents one or more rounds of queries and answers sharing the same communication context.

% The type of prompt involved in the study is \textit{prefix prompt}~\cite{prompt-engineering-survey}, which expects the LLM to continue the content
% llm is query based, in a conversational style
% what is prompt, what is query, what is conversation
% we only consider the second form of prompt
