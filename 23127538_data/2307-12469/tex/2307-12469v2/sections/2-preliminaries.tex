% \vspace{-7pt}
\section{Preliminaries}
\label{sec:preliminaries}

% Figure environment removed
% \vspace{-10pt}
\noindent

\noindent
\textbf{Fuzz Driver Basics} \tab 
% key aspects of a fuzz driver
% The prerequisites can include the initialization of the target API arguments and the setup of the correct execution context.
The key components of a fuzz driver are illustrated in Figure~\ref{fig:fuzz-driver-internal}.
A typical fuzz driver has three necessary parts: prerequisites initialization (line 3), execution (line 4), and post-cleaning (line 7).
Besides, there are three optional parts listed in lines 2, 5, and 6 that can improve a driver's effectiveness.
Line 2 part improves a driver by proper input arrangement such as rejecting too short or too long inputs, interpreting input data as multiple testing arguments, etc.
Line 5 part enables a driver to call more APIs which triggers more program behaviors during fuzzing.
Finally, line 6 part adds semantic oracles for detecting logical bugs.
These oracles are similar to \texttt{assert} statements in unit tests, aborting execution when certain program properties are unsatisfied.
Since a driver will be repeatedly executed with randomly mutated input, there is a high requirement on its correctness and robustness.
Incorrect or unrobust usage can lead to both false positives and negatives.
For instance, if a driver failed to feed the mutated data into the API, its fuzzing can never find any bug.
Or if an API argument is incorrectly initialized, false crashes may be raised.
% In this paper, an effective fuzz driver represents the drivers which have correct API usage and produce no false positives.
% Precisely validating the effectiveness of fuzz drivers is crucial for evaluating fuzz driver generation methods.
% However, general validation techniques do not work well due to the diverse semantics on the API usages.

\noindent
\textbf{Minimal Requirements of Effective Fuzz Drivers} \tab 
% what is an effective fuzz driver
% To be effective, a fuzz driver must correctly test the API and produce no false positive results.
The minimal requirements covers the line 3,4, and 7 of Figure~\ref{fig:fuzz-driver-internal}, which mainly include correctly initializing the arguments and satisfying necessary control flow dependencies.
Argument initialization can be one of the following cases (in the order of simplicity):
\ding{182} \textbf{C1}: If the argument value can be any value or should be naive values like \texttt{0} or \texttt{NULL}, a variable is declared or a literal constant is used directly;
\ding{183} \textbf{C2}: If the argument is supposed to be a macro or a global variable that is already defined in common libraries or the target API's project, it is located and used;
\ding{184} \textbf{C3}: If creating the argument requires the use of common library APIs, such as creating a file and writing specific content, common practices are followed;
\ding{185} \textbf{C4}: If initializing the argument requires the output of other APIs within the project, those APIs are initialized first following the above initialization cases.

% \noindent
% \textbf{LLM-Based Code Generation} \tab 
% LLMs provide a natural language interface that allows users to generate code through conversational queries and answers.
% With this interface, code generation tasks can be completed more efficiently and with less technical expertise required.
% In this study, prompt represents the content of a single query while the conversation represents one or more rounds of queries and answers sharing the same communication context.

% The type of prompt involved in the study is \textit{prefix prompt}~\cite{prompt-engineering-survey}, which expects the LLM to continue the content
% llm is query based, in a conversational style
% what is prompt, what is query, what is conversation
% we only consider the second form of prompt
