
\subcompact
\subsection{Impact of Modern Hardware}
\label{subsec:modern_hardware}
In this section, we compare \system with existing TSPEs on how they interact with modern multicore processors from the modern hardware architecture perspective. 
% And we then show how the evaluation results vary under increasing number of cores.

\textbf{Micro-architectural Analysis.}
We take SL as an example to show the breakdown of the execution time according to the Intel Manual. Figure~\ref{fig:uarch_topdown} compares the time breakdown of different TSPEs. We measure the hardware performance counters through Intel Vtune Profiler during the algorithm execution and compute the top-down metrics. 
We have three major observations.\margi{R5D8}First, the breakdown results reaffirm our previous analysis that \system spends up to 2.3x fewer clock ticks for transaction processing compared to \tstream and \sstore, because of its more efficient adaptive scheduling strategies. Second, all three TSPEs \change{are Memory Bounded}, i.e., a large proportion of CPU cycles are spent due to memory access instructions: \system (58.5\%), \tstream (63.3\%), and \sstore (80.9\%).
% \change{This means }.
The detailed profiling with Intel Vtune Profiler reveals that it is commonly due to the heavy usage of latches to resolve dependencies among transactions while accessing the shared-mutable state. Both \tstream and \sstore have a higher Memory Bound than \system due to the higher synchronization cost. Nevertheless, \change{Figure~\ref{fig:uarch_topdown} and\margii{-15pt}{R5D8}Figure~\ref{fig:Breakdown} jointly indicate that \system can adopt more efficient exploration strategies to further improve its performance.}
% reduce the synchronization overhead.

\begin{comment}
this is mainly because of the inevitable dependencies solving among transactions during accessing shared-mutable state. 
\tony{Nevertheless, both \tstream (63.3\%) and \sstore (80.9\%) show a higher Memory Bound than \system (58.5\%) due to the higher synchronization cost. -- are you sure?}
\end{comment}
% and failed to better utilize hardware resources. 
% Similar to our previous observation, 
% There are four further key takeaways.
% First,
% \emph{Abort Time} refers to the wasted computation time due to abort and redos.
% TStream has the highest abort time because TStream has to redo the entire batch of transactions when transaction abort happens.
% S-Store spends little time in abort as it involves little redo of state transactions because dependent transactions are executed serially.
% Second,
% both \system and TStream successfully reduce synchronization overhead (\emph{Sync Time}) compared to S-Store. This explains their better performance on multicore processors.
% Third,
% \emph{Construct Time} refers to the time spent on constructing data structure e.g., \stpg in \system and operation chains in TStream. There is no construction overhead in S-Store, as it does not dynamically decompose state transactions.
% In contrast, both TStream and \system spend a significant portion of time during construction, due to the costly transaction decomposition process. This also explains why \system is not linearly scalable.
% Our further investigation reveals that a construction bottleneck is at the sorting of operations at runtime. 
% % fine-grained dependency identification, mainly causing by the sorting of operations by timestamp (Section~\ref{subsec:construction}). 
% Further incorporating more efficient concurrent sorting algorithms~\cite{chhugani2008efficient} in \system is a valuable future work.
% Forth,
% \emph{Explore Time} refers to the time spent on exploring available operations to process.
% We can see that \system spends a significant fraction of time to perform exploration due to the message-passing among threads.
% More efficient exploration strategies such as prioritising mechanisms~\cite{kwok1999static} may be further incorporated in \system thanks to its modularized architecture. 
% % Figure environment removed

\textbf{Multicore Scalability.}
Figure~\ref{fig:multi_core} shows the scalability comparison among TSPEs, with two major observations. 
First, \system outperforms prior schemes with an increasing number of cores confirming the good scalability of \system. However, there is still a large room for further improving \system towards linearly scale-up, the reason being that it becomes memory bounded as Figure~\ref{fig:uarch_topdown} previously shown.
Second, when the number of cores is low, \system performs even worse than \sstore due to the large constant overhead of \tpg construction process. In a resource constraint setting, existing non-adaptive solutions may be more favoured.
% % Figure environment removed



