\section{Planning: \tpg Construction and Dependency Tracking}
\label{sec:planning}
In this section, we detail the process of \tpg construction along with how \system tracks dependencies in workloads.

\subcompact
\subsection{Planning Overview}
\label{subsec:construction}

% Figure environment removed

\system constructs a \tpg for every batch of state transactions with minimal overhead. Upon the arrival of transactions, they are decomposed into atomic state access operations, which then serve as the vertices of the \tpg. Two main techniques are employed by \system to aid in the construction of the \tpg: \emph{Two-phase \tpg construction} and \emph{Virtual Operations}.

\textbf{Two-phase \tpg construction:} 
To counter the issue of out-of-order state transactions, \system partitions the \tpg construction process into two phases: stream processing phase and transaction processing phase. During the stream processing phase, transactions are decomposed into atomic state operations, which are arranged as per the temporal order of the transactions and serve as vertices of the \tpg. During the transaction processing phase, three types of dependencies - 
\myc{\ld, \td and \pd}
% Logical Dependency (\ld), Temporal Dependency (\td), and Parametric Dependency (\pd) 
- are identified among these state operations to construct the \tpg.

\textbf{Virtual Operations:} To identify dependencies for an operation that accesses multiple \myc{(e.g., $n$)} states, $n$ virtual operations of the operation are maintained. Each virtual operation represents one state access on a specific state and is inserted into sorted lists of corresponding states. This method allows \system to efficiently identify dependencies during the \tpg construction process.

\subcompact
\subsection{Dependency Tracking for Out-of-Order State Transactions}
\label{subsec:out-of-order}
The construction of the \tpg includes the identification of \lds among operations from the same transaction. However, due to the potential out-of-order arrival of transactions, \tds and \pds cannot be immediately identified. To solve this issue, \system utilizes two-phase \tpg construction and virtual operations to identify all three types of dependencies:

\textbf{Stream processing phase:} Transactions are decomposed into atomic state access operations and \lds are identified. A preliminary \tpg is constructed by inserting operations as vertices and \lds as edges. To identify \tds, operations are inserted into key-partitioned sorted lists (based on the targeted state of each operation) sorted by timestamp. For each write operation with multiple states, virtual operations are maintained and inserted into the sorted lists to identify \pds during the next phase.

\textbf{Transaction processing phase:} At this phase, further state transactions are blocked until the stream processing phase resumes. \tds and \pds can be identified efficiently using the constructed sorted list and virtual operations from the stream processing phase. \tds are identified by iterating through operations in each sorted list. \pds are identified based on the precedence of the virtual operations in the sorted list. After identifying all \tds and \pds, these are inserted as edges into the \tpg.

\textbf{Running Example.}
% A practical application of this process is in Streaming Ledger (SL), a real-world stream application that processes input events involving money and asset transfers between accounts. 
\myc{A practical application of this process is in SL, which involves two types of transactions: deposit transactions and transfer transactions.}
Figure~\ref{fig:TPG} shows an example involving a deposit transaction and two transfer transactions that arrive consecutively. Through the two-phase \tpg construction process and the use of virtual operations, the dependencies are tracked efficiently, and a comprehensive \tpg is constructed.

\myc{
In the stream processing phase, upon arrival, transactions $txn_1$, $txn_2$, and $txn_3$ are decomposed into atomic state access operations $O_1$, $O_2$, $O_3$, $O_4$, and $O_5$. 
$txn_1$ is decomposed into $O_1$, $txn_2$ into $O_2$ and $O_3$, and $txn_3$ into $O_4$ and $O_5$. 
% Here, $f_1(A,B)$ denotes $B=B-1$ if $A>2$ and $f_2(A,B)$ denotes $A=A+1$ if $B>2$.
}
% \myc{
% In the stream processing phase, upon arrival, transactions $txn_1$, $txn_2$, and $txn_3$ are decomposed into atomic state access operations $O_1$, $O_2$, $O_3$, $O_4$, and $O_5$. $txn_1$ is decomposed into $O_1 = Write_1(A,f_1(V_1))$, $txn_2$ into $O_2 = Write_2(A,f_2(A,V_2))$ and $O_3 = Write_2(B,f_3(B,A,V_2))$, and $txn_3$ into $O_4 = Write_3(B,f_4(B,V_3))$ and $O_5 = Write_3(A,f_5(A,B,V_3))$. Here, $f_1(A,B)$ denotes $B=B-1$ if $A>2$ and $f_2(A,B)$ denotes $A=A+1$ if $B>2$.
% }
\lds among $O_2, O_3$ and $O_4, O_5$ are identified as they are from the same transaction and are ordered by their statement orders. A preliminary \tpg is constructed by inserting these operations as vertices and the \lds as edges. 
% The operations are then inserted into two sorted lists (one for each state, A and B), and for operations $O_3$ and $O_5$, which have write functions dependent on states $A$ or $B$, virtual operations ($VO_3^{A}$ and $VO_5^{B}$) are inserted into the sorted lists of states $A$ and $B$, respectively.
\myc{
The operations are then inserted into two sorted lists (one for each state, A and B). For operations $O_3$ and $O_5$, which have write functions dependent on states $A$ or $B$, virtual operations ($VO_3^{A}$ and $VO_5^{B}$) are inserted into the sorted lists of states $A$ and $B$, respectively.
}

During the transaction processing phase, \tds can be identified among $O_1, O_2, O_5$ and $O_3, O_4$ by iterating through the operations in each sorted list. \pds are identified between $O_1$ and $VO_3^{A}$, and between $O_3$ and $VO_5^{B}$ according to the previously inserted virtual operations. After the identification of \tds and \pds, they are inserted as edges to refine the preliminary \tpg to become the final \tpg of the current batch of state transactions.

% This process thus successfully manages the dependencies among transactions, even those that arrive out-of-order, and constructs a comprehensive \tpg.

% \curry{In this section, we detail the process of \tpg construction and how dependencies in workloads are tracked.
% }

% \subsection{Planning Overview}
% \label{subsec:construction}

% \myc{
% \system needs to construct a \tpg for every batch of state transactions with low overhead. 
% Upon arrival, transactions are decomposed into atomic state access operations, which are the vertexes of the \tpg, accordingly. 
% \system introduces two main techniques for helping constructing \tpg during the planning stage: \emph{Two-step \tpg construction} and \emph{Virtual Operations}.
% }

% \myc{
% \textbf{Two-step \tpg construction.}
% To address the issue of out-of-order state transactions, \system partitions the \tpg construction process into two steps during the stream processing phase and transaction processing phase, correspondingly. 
% In the stream processing phase, transactions are decomposed into atomic state operations, serving as the vertices of the \tpg.
% Those state operations are ordered following the temporal order of state transactions.
% In the transaction processing phase, three types of dependencies are identified among these state operations to construct \tpg.
% }

% \myc{
% \textbf{Virtual Operations.}
% \label{subsec:virtual}
% To help identify dependencies for an operation with multiple states to access $O_i=Write(k,f(k_1,k_2,...k_n))$, we additionally maintain $n$ \emph{virtual operations} of $O_i$. 
% Each \emph{virtual operation} represents a state access on the specific state, denoted as $VO_i^{k_j}$, $k_j$ $\in$ $k_1,k_2,...k_n$, inserted into $sortedLists$ of $k_1,k_2,...k_n$, correspondingly.
% By maintaining virtual operations, \system can identify dependencies efficiently during the \tpg construction process.
% }


% \subsection{Dependency Tracking for Out-of-Order State Transactions}
% \label{subsec:out-of-order}
% \myc{
% During \tpg construction, \lds can be identified among operations from the same transaction. 
% However, \tds and \pds can not be identified immediately because the arrival of transactions may be out-of-order. 
% \system identifies \lds, \pds, and \tds among out-of-order state transactions based on the two-step \tpg construction and virtual operations as follows:
% }

% \myc{
% \textbf{TPG construction during stream processing phase:} 
% Transactions are decomposed into atomic state access operations.
% \lds are identified among operations from the same transaction according to their statement orders. 
% A \tpg $G$ is constructed by inserting operations as vertexes and \lds as edges, correspondingly. 
% To help identify \tds among operations, which may arrive out-of-order,
% all operations are inserted into key-partitioned $sortedLists$ (i.e., a concurrent skip list~\cite{fraser2004practical}), where the key is the targeting state of each operation and sorted by timestamp.
% To help identify \pds during the next phase, for each write operation $O_i=Write(k,f(k_1,k_2,...k_n))$, we additionally maintain $n$ \emph{virtual operations} of $O_i$. 
% Each \emph{virtual operation} represents a state access on the specific state, denoted as $VO_i^{k_j}$, $k_j$ $\in$ $k_1,k_2,...k_n$, inserted into $sortedLists$ of $k_1,k_2,...k_n$, correspondingly.
% }

% \myc{
% \textbf{TPG construction during transaction processing phase:} 
% During the transaction processing phase, all further state transactions are blocked until \system returns back to the stream processing phase. 
% We can now identify \tds and \pds efficiently with the help of the constructed $sortedList$ and \emph{virtual operations} during the stream processing phase.
% First, \tds can be identified in a straightforward way by iterating through operations inserted into each $sortedList$.
% Note that \emph{virtual operations} are not involved in identifying \tds.
% Second, 
% \pds can be identified according to the inserted \emph{virtual operations}.
% In particular, $O_i$ is parametric dependent on the precedent write operation of the \emph{virtual operation} in the $sortedList$.
% After identifying all \tds and \pds, we insert them as edges to $G$, which captures the complex workload dependencies of the current batch of state transactions. 
% }

% \paragraph{Running Example: Streaming Ledger (SL):}
% We use the SL from our benchmark workloads as a running example. 
% SL represents a real-world stream application suggested by a recent commercial transactional SPE~\cite{Transactions2018}. 
% It processes input events that involve wiring money and assets between accounts. 
% Two types of state transactions accessing the two tables may be generated during the pre-processing of each input event.
% A \emph{Transfer} transaction processes request that transfer balances between user accounts and assets.
% A \emph{Deposit} transaction processes request that top-up user accounts or assets. 
% Figure \ref{fig:TPG} shows an example involving a deposit transaction ($txn_1$) and two transfer transactions ($txn_2$, $txn_3$) arrived consecutively. 

% \myc{
% During the stream processing phase, upon arriving, $txn_1 \sim txn_3$ are immediately decomposed into atomic state access operations $O_1 \sim O_5$.
% $txn_1$ is decomposed into one $O_1 = Write(A,A)$ operation. 
% $txn_2$ is decomposed into $O_2 = Write(A,A)$ and $O_3 = Write(B,f_1(A,B))$. 
% $txn_3$ is decomposed into $O_4 = Write(B,B)$ and $O_5 = Write(A,f_2(A,B))$. 
% $f_i$ is a user-defined-function. We assume $f_1(A,B)$: $B=B-1$ if $A>2$, $f_2(A,B)$: $A=A+1$ if $B>2$.
% As aforementioned, \lds among $O_2, O_3$ and $O_4, O_5$ are identified among operations from the same transaction according to their statement orders.
% A \tpg $G$ is constructed by inserting operations as vertexes and \lds as edges, correspondingly.
% Then, operations are inserted into two $sortedLists$ (e.g., concurrent skip list~\cite{fraser2004practical}), separating by states. 
% Each operation is inserted once based on its target state $A, B$.
% For $O_3$ and $O_5$ whose write function depend on states $A$ or $B$, we further insert a \emph{virtual operation} (denoted as $VO_3^{A}$ and $VO_5^{B}$) into the $sortedList$ of $A$ and $B$, correspondingly.
% }

% \myc{
% During the transaction processing phase,
% \tds can be identified among $O_1, O_2, O_5$ and $O_3, O_4$ by iterating through operations inserted into each $sortedList$.
% \pds can be identified among $O_1$ and $VO_3^{A}$ and among $O_3$ and $VO_5^{B}$ according to the inserted \emph{virtual operations} as discussed earlier.
% Finally, after we identify \td and \pd, we insert them as edges to refine $G$ as the $TPG$ of the current batch of state transactions.
% }

% % Figure environment removed

% % Figure environment removed

\subcompact
\subsection{Dependency Tracking for Window Operations}

% Figure environment removed

Window operations add another layer of complexity to dependency tracking as these operations may operate on a range of states defined by the window size. To manage this complexity, we present a generalized structure of window operations and identify dependencies among these operations by comparing their overlapping windows. In alignment with previous work~\cite{golab2}, a window operation in \system is modeled as a read or write operation, further associated with a time range and a trigger time. 

Dependencies among window operations are determined based on the trigger time and time range, enabling the identification of conflicting read or write operations. This facilitates the construction of \tpg and the scheduling of window operations. Specifically, a window operation is temporally or parametrically dependent on another operation if: 1) it overlaps with another operation in terms of state access, and 2) its window trigger happens after the trigger of another operation, and their window time ranges overlap. The dependency tracking for window operations follows a similar process as for normal operations, identifying dependencies based on the keys accessed and window trigger time. This approach works because two successive operations always share an overlapping window range.

A running example of dependency tracking among window operations is provided in Figure~\ref{fig:windowoperation}. The objective, similar to that in Section~\ref{subsec:nondeterminisitc_dependency}, is to identify dependencies for a new non-deterministic state access operation $O_6$ among five operations in three $sortedLists$ $A, B, C$. Specifically, the operation is a window write operation, tasked to aggregate state access of $C$ within the past 10 seconds and write the results to the target state $A$. Following the dependency tracking mechanism, we insert operation $O_6$ into the $sortedList$ $A$ and a virtual operation $VO_6^{C}$ into the $sortedList$ $C$. Subsequently, we establish a \pd between $O_5$ and $O_6$, and a \td between $O_2$ and $O_6$.


\subcompact
\subsection{Dependency Tracking for Non-deterministic State Operations}
\label{subsec:nondeterminisitc_dependency}

Non-deterministic state operations pose a challenge for dependency tracking as the states these operations access remain undetermined initially. In other words, the key $k$, written by an operation as discussed in Section~\ref{subsubsec:tsp}, can itself be a function. Therefore, the state to read or write depends on the result of the function evaluation. However, a pessimistic assumption can be made that in the worst-case scenario, a non-deterministic state operation could potentially access all states. Consequently, this operation is considered dependent on preceding operations of all states. 

To facilitate this, we introduce virtual operations of a non-deterministic state operation into all possible states during \tpg construction, establishing potential parametric dependencies with other operations. Particularly, \system tracks \pds for non-deterministic state transactions by leveraging virtual operations, following an approach akin to the one described in Section~\ref{subsec:out-of-order}. This approach permits \system to accurately schedule non-deterministic state transactions, albeit at the cost of potential parallel execution opportunities.

An illustrative example showcased in Figure~\ref{fig:nondeterminisitc}, elucidates dependency tracking for non-deterministic state operations. Initially, five atomic state access operations $O_1 \sim O_5$ are placed in three $sortedLists$ $A, B, C$. The objective is to ascertain dependencies for a newly introduced non-deterministic state access operation $O_6$. Specifically, $O_6$ writes a value $v$ to a state determined by a user-defined function $UDF$. By applying the dependency tracking mechanism, we incorporate three \emph{virtual operations} $VO_6^{A}, VO_6^{B}, VO_6^{C}$ into the three $sortedLists$ $A, B, C$. Subsequently, \pds for $O_6$ are identified in each $sortedList$ accordingly.

