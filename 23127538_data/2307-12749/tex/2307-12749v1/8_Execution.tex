\section{Execution: Fine-grained Task Management}
\label{sec:execution}
\system employs sophisticated mechanisms, such as Finite State Machine (FSM) Annotations and Multi-versioning State Table Management, to ensure correct scheduling and efficient execution of operations.

\subcompact
\subsection{Finite State Machine Annotations}

\begin{table}
\centering
\caption{State Definition in the \stpg.}
\label{tab:state}
\resizebox{0.4\textwidth}{!}{%
\begin{tabular}{|p{2.4cm}|p{5cm}|}
\hline
\textbf{State} & \textbf{Definition}               \\ \hline
Blocked (\blk)                   & Operation is not ready to schedule  \\ \hline
Ready (\rdy)                     & Operation is ready to schedule               \\ \hline

Executed (\exe)                  & Operation is successfully processed                     \\ \hline
Aborted (\abt)                   & Operation is aborted  \\ \hline
\end{tabular}%
}
\end{table}

% Figure environment removed

\system uses FSM Annotations to augment the \tpg and form an enhanced \emph{stateful task precedence graph} (\stpg). This augmentation allows \system to continuously monitor state transitions in every vertex of the \stpg, enabling the system to adjust its decisions dynamically based on current workload characteristics and maintain accurate scheduling.


Each vertex in the \stpg can be in one of four states, as summarized in Table~\ref{tab:state}:
(1) \textbf{Blocked (\blk)}, where a vertex is not ready for scheduling due to unresolved dependencies.
(2) \textbf{Ready (\rdy)}, indicating a vertex is ready for scheduling as all its dependencies have been resolved.
(3) \textbf{Executed (\exe)}, denoting a vertex has been successfully processed.
(4) \textbf{Aborted (\abt)}, representing a vertex that has been aborted due to the failed processing of itself or its dependent vertices.

\subcompact
\subsection{Multi-versioning State Table Management}
The \myc{state table management strategy} of \system incorporates multi-versioning in the state table. Each state access operation adds a new version of a record to the state table, which is annotated with a timestamp for identification. This approach allows for precise tracking and accessibility of each operation's impact on the state, offering a comprehensive history of state transitions.

This multi-versioning state table plays a crucial role in managing execution and aborting operations. When an operation transitions to the \exe state, the corresponding state in the state table is updated with a new record. Conversely, when an operation transitions to the \abt state, the subsequent records are removed from the state table.



% \section{Execution: \system's Approach to Task Management}
% \label{sec:execution}
% \system employs a combination of advanced techniques to facilitate the correct scheduling and efficient execution of operations: Finite State Machine (FSM) Annotations and Multi-versioning State Table Management.

% \subsection{Finite State Machine Annotations}
% Finite State Machine Annotations in \system enhance the Task Precedence Graph (TPG), forming a \emph{stateful task precedence graph} (\stpg). By augmenting each vertex of the \tpg with FSM annotations, \system is capable of continuously monitoring state transitions within the \stpg. This ability allows the system to dynamically adjust its decisions based on the current workload characteristics, thereby ensuring accurate scheduling.

% In the \stpg, each vertex can exist in one of four states, as summarized in Table~\ref{tab:state}:
% (1) \textbf{Blocked (\blk)}, signifying a vertex is not ready for scheduling due to unresolved dependencies.
% (2) \textbf{Ready (\rdy)}, indicating a vertex is ready for scheduling as all its dependencies are resolved.
% (3) \textbf{Executed (\exe)}, denoting a vertex has been successfully processed.
% (4) \textbf{Aborted (\abt)}, showing a vertex has been aborted due to failed processing of itself or its dependent vertices.

% \subsection{Effective Handling of Aborts}
% \system efficiently manages aborts, which can occur due to unsatisfied constraints or conflicts among state transactions. Logical dependencies among state access operations are tracked within the \stpg, enabling the immediate resolution of aborts as they are detected. This strategy leads to reduced wasted computation and rollbacks, significantly improving the overall performance of the TSPE.

% \subsection{State Management via Multi-versioning State Table}
% In the context of state management, \system utilizes a multi-versioning approach in its state table. Each state access operation appends a new version of a record in the state table, annotated with a timestamp for identification. This methodology allows for clear tracking and accessibility of each operation's impact on the state, providing a thorough history of state transitions.

% The multi-versioning state table is crucial in handling the execution and aborting of operations. With an operation's transition to the \exe state, the state table is updated with a new record to indicate this change. Conversely, when operation transitions to the \abt state, the records appended subsequently are removed from the state table to reflect this transition.

% Figure~\ref{figures:state} presents two scenarios of state transition, incorporating six cases (\textbf{T1}$\sim$\textbf{T6}). \textbf{T1}$\sim$\textbf{T3} represent transitions during execution, while \textbf{T4}$\sim$\textbf{T6} depict transitions during abort handling. The symbol $*$ is used to indicate transitions from any state.


% \subsection{Normal Execution}
% Figure~\ref{fig:normal} depicts the state transition during normal execution. Operations can be either \textbf{serially scheduled} based on dependencies (\textbf{T1\&T2}) or \textbf{speculatively scheduled} (\textbf{T3}) with unresolved dependencies for enhanced concurrency. The multi-versioning state table management ensures the correctness of state access during the execution of state operations.

% \emph{Serial Schedule}:
% \textbf{T1: (\blk $\rightarrow$ \rdy).}
% When an operation's dependencies in \blk state are all resolved, i.e., all dependent operations are in \exe state, it transitions to \rdy state, becoming available for scheduling.
% \textbf{T2: (\rdy $\rightarrow$ \exe).}
% Operations in \rdy state are scheduled for execution by retrieving the target states from the multi-versioning state table and applying user-defined functions among them. Successful processing of an operation prompts its transition to \exe. Write operations must also write a new version of the state back to the state table.

% \emph{Speculative Schedule}:
% \textbf{T3: (\blk $\rightarrow$ \exe).}
% Operations in \blk state can be speculatively scheduled despite unresolved dependencies to enhance execution concurrency. Specifically, if targeting states are unavailable, the state table management ensures that an operation can wait (for instance, through locks) until its targeting versions of states become available, although this may introduce additional context-switching overhead.

\subcompact
\subsection{Execution Details}

\myc{
Figure~\ref{figures:state} outlines two scenarios of state transition, including six cases (\textbf{T1}$\sim$\textbf{T6}). Transitions \textbf{T1}$\sim$\textbf{T3} occur during execution, while \textbf{T4}$\sim$\textbf{T6} occur during abort handling. 
We introduce the detailed state transition with the associated state table management strategy that enables the correct execution of state transactions in this section.
}
% The symbol $*$ denotes transitions starting from any state.

% Aborts in \system, resulting from unsatisfied constraints or conflicts among state transactions, are efficiently managed. The system tracks logical dependencies among state access operations within the \stpg and resolves aborts as they are detected. This efficient handling of aborts minimizes wasted computation and rollbacks, thereby improving the overall performance.

\subsubsection{Regular Execution}
State transition during regular execution, as depicted in Figure~\ref{fig:normal}, can be categorized into two primary scheduling methods used in \system, namely, Serial and Speculative scheduling. Both techniques are coordinated under the management of \system's multi-versioning state table, which ensures the correctness of state access during the execution of state operations.

In \textbf{Serial Scheduling}, operation transitions from a \blk to \rdy state (\textbf{T1}) when all its dependent operations are in the \exe state, thereby making it ready for scheduling. Once in the \rdy state, the operation is scheduled for execution by retrieving the target states from the multi-versioning state table and applying user-defined functions among them. If successful, this processing leads to the operation's transition to the \exe state (\textbf{T2}).

\textbf{Speculative Scheduling} offers an enhancement to execution concurrency. Specifically, an operation in the \blk state can be speculatively scheduled, despite having unresolved dependencies (\textbf{T3}). If the targeted states are unavailable, the state table management strategy in \system ensures that the operation can wait until its targeted versions of states become available, although this may introduce additional context-switching overhead.

\subsubsection{Abort and Rollback}

% Aborts in \system, resulting from unsatisfied constraints or conflicts among state transactions, are efficiently managed. The system tracks logical dependencies among state access operations within the \stpg and resolves aborts as they are detected. This efficient handling of aborts minimizes wasted computation and rollbacks, thereby improving the overall performance.

The state transition during abort handling is illustrated in Figure~\ref{fig:rollback}.
When the processing of an operation fail or its logically dependent operations transit to \abt, the state of the operation transits to \abt from any state (\textbf{T4}). During this process, \myc{by relying on state table management strategy}, \system clears the state access impact of write operations on the state table, removing all versions of states appended after the states appended by the aborted operations.

Rollbacks, on the other hand, represent a strategic aspect of \system's abort handling. Instead of simply rolling back all affected operations to the \blk state, the system proactively checks whether the operation is ready to execute immediately after rollback, which could mean transitioning from \exe or \blk to \rdy (\textbf{T5}). However, if the dependent operations roll back to \rdy or \blk, the current operation must roll back to \blk due to unresolved dependencies (\textbf{T6}).

% \subsection{Abort handling}
% An overview state transition during abort handling can be shown in Figure~\ref{fig:rollback}.
% \myc{
% When the processing of an operation is failed, the associated transaction has to be aborted (\textbf{T4}) and its state needs to be updated accordingly. 
% Note that, as the aborted operations may be speculatively scheduled with unsolved dependencies, we may need to also rollback (\textbf{T5\&T6}) affected operations from other transactions.
% }

% \emph{Aborting Operations:}
% \textbf{T4: ($* \rightarrow$ \abt).} 
% The state will be transited to \abt from any state when the processing of an operation is failed or its logically dependent operations transit to \abt.
% \myc{
% During aborting operations, \system has to also clear the state access impact of write operations on the state table.
% In particular, it needs to remove all versions of states that are appended after the states appended by aborted operations.
% }

% \emph{Rollback Operations:}
% \textbf{T5: (\exe/\blk $\rightarrow$ \rdy).} 
% Instead of simply rollback all affected operations to \blk state, we can avoid costly re-exploring of the \stpg. Specifically, we \emph{proactively} check whether the operation is ready to execute immediately after rollback, i.e., when dependent operations transit to \abt, the current operation under \exe or \blk will transit to \rdy and execute immediately.
% \textbf{T6: (\exe/\rdy $\rightarrow$ \blk).} 
% When dependent operations rollback to \rdy / \blk, current operation has to rollback to \blk because of unsolved dependencies.
% \myc{
% Similar to T4, the rollback of \exe operations also needs to check and clear the state access impact of write operations on the state table.
% }
% The abort handling is completed when all operations are processed after \abt operations transit to either \rdy or \blk.

% \subsection{Execution of Window Operations}
% \myc{
% By relying on the multi-versioning state table, window operations can be executed by accessing desired versions of states followed by a user-defined aggregation function. 
% With such a window operation, a stream window query (e.g., sliding and tumbling window query) can run by periodically triggering and processing window operations. The triggering period depends on window size and slide size configurations.
% Then, we need to further specify the trigger time and window size of each window operation for periodical execution.
% The window query results can be retrieved after all its window operations are executed.
% For each window operation, we need to further specify the targeting range of states to access and the function to be applied. 
% This is enabled by querying multiple versions of states on the state table.
% }

% \myc{
% To further construct high-level complicated window queries such as sliding window queries,  there are mainly three steps.
% First, declaring the number of window slides to be constructed for the window event based on low-level window operations.
% Second, for each window operation, specifying the window trigger timestamp, subset of state to be accessed, and window size.
% Third, creating a window aggregation function to be applied among the states within the window.
% Furthermore, complicated queries such as a sliding window with a large window size require more careful optimizations such as minimizing redundant computation of overlapping window operations. 
% We implemented the sliding window by considering each window slide as a individual operation to ensure correctness.
% We leave the exploration of efficient sliding window queries during transactional stream processing as future work.
% }

% \subsection{Execution of Non-deterministic State Operations}
% \myc{
% Non-deterministic state operations can be executed using a similar logic to deterministic state operations. However, aborting and rolling back non-deterministic state operations require additional system-level support.
% In particular, \system is responsible for mitigating the impact of non-deterministic state operations on state access. When executing a non-deterministic state operation, we first compute the key corresponding to the current moment. This can be done using a user-defined function (UDF), a random number generator, or a timer, which depends on workload requirements.
% Next, we record the state accessed by the non-deterministic state operations in the \stpg. This recording allows for deterministic rollback in case of transaction aborts. During the state transition triggered by aborting or rolling back, \system removes the associated versions of these records to ensure correctness and consistency.
% }

\subcompact
\subsection{Running Example}
% Figure environment removed

To demonstrate the state transitions of operations in an \stpg, consider an example shown in Figure~\ref{fig:state_transition_example}. This example features three operations - $O_1, O_2, O_3$. Here, $O_1$ and $O_2$ are logically dependent on each other, while $O_3$ is parametrically dependent on $O_2$.

Initially, all operations are in the \blk state. Upon the first round of exploration, $O_1$ and $O_2$ transition to \rdy, as there are no \td and \pd dependencies among them. They can therefore be speculatively executed concurrently. During execution, $O_2$ transitions to \exe before $O_1$, and subsequently, $O_3$ transitions to \rdy. Once $O_1$ and $O_3$ execute and transition to \exe, the execution process based on \stpg is complete.

However, during the execution process, there may be a need for aborting and rolling back operations. For instance, when $O_1$ and $O_3$ are executed concurrently, $O_1$ may abort while $O_3$ successfully executes. Given the \ld between $O_1$ and $O_2$, $O_2$ transitions to \abt, as mandated by the aborting mechanism. Consequently, $O_3$ must rollback from \exe to \rdy due to its \pd edge with $O_2$. Finally, \system initiates a redo from $O_3$, transitioning its state to \exe and marking the completion of the execution based on \stpg.

\subcompact
\subsection{Special Scenarios}

\myc{
We then introduce the execution details of special scenarios, i.e., window and non-deterministic state operations.
}

\subsubsection{Execution of Window Operations}
Window operations are a unique execution scenario facilitated by \system's multi-versioning state table. These operations can access the desired versions of states followed by a user-defined aggregation function. Stream window queries, such as sliding and tumbling window queries, are executed by periodically triggering and processing window operations, with the triggering period depending on window size and slide size configurations. For each window operation, the targeting range of states to access and the function to be applied are specified. This process is facilitated by querying multiple versions of states on the state table.




\subsubsection{Execution of Non-deterministic State Operations}
Non-deterministic state operations also present a distinct execution scenario that necessitates additional system-level support. When executing such an operation, \system computes a key corresponding to the current moment based on workload requirements. The state accessed by non-deterministic state operations is then recorded in the \stpg, which ensures deterministic rollback in case of transaction aborts. During the state transition triggered by aborting or rolling back, \system removes the associated versions of these records to ensure correctness and consistency.



% \subsection{Running Example}

% % Figure environment removed

% \myc{
% We show a running example of state transitions of operations in an \stpg as shown in Figure~\ref{fig:state_transition_example}.
% The example explains state transitions for an \stpg with three operations $O_1, O_2, O_3$, where $O_1$ and $O_2$ are logically dependent with each other and $O_3$ are parametric dependent with $O_2$.
% The example contains both state transition during normal execution and state transition when aborting happens.
% }

% \myc{
% For the state transition in normal execution, initially, all operations are in \blk state.
% After the first round of exploration, the state of $O_1$ and $O_2$ transit to \rdy since there are no \td and \pd dependencies among them, and they can be speculatively executed concurrently.
% During execution, $O_2$ transits to \exe earlier than $O_1$ and $O_3$ transits to \rdy correspondingly.
% Finally, $O_1$ and $O_3$ are executed and transit to \exe, the execution based on \stpg is completed.
% }

% \myc{
% For the state transition when aborting happens, \system has to abort the state transactions and rollback the speculatively executed operations of other state transactions.
% In this example, when $O_1$ and $O_3$ are executed concurrently, $O_1$ may abort while $O_3$ can be executed successfully.
% Since $O_1$ and $O_2$ are logically dependent with each other, $O_2$ transits to \abt following the aborting mechanism.
% Subsequently, $O_3$ has to rollback from \exe to \rdy since it has a \pd edge with $O_2$.
% Finally, \system redo from $O_3$ and transits its state to \exe, and the execution based on \stpg is completed.
% }
