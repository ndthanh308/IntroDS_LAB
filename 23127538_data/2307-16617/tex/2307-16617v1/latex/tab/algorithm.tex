% \begin{algorithm}
%     \renewcommand{\algorithmicrequire}{\textbf{Input}}
% 	\renewcommand{\algorithmicensure}{\textbf{Output}}
%     \caption{Training Procedure of Fuller}
%     \label{alg:fuller}
%     \begin{algorithmic}[1]
%         % \STATE \textbf{Input} input $x_{lid}$ and $x_{img}$, ground-truth $y_{lid}$ and $y_{img}$, backbone $H$, last backbone layer $H_{last}$, fusion layer $H_{fuse}$, task heads $\phi_{lid}$ and $\phi_{img}$, learning rate $\eta$
%         \REQUIRE input $X$, ground-truth $Y$, backbone $H$, backbone's parameter $\theta^H$, task head $\phi$, task head's parameter $\theta^T$, learning rate $\eta$.
%         % \STATE \textbf{Output} backbone $H$, task head $\phi$
%         \ENSURE backbone $H$, task head $\phi$
%         \FOR {\{($x_{lid}$, $x_{img}$), {($y_{seg}$, $y_{det}$})\} in \{$X$,$Y$\}}
%         \STATE inter-gradient calibration for task conflict: \\
%         $\bigtriangledown_{H_{last}}\mathcal{L}_{\rm seg} \leftarrow \frac{\partial \mathcal{L_{\rm seg}}(\phi_{\rm seg}(H(x_{lid},x_{img})),y_{seg})}{\partial H_{last}}$ 
        
%         \STATE $\bigtriangledown_{H_{last}}\mathcal{L}_{\rm det} \leftarrow \frac{\partial \mathcal{L_{\rm det}}(\phi_{\rm det}(H(x_{lid},x_{img})),y_{det})}{\partial H_{last}}$  
        
%         \STATE $\alpha_{\rm seg}$, $\alpha_{\rm det}$ $\leftarrow$ {\rm IMTL}($\bigtriangledown_{H_{last}}\mathcal{L}_{\rm seg}$,$\bigtriangledown_{H_{last}}\mathcal{L}_{\rm det}$) 
%         \STATE $\mathcal{L}\leftarrow \alpha_{\rm seg}\cdot \mathcal{L}_{\rm seg} + \alpha_{\rm det}\cdot \mathcal{L}_{\rm det}$
%         \STATE $\theta^T \leftarrow \theta^T - \eta \cdot \frac{\partial \mathcal{L}}{\partial \theta^T}$
%         \STATE intra-gradient calibration for modality bias \\
%         $G_{lid} \leftarrow \frac{\partial \mathcal{L}}{\partial H_{fuse}}[:,:256,:,:]$
%         \STATE $G_{img} \leftarrow \frac{\partial \mathcal{L}}{\partial H_{fuse}}[:,256:,:,:]$
        
%         \ENDFOR
%     \end{algorithmic}
% \end{algorithm}

\begin{algorithm}[t]
    \renewcommand{\algorithmicrequire}{\textbf{Input}}
	\renewcommand{\algorithmicensure}{\textbf{Output}}
    \caption{Training Procedure of Fuller}
    \label{alg:fuller}
    \begin{algorithmic}[1]
        % \STATE \textbf{Input} input $x_{lid}$ and $x_{img}$, ground-truth $y_{lid}$ and $y_{img}$, backbone $H$, last backbone layer $H_{last}$, fusion layer $H_{fuse}$, task heads $\phi_{lid}$ and $\phi_{img}$, learning rate $\eta$
        \REQUIRE 
        % input $X$, ground-truth $Y$, 
        composition function $\sigma$, 
        %shared backbone $H$, 
        modality branches' parameter $\theta^H$, 
        %task head $K$, 
        intra-gradient layer's parameter $\theta^F$,
        off-the-modality's parameter $\theta^K$, learning rate $\eta$.
        %\xd{as we have too much symbols, pls check whole paper whether each symbol is defined, where implementation details explain all parameters}
        % \STATE \textbf{Output} backbone $H$, task head $\phi$
        \ENSURE $\theta^H$, $\theta^K$
        \FOR { $t=0,1,2,...,T$}
        \STATE Inter-gradient Calibration For Task Conflict: \\ 
        
        %$\leftarrow$ {\rm IMTL}(
        %$\frac{\partial \mathcal{L}_{\rm det}}{\partial{\theta^{H}_{last}}}$,
        %$\frac{\partial \mathcal{L}_{\rm seg}}{\partial{\theta^{H}_{last}}}$)
        
        {\small $\alpha_{\rm Seg}$, $\alpha_{\rm Det}$
        $\leftarrow$ {\rm IMTL}(
        $\nabla_{\texttt{shared\_L}}\mathcal{L}_{\rm{Det}},
        \nabla_{\texttt{shared\_L}}\mathcal{L}_{\rm{Seg}}$)}

        \STATE $\mathcal{L}\leftarrow \alpha_{\rm Seg}\cdot \mathcal{L}_{\rm Seg} + \alpha_{\rm Det}\cdot \mathcal{L}_{\rm Det}$
        \STATE $\theta^K \leftarrow \theta^K - \eta \cdot \frac{\partial \mathcal{L}}{\partial \theta^K}$ \ $\triangleleft$ \ Update task heads
        % \STATE $\theta^F \leftarrow \theta^F - \eta \cdot \frac{\partial \mathcal{L}}{\partial \theta^F}$ \ $\triangleleft$ \ \ Update fusion block 
        \STATE Intra-gradient Calibration for Modality Bias: \\
        % $G^{t}_{lid} \leftarrow \frac{\partial \mathcal{L}}{\partial H_{fuse}}[:,:256,:,:]$
        
        \STATE $\nabla{\theta^{F}_{lid}},  \nabla{\theta^{F}_{img}} \leftarrow \frac{\partial \mathcal{L}}{\partial \theta^{F}_{lid}}, \frac{\partial \mathcal{L}}{\partial \theta^{F}_{img}}$
        
        % \STATE $G^{t}_{img} \leftarrow \frac{\partial \mathcal{L}}{\partial H_{fuse}}[:,256:,:,:]$
        
        \STATE $w^{t}_{lid} \leftarrow \sigma(||\nabla{{\theta^{F}_{lid}}^{t}}||,||\nabla{{\theta^{F}_{img}}^{t}}||)$\\
        $w^{t}_{img} \leftarrow \sigma(||\nabla{{\theta^{F}_{img}}^{t}}||,||\nabla{{\theta^{F}_{lid}}^{t}}||)$
        \STATE $w^{t}_{lid} \leftarrow m\cdot w^{t-1}_{lid} + (1-m)\cdot w^{t}_{lid}$ \\ %$\triangleleft$ momentum update
        $w^{t}_{img} \leftarrow m\cdot w^{t-1}_{img} + (1-m)\cdot w^{t}_{img}$ 
        \STATE $G^{t}_{lid} \leftarrow w^{t}_{lid} \cdot G^{t}_{lid}$
        ; \; $G^{t}_{img} \leftarrow w^{t}_{img} \cdot G^{t}_{img}$
        \STATE backward $G^{t}_{lid}$ and update $\theta^{H}_{lid}$ \; \; $\triangleleft$ LiDAR branch
        \STATE backward $G^{t}_{img}$ and update $\theta^{H}_{img}$ $\triangleleft$ Image branch
        \ENDFOR
    \end{algorithmic}
\end{algorithm}