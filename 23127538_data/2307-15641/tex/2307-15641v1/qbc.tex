\pdfoutput=1
\def\paperversion{acm} % only edit this value to change paper template
% \def\isfinal{} % uncomment this line out to hide all comments

\def\paperversionACM{acm}
\def\paperversionSpringer{springer}
\ifx\paperversion\paperversionACM
\documentclass[acmsmall,nonacm]{acmart}
\settopmatter{printfolios=true, printccs=false, printacmref=false}
\else
\RequirePackage{amsmath}
\documentclass[runningheads]{llncs}
\fi

% This is file is based on sample-acmsmall-conf.tex.
\usepackage[ascii]{inputenc}
\usepackage{amsfonts}
\usepackage{braket,microtype,amsmath,mathtools,graphicx,enumitem,booktabs,bm,xspace,float,mathdots,mleftright}
%%% TODO cannot load amsthm in springer llncs format for some reason.
\ifx\paperversion\paperversionACM
\usepackage{amsthm}
\fi

\ifx\paperversion\papberversionSpringer
\usepackage[final]{hyperref}
\hypersetup{
  breaklinks=true,   % splits links across lines
  colorlinks=true,   % displays links as colored text instead of blocks
  citecolor=red,
}
\fi

\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[english]{babel}
\usepackage[capitalize,nameinlink]{cleveref}
\usepackage{quantikz}
\usepackage[breakable]{tcolorbox}
\usepackage{crossreftools}
\usepackage{thm-restate}

\AtEndPreamble{%
\theoremstyle{acmdefinition}
\newtheorem{remark}[theorem]{Remark}}
% \ifx\paperversion\paperversionACM
% \renewcommand\qedsymbol{$\blacksquare$}
% \fi
\allowdisplaybreaks[4]

%==============================================================================
\numberwithin{equation}{section}
\DeclareMathOperator{\Exp}{Exp}
\DeclareMathOperator{\tr}{tr}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\parens{\lparen}{\rparen}
\DeclarePairedDelimiter\braces{\lbrace}{\rbrace}
\DeclarePairedDelimiter\bracks{\lbrack}{\rbrack}
\DeclarePairedDelimiter\angles{\langle}{\rangle}

\ifx\paperversion\paperversionSpringer
%%% TODO figure out lBrack
\DeclarePairedDelimiter\Bracks{\lbrack\!\lbrack}{\rbrack\!\rbrack}
\else
\DeclarePairedDelimiter\Bracks{\lBrack}{\rBrack}
\fi

\newcommand{\ketbra}[2]{\ket{#1} \!\! \bra{#2}}
\renewcommand{\proj}[1]{\ket{#1} \!\! \bra{#1}}
\newcommand{\ot}{\otimes}
\newcommand{\op}{\oplus}
\newcommand{\eps}{\varepsilon}
\newcommand{\del}{\delta}
\renewcommand{\vec}[1]{\boldsymbol{#1}}
\newcommand{\q}{{\vec{q}}}
\newcommand{\trn}{^\intercal}
\newcommand{\inv}{^{-1}}
\newcommand{\cH}{\mathcal H}
\newcommand{\cE}{\mathcal E}
\newcommand{\cP}{\mathcal P}
\newcommand{\cM}{\mathcal M}
\newcommand{\cG}{\mathcal G}
\newcommand{\cI}{\mathcal I}
\newcommand{\cC}{\mathcal C}
\newcommand{\cS}{\mathcal S}
\newcommand{\cO}{\mathcal O}
\newcommand{\cB}{\mathcal B}
\newcommand{\cF}{\mathcal F}
\newcommand{\R}{\mathbb R}
\newcommand{\C}{\mathbb C}
\newcommand{\Z}{\mathbb Z}
\newcommand{\F}{\mathbb F}
\newcommand{\N}{\mathbb N}
\newcommand{\littlesum}{\mathop{{\textstyle \sum}}}
\newcommand{\littleprod}{\mathop{{\textstyle \prod}}}
\newcommand{\grad}{\nabla}
\newcommand{\half}{\tfrac12}
\newcommand{\bone}{\boldsymbol{1}}
\newcommand{\irange}[2]{\{#1, \ldots, #2\}}
\newcommand{\cPHle}[1][\cH]{\cP_{\leq 1}(#1)}
\newcommand{\dH}[1][\cH]{\mathcal{D}(#1)}
\newcommand{\dHle}[1][\cH]{\mathcal{D}_{\leq 1}(#1)}
\newcommand{\qVars}{\vec{\mathsf{qVars}}}
\newcommand{\hoare}[3]{\braces*{#1} #2 \braces*{#3}}
\newcommand{\hoareb}[3]{\framebox{$\braces*{#1} #2 \braces*{#3}$}}
\newcommand{\parcorr}{\models_\text{par}}
\newcommand{\totcorr}{\models_\text{tot}}
% \newcommand{\satisfies}[2]{\Exp\parens*{#1 \models #2}}
\newcommand{\satisfies}[2]{\mathbb{E}_{#1}\parens*{#2}}
\newcommand{\imp}{\Rightarrow}

%%% qwhile syntax
\colorlet{qpbgcol}{gray!15}
% gray box to bg-color programs
\newtcbox{\qpouterbox}{on line,
  breakable,
  colback=qpbgcol,
  colframe=qpbgcol,
  size=fbox,
  arc=2pt,
  boxsep=1pt,
  left=1pt,right=1pt,top=0pt,bottom=0pt,
}
% white inner box to "escape" abstract program terms
\newtcbox{\qpinnerbox}{on line,
  enforce breakable,
  colback=white,
  colframe=white,
  size=fbox,
  arc=1pt,
  boxsep=1pt,
  left=0pt,right=0pt,top=0pt,bottom=0pt
}
\newcommand{\qpenv}[1]{\qpouterbox{$#1$}}
\newcommand{\qpabsprog}[1]{\qpinnerbox{$#1$}}
% \renewcommand{\qpenv}[1]{#1} %%% uncomment this to disable bg-color for qwhile code
\newcommand{\qpabort}{\textbf{abort}}
\newcommand{\qpskip}{\textbf{skip}}
\newcommand{\qpinit}[1]{#1 := \ket{\vec 0}}
\newcommand{\qpinitS}[1]{#1 := \ket{0}}
\newcommand{\qpunitary}[2]{#1 := #2(#1)}
\newcommand{\qprepeat}[2]{\textbf{repeat } #1 \textbf{ do } #2 \textbf{ end}}
\newcommand{\qpselect}[3]{\textbf{case meas } #2 \textbf{ with } #1 \textbf{ of } #3 \textbf{ end}}
\newcommand{\qpwhile}[4][]{\textbf{while}#1 \textbf{ meas } #3 \textbf{ with } #2 \textbf{ do } #4 \textbf{ end}}
\newcommand{\qphole}[2]{\braces{#1}\square \braces{#2}}

%%% syntax sugar
\newcommand{\qpifte}[4]{\textbf{if meas } #2 \textbf{ with } #1 \textbf{ then } #3 \textbf{ else } #4 \textbf{ end}}
\newcommand{\qpif}[3]{\textbf{if meas } #2 \textbf{ with } #1 \textbf{ then } #3 \textbf{ end}}
% basis measurement
\newcommand{\qpifteB}[3]{\textbf{if meas } #1 \textbf{ then } #2 \textbf{ else } #3 \textbf{ end}}
\newcommand{\qpifB}[2]{\textbf{if meas } #1 \textbf{ then } #2 \textbf{ end}}
\newcommand{\qpwhileB}[2]{\textbf{while meas } #1 \textbf{ do } #2 \textbf{ end}}
\newcommand{\qpselectS}[2]{\textbf{case meas } #1 \textbf{ of } #2 \textbf{ end}}

%%% refinement
\newcommand{\refine}{\hookrightarrow}
\newcommand{\parref}{\refine_\mathrm{par}}
\newcommand{\totref}{\refine_\mathrm{tot}}
\newcommand{\ruleitem}[1]{\item[{(\crtcrossreflabel{#1}[rule:#1])}]} % usage \ruleitem{A.BC} => \item[(A.BC)]\label{rule:A.BC}
\newcommand{\ruleref}[1]{\hyperref[rule:#1]{(#1)}}
\newcommand{\ruletag}[2][]{\tag{\ref{rule:#2} #1}} % usage \ruletag{H.init} or \ruletag[side-condition-name]{H.init}

\newenvironment{proofcase}{\smallskip}{}

%%% https://tex.stackexchange.com/questions/151562/environment-definition-gives-an-error
\makeatletter
\newenvironment{inferencelist}%
{\begingroup\addtolength{\jot}{1em}\start@align\@ne\st@rredtrue\m@ne}
{\endalign\endgroup}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \makeatletter
% \font\uwavefont=lasyb10 scaled 652
% \newcommand\colorwave[1][blue]{\bgroup\markoverwith{\lower3\p@\hbox{\uwavefont\textcolor{#1}{\char58}}}\ULon}
% \makeatother
% \ifcsname isfinal\endcsname
% \newcommand\createtodoauthor[2]{
%   \def\tmpdefault{emptystring}
%   \expandafter\newcommand\csname #1\endcsname[2][\tmpdefault]{}
%   \expandafter\newcommand\csname #1m\endcsname[2][\tmpdefault]{}
%   \expandafter\newcommand\csname #1f\endcsname[2][\tmpdefault]{}
% }
% \else
% \newcommand\createtodoauthor[2]{%
%   \def\tmpdefault{emptystring}
%   % inline comment: use \<name>{}
%   \expandafter\newcommand\csname #1\endcsname[2][\tmpdefault]{%
%     \def\tmp{##1}
%       \ifthenelse {\equal{\tmp}{\tmpdefault}}
%         {{\color{#2}\textbf{#1:} ##2}}
%         {\ifthenelse {\equal{##2}{}}
%           {\colorwave[#2]{##1}\xspace}
%           {{\color{#2}\textbf{#1:} ##2}\colorwave[#2]{##1}}}
%         }
%   % margin comment: use \<name>m{...}
%   \expandafter\newcommand\csname #1m\endcsname[2][\tmpdefault]{%
%     \def\tmp{##1}
%       \ifthenelse {\equal{\tmp}{\tmpdefault}}
%         {\todo[linecolor=#2,backgroundcolor=#2,bordercolor=#2]}%
%         {\ifthenelse {\equal{##2}{}}
%           {\colorwave[#2]{##1}\xspace}
%           {\todo[linecolor=#2,backgroundcolor=#2,bordercolor=#2]{\textbf{#1:} ##2}\colorwave[#2]{##1}}}
%         }
%   % figure comment: use \<name>f{...}
%   \expandafter\newcommand\csname #1f\endcsname[2][\tmpdefault]{
%     \smash{\marginnote{
%       \todo[inline,linecolor=#2,backgroundcolor=#2,bordercolor=#2]{\textbf{#1:} ##2}}
%     }}
% }
% \fi
%
% \definecolor{pairedNegTwoDarkGray}{HTML}{827b7b}
% \definecolor{pairedOneLightBlue}{HTML}{a6cee3}
% \definecolor{pairedTwoDarkBlue}{HTML}{1f78b4}
% \definecolor{pairedThreeLightGreen}{HTML}{b2df8a}
% \definecolor{pairedFourDarkGreen}{HTML}{33a02c}
% \definecolor{pairedFiveLightRed}{HTML}{fb9a99}
% \definecolor{pairedSixDarkRed}{HTML}{e31a1c}
% \createtodoauthor{author}{pairedOneLightBlue}
% \createtodoauthor{AP}{pairedSixDarkRed} %pairedTwoDarkBlue}
% \createtodoauthor{authorthree}{pairedThreeLightGreen}
% \createtodoauthor{IS}{pairedFourDarkGreen}
% \createtodoauthor{MW}{pairedSixDarkRed}
% \newcommand{\edit}[1]{{\color{red}#1}}

%=============================================================================
\AtBeginDocument{\providecommand\BibTeX{{Bib\TeX}}}

\ifx\paperversion\paperversionACM
\setcopyright{acmcopyright}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{XXXXXXX.XXXXXXX}
% \acmConference[Conference acronym 'XX]{Make sure to enter the correct conference title from your rights confirmation emai}{June 03--05, 2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}
\fi

\begin{document}

%=============================================================================
% \title{QbC: Quantum programs that are correct by Construction}
\title{QbC: Quantum Correctness by Construction}
\newcommand{\theshortauthors}{Peduri, Schaefer, and Walter}

\ifx\paperversion\paperversionACM

\author{Anurudh Peduri}
\email{anurudh.peduri@rub.de}
\affiliation{%
  \institution{Chair for Quantum Information, Faculty of Computer Science, Ruhr~University~Bochum}
  \city{Bochum}
  \country{Germany}
}
\author{Ina Schaefer}
\email{ina.schaefer@kit.edu}
\affiliation{%
  \institution{Chair of Testing, Validation and Analysis of Software-Intensive Systems (TVA), Institute for Information Security and Dependability (KASTEL), Karlsruhe Institute of Technology}
  \city{Karlsruhe}
  \country{Germany}
}
\affiliation{%
  \institution{School of Data Science \& Computational Thinking, Stellenbosch University}
  \city{Stellenbosch}
  \country{South Africa}
}
\author{Michael Walter}
\email{michael.walter@rub.de}
\affiliation{%
  \institution{Chair for Quantum Information, Faculty of Computer Science, Ruhr~University~Bochum}
  \city{Bochum}
  \country{Germany}
}
\renewcommand{\shortauthors}{\theshortauthors}

\else
\ifx\paperversion\paperversionSpringer

\author{Anurudh Peduri\inst{1}
\and
Ina Schaefer\inst{2,3}
\and
Michael Walter\inst{1}}
\authorrunning{\theshortauthors}
\institute{
  Chair for Quantum Information,
  Faculty of Computer Science,
  Ruhr~University~Bochum, Bochum, Germany
  \and
  Chair of Testing, Validation and Analysis of Software-Intensive Systems (TVA),
  Institute for Information Security and Dependability (KASTEL),
  Karlsruhe Institute of Technology, Karlsruhe, Germany
  \and
  School of Data Science \& Computational Thinking,
  Stellenbosch University, South Africa
}

\fi
\fi

%=============================================================================
\newcommand{\theabstract}{%
Thanks to the rapid progress and growing complexity of quantum algorithms, correctness of quantum programs has become a major concern.
Pioneering research over the past years has proposed various approaches to formally verify quantum programs using proof systems such as quantum Hoare logic.
All these prior approaches are post-hoc: one first implements a complete program and only then verifies its correctness.
In this work, we propose \emph{Quantum Correctness by Construction (QbC)}: an approach to constructing quantum programs from their specification in a way that ensures correctness.
We use pre- and postconditions to specify program properties,
and propose a set of refinement rules to construct correct programs in a quantum while language.
We validate QbC by constructing quantum programs for two idiomatic problems, teleportation and search, from their specification.
We find that the approach naturally suggests how to derive program details, highlighting key design choices along the way.
As such, we believe that QbC can play an important role in supporting the design and taxonomization of quantum algorithms and software.}
\newcommand{\thekeywords}{quantum Hoare logic, correctness by construction, quantum while language}
%=============================================================================


\ifx\paperversion\paperversionACM
\begin{abstract}
\theabstract
\end{abstract}
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003790.10002990</concept_id>
       <concept_desc>Theory of computation~Logic and verification</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10011741</concept_id>
       <concept_desc>Theory of computation~Hoare logic</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003753.10003758</concept_id>
       <concept_desc>Theory of computation~Quantum computation theory</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Logic and verification}
\ccsdesc[500]{Theory of computation~Hoare logic}
\ccsdesc[500]{Theory of computation~Quantum computation theory}

\keywords{\thekeywords}
% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}
\fi

%=============================================================================
\maketitle
%=============================================================================

\ifx\paperversion\paperversionSpringer
\begin{abstract}
\theabstract

\keywords{\thekeywords}
\end{abstract}
\fi

%=============================================================================
\section{Introduction}
\label{sec:intro}
%=============================================================================
The field of quantum computing has seen tremendous progress over the past few decades.
There are a variety of quantum algorithms for a broad range of computational problems, including for combinatorial search and optimization~\cite{grover1996,brassard2002quantum,ambainis2004quantum,apers2022no}, factoring and other algebraic problems~\cite{shor1994}, and linear algebra~\cite{hhl2009,gilyenquantum2019,van2021quantum} --
supported by algorithmic frameworks such as quantum walks~\cite{qwalks2003} and the quantum singular value transform~\cite{gilyenquantum2019,granduni2021},
as well as by novel quantum data structures~\cite{qram,tower2022}.
\Citet{montanaro_quantum_2016} provides an overview of various quantum algorithms.
To support these developments and the construction of larger quantum programs, \citet{selinger_2004} first proposed a design for a quantum programming language.
Since then, there have been numerous quantum programming languages at various levels of abstraction (see, e.g.,~\cite{qml2005,quipper2013,Steiger2018projectq,qsharp2018,silq2022,qunity2023} and references therein).

Correctness of algorithms has always been a major concern in computing.
In the past decades, there has been intensive work on program analysis, testing and verification of programs and software.
For classical computing, \citet{hoare1969hoare} introduced a formal system to specify program properties and prove correctness.
In this system, for a program~$S$, one specifies its properties by using a precondition~$P$ and a postcondition~$Q$, resulting in a \emph{Hoare triple} denoted as $\hoare{P}{S}{Q}$.
A Hoare triple is said to be correct if running the program S starting in any state satisfying the precondition results in a state that satisfies the postcondition.
Hoare logic has been extended to probabilistic programs~\cite{probabilisticCBC2020,Morgan1998pGCLFR}, where the conditions are probabilistic, and one checks correctness by computing expectations of the properties.
A detailed review of the progress in Hoare logic can be found in~\cite{apt_fifty_2019}.
Another approach to verifying programs is using Incorrectness Logic~\cite{incorrectnesslogic2019}, which attempts to find bugs in programs
by finding counterexamples.
Quantum computing poses unique challenges for formal verification that are not encountered in classical computing due to the nature of its computational model.
Pioneering research over the past years has uncovered how to adapt the above-mentioned approaches to the quantum setting.
This has given rise to, e.g., quantum Hoare logic~\cite{ying2012quantum} and quantum incorrectness logic~\cite{peng2022_quantum_incorrectness_logic}.
We survey key developments in quantum verification in \cref{sec:related-work}.

Still, all prior approaches to verifying quantum programs are \emph{post-hoc}:
they take the completed program as a starting point and establish whether the program meets the specification.
If post-hoc verification fails, there is often no indication of what needs to be fixed in the program.
% It could be that the program is indeed incorrect and does not satisfy its specification, or that the specification is just not the desired one.
Especially in the quantum setting, predicates specifying program properties are represented by large matrices, which makes it difficult to reason about, locate, and fix issues with quantum programs with a post-hoc approach.
In contrast, \emph{Correctness-by-Construction (CbC)}~\cite{10.5555/550359,kourie_correctness-by-construction_2012} is a programming methodology to incrementally build correct programs based on a specification.
For classical computing, CbC provides a method where one starts with a concise specification that the program to be developed should satisfy and then uses a small set of refinement rules to incrementally construct the program in such a way that at the end of the construction process, the program provably satisfies the specification, i.e., it is correct by construction.
This approach can help build well-structured and concise programs and draw insights from the corresponding specification, supporting algorithm designers in developing intuition and allowing them to focus on central design aspects of the constructed algorithms.
CbC enables the taxonomization of algorithmic families and supports inventive algorithmics~\cite{DBLP:conf/isola/CleophasKPSW16}, which is urgently needed to design novel quantum algorithms.
\Citet{runge2020comparecorc} provide a detailed comparison between CbC and post-hoc verification techniques.
We review relevant literature on CbC in \cref{sec:related-work}.
To the best of our knowledge, the Correctness-by-Construction approach has not been applied to construct and verify quantum programs.

%-----------------------------------------------------------------------------
\paragraph{Our contributions}
%-----------------------------------------------------------------------------
In this work, we propose \emph{Quantum Correctness by Construction (QbC)}, an approach to constructing quantum programs from their specification in a way that ensures correctness.
To this end, we consider a simple quantum programming language, the \emph{quantum while language}, and extend it with a new construct called a \emph{hole}, which represents a yet-to-be-constructed program.
Holes take the form $\qpenv{\qphole{P}{Q}}$, where~$P$ and~$Q$ represent the pre- and postconditions that should be satisfied by the program, as in quantum Hoare logic~\cite{ying2012quantum}.
For example, the specification for the paradigmatic problem of \emph{searching} a ``database''~$f\colon\{0,1\}^n\to\{0,1\}$ with success probability~$p$, as famously solved by Grover's algorithm~\cite{grover1996}, can be succinctly expressed as
\[ \qpenv{\qphole{pI}{\sum_{x ~\text{s.t.}~ f(x) = 1} \proj{x}}}. \]
This states that measuring the program's output results in a solution, i.e., an~$x$ such that~$f(x) = 1$, with probability~$p$.
We discuss this example in detail in~\cref{subsec:examples:qsearch}.

For the above language, we then provide \emph{refinement rules}, which allow filling in holes in quantum programs in such a way that correctness is preserved.
These rules take the following form:
\[ \qpenv{\qphole{P}{Q}} \refine S \quad\quad\quad \text{if certain conditions $C_1, C_2, \ldots$ hold} \]
To apply such a rule, one first checks that the conditions~$C_1, C_2, \dots$ are satisfied and then replaces the left-hand side hole with the right-hand side program~$S$ (which may itself contain other holes).
For example, we can always apply the \emph{sequence rule}, $\qpenv{\qphole{P}{Q}} \refine \qpenv{\qphole{P}{R} ; \qphole{R}{Q}}$;
intuitively, this rule states that in order to construct a program that takes precondition~$P$ to postcondition~$Q$, it suffices to construct a program that takes the precondition to some intermediate condition~$R$, and another one that takes this intermediate condition to the postcondition.
Starting from an initial specification~$\qpenv{\qphole{P}{Q}}$, one iteratively applies refinement rules until one arrives at a program $S_\text{final}$ that contains no more holes.
We prove a \emph{soundness theorem} that states that any program obtained by this process of refinement is guaranteed to satisfy the initial specification, that is, the quantum Hoare triple~$\hoare{P}{S_\text{final}}{Q}$ is valid and the program is correct by construction.
To prove this, we % consider the refinement rules as a relation on programs and
use induction on the length of the sequence of refinement steps that are applied.
We note that our formalization in terms of refining \emph{programs with holes} applies beyond quantum verification and as such can also offer a new perspective of correctness-by-construction more generally.

Finally, we validate our approach by constructing several quantum programs, including programs for two idiomatic problems: \emph{quantum teleportation} and \emph{quantum search}.
In each case, we start from their intuitive specification and use one key algorithmic idea or refinement step at a time.
We find that the refinement rules not only guide the construction of the desired programs, but that the QbC approach also reveals design choices that can be made along the way.
For example, when constructing a program for the quantum search problem, we show how one can naturally arrive at both a naive algorithm that proceeds by random sampling, as well as Grover's celebrated search algorithm that offers a quantum speedup.

To summarize, in this work, we:
\begin{enumerate}
\item Introduce a Quantum Correctness by Construction (QbC) approach for quantum programs.
In QbC, quantum programs are constructed starting from specifications by successively applying refinement rules.
This is in contrast to prior work in quantum verification, which has largely focused on post-hoc approaches.
\item In doing so, provide a new formalization for correctness by construction in general, based on programs with \emph{holes}, which specify pre- and postconditions of subprograms that still need to be constructed.
We believe that this formalization more directly captures the spirit of correctness-by-construction than previous ones and hence may be of independent interest.

\item Prove that our refinement rules are sound: Any program constructed from an initial specification by using the refinement rules must satisfy the specification.
% (in the sense of quantum Hoare logic).

\item Validate QbC by constructing quantum programs for idiomatic problems, starting from their specification.
Our findings suggest that QbC can play an important role in supporting the design and taxonomization of quantum algorithms and software.
\end{enumerate}

%-----------------------------------------------------------------------------
\paragraph{Organization of the paper}
%-----------------------------------------------------------------------------
In \cref{sec:prelims}, we review the basic quantum formalism that is used in the paper.
We introduce the \emph{quantum while language}, a simple quantum programming language with control-flow and loops, as well as \emph{quantum Hoare logic}, which defines notions of correctness of quantum programs in terms of pre- and postconditions.
In \cref{sec:qbc}, we introduce \emph{Quantum Correctness by Construction (QbC)}.
We first define an extension of the quantum while language, called \emph{programs with holes}, which allows specifying subprograms that still need to be constructed.
Then we define refinement rules that can be used to construct quantum programs from given specifications, and we prove soundness of these rules.
In \cref{sec:examples}, we use the QbC approach to naturally construct several quantum programs starting from their specification.
We survey relevant related work in \cref{sec:related-work} and conclude in \cref{sec:conclusion}.
\Cref{app:total soundness} contains the technical proof of a result announced in the main text.


%=============================================================================
\section{Preliminaries}
\label{sec:prelims}
%=============================================================================
In this section, after collecting some notation and conventions (\cref{subsec:notation}), we provide a brief introduction to the formalism of quantum computing~(\cref{subsec:quantum}).
Then we describe the syntax and semantics of a simple quantum programming language~(\cref{subsec:qwhile}) as well as quantum Hoare logic~(\cref{subsec:quantum-hoare-logic}).

%-----------------------------------------------------------------------------
\subsection{Notation and Conventions}
\label{subsec:notation}
%-----------------------------------------------------------------------------
We fix some notation and conventions that are used throughout the paper.
% Hilbert space
A finite-dimensional Hilbert space~$\mathcal H$ is a finite-dimensional complex vector space with inner product.
% Kets and Bras
We write~$\ket\psi \in \mathcal H$ for vectors, $\bra\phi$ for covectors, and~$\braket{\phi|\psi}$ for the inner product.
In general, $M^\dagger$ denotes the adjoint of a linear operator~$M$.
% I and Trace
The identity operator on a Hilbert space~$\cH$ is denoted by~$I_\cH$ and can be written as $I_\cH = \sum_x \proj x$ for any orthonormal basis $\{ \ket x \}$ of~$\cH$.
We usually write~$I$ when the Hilbert space is clear from the context.
The \emph{trace} of an operator~$M$ is given by~$\tr M = \sum_x \braket{x|M|x}$ for any orthonormal basis~$\{\ket x\}$ of $\cH$.
% Unitary
An operator~$U$ is called a \emph{unitary} if~$U U^\dagger = U^\dagger U = I$.
% PSD
An operator~$M$ on~$\cH$ is \emph{Hermitian} if $\braket{\psi|M|\psi} \in \R$ for all vectors~$\ket\psi\in\cH$, and \emph{positive-semi\-definite~(PSD)} if~$\braket{\psi|M|\psi} \ge 0$ for all vectors~$\ket\psi \in \cH$.
Equivalently,~$M$ can be diagonalized by a unitary matrix and has real resp.\ nonnegative eigenvalues.
Any PSD operator~$M$ has a unique PSD \emph{square-root}, denoted by~$\sqrt M$.
Given two operators~$A$ and~$B$ on~$\cH$, we write $A \preceq B$ if and only if~$B - A$ is PSD;
this defines the \emph{L\"owner order}.
% Projector
A Hermitian operator~$P$ is called a \emph{projection} (or \emph{projector}) if~$P^2 = P$.
% Superops
A linear function~$\cE$ mapping operators on one Hilbert space to operators on another is called a \emph{superoperator}.
% Trace
It is called \emph{trace preserving} if~$\tr M = \tr \cE(M)$ for every operator~$M$,
and \emph{trace non-increasing} if~$\tr M \ge \tr \cE(M)$ for every~$M$.
% CP
A superoperator $\cE$ on $\cH$ is called \emph{positive} if~$\cE(M)$ is PSD for every PSD~$M$,
and \emph{completely positive} if the superoperator~$\cE \ot \cI_{\cH'}$ is positive for every Hilbert space~$\cH'$ (where~$\cI_{\cH'}$ is the identity superoperator).
We denote by~$\cE^\dagger$ the adjoint of a superoperator with respect to the Hilbert-Schmidt inner product, which is completely positive iff~$\cE$ is completely positive.
It is easy to see that~$\cE$ is trace preserving iff its adjoint is \emph{unital}, that is,~$\cE^\dagger(I) = I$, and trace non-increasing if the adjoint is \emph{sub-unital}, that is, $\cE^\dagger(I) \preceq I$.

%-----------------------------------------------------------------------------
\subsection{Quantum Computing}
\label{subsec:quantum}
%-----------------------------------------------------------------------------
We now recall the basic formalism of quantum computing.
We refer to the excellent textbooks~\citet{nielsen2010quantum,wilde2013quantum} for more comprehensive introductions.

%-----------------------------------------------------------------------------
\paragraph{Variables}
A \emph{quantum variable} (or \emph{quantum register})~$q$ is modeled by a Hilbert space~$\cH_q = \C^{\Sigma_q}$ for some finite index set~$\Sigma_q$.
This means that $\cH_q$ is a vector space equipped with an inner product and an orthonormal \emph{standard basis} (or \emph{computational basis})~$\ket x$, labeled by the elements~$x\in \Sigma_q$.
When~$\Sigma_q = \{0,1\}$, then~$\cH_q = \C^2$ and~$q$ is called a \emph{qubit}.
If~$\vec{q}$ is a collection of quantum variables, then the corresponding Hilbert space is $\cH_{\vec q} = \bigotimes_{q \in \vec q} \cH_q \cong \C^{\Sigma_{\vec q}}$, where~$\Sigma_{\vec q} = \prod_{q \in \vec q} \Sigma_q$ labels the standard (product) basis of the quantum variables~$\vec q$.
We assume that there is a finite set of quantum variables, denoted by $\qVars$.
Then the overall Hilbert space is
\begin{align*}
  \cH = \cH_{\qVars} = \bigotimes_{q\in\qVars} \cH_q \cong \bigotimes_{q\in\qVars} \C^{\Sigma_q} = \C^\Sigma,
\end{align*}
where $\Sigma = \Sigma_{\qVars} = \prod_{q \in \qVars} \Sigma_q$ labels the standard basis of the all quantum variables.
It is well understood how to extend the above to infinite-dimensional Hilbert spaces and an infinite number of quantum variables, but we will not need this here.

%-----------------------------------------------------------------------------
\paragraph{States}
The \emph{state} of all the quantum variables is described by a positive semidefinite (PSD) operator on~$\cH$ having trace equal to $1$, often called a \emph{density operator}.
We denote the set of all such operators by~$\dH$.
A state is called \emph{pure} if it is given by a rank-one projection, i.e., if~$\rho=\proj\Psi$ for some unit vector~$\Psi\in\cH$.
States that are not pure are called \emph{mixed}.
More generally, we consider \emph{partial states}, also known as \emph{subnormalized states}, which are positive semidefinite operators of trace at most one, denoted by $\dHle$.
Partial states are akin to sub-probability measures in probabilistic computing.
They are useful for reasoning about quantum programs that may terminate with probability less than one.

%-----------------------------------------------------------------------------
\paragraph{Operations}
There are two basic kinds of operations.
The first is to apply a \emph{unitary}.
If we apply a unitary~$U$ on~$\cH$ to a (partial) state~$\rho$, the result is $U \rho U^\dagger$, which is again a (partial) state.

The second is to measure the quantum state.
A \emph{measurement} (also called a \emph{positive operator-valued measure} or \emph{POVM}) is given by a family of positive semidefinite operators~$\vec M = \{M_\omega\}_{\omega\in\Omega}$,
labeled by some finite index set~$\Omega$, such that~$\sum_{\omega\in\Omega} M_\omega = I$.
If one measures a (partial) state~$\rho$ then the probability of seeing outcome~$\omega\in\Omega$ is~$q_\omega = \tr(\rho M_\omega)$,
in which case the state changes to~$\rho_\omega = \sqrt{M_\omega} \rho \sqrt{M_\omega} / q_\omega$.
We abbreviate $\cM_\omega(\rho) = \sqrt{M_\omega} \rho \sqrt{M_\omega}$.
Note that this is a partial state, with trace equal to the probability of outcome~$\omega$.

When $\Omega = \{0,1\}$, there are only two possible outcomes, and this is called a \emph{binary measurement}.
Any binary measurement~ $\{B_0, B_1\}$ can be obtained by picking a positive semidefinite operator~$B$ with~$B \preceq I$ and setting~$B_0 = I - B$ and~$B_1 = B$.
As above, we abbreviate~$\cB_0(\rho) = \sqrt{I-B}\rho\sqrt{I-B}$ and~$\cB_1(\rho) = \sqrt{B} \rho \sqrt{B}$.
For example, for a qubit, $B = \proj1$ defines the standard basis measurement, with $B_0=\proj0$ and $B_1=\proj1$.
In the rest of the paper, we will refer to~$B$ rather than~$\{B_0,B_1\}$ as a binary measurement unless specified otherwise.

We can also apply any of the above operations to a subset~$\vec{q} \subseteq \qVars$ of the quantum variables.
To this end, let us, for an arbitrary operator~$A$ on~$\cH_{\vec q}$, define the operator~$A_{\vec q} = A \ot I$ on~$\cH$, where the tensor product is with respect to the decomposition~$\cH = \cH_{\vec q} \ot \cH_{\vec q^c}$ and $\vec{q}^c = \qVars \setminus \vec{q}$ denotes the remaining quantum variables.
In prior work, this has been called \emph{cylindrical extension}~\cite{coqq2023}.
Then, if~$U$ is a unitary on~$\cH_{\vec q}$, we can apply it to the quantum variables~$\vec{q}$ by taking~$U_{\vec q}$ in the above prescription.
Similarly, if~$\{M_\omega\}_{\omega\in\Omega}$ is a measurement on $\cH_{\vec q}$, we take $\{ M_{\omega,\vec q} \}$ in the above prescription; we also abbreviate~$\cM_{\omega,\vec q}(\rho) = \sqrt{M_{\omega,\vec q}} \rho \sqrt{M_{\omega,\vec q}}$.


%-----------------------------------------------------------------------------
\subsection{Quantum While Language}
\label{subsec:qwhile}
%-----------------------------------------------------------------------------

In this paper, we consider a \emph{quantum while language}~\cite{ying2012quantum,coqq2023,feng2021quantum}.
We first introduce its syntax and then discuss its denotational semantics.
The language supports initializing quantum registers, applying unitary operations, and classical control flow based on quantum measurement outcomes.

%-----------------------------------------------------------------------------
\paragraph{Syntax}
We first describe the language's syntax.

\newcommand{\qwhilesyntax}{\ensuremath{
S~::=~
    &\;\; \qpskip~
    |\; \qpinit{\vec q} ~
    |\; \qpunitary{\vec{q}}{U} ~
    |\; S_1 ; S_2
    |\; \qprepeat{N}{S} ~\\
    &|\; \qpselect{\{\omega_1 \colon M_{\omega_1}, \omega_2 \colon M_{\omega_2}, \ldots\}}{\vec{q}}{\omega_1 \colon S_{\omega_1}, \ \omega_2 \colon S_{\omega_2}, \ \ldots}~\\
    &|\; \qpwhile{B}{\vec{q}}{S} ~
}}
\begin{definition}[Syntax]
\label{def:qwhile-syntax}
Quantum while programs are given by the following grammar:
\begin{align*} \qwhilesyntax \end{align*}
where $S, S_1, S_2, S_{\omega}$ denote programs in the language;
$\vec{q}$ denotes a set of quantum variables;
$U$ is a unitary operator on~$\cH_{\vec{q}}$;
$N$ is a natural number;
$\{M_{\omega}\}_{\omega\in\Omega}$ is a measurement on~$\cH_{\vec{q}}$ with outcomes in some set $\Omega = \{\omega_1, \omega_2, \ldots\}$;
$B$ is an operator defining a binary measurement~$\{I-B, B\}$.
\end{definition}
%
The first five instructions are self-explanatory:
$\qpenv{\textbf{skip}}$ is a no-op;
$\qpenv{\qpinit{\vec q}}$ initializes the register $\vec q$;
$\qpenv{\qpunitary{\vec q}{U}}$ applies a unitary $U$ to the register $\vec q$;
$\qpenv{\qpabsprog{S_1}~; \qpabsprog{S_2}}$ sequentially composes the two programs, running ${S_1}$ followed by ${S_2}$;
and $\qpenv{\qprepeat{N}{\qpabsprog{S}}}$ runs the program $S$ $N$ times.
%
The \textbf{case} statement is used for control flow: it measures the register $\vec q$ with the measurement $\vec M$, and on seeing outcome $\omega$ runs the program ${S_\omega}$.
The \textbf{while} statement measures the register $\vec q$ with a binary measurement $B$ and, if it succeeds, runs the loop body~${S}$ and repeats.
Thus, both \textbf{case} and \textbf{while} are classical control flow based on the outcome of a quantum measurement.

%-----------------------------------------------------------------------------
% \paragraph{Syntactic sugar}
We also introduce some syntactic sugar for convenience.
First, we define an \textbf{if} statement as a shorthand for a \textbf{case} statement with a binary measurement:
\begin{gather*}
\qpenv{\qpifte{B}{\vec q}{\qpabsprog{S_1}}{\qpabsprog{S_0}}} \\
\;\equiv\;
\qpenv{\qpselect{\{0\colon I-B, 1\colon B\}}{\vec q}{0 \colon \qpabsprog{S_0},\ 1 \colon \qpabsprog{S_1}}}
\end{gather*}
We allow leaving out the \textbf{else} branch, in which case we take $S_0 = \qpenv{\qpskip}$.
We also define the following shorthands for \textbf{if}, \textbf{case}, and \textbf{while} statements involving standard basis measurements:
\begin{align*}
\qpenv{\qpifteB{q}{\qpabsprog{S_1}}{\qpabsprog{S_0}}}
  &\;\equiv\;
  \qpenv{\qpifte{\proj1}{q}{\qpabsprog{S_1}}{\qpabsprog{S_0}}} \\
\qpenv{\qpselectS{\vec q}{\dots}}
  &\;\equiv\;
  \qpenv{\qpselect{\{x\colon\proj{x}\}_{x \in \Sigma_{\vec q}}}{\vec q}{\dots}} \\
\qpenv{\qpwhileB{q}{\qpabsprog{S}}}
  &\;\equiv\;
  \qpenv{\qpwhile{\proj1}{q}{\qpabsprog{S}}}
\end{align*}
We discuss a simple quantum while program that will serve as a running example.

\begin{example}[Quantum coin toss until zero]
\label{ex:coin-toss:program}
Consider the following algorithm:
Initialize a qubit in the $\ket0$ state.
Repeatedly apply the Hadamard gate and measure in the standard basis until the outcome~``0'' is seen.
This can be realized by the corresponding quantum while program:
\[
S_\text{toss-until-zero} =
\qpenv{
\begin{aligned}
  &\qpinitS{q} ;  \\
  &\qpunitary{q}{H} ; \\
  &\qpwhileB{q}{\\
    &\quad\qpunitary{q}{H}\\&
  }
\end{aligned}
}
\]
\end{example}

%-----------------------------------------------------------------------------
\paragraph{Semantics}
Any quantum while program~$S$ defines a function that maps the state of the quantum variables before execution to the corresponding (partial) state after program execution.
This is called the \emph{denotational semantics} of $S$, denoted~$\Bracks{S}$, and is defined formally in the following.

\begin{definition}[Denotational semantics]\label{def:semantics}
For any program $S$, its denotational semantics is the map
\begin{equation*}
    \Bracks{S} \colon \dHle \rightarrow \dHle,
\end{equation*}
which is defined recursively in the following way:
\begin{enumerate}
  % skip
  \item $\Bracks{\qpenv{\qpskip}} (\rho) = \rho$
  % init
  \item $\Bracks{\qpenv{\qpinit{\vec q}}} (\rho)
  = \sum_{\vec x \in \Sigma_{\vec q}} \ketbra{\vec 0}{\vec x}_{\vec q} \rho \ketbra{\vec x}{\vec 0}_{\vec q}$
  % unit
  \item $\Bracks{\qpenv{\qpunitary{\vec{q}}{U}}}(\rho)
  = U_{\vec q} \rho U_{\vec q}^\dagger$
  % seq
  \item $\Bracks{\qpenv{\qpabsprog{S_1} ; \qpabsprog{S_2}}} (\rho)
  = \Bracks{S_2}\parens*{\Bracks{S_1}(\rho)}$
  % repeat
  \item $\Bracks{\qpenv{\qprepeat{N}{\qpabsprog{S}}}} (\rho)
  = \Bracks{S}^N(\rho)$
  % case
  \item $\Bracks{\qpenv{\qpselect{\vec M}{\vec{q}}{\ldots, \ \omega \colon \qpabsprog{S_{\omega}},\ \ldots}}} (\rho)
  = \sum_{\omega\in\Omega} \Bracks{S_\omega}(\cM_{\omega,\vec q}(\rho))$
  % while
  \item $\Bracks{\qpenv{\qpwhile{B}{\vec{q}}{\qpabsprog{S}}}}(\rho)
  = \sum_{k=0}^{\infty} \parens*{\cB_{0,\vec q} \circ \parens*{ \Bracks{S} \circ \cB_{1,\vec q} }^k}(\rho)$
\end{enumerate}
\end{definition}
%
We explain the semantics above using the definitions from \cref{subsec:quantum}.
Statements~(1)-(5) are self-explanatory.
The \textbf{case} statement~(6) measures a set of variables $\vec q$ with the measurement $\vec M$,
and on seeing outcome~$\omega$ executes program $S_\omega$.
The \textbf{while} statement~(7) runs a loop with body $S$, guarded by the condition that measuring $\vec q$ with the binary measurement $B$ gives outcome $1$.
The semantics for \textbf{while} is easily seen to be well-defined, as the partial states~$\sigma_n = \sum_{k=0}^n \parens*{\cB_{0,\vec q} \circ \parens{ \Bracks{S} \circ \cB_{1,\vec q} }^k}(\rho)$ form an increasing sequence (meaning~$\sigma_{n+1} \succeq \sigma_n$ for all~$n$) that is bounded from above.
Note that~$\sigma_n$ represents the partial state corresponding to termination within at most~$n$ iterations of the loop.

For a program to be physically realizable on a quantum computer, it must be \emph{completely positive and trace non-increasing}.
One can note that $\Bracks{S}$ satisfies both these conditions for any program~$S$.
In particular, the quantity~$\tr(\Bracks{S}(\rho))$ is a number in~$[0,1]$ for any state~$\rho\in\dH$; it can be interpreted as the \emph{probability of termination} of the program~$S$ when started in the initial state~$\rho$.
In particular, the program~$S$ \emph{terminates almost surely} (that is, with probability one) when started in state~$\rho$ if, and only if $\tr(\Bracks{S}(\rho))=1$.
Moreover, we can see when the program is \emph{trace preserving}, meaning that it terminates on any input state:
(1)-(3) are always trace preserving,
(4)-(6) are trace preserving if all the sub-programs ($S_1$ and $S_2$, or $S$, or $S_\omega$ for $\omega\in\Omega$, respectively) are trace preserving,
and (7) is trace preserving if the sub-program~$S$ is trace preserving and the loop terminates with probability one.

\begin{example}[Semantics for quantum coin toss until zero]\label{ex:coin-toss:semantics}
We compute the semantics for the program in \cref{ex:coin-toss:program}, which can be written as
\[ {S_\text{toss-until-zero}} = \qpenv{\qpinitS{q} ; \qpunitary{q}{H} ; \qpabsprog{S_\text{loop}}}, \]
with
\[ \qpabsprog{S_\text{loop}} = \qpenv{\qpwhileB{q}{\qpunitary{q}{H}}}. \]
Then for any state $\rho \in \dH$,
\begin{align*}
\Bracks{{S_\text{toss-until-zero}}}(\rho)
&=\Bracks{\qpenv{
    \qpinitS{q} ;
    \qpunitary{q}{H} ;
    \qpabsprog{S_\text{loop}}
}}(\rho) \\
&= \Bracks{{S_\text{loop}}} \parens[\big]{\Bracks{\qpenv{\qpunitary{q}{H}}} (\Bracks{\qpenv{\qpinitS{q}}}(\rho))} \\
&= \Bracks{{S_\text{loop}}} \parens[\big]{\Bracks{\qpenv{\qpunitary{q}{H}}} (\proj0)} \\
&= \Bracks{S_\text{loop}} \parens*{ \proj{+} }.
\end{align*}
It remains to compute the semantics of the loop, which for a general state~$\sigma$ is given by
\begin{align*}
  \Bracks{S_\text{loop}}(\sigma)
&= \sum_{k = 0}^{\infty} \parens*{\cB_0 \circ (\Bracks{\qpenv{\qpunitary{q}{H}}} \circ \cB_1)^k}(\sigma),
\end{align*}
where $\cB_j(\rho) = \proj{j}\!\rho\!\proj{j}$.
Now, for any state~$\sigma$, we have $(\Bracks{\qpenv{\qpunitary{q}{H}}} \circ \cB_1)(\sigma) = \braket{1|\sigma|1} \proj-$,
and therefore for any~$k \ge 1$,
$(\Bracks{\qpenv{\qpunitary{q}{H}}} \circ \cB_1)^k(\proj+) = \frac1{2^k} \proj-$.
Altogether, we find that, for any initial state~$\rho$,
\begin{align*}
\Bracks{{S_\text{toss-until-zero}}}(\rho)
&= \cB_0(\proj+) + \sum_{k = 1}^\infty \cB_0\parens*{\frac1{2^k}\proj-} \\
&= \frac12\proj0 + \sum_{k = 1}^\infty \frac1{2^{k+1}}\proj0 \\
&= \proj0.
\end{align*}
We see that no matter what state we start in, the program always terminates in the pure state~$\ket0$.
\end{example}


%-----------------------------------------------------------------------------
\subsection{Specifying Program Properties -- Quantum Hoare Logic}
\label{subsec:quantum-hoare-logic}
%-----------------------------------------------------------------------------
Hoare logic is a formal system to state and prove correctness of programs.
For a program~$S$, one specifies a precondition~$P$ and postcondition~$Q$ to form a Hoare triple $\hoare{P}{S}{Q}$.
Such a Hoare triple is said to hold if, for any state that satisfies $P$, running the program on it results in a state that satisfies~$Q$.
Here~$P$ and~$Q$ are predicates over the state of the program variables.
In this section, we present the formalism for \emph{quantum Hoare logic}~\cite{ying2012quantum}.

%-----------------------------------------------------------------------------
\paragraph{Predicates}
Predicates are properties of the state of the system that can hold to some degree.
Recall that any PSD operator $P \preceq I$ defines a binary measurement~$\vec B = \{B_0,B_1\}$ by setting~$B_0 = I - P$ and $B_1 = P$.
We may think of~$P$ as defining a predicate.
Similarly as in probabilistic Hoare logic~\cite{Morgan1998pGCLFR}, instead of assigning a definite truth value to a given predicate and state, we rather assign an \emph{expectation} or degree to which the predicate holds in the given state -- namely the probability of getting outcome~$1$ if one were to apply the corresponding measurement.
For a state~$\rho$, this probability is given by~$\tr(P \rho)$, as explained earlier.
We thus arrive at the following definition.

\begin{definition}[Predicates and expectation]\label{def:pred exp}
A \emph{predicate} is a positive semidefinite operator~$P$ such that~$P \preceq I$, and the set of all such predicates is denoted $\cPHle$.
The \emph{expectation} of the predicate~$P$ in a (partial) state $\rho \in \dHle$ is defined as
\begin{align*}
  \satisfies{\rho}{P} = \tr(P\rho) \in [0,1].
\end{align*}
We say that \emph{$P$ implies $Q$} (denoted $P \imp Q$) for two predicates $P, Q$ iff $\satisfies{\rho}{P} \le \satisfies{\rho}{Q}$ for all states~$\rho\in\dH$.
This is plainly equivalent to $P \preceq Q$ in the L\"owner order.
\end{definition}

%-----------------------------------------------------------------------------
\paragraph{Quantum Hoare Triples}
A quantum Hoare triple is denoted by
\[ \hoare{P}{S}{Q} \]
and consists of a program~$S$, precondition~$P$, and postcondition~$Q$, where $P, Q$ are predicates as defined above.
Similar to probabilistic Hoare logic, we have notions of correctness of a Hoare triple.

We start with total correctness, which states that the degree to which the postcondition holds is at least the degree to which the precondition holds:

\begin{definition}[Total Correctness]
\label{def:total-correctness}
For a program~$S$ and predicates~$P$,~$Q$,
the Hoare triple $\hoare{P}{S}{Q}$ is said to be \emph{totally correct} if for all partial states~$\rho \in \dHle$,
\begin{equation*}
    \satisfies{\rho}{P} \le \satisfies{\Bracks{S}(\rho)}{Q}.
\end{equation*}
We denote total correctness by $\totcorr \hoare{P}{S}{Q}$.
It is equivalent to%~$P \preceq \Bracks{S}^\dagger(Q)$ or
~$P \imp \Bracks{S}^\dagger(Q)$.
\end{definition}

Next, we define partial correctness, where the degree to which the postcondition holds only matters insofar as the program terminates.

\begin{definition}[Partial Correctness]
\label{def:partial-correctness}
For a program~$S$ and predicates~$P$,~$Q$,
the Hoare triple $\hoare{P}{S}{Q}$ is said to be \emph{partially correct} if for all partial states~$\rho \in \dHle$,
\begin{equation}\label{eq:def par cor}
    \satisfies{\rho}{P}
    \le \satisfies{\Bracks{S}(\rho)}{Q}
    + [\tr(\rho) - \tr(\Bracks{S}(\rho))].
\end{equation}
This condition can be equivalently stated as
\begin{align*}
    \satisfies{\rho}{P} - \tr(\rho)
    \le \satisfies{\Bracks{S}(\rho)}{Q} - \tr(\Bracks{S}(\rho))
\end{align*}
or
\begin{equation}\label{eq:def par cor alt}
    \satisfies{\rho}{I-P} \geq \satisfies{\Bracks{S}(\rho)}{I-Q}.
\end{equation}
We denote partial correctness by $\parcorr \hoare{P}{S}{Q}$.
It is equivalent to% $I-P \succeq \Bracks{S}^\dagger(I-Q)$, or
% ~$P \imp I - \Bracks{S}^\dagger(I-Q)$.
~$\Bracks{S}^\dagger(I-Q) \imp I - P$.
\end{definition}

We note that it in order to establish total or partial correctness, it suffices to verify the defining inequalities for all states~$\rho\in\dH$ (rather than for all partial states).

As explained below \cref{def:semantics}, the term $[\tr(\rho) - \tr(\Bracks{S}(\rho))]$ in \cref{eq:def par cor} is the \emph{probability of non-termination} of the program~$S$ when starting in the initial state~$\rho$, and it is always non-negative (as $\Bracks{S}$ is trace non-increasing).
Intuitively, \cref{eq:def par cor} states that the degree to which the postcondition holds is at least the degree to which the precondition holds, \emph{minus the probability of non-termination}.
The equivalent \cref{eq:def par cor alt} states that the probability that the program terminates and the postcondition does \emph{not} hold is at most the probability that the precondition does \emph{not} hold.
Clearly, total implies partial correctness.

For later use, we note that~$\totcorr \hoare {I}{S}{Q}$ means that, for any initial state, the program terminates almost surely in a state satisfying the postcondition, while~$\parcorr \hoare {I}{S}{Q}$ means that the postcondition holds whenever the program terminates.
In particular, $\totcorr \hoare {I}{S}{I}$ states that the program terminates almost surely on any initial state, while $\parcorr \hoare {I}{S}{I}$ holds trivially for any program.

%-----------------------------------------------------------------------------
\paragraph{Projections as Predicates}
Projections are predicates~$P$ such that $P^2 = P$.
When the precondition in a Hoare triple is a projection, we only need to verify correctness for pure states that exactly satisfy the precondition, meaning that~$\satisfies \rho P = 1$ or equivalently~$P \ket\psi = \ket\psi$.
We restate this result from \citet[Theorem 3.2]{aQHL2019} in the following way that we found most useful for verification.

\begin{lemma}[Projections as Predicates]\label{lem:projections as predicates}
For any Hoare triple~$\hoare{P}{S}{Q}$ with $P$ a projection,~we~have:
\begin{enumerate}
\item
$\totcorr \hoare{P}{S}{Q}$
iff~
$\satisfies{\Bracks{S}(\proj\psi)}{Q} = 1$
for every unit vector $\ket{\psi}$ such that~$P\ket\psi = \ket\psi$.
\item
$\parcorr \hoare{P}{S}{Q}$
iff~
$\satisfies{\Bracks{S}(\proj\psi)}{Q} = \satisfies{\Bracks{S}(\proj\psi)}{I}$
for every unit vector~$\ket{\psi}$ such that~$P\ket\psi~\!=~\!\ket\psi$.
\end{enumerate}
\end{lemma}

By plugging $S = \qpenv{\qpskip}$ into \cref{lem:projections as predicates}, we obtain the following fact:

\begin{corollary}\label{cor:projection-predicates}
Let~$P$ be a projection and~$Q$ an arbitrary predicate.
Then,
$P \imp Q$ holds
if, and only if, $\braket{\psi|Q|\psi} = 1$ for every unit vector $\ket \psi$ such that~$P\ket\psi = \ket\psi$.
\end{corollary}

In particular, we can specify the behavior of the program when run with some initial pure state~$\ket\Psi$
by using the precondition~$P = \proj\Psi$.
Indeed, since~$\ket\Psi$ is the only vector (up to a scalar) such that~$P \ket\Psi = \ket\Psi$,
it follows from \cref{lem:projections as predicates} that a Hoare triple~$\hoare {\proj\Psi} S Q$ is totally correct iff~$\satisfies{\Bracks{S}(\proj\Psi)}{Q} = 1$,
and partially correct iff~$\satisfies{\Bracks{S}(\proj\Psi)}{Q} = \satisfies{\Bracks{S}(\proj\Psi)}{I}$.
More generally, the precondition~$P = \proj\psi_{\vec q} \ot I_{\vec{q}^c}$ can be used to specify the behavior on input states where the quantum variables~$\vec q$ are in some pure state~$\ket\psi \in \cH_{\vec q}$.
% (equivalently, $\rho = \proj\psi_{\vec q} \ot \rho_{\vec{q}^c}$ for some arbitrary state $\rho_{\vec{q}^c}$).
%
The situation simplifies further if the postcondition is also given by a pure state, say~$Q=\proj\Phi$.
Indeed, the Hoare triple~$\hoare {\proj\Psi} S {\proj\Phi}$ is totally correct iff~$\Bracks{S}(\proj\Psi) = \proj\Phi$,
and partially correct iff~$\Bracks{S}(\proj\Psi) = p \proj\Phi$ for some arbitrary probability of termination~$p\in[0,1]$.
In other words, total (or partial) correctness of the above Hoare triple means that running the program~$S$ on state~$\ket\Psi$ results in state~$\ket\Phi$ (if the program terminates).
%
We use the above observations later when describing the specifications for teleportation and search in \cref{sec:examples}.
We caution that we \emph{cannot} specify program behavior on mixed initial states~$\rho$ by taking~$P=\rho$.
% For example, for the mixed state $\rho = \frac I 2 = \frac12 \proj0 + \frac12 \proj1$ we have~$\satisfies{\rho}{\rho} = \tr(\rho^2) = \frac12 < 1$.
However, since any mixed state can be purified, this does not impose a real restriction.

We discuss the correctness of a natural Hoare triple for our running example.

\begin{example}[Hoare triple for quantum coin toss until zero]\label{ex:coin-toss:spec}
One way to specify the behavior of the program~$S_\text{toss-until-zero}$ in \cref{ex:coin-toss:program} is by the quantum Hoare triple
\[ \hoare{I}{S_\text{toss-until-zero}}{\proj0}. \]
As discussed, this states that, for any input state, the program terminates in the final state~$\ket0$.
We can verify explicitly that this Hoare triple program is totally correct.
Indeed, we saw in \cref{ex:coin-toss:semantics} that $\Bracks{S_\text{toss-until-zero}}(\rho) = \proj0$ for every state~$\rho\in\dH$, and hence
\begin{align*}
  \satisfies{\Bracks{S_\text{toss-until-zero}}(\rho)}{\proj0}
= \satisfies{\proj0}{\proj0}
= \tr \proj0 \proj0
= 1
= \tr\rho
= \satisfies{\rho}{I}
\end{align*}
for every state~$\rho\in\dH$.
This confirms that the triple $\hoare{I}{S_\text{toss-until-zero}}{\proj0}$ is totally correct.
\end{example}

%-----------------------------------------------------------------------------
\subsection{Multiple Specifications}\label{subsec:multispec}
We often want to specify that a single program satisfies several Hoare triples at once.
We give three motivating examples:
\begin{enumerate}
\item
To prove a Hoare triple~$\hoare P {\qpenv{\qprepeat N S}} Q$ correct, it suffices to prove that the loop body satisfies~$\hoare {R_j} S {R_{j+1}}$ holds for all~$j\in\{0,\dots,N-1\}$, for predicates~$R_0,\dots,R_N$ with~$P \imp R_0$ and~$R_N \imp Q$.
\item
To assert that a program~$S$ terminates on any input, we can always add the Hoare triple~$\hoare I S I$ on top of any other Hoare triple that we may also want to hold (as discussed earlier).
\item
A program that creates a qubit that, when measured, outputs $x \in \{0,1\}$ with 50\% probability each, can be specified by the two Hoare triples~$\hoare {I/2} S {\proj x}$ for $x\in\{0,1\}$ (see \cref{subsec:example:fair-coin}).
\end{enumerate}
At other times, we may even want to allow the program~$S$ to depend on some parameter.
For example, the search algorithms of \cref{subsec:examples:qsearch}, as well as the pre- and postconditions that specify what it means for the search algorithm to be correct, will need to depend explicitly on the database that is being queried.
We will therefore consider Hoare triples
\begin{align*}
  \hoare {P_\lambda} {S_\lambda} {Q_\lambda},
\end{align*}
where the pre- and postconditions as well as the program are parameterized by~$\lambda$ in some index set~$\Lambda$.
Such a Hoare triple is (totally or partially) correct if it is correct for every definite value of~$\lambda$.
If the program~$S_\lambda$ does not depend on~$\lambda$, we have a single program that satisfies multiple specifications, while if it depends on (part of)~$\lambda$, then we have a family of programs.
To stick with the literature, we will think of~$\lambda$ as a \emph{formal (or meta) parameter} that is implicitly quantified over universally, but one could instead also adjust the definition of predicates to be functions~$\Lambda \to \cPHle$ (and extend the notions of expectation, implication, and so forth in a straightforward way).

The following notation will be useful: if~$\lambda$ ranges over a finite set of options~$\{\lambda_1, \ldots, \lambda_k\}$, then we will also write
\[
\hoare{P_{\lambda_1}, \dots, P_{\lambda_k}}{S_{\lambda_1}, \dots, S_{\lambda_k}}{Q_{\lambda_1}, \dots, Q_{\lambda_k}}
\]
instead of $\hoare {P_\lambda} {S_\lambda} {Q_\lambda}$.
If the precondition, the postcondition, or the program do not depend on~$\lambda$, we will write the corresponding term only once.
For instance, the third motivating example above could alternatively be written as $\hoare{I/2}{S}{\proj0, \proj1}$.

%=============================================================================
\section{Correctness by construction for quantum programs}
\label{sec:qbc}
%=============================================================================

In the Correctness-by-Construction (CbC) approach, one starts with a specification and successively refines it to construct a program that is guaranteed to satisfy the initial specification.
Prior work on CbC defined refinement rules in terms of Hoare triples:
one could replace an ``abstract'' program~$S$ in a Hoare triple~$\hoare{P}{S}{Q}$ (where~$P, Q$ are some predicates) by some concrete program~$S'$ provided certain side conditions were satisfied, which often involved the validity of other Hoare triples for subprograms that have to be constructed beforehand.

Here we propose a new way of formalizing CbC that does not require the prior construction of suitable subprograms (while we demonstrate it in the quantum setting, the idea is generally applicable).
To this end, we extend the quantum while language by a new construct~$\qphole{P}{Q}$, called a \emph{hole}, which represents a yet-to-be-constructed subprogram that carries a precondition~$P$ and a postcondition~$Q$ (\cref{subsec:qwhile-with-holes}).
This notion of programs with holes is similar in spirit to abstract execution~\cite{absexec2019}, where one is interested in executing and analyzing programs containing ``abstract statements''.
We then proceed to provide \emph{refinement rules} (\cref{sec:refinement-relation}) that can be used to construct correct programs by replacing holes with concrete programs.
Finally, we prove that our refinement relation is sound: any program~$S$ constructed from a specification~$\qpenv{\qphole{P}{Q}}$ must satisfy that specification, meaning that the Hoare triple~$\hoare{P}{S}{Q}$ is correct (\cref{sec:soundness}).


%-----------------------------------------------------------------------------
\subsection{Quantum While Language with Holes}
\label{subsec:qwhile-with-holes}
%-----------------------------------------------------------------------------
To support QbC specifications, we first extend our quantum while language in \cref{def:qwhile-syntax} with a new construct: \emph{holes}.
A hole is a yet-to-be-constructed program tagged with a precondition and a postcondition, such that the corresponding Hoare triple should be satisfied once the hole is filled by a program.
We define the syntax of the extended language below.

\begin{definition}[Syntax]
\label{def:programs-with-holes}
Programs in the quantum while language with holes are given by the following grammar:
\begin{align*}
  \qwhilesyntax \\
  &|\; \qphole{P}{Q}
\end{align*}
where $S, S_1, S_2, S_{\omega}$ denote programs in the language;
$\vec{q}$ denotes a set of quantum variables;
$U$ is a unitary operator on~$\cH_{\vec{q}}$;
$N$ is a natural number;
$\{M_{\omega}\}_{\omega\in\Omega}$ is a measurement on~$\cH_{\vec{q}}$ with outcomes in some set $\Omega = \{\omega_1, \omega_2, \ldots\}$;
$B$ is an operator defining a binary measurement~$\{I-B, B\}$;
and~$P$ and~$Q$ are predicates.
We say that $\qpenv{\qphole{P}{Q}}$ is a \emph{hole} with precondition~$P$ and a postcondition~$Q$.

The above grammar is identical to the quantum while language (\cref{def:qwhile-syntax}), except for the last line, which defines the hole construct.
A program that may contain holes is called an \emph{abstract program}, and one that does not contain any holes is called a \emph{concrete program}.
In other words, concrete programs are simply programs in the quantum while language.
\end{definition}

In the following we will also be interested in holes that satisfy multiple pre- and postconditions, which can be formalized just as discussed for Hoare triples (\cref{subsec:multispec}).
We will denote these as~$\qpenv{\qphole{P_\lambda}{Q_\lambda}}$, where~$\lambda$ is some formal parameter, or use short-hand notation such as~$\qpenv{\qphole{P,P'}{Q,Q'}}$.
See, e.g., \ruleref{H.split} and \ruleref{H.repeat} below, and \cref{rem:multispec rules} for further discussion.

%-----------------------------------------------------------------------------
\subsection{Refinement Rules}
\label{sec:refinement-relation}
%-----------------------------------------------------------------------------
Refinement is the process of replacing holes in abstract programs with other (abstract or concrete) programs.
To this end, we define a \emph{refinement relation} on abstract programs, and we use this iteratively to construct concrete programs from specifications given by a single hole~$\qpenv{\qphole{P}{Q}}$.

\begin{definition}[Refinement for partial correctness]\label{def:parref}
We define a relation~$\parref$, called \emph{refinement for partial correctness} on programs with holes~(\cref{def:programs-with-holes}) as follows:
For any two predicates~$P$~and~$Q$,
\begin{enumerate}[align=right,leftmargin=1.7cm]
%
  \ruleitem{H.skip}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpskip}$,
    if $P \imp Q$.
%
  \ruleitem{H.init}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpinit{\vec q}}$,
    if $P \imp \sum_{\vec x\in\Sigma_{\vec q}} \ketbra{\vec x}{\vec 0}_{\vec q} Q \ketbra{\vec 0}{\vec x}_{\vec q}$.
%
  \ruleitem{H.unit}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpunitary{\vec{q}}{U}}$,
    if $P \imp U_{\vec q}^\dagger Q U_{\vec q}$ or, equivalently, $U_{\vec q} P U_{\vec q}^\dagger \imp Q$.
%
  \ruleitem{H.seq}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qphole{P}{R} ; \qphole{R}{Q}}$
    for any predicate~$R$.
%
  \ruleitem{H.split}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qphole{P_\gamma}{Q_\gamma}}$
    for any two families of predicates~$P_\gamma,Q_\gamma$ for~$\gamma$ in some index set $\Gamma$, such that~$P \imp \sum_\gamma p_\gamma P_\gamma$ and~$\sum_\gamma p_\gamma Q_\gamma \imp Q$ for a probability distribution~$p_\gamma$.
%
  \ruleitem{H.repeat}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qprepeat{N}{\qphole{R_j}{R_{j+1}}}}$,
    where $j \in \irange{0}{N - 1}$, \\
    for any predicates~$R_0, R_1, \ldots, R_N$
    such that $P \imp R_0$ and $R_N \imp Q$.
%
  \ruleitem{H.case}
  $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpselect {\vec M} {\vec q} { \{\omega \colon \qphole{P_\omega}{Q}\}_{\omega\in\Omega}} }$

  for any family of predicates~$P_\omega$ for $\omega\in\Omega$ such that $P \imp \sum_{\omega \in \Omega} \cM_{\omega}(P_\omega)$.
%
  \ruleitem{HP.while}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpwhile{B}{\vec q}{ \qphole{R}{\cB_0(Q) + \cB_1(R)}}}$,

    for any predicate $R$ such that $P \imp \cB_0(Q) + \cB_1(R)$.
    % where the measurement is $\{B_0 = I-B, B_1=B\}$.
\end{enumerate}
We also have rules for composite statements:
\begin{enumerate}[align=right,leftmargin=1.6cm,resume] %[align=left,resume]
\ruleitem{C.seqL}
  $\qpenv{\qpabsprog{S_1'};\qpabsprog{S_2}}
    \parref
    \qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}$
  if $S_1' \parref S_1$.
%
\ruleitem{C.seqR}
  $\qpenv{\qpabsprog{S_1};\qpabsprog{S_2'}}
    \parref
    \qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}$
  if ${S_2'} \parref {S_2}$.
%
\ruleitem{C.repeat}
  $\qpenv{\qprepeat{N}{\qpabsprog{S'}}}
    \parref
  \qpenv{\qprepeat{N}{\qpabsprog{S}}}$
  if $S' \parref S$.
%
\ruleitem{C.case}
  $\qpenv{\qpselect{\vec M}{\vec q}{\omega \colon \qpabsprog{S'_\omega}~, \ \dots}} \parref$ \\
  $\qpenv{\qpselect{\vec M}{\vec q}{\omega \colon \qpabsprog{S_\omega}~, \ \dots}}$, \\
  if ${S'_\omega} \parref {S_\omega}$ for exactly one $\omega\in\Omega$ (and the rest being unchanged).
%
\ruleitem{C.while}
  $\qpenv{\qpwhile{B}{\vec q}{\qpabsprog{S'}}} \parref$ \\
  $\qpenv{\qpwhile{B}{\vec q}{\qpabsprog{S}}}$,
  if ${S'}~\parref~{S}$.
\end{enumerate}
For any two programs $S, S'$, we say \emph{$S'$ refines in one step to $S$ ensuring partial correctness} if~$S' \parref S$.
More generally, for any~$k\geq0$ we define~$S' \parref^k S$ if $S'$ refines to $S$ in $k$ such steps.
We say \emph{$S'$ refines to $S$ ensuring partial correctness} if~$S$ can be obtained from $S'$ by applying any number of refinement steps and denote this by~$S' \parref^* S$.
Clearly, $\parref^* = \bigcup_{k = 0}^{\infty} \parref^k$ is the reflexive and transitive closure of the relation~$\parref$.
\end{definition}

In \cref{def:parref}, the rules labeled (H.$*$) and (HP.while) are used to refine a single hole to another program (H stands for hole).
%
The rules labeled (C.$*$) are used to refine holes in composite programs (C stands for composite).
%
The first four rules are self-explanatory.
We explain the \ruleref{H.split}, \ruleref{H.repeat}, \ruleref{H.case} and \ruleref{HP.while} rules.
%
To motivate \ruleref{H.split}, observe that if a program satisfies two Hoare triples $\hoare P S Q$ and $\hoare{P'} S {Q'}$, then it also satisfies any combination $\hoare{p P + (1-p) Q} S {p Q + (1-p)Q'}$ for~$p\in[0,1]$.
So to ensure the latter it suffices to construct a program that satisfies the former.
Note that in stating this rule we use the syntax for multiple specifications discussed below \cref{def:programs-with-holes}.
In \ruleref{H.split} we also allow for weakening preconditions and strengthening postconditions; we isolate this in \ruleref{H.sw} below for convenience.
To refine a hole to a \textbf{repeat} statement using \ruleref{H.repeat}, we must find a family of predicates $R_0, R_1, \ldots, R_N$,
such that $R_n$ holds after running the loop body $0 \le n \le N$ times, with $R_0$ implied by the precondition and $R_N$ implying the postcondition.
The body of the \textbf{repeat} statement is $\qpenv{\qphole{R_j}{R_{j + 1}}}$ where $j \in \irange{0}{N-1}$ is a formal parameter, meaning that the yet-to-be-constructed program must satisfy these specification for all such~$j$.
%
To refine a hole to a \textbf{case} statement using \ruleref{H.case}, we must find a family of predicates~$P_\omega$ for each measurement outcome~$\omega$ such that if~$P$ holds before the measurement then~$P_\omega$ holds after measurement upon seeing outcome~$\omega$.
%
Finally, to refine a hole to a \textbf{while} statement using \ruleref{HP.while}, we need to find an ``invariant'' $R$ for the loop body.
If the measurement succeeds after the execution of the loop body, then~$R$ must hold; otherwise~$Q$ must hold.
The composite rules are also self-explanatory: they allow refining any hole in a composite program using any of the rules above.

\begin{remark}[Multiple specifications and formal parameters]\label{rem:multispec rules}
As mentioned, some refinement rules can introduce holes with multiple specifications.
For example, \ruleref{H.repeat} introduces a hole with pre- and postcondition labeled by an index $j \in \irange{0}{N-1}$, and \ruleref{H.split} introduces a new parameter~$\gamma$ in some arbitrary index set~$\Gamma$.
We can model this formally by implicitly extending the index set~$\Lambda$ of \cref{subsec:multispec} to include this new parameter.
Later refinements may depend on this parameter.
For example, if we refine a hole produced by \ruleref{H.repeat} with the \ruleref{H.seq} rule, then the intermediate predicates~$R$ may also depend on~$j$.
See \cref{sec:examples} for many examples.
\end{remark}

To illustrate how to apply the above rules, we revisit our running example:

\begin{example}[Refining the specification of quantum coin toss until zero]
\label{ex:coin-toss:refinement-simple}
Consider the following abstract program, which consists of a single hole, with pre- and postcondition as in the Hoare triple for the quantum coin toss until zero program as derived in \cref{ex:coin-toss:spec}:
\[ \qpenv{\qphole{I}{\proj0}} \]
One possible refinement is:
\begin{align*}
  \qpenv{\qphole{I}{\proj0}} \parref \qpenv{\qpinitS{q}} \ruletag{H.init}
\end{align*}
The above refinement rule can be applied as the condition~$I \imp \sum_{x \in \{0,1\}} \ketbra{x}{0} \proj0 \ketbra{0}{x}$ is satisfied, because the RHS equals $I$.
However, this is not the only program one can construct satisfying it.
Instead, we can also use the sequence rule \ruleref{H.seq}:
\begin{align*}
  \qpenv{\qphole{I}{\proj0}}
  \parref
  \qpenv{\qphole{I}{I} ; \qphole{I}{\proj0}}
  \ruletag{H.seq}
\end{align*}
Now the program at hand is a sequence of two holes.
We can now refine the second hole as follows:
\[
  \qpenv{\qphole{I}{I} ; \qphole{I}{\proj0}}
  \parref
  \qpenv{\qphole{I}{I} ; \qpinitS{q}}
  \ruletag{H.init}
\]
We can achieve this by using \ruleref{C.seqR}, as we already know that $\qpenv{\qphole{I}{\proj0}} \parref \qpenv{\qpinitS{q}}$.
One can now continue and fill in the remaining hole arbitrarily.
In \cref{subsec:example:coin-toss-until-zero}, we will explain how to re-construct our quantum coin toss until zero program by using refinement rules.
\end{example}

We can also apply these rules to the syntactic sugar introduced in \cref{subsec:qwhile} and deduce some other rules for convenience.
For example, since an \textbf{if} statement is shorthand for a \textbf{case} statement (\cref{subsec:qwhile}), we also have
\begin{enumerate}[align=right,leftmargin=1.7cm]
\ruleitem{H.ifElse}
  $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qpifte {B} {\vec q} { \qphole{R_1}{Q} } { \qphole{R_0}{Q} } }$, \\
  for any two predicates~$R_0,R_1$ such that $P \imp \cB_0(R_0) + \cB_1(R_1)$.
\end{enumerate}
We can also introducing an \textbf{if} statement without an \textbf{else} branch:
\begin{enumerate}[align=right,leftmargin=1.7cm]
\ruleitem{H.if}
  $\qpenv{\qphole{P}{Q}} \parref^* \qpenv{\qpif {B} {\vec q} { \qphole{R}{Q} } }$, \\
  for any predicate~$R$ such that $P \imp \cB_0(Q) + \cB_1(R)$.
\end{enumerate}
This follows from \ruleref{H.ifElse} by further the second hole using \ruleref{H.skip}.

Finally, we have the following rule that shows that we may always construct a program that has a weaker precondition and a stronger postcondition:
\begin{enumerate}[align=right,leftmargin=1.7cm]
  \ruleitem{H.sw}
    $\qpenv{\qphole{P}{Q}} \parref \qpenv{\qphole{P'}{Q'}}$
    for any predicates $P', Q'$ such that $P \imp P'$ and $Q' \imp Q$.
\end{enumerate}
This is a special case of \ruleref{H.split} where we take the two families to consist of a single predicate~$P'$ and $Q'$, respectively.

\begin{remark}[Challenges of quantum verification]
We note that the quantum setting poses some interesting new challenges that do not arise in the classical setting.
For example, in a \ruleref{H.case} rule for classical programs, one can always choose the predicates as~$P_\omega = P \land (q = \omega)$.
However, in the quantum setting, there is generally no canonical choice of the predicates~$P_\omega$.
We leave the problem of finding suitable heuristics for deriving such predicates to future work.
% This means that it is in general nontrivial to go from inference rules in the quantum Hoare proof system~\cite{ying2012quantum} to refinement rules for QbC.
% in particular, QbC refinement rules are not merely the reverse of quantum Hoare logic rules,
% but need to be designed more carefully to develop a sound refinement system.
\end{remark}

We also define refinement rules that ensure total correctness.

\begin{definition}[Refinement for Total Correctness]
\label{def:totref}
We define a relation~$\totref$, called \emph{refinement for total correctness} on programs with holes, by using all the rules from \cref{def:parref} that are labeled (H.$*$) or (C.$*$), by replacing each $\parref$ with $\totref$, but replacing \ruleref{HP.while} by the following rule (which we motivate below):
\begin{enumerate}[align=right,leftmargin=2.5cm]
\ruleitem{H.whileEps}
  $\qpenv{\qphole{P}{Q}}
  \totref
  \qpenv{
  \begin{aligned}
      &\qpwhile{B}{\q}{\\
      &\quad \qpenv{\qphole{R, \eps B^\text{supp}_\q, B^\text{supp}_\q}{\cB_0(Q) + \cB_1(R), I - B_\q, I}}\\
      &}
  \end{aligned}
  }
  $, \\
  for any two predicates~$B, R$ with~$P \imp \cB_0(Q) + \cB_1(R)$ and any~$\eps>0$;
  where~$B^\text{supp}$ denotes the projection onto the support of~$B$ (if $B$ is a projection then $B^\text{supp} = B$).
\end{enumerate}
For any two programs $S, S'$, we say that \emph{$S'$ refines in one step to $S$ ensuring total correctness} if~$S' \totref S$.
More generally, for any~$k\geq0$, we define~$S' \totref^k S$ if $S'$ refines to $S$ in $k$ such steps.
We say that~\emph{$S'$ refines to $S$ ensuring total correctness} if~$S$ can be obtained from $S'$ by applying any number of refinement steps and denote this by~$S' \totref^* S$.
Similarly as above, $\totref^* = \bigcup_{k = 0}^{\infty} \totref^k$ is the reflexive and transitive closure of the relation~$\totref$.
\end{definition}

The new rule \ruleref{H.whileEps} can be used to construct \textbf{while} loops with a ``loop invariant''~$R$.
In contrast to \ruleref{HP.while}, the new rule ensures total correctness by imposing two additional requirements on the loop body:
First, $\qpenv{\qphole {\eps B_\q^\text{supp}} {I-B_\q} }$ ensures that when we measure the loop condition after each iteration, we obtain outcome~$0$ (and hence exit the loop) with at least some constant probability~$\eps>0$.
Second, $\qpenv{\qphole {B_\q^\text{supp}} I}$ ensures that the loop body will terminate almost surely.
Note that each time we enter the loop body, we know that the loop condition was just measured and yielded outcome~$1$.
Hence the initial state of the loop body is necessarily supported on the support of the predicate~$B$, which allows us to use the precondition~$B^\text{supp}_\q$ in the specification of the loop body.
It is intuitively clear that loops constructed under these hypotheses terminate almost surely,%
\footnote{This follows from our soundness theorem (\cref{thm:soundness-total}), along with the following observation:
If $\qpenv{\qphole P Q} \totref S$ by applying the \ruleref{H.whileEps} rule, then also $\qpenv{\qphole {P,I} {Q,I}} \totref S$, since \ruleref{H.whileEps} can always be applied with~$P=Q=I$ and~$R=B^\text{supp}_\q$ and does not yield any additional constraints on the loop body.}
and within an expected number of~$1/\eps$ iterations.
We note that $\totref~\subseteq~\parref$, $\totref^k~\subseteq~\parref^k$, and~$\totref^*~\subseteq~\parref^*$.
% We provide a while rule for total correctness in \cref{lem:total-while-eps} below.
See \cref{subsec:examples:boosting} for further discussion and an application, and \cref{sec:related-work} for related work on proving termination of probabilistic programs.

%------------------------------------------------------------------------------
\subsection{Soundness of Refinement}
\label{sec:soundness}
%------------------------------------------------------------------------------

In the previous section, we introduced relations that allow one to iteratively refine programs with holes.
We now show that the set of rules given before is \emph{sound}, meaning that it ensures the correctness of constructed programs, in the following sense:
if one starts with a specification, that is, a single hole~$\qpenv{\qphole{P}{Q}}$,
and repeatedly refines to construct a concrete program~$S$ (i.e., a program without holes),
then the constructed program satisfies the initial specification, meaning that Hoare triple $\hoare{P}{S}{Q}$ is correct.
We first state this result for refinement for partial correctness:

\begin{restatable}[Soundness of refinement for partial correctness]{theorem}{thmsoundnesspartial}
\label{thm:soundness-partial}
For any two predicates~$P, Q$ and any concrete program~$S$,
if $\qpenv{\qphole{P}{Q}} \parref^* {S}$, then $\parcorr \hoare{P}{S}{Q}$.
\end{restatable}

Before giving the proof, we first analyze the notion of how a program with multiple holes can be filled.
Consider, e.g., the following intermediate programs from \cref{ex:coin-toss:refinement-simple}:
\[
  \qpenv{\qphole{I}{I} ; \qphole{I}{\proj0}}
\]
The only way to refine this program is by picking a hole and refining it individually.
The same is true more generally for any composite program (sequence, \textbf{repeat}, \textbf{case}, \textbf{while}): if one refines such a program, then the resulting program has the same outer structure; only its sub-programs get refined.
We prove this in the following lemma.

\begin{lemma}[Refining programs containing holes]
\label{lem:chain_split}
For the relation~$\refine$ being either $\parref$ or $\totref$, we have the following for every $k \in \N$:
\begin{enumerate}
  \item
    If $\qpenv{\qpabsprog{S'_1};\qpabsprog{S'_2}} \refine^k S$,
    then there exist programs $S_1$ and $S_2$, and integers $k_1, k_2 \in \N$
    such that $S = \qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}$
    and $S'_1 \refine^{k_1} S_1$ and $S'_2 \refine^{k_2} S_2$ and $k_1 + k_2 = k$.
  \item
    If $\qpenv{\qprepeat{N}{\qpabsprog{S_\text{body}'}}} \refine^k S$,
    then there exists a program $S_\text{body}$ such that \\
    $S~=~\qpenv{\qprepeat{N}{\qpabsprog{S_\text{body}}}}$
    and $S_\text{body}' \refine^k S_\text{body}$.
  \item
    If $\qpenv{\qpselect{\vec M}{\vec q}{\{\omega \colon \qpabsprog{S'_\omega}\}_{\omega\in\Omega}}}
    \parref^k S$
    then there exist programs $S_\omega$ and integers $k_\omega \in \N$ for all $\omega\in\Omega$
    such that $S = \qpenv{\qpselect{\vec M}{\vec q}{{\{\omega \colon \qpabsprog{S_\omega}\}_{\omega\in\Omega}}}}$,
    and $S'_\omega \refine^{k_\omega} S_\omega$ for each $\omega\in\Omega$, and $\sum_\omega k_\omega = k$.
  \item
    If $\qpenv{\qpwhile{B}{\vec q}{\qpabsprog{S_\text{body}'}}} \refine^k S$
    then there exists a program $S_\text{body}$
    such that $S = \qpenv{\qpwhile{B}{\vec q}{\qpabsprog{S_\text{body}}}}$
    and $S_\text{body}' \refine^k S_\text{body}$.
\end{enumerate}
\end{lemma}
\begin{proof}
(1) We first prove the claim for $k = 1$.
If $\qpenv{\qpabsprog{S'_1};\qpabsprog{S'_2}} \refine S$, then we could only have applied one of \ruleref{C.seqL} or \ruleref{C.seqR} and therefore $S$ must be some sequence statement of the form $\qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}$.
If we use \ruleref{C.seqL} then we have $S'_1 \refine S_1$ and $S'_2 = S_2$, and similarly for \ruleref{C.seqR}.
Since, in both cases, $S$ is again a sequence statement, we can apply the preceding observation inductively to prove the claim for arbitrary~$k$.
% In each step, exactly one of the left program $S'_1$ or the right program $S'_2$ is refined, hence proving the claim.

Similarly, for~(2) we can only refine by using \ruleref{C.repeat},
for~(3) only using \ruleref{C.case},
and for~(4) only using \ruleref{C.while}.
All these rules preserve the root program structure and only refine the body of the program, hence proving the lemma.
\end{proof}

%------------------------------------------------------------------------------
We can now proceed to prove our soundness theorem for refinement for partial correctness:

% \thmsoundnesspartial*

\begin{proof}[Proof of \cref{thm:soundness-partial}]
We prove this by induction over the length of the refinement chain.
That is, we prove by induction for every $k \ge 1$, if $\qpenv{\qphole{P}{Q}} \parref^k S$ and $S$ has no holes, then $\parcorr \hoare{P}{S}{Q}$.
% (where $\parref^k$ is a $k$-step refinement).

\medskip\emph{Base case~$(k = 1)$:}
We have $\qpenv{\qphole{P}{Q}}~\parref~S$.
Since~$S$ has no holes, the refinement can only be due to one of the rules \ruleref{H.skip}, \ruleref{H.init} or \ruleref{H.unit}.
We analyze these three cases separately:

\begin{proofcase}
\ruleref{H.skip}
$S = \qpenv{\qpskip}$ and $P \imp Q$:
%
The semantics of the former is~$\Bracks{S}(\rho) = \Bracks{\qpenv{\qpskip}}(\rho) = \rho$ and the latter means that~$\tr(P \rho) \le \tr(Q \rho)$ for all states~$\rho$.
Therefore, we have for all states~$\rho$ that
\[
\satisfies{\rho}{P} = \tr(P\rho) \le \tr(Q\rho) = \tr(Q~\Bracks{S}(\rho)) = \satisfies{\Bracks{S}(\rho)}{Q}.
\]
This proves $\totcorr \hoare{P}{\qpenv{\qpskip}}{Q}$ and therefore also $\parcorr \hoare{P}{\qpenv{\qpskip}}{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.init}
$S = \qpenv{\qpinit{\vec q}}$
and
$P \imp \sum_{\vec x\in\Sigma_{\vec q}} \ketbra{\vec x}{\vec 0}_{\vec q} Q \ketbra{\vec 0}{\vec x}_{\vec q}$:
From the latter, we have for all states $\rho$:
\begin{align*}
    \satisfies{\rho}{P}
    = \tr(P\rho)
    &\le \tr\left(\parens*{\sum_{\vec x\in\Sigma_{\vec q}} \ketbra{\vec x}{\vec 0}_{\vec q} Q \ketbra{\vec 0}{\vec x}_{\vec q}} \rho\right) \\
    &= \tr\left({\sum_{\vec x\in\Sigma_{\vec q}} Q \ketbra{\vec 0}{\vec x}_{\vec q}} \rho \ketbra{\vec x}{\vec 0}_{\vec q} \right) \\
    &= \tr\left(Q ~ \Bracks{\qpenv{\qpinit{\vec q}}}(\rho) \right)
    = \satisfies{\Bracks{S}(\rho)}{Q}.
\end{align*}
This proves $\totcorr \hoare{P}{\qpenv{\qpinit{q}}}{Q}$ and therefore also $\parcorr \hoare{P}{\qpenv{\qpinit{q}}}{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.unit}
$S = \qpenv{\qpunitary{\vec q}{U}}$
and
$P \imp U^\dagger Q U$:
The latter condition means that $\tr(P\rho) \le \tr(U^\dagger Q U \rho)$ for all states $\rho$, and therefore
\begin{align*}
    \satisfies{\rho}{P}
    = \tr(P\rho)
    \le \tr(\parens{U^\dagger Q U} \rho)
    = \tr(Q(U\rho U^\dagger))
    = \tr(Q~\Bracks{\qpenv{\qpunitary{\vec q}{U}}}(\rho))
    = \satisfies{\Bracks{S}(\rho)}{Q}.
\end{align*}
This proves $\totcorr \hoare{P}{\qpenv{\qpunitary{\vec q}{U}}}{Q}$ and therefore also $\parcorr \hoare{P}{\qpenv{\qpunitary{\vec q}{U}}}{Q}$.
\end{proofcase}

\noindent We have thus established the base case, namely that if~$\qpenv{\qphole{P}{Q}} \parref^1 S$ then~$\parcorr \hoare{P}{S}{Q}$.

\medskip\emph{Induction Step $(k > 1)$:}
Using the induction hypothesis, we assume that all refinements of length at most $k - 1$ are partially correct.
We now prove that any program that refines in $k$ steps must also be partially correct.
Now, $\qpenv{\qphole{P}{Q}} \parref^k S$ means that there exists a program~$S'$ such that $\qpenv{\qphole{P}{Q}} \parref S' \parref^{k-1} S$.
Since~$S'$ must have holes, the refinement~$\qpenv{\qphole{P}{Q}} \parref S'$ can only be due to one of the following rules:

\begin{proofcase}
\ruleref{H.seq}
$S' = \qpenv{\qphole{P}{R};\qphole{R}{Q}}$:
As $S' \parref^{k-1} S$, \cref{lem:chain_split} states that there are programs~$S_1, S_2$ and integers~$k_1, k_2$
such that $S = \qpenv{\qpabsprog{S_1} ; \qpabsprog{S_2}}$
and $\qpenv{\qphole{P}{R}}~\parref^{k_1}~S_1$
and $\qpenv{\qphole{R}{Q}}~\parref^{k_2}~S_2$
(where~$k_1 + k_2 = k - 1$).
From the induction hypothesis we have that $\parcorr \hoare{P}{S_1}{R}$ and $\parcorr \hoare{R}{S_2}{Q}$.
Therefore, for any partial state $\rho$,
\begin{align*}
  \satisfies{\rho}{P} - \tr(\rho)
  &=\tr(P\rho) - \tr(\rho) \\
  &\le \tr(R~\Bracks{S_1}(\rho)) - \tr(\Bracks{S_1}(\rho)) \\
  &\le \tr(Q~\Bracks{S_2}(\Bracks{S_1}(\rho))) - \tr(\Bracks{S_2}(\Bracks{S_1}(\rho))) \\
  &= \tr(Q~\Bracks{\qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}}(\rho))
      - \tr(\Bracks{\qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}}(\rho)) \\
  &= \satisfies{\Bracks{S}(\rho)}{Q} - \tr(\Bracks{S}(\rho)).
\end{align*}
Therefore, $\parcorr \hoare{P}{S}{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.split}
$S' = \qpenv{\qphole{P_\gamma}{Q_\gamma}}$ and $P \imp \sum_\gamma p_\gamma P_\gamma$ and~$\sum_\gamma p_\gamma Q_\gamma \imp Q$:
Recall the latter mean that~$P \preceq \sum_\gamma p_\gamma P_\gamma$ and~$\sum_\gamma p_\gamma Q_\gamma \preceq Q$.
From the induction hypothesis we have~$\parcorr \hoare{P_\gamma}{S}{Q_\gamma}$ for all~$\gamma$.
Therefore, for any partial state $\rho$,
\begin{align*}
\satisfies{\rho}{P} - \tr(\rho)
&=\tr(P\rho) - \tr(\rho) \\
&\le % \sum_\gamma p_\gamma \tr(P_\gamma \rho) - \tr(\rho) \\ &=
\sum_\gamma p_\gamma \parens*{ \tr(P_\gamma \rho) - \tr(\rho) } \\
&\leq \sum_\gamma p_\gamma \parens*{ \tr(Q_\gamma \Bracks{S}(\rho)) - \tr(\Bracks{S}(\rho)) } \\
%&= \sum_\gamma p_\gamma \tr(Q_\gamma \Bracks{S}(\rho) - \tr(\Bracks{S}(\rho)) \\
&\leq \tr(Q \Bracks{S}(\rho)) - \tr(\Bracks{S}(\rho))
= \satisfies{\Bracks{S}(\rho)}{Q} - \tr(\Bracks{S}(\rho)).
\end{align*}
Therefore, $\parcorr \hoare{P}{S}{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.repeat}
$S' = \qpenv{\qprepeat{N}{\qphole{R_j}{R_{j+1}}}}$, with $j~\in~\irange{0}{N-1}$ a formal parameter, $P~\imp~R_0$, and~$R_N~\imp~Q$:
As $S' \parref^{k-1} S$, \cref{lem:chain_split} states that $S = \qpenv{\qprepeat{N}{\qpabsprog{C}}}$ for some program~$C$ satisfying~$\qpenv{\qphole{R_j}{R_{j+1}}}~\parref^{k-1}~C$.
By the induction hypothesis, $\parcorr \hoare{R_j}{C}{R_{j+1}}$.
It follows that for all~$j \in \irange{0}{N-1}$ and any partial state $\sigma_j$, we have
\begin{align*}
  \tr(R_j \sigma_j) - \tr\sigma_j \le \tr(R_{j+1} \Bracks{C}(\sigma_j)) - \tr(\Bracks{C}(\sigma_j)).
\end{align*}
Choosing $\sigma_j = \Bracks{C}^j(\rho)$, for some arbitrary partial state $\rho$, the above inequality becomes
\begin{align*}
  \tr(R_j~\Bracks{C}^j(\rho)) - \tr(\Bracks{C}^j(\rho)) \le \tr(R_{j+1} \Bracks{C}^{j+1}(\rho)) - \tr(\Bracks{C}^{j+1}(\rho))
\end{align*}
and chaining the above inequalities for~$j \in \irange{0}{N-1}$ gives us
\begin{align*}
  \satisfies{\rho}{R_0} - \tr(\rho)
&= \tr(R_0~\rho) - \tr(\rho) \\
&\leq \tr(R_N~\Bracks{C}^N(\rho)) - \tr(\Bracks{C}^N(\rho)) \\
&= \satisfies{\Bracks{S}(\rho)}{R_N} - \tr(\Bracks{S}(\rho)),
\end{align*}
where we used that~$\Bracks{S} = \Bracks{C}^N$.
This shows that that $\parcorr \hoare{R_0}{S}{R_N}$.
Since~$P~\imp~R_0$ and~$R_N~\imp~Q$, it follows that~$\parcorr \hoare{P}{S}{Q}$ just like in the preceding case.
\end{proofcase}

\begin{proofcase}
\ruleref{H.case}
$S' = \qpenv{\qpselect{\vec M}{\vec q}{\{\omega \colon \qphole{P_\omega}{Q}\}_{\omega\in\Omega}}}$
and $P \imp \sum_{\omega\in\Omega} \cM_\omega(P_\omega)$:
According to \cref{lem:chain_split}, there exist programs~$S_\omega$ and numbers~$k_\omega$ for every~$\omega \in \Omega$,
such that~$S = \qpenv{\qpselect{\vec M}{\vec q}{\{\omega \colon \qpabsprog{S_\omega}\}_{\omega\in\Omega}}}$
and~$\qpenv{\qphole{P_\omega}{Q}} \parref^{k_\omega} S_\omega$
and~$\sum_\omega k_\omega = k - 1$.
From the induction hypothesis we have that $\parcorr \hoare{P_\omega}{S_\omega}{Q}$ for every $\omega\in\Omega$.
Therefore, for any partial state $\sigma$ and any $\omega\in\Omega$,
\[
\tr(P_\omega \sigma) - \tr(\sigma)
\le \tr(Q~\Bracks{S_\omega}(\sigma)) - \tr(\Bracks{S_\omega}(\sigma))
\]
%
So for every partial state $\rho$, we have
\begin{align*}
  \satisfies{\rho}{P} - \tr(\rho)
  &=\tr(P\rho) - \tr(\rho) \\
  &\le \tr{\parens*{\parens*{\sum_{\omega\in\Omega}\cM_\omega(P_\omega)} \rho}} - \tr(\rho) \\
  % &= \sum_{\omega\in\Omega} \tr{\parens*{\cM_\omega(P_\omega) \rho}} - \sum_{\omega\in\Omega} \tr(\cM_\omega(\rho)) \\
  &= \sum_{\omega\in\Omega} \tr{\parens*{P_\omega \cM_\omega(\rho)}} - \tr(\cM_\omega(\rho)) \\
  &\le \sum_{\omega\in\Omega} \tr{\parens*{Q~\Bracks{S_\omega}(\cM_\omega(\rho))) - \tr(\Bracks{S_\omega}(\cM_\omega(\rho))}} \\
  &= \tr(Q~\Bracks{S}(\rho)) - \tr(\Bracks{S}(\rho)) \\
  &= \satisfies{\Bracks{S}(\rho)}{Q} - \tr(\Bracks{S}(\rho)).
\end{align*}
Therefore, $\parcorr \hoare{P}S{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{HP.while}
$S' = \qpenv{\qpwhile{B}{\vec q}{ \qphole{R}{\cB_0(Q) + \cB_1(R)} }}$ and $P~\imp~\cB_0(Q)~+~\cB_1(R)$:
As $S' \parref^{k-1} S$, by \cref{lem:chain_split} we must have $S = \qpenv{\qpwhile{B}{\vec q}{\qpabsprog{C}}}$ for some program~$C$ such that $\qpenv{\qphole{R}{\cB_0(Q) + \cB_1(R)}} \parref^{k-1} C$.
From the induction hypothesis we have that~$\parcorr~\hoare{R}{C}{\cB_0(Q) + \cB_1(R)}$, meaning that for every partial state~$\sigma$ we have
\begin{equation*}
  \tr(R\sigma) - \tr(\sigma)
  \le \tr{\parens*{\parens[\big]{\cB_0(Q) + \cB_1(R)} ~ \Bracks{C}(\sigma)}} - \tr(\Bracks{C}(\sigma)),
\end{equation*}
or equivalently, after some algebraic manipulations,
\begin{align}\label{eq:partial-loop-body-correct}
%   \tr(R\sigma) - \tr(\sigma)
% \le \tr{\parens*{Q \cB_0(\Bracks{C}(\sigma))}}
% + \tr{\parens*{R \cB_1(\Bracks{C}(\sigma))}}
% - \tr(\cB_0(\Bracks{C}(\sigma)))
% - \tr(\cB_1(\Bracks{C}(\sigma)))
% =
% \tr(\cB_0(\Bracks{C}(\sigma)))
% - \tr{\parens*{Q \cB_0(\Bracks{C}(\sigma))}}
% \leq
% - \tr(R\sigma)
% + \tr(\sigma)
% + \tr{\parens*{R \cB_1(\Bracks{C}(\sigma))}}
% - \tr(\cB_1(\Bracks{C}(\sigma)))
% =
  \tr\braces*{(I - Q)~\cB_0(\Bracks{C}(\sigma))}
  \leq
  \tr\braces{(I - R) (\sigma - \cB_1(\Bracks{C}(\sigma)))}.
\end{align}
%
Recalling the semantics of \textbf{while} applied to an arbitrary (partial) state $\rho$, we have
\[
  \Bracks{S}(\rho)
  % = \Bracks{\qpenv{\qpwhile{B}{\vec q}{\qpabsprog{C}}}}(\rho)
  = \sum_{k = 0}^\infty \rho_k,
  \quad \text{where}~ \rho_k = \parens*{ \cB_0 \circ \parens*{ \Bracks{C} \circ \cB_1 }^k }(\rho).
\]
For each $k \ge 0$, define $\sigma_k = (\cB_1 \circ (\Bracks{C} \circ \cB_1)^k)(\rho)$,
and therefore $\rho_{k+1} = \cB_0(\Bracks{C}(\sigma_k))$.
Applying \cref{eq:partial-loop-body-correct} to~$\sigma = \sigma_k$, we get
\begin{align*}
  \tr\braces*{(I - Q)~\rho_{k+1}} \leq \tr\braces{(I - R) (\sigma_k - \sigma_{k+1})}.
\end{align*}
Summing the above over~$k\in\{0,\dots,n-1\}$, for some arbitrary~$n$, and adding~$\tr\braces*{(I - Q)~\rho_0}$, we get
\begin{align*}
\tr\braces*{(I - Q)~\sum_{k = 0}^n \rho_k}
&\leq \tr\braces*{(I - Q)~\rho_0} + \tr\braces{(I - R) (\sigma_0 - \sigma_n)} \\
&= \tr\braces*{(I - Q)~\cB_0(\rho)} + \tr\braces{(I - R) (\cB_1(\rho) - \sigma_n)} \\
&= \tr(\rho) - \tr\braces*{\parens*{ \cB_0(Q) + \cB_1(R) } \rho} - \tr\braces{(I - R) \sigma_n} \\
&\leq \tr(\rho) - \tr\braces*{\parens*{ \cB_0(Q) + \cB_1(R) } \rho} \\
&\leq \tr(\rho) - \tr\braces*{P \rho}
= \satisfies{\rho}{I-P},
\end{align*}
using $P~\imp~\cB_0(Q)~+~\cB_1(R)$ in the last inequality.
Taking the limit~$n\to\infty$, we obtain that
\begin{align*}
  \satisfies{\Bracks{S}(\rho)}{I-Q} \leq \satisfies{\rho}{I-P}
\end{align*}
which means that $\parcorr \hoare{P}S{Q}$.
\end{proofcase}
% From the above cases we can conclude that if $\qpenv{\qphole{P}{Q}} \parref^k S$, then $\parcorr \hoare{P}{S}{Q}$.

\medskip

\noindent This concludes the proof of the induction step and hence the proof of the theorem.
\end{proof}

\begin{restatable}[Soundness of refinement for total correctness]{theorem}{thmsoundnesstotal}
\label{thm:soundness-total}
For any two predicates~$P, Q$ and any concrete program~$S$,
if $\qpenv{\qphole{P}{Q}} \totref^* S$ then $\totcorr \hoare{P}{S}{Q}$.
\end{restatable}

\Cref{thm:soundness-total} can be proved similarly to \cref{thm:soundness-partial} by induction over the length of the refinement chain.
In the base case, the set of rules that have to be considered is identical, and we have already seen in the proof of \cref{thm:soundness-partial} that these rules ensure total correctness.
In the induction step, it is straightforward to adapt the argument given earlier for the rules \ruleref{H.seq}, \ruleref{H.repeat}, \ruleref{H.split}, and \ruleref{H.case}, while \ruleref{H.whileEps} requires a more careful analysis.
The detailed proof can be found in \cref{app:total soundness}.

%=============================================================================
\section{Examples}
\label{sec:examples}
%=============================================================================
In this section, we demonstrate how to use the QbC approach to construct quantum programs from their specification.
We first construct a fair quantum coin (\cref{subsec:example:fair-coin}) and re-construct our running example of tossing a quantum coin until the zero outcome is obtained (\cref{subsec:example:coin-toss-until-zero}).
After these two pedagogical examples, we discuss two more complicated examples by constructing a quantum teleportation protocol (\cref{subsec:examples:teleportation}) and two quantum search algorithms (\cref{subsec:examples:qsearch}).
Finally, we describe new refinement rules to boost the success probability of quantum algorithms (\cref{subsec:examples:boosting}).
This illustrates how QbC can be usefully extended by higher-level algorithmic pattern and construction principles.
Particularly for the more complicated algorithms, we find that the QbC approach allows naturally discovering program detail on the fly, without explicitly using a priori knowledge of the final algorithms.
It also suggests key design decisions that give rise to different quantum programs satisfying the same specification.

%-----------------------------------------------------------------------------
\subsection{Fair Quantum Coin}\label{subsec:example:fair-coin}
%-----------------------------------------------------------------------------

%\paragraph{Problem}
A fair quantum coin is a program that prepares a quantum bit in a state that, when measured in the standard basis, gives rise to either outcome with 50\% probability.
There are infinitely many such states, but two natural ones are the \emph{Hadamard basis} states~$\ket\pm = ( \ket0 \pm \ket1 )/\sqrt2$.
We will use~$\qVars = \{ q \}$ in this example, where $q$ is a qubit quantum variable.

\paragraph{Specification}
To specify that each outcome of a standard basis measurement occurs with 50\%~probability, we can use the following program with a single hole:
\[ S_\text{fair-coin} = \qpenv{\qphole{I/2}{\proj x}}, \]
where $x \in \{0, 1\}$ is a formal parameter (see \cref{subsec:multispec}).
Indeed, suppose we manage to refine the above into a concrete program~$S'$, i.e., a program without holes, which does not explicitly use the parameter~$x$.
Then our soundness results (\cref{thm:soundness-partial,thm:soundness-total}) guarantee that the Hoare triple
\[ \hoare{I/2}{S'}{\proj x} \]
is valid for every $x\in\{0,1\}$, meaning that if we run the program with an arbitrary input state and measure the resulting output state, then we obtain either outcome~$x\in\{0,1\}$ with probability at least, and hence equal to~$\frac12$.

\paragraph{Construction}
The well-known idea is that the Hadamard gate
\begin{align}\label{eq:hadamard}
  H = \frac1{\sqrt2} \begin{pmatrix}1 & 1 \\ 1 & -1\end{pmatrix}
\end{align}
maps the standard basis to the Hadamard basis, which allows us to realize the coin toss.
To confirm this, we consider the following sequence of refinements:
\begin{align*}
  S_\text{fair-coin}
  &= \qpenv{\qphole{I/2}{\proj x}} \\
  &\totref \qpenv{\qphole{I/2}{R} ; \qphole{R}{\proj x}} \ruletag{H.seq} \\
  &\totref \qpenv{\qpinitS{q} ; \qphole{R}{\proj x}} \ruletag{H.init} \\
  &\totref \qpenv{\qpinitS{q} ; \qpunitary{q}{H}} \ruletag{H.unit}
\end{align*}
The first refinement is always valid, but how should we pick the predicate~$R$ so that the subsequent refinements can be applied?
To apply \ruleref{H.init}, we need that
$I/2 \imp \sum_{y \in \{0, 1\}} \ketbra{y}{0} R \ketbra{0}{y}$,
meaning that $\braket{0|R|0} \geq \frac12$ for $x\in\{0,1\}$.
To apply \ruleref{H.unit}, we should choose~$R$ such that~$R \imp H \proj x H$.
Since the latter is a pure state, this suggests $R = H \proj x H$ (which is also the weakest precondition for the Hadamard subprogram and postcondition), and for this choice we have that
\begin{align*}
  \braket{0|R|0} = \abs*{\braket{0|H|x}}^2 = \frac12.
\end{align*}
Thus the above refinements are valid and we have constructed a program that implements the fair quantum coin toss specification correctly, by construction:
\begin{align*}
  S_\text{fair-coin} \totref^* \qpenv{\qpinitS{q} ; \qpunitary{q}{H}},
\end{align*}


%-----------------------------------------------------------------------------
\subsection{Quantum Coin Toss until Zero}\label{subsec:example:coin-toss-until-zero}
%-----------------------------------------------------------------------------
Next, we revisit our running example, the quantum coin toss until zero from \cref{ex:coin-toss:program}.

\paragraph{Specification}
As discussed in \cref{ex:coin-toss:spec}, a natural specification for the quantum coin toss until zero program is given by
\begin{align}\label{eq:orig toss until zero}
  S_\text{toss-until-zero} = \qpenv{\qphole{I}{\proj0}}
\end{align}
(for uniformity with the other examples in this section, we now use $S_\text{toss-until-zero}$ to denote the specification, instead of the concrete program that we seek to construct).
Of course, \cref{eq:orig toss until zero} is not a very interesting specification, as much simpler programs than our original program also satisfy it.
For example, by a single refinement using \ruleref{H.init}, we arrive at the following program:
\[
  S_\text{toss-until-zero}
% = \qpenv{\qphole{I}{\proj0}}
\totref \qpenv{\qpinitS{q}} \ruletag{H.init}
\]
Nevertheless, we refine this initial specification to arrive at a more structured one that naturally leads to our original program:
\begin{align*}
  S_\text{toss-until-zero}
  % &= \qpenv{\qphole{I}{\proj0}} \\
%
  &\totref
  \qpenv{
    {\qphole{I}{\proj+}} ;
    {\qphole{\proj+}{\proj0}}
  }
  \ruletag{H.seq} \\
%
  &\parref
  \qpenv{
    \qphole{I}{\proj+} ;
    \qpwhileB{q}{
      \qphole{\proj1}{I}
    }
  }
  \ruletag{HP.while} \\
%
  &\totref
  \qpenv{
    \qphole{I}{\proj+} ;
    \qpwhileB{q}{
      \qphole{\proj1}{\proj-}
    }
  }
  \ruletag{H.sw}
\end{align*}
Here we applied the rule \ruleref{HP.while} with~$R = \proj1$.
This is allowed since we have $\proj+ \imp \cB_0(\proj0) + \cB_1(\proj1) = I$, with~$\cB$ the standard basis measurement (i.e., $\cB_j(\proj j) = \proj j$).
Thus we have arrived at the following more structured specification, which (partially) refines \cref{eq:orig toss until zero}:
\begin{align*}
  S'_\text{toss-until-zero} = \qpenv{
    \underbrace{\qphole{I}{\proj+}}_{S_\text{init}} ;
    \qpwhileB{q}{
      \underbrace{\qphole{\proj1}{\proj-}}_{S_\text{body}}
    }
  }
\end{align*}
% Similarly, to apply the step \ruleref{H.sw}, both the conditions $\proj1 \imp \proj1$ and $\proj- \imp I$ are true.

\paragraph{Construction}
We now construct a program from this specification by refining the two holes~$S_\text{init}$ and~$S_\text{body}$:
\begin{align*}
S_\text{init}
%= \qpenv{\qphole{I}{\proj+}}
&\totref \qpenv{\qphole{I}{\proj0} ; \qphole{\proj0}{\proj+}} \ruletag{H.seq} \\
&\totref \qpenv{\qpinitS{q}        ; \qphole{\proj0}{\proj+}} \ruletag{H.init} \\
&\totref \qpenv{\qpinitS{q}        ; \qpunitary{q}{H}       } \ruletag{H.unit}
\end{align*}
and
\begin{align*}
S_\text{body}
%= \qpenv{\qphole{\proj1}{\proj-}}
\totref \qpenv{\qpunitary{q}{H}} \ruletag{H.unit}
\end{align*}
It is easy to see that the conditions required for the above refinements are satisfied.
%
Putting together the above, we have re-constructed the quantum coin toss until zero program from a specification:
\begin{gather*}
% S_\text{toss-until-zero} \parref^*
S'_\text{toss-until-zero} \totref^*
\qpenv{
  \qpinitS{q} ;
  \qpunitary{q}{H} ;
  \qpwhileB{q}{\qpunitary{q}{H}}
}
\end{gather*}

%-----------------------------------------------------------------------------
\subsection{Quantum Teleportation}
\label{subsec:examples:teleportation}
%-----------------------------------------------------------------------------

%\paragraph{Problem}
Imagine two parties, Alice and Bob, who share a maximally entangled state, say qubits~$a,b$ in state
\[ \ket{\phi^+} = \frac1{\sqrt2}(\ket{00} + \ket{11}). \]
Alice has another qubit~$q$ in an unknown \emph{quantum} state, and wants to transfer its state to Bob's qubit~$b$, by sending only \emph{classical} information but utilizing the maximally entangled state as a resource.
Furthermore, if~$q$ was correlated or entangled with other quantum variables, then after teleportation the same should be true for~$b$.
This is called \emph{quantum teleportation} and is a basic building block for quantum communication (see \citet{nielsen2010quantum,wilde2013quantum}).

\paragraph{Specification}
To specify teleportation, consider an arbitrary quantum state~$\rho$ between Alice's and some arbitrary other quantum variable~$r$, which does not participate in the protocol (in quantum information, $r$ is called a reference system).
After teleportation, we want the state of Bob's qubit~$b$ and~$r$ to be in the same state.
Without loss of generality, we can take~$\rho$ to be a maximally entangled state, $\rho = \proj{\phi^+}$ (that is, it suffices to realize ``entanglement swapping'').
Indeed, a basic principle of quantum information theory asserts that if two quantum programs (completely positive maps) have the same behavior when applied to one half of a maximally entangled state, then they must have the same behavior on all states~\cite{nielsen2010quantum,wilde2013quantum}.
Recall from \cref{cor:projection-predicates} that we can assert that quantum variables are in a given pure state by using its projection as the predicate.
This translates to the following initial specification:
% \[ S_\text{teleport} = \qpenv{\qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{\proj{\phi^+}_{br} \ot I_{qa}}} \]
\begin{align}\label{eq:orig teleport}
  S_\text{teleport} = \qpenv{\qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{\proj{\phi^+}_{br}}}
\end{align}

Now, an arbitrary program that meets the above specification will not be a teleportation protocol, since in teleportation we want to constrain all quantum operations to Alice and Bob's variables, while only allowing them to communicate classical bits from Alice to Bob.
This disallows, e.g., simply swapping qubits~$q$ and~$b$ by applying a quantum gate.
We can implement this latter constraint by the following sequence of refinements:
\begin{align*}
  &S_\text{teleport} \\
  \totref
  \ &\qpenv{
      \qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{P} ;
      \qphole{P}{\proj{\phi^+}_{br}}
  }
  \ruletag{H.seq} \\
  \totref
  \ &\qpenv{
      \qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{P} ;
      \qpselectS{q, a}{(x, y) \colon \qphole{Q(x, y)}{\proj{\phi^+}_{br}}}
  },
  \ruletag{H.case}
\end{align*}
where $x, y \in \{0, 1\}$ for arbitrary predicates $Q(x, y)$.
We can ensure that \ruleref{H.case} is valid by taking
\begin{align}\label{eq:P via Qxy}
  P := \sum_{x, y} \proj{xy}_{qa} Q(x, y) \proj{xy}_{qa}.
\end{align}
We have arrived at the following specification, which refines \cref{eq:orig teleport}:
\begin{align*}
  S'_\text{teleport} = \qpenv{
      \underbrace{ \qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{P} }_{S_\text{Alice}} ;
      \qpselectS{q, a}{(x, y) \colon \underbrace{ \qphole{Q(x, y)}{\proj{\phi^+}_{br}} }_{S_{\text{Bob},x,y}}}
  }
\end{align*}
which consists of three steps:
\begin{enumerate}
  \item Alice first applies some quantum program $S_\text{Alice}$ (which will be constructed to only act on her qubits).
  \item Alice measures her quantum bits~$q,a$ in the standard basis (without loss of generality) and obtain as outcomes two classical bits~$x,y$, which we imagine she communicates to Bob.
  \item Bob applies another quantum program $S_{\text{Bob},x,y}$ (which will be constructed to only act on his qubit) that is allowed to explicitly depend on the outcomes~$x$ and~$y$.
\end{enumerate}
This precisely captures the structure as well as functionality of a quantum teleportation protocol.

\paragraph{Construction}
Before starting the construction we first simplify the precondition~$Q(x,y)$ of Bob's program.
As the latter is run straight after Alice's measurements, which yielded outcomes~$x,y$, we know that Alice's qubits must be in state~$\ket{x,y}$.
This motivates and in fact implies that we may take
\begin{align}\label{eq:teleport form of Q}
  Q(x,y) = \proj{xy}_{qa} \ot R_{br}(x,y)
\end{align}
for certain predicates~$R_{rb}(x,y)$ on qubits~$b,r$ that still need to be determined.

To construct Alice and Bob's programs, we make the straightforward ansatz that each applies some unitary, which in Bob's case may depend on the measurement outcomes~$x,y$.
Thus we refine
\begin{align*}
  S_\text{Alice} = \qphole{\proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab}}{P} &\totref \qpenv{\qpunitary{q, a}{V}} \ruletag{H.unit} \\
\intertext{and}
  S_{\text{Bob},x,y} = \qphole{Q(x, y)}{\proj{\phi^+}_{br}} &\totref \qpenv{\qpunitary{b}{U(x,y)}}, \ruletag{H.unit}
\end{align*}
where~$V$ is a two-qubit unitary and the~$U(x,y)$ are one-qubit unitaries that we still need to construct.
The second refinement is valid if $U_b(x,y) Q(x,y) U_b^\dagger(x,y) \imp \proj{\phi^+}_{br}$, which we can satisfy by picking
\[ R_{br}(x,y) = U^\dagger_b(x,y) \proj{\phi^+}_{br} U_b(x,y), \]
in view of \cref{eq:teleport form of Q}.
By \cref{eq:P via Qxy}, this in turn implies that
\begin{align}\label{eq:P via Uxy}
  P
% = \sum_{x, y} \proj{xy}_{qa} \ot R_{br}(x,y)
= \sum_{x, y} \proj{xy}_{qa} \ot U_b^\dagger(x,y) \proj{\phi^+}_{br} U_b(x,y).
\end{align}
The first refinement is valid if $V_{qa} \parens{ \proj{\phi^+}_{qr} \ot \proj{\phi^+}_{ab} } V_{qa}^\dagger \imp P$.
As the left-hand side is a pure state, \cref{cor:projection-predicates} shows that this condition is equivalent to
\begin{align}
\nonumber
  1
= \braket{ \phi^+_{qr} \ot \phi^+_{ab} | V_{qa}^\dagger P V_{qa} | \phi^+_{qr} \ot \phi^+_{ab}}
&= \sum_{x,y} \abs{ \braket{ x_q \ot y_a \ot \phi^+_{br} |  U_b(x,y) V_{qa} | \phi^+_{qr} \ot \phi^+_{ab} } }^2 \\
\nonumber
&= \sum_{x,y} \abs{ \braket{ x_q \ot y_a \ot \phi^+_{br} |  U_b(x,y) V^T_{rb} | \phi^+_{qr} \ot \phi^+_{ab} } }^2 \\
\label{eq:tele final}
&= \frac14 \sum_{x,y} \abs{ \braket{ \phi^+_{br} | U_b(x,y) V^T_{rb} | x_r \ot y_b } }^2,
\end{align}
where we first used \cref{eq:P via Uxy} and then the identity~$V_{qa} \ket{\phi^+_{qr} \ot \phi^+_{ab}} = V^T_{rb} \ket{\phi^+_{qr} \ot \phi^+_{ab}}$,
known as the ``transpose trick'' in quantum computing, which allows moving an arbitrary operator acting on qubits~$q,a$ to the other side of the maximally entangled states, that is, to act on qubits~$r,b$, if we replace the operator by its transpose (in the computational basis).
This well-known identity is easily verifed by direct calculation.
The final step follows by observing that~$\bra{x_q} \ket{\phi^+_{qr}} = \ket{x_r}/\sqrt2$ and similarly~$\bra{y_a} \ket{\phi^+_{ab}} = \ket{x_b}/\sqrt2$.
Since all of the summands in \cref{eq:tele final} are at most one, they must all be equal to one.
In other words,
\begin{align*}
  V^T_{rb} \ket{xy}_{rb} \quad\text{and}\quad U_b^\dagger(x,y) \ket{\phi^+_{br}}
\end{align*}
must be the same states for all~$x,y\in\{0,1\}$ (up to irrelevant overall phases).
Note that the left-hand side states make up an orthonormal basis, while the right-hand states are all maximally entangled (since they obtained by applying a unitary to one of the qubits of~$\ket{\phi^+}$).
It follows that we should pick~$V^T_{rb}$ to be a unitary that maps the standard basis to a basis of maximally entangled states.
And this is also sufficient since any two maximally entangled states differ by a unitary on either of the qubits.
As is well know, the Bell basis consists of maximally entangled states and it can be prepared by the unitary~$V^T_{rb} = \text{CNOT}_{rb} H_b$.
Thus we take
\[ V = (H \ot I) \text{CNOT}. \]
Finally, we note that the Bell states can be obtained from the standard maximally entangled state as~$V^T_{rb} \ket{yx}_{rb} = Z_b^y X_b^x \ket{\phi^+}_{rb}$, where~$X$ and~$Z$ denote the Pauli~$X$ and~$Z$ matrices.
Thus Bob's unitaries should be
\[ U(x,y) = X^x Z^y. \]
Altogether, we have constructed the following program, which is nothing but the standard protocol for quantum teleportation:
\[
S'_\text{teleport} \totref^*
\qpenv{
\begin{aligned}
&\qpunitary{q, a}{(H \ot I) \text{CNOT}} ; \\
&\qpselectS{(q, a)}{\\
&\quad 00 \colon \qpunitary{b}{I} \\
&\quad 01 \colon \qpunitary{b}{Z} \\
&\quad 10 \colon \qpunitary{b}{X} \\
&\quad 11 \colon \qpunitary{b}{XZ} \\&
}
\end{aligned}
}
\]
As it was obtained by refining the specification, it satisfies the specification by construction.
Of course we can also replace the first line by a sequence of two statements~$\qpenv{\qpunitary{q, a}{\text{CNOT}}}$ and~$\qpenv{\qpunitary{q}{H}}$ without changing the program's semantics.

%------------------------------------------------------------------------------
\subsection{Quantum Search}
\label{subsec:examples:qsearch}
%------------------------------------------------------------------------------

We consider the following search problem~\cite{nielsen2010quantum,grover1996}.
Given query access to a Boolean function or ``database''~$f\colon\{0,1\}^n \to \{0,1\}$,
we wish to find a bitstring~$x \in \{0, 1\}^n$ such that $f(x) = 1$.
Such an~$x$ is often called a ``solution'' or ``marked element''.
In the quantum setting, we are given query access to~$f$ via the following \emph{standard quantum oracle} unitary,
\[ \cO_f \ket{x}_{\q}\ket{y}_{a} = \ket{x}_{\q}\ket{y \oplus f(x)}_a, \]
or by the following \emph{phase oracle} unitary
\begin{align}\label{eq:phase oracle}
  P_f\ket{x}_\q = (-1)^{f(x)} \ket{x}_\q,
\end{align}
which can be obtained from the former in a straightforward fashion.
Here, $\q$ is a quantum variable consisting of~$n$ qubits.
Let us define $N = 2^n$ as the size of the search space,
and $T = \abs{\{x \mid f(x) = 1\}}$ as the number of solutions.
We will assume knowledge of this number of solutions, but note that this is not necessary to solve the search problem.
In the following, we will first present a specification of the search problem, and then construct \emph{two} different programs that satisfy the specification by construction: a simple algorithm based on random sampling and Grover's celebrated quantum search algorithm~\cite{grover1996}.

\paragraph{Specification}
The specification for the search problem can be given as follows:
\[
S_\text{search}(p) = \qpenv{\qphole{pI}{\sum_{x \mid f(x)=1} \proj{x}_{\vec q}}},
\]
It states that if we measure the state after program execution, we obtain a solution~$x$ with probability at least~$p$.
Thus, $p$ is the probability of success of the search algorithm.
In our constructions below, we treat~$p$ as a parameter that will naturally be selected during the refinement process.
Note that whatever the value of~$p$, such an algorithm (if it terminates) can always be amplified or `boosted' to any desired success probability by repeating it sufficiently often until it finds a solution.
We discuss this in \cref{subsec:examples:boosting} below and propose refinement rules to automate this reasoning.

%------------------------------------------------------------------------------
\paragraph{Construction I: Random Sampling}
One can solve the search problem by sampling~$x\in\{0,1\}^n$ uniformly at random.
Clearly, this succeeds with probability $T/N$.
One way to achieve this by a quantum program is by preparing the uniform superposition~$\ket U = \frac1{\sqrt N}\sum_{x \in \{0,1\}^n} \ket x$, since measuring this state in the standard basis will yield a uniformly random~$x\in\{0,1\}^n$.
We can confirm that this construction works with the aforementioned success probability, by refining the specification into a program that prepares the state~$\ket U$.
This can be done by first initializing all qubits in the zero state and then applying Hadmard gates~$H$ (\cref{eq:hadamard}) to all of the qubits:
\begin{align*}
  S_\text{search}(p)
  %&= \qpenv{\qphole{pI}{\sum_{x \mid f(x)=1} \proj{x}_{\vec q}}} \\
  &\totref \qpenv{
    \qphole{pI}{R} ;
    \qphole{R}{\sum_{x \mid f(x)=1} \proj{x}_{\vec q}}
  } \ruletag{H.seq} \\
  &\totref \qpenv{
    \qpinit{\q} ;
    \qphole{R}{\sum_{x \mid f(x)=1} \proj{x}_{\vec q}}
  } \ruletag{H.init} \\
  &\totref \qpenv{
    \qpinit{\q} ;
    \qpunitary{\q}{H^{\ot n}}
  } \ruletag{H.unit}
\end{align*}
To apply \ruleref{H.init}, we need that~$pI \imp \sum_x \ketbra{x}{0}_\q R \ketbra{0}{x}_\q$, that is, $p \leq \braket{0 | R | 0}$.
To apply \ruleref{H.unit}, we can choose $R = H^{\ot n} \parens*{\sum_{x \mid f(x)=1} \proj{x}_{\vec q}} H^{\ot n}$.
Thus the above refinements are valid if
\begin{align*}
  p
\leq \braket{0 | R | 0}
= \braket{U | \sum_{x \mid f(x)=1} \proj{x}_{\vec q} | U}
= \frac T N.
\end{align*}
Thus we should pick~$p:=T/N$ to maximize the success probability.
Altogether, we have constructed a search algorithm that succeeds with probability~$p=T/N$.
As mentioned earlier and will be discussed in detail in \cref{subsec:examples:boosting}, by repeating the above~$O(N/T)$ times until we find a solution, we can obtain a program that solves the search problem with any desired constant probability of success (say, $p=2/3$) at a cost of~$O(N/T)$ queries.

%------------------------------------------------------------------------------
\paragraph{Construction II: Grover Search}
\citet{grover1996} proposed a quantum algorithm for the search problem which has a quadratic speedup compared to random sampling.
In the following, we will re-construct this algorithm by making natural choices and using one key idea at a time.

\paragraph*{Step~1}
The first observation is that while the uniform superposition~$\ket U$ over all bitstrings is easy to prepare, what we are really after is the uniform superposition of all \emph{solutions}, that is, the ``good'' state $\ket G = \frac1{\sqrt T} \sum_{x ~\text{s.t.}~ f(x) = 1} \ket x$.
Indeed, measuring~$\ket G$ will yield a solution with probability one.
We can formalize this idea by strengthening the postcondition of the specification:
\[
S_\text{search}(p) \totref \qpenv{\underbrace{\qphole{pI}{\proj G}}_{S_\text{good}(p)}}, \ruletag{H.sw}
\]
We may apply \ruleref{H.sw} since the condition $\proj G \imp \sum_{x ~\text{s.t.}~ f(x)=1} \proj x$ is satisfied.
Indeed, the good state~$\ket G$ is clearly contained in the span of the basis states~$\ket x$ corresponding to solutions~$x$.
% One can see that
% \[
% \bra G \parens*{\sum_{x ~\text{s.t.}~ f(x)=1} \proj x} \ket G = \sum_{x ~\text{s.t.}~ f(x)=1} \abs{\braket{G|x}}^2 = \sum_{x ~\text{s.t.}~ f(x)=1} \frac1T = 1.
% \]
% And using \cref{cor:projection-predicates}, this is equivalent to the above condition.


\paragraph*{Step~2}
The uniform state~$\ket U$ (which is easy to prepare, but not very useful) and the good state~$\ket G$ (which solves the problem, but is a priori unclear how to prepare) span a two-dimensional subspace of the exponentially large Hilbert space.
The key idea (which has no classical counterpart) then is to try to \emph{rotate} the state~$\ket U$ onto~$\ket G$ in this two-dimensional subspace.

To realize this idea, we first define an orthonormal basis of the two-dimensional subspace by picking~$\ket G$ and a vector orthogonal to it, namely the ``bad state''~$\ket{B} = \frac1{\sqrt{N-T}} \sum_{x ~\text{s.t.}~ f(x) = 0} \ket x$.
At any stage of the program, we would like the state of $\vec q$ to be of the form
\[ \ket{\theta} = \cos\theta \ket B + \sin\theta \ket G \]
for some angle~$\theta$, which will serve as a loop variant in the following.
The plan is now to prepare the uniform state, which has angle~$\upsilon = \arcsin{\sqrt{T/N}} \in [0,\pi/2]$ as it can be written as~$\ket U = \sqrt{(N-T)/N} \ket B + \sqrt{T/N} \ket G$, and then rotate it repeatedly by some angle~$\delta>0$ towards the good state~$\ket G$, which is at angle~$\frac\pi2$.
We can formalize this by the following refinements:
\begin{align*}
S_\text{good}(p)
&= \qpenv{\qphole{pI}{\proj{\frac\pi2}}} \\
&\totref \qpenv{\qphole{pI}{\proj{\theta_0}} ; \qphole{\proj{\theta_0}}{\proj{\frac\pi2}}} \ruletag{H.seq} \\
&\totref \qpenv{
    \underbrace{\qphole{pI}{\proj{\theta_0}}}_{S_\text{init}} ;
    \qprepeat{r}{
      \underbrace{\qphole{\proj{\theta_j}}{\proj{\theta_{j+1}}}}_{S_\text{rotate}(\delta)}
    }
  }
  \ruletag{H.repeat}
\end{align*}
To apply \ruleref{H.repeat}, we choose $\theta_r = \frac\pi2$ and $\theta_{j + 1} = \theta_j + \delta$ for some arbitary rotation angle~$\delta$ and number of rotations~$r$ that we will determine later.
Hence~$\theta_0 = \frac\pi2 - r \delta$.

We first construct the $S_\text{init}$ program.
Following the plan, we prepare the uniform superposition~$\ket U = \ket\upsilon$, which we already know how to do from above:
\begin{align*}
  S_\text{init}
  &\totref \qpenv{ \qphole{pI}{R} ; \qphole{R}{\proj{\theta_0}} }\ruletag{H.seq} \\
  &\totref \qpenv{ \qpinit{\q} ; \qphole{R}{\proj{\theta_0}} } \ruletag{H.init} \\
  &\totref \qpenv{ \qpinit{\q} ; \qpunitary{\q}{H^{\ot n}} }\ruletag{H.unit}
\end{align*}
Since the postcondition is different from the above, we also need to choose~$R$ differently, but we can follow the same reasoning.
In order to apply \ruleref{H.init}, we need that~$p \leq \braket{0 | R | 0}$, and to apply~\ruleref{H.unit} we can choose $R = H^{\ot n} \proj{\theta_0} H^{\ot n}$.
Together, we find that the maximum success probability for which the above refinements are valid is given by
\begin{align*}
p
:= \braket{0 | R | 0}
= \abs{\braket{0 | H^{\ot n} | \theta_0}}^2
= \abs{\braket{\upsilon | \theta_0}}^2
% = \sin^2\parens*{r\delta + \arcsin\parens*{\sqrt{\frac T N}}}
% = \cos^2\parens*{\frac\pi2 - r\delta - \arcsin\parens*{\sqrt{\frac T N}} }.
= \cos^2\parens*{ \frac\pi2 - r\delta - \upsilon }.
\end{align*}
To maximize this probability, we should further choose~$r$ such that the right-hand side is maximized.
We will pick~$r$ such that the angle in the cosine is closest to~$0$:
\begin{align}\label{eq:r}
r := \bracks*{\frac{\frac\pi2 - \upsilon}{\delta}},
\end{align}
where $\bracks{\cdot}$ denotes rounding to the nearest integer.
Clearly, $p \ge \cos^2(\delta/2)$.

\paragraph*{Step~3}
We still need to construct the program~$S_\text{rotate}(\delta)$ for some rotation angle~$\delta$.
To this end, we first observe that it suffices to construct a program that satisfies the stronger specification:
\begin{align*}
  S'_\text{rotate}(\delta) = \qphole{\proj{\theta}}{\proj{\theta+\delta}}.
\end{align*}
Indeed, programs satisfying this specification rotate \emph{all} states~$\ket\theta$ in the two-dimensional subspace by~$\delta$, as opposed just the states~$\ket{\theta_j}$ for~$j\in\{0,1,\dots,N-1\}$.

How can we obtain such a rotation?
% Clearly we need to at some point query the oracle to solve the search problem.
Observe that the quantum phase oracle~$P_f$ in \cref{eq:phase oracle} is a \emph{reflection} about the vector $\ket B$, as it maps
% $P_f(\alpha \ket B + \beta \ket G) = \alpha \ket B - \beta \ket G$.
$P_f \ket\theta = \ket{-\theta}$.
Now, we know that two reflections make a rotation.
For our second reflection we simply pick some known state (independent of the instance of the search problem) to reflect about.
A natural choice is $\ket U$, since the corresponding reflection~$2\proj{U} - I$ can be efficiently implemented using~$O(n)$ gates.
Thus we introduce these two reflections in sequence and determine the rotation angle from the conditions of the refinements:
\begin{align*}
  S'_\text{rotate}(\delta)
  &\totref \qpenv{
    \qphole{\proj{\theta}}{\proj{-\theta}}
    ;
    \qphole{\proj{-\theta}}{\proj{\theta+\delta}}
  } \ruletag{H.seq} \\
  &\totref \qpenv{
    \qpunitary{\vec q}{P_f}
    ;
    \qphole{\proj{-\theta}}{\proj{\theta+\delta}}
  } \ruletag{H.unit} \\
  &\totref \qpenv{
    \qpunitary{\vec q}{P_f}
    ;
    \qpunitary{\vec q}{(2\proj{U} - I)}
  } \ruletag{H.unit}
\end{align*}
The first application of \ruleref{H.unit} is correct by our choice of intermediate condition, but for the second one we need that
\begin{align*}
  \parens*{ 2\proj{U} - I } \proj{-\theta} \parens*{ 2\proj{U} - I }
 \imp \proj{\theta+\delta}.
\end{align*}
Since~$\ket U$ is at angle~$\upsilon$, reflecting about it sends~$\ket{-\theta} = \ket{\upsilon-(\theta+\upsilon)}$ to~$\ket{\upsilon+(\theta+\upsilon)}=\ket{\theta+2\upsilon}$.
Thus the above refinements are valid if we choose~$\delta = 2\upsilon$ as the rotation angle, where we recall that~$\upsilon = \arcsin{\sqrt{T/N}}$.
If we plug this back into \cref{eq:r} we find that the number of rotations is
\begin{align*}
  r
= \bracks*{\frac{\frac\pi2 - \upsilon}{2\upsilon}}
= \bracks*{\frac\pi{4\arcsin{\sqrt{T/N}}} - \frac12}
= O\parens*{\sqrt{\frac N T}}.
\end{align*}
Moreover, the success probability can be lower bounded as
\begin{align*}
  p
\geq \cos^2(\delta/2)
= 1 - \sin^2(\upsilon)
= 1 - \frac TN.
\end{align*}
Thus we obtain the following quantum program:
\[
  S_\text{search}\parens*{1 - \frac T N}
  % = \qpenv{\qphole{\parens*{1 - \frac{T}{N}} I}{\sum_{x ~\text{s.t.}~ f(x)=1}\proj x}}
  \totref^*
  \qpenv{
    \begin{aligned}
      &\qpinit{\vec q} ;~ \\
      &\qpunitary{\vec q}{H^{\ot n}} ;~ \\
      &\qprepeat{
          \bracks*{
            \frac
              {\pi}
              {4\arcsin{\sqrt{\frac T N}}}
            - \frac12
          }
        }{\\
        &\quad \qpunitary{\vec q}{P_f}; \\
        &\quad \qpunitary{\vec q}{(2\proj{U} - I)} \\
      &}
    \end{aligned}
  }
\]
As we have constructed it by refining the initial specification for the search problem, it satisfies the specification by construction.
It succeeds with probability~$p \geq 1 - T/N$ and uses~$O(\sqrt{N/T})$ queries to the quantum oracle.
This algorithm is in fact Grover's algorithm~\cite{grover1996}.

%------------------------------------------------------------------------------
\subsection{Boosting Success Probability}
\label{subsec:examples:boosting}
%------------------------------------------------------------------------------
In the preceding example, we constructed two quantum programs that succeed with some probability.
We modeled this by a specification of the form~$\qpenv{\qphole{\eps I}{Q}}$ for some $\eps>0$; here we write~$\eps$ rather than~$p$ because the discussion that follows is most relevant when~$\eps$ is a small probability.
Indeed, a Hoare triple $\hoare{\eps I}{S}{Q}$ is totally correct if the program~$S$ terminates and the postcondition~$Q$ holds with probability at least~$\eps$.
% This can be seen from the definition of total correctness:
% $p \le \satisfies{\Bracks{S}(\rho)}{P}$ for every state~$\rho$.
% Similarly, the triple is partially correct if with probability at least~$p$ either the postcondition holds or the program does not terminate.
We can amplify or `boost' the success probability of such a program~$S$ arbitrarily by simply repeating it until the postcondition holds, provided (i)~the program~$S$ terminates almost surely (so that we keep repeating) and (ii)~the postcondition is given by a projection (so that measuring it does not impact its expectation).
To incorporate the termination requirement we can consider the multiple specification~$\qpenv{\qphole{\eps I,I}{Q,I}}$.

In this section, we give two refinement rules that formalize this reasoning.
We first give a rule that reduces the construction of a program that succeeds with some probability~$p\in(0,1)$ to the construction of a program that succeeds with some smaller probability~$\eps\in(0,p)$:
\begin{enumerate}[align=right,leftmargin=2.5cm]
\ruleitem{H.boostRep}
  $\qpenv{\qphole{pI, I}{Q_\q, I}}
  \totref^*
  \qpenv{
  \begin{aligned}
      &\qprepeat{\ceil{\log_{1-\eps} (1 - p)}}{ \\
      &\quad \qpif{I - Q}{\q}{\\
      &\qquad \qpenv{\qphole{\eps(I - Q_\q), I - Q_\q}{Q_\q, I}}\\
      &\quad }\\
      &}
  \end{aligned}
  }
  $, \\
  for any projection~$Q$ and any~$\eps\in(0,p)$.\!\!\!\!\!\!
\end{enumerate}

\begin{lemma}[Boosting Success Probability]\label{lem:boosting-repeat}
The relation \ruleref{H.boostRep} holds.
\end{lemma}
\begin{proof}
We show that \ruleref{H.boostRep} holds by successively refining the left-hand side into the right-hand side.
To this end we first refine:
\begin{align*}
  \qpenv{\qphole{pI, I}{Q_\q, I}}
\totref \qpenv{ \qprepeat{N}{ \underbrace{\qphole{R_j, I}{R_{j+1}, I} }_{S_\text{body}} } }, \ruletag{H.repeat}
\end{align*}
where we choose $N = \ceil{\log_{1-\eps} (1 - p)}$ and
\[
  R_j
= (1 - \eps)^{N-j} Q_\q + \parens[\big]{ 1 - (1 - \eps)^{N-j} } I
% = \parens[\big]{ 1 - (1 - \eps)^{N-j} } (I - Q_\q) + Q_\q
\]
for $j\in\{0,\dots,N\}$.
The application of \ruleref{H.repeat} is valid since $R_N = Q_\q$, while $pI \imp R_0$ holds because~$p \leq 1 - (1 - \eps)^{N}$ by our choice of~$N$.
% Indeed:
% \begin{align*}
%   p \leq 1 - (1 - \eps)^N \\
%   1 - p \geq (1 - \eps)^N \\
%   \log(1 - p) \geq N \log(1 - \eps) \\
%   N \geq \frac {\log(1 - p)} {\log(1 - \eps)} = \log_{1-\eps}(1-p).
% \end{align*}
Next, since we only want to apply the subroutine if the postcondition does not already hold, we refine the loop body by measuring the postcondition:
\begin{align*}
  S_\text{body}
\totref \qpenv{ \qpif{I - Q}{\vec q}{ \underbrace{ \qphole{P_j, I - Q_\q}{R_{j+1}, I} }_{S_\text{then}} } } \ruletag{H.if}
\end{align*}
which is valid if we take
\begin{align*}
  P_j
= (I - Q_\q) R_j (I - Q_\q)
= \parens[\big]{ 1 - (1 - \eps)^{N-j} } (I - Q_\q).
\end{align*}
% Indeed, the side condition for the first spec holds with equality:
% \begin{align*}
%   R_j
% = \parens[\big]{ 1 - (1 - \eps)^{N-j} } (I - Q_\q) + Q_\q
% = Q_\q R_{j+1} Q_\q + (I - Q_\q) P_j (I - Q_\q)
% \end{align*}
% and for the second specification this is also true:
% \begin{align*}
%   I
% = Q_\q I Q_\q + (I - Q_\q)(I - Q_\q)(I - Q_\q)
% \end{align*}
We can obtain the desired program by splitting up this specification in the following way:
\begin{align*}
  S_\text{then}
\totref\ &\qpenv{\qphole{\eps(I - Q_\q), I - Q_\q, I - Q_\q}{Q_\q, I, I}} \ruletag{H.split} \\
=\ &\qpenv{\qphole{\eps(I - Q_\q), I - Q_\q}{Q_\q, I}}
\end{align*}
Indeed, this refinement can be applied since
\begin{align*}
  P_j
&= \parens[\big]{ 1 - (1 - \eps)^{N-j} } (I - Q_\q) \\
&= \parens[\big]{ 1 - (1 - \eps)^{N-j-1} (1 - \eps) } (I - Q_\q) \\
&= (1 - \eps)^{N-j-1} \eps (I - Q_\q) + \parens[\big]{ 1 - (1 - \eps)^{N-j-1} } (I - Q_\q),
\intertext{while}
  R_{j+1}
&= (1 - \eps)^{N-j-1} Q_\q + \parens[\big]{ 1 - (1 - \eps)^{N-j-1} } I.
\end{align*}
so \ruleref{H.split} can be applied with probabilities~$(1 - \eps)^{N-j-1}$ and~$1-(1 - \eps)^{N-j-1}$.
\end{proof}

Finally, we give a rule to reduce the construction of programs that succeed with probability one to ones that succeed with some finite probability~$\eps\in(0,1)$, by repeating the program an unbounded number of times until it succeeds:
\begin{enumerate}[align=right,leftmargin=2.5cm]
\ruleitem{H.boostWhile}
  $\qpenv{\qphole{I}{Q_\q}}
  \totref
  \qpenv{
  \begin{aligned}
      &\qpwhile{I - Q}{\q}{\\
      &\quad \qpenv{\qphole{\eps (I - Q_\q), I - Q_\q}{Q_\q, I}}\\
      &}
  \end{aligned}
  }
  $, \\
  for any projection~$Q$ and any~$\eps>0$.
\end{enumerate}
Note that we impose a slightly weaker precondition on the loop body than in the preceding discussion.
This takes into account that the loop body's initial state is necessarily supported on~$I-Q$ due to the preceding measurement.

\begin{lemma}[Boosting Success Probability]\label{lem:boosting-while}
The relation \ruleref{H.boostWhile} holds.
\end{lemma}
\begin{proof}
Simply apply \ruleref{H.whileEps} with~$B=R=I-Q$ and $P=I$ (and remove the repeated specification).
This refinement can be applied because~$\cB_0(Q) + \cB_1(R) = I$.
\end{proof}


%==============================================================================
\section{Related Work}\label{sec:related-work}
%==============================================================================
\paragraph{Correctness-by-construction for classical programs}
The Correctness-by-Construction (CbC) approach to programming was initially introduced by \citet{10.5555/550359} and \citet{gries_science_1981}
and later extended by \citet{kourie_correctness-by-construction_2012}.
There has been extensive work on developing a tool for CbC for classical programs, called CorC~\cite{runge2019corc},
and on building an ecosystem around it~\cite{bordis2022corc, runge2020latticeinfocbc, runge2023flexcbc, bordis2023corceco,knuppel_scaling_2020}.
\citet{traitcbc2022} introduce Traits for CbC: a way to support CbC in languages with existing support for post-hoc verification.
Another approach in the spirit of CbC is the B method~\cite{1996bbook,2003bmethod}, which uses first-order logic to incrementally refine an abstract machine into a concrete implementation.
This methodology has been implemented in the Event-B ecosystem~\cite{2010modellingEventB}.
%
One key difference between prior CbC approaches and our approach is the formalization of \emph{programs with holes}.
Formalizing specifications using holes helps us write specifications as first-class entities in the programming language,
and we then proceeded to give a rigorous refinement relation to formalize the refinement rules used to construct programs.
The constraints that need to be satisfied to apply a refinement rule are referred to as \emph{side-conditions} in some prior works.

\paragraph{Probabilistic Verification}
Hoare logic was first extended to probabilistic programs by \citet{probhoare1999}, who extended the notion of boolean predicates to real-valued predicates that can attain any value between~0 and~1, representing the degree to which the predicate holds in a given state.
\Citet{10.1145/2933575.2935317} provide another approach for verifying probabilistic programs using weakest precondition reasoning, and \citet{10.1145/3290347} gave an extension for supporting separation logic.
\Citet{Morgan1998pGCLFR} introduced an approach for verifying probabilistic programs using Hoare logic in the guarded command language relying on weakest preconditions (called pre-expectations) and backwards reasoning.
\Citet{pardo2022pgcl} propose a dynamic logic for specifying forward reasoning for properties of probabilistic programs.
We refer to \citet{kaminski2016weakest} and references therein for recent work on proving termination and bounding the expected runtime of probabilistic programs.


\paragraph{Quantum Verification}
The first approach on Hoare logic for quantum programs was introduced by~\citet{ying2012quantum}.
This was subsequently extended to include classical variables~\cite{feng2021quantum}.
\Citet{coqq2023} recently provided a rigorous implementation of quantum Hoare logic in Coq with a range of applications.
\Citet{aQHL2019} focused on projections as predicates and proposed a notion of robust Hoare triples, which allow pre- and postconditions to be approximately satisfied (interestingly, this cannot be expressed in ordinary quantum Hoare logic).
\Citet{rand2019verification} surveys recent advances in Hoare-style verification logics for quantum programs.
% An alternative approach for finding bugs in programs is Incorrectness Logic~\cite{incorrectnesslogic2019}.
An incorrectness logic for quantum programs was introduced by \citet{peng2022_quantum_incorrectness_logic}.
All these prior approaches for quantum logic have been post-hoc, in contrast to the QbC formalism presented in this paper.

%==============================================================================
\section{Conclusion and outlook}\label{sec:conclusion}
%==============================================================================
In this work, we proposed Quantum Correctness by Construction (QbC), an approach for constructing quantum programs that are guaranteed to be correct by construction.
To this end, we extended a quantum while language with a new construct called \emph{holes}, which  represent yet-to-be-constructed subprograms that carry a precondition and a postcondition.
We presented refinement rules that iteratively refine such quantum programs and proved that these rules are sound: every program is guaranteed to satisfy the specification it was constructed from.
Finally, we demonstrated the QbC approach by constructing quantum programs for some idiomatic problems, starting from their natural specification.
We found that in these examples, QbC naturally suggested how to derive program details and highlighted key design choices that had to be made along the way.
We take these findings to suggest that QbC could meaningfully support the design of novel quantum algorithms, their taxonomization, and the construction and verification of larger quantum software -- helping to unleash the full potential of quantum computing and the emerging hardware.

We briefly comment on some directions for future research.
First, it would be interesting to identify further refinement rules that encode high-level reasoning and design patterns that are commonly used in quantum algorithms.
For example, quantum amplitude amplification~\cite{brassard2002quantum} generalizes Grover's algorithm to offer a quantum speedup for boosting the success probability of a subroutine that improves over naive repetition (cf.\ \cref{subsec:examples:qsearch,subsec:examples:boosting}).
Second, it would also be desirable to provide refinement rules that ensure total correctness of \textbf{while} loops in more general situations than our \ruleref{H.whileEps} rule.
The standard approach in post-hoc quantum verification is to use ranking functions~\cite{ying2012quantum} to prove termination of loops.
We see incorporating such a methodology into our QbC approach as a natural next step that might also inform other challenges, such as constructing quantum programs that are \emph{efficient by construction}.
Third, while the \emph{quantum while language} used in this paper provided a good starting point and clean theoretical model, it is not very expressive.
It would be desirable to extend the QbC approach to more expressive languages, which might include both classical and quantum variables~\cite{feng2021quantum}, oracles and subroutines, quantum data structures, etc.
Finally, while our work clearly highlights the potential of the correctness-by-construction methodology, which offers a top-down approach to help programmers devise the overall structure without access to a complete and correct program, it would also be interesting to devise hybrid approaches that combine both post-hoc (Hoare or weakest-precondition logic) and correctness-by-construction (CbC) reasoning, which can both be useful particularly when constructing larger and more complex programs~\cite{CbCandPhV2016}.

%==============================================================================
\ifx\paperversion\paperversionACM
\begin{acks}
We thank Bruce Watson for fruitful discussions on the subject of this work.
All authors acknowledge support by the BMBF (QuBRA, 13N16135 \& 13N16303).
IS also acknowledges support by the BMWK (ProvideQ, 01MQ22006F).
MW also acknowledges support by the European Union (ERC, SYMOPTIC, 101040907), by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) under Germany's Excellence Strategy - EXC\ 2092\ CASA - 390781972, and by the Dutch Research Council (NWO grant OCENW.KLEIN.267).
\end{acks}
\fi
%==============================================================================

\ifx\paperversion\paperversionACM
\bibliographystyle{ACM-Reference-Format}
\else
  \ifx\paperversion\paperversionSpringer
  \bibliographystyle{splncs04}
  \fi
\fi
\bibliography{qbc}

%==============================================================================
%% Appendix
% \clearpage
\appendix
%==============================================================================

%==============================================================================
\section{Soundness of Refinement for Total Correctness}
\label{app:total soundness}
%==============================================================================
In this appendix we prove \cref{thm:soundness-total}.
We restate the theorem for convenience.
Its proof is very similar to the one of \cref{thm:soundness-partial}.

\thmsoundnesstotal*
\begin{proof}
We prove by induction for $k \ge 1$ that if $\qpenv{\qphole{P}{Q}} \totref^k S$ and~$S$ is a concrete program (i.e., has no holes) then~$\totcorr \hoare{P}{S}{Q}$.

\medskip\emph{Base case~$(k = 1)$:}
We have $\qpenv{\qphole{P}{Q}}~\totref~S$.
Since~$S$ has no holes, the refinement can only be due to one of the rules \ruleref{H.skip}, \ruleref{H.init} or \ruleref{H.unit}.
In the proof of \cref{thm:soundness-partial} we already saw that these rules are totally correct.
This concludes the base case.


\medskip\emph{Induction Step $(k > 1)$:}
Using the induction hypothesis, we assume that all refinements of length at most $k - 1$ are totally correct.
We now prove that any program that refines in $k$ steps must also be totally correct.
Now, $\qpenv{\qphole{P}{Q}} \totref^k S$ means that there exists a program~$S'$ such that $\qpenv{\qphole{P}{Q}} \totref S' \totref^{k-1} S$.
Since~$S'$ must have holes, the refinement~$\qpenv{\qphole{P}{Q}} \totref S'$ can only be due to one of the following rules:

\begin{proofcase}
\ruleref{H.seq}
$S' = \qpenv{\qphole{P}{R};\qphole{R}{Q}}$:
As $S' \totref^{k-1} S$, \cref{lem:chain_split} states that there are programs~$S_1, S_2$ and integers~$k_1, k_2$
such that $S = \qpenv{\qpabsprog{S_1} ; \qpabsprog{S_2}}$
and $\qpenv{\qphole{P}{R}}~\totref^{k_1}~S_1$
and $\qpenv{\qphole{R}{Q}}~\totref^{k_2}~S_2$
(where~$k_1 + k_2 = k - 1$).
From the induction hypothesis we have that $\totcorr \hoare{P}{S_1}{R}$ and $\totcorr \hoare{R}{S_2}{Q}$.
Therefore, for any partial state $\rho$,
\begin{align*}
  \satisfies{\rho}{P}
  =\tr(P\rho)
  &\le \tr(R~\Bracks{S_1}(\rho)) \\
  &\le \tr(Q~\Bracks{S_2}(\Bracks{S_1}(\rho))) \\
  &= \tr(Q~\Bracks{\qpenv{\qpabsprog{S_1};\qpabsprog{S_2}}}(\rho)) \\
  &= \satisfies{\Bracks{S}(\rho)}{Q}.
\end{align*}
Therefore, $\totcorr \hoare{P}{S}{Q}$.
\end{proofcase}

% \begin{proofcase}
% \ruleref{H.sw}
% $S' = \qpenv{\qphole{P'}{Q'}}$ and $P \imp P', Q' \imp Q$:
% Recall that the latter means that~$P \preceq P'$ and~$Q' \preceq Q$.
% From the induction hypothesis we have $\totcorr~\hoare{P'}{S}{Q'}$.
% Therefore, for any partial state $\rho$,
% \begin{align*}
% \satisfies{\rho}{P}
% =\tr(P\rho)
% \le \tr(P'\rho)
% \le \tr(Q'~\Bracks{S}(\rho))
% \le \tr(Q~\Bracks{S}(\rho))
% = \satisfies{\Bracks{S}(\rho)}{Q}.
% \end{align*}
% Therefore, $\totcorr \hoare{P}{S}{Q}$.
% \end{proofcase}

\begin{proofcase}
\ruleref{H.split}
$S' = \qpenv{\qphole{P_\gamma}{Q_\gamma}}$ and $P \imp \sum_\gamma p_\gamma P_\gamma$ and~$\sum_\gamma p_\gamma Q_\gamma \imp Q$:
Recall the latter mean that~$P \preceq \sum_\gamma p_\gamma P_\gamma$ and~$\sum_\gamma p_\gamma Q_\gamma \preceq Q$.
From the induction hypothesis we have~$\totcorr \hoare{P_\gamma}{S}{Q_\gamma}$ for all~$\gamma$.
Therefore, for any partial state $\rho$,
\begin{align*}
\satisfies{\rho}{P}
&=\tr(P\rho) \\
&\leq \sum_\gamma p_\gamma \tr(P_\gamma \rho) \\
&\leq \sum_\gamma p_\gamma \tr(Q_\gamma \Bracks{S}(\rho)) \\
&\leq \tr(Q \Bracks{S}(\rho)) = \satisfies{\Bracks{S}(\rho)}{Q}.
\end{align*}
Therefore, $\totcorr \hoare{P}{S}{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.repeat}
$S' = \qpenv{\qprepeat{N}{\qphole{R_j}{R_{j+1}}}}$, with $j~\in~\irange{0}{N-1}$ a formal parameter, $P~\imp~R_0$, and~$R_N~\imp~Q$:
As $S' \totref^{k-1} S$, \cref{lem:chain_split} states that $S = \qpenv{\qprepeat{N}{\qpabsprog{C}}}$ for some program~$C$ satisfying~$\qpenv{\qphole{R_j}{R_{j+1}}}~\totref^{k-1}~C$.
By the induction hypothesis, $\totcorr \hoare{R_j}{C}{R_{j+1}}$.
It follows that for all~$j \in \irange{0}{N-1}$ and any partial state $\sigma_j$, we have
\begin{align*}
  \tr(R_j \sigma_j) \le \tr(R_{j+1} \Bracks{C}(\sigma_j)).
\end{align*}
Choosing $\sigma_j = \Bracks{C}^j(\rho)$, for some arbitrary partial state $\rho$, the above inequality becomes
\begin{align*}
  \tr(R_j~\Bracks{C}^j(\rho)) \le \tr(R_{j+1} \Bracks{C}^{j+1}(\rho)),
\end{align*}
and chaining the above inequalities for~$j \in \irange{0}{N-1}$ gives us
\begin{align*}
  \satisfies{\rho}{R_0}
  = \tr(R_0~\rho)
  \leq \tr(R_N~\Bracks{C}^N(\rho))
  = \satisfies{\Bracks{S}(\rho)}{R_N},
\end{align*}
where we used that~$\Bracks{S} = \Bracks{C}^N$.
This shows that that $\totcorr \hoare{R_0}{S}{R_N}$.
Since~$P~\imp~R_0$ and~$R_N~\imp~Q$, it follows that~$\totcorr \hoare{P}{S}{Q}$ just like in the preceding case.
\end{proofcase}

\begin{proofcase}
\ruleref{H.case}
$S' = \qpenv{\qpselect{\vec M}{\vec q}{\{\omega \colon \qphole{P_\omega}{Q}\}_{\omega\in\Omega}}}$
and $P \imp \sum_{\omega\in\Omega} \cM_\omega(P_\omega)$:
According to \cref{lem:chain_split}, there exist programs~$S_\omega$ and numbers~$k_\omega$ for every~$\omega \in \Omega$,
such that~$S = \qpenv{\qpselect{\vec M}{\vec q}{\{\omega \colon \qpabsprog{S_\omega}\}_{\omega\in\Omega}}}$
and~$\qpenv{\qphole{P_\omega}{Q}} \totref^{k_\omega} S_\omega$
and~$\sum_\omega k_\omega = k - 1$.
From the induction hypothesis we have that $\totcorr \hoare{P_\omega}{S_\omega}{Q}$ for every $\omega\in\Omega$.
Therefore, for any partial state $\sigma$ and any $\omega\in\Omega$,
\[
\tr(P_\omega \sigma)
\le \tr(Q~\Bracks{S_\omega}(\sigma))
\]
%
So for every partial state $\rho$ we have
\begin{align*}
  \satisfies{\rho}{P}
  =\tr(P\rho)
  &\le \tr{\parens*{\parens*{\sum_{\omega\in\Omega}\cM_\omega(P_\omega)} \rho}}  \\
  &= \sum_{\omega\in\Omega} \tr{\parens*{P_\omega \cM_\omega(\rho)}} \\
  &\le \sum_{\omega\in\Omega} \tr{\parens*{Q~\Bracks{S_\omega}(\cM_\omega(\rho)))}} \\
  &= \tr(Q~\Bracks{S}(\rho))
  = \satisfies{\Bracks{S}(\rho)}{Q}.
\end{align*}
Therefore, $\totcorr \hoare{P}S{Q}$.
\end{proofcase}

\begin{proofcase}
\ruleref{H.whileEps}
$S' = \qpenv{\qpwhile{B}{\vec q}{
  \qpenv{\qphole{R, \eps B^\text{supp}_\q, B^\text{supp}_\q}{\cB_0(Q) + \cB_1(R), I - B_\q, I}}
}}$, where $P~\imp~\cB_0(Q)~+~\cB_1(R)$:

As $\totref^*~\subseteq~\parref^*$, \cref{thm:soundness-partial} already implies that~$\{P\}S\{Q\}$ is partially correct.
To show total correctness, it suffices to prove that~$\tr(\Bracks{S}(\rho)) = \tr(\rho)$ for any partial state~$\rho$ (that is, $S$ terminates almost surely on any initial state).
Now, by \cref{lem:chain_split} we have $S = \qpenv{\qpwhile{B}{\vec q}{\qpabsprog{C}}}$ for some program~$C$ such that
$\qpenv{\qphole{R,\eps B^\text{supp}_\q, B^\text{supp}_\q}{\\cB_0(Q) + \cB_1(R), I-B_\q, I}} \totref^{k-1} C$.
In particular, the two Hoare triples
\begin{align}\label{eq:whileEps triples}
  \hoare{B^\text{supp}_\q}{C}{I}
\quad\text{and}\quad
  \hoare{\eps B^\text{supp}_\q}{C}{I - B_\q}
\end{align}
%$$\hoare{R}{C}{\cB_0(Q) + \cB_1(R)}$,
are totally correct by the induction hypothesis.
Consider the semantics of the while loop:
\begin{align}\label{eq:whileEps loop}
  \Bracks{S}(\rho) = \sum_{k = 0}^\infty \parens*{ \cB_0 \circ \parens*{ \Bracks{C} \circ \cB_1 }^k }(\rho)
\end{align}
for all states~$\rho$.
Total correctness of the first triple in \cref{eq:whileEps triples} means that
$\tr(B^\text{supp}_\q \rho) \leq \tr(\Bracks{C}(\rho))$.
Note also that the right-hand side of this inequality is at most~$\tr(\rho)$.
By taking~$\rho=\cB_1(\sigma)$, which satisfies $\tr(B^\text{supp}_\q \rho) = \tr(\rho)$, it follows that~$\tr(\Bracks{C}(\cB_1(\sigma)) = \tr(\cB_1(\sigma))$ for any state~$\sigma$.
Using this identity, it is easy to verify that
\begin{align*}
  \tr \sum_{k = 0}^n \parens*{ \cB_0 \circ \parens*{ \Bracks{C} \circ \cB_1 }^k }(\rho)
+ \tr \parens*{ \cB_1 \circ \parens*{ \Bracks{C} \circ \cB_1 }^n }(\rho)
= \tr(\rho)
\end{align*}
for all~$n$ and hence also if we take the limit~$n\to\infty$.
By comparing with \cref{eq:whileEps loop}, we deduce that~$\tr(\Bracks{S}(\rho)) = \tr(\rho)$ if and only if
\begin{align}\label{eq:no tail}
  \lim_{n\to\infty} \tr \parens*{ \cB_1 \circ \parens*{ \Bracks{C} \circ \cB_1 }^n }(\rho) = 0
\end{align}
(this can be interpreted as the probability of non-termination).
To establish \cref{eq:no tail}, we consider the second Hoare triple in \cref{eq:whileEps triples}.
Its total correctness means that~$\tr((I - B_\q) \Bracks{C}(\rho)) \geq \eps \tr(B^\text{supp}_\q \rho)$ for all states~$\rho$, and hence we have
\begin{align*}
  \tr((\cB_1 \circ \Bracks{C} \circ \cB_1)(\sigma))
&= \tr(B_\q~\Bracks{C}(\cB_1(\sigma))) \\
&= \tr(\Bracks{C}(\cB_1(\sigma)))
- \tr((I - B_\q)\Bracks{C}(\cB_1(\sigma))) \\
&\leq \tr(\cB_1(\sigma))
- \eps \tr(B^\text{supp}_\q ~\cB_1(\sigma) ) \\
&= (1 - \eps) \tr(\cB_1(\sigma))
\end{align*}
for all states~$\sigma$.
This readily implies \cref{eq:no tail} and hence that $\tr(\Bracks{S}(\rho)) = \tr(\rho)$ for every state~$\rho$.
% Thus we have proved that the program~$S$ terminates almost surely.
Since we already established that~$\parcorr \hoare{P}{S}{Q}$, it follows that~$\totcorr \hoare{P}{S}{Q}$.
\end{proofcase}

\medskip

\noindent This concludes the proof of the induction step and hence the proof of the theorem.
\end{proof}

\end{document}
