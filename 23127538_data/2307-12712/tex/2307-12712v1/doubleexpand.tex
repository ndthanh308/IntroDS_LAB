We now have all the tools to produce in-place polynomial algorithms.
We start, in~\cref{alg:doublebilin}, with a version
of~\cref{alg:bilin} that regroups the intermediate computations into
consecutive blocks.

\begin{algorithm}[htbp]
  \caption{In place bilinear $2$ by $2$ formula}\label{alg:doublebilin}
  \begin{algorithmic}[1]\small
    \REQUIRE $\vec{a}\in\D^m$, $\vec{b}\in\D^n$, $\vec{c}\in\D^s$;
    $\mat{\alpha}\in\D^{t{\times}m}$, $\mat{\beta}\in\D^{t{\times}n}$,
    $\mat{\mu}\in\D^{s{\times}(2t)}=\begin{bmatrix}M_1&\ldots&M_t\end{bmatrix}$,
      with no zero-rows in $\alpha$, $\beta$, $\mu$,
      and s.t. $M_i\in\D^{s{\times}2}$ is of full-rank $2$ for $i=1..t$.
    \READONLY$\mat{\alpha},\mat{\beta},\mat{\mu}$.
    \ENSURE $\vec{c}\pe\mat{\mu}\vec{m}$, for
    $\vec{m}=(\mat{\alpha}\vec{a})\otimes(\mat{\beta}\vec{b})$, such
    that $(a_i\cdot{b_j})$ fits two result variables $c_k$, $c_l$.
    \FOR{$\ell=1$ \To $t$}
    \STATE Let $i$ s.t. $\alpha_{\ell,i}\neq{0}$;
    \STATE\label{lin:doublealpha}$a_i\fe\alpha_{\ell,i}$;
    \algorithmicfor~{$\lambda=1$ \To $m$, $\lambda\neq{i}$, $\alpha_{\ell,\lambda}\neq{0}$ }~
	\algorithmicdo~{$a_i\pe\alpha_{\ell,\lambda}a_\lambda$}~
    \algorithmicend
    \STATE Let $j$ s.t. $\beta_{\ell,j}\neq{0}$;
    \STATE\label{lin:doublebeta}$b_j\fe\beta_{\ell,j}$;
    \algorithmicfor~{$\lambda=1$ \To $n$, $\lambda\neq{j}$, $\beta_{\ell,\lambda}\neq{0}$}~
	\algorithmicdo~{$b_j\pe\beta_{\ell,\lambda}b_\lambda$}~
    \algorithmicend
    \STATE Let $k,f$
    s.t. $M=\begin{bmatrix}\mu_{k,2\ell}&\mu_{k,2\ell+1}\\\mu_{f,2\ell}&\mu_{f,2\ell+1}\end{bmatrix}$
    is invertible;
    \STATE\label{lin:invmul}$\begin{bmatrix} c_k\\c_f \end{bmatrix} \leftarrow M^{-1}
    \begin{bmatrix} c_k\\c_f \end{bmatrix}$
    \hfill\COMMENT{Via~\cref{eq:twobytwomul,rq:zerotopleft}}
    \STATE\label{lin:divsube}\algorithmicfor~{$\lambda=1$ \To $s$,
      $\lambda\not\in\{f,k\}$, $\mu_{\lambda,2\ell}\neq{0}$}~
	\algorithmicdo~{$c_\lambda\me\mu_{\lambda,2\ell}{c_k}$}~
    \algorithmicend
    \STATE\label{lin:divsubo}\algorithmicfor~{$\lambda=1$ \To $s$,
      $\lambda\not\in\{f,k\}$, $\mu_{\lambda,2\ell+1}\neq{0}$}~
	\algorithmicdo~{$c_\lambda\me\mu_{\lambda,2\ell+1}{c_f}$}~
    \algorithmicend
    \STATE\label{lin:doubleproduct}$\begin{bmatrix} c_k\\c_f
    \end{bmatrix}\pe{a_i\cdot{b_j}}$\hfill\COMMENT{This is the
      accumulation of the product $\begin{bmatrix} m_k\\m_f\end{bmatrix}$}
    \STATE\algorithmicfor~{$\lambda=1$ \To $s$,
      $\lambda\not\in\{f,k\}$, $\mu_{\lambda,2\ell+1}\neq{0}$}~
	\algorithmicdo~{$c_\lambda\pe\mu_{\lambda,2\ell+1}{c_f}$}~
    \algorithmicend\hfill\COMMENT{undo~\ref{lin:divsubo}}
    \STATE\algorithmicfor~{$\lambda=1$ \To $s$,
      $\lambda\not\in\{f,k\}$, $\mu_{\lambda,2\ell}\neq{0}$}~
	\algorithmicdo~{$c_\lambda\pe\mu_{\lambda,2\ell}{c_k}$}~
    \algorithmicend\hfill\COMMENT{undo~\ref{lin:divsube}}
    \STATE$\begin{bmatrix} c_k\\c_f \end{bmatrix} \leftarrow M\begin{bmatrix} c_k\\c_f \end{bmatrix}$
    \hfill\COMMENT{Via~\cref{eq:twobytwomul,rq:zerotopleft}, undo~\ref{lin:invmul}}
    \STATE
    \algorithmicfor~{$\lambda=1$ \To $n$, $\lambda\neq{j}$, $\beta_{\ell,\lambda}\neq{0}$}~
	\algorithmicdo~{$b_j\me\beta_{\ell,\lambda}b_\lambda$}~
    \algorithmicend;~$b_j\de\beta_{\ell,j}$;\hfill\COMMENT{undo~\ref{lin:doublebeta}}
    \STATE
    \algorithmicfor~{$\lambda=1$ \To $m$, $\lambda\neq{i}$, $\alpha_{\ell,\lambda}\neq{0}$}~
	\algorithmicdo~{$a_i\me\alpha_{\ell,\lambda}a_\lambda$}~
    \algorithmicend;~$a_i\de\alpha_{\ell,i}$;\hfill\COMMENT{undo~\ref{lin:doublealpha}}
    \ENDFOR
    \RETURN $\vec{c}$.
  \end{algorithmic}
\end{algorithm}


\begin{theorem}\label{thm:doublebilin}
\Cref{alg:doublebilin} is correct, in-place, and requires
$t$ \MUL-2D,
$2(\#\alpha+\#\beta+\#\mu-t)$ \ADD and
$2(\sharp\alpha+\sharp\beta+\sharp\mu+2t)$ \SCA operations.
\end{theorem}
\begin{proof}
  Thanks to~\cref{eq:twobytwo,eq:twobytwomul,rq:zerotopleft},
  correctness is similar to that of~\cref{alg:bilin}
  in~\cref{thm:bilin}.
For the number of operations, \cref{eq:twobytwomul} requires $4$ \SCA
and $2$ \ADD operations and is called $2t$ times.
The rest is similar to~\cref{alg:bilin} and amounts to
$2t+2(\#\alpha-t+\#\beta-t+\#\mu-2t)+(2t)2$ \ADD and
$2(\sharp\alpha+\sharp\beta+\sharp\mu-2t)+(2t)4$ \SCA operations.
\end{proof}

There remains now to use a double expansion of the output matrix
$\mu\in\D^{s{\times}t}$ to simulate the double size of the
intermediate products (\MUL-2D), producing
$\mu\in\D^{s{\times}(2t)}$ matrix $\mu^{(2)}$, as
in~\cref{eq:bilinkarasplit}, that is used as an input in~\cref{alg:doublebilin}.
This is shown in~\cref{alg:doubleexpand}.

\begin{algorithm}[htbp]
\caption{Double expansion of output matrix}\label{alg:doubleexpand}
\begin{algorithmic}
\REQUIRE $\mu\in\D^{m{\times}n}$ representing the
linear distribution of $n$ values to $m$ outputs.
\ENSURE $\mu^{(2)}\in\D^{(m+1){\times}(2n)}$, representing the linear
distribution of $n$ double-size values to $m+1$ outputs.
\STATE Let $\mu^{(2)}={0}^{(m+1){\times}(2n)}$;
\FOR{$j=0$ \To $n$}
\FOR{$i=0$ \To $m$}
\STATE $\mu^{(2)}(i,2j)=\mu(i,j)$;
\STATE $\mu^{(2)}(i+1,2j+1)=\mu(i,j)$;
\ENDFOR
\ENDFOR
\RETURN $\mu^{(2)}$.
\end{algorithmic}
\end{algorithm}

\begin{lemma}\Cref{alg:doubleexpand} is correct.\end{lemma}
\begin{proof}
  It is sufficient to note that by expanding each
  coefficient to a $2{\times}2$ identity, then adding two successive
  rows is just a $2{\times}2$ merging of the last row of an identity
  with the first row of another identity.
  Therefore the resulting matrix,
  $\mu^{(2)}$, has for non-zero entries, exactly twice those of $\mu$.
\end{proof}

Now we prove, in \cref{lem:fullrank},
that in fact any double expansion of a representative matrix
is suitable for the in-place computation of~\cref{alg:doublebilin}.

\begin{lemma}\label{lem:fullrank}
  If $\mu$ does not contain any zero column, then each pair of columns
  of $\mu^{(2)}$, resulting from the expansion of a single column in $\mu$,
  contains an invertible lower triangular $2{\times}2$ submatrix.
\end{lemma}
\begin{proof}
Consider the top most non-zero element of a column.
It is expanded as a $2{\times}2$ identity matrix whose second row is
merged with the first row of the next identity matrix: in
picture, $\begin{smatrix} a \\ b\end{smatrix}$ is expanded to
$\begin{smatrix} a &0 \\ b & a\\ * & b\end{smatrix}$.
\end{proof}
