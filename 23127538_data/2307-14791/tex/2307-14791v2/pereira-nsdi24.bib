
% Journals

% First the Full Name is given, then the abbreviation used in the AMS Math
% Reviews, with an indication if it could not be found there.
% Note the 2nd overwrites the 1st, so swap them if you want the full name.

 %{AMS}
 @String{AMSTrans = "American Mathematical Society Translations" }
 @String{AMSTrans = "Amer. Math. Soc. Transl." }
 @String{BullAMS = "Bulletin of the American Mathematical Society" }
 @String{BullAMS = "Bull. Amer. Math. Soc." }
 @String{ProcAMS = "Proceedings of the American Mathematical Society" }
 @String{ProcAMS = "Proc. Amer. Math. Soc." }
 @String{TransAMS = "Transactions of the American Mathematical Society" }
 @String{TransAMS = "Trans. Amer. Math. Soc." }

 %ACM
 @String{CACM = "Communications of the {ACM}" }
 @String{CACM = "Commun. {ACM}" }
 @String{CompServ = "Comput. Surveys" }
 @String{JACM = "J. ACM" }
 @String{ACMMathSoft = "{ACM} Transactions on Mathematical Software" }
 @String{ACMMathSoft = "{ACM} Trans. Math. Software" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newsletter" }
 @String{SIGNUM = "{ACM} {SIGNUM} Newslett." }

 @String{AmerSocio = "American Journal of Sociology" }
 @String{AmerStatAssoc = "Journal of the American Statistical Association" }
 @String{AmerStatAssoc = "J. Amer. Statist. Assoc." }
 @String{ApplMathComp = "Applied Mathematics and Computation" }
 @String{ApplMathComp = "Appl. Math. Comput." }
 @String{AmerMathMonthly = "American Mathematical Monthly" }
 @String{AmerMathMonthly = "Amer. Math. Monthly" }
 @String{BIT = "{BIT}" }
 @String{BritStatPsych = "British Journal of Mathematical and Statistical
		  Psychology" }
 @String{BritStatPsych = "Brit. J. Math. Statist. Psych." }
 @String{CanMathBull = "Canadian Mathematical Bulletin" }
 @String{CanMathBull = "Canad. Math. Bull." }
 @String{CompApplMath = "Journal of Computational and Applied Mathematics" }
 @String{CompApplMath = "J. Comput. Appl. Math." }
 @String{CompPhys = "Journal of Computational Physics" }
 @String{CompPhys = "J. Comput. Phys." }
 @String{CompStruct = "Computers and Structures" }
 @String{CompStruct = "Comput. \& Structures" }
 @String{CompJour = "The Computer Journal" }
 @String{CompJour = "Comput. J." }
 @String{CompSysSci = "Journal of Computer and System Sciences" }
 @String{CompSysSci = "J. Comput. System Sci." }
 @String{Computing = "Computing" }
 @String{ContempMath = "Contemporary Mathematics" }
 @String{ContempMath = "Contemp. Math." }
 @String{Crelle = "Crelle's Journal" }
 @String{GiornaleMath = "Giornale di Mathematiche" }
 @String{GiornaleMath = "Giorn. Mat." } % didn't find in AMS MR., ibid.

 %IEEE
 @String{Computer = "{IEEE} Computer" }
 @String{IEEETransComp = "{IEEE} Transactions on Computers" }
 @String{IEEETransComp = "{IEEE} Trans. Comput." }
 @String{IEEETransAC = "{IEEE} Transactions on Automatic Control" }
 @String{IEEETransAC = "{IEEE} Trans. Automat. Control" }
 @String{IEEESpec = "{IEEE} Spectrum" } % didn't find in AMS MR
 @String{ProcIEEE = "Proceedings of the {IEEE}" }
 @String{ProcIEEE = "Proc. {IEEE}" } % didn't find in AMS MR
 @String{IEEETransAeroElec = "{IEEE} Transactions on Aerospace and Electronic
	 Systems" }
 @String{IEEETransAeroElec = "{IEEE} Trans. Aerospace Electron. Systems" }

 @String{IMANumerAna = "{IMA} Journal of Numerical Analysis" }
 @String{IMANumerAna = "{IMA} J. Numer. Anal." }
 @String{InfProcLet = "Information Processing Letters" }
 @String{InfProcLet = "Inform. Process. Lett." }
 @String{InstMathApp = "Journal of the Institute of Mathematics and
	 its Applications" }
 @String{InstMathApp = "J. Inst. Math. Appl." }
 @String{IntControl = "International Journal of Control" }
 @String{IntControl = "Internat. J. Control" }
 @String{IntNumerEng = "International Journal for Numerical Methods in
	 Engineering" }
 @String{IntNumerEng = "Internat. J. Numer. Methods Engrg." }
 @String{IntSuper = "International Journal of Supercomputing Applications" }
 @String{IntSuper = "Internat. J. Supercomputing Applic." } % didn't find
%% in AMS MR
 @String{Kibernetika = "Kibernetika" }
 @String{JResNatBurStand = "Journal of Research of the National Bureau
	 of Standards" }
 @String{JResNatBurStand = "J. Res. Nat. Bur. Standards" }
 @String{LinAlgApp = "Linear Algebra and its Applications" }
 @String{LinAlgApp = "Linear Algebra Appl." }
 @String{MathAnaAppl = "Journal of Mathematical Analysis and Applications" }
 @String{MathAnaAppl = "J. Math. Anal. Appl." }
 @String{MathAnnalen = "Mathematische Annalen" }
 @String{MathAnnalen = "Math. Ann." }
 @String{MathPhys = "Journal of Mathematical Physics" }
 @String{MathPhys = "J. Math. Phys." }
 @String{MathComp = "Mathematics of Computation" }
 @String{MathComp = "Math. Comp." }
 @String{MathScand = "Mathematica Scandinavica" }
 @String{MathScand = "Math. Scand." }
 @String{TablesAidsComp = "Mathematical Tables and Other Aids to Computation" }
 @String{TablesAidsComp = "Math. Tables Aids Comput." }
 @String{NumerMath = "Numerische Mathematik" }
 @String{NumerMath = "Numer. Math." }
 @String{PacificMath = "Pacific Journal of Mathematics" }
 @String{PacificMath = "Pacific J. Math." }
 @String{ParDistComp = "Journal of Parallel and Distributed Computing" }
 @String{ParDistComp = "J. Parallel and Distrib. Comput." } % didn't find
%% in AMS MR
 @String{ParComputing = "Parallel Computing" }
 @String{ParComputing = "Parallel Comput." }
 @String{PhilMag = "Philosophical Magazine" }
 @String{PhilMag = "Philos. Mag." }
 @String{ProcNAS = "Proceedings of the National Academy of Sciences
					of the USA" }
 @String{ProcNAS = "Proc. Nat. Acad. Sci. U. S. A." }
 @String{Psychometrika = "Psychometrika" }
 @String{QuartMath = "Quarterly Journal of Mathematics, Oxford, Series (2)" }
 @String{QuartMath = "Quart. J. Math. Oxford Ser. (2)" }
 @String{QuartApplMath = "Quarterly of Applied Mathematics" }
 @String{QuartApplMath = "Quart. Appl. Math." }
 @String{RevueInstStat = "Review of the International Statisical Institute" }
 @String{RevueInstStat = "Rev. Inst. Internat. Statist." }

 %SIAM
 @String{JSIAM = "Journal of the Society for Industrial and Applied
	 Mathematics" }
 @String{JSIAM = "J. Soc. Indust. Appl. Math." }
 @String{JSIAMB = "Journal of the Society for Industrial and Applied
	 Mathematics, Series B, Numerical Analysis" }
 @String{JSIAMB = "J. Soc. Indust. Appl. Math. Ser. B Numer. Anal." }
 @String{SIAMAlgMeth = "{SIAM} Journal on Algebraic and Discrete Methods" }
 @String{SIAMAlgMeth = "{SIAM} J. Algebraic Discrete Methods" }
 @String{SIAMAppMath = "{SIAM} Journal on Applied Mathematics" }
 @String{SIAMAppMath = "{SIAM} J. Appl. Math." }
 @String{SIAMComp = "{SIAM} Journal on Computing" }
 @String{SIAMComp = "{SIAM} J. Comput." }
 @String{SIAMMatrix = "{SIAM} Journal on Matrix Analysis and Applications" }
 @String{SIAMMatrix = "{SIAM} J. Matrix Anal. Appl." }
 @String{SIAMNumAnal = "{SIAM} Journal on Numerical Analysis" }
 @String{SIAMNumAnal = "{SIAM} J. Numer. Anal." }
 @String{SIAMReview = "{SIAM} Review" }
 @String{SIAMReview = "{SIAM} Rev." }
 @String{SIAMSciStat = "{SIAM} Journal on Scientific and Statistical
	 Computing" }
 @String{SIAMSciStat = "{SIAM} J. Sci. Statist. Comput." }

 @String{SoftPracExp = "Software Practice and Experience" }
 @String{SoftPracExp = "Software Prac. Experience" } % didn't find in AMS MR
 @String{StatScience = "Statistical Science" }
 @String{StatScience = "Statist. Sci." }
 @String{Techno = "Technometrics" }
 @String{USSRCompMathPhys = "{USSR} Computational Mathematics and Mathematical
	 Physics" }
 @String{USSRCompMathPhys = "{U. S. S. R.} Comput. Math. and Math. Phys." }
 @String{VLSICompSys = "Journal of {VLSI} and Computer Systems" }
 @String{VLSICompSys = "J. {VLSI} Comput. Syst." }
 @String{ZAngewMathMech = "Zeitschrift fur Angewandte Mathematik und
	 Mechanik" }
 @String{ZAngewMathMech = "Z. Angew. Math. Mech." }
 @String{ZAngewMathPhys = "Zeitschrift fur Angewandte Mathematik und Physik" }
 @String{ZAngewMathPhys = "Z. Angew. Math. Phys." }

% Publishers % ================================================= |

 @String{Academic = "Academic Press" }
 @String{ACMPress = "{ACM} Press" }
 @String{AdamHilger = "Adam Hilger" }
 @String{AddisonWesley = "Addison-Wesley" }
 @String{AllynBacon = "Allyn and Bacon" }
 @String{AMS = "American Mathematical Society" }
 @String{Birkhauser = "Birkha{\"u}ser" }
 @String{CambridgePress = "Cambridge University Press" }
 @String{Chelsea = "Chelsea" }
 @String{ClaredonPress = "Claredon Press" }
 @String{DoverPub = "Dover Publications" }
 @String{Eyolles = "Eyolles" }
 @String{HoltRinehartWinston = "Holt, Rinehart and Winston" }
 @String{Interscience = "Interscience" }
 @String{JohnsHopkinsPress = "The Johns Hopkins University Press" }
 @String{JohnWileySons = "John Wiley and Sons" }
 @String{Macmillan = "Macmillan" }
 @String{MathWorks = "The Math Works Inc." }
 @String{McGrawHill = "McGraw-Hill" }
 @String{NatBurStd = "National Bureau of Standards" }
 @String{NorthHolland = "North-Holland" }
 @String{OxfordPress = "Oxford University Press" }  %address Oxford or London?
 @String{PergamonPress = "Pergamon Press" }
 @String{PlenumPress = "Plenum Press" }
 @String{PrenticeHall = "Prentice-Hall" }
 @String{SIAMPub = "{SIAM} Publications" }
 @String{Springer = "Springer-Verlag" }
 @String{TexasPress = "University of Texas Press" }
 @String{VanNostrand = "Van Nostrand" }
 @String{WHFreeman = "W. H. Freeman and Co." }

%Entries

@IEEEtranBSTCTL{IEEEexample:BSTcontrol,CTLdash_repeated_names = "no"}

@inproceedings {Panda2016,
	author={Panda, Aurojit and Han, Sangjin and Jang, Keon and Walls, Melvin and Ratnasamy, Sylvia and Shenker, Scott},
	title={{NetBricks}: Taking the {V} out of {NFV}},
	booktitle={12th {USENIX} Symposium on Operating Systems Design and Implementation ({OSDI}'16)},
	year = {2016},
	isbn = {978-1-931971-33-1},
	address = {Savannah, GA},
	pages = {203--216},
	url = {https://www.usenix.org/conference/osdi16/technical-sessions/presentation/panda},
	publisher = {{USENIX} Association},
	month = nov,
}

@article{Herlihy1993,
	author = {Herlihy, Maurice},
	doi = {10.1145/161468.161469},
	issn = {15584593},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	number = {5},
	pages = {745--770},
	title = {{A Methodology for Implementing Highly Concurrent Data Objects}},
	volume = {15},
	year = {1993}
}

@article{Deri2004,
	author = {Deri, Luca},
	journal = {Proceedings of SANE},
	keywords = {device polling,linux,netflow,passive packet capture},
	pages = {85},
	title = {{Improving Passive Packet Capture : Beyond Device Polling}},
	volume = {2004},
	year = {2004}
}

@article{Byma2014,
	author = {Byma, Stuart and Steffan, J. Gregory and Bannazadeh, Hadi and Leon-Garcia, Alberto and Chow, Paul},
	doi = {10.1109/FCCM.2014.42},
	isbn = {9781479951116},
	journal = {Proceedings - 2014 IEEE 22nd International Symposium on Field-Programmable Custom Computing Machines, FCCM 2014},
	pages = {109--116},
	publisher = {IEEE},
	title = {{FPGAs in the cloud: Booting virtualized hardware accelerators with OpenStack}},
	year = {2014}
}

@article{Nobach2015,
	author = {Nobach, Leonhard and Hausheer, David},
	doi = {10.1109/NetSys.2015.7089057},
	isbn = {9781479958047},
	journal = {Proceedings - International Conference on Networked Systems, NetSys 2015},
	pages = {1--5},
	publisher = {IEEE},
	title = {{Open, elastic provisioning of hardware acceleration in NFV environments}},
	year = {2015}
}

@article{Architecture2014,
	author = {Architecture, Control},
	journal = {Onf Tr-502},
	number = {March},
	pages = {68},
	title = {{ONF SDN Architecture}},
	url = {https://www.opennetworking.org/images/stories/downloads/sdn-resources/technical-reports/TR_SDN_ARCH_1.0_06062014.pdf},
	year = {2014}
}

@inproceedings{chiosi2012network,
  title={Network functions virtualisation: An introduction, benefits, enablers, challenges and call for action},
  author={Chiosi, Margaret and Clarke, Don and Willis, Peter and Reid, Andy and Feger, James and Bugenhagen, Michael and Khan, Waqar and Fargano, Michael and Cui, Chunfeng and Deng, Hui and others},
  booktitle={SDN and OpenFlow World Congress},
  month={oct},
  year={2012},
  note={Retrieved 2023-04-25},
  url={https://portal.etsi.org/NFV/NFV_White_Paper.pdf}
}

@misc{etsi2012specification,
	author = {{European Telecommunications Standards Institute (ETSI)}},
	title = {{Network Functions Virtualisation (NFV)}},
	url = {https://www.etsi.org/technologies/nfv},
	note = {Retrieved 2023-04-25},
}

@misc{ETSIIndustrySpecificationGroupISGNetworkFunctionsVirtualisationNFV2017,
	author = {{Network Functions Virtualisation (NFV) ETSI Industry Specification Group (ISG)}},
	keywords = {NFV,use case},
	title = {{ETSI GS NFV 001 - V1.2.1 - Network Functions Virtualisation (NFV); Use Cases}},
	url = {https://www.etsi.org/deliver/etsi_gr/NFV/001_099/001/01.02.01_60/gr_nfv001v010201p.pdf},
	note = {Retrieved 2023-04-25},
	year = {2017}
}

@misc{ETSIIndustrySpecificationGroupISGNetworkFunctionsVirtualisationNFV2014,
	author = {{Network Functions Virtualisation (NFV) ETSI Industry Specification Group (ISG)}},
	title = {{ETSI GS NFV 002 - V1.2.1 - Network Functions Virtualisation (NFV); Architectural Framework}},
	url = {https://www.etsi.org/deliver/etsi_gs/NFV/001_099/002/01.02.01_60/gs_nfv002v010201p.pdf},
	note = {Retrieved 2023-04-25},
	year = {2014}
}

@article{Bonelli2016,
  author={Bonelli, Nicola and Giordano, Stefano and Procissi, Gregorio},
  journal={IEEE Journal on Selected Areas in Communications}, 
  title={{Network Traffic Processing With PFQ}}, 
  year={2016},
  volume={34},
  number={6},
  pages={1819-1833},
  doi={10.1109/JSAC.2016.2558998}
}

@misc{Ntop2014,
	author = {Ntop},
	title = {{PF{\_}RING ZC (Zero Copy)}},
	year = {2014},
	note = {\url{https://www.ntop.org/products/packet-capture/pf_ring/pf_ring-zc-zero-copy}}
}

@misc{IntelPMD2010,
	author = {Intel},
	title = {{DPDK: Poll Mode Driver}},
	year = 2023,
	note = {\url{https://doc.dpdk.org/guides/prog_guide/poll_mode_drv.html}}
}

@misc{Intel2010,
	author = {Intel},
	title = {{Data Plane Development Kit}},
	year = {2010},
	note = {\url{https://www.dpdk.org}}
}

@misc{rtm,
	author = {Intel},
	title = {{Restricted Transactional Memory Overview}},
	year = 2023,
	note = {\url{https://www.intel.com/content/www/us/en/docs/cpp-compiler/developer-guide-reference/2021-8/restricted-transactional-memory-overview.html}}
}

@article{Egi,
	author = {Egi, Norbert and Dobrescu, Mihai and Du, Jianqing and Argyraki, Katerina and Chun, Byung-gon and Fall, Kevin and Iannaccone, Gianluca and Knies, Allan and Manesh, Maziar and Mathy, Laurent and Ratnasamy, Sylvia and Research, Intel},
	journal = {Network},
	number = {December 2016},
	title = {{Understanding the Packet Processing Capability of Multi-Core Servers}}
}

@article{Su2017,
	author = {Su, Zidong and Baynat, Bruno and Begin, Thomas},
	doi = {10.1109/NETSOFT.2017.8004211},
	isbn = {9781509060085},
	journal = {2017 IEEE Conference on Network Softwarization: Softwarization Sustaining a Hyper-Connected World: en Route to 5G, NetSoft 2017},
	keywords = {DPDK,NFV,modeling,performance evaluation,polling system,switch-over time,virtual switch},
	pages = {1--5},
	title = {{A new model for DPDK-based virtual switches}},
	year = {2017}
}

@inproceedings{Cadar2008,
    author = {Cadar, Cristian and Dunbar, Daniel and Engler, Dawson},
    title = {{KLEE: Unassisted and Automatic Generation of High-Coverage Tests for Complex Systems Programs}},
    year = {2008},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {We present a new symbolic execution tool, KLEE, capable of automatically generating tests that achieve high coverage on a diverse set of complex and environmentally-intensive programs. We used KLEE to thoroughly check all 89 stand-alone programs in the GNU COREUTILS utility suite, which form the core user-level environment installed on millions of Unix systems, and arguably are the single most heavily tested set of open-source programs in existence. KLEE-generated tests achieve high line coverage -- on average over 90\% per tool (median: over 94\%) -- and significantly beat the coverage of the developers' own hand-written test suite. When we did the same for 75 equivalent tools in the BUSYBOX embedded system suite, results were even better, including 100\% coverage on 31 of them.We also used KLEE as a bug finding tool, applying it to 452 applications (over 430K total lines of code), where it found 56 serious bugs, including three in COREUTILS that had been missed for over 15 years. Finally, we used KLEE to crosscheck purportedly identical BUSYBOX and COREUTILS utilities, finding functional correctness errors and a myriad of inconsistencies.},
    booktitle = {Proceedings of the 8th USENIX Conference on Operating Systems Design and Implementation},
    pages = {209–224},
    numpages = {16},
    location = {San Diego, California},
    series = {OSDI'08}
}

@inproceedings{Rizzo2012,
    author = {Rizzo, Luigi},
    title = {{Netmap: A Novel Framework for Fast Packet I/O}},
    year = {2012},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Many applications (routers, traffic monitors, firewalls, etc.) need to send and receive packets at line rate even on very fast links. In this paper we present netmap, a novel framework that enables commodity operating systems to handle the millions of packets per seconds traversing 1..10 Gbit/s links, without requiring custom hardware or changes to applications.In building netmap, we identified and successfully reduced or removed three main packet processing costs: per-packet dynamic memory allocations, removed by preallocating resources; system call overheads, amortized over large batches; and memory copies, eliminated by sharing buffers and metadata between kernel and userspace, while still protecting access to device registers and other kernel memory areas. Separately, some of these techniques have been used in the past. The novelty in our proposal is not only that we exceed the performance of most of previouswork, but also that we provide an architecture that is tightly integrated with existing operating system primitives, not tied to specific hardware, and easy to use and maintain.Netmap has been implemented in FreeBSD and Linux for several 1 and 10 Gbit/s network adapters. In our prototype, a single core running at 900 MHz can send or receive 14.88 Mpps (the peak packet rate on 10 Gbit/s links). This is more than 20 times faster than conventional APIs. Large speedups (5\texttimes{} and more) are also achieved on user-space Click and other packet forwarding applications using a libpcap emulation library running on top of netmap.},
    booktitle = {Proceedings of the 2012 USENIX Conference on Annual Technical Conference},
    pages = {9},
    numpages = {1},
    location = {Boston, MA},
    series = {USENIX ATC'12}
}

@inproceedings{Dobrescu2009,
    author = {Dobrescu, Mihai and Egi, Norbert and Argyraki, Katerina and Chun, Byung-Gon and Fall, Kevin and Iannaccone, Gianluca and Knies, Allan and Manesh, Maziar and Ratnasamy, Sylvia},
    title = {{RouteBricks: Exploiting Parallelism to Scale Software Routers}},
    year = {2009},
    isbn = {9781605587523},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1629575.1629578},
    doi = {10.1145/1629575.1629578},
    abstract = {We revisit the problem of scaling software routers, motivated by recent advances in server technology that enable high-speed parallel processing--a feature router workloads appear ideally suited to exploit. We propose a software router architecture that parallelizes router functionality both across multiple servers and across multiple cores within a single server. By carefully exploiting parallelism at every opportunity, we demonstrate a 35Gbps parallel router prototype; this router capacity can be linearly scaled through the use of additional servers. Our prototype router is fully programmable using the familiar Click/Linux environment and is built entirely from off-the-shelf, general-purpose server hardware.},
    booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
    pages = {15–28},
    numpages = {14},
    keywords = {multicore, parallelism, programmability, software router},
    location = {Big Sky, Montana, USA},
    series = {SOSP '09}
}

@article{Trevisan2016,
    author = {Trevisan, Martino and Finamore, Alessandro and Mellia, Marco and Munafo, Maurizio and Rossi, Dario},
    title = {{Traffic Analysis with Off-the-Shelf Hardware: Challenges and Lessons Learned}},
    year = {2017},
    issue_date = {March 2017},
    publisher = {IEEE Press},
    volume = {55},
    number = {3},
    issn = {0163-6804},
    url = {https://doi.org/10.1109/MCOM.2017.1600756CM},
    doi = {10.1109/MCOM.2017.1600756CM},
    abstract = {In recent years, the progress in both hardware and software allows user-space applications to capture packets at 10 Gb/s line rate or more, with cheap COTS hardware. However, processing packets at such rates with software is still far from being trivial. In the literature, this challenge has been extensively studied for network intrusion detection systems, where per-packet operations are easy to parallelize with support of hardware acceleration. Conversely, the scalability of statistical traffic analyzers (STAs) is intrinsically complicated by the need to track per-flow state to collect statistics. This challenge has received less attention so far, and it is the focus of this work. We present and discuss design choices to enable a STA to collects hundreds of per-flow metrics at a multi-10-Gb/s line rate. We leverage a handful of hardware advancements proposed over the last years (e.g., RSS queues, NUMA architecture), and we provide insights on the trade-offs they imply when combined with state-of-the-art packet capture libraries and the multi-process paradigm. We outline the principles to design an optimized STA, and we implement them to engineer DPDKStat, a solution combining the Intel DPDK framework with the traffic analyzer Tstat. Using traces collected from real networks, we demonstrate that DPDKStat achieves 40 Gb/s of aggregated rate with a single COTS PC.},
    journal = {Comm. Mag.},
    month = {mar},
    pages = {163–169},
    numpages = {7}
}


@inproceedings{Zaostrovnykh2017,
    author = {Zaostrovnykh, Arseniy and Pirelli, Solal and Pedrosa, Luis and Argyraki, Katerina and Candea, George},
    title = {{A Formally Verified NAT}},
    year = {2017},
    isbn = {9781450346535},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3098822.3098833},
    doi = {10.1145/3098822.3098833},
    abstract = {We present a Network Address Translator (NAT) written in C and proven to be semantically correct according to RFC 3022, as well as crash-free and memory-safe. There exists a lot of recent work on network verification, but it mostly assumes models of network functions and proves properties specific to network configuration, such as reachability and absence of loops. Our proof applies directly to the C code of a network function, and it demonstrates the absence of implementation bugs. Prior work argued that this is not feasible (i.e., that verifying a real, stateful network function written in C does not scale) but we demonstrate otherwise: NAT is one of the most popular network functions and maintains per-flow state that needs to be properly updated and expired, which is a typical source of verification challenges. We tackle the scalability challenge with a new combination of symbolic execution and proof checking using separation logic; this combination matches well the typical structure of a network function. We then demonstrate that formally proven correctness in this case does not come at the cost of performance. The NAT code, proof toolchain, and proofs are available at [58].},
    booktitle = {Proceedings of the Conference of the ACM Special Interest Group on Data Communication},
    pages = {141–154},
    numpages = {14},
    keywords = {Network-Function Verification, Symbolic Execution, Lazy Proofs},
    location = {Los Angeles, CA, USA},
    series = {SIGCOMM '17}
}

@inproceedings{Barbette2015,
    author = {Barbette, Tom and Soldani, Cyril and Mathy, Laurent},
    title = {{Fast Userspace Packet Processing}},
    year = {2015},
    isbn = {9781467366328},
    publisher = {IEEE Computer Society},
    address = {USA},
    abstract = {In recent years, we have witnessed the emergence of high speed packet I/O frameworks, bringing unprecedented network performance to userspace. Using the Click modular router, we first review and quantitatively compare several such packet I/O frameworks, showing their superiority to kernel-based forwarding. We then reconsider the issue of software packet processing, in the context of modern commodity hardware with hardware multi-queues, multi-core processors and non-uniform memory access. Through a combination of existing techniques and improvements of our own, we derive modern general principles for the design of software packet processors. Our implementation of a fast packet processor framework, integrating a faster Click with both Netmap and DPDK, exhibits up-to about 2.3x speed-up compared to other software implementations, when used as an IP router.},
    booktitle = {Proceedings of the Eleventh ACM/IEEE Symposium on Architectures for Networking and Communications Systems},
    pages = {5–16},
    numpages = {12},
    keywords = {intel dpdk, fast packet i/o, high-speed net- working, userspace i/o, netmap, network processing., click modular router, numa, multi-queue},
    location = {Oakland, California, USA},
    series = {ANCS '15}
}

@inproceedings{Emmerich2015,
    author = {Emmerich, Paul and Gallenm\"{u}ller, Sebastian and Raumer, Daniel and Wohlfart, Florian and Carle, Georg},
    title = {{MoonGen: A Scriptable High-Speed Packet Generator}},
    year = {2015},
    isbn = {9781450338486},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2815675.2815692},
    doi = {10.1145/2815675.2815692},
    abstract = {We present MoonGen, a flexible high-speed packet generator. It can saturate 10 GbE links with minimum-sized packets while using only a single CPU core by running on top of the packet processing framework DPDK. Linear multi-core scaling allows for even higher rates: We have tested MoonGen with up to 178.5 Mpps at 120 Gbit/s. Moving the whole packet generation logic into user-controlled Lua scripts allows us to achieve the highest possible flexibility. In addition, we utilize hardware features of commodity NICs that have not been used for packet generators previously. A key feature is the measurement of latency with sub-microsecond precision and accuracy by using hardware timestamping capabilities of modern commodity NICs. We address timing issues with software-based packet generators and apply methods to mitigate them with both hardware support and with a novel method to control the inter-packet gap in software. Features that were previously only possible with hardware-based solutions are now provided by MoonGen on commodity hardware. MoonGen is available as free software under the MIT license in our git repository at https://github.com/emmericp/MoonGen},
    booktitle = {Proceedings of the 2015 Internet Measurement Conference},
    pages = {275–287},
    numpages = {13},
    keywords = {dpdk, user space networking, packet generation, lua},
    location = {Tokyo, Japan},
    series = {IMC '15}
}

@article{Mijumbi2016,
	archivePrefix = {arXiv},
	arxivId = {1509.07675},
	author = {Mijumbi, Rashid and Serrat, Joan and Gorricho, Juan Luis and Bouten, Niels and {De Turck}, Filip and Boutaba, Raouf},
	doi = {10.1109/COMST.2015.2477041},
	eprint = {1509.07675},
	issn = {1553877X},
	journal = {IEEE Communications Surveys and Tutorials},
	keywords = {Cloud computing,Future Internet,Network function virtualization,Software defined networking,Virtual network functions},
	number = {1},
	pages = {236--262},
	title = {{Network function virtualization: State-of-the-art and research challenges}},
	volume = {18},
	year = {2016}
}

@article{Han2015,
	author = {Han, Bo and Gopalakrishnan, Vijay and Ji, Lusheng and Lee, Seungjoon},
	doi = {10.1109/MCOM.2015.7045396},
	issn = {01636804},
	journal = {IEEE Communications Magazine},
	number = {2},
	pages = {90--97},
	title = {{Network function virtualization: Challenges and opportunities for innovations}},
	volume = {53},
	year = {2015}
}

@inproceedings{Emmerich2018,
	author = {Emmerich, Paul and Pudelko, Maximilian and Bauer, Simon and Carle, Georg},
    title = {{User Space Network Drivers}},
    year = {2018},
    isbn = {9781450355858},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3232755.3232767},
    doi = {10.1145/3232755.3232767},
    abstract = {The rise of user space packet processing frameworks like DPDK and netmap makes low-level code more accessible to developers and researchers. Previously, driver code was hidden in the kernel and rarely modified-or even looked at-by developers working at higher layers. These barriers are gone nowadays, yet developers still treat user space drivers as black-boxes magically accelerating applications. We want to change this: every researcher building network applications should understand the intricacies of the underlying drivers, especially if they impact performance. We present ixy, a user space network driver designed for simplicity and educational purposes. Ixy focuses on the bare essentials of user space packet processing: a packet forwarder including the whole NIC driver uses less than 1000 lines of C code.Our code is available as free and open source under the BSD license at https://github.com/emmericp/ixy.},
    booktitle = {Proceedings of the Applied Networking Research Workshop},
    pages = {91–93},
    numpages = {3},
    location = {Montreal, QC, Canada},
    series = {ANRW '18}
}

@article{Krawczyk1994,
	author = {Krawczyk, Hugo},
	doi = {10.1007/3-540-48658-5_15},
	isbn = {9783540583332},
	issn = {16113349},
	journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
	pages = {129--139},
	title = {{LFSR-based hashing and authentication}},
	volume = {839 LNCS},
	year = {1994}
}

@article{Jiang2013,
	author = {Jiang, Haiyang and Zhang, Guangxing and Xie, Gaogang and Salamatian, Kave and Mathy, Laurent},
	doi = {10.1109/ANCS.2013.6665196},
	isbn = {9781479916405},
	journal = {ANCS 2013 - Proceedings of the 9th ACM/IEEE Symposium on Architectures for Networking and Communications Systems},
	keywords = {load balancing,many-core,network intrusion detection system,parallel},
	pages = {137--146},
	title = {{Scalable high-performance parallel design for Network Intrusion Detection Systems on many-core processors}},
	year = {2013}
}

@article{Woo2012,
	author = {Woo, Shinae and Park, Kyoungsoo},
	title = {{Scalable TCP session monitoring with symmetric receive-side scaling}},
	journal={KAIST, Daejeon, Korea, Tech. Rep},
    volume={144},
    year={2012},
    publisher={Citeseer}
}

@article{Rogers2009,
	author = {Rogers, Brian M. and Krishna, Anil and Bell, Gordon B. and Vu, Ken and Jiang, Xiaowei and Solihin, Yan},
	doi = {10.1145/1555815.1555801},
	isbn = {9781605585260},
	issn = {01635964},
	journal = {ACM SIGARCH Computer Architecture News},
	number = {3},
	pages = {371},
	title = {{Scaling the bandwidth wall}},
	volume = {37},
	year = {2009}
}

@article{Vesovic2017,
	author = {Vesovi{\'{c}}, Mihailo and Smiljani{\'{c}}, Aleksandra and Toma{\v{s}}evi{\'{c}}, Milo},
	doi = {10.5937/telfor1701002V},
	issn = {23349905},
	journal = {Telfor Journal},
	keywords = {10 GbE,High speed packet I/O,IP lookup,Parallelization,Software routers},
	number = {1},
	pages = {2--7},
	title = {{Speeding up ip lookup procedure in software routers by means of parallelization}},
	volume = {9},
	year = {2017}
}

@article{Asai2018,
	author = {Asai, Hirochika},
	doi = {10.1109/NETSOFT.2018.8460009},
	isbn = {9781538646335},
	journal = {2018 4th IEEE Conference on Network Softwarization and Workshops, NetSoft 2018},
	number = {NetSoft},
	pages = {141--149},
	publisher = {IEEE},
	title = {{Efficient Multicore Scaling in Software Packet Forwarding Engines}},
	year = {2018}
}

@article{Intel,
	author = {Intel, From and Platform, Acceleration},
	title = {{High-Performance Multi-Core Networking Software Design Options}}
}

@article{Fusco2010,
	author = {Fusco, Francesco and Luca, Deri},
	doi = {10.1145/1879141.1879169},
	isbn = {9781450300575},
	journal = {Proceedings of the ACM SIGCOMM Internet Measurement Conference, IMC},
	keywords = {Linux kernel,Multi-core systems,Network packet capture},
	pages = {218--224},
	title = {{High speed network traffic analysis with commodity multi-core systems}},
	year = {2010}
}

@article{Egi2008,
	author = {Egi, Norbert and Greenhalgh, Adam and Handley, Mark and Hoerdt, Mickael and Huici, Felipe and Mathy, Laurent},
	doi = {10.1145/1544012.1544032},
	isbn = {9781605582108},
	journal = {Proceedings of 2008 ACM CoNEXT Conference - 4th International Conference on Emerging Networking EXperiments and Technologies, CoNEXT '08},
	title = {{Towards high performance virtual routers on commodity hardware}},
	year = {2008}
}

@article{Ge2014,
	author = {Ge, Xiongzi and Liu, Yi and Du, David H.C. and Zhang, Liang and Guan, Hongguang and Chen, Jian and Zhao, Yuping and Hu, Xinyu},
	doi = {10.1145/2740070.2631426},
	isbn = {9781450328364},
	issn = {01464833},
	journal = {ACM SIGCOMM Computer Communication Review},
	keywords = {middlebox,network function virtualization,openstack},
	number = {4},
	pages = {353--354},
	title = {{OpenANFV: Accelerating Network Function Virtualization with a Consolidated Framework in OpenStack}},
	volume = {44},
	year = {2014}
}

@article{Hanford2016,
	author = {Hanford, Nathan and Ahuja, Vishal and Farrens, Matthew and Ghosal, Dipak and Balman, Mehmet and Pouyoul, Eric and Tierney, Brian},
	doi = {10.1016/j.future.2015.09.012},
	issn = {0167739X},
	journal = {Future Generation Computer Systems},
	keywords = {Congestion avoidance,End-system bottleneck,Flow control,GridFTP,Networks,Traffic shaping},
	pages = {277--283},
	publisher = {Elsevier B.V.},
	title = {{Improving network performance on multicore systems: Impact of core affinities on high throughput flows}},
	url = {http://dx.doi.org/10.1016/j.future.2015.09.012},
	volume = {56},
	year = {2016}
}

@misc{rss,
  author = {Amy Viviano},
  title = {{Introduction to Receive Side Scaling}},
  note = {\url{https://docs.microsoft.com/en-us/windows-hardware/drivers/network/introduction-to-receive-side-scaling}},
  year = {2023}
}

@misc{rss-hashes,
	author = {{Microsoft Inc.}},
	title = {{RSS Hashing Functions}},
    year = 2023,
	note = {\url{https://learn.microsoft.com/en-us/windows-hardware/drivers/network/rss-hashing-functions}}
}

@misc{dpdk-rss-fields,
	author = {{Intel}},
	title = {{RSS compatible packet fields on the DPDK RSS API}},
    year = 2023,
	note = {\url{https://github.com/DPDK/dpdk/blob/4fceceed5b5e9fbf04acffd66239c79d81e79260/lib/ethdev/rte_ethdev.h\#L572}}
}

@misc{pktgen,
	author = {{Keith Wiles}},
	title = {{Pktgen - Traffic Generator powered by DPDK}},
    year = 2023,
	note = {\url{https://github.com/pktgen/Pktgen-DPDK}}
}

@misc{DDIO,
	author = {Intel},
	title = {{Intel data-direct I/O technology}},
    year = 2023,
	note = {\url{https://www.intel.com/content/www/us/en/io/data-direct-i-o-technology.html}}
}

@article{Sherry2012,
	 author = {Sherry, Justine and Hasan, Shaddi and Scott, Colin and Krishnamurthy, Arvind and Ratnasamy, Sylvia and Sekar, Vyas},
	 title = {Making Middleboxes Someone else's Problem: Network Processing As a Cloud Service},
	 journal = {SIGCOMM Comput. Commun. Rev.},
	 issue_date = {October 2012},
	 volume = {42},
	 number = {4},
	 month = aug,
	 year = {2012},
	 issn = {0146-4833},
	 pages = {13--24},
	 numpages = {12},
	 url = {http://doi.acm.org/10.1145/2377677.2377680},
	 doi = {10.1145/2377677.2377680},
	 acmid = {2377680},
	 publisher = {ACM},
	 address = {New York, NY, USA},
	 keywords = {cloud, middlebox, outsourcing},
} 

@techreport{Dagum1998,
	author = {Dagum, Leonardo and Menon, Ramesh},
	title = {{OpenMP: An Industry-Standard API for Shared-Memory Programming}},
	url = {www.openmp.org.},
	year = {1998}
}

@techreport{fdio-vpp,
  title={{Vector Packet Processing - One Terabit Software Router on Intel Xeon Scalable Processor Family Server}},
  author={FD.io},
  year={2017},
  note={\url{https://fd.io/docs/whitepapers/FDioVPPwhitepaperJuly2017.pdf}}
}

@article{Papadogiannaki2017,
    author={Papadogiannaki, Eva and Koromilas, Lazaros and Vasiliadis, Giorgos and Ioannidis, Sotiris},
    journal={IEEE/ACM Transactions on Networking}, 
    title={{Efficient Software Packet Processing on Heterogeneous and Asymmetric Hardware Architectures}}, 
    year={2017},
    volume={25},
    number={3},
    pages={1593-1606},
    doi={10.1109/TNET.2016.2642338}
}

@article{Nam2015,
	author = {Nam, Jaehyun and Jamshed, Muhammad and Choi, Byungkwon and Han, Dongsu and Park, Kyoung Soo},
	doi = {10.1007/978-3-319-26362-5_5},
	isbn = {9783319263618},
	issn = {16113349},
	journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
	keywords = {Many-core processor,Network intrusion detection system,Offloading,Parallelism},
	pages = {89--110},
	title = {{Haetae: Scaling the performance of network intrusion detection with many-core processors}},
	volume = {9404},
	year = {2015}
}

@article{Gallenmuller2018,
	author = {Gallenm{\"{u}}ller, Sebastian and Scholz, Dominik and Wohlfart, Florian and Scheitle, Quirin and Emmerich, Paul and Carle, Georg},
	doi = {10.1109/COMSNETS.2018.8328173},
	isbn = {9781538611821},
	journal = {2018 10th International Conference on Communication Systems and Networks, COMSNETS 2018},
	keywords = {High-performance packet processing,Libmoon,MoonGen,Reproducible network measurements},
	pages = {1--8},
	title = {{High-performance packet processing and measurements}},
	volume = {2018-Janua},
	year = {2018}
}

@article{Jamshed2012,
	author = {Jamshed, Muhammad and Lee, Jihyung and Moon, Sangwoo and Kim, Deokjin and Lee, Sungryoul and Park, Kyoungsoo},
	isbn = {9781450316514},
	journal = {Proceedings of the 2012 ACM Conference on Computer and Communications Security},
	keywords = {batch processing,gpu,intrusion detection,pattern matching},
	pages = {317--328},
	title = {{Kargus: A Highly-scalable Software-based Intrusion Detection System Categories and Subject Descriptors}},
	year = {2012}
}

@inproceedings{Kumar2007,
	author = {Kumar, Amit and Huggahalli, Ram},
	booktitle = {Proceedings of the Annual International Symposium on Microarchitecture, MICRO},
	doi = {10.1109/MICRO.2007.22},
	isbn = {0769530478},
	issn = {10724451},
	pages = {161--171},
	title = {{Impact of cache coherence protocols on the processing of network traffic}},
	year = {2007}
}

@article{Egi2009,
	author = {Egi, Norbert and Greenhalgh, Adam and Handley, Mark and Iannaccone, Gianluca and Manesh, Maziar and Mathy, Laurent and Ratnasamy, Sylvia},
	doi = {10.1109/NPC.2009.39},
	isbn = {9780769538372},
	journal = {NPC 2009 - 6th International Conference on Network and Parallel Computing},
	pages = {117--124},
	title = {{Improved forwarding architecture and resource management for multi-core software routers}},
	year = {2009}
}

@article{Wu2018,
	author = {Wu, Xiaoban and Li, Peilong and Ran, Yongyi and Luo, Yan},
	doi = {10.1016/j.future.2017.04.038},
	issn = {0167739X},
	journal = {Future Generation Computer Systems},
	keywords = {100 Gbps,DPDK,Network measurement},
	pages = {180--189},
	title = {{Network measurement for 100 GbE network links using multicore processors}},
	volume = {79},
	year = {2018}
}

@techreport{OpenNetworkingFoundation2012,
  added-at = {2014-12-10T16:12:02.000+0100},
  author = {{ONF}},
  biburl = {https://www.bibsonomy.org/bibtex/229da0c7fde89c4ce2405166a57d16009/chesteve},
  institution = {Open Networking Foundation},
  interhash = {4e1d986e5343233ec534a5291d2b8921},
  intrahash = {29da0c7fde89c4ce2405166a57d16009},
  keywords = {imported},
  month = {April},
  timestamp = {2014-12-10T16:12:02.000+0100},
  title = {Software-Defined Networking: The New Norm for Networks},
  year = 2012
}

@inproceedings{scholz2014look,
  author = {Scholz, Dominik},
  title = {A Look at Intel's Dataplane Development Kit},
  booktitle = {Proceedings of the Seminars Future Internet ({FI}) and Innovative Internet Technologies and Mobile Communications ({IITM}), Summer Semester 2014},
  year = {2014},
  editor = {Carle, Georg and Raumer, Daniel and Schwaighofer, Lukas},
  volume = {NET-2014-08-1},
  series = {Network Architectures and Services ({NET})},
  pages = {115--122},
  address = {Munich, Germany},
  month = sep,
  publisher = {Chair for Network Architectures and Services, Department of Computer Science, Technische Universit{\"a}t M{\"u}nchen},
  doi = {10.2313/NET-2014-08-1_15},
  timestamp = {2014.09.03},
  url = {http://www.net.in.tum.de/fileadmin/TUM/NET/NET-2014-08-1/NET-2014-08-1_15.pdf},
  month_numeric = {9}
}

@inproceedings{zaostrovnykh2019verifying,
    author = {Zaostrovnykh, Arseniy and Pirelli, Solal and Iyer, Rishabh and Rizzo, Matteo and Pedrosa, Luis and Argyraki, Katerina and Candea, George},
    title = {{Verifying Software Network Functions with No Verification Expertise}},
    year = {2019},
    isbn = {9781450368735},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3341301.3359647},
    doi = {10.1145/3341301.3359647},
    abstract = {We present the design and implementation of Vigor, a software stack and toolchain for building and running software network middleboxes that are guaranteed to be correct, while preserving competitive performance and developer productivity. Developers write the core of the middlebox---the network function (NF)---in C, on top of a standard packet-processing framework, putting persistent state in data structures from Vigor's library; the Vigor toolchain then automatically verifies that the resulting software stack correctly implements a specification, which is written in Python.Vigor has three key features: network function developers need no verification expertise, and the verification process does not require their assistance (push-button verification); the entire software stack is verified, down to the hardware (full-stack verification); and verification can be done in a pay-as-you-go manner, i.e., instead of investing upfront a lot of time in writing and verifying a complete specification, one can specify one-off properties in a few lines of Python and verify them without concern for the rest.We developed five representative NFs---a NAT, a Maglev load balancer, a MAC-learning bridge, a firewall, and a traffic policer---and verified with Vigor that they satisfy standards-derived specifications, are memory-safe, and do not crash or hang. We show that they provide competitive performance.The Vigor framework is available at http://vigor.epfl.ch.},
    booktitle = {Proceedings of the 27th ACM Symposium on Operating Systems Principles},
    pages = {275–290},
    numpages = {16},
    location = {Huntsville, Ontario, Canada},
    series = {SOSP '19}
}

@article{sutter2005free,
  title={The free lunch is over: A fundamental turn toward concurrency in software},
  author={Sutter, Herb},
  journal={Dr. Dobb’s journal},
  volume={30},
  number={3},
  pages={202--210},
  year={2005}
}

@inbook{dorado2013,
	author = {García-Dorado, José and Mata, Felipe and Ramos, Javier and Santiago del Río, Pedro and Moreno, Victor and Aracil, Javier},
	year = {2013},
	month = {01},
	pages = {3-27},
	title = {High-Performance Network Traffic Processing Systems Using Commodity Hardware},
	isbn = {9783642367830},
	doi = {10.1007/978-3-642-36784-7_1}
}

@inproceedings{cha1997local,
	author = {Cha, Byungki and Iwama, Kazuo and Kambayashi, Yahiko and Miyazaki, Shuichi},
    title = {Local Search Algorithms for Partial MAXSAT},
    year = {1997},
    isbn = {0262510952},
    publisher = {AAAI Press},
    abstract = {MAXSAT solutions, i.e., near-satisfying assignments for propositional formulas, are sometimes meaningless for real-world problems because such formulas include "mandatory clauses" that must be all satisfied for the solution to be reasonable. In this paper, we introduce Partial MAXSAT and investigate how to solve it using local search algorithms. An instance of Partial MAXSAT consists of two formulas fA and fB, and its solution must satisfy all clauses in fA and as many clauses in fB as possible. The basic idea of our algorithm is to give weight to fA-clauses (the mandatory clauses) and then apply local search. We face two problems; (i) what amount of weight is appropriate and (ii) how to deal with the common action of local search algorithms, giving weight to clauses for their own purpose, which will hide the initial weight as the algorithms proceed.},
    booktitle = {Proceedings of the Fourteenth National Conference on Artificial Intelligence and Ninth Conference on Innovative Applications of Artificial Intelligence},
    pages = {263–268},
    numpages = {6},
    location = {Providence, Rhode Island},
    series = {AAAI'97/IAAI'97}
}

@inproceedings{fu2006solving,
    author="Fu, Zhaohui and Malik, Sharad",
    editor="Biere, Armin and Gomes, Carla P.",
    title={{On Solving the Partial MAX-SAT Problem}},
    booktitle="Theory and Applications of Satisfiability Testing - SAT 2006",
    year="2006",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="252--265",
    abstract="Boolean Satisfiability (SAT) has seen many successful applications in various fields such as Electronic Design Automation and Artificial Intelligence. However, in some cases, it may be required/preferable to use variations of the general SAT problem. In this paper, we consider one important variation, the Partial MAX-SAT problem. Unlike SAT, Partial MAX-SAT has certain constraints (clauses) that are marked as relaxable and the rest are hard, i.e. non-relaxable. The objective is to find a variable assignment that satisfies all non-relaxable clauses together with the maximum number of relaxable ones. We have implemented two solvers for the Partial MAX-SAT problem using a contemporary SAT solver, zChaff. The first approach is a novel diagnosis based algorithm; it iteratively analyzes the UNSAT core of the current SAT instance and eliminates the core through a modification of the problem instance by adding relaxation variables. The second approach is encoding based; it constructs an efficient auxiliary counter that constrains the number of relaxed clauses and supports binary search or linear scan for the optimal solution. Both solvers are complete as they guarantee the optimality of the solution. We discuss the relative strengths and thus applicability of the two solvers for different solution scenarios. Further, we show how both techniques benefit from the persistent learning techniques of incremental SAT. Experiments using practical instances of this problem show significant improvements over the best known solvers.",
    isbn="978-3-540-37207-3"
}

@inproceedings{de2008z3,
    author={Leonardo de Moura and Nikolaj Bj{\o}rner},
    editor={Ramakrishnan, C. R. and Rehof, Jakob},
    title={{Z3: An Efficient SMT Solver}},
    booktitle={{Tools and Algorithms for the Construction and Analysis of Systems}},
    year={2008},
    publisher={Springer Berlin Heidelberg},
    address={Berlin, Heidelberg},
    pages={337--340},
    abstract={Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
    isbn={978-3-540-78800-3}
}

@inproceedings{guo2001war,
    author={Liang Guo and Matta, I.},
    booktitle={Proceedings Ninth International Conference on Network Protocols. ICNP 2001}, 
    title={{The war between mice and elephants}}, 
    year={2001},
    volume={},
    number={},
    pages={180-188},
    doi={10.1109/ICNP.2001.992898}
}

@article{lan2006measurement,
    author = {Lan, Kun-chan and Heidemann, John},
    title = {{A Measurement Study of Correlations of Internet Flow Characteristics}},
    year = {2006},
    issue_date = {16 January 2006},
    publisher = {Elsevier North-Holland, Inc.},
    address = {USA},
    volume = {50},
    number = {1},
    issn = {1389-1286},
    abstract = {Previous studies of Internet traffic have shown that a very small percentage of flows consume most of the network bandwidth. It is important to understand the characteristics of such flows for traffic monitoring and modeling purposes. Several prior researchers have characterized such flows using different classification schemes: by size as elephant and mice; by duration as tortoise and dragonfly; and by burstiness as alpha and beta traffic. However, it is not clear how these different definitions of flows are related to each other. In this work, using data recorded from two different operational networks, we study these ''heavy-hitter'' flows in four different dimensions, namely size, duration, rate and burstiness, and examine how they are correlated. This paper makes three contributions: first, we systematically characterize prior definitions for the properties of such heavy-hitter traffic. Second, based on our datasets, we observe that there are strong correlations between some combinations of size, rate and burstiness. Finally, we provide a plausible explanation for the observed correlations. We show that these correlations could be explained by transport and application-level protocol mechanisms.},
    journal = {Comput. Netw.},
    month = {jan},
    pages = {46–62},
    numpages = {17},
    keywords = {Network measurement, Internet traffic, Heavy-hitter}
}

@inproceedings{pedrosa2018automated,
    author = {Pedrosa, Luis and Iyer, Rishabh and Zaostrovnykh, Arseniy and Fietz, Jonas and Argyraki, Katerina},
    title = {{Automated Synthesis of Adversarial Workloads for Network Functions}},
    year = {2018},
    isbn = {9781450355674},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3230543.3230573},
    doi = {10.1145/3230543.3230573},
    abstract = {Software network functions promise to simplify the deployment of network services and reduce network operation cost. However, they face the challenge of unpredictable performance. Given this performance variability, it is imperative that during deployment, network operators consider the performance of the NF not only for typical but also adversarial workloads. We contribute a tool that helps solve this challenge: it takes as input the LLVM code of a network function and outputs packet sequences that trigger slow execution paths. Under the covers, it combines directed symbolic execution with a sophisticated cache model to look for execution paths that incur many CPU cycles and involve adversarial memory-access patterns. We used our tool on 11 network functions that implement a variety of data structures and discovered workloads that can in some cases triple latency and cut throughput by 19\% relative to typical testing workloads.},
    booktitle = {Proceedings of the 2018 Conference of the ACM Special Interest Group on Data Communication},
    pages = {372–385},
    numpages = {14},
    keywords = {adversarial inputs, network function performance},
    location = {Budapest, Hungary},
    series = {SIGCOMM '18}
}

@inproceedings{barbette2019rss++,
    author = {Barbette, Tom and Katsikas, Georgios P. and Maguire, Gerald Q. and Kosti\'{c}, Dejan},
    title = {{RSS++: Load and State-Aware Receive Side Scaling}},
    year = {2019},
    isbn = {9781450369985},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3359989.3365412},
    doi = {10.1145/3359989.3365412},
    abstract = {While the current literature typically focuses on load-balancing among multiple servers, in this paper, we demonstrate the importance of load-balancing within a single machine (potentially with hundreds of CPU cores). In this context, we propose a new load-balancing technique (RSS++) that dynamically modifies the receive side scaling (RSS) indirection table to spread the load across the CPU cores in a more optimal way. RSS++ incurs up to 14x lower 95th percentile tail latency and orders of magnitude fewer packet drops compared to RSS under high CPU utilization. RSS++ allows higher CPU utilization and dynamic scaling of the number of allocated CPU cores to accommodate the input load while avoiding the typical 25\% over-provisioning.RSS++ has been implemented for both (i) DPDK and (ii) the Linux kernel. Additionally, we implement a new state migration technique which facilitates sharding and reduces contention between CPU cores accessing per-flow data. RSS++ keeps the flow-state by groups that can be migrated at once, leading to a 20\% higher efficiency than a state of the art shared flow table.},
    booktitle = {Proceedings of the 15th International Conference on Emerging Networking Experiments And Technologies},
    pages = {318–333},
    numpages = {16},
    keywords = {intra server, state-aware, load-balancing, NIC indirection table},
    location = {Orlando, Florida},
    series = {CoNEXT '19}
}

@techreport{rfc2544,
  author = {S. Bradner and J. McQuaid},
  title = {{Benchmarking Methodology for Network Interconnect Devices}},
  howpublished = {Internet Requests for Comments},
  type = {RFC},
  number = 2544,
  year = {1999},
  month = {03},
  publisher = {RFC Editor},
  institution = {RFC Editor},
  note = {\url{https://tools.ietf.org/rfc/rfc2544.txt}},
}

@techreport{rfc3022,
  author = {P. Srisuresh and K. Egevang},
  title = {{Traditional IP Network Address Translator (Traditional NAT)}},
  howpublished = {Internet Requests for Comments},
  type = {RFC},
  number = 3022,
  year = {2001},
  month = {01},
  publisher = {RFC Editor},
  institution = {RFC Editor},
  note = {\url{https://www.rfc-editor.org/rfc/rfc3022}}
}

@inproceedings{lee2004standard,
  title={Standard for a precision clock synchronization protocol for networked measurement and control systems},
  author={Lee, Kang B and Eldson, J},
  booktitle={2004 Conference on IEEE 1588, Standard for a Precision Clock Synchronization Protocol for Networked Measurement and Control Systems},
  year={2004}
}

@article{primorac2017measure,
  title={How to measure the killer microsecond},
  author={Primorac, Mia and Bugnion, Edouard and Argyraki, Katerina},
  journal={ACM SIGCOMM Computer Communication Review},
  volume={47},
  number={5},
  pages={61--66},
  year={2017},
  publisher={ACM New York, NY, USA}
}

@inproceedings{dobrescu2012toward,
    author = {Dobrescu, Mihai and Argyraki, Katerina and Ratnasamy, Sylvia},
    title = {{Toward Predictable Performance in Software Packet-Processing Platforms}},
    year = {2012},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {To become a credible alternative to specialized hardware, general-purpose networking needs to offer not only flexibility, but also predictable performance. Recent projects have demonstrated that general-purpose multicore hard-ware is capable of high-performance packet processing, but under a crucial simplifying assumption of uniformity: all processing cores see the same type/amount of traffic and run identical code, while all packets incur the same type of conventional processing (e.g., IP forwarding). Instead, we present a general-purpose packet-processing system that combines ease of programmability with predictable performance, while running a diverse set of applications and serving multiple clients with different needs. Offering predictability in this context is considered a hard problem because software processes contend for shared hardware resources--caches, memory controllers, buses--in unpredictable ways. Still, we show that, in our system, (a) the way in which resource contention affects performance is predictable and (b) the overall performance depends little on how different processes are scheduled on different cores. To the best of our knowledge, our results constitute the first evidence that, when designing software network equipment, flexibility and predictability are not mutually exclusive goals.},
    booktitle = {Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation},
    pages = {11},
    numpages = {1},
    location = {San Jose, CA},
    series = {NSDI'12}
}

@inproceedings{manousis2020contention,
    author = {Manousis, Antonis and Sharma, Rahul Anand and Sekar, Vyas and Sherry, Justine},
    title = {{Contention-Aware Performance Prediction For Virtualized Network Functions}},
    year = {2020},
    isbn = {9781450379557},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3387514.3405868},
    doi = {10.1145/3387514.3405868},
    abstract = {At the core of Network Functions Virtualization lie Network Functions (NFs) that run co-resident on the same server, contend over its hardware resources and, thus, might suffer from reduced performance relative to running alone on the same hardware. Therefore, to efficiently manage resources and meet performance SLAs, NFV orchestrators need mechanisms to predict contention-induced performance degradation. In this work, we find that prior performance prediction frameworks suffer from poor accuracy on modern architectures and NFs because they treat memory as a monolithic whole. In addition, we show that, in practice, there exist multiple components of the memory subsystem that can separately induce contention. By precisely characterizing (1) the pressure each NF applies on the server's shared hardware resources (contentiousness) and (2) how susceptible each NF is to performance drop due to competing contentiousness (sensitivity), we develop SLOMO, a multivariable performance prediction framework for Network Functions. We show that relative to prior work SLOMO reduces prediction error by 2-5x and enables 6-14\% more efficient cluster utilization. SLOMO's codebase can be found at https://github.com/cmu-snap/SLOMO.},
    booktitle = {Proceedings of the Annual Conference of the ACM Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer Communication},
    pages = {270–282},
    numpages = {13},
    keywords = {Packet Processing Software, Network Functions Performance},
    location = {Virtual Event, USA},
    series = {SIGCOMM '20}
}

@inproceedings{mccanne1993bsd,
  title={The BSD Packet Filter: A New Architecture for User-level Packet Capture.},
  author={McCanne, Steven and Jacobson, Van},
  booktitle={USENIX winter},
  volume={46},
  year={1993}
}

@inproceedings{benson2010network,
    author = {Benson, Theophilus and Akella, Aditya and Maltz, David A.},
    title = {Network Traffic Characteristics of Data Centers in the Wild},
    year = {2010},
    isbn = {9781450304832},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/1879141.1879175},
    doi = {10.1145/1879141.1879175},
    abstract = {Although there is tremendous interest in designing improved networks for data centers, very little is known about the network-level traffic characteristics of data centers today. In this paper, we conduct an empirical study of the network traffic in 10 data centers belonging to three different categories, including university, enterprise campus, and cloud data centers. Our definition of cloud data centers includes not only data centers employed by large online service providers offering Internet-facing applications but also data centers used to host data-intensive (MapReduce style) applications). We collect and analyze SNMP statistics, topology and packet-level traces. We examine the range of applications deployed in these data centers and their placement, the flow-level and packet-level transmission properties of these applications, and their impact on network and link utilizations, congestion and packet drops. We describe the implications of the observed traffic patterns for data center internal traffic engineering as well as for recently proposed architectures for data center networks.},
    booktitle = {Proceedings of the 10th ACM SIGCOMM Conference on Internet Measurement},
    pages = {267–280},
    numpages = {14},
    keywords = {data center traffic, characterization},
    location = {Melbourne, Australia},
    series = {IMC '10}
}

@misc{ebpf,
	title = {{Express Data Path}},
    note = {\url{https://en.wikipedia.org/wiki/Express_Data_Path}},
    year = {2023}
}

@misc{ebpf-maps,
    title = {{eBPF maps}},
    note = {\url{https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html}},
    year = {2023}
}

@inproceedings{eisenbud2016maglev,
    author = {Eisenbud, Daniel E. and Yi, Cheng and Contavalli, Carlo and Smith, Cody and Kononov, Roman and Mann-Hielscher, Eric and Cilingiroglu, Ardas and Cheyney, Bin and Shang, Wentao and Hosein, Jinnah Dylan},
    title = {{Maglev: A Fast and Reliable Software Network Load Balancer}},
    year = {2016},
    isbn = {9781931971294},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Maglev is Google's network load balancer. It is a large distributed software system that runs on commodity Linux servers. Unlike traditional hardware network load balancers, it does not require a specialized physical rack deployment, and its capacity can be easily adjusted by adding or removing servers. Network routers distribute packets evenly to the Maglev machines via Equal Cost Multipath (ECMP); each Maglev machine then matches the packets to their corresponding services and spreads them evenly to the service endpoints. To accommodate high and ever-increasing traffic, Maglev is specifically optimized for packet processing performance. A single Maglev machine is able to saturate a 10Gbps link with small packets. Maglev is also equipped with consistent hashing and connection tracking features, to minimize the negative impact of unexpected faults and failures on connection-oriented protocols. Maglev has been serving Google's traffic since 2008. It has sustained the rapid global growth of Google services, and it also provides network load balancing for Google Cloud Platform.},
    booktitle = {Proceedings of the 13th Usenix Conference on Networked Systems Design and Implementation},
    pages = {523–535},
    numpages = {13},
    location = {Santa Clara, CA},
    series = {NSDI'16}
}

@inproceedings{bolt,
    author = {Iyer, Rishabh and Pedrosa, Luis and Zaostrovnykh, Arseniy and Pirelli, Solal and Argyraki, Katerina and Candea, George},
    title = {{Performance Contracts for Software Network Functions}},
    year = {2019},
    isbn = {9781931971492},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Software network functions (NFs), or milddleboxes, promise flexibility and easy deployment of network services, but face the serious challenge of unexpected performance behaviour. We propose the notion of a performance contract, a construct formulated in terms of performance critical variables, that provides a precise description of NF performance. Performance contracts enable fine-grained prediction and scrutiny of NF performance for arbitrary workloads, without having to run the NF itself.We describe BOLT, a technique and tool for computing such performance contracts for the entire software stack of NFs written in C, including the core NF logic, DPDK packet processing framework, and NIC driver. BOLT takes as input the NF implementation code and outputs the corresponding contract. Under the covers, it combines pre-analysis of a library of stateful NF data structures with automated symbolic execution of the NF's code. We evaluate BOLT on four NFs--a Maglev-like load balancer, a NAT, an LPM router, and a MAC bridge--and show that its performance contracts predict the dynamic instruction count and memory access count with a maximum gap of 7\% between the real execution and the conservatively predicted upper bound. With further engineering, this gap can be reduced.},
    booktitle = {Proceedings of the 16th USENIX Conference on Networked Systems Design and Implementation},
    pages = {517–530},
    numpages = {14},
    location = {Boston, MA, USA},
    series = {NSDI'19}
}

@inproceedings{kazemian2012header,
    author = {Kazemian, Peyman and Varghese, George and McKeown, Nick},
    title = {{Header Space Analysis: Static Checking for Networks}},
    year = {2012},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Today's networks typically carry or deploy dozens of protocols and mechanisms simultaneously such as MPLS, NAT, ACLs and route redistribution. Even when individual protocols function correctly, failures can arise from the complex interactions of their aggregate, requiring network administrators to be masters of detail. Our goal is to automatically find an important class of failures, regardless of the protocols running, for both operational and experimental networks.To this end we developed a general and protocol-agnostic framework, called Header Space Analysis (HSA). Our formalism allows us to statically check network specifications and configurations to identify an important class of failures such as Reachability Failures, Forwarding Loops and Traffic Isolation and Leakage problems. In HSA, protocol header fields are not first class entities; instead we look at the entire packet header as a concatenation of bits without any associated meaning. Each packet is a point in the {0,1}L space where L is the maximum length of a packet header, and networking boxes transform packets from one point in the space to another point or set of points (multicast).We created a library of tools, called Hassel, to implement our framework, and used it to analyze a variety of networks and protocols. Hassel was used to analyze the Stanford University backbone network, and found all the forwarding loops in less than 10 minutes, and verified reachability constraints between two subnets in 13 seconds. It also found a large and complex loop in an experimental loose source routing protocol in 4 minutes.},
    booktitle = {Proceedings of the 9th USENIX Conference on Networked Systems Design and Implementation},
    pages = {9},
    numpages = {1},
    location = {San Jose, CA},
    series = {NSDI'12}
}

@inproceedings{khurshid2013veriflow,
    author = {Khurshid, Ahmed and Zhou, Wenxuan and Caesar, Matthew and Godfrey, P. Brighten},
    title = {{Veriflow: Verifying Network-Wide Invariants in Real Time}},
    year = {2012},
    issue_date = {October 2012},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {42},
    number = {4},
    issn = {0146-4833},
    url = {https://doi.org/10.1145/2377677.2377766},
    doi = {10.1145/2377677.2377766},
    abstract = {Networks are complex and prone to bugs. Existing tools that check configuration files and data-plane state operate offline at timescales of seconds to hours, and cannot detect or prevent bugs as they arise.Is it possible to check network-wide invariants in real time, as the network state evolves? The key challenge here is to achieve extremely low latency during the checks so that network performance is not affected. In this paper, we present a preliminary design, VeriFlow, which suggests that this goal is achievable. VeriFlow is a layer between a software-defined networking controller and network devices that checks for network-wide invariant violations dynamically as each forwarding rule is inserted. Based on an implementation using a Mininet OpenFlow network and Route Views trace data, we find that VeriFlow can perform rigorous checking within hundreds of microseconds per rule insertion.},
    journal = {SIGCOMM Comput. Commun. Rev.},
    month = {sep},
    pages = {467–472},
    numpages = {6},
    keywords = {forwarding, openflow, real time, debugging, software-defined networking}
}

@inproceedings{beckett2017general,
    author = {Beckett, Ryan and Gupta, Aarti and Mahajan, Ratul and Walker, David},
    title = {{A General Approach to Network Configuration Verification}},
    year = {2017},
    isbn = {9781450346535},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3098822.3098834},
    doi = {10.1145/3098822.3098834},
    abstract = {We present Minesweeper, a tool to verify that a network satisfies a wide range of intended properties such as reachability or isolation among nodes, waypointing, black holes, bounded path length, load-balancing, functional equivalence of two routers, and fault-tolerance. Minesweeper translates network configuration files into a logical formula that captures the stable states to which the network forwarding will converge as a result of interactions between routing protocols such as OSPF, BGP and static routes. It then combines the formula with constraints that describe the intended property. If the combined formula is satisfiable, there exists a stable state of the network in which the property does not hold. Otherwise, no stable state (if any) violates the property. We used Minesweeper to check four properties of 152 real networks from a large cloud provider. We found 120 violations, some of which are potentially serious security vulnerabilities. We also evaluated Minesweeper on synthetic benchmarks, and found that it can verify rich properties for networks with hundreds of routers in under five minutes. This performance is due to a suite of model-slicing and hoisting optimizations that we developed, which reduce runtime by over 460x for large networks.},
    booktitle = {Proceedings of the Conference of the ACM Special Interest Group on Data Communication},
    pages = {155–168},
    numpages = {14},
    keywords = {Control plane analysis, Network verification},
    location = {Los Angeles, CA, USA},
    series = {SIGCOMM '17}
}

@inproceedings{chen2018towards,
    author = {Chen, Haoxian and Wang, Anduo and Loo, Boon Thau},
    title = {Towards Example-Guided Network Synthesis},
    year = {2018},
    isbn = {9781450363952},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3232565.3234462},
    doi = {10.1145/3232565.3234462},
    abstract = {In recent years, there has been a proliferation in network domain-specific languages (DSL). These languages enable us to exploit the programmability of these networks, while still providing correctness guarantees through verification and analysis of DSLs. However, none of these DSLs have received widespread adoption. First these new languages require a learning curve among operators who may not be trained programmers. Second, these new SDN applications sometimes rely on functionality in legacy networks that cannot be easily migrated or analyzed.To address these challenges, we propose Facon, a new tool that enables us to automatically generate programs in arbitrary DSLs, based on input/output examples. Since input/output examples applies to any network protocols, this approach can be generalized, hence enabling us to migrate legacy networks to new DSLs, or to transform one DSL to another. As an initial feasibility study, we apply Facon to a family of logic-based network DSLs based on declarative networking. Facon takes as examples input/output examples either provided by an operator or observed from a legacy system. Facon then automatically generates a declarative networking program faithful to these examples. We propose an efficient search algorithm that exploits syntactic constraints in declarative networking to prune the search space, and semantics as heuristics to guide the search direction. Our initial results are promising. Facon successfully synthesizes declarative networking programs at a scale beyond previous logic program synthesis tools can handle.},
    booktitle = {Proceedings of the 2nd Asia-Pacific Workshop on Networking},
    pages = {65–71},
    numpages = {7},
    keywords = {Inductive Logic Programming, Network Programming, Program Synthesis},
    location = {Beijing, China},
    series = {APNet '18}
}

@inproceedings{gao2020switch,
    author = {Gao, Xiangyu and Kim, Taegyun and Wong, Michael D. and Raghunathan, Divya and Varma, Aatish Kishan and Kannan, Pravein Govindan and Sivaraman, Anirudh and Narayana, Srinivas and Gupta, Aarti},
    title = {{Switch Code Generation Using Program Synthesis}},
    year = {2020},
    isbn = {9781450379557},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3387514.3405852},
    doi = {10.1145/3387514.3405852},
    abstract = {Writing packet-processing programs for programmable switch pipelines is challenging because of their all-or-nothing nature: a program either runs at line rate if it can fit within pipeline resources, or does not run at all. It is the compiler's responsibility to fit programs into pipeline resources. However, switch compilers, which use rewrite rules to generate switch machine code, often reject programs because the rules fail to transform programs into a form that can be mapped to a pipeline's limited resources---even if a mapping actually exists.This paper presents a compiler, Chipmunk, which formulates code generation as a program synthesis problem. Chipmunk uses a program synthesis engine, SKETCH, to transform high-level programs down to switch machine code. However, naively formulating code generation as program synthesis can lead to long compile times. Hence, we develop a new domain-specific synthesis technique, slicing, which reduces compile times by 1-387x and 51x on average.Using a switch hardware simulator, we show that Chipmunk compiles many programs that a previous rule-based compiler, Domino, rejects. Chipmunk also produces machine code with fewer pipeline stages than Domino. A Chipmunk backend for the Tofino programmable switch shows that program synthesis can produce machine code for high-speed switches.},
    booktitle = {Proceedings of the Annual Conference of the ACM Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer Communication},
    pages = {44–61},
    numpages = {18},
    keywords = {packet processing pipelines, code generation, Programmable switches, slicing, program synthesis},
    location = {Virtual Event, USA},
    series = {SIGCOMM '20}
}

@inproceedings{zhang2020gallium,
    author = {Zhang, Kaiyuan and Zhuo, Danyang and Krishnamurthy, Arvind},
    title = {{Gallium: Automated Software Middlebox Offloading to Programmable Switches}},
    year = {2020},
    isbn = {9781450379557},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3387514.3405869},
    doi = {10.1145/3387514.3405869},
    abstract = {Researchers have shown that offloading software middleboxes (e.g., NAT, firewall, load balancer) to programmable switches can yield orders-of-magnitude performance gains. However, it requires manually selecting the middle-box components to offload and rewriting the offloaded code in P4, a domain-specific language for programmable switches. We design and implement Gallium, a compiler that transforms an input software middlebox into two parts---a P4 program that runs on a programmable switch and an x86 non-offloaded program that runs on a regular middlebox server. Gallium ensures that (1) the combined effect of the P4 program and the non-offloaded program is functionally equivalent to the input middlebox program, (2) the P4 program respects the resource constraints in the programmable switch, and (3) the run-to-completion semantics are met under concurrent execution. Our evaluations show that Gallium saves 21-79\% of processing cycles and reduces latency by about 31\% across various software middleboxes.},
    booktitle = {Proceedings of the Annual Conference of the ACM Special Interest Group on Data Communication on the Applications, Technologies, Architectures, and Protocols for Computer Communication},
    pages = {283–295},
    numpages = {13},
    keywords = {Middleboxes, Protocol offload},
    location = {Virtual Event, USA},
    series = {SIGCOMM '20}
}

@inproceedings{vanbever2020,
    author = {Rudiger Birkner and Dana Drachsler-Cohen and Laurent Vanbever and Martin Vechev},
    title = {{Config2Spec}: Mining Network Specifications from Network Configurations },
    booktitle = {17th USENIX Symposium on Networked Systems Design and Implementation (NSDI 20)},
    year = {2020},
    isbn = {978-1-939133-13-7},
    address = {Santa Clara, CA},
    pages = {969--984},
    url = {https://www.usenix.org/conference/nsdi20/presentation/birkner},
    publisher = {USENIX Association},
    month = feb
}

@inproceedings{vanbever2021,
    author = {Schneider, Tibor and Birkner, R\"{u}diger and Vanbever, Laurent},
    title = {{Snowcap: Synthesizing Network-Wide Configuration Updates}},
    year = {2021},
    isbn = {9781450383837},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3452296.3472915},
    doi = {10.1145/3452296.3472915},
    abstract = {Large-scale reconfiguration campaigns tend to be nerve-racking for network operators as they can lead to significant network downtimes, decreased performance, and policy violations. Unfortunately, existing reconfiguration frameworks often fall short in practice as they either only support a small set of reconfiguration scenarios or simply do not scale.We address these problems with Snowcap, the first network reconfiguration framework which can synthesize configuration updates that comply with arbitrary hard and soft specifications, and involve arbitrary routing protocols. Our key contribution is an efficient search procedure which leverages counter-examples to efficiently navigate the space of configuration updates. Given a reconfiguration ordering which violates the desired specifications, our algorithm automatically identifies the problematic commands so that it can avoid this particular order in the next iteration.We fully implemented Snowcap and extensively evaluated its scalability and effectiveness on real-world topologies and typical, large-scale reconfiguration scenarios. Even for large topologies, Snowcap finds a valid reconfiguration ordering with minimal side-effects (i.e., traffic shifts) within a few seconds at most.},
    booktitle = {Proceedings of the 2021 ACM SIGCOMM 2021 Conference},
    pages = {33–49},
    numpages = {17},
    keywords = {network analysis, configuration, migration},
    location = {Virtual Event, USA},
    series = {SIGCOMM '21}
}

@inproceedings {khalid2016paving,
    author = {Khalid, Junaid and Gember-Jacobson, Aaron and Michael, Roney and Abhashkumar, Anubhavnidhi and Akella, Aditya},
    title = {{Paving the Way for NFV: Simplifying Middlebox Modifications Using StateAlyzr}},
    year = {2016},
    isbn = {9781931971294},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Important Network Functions Virtualization (NFV) scenarios such as ensuring middlebox fault tolerance or elasticity require redistribution of internal middlebox state. While many useful frameworks exist today for migrating/ cloning internal state, they require modifications to middlebox code to identify needed state. is process is tedious and manual, hindering the adoption of such frameworks. We present a framework-independent system, StateAlyzr, that embodies novel algorithms adapted from program analysis to provably and automatically identify all state that must be migrated/cloned to ensure consistent middlebox output in the face of redistribution. We find that StateAlyzr reducesman-hours required for code modification by nearly 20\texttimes{}. We apply State-Alyzr to four open source middleboxes and find its algorithms to be highly precise. We find that a large amount of, but not all, live state matters toward packet processing in these middleboxes. StateAlyzr's algorithms can reduce the amount of state that needs redistribution by 600- 8000\texttimes{} compared to naive schemes.},
    booktitle = {Proceedings of the 13th Usenix Conference on Networked Systems Design and Implementation},
    pages = {239–253},
    numpages = {15},
    location = {Santa Clara, CA},
    series = {NSDI'16}
}

@article{larus2007transactional,
  title={Transactional memory},
  author={Larus, James R and Rajwar, Ravi},
  journal={Synthesis Lectures on Computer Architecture},
  volume={1},
  number={1},
  pages={1--226},
  year={2007},
  publisher={Morgan \& Claypool Publishers}
}

@inproceedings{farshin2021packetmill,
    author = {Farshin, Alireza and Barbette, Tom and Roozbeh, Amir and Maguire Jr., Gerald Q. and Kosti\'{c}, Dejan},
    title = {{PacketMill: Toward per-Core 100-Gbps Networking}},
    year = {2021},
    isbn = {9781450383172},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3445814.3446724},
    doi = {10.1145/3445814.3446724},
    abstract = {We present PacketMill, a system for optimizing software packet processing, which (i) introduces a new model to efficiently manage packet metadata and (ii) employs code-optimization techniques to better utilize commodity hardware. PacketMill grinds the whole packet processing stack, from the high-level network function configuration file to the low-level userspace network (specifically DPDK) drivers, to mitigate inefficiencies and produce a customized binary for a given network function. Our evaluation results show that PacketMill increases throughput (up to 36.4 Gbps -- 70\%) \& reduces latency (up to 101 us -- 28\%) and enables nontrivial packet processing (e.g., router) at ~100 Gbps, when new packets arrive >10\texttimes{} faster than main memory access times, while using only one processing core.},
    booktitle = {Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems},
    pages = {1–17},
    numpages = {17},
    keywords = {Middleboxes, Metadata Management, LLVM, Full-Stack Optimization, FastClick, DPDK, Compiler Optimizations, X-Change, Commodity Hardware, PacketMill, Packet Processing, 100-Gbps Networking},
    location = {Virtual, USA},
    series = {ASPLOS '21}
}

@inproceedings{neugebauer2018understanding,
    author = {Neugebauer, Rolf and Antichi, Gianni and Zazo, Jos\'{e} Fernando and Audzevich, Yury and L\'{o}pez-Buedo, Sergio and Moore, Andrew W.},
    title = {{Understanding PCIe Performance for End Host Networking}},
    year = {2018},
    isbn = {9781450355674},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3230543.3230560},
    doi = {10.1145/3230543.3230560},
    abstract = {In recent years, spurred on by the development and availability of programmable NICs, end hosts have increasingly become the enforcement point for core network functions such as load balancing, congestion control, and application specific network offloads. However, implementing custom designs on programmable NICs is not easy: many potential bottlenecks can impact performance.This paper focuses on the performance implication of PCIe, the de-facto I/O interconnect in contemporary servers, when interacting with the host architecture and device drivers. We present a theoretical model for PCIe and pcie-bench, an open-source suite, that allows developers to gain an accurate and deep understanding of the PCIe substrate. Using pcie-bench, we characterize the PCIe subsystem in modern servers. We highlight surprising differences in PCIe implementations, evaluate the undesirable impact of PCIe features such as IOMMUs, and show the practical limits for common network cards operating at 40Gb/s and beyond. Furthermore, through pcie-bench we gained insights which guided software and future hardware architectures for both commercial and research oriented network cards and DMA engines.},
    booktitle = {Proceedings of the 2018 Conference of the ACM Special Interest Group on Data Communication},
    pages = {327–341},
    numpages = {15},
    keywords = {operating system, reconfigurable hardware, PCIe},
    location = {Budapest, Hungary},
    series = {SIGCOMM '18}
}

@article{barach2018high,
  author={Barach, David and Linguaglossa, Leonardo and Marion, Damjan and Pfister, Pierre and Pontarelli, Salvatore and Rossi, Dario},
  journal={IEEE Communications Magazine}, 
  title={{High-Speed Software Data Plane via Vectorized Packet Processing}}, 
  year={2018},
  volume={56},
  number={12},
  pages={97-103},
  doi={10.1109/MCOM.2018.1800069}
}

@article{bosshart2014p4,
  title={P4: Programming protocol-independent packet processors},
  author={Bosshart, Pat and Daly, Dan and Gibb, Glen and Izzard, Martin and McKeown, Nick and Rexford, Jennifer and Schlesinger, Cole and Talayco, Dan and Vahdat, Amin and Varghese, George and others},
  journal={ACM SIGCOMM Computer Communication Review},
  volume={44},
  number={3},
  pages={87--95},
  year={2014},
  publisher={ACM New York, NY, USA}
}

@misc{tofinoswitch,
	author = {Intel},
	title = {{Intel Tofino}},
	note = {Retrieved 2023-04-25},
	url = {https://www.intel.com/content/www/us/en/products/network-io/programmable-ethernet-switch/tofino-series.html},
}

@inproceedings {pix,
    author = {Rishabh Iyer and Katerina Argyraki and George Candea},
    title = {{Performance Interfaces for Network Functions}},
    booktitle = {19th USENIX Symposium on Networked Systems Design and Implementation (NSDI 22)},
    year = {2022},
    isbn = {978-1-939133-27-4},
    address = {Renton, WA},
    pages = {567--584},
    url = {https://www.usenix.org/conference/nsdi22/presentation/iyer},
    publisher = {USENIX Association},
    month = apr
}

@manual{e810,
	organization  = "Intel",
	title         = "Intel® Ethernet Controller E810 Datasheet",
	year          =  2022,
	month         =  10,
	note          = "Version 2.4. \url{https://www.intel.com/content/www/us/en/content-details/613875/intel-ethernet-controller-e810-datasheet.html}",
}

@manual{x710,
	organization  = "Intel",
	title         = "Intel® Ethernet Controller X710/{\allowbreak}XXV710/{\allowbreak}XL710 Datasheet",
	year          =  2022,
	month         =  6,
	note          = "Version 4.1. \url{https://www.intel.com/content/www/us/en/content-details/332464/intel-ethernet-controller-x710-xxv710-xl710-datasheet.html}",
}

@misc{connectx5,
	author = {NVIDIA},
	title = {{Mellanox ConnectX-5 Ethernet Adapter Card}},
    year = 2020,
	note = {\url{{https://network.nvidia.com/files/doc-2020/pb-connectx-5-en-card.pdf}}},
}


@inproceedings{li2016just,
  title={Just say $\{$NO$\}$ to paxos overhead: Replacing consensus with network ordering},
  author={Li, Jialin and Michael, Ellis and Sharma, Naveen Kr and Szekeres, Adriana and Ports, Dan RK},
  booktitle={12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)},
  pages={467--483},
  year={2016}
}

@inproceedings{silkroad,
  title={Silkroad: Making stateful layer-4 load balancing fast and cheap using switching asics},
  author={Miao, Rui and Zeng, Hongyi and Kim, Changhoon and Lee, Jeongkeun and Yu, Minlan},
  booktitle={Proceedings of the Conference of the ACM Special Interest Group on Data Communication},
  pages={15--28},
  year={2017}
}

@inproceedings{opensketch,
  title={Software $\{$Defined$\}$$\{$Traffic$\}$ Measurement with $\{$OpenSketch$\}$},
  author={Yu, Minlan and Jose, Lavanya and Miao, Rui},
  booktitle={10th USENIX Symposium on Networked Systems Design and Implementation (NSDI 13)},
  pages={29--42},
  year={2013}
}

@inproceedings{netcache,
  title={Netcache: Balancing key-value stores with fast in-network caching},
  author={Jin, Xin and Li, Xiaozhou and Zhang, Haoyu and Soul{\'e}, Robert and Lee, Jeongkeun and Foster, Nate and Kim, Changhoon and Stoica, Ion},
  booktitle={Proceedings of the 26th Symposium on Operating Systems Principles},
  pages={121--136},
  year={2017}
}

@inproceedings{netchain,
  title={$\{$NetChain$\}$:$\{$Scale-Free$\}$$\{$Sub-RTT$\}$ Coordination},
  author={Jin, Xin and Li, Xiaozhou and Zhang, Haoyu and Foster, Nate and Lee, Jeongkeun and Soul{\'e}, Robert and Kim, Changhoon and Stoica, Ion},
  booktitle={15th USENIX Symposium on Networked Systems Design and Implementation (NSDI 18)},
  pages={35--49},
  year={2018}
}

@inproceedings{tai2008,
  title={Making large scale deployment of RCP practical for real networks},
  author={Tai, C-H and Zhu, Jiang and Dukkipati, Nandita},
  booktitle={IEEE INFOCOM 2008-The 27th Conference on Computer Communications},
  pages={2180--2188},
  year={2008},
  organization={IEEE}
}

@inproceedings{sinha2004,
  title={Harnessing TCP’s burstiness with flowlet switching},
  author={Sinha, Shan and Kandula, Srikanth and Katabi, Dina},
  booktitle={Proc. 3rd ACM Workshop on Hot Topics in Networks (Hotnets-III)},
  year={2004},
  organization={Citeseer}
}

@article{nichols2012,
  title={Controlling Queue Delay: A modern AQM is just one piece of the solution to bufferbloat.},
  author={Nichols, Kathleen and Jacobson, Van},
  journal={Queue},
  volume={10},
  number={5},
  pages={20--34},
  year={2012},
  publisher={ACM New York, NY, USA}
}

@article{kunniyur2004,
  title={An adaptive virtual queue (AVQ) algorithm for active queue management},
  author={Kunniyur, Srisankar S and Srikant, Rayadurgam},
  journal={IEEE/ACM Transactions on networking},
  volume={12},
  number={2},
  pages={286--299},
  year={2004},
  publisher={IEEE}
}

@inproceedings{exposure,
  title={Exposure: Finding malicious domains using passive DNS analysis.},
  author={Bilge, Leyla and Kirda, Engin and Kruegel, Christopher and Balduzzi, Marco},
  booktitle={Ndss},
  pages={1--17},
  year={2011}
}

@inproceedings{alizadeh2012,
  title={Less Is More: Trading a Little Bandwidth for $\{$Ultra-Low$\}$ Latency in the Data Center},
  author={Alizadeh, Mohammad and Kabbani, Abdul and Edsall, Tom and Prabhakar, Balaji and Vahdat, Amin and Yasuda, Masato},
  booktitle={9th USENIX Symposium on Networked Systems Design and Implementation (NSDI 12)},
  pages={253--266},
  year={2012}
}

@inproceedings{conga,
  title={CONGA: Distributed congestion-aware load balancing for datacenters},
  author={Alizadeh, Mohammad and Edsall, Tom and Dharmapurikar, Sarang and Vaidyanathan, Ramanan and Chu, Kevin and Fingerhut, Andy and Lam, Vinh The and Matus, Francis and Pan, Rong and Yadav, Navindra and others},
  booktitle={Proceedings of the 2014 ACM conference on SIGCOMM},
  pages={503--514},
  year={2014}
}

@misc{natasha,
	author = {{Scaleway}},
	url = {https://github.com/scaleway/natasha},
	title = {{Natasha}},
	note = {Retrieved 2023-04-25}
}

@inproceedings{mp5,
    author = {Shrivastav, Vishal},
    title = {{Stateful Multi-Pipelined Programmable Switches}},
    year = {2022},
    isbn = {9781450394208},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3544216.3544269},
    doi = {10.1145/3544216.3544269},
    abstract = {Given the clock rate of a single packet processing pipeline has saturated due to slowdown in transistor scaling, today's programmable switches employ multiple parallel pipelines to meet high packet processing rates. However, parallel processing poses a challenge for stateful packet processing, where it becomes hard to guarantee functional correctness while maintaining line rate processing. This paper presents the design and implementation of MP5, which is a new switch architecture, compiler, and runtime for multi-pipelined programmable switches that is functionally equivalent to a logical single pipelined switch while also processing packets close to the ideal processing rate, for all packet processing programs.},
    booktitle = {Proceedings of the ACM SIGCOMM 2022 Conference},
    pages = {663–676},
    numpages = {14},
    keywords = {switch architecture, programmable networks},
    location = {Amsterdam, Netherlands},
    series = {SIGCOMM '22}
}

@inproceedings{agarwal2022understanding,
    author = {Agarwal, Saksham and Agarwal, Rachit and Montazeri, Behnam and Moshref, Masoud and Elmeleegy, Khaled and Rizzo, Luigi and de Kruijf, Marc Asher and Kumar, Gautam and Ratnasamy, Sylvia and Culler, David and Vahdat, Amin},
    title = {Understanding Host Interconnect Congestion},
    year = {2022},
    isbn = {9781450398992},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3563766.3564110},
    doi = {10.1145/3563766.3564110},
    abstract = {We present evidence and characterization of host congestion in production clusters: adoption of high-bandwidth access links leading to emergence of bottlenecks within the host interconnect (NIC-to-CPU data path). We demonstrate that contention on existing IO memory management units and/or the memory subsystem can significantly reduce the available NIC-to-CPU bandwidth, resulting in hundreds of microseconds of queueing delays and eventual packet drops at hosts (even when running a state-of-the-art congestion control protocol that accounts for CPU-induced host congestion). We also discuss implications of host interconnect congestion to design of future host architecture, network stacks and network protocols.},
    booktitle = {Proceedings of the 21st ACM Workshop on Hot Topics in Networks},
    pages = {198–204},
    numpages = {7},
    keywords = {congestion control, network hardware, datacenter transport},
    location = {Austin, Texas},
    series = {HotNets '22}
}

@article{tsx,
  title={{Intel 64 and IA-32 architectures software developer’s
manual}},
  author={Intel},
  year={2022}
}

@inproceedings{synapse,
    author = {Pereira, Francisco and Matos, Gon\c{c}alo and Sadok, Hugo and Kim, Daehyeok and Martins, Ruben and Sherry, Justine and Ramos, Fernando M. V. and Pedrosa, Luis},
    title = {{Automatic Generation of Network Function Accelerators Using Component-Based Synthesis}},
    year = {2022},
    isbn = {9781450398923},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3563647.3563656},
    doi = {10.1145/3563647.3563656},
    abstract = {Designing networked systems that take best advantage of heterogeneous dataplanes - e.g., dividing packet processing across both a PISA switch and an x86 CPU - can improve performance, efficiency, and resource consumption. However, programming for multiple hardware targets remains challenging because developers must learn platform-specific languages and skills. While some 'write-once, run-anywhere' compilers exist, they are unable to consider a range of implementation options to tune the NF to meet performance objectives. In this short paper, we explore preliminary ideas towards a compiler that explores a large search space of different mappings of functionality to hardware. This exploration can be tuned for a programmer-specified objective, such as minimizing memory consumption or maximizing network throughput. Our initial prototype, SyNAPSE, is based on a methodology called component-based synthesis and supports deployments across x86 and Tofino platforms. Relative to a baseline compiler which only generates one deployment decision, SyNAPSE uncovers thousands of deployment options - including a deployment which reduces the amount of controller traffic by an order of magnitude, and another deployment which halves memory usage.},
    booktitle = {Proceedings of the Symposium on SDN Research},
    pages = {89–97},
    numpages = {9},
    keywords = {programming abstraction, in-network compute, network function virtualization},
    location = {Virtual Event},
    series = {SOSR '22}
}

@inproceedings{fogel2015batfish,
    author = {Fogel, Ari and Fung, Stanley and Pedrosa, Luis and Walraed-Sullivan, Meg and Govindan, Ramesh and Mahajan, Ratul and Millstein, Todd},
    title = {{A General Approach to Network Configuration Analysis}},
    year = {2015},
    isbn = {9781931971218},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {We present an approach to detect network configuration errors, which combines the benefits of two prior approaches. Like prior techniques that analyze configuration files, our approach can find errors proactively, before the configuration is applied, and answer "what if" questions. Like prior techniques that analyze data-plane snapshots, our approach can check a broad range of forwarding properties and produce actual packets that violate checked properties. We accomplish this combination by faithfully deriving and then analyzing the data plane that would emerge from the configuration. Our derivation of the data plane is fully declarative, employing a set of logical relations that represent the control plane, the data plane, and their relationship. Operators can query these relations to understand identified errors and their provenance. We use our approach to analyze two large university networks with qualitatively different routing designs and find many misconfigurations in each. Operators have confirmed the majority of these as errors and have fixed their configurations accordingly.},
    booktitle = {Proceedings of the 12th USENIX Conference on Networked Systems Design and Implementation},
    pages = {469–483},
    numpages = {15},
    location = {Oakland, CA},
    series = {NSDI'15}
}

@misc{katran,
    title={{Open-sourcing Katran, a scalable network load balancer}},
    author={Shirokov, Nikita and Dasineni, Ranjeeth},
    year={2018},
    note = {\url{{https://engineering.fb.com/2018/05/22/open-source/open-sourcing-katran-a-scalable-network-load-balancer/}}}
}

@inproceedings{xdp,
    author = {H\o{}iland-J\o{}rgensen, Toke and Brouer, Jesper Dangaard and Borkmann, Daniel and Fastabend, John and Herbert, Tom and Ahern, David and Miller, David},
    title = {{The EXpress Data Path: Fast Programmable Packet Processing in the Operating System Kernel}},
    year = {2018},
    isbn = {9781450360807},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3281411.3281443},
    doi = {10.1145/3281411.3281443},
    abstract = {Programmable packet processing is increasingly implemented using kernel bypass techniques, where a userspace application takes complete control of the networking hardware to avoid expensive context switches between kernel and userspace. However, as the operating system is bypassed, so are its application isolation and security mechanisms; and well-tested configuration, deployment and management tools cease to function.To overcome this limitation, we present the design of a novel approach to programmable packet processing, called the eXpress Data Path (XDP). In XDP, the operating system kernel itself provides a safe execution environment for custom packet processing applications, executed in device driver context. XDP is part of the mainline Linux kernel and provides a fully integrated solution working in concert with the kernel's networking stack. Applications are written in higher level languages such as C and compiled into custom byte code which the kernel statically analyses for safety, and translates into native instructions.We show that XDP achieves single-core packet processing performance as high as 24 million packets per second, and illustrate the flexibility of the programming model through three example use cases: layer-3 routing, inline DDoS protection and layer-4 load balancing.},
    booktitle = {Proceedings of the 14th International Conference on Emerging Networking EXperiments and Technologies},
    pages = {54–66},
    numpages = {13},
    keywords = {XDP, BPF, DPDK, programmable networking},
    location = {Heraklion, Greece},
    series = {CoNEXT '18}
}

@misc{cilium,
    title = {Cilium Project},
    note = {\url{https://cilium.io/}},
    year = {2023}
}

@inproceedings{crab,
    author = {Kogias, Marios and Iyer, Rishabh and Bugnion, Edouard},
    title = {{Bypassing the Load Balancer without Regrets}},
    year = {2020},
    isbn = {9781450381376},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3419111.3421304},
    doi = {10.1145/3419111.3421304},
    abstract = {Load balancers are a ubiquitous component of cloud deployments and the cornerstone of workload elasticity. Load balancers can significantly affect the end-to-end application latency with their load balancing decisions, and constitute a significant portion of cloud tenant expenses.We propose CRAB, an alternative L4 load balancing scheme that eliminates latency overheads and scalability bottlenecks while simultaneously enabling the deployment of complex, stateful load balancing policies. A CRAB load balancer only participates in the TCP connection establishment phase and stays off the connection's datapath. Thus, load balancer provisioning depends on the rate of new connections rather than the actual connection bandwidth. CRAB depends on a new TCP option that enables connection redirection. We provide different implementations for a CRAB load balancer on different technologies, e.g., P4, DPDK, and eBPF, showing that a CRAB load balancer does not require many resources to perform well. We introduce the connection redirection option to the Linux kernel with minor modifications, so that it that can be shipped with the VM images offered by the cloud providers. We show how the same functionality can be achieved with a vanilla Linux kernel using a Netfilter module, while we discuss how CRAB can work while clients and servers remain completely agnostic, based on functionality added on the host.Our evaluation shows that CRAB pushes the IO bottleneck from the load balancer to the servers in cases where vanilla L4 load balancing does not scale and provides end-to-end latencies that are close to direct communication while retaining all the scheduling benefits of stateful L4 load balancing.},
    booktitle = {Proceedings of the 11th ACM Symposium on Cloud Computing},
    pages = {193–207},
    numpages = {15},
    location = {Virtual Event, USA},
    series = {SoCC '20}
}

@inproceedings{hxdp,
    author = {Marco Spaziani Brunella and Giacomo Belocchi and Marco Bonola and Salvatore Pontarelli and Giuseppe Siracusano and Giuseppe Bianchi and Aniello Cammarano and Alessandro Palumbo and Luca Petrucci and Roberto Bifulco},
    title = {{hXDP}: Efficient Software Packet Processing on {FPGA} {NICs}},
    booktitle = {14th USENIX Symposium on Operating Systems Design and Implementation (OSDI 20)},
    year = {2020},
    isbn = {978-1-939133-19-9},
    pages = {973--990},
    url = {https://www.usenix.org/conference/osdi20/presentation/brunella},
    publisher = {USENIX Association},
    month = nov
}

@inproceedings{xdp-netdev,
  title={{XDP in practice: integrating XDP into our DDoS mitigation pipeline}},
  author={Bertin, Gilberto},
  booktitle={Technical Conference on Linux Networking, Netdev},
  volume={2},
  pages={1--5},
  year={2017},
  organization={The NetDev Society}
}

@article{hda,
  title={{ACM SIGCOMM 2018 Morning Tutorial on Host Dataplane Acceleration (HDA)}},
  author={Beckett, David and Joubert, Jaco and Horman, Simon},
  journal={New York, NY, USA},
  note={\url{https://conferences.sigcomm.org/sigcomm/2018/tutorial-hda.html}},
  year={2018}
}

@inproceedings{opennf,
    author = {Gember-Jacobson, Aaron and Viswanathan, Raajay and Prakash, Chaithan and Grandl, Robert and Khalid, Junaid and Das, Sourav and Akella, Aditya},
    title = {{OpenNF: Enabling Innovation in Network Function Control}},
    year = {2014},
    isbn = {9781450328364},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2619239.2626313},
    doi = {10.1145/2619239.2626313},
    abstract = {Network functions virtualization (NFV) together with software-defined networking (SDN) has the potential to help operators satisfy tight service level agreements, accurately monitor and manipulate network traffic, and minimize operating expenses. However, in scenarios that require packet processing to be redistributed across a collection of network function (NF) instances, simultaneously achieving all three goals requires a framework that provides efficient, coordinated control of both internal NF state and network forwarding state. To this end, we design a control plane called OpenNF. We use carefully designed APIs and a clever combination of events and forwarding updates to address race conditions, bound overhead, and accommodate a variety of NFs. Our evaluation shows that OpenNF offers efficient state control without compromising flexibility, and requires modest additions to NFs.},
    booktitle = {Proceedings of the 2014 ACM Conference on SIGCOMM},
    pages = {163–174},
    numpages = {12},
    keywords = {software-defined networking, network functions, middleboxes},
    location = {Chicago, Illinois, USA},
    series = {SIGCOMM '14}
}

@inproceedings{split-merge,
    author = {Rajagopalan, Shriram and Williams, Dan and Jamjoom, Hani and Warfield, Andrew},
    title = {{Split/Merge: System Support for Elastic Execution in Virtual Middleboxes}},
    year = {2013},
    publisher = {USENIX Association},
    address = {USA},
    abstract = {Developing elastic applications should be easy. This paper takes a step toward the goal of generalizing elasticity by observing that a broadly deployed class of software-- the network middlebox--is particularly well suited to dynamic scale. Middleboxes tend to achieve a clean separation between a small amount of per-flow network state and a large amount of complex application logic. We present a state-centric, systems-level abstraction for elastic middleboxes called Split/Merge. A virtual middlebox that has appropriately classified its state (e.g., perflow state) can be dynamically scaled out (or in) by a Split/Merge system, but remains ignorant of the number of replicas in the system. Per-flow state may be transparently split between many replicas or merged back into one, while the network ensures flows are routed to the correct replica. As a result, Split/Merge enables load-balanced elasticity. We have implemented a Split/Merge system, called FreeFlow, and ported Bro, an open-source intrusion detection system, to run on it. In controlled experiments, FreeFlow enables a 25\% reduction in maximum latency while eliminating hotspots during scale-out and a 50\% quicker scale-in than standard approaches.},
    booktitle = {Proceedings of the 10th USENIX Conference on Networked Systems Design and Implementation},
    pages = {227–240},
    numpages = {14},
    location = {Lombard, IL},
    series = {NSDI'13}
}

@inproceedings{ftmb,
author = {Sherry, Justine and Gao, Peter Xiang and Basu, Soumya and Panda, Aurojit and Krishnamurthy, Arvind and Maciocco, Christian and Manesh, Maziar and Martins, Jo\~{a}o and Ratnasamy, Sylvia and Rizzo, Luigi and Shenker, Scott},
title = {Rollback-Recovery for Middleboxes},
year = {2015},
issue_date = {October 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {4},
issn = {0146-4833},
url = {https://doi.org/10.1145/2829988.2787501},
doi = {10.1145/2829988.2787501},
abstract = {Network middleboxes must offer high availability, with automatic failover when a device fails. Achieving high availability is challenging because failover must correctly restore lost state (e.g., activity logs, port mappings) but must do so quickly (e.g., in less than typical transport timeout values to minimize disruption to applications) and with little overhead to failure-free operation (e.g., additional per-packet latencies of 10-100s of us). No existing middlebox design provides failover that is correct, fast to recover, and imposes little increased latency on failure-free operations. We present a new design for fault-tolerance in middleboxes that achieves these three goals. Our system, FTMB (for Fault-Tolerant MiddleBox), adopts the classical approach of "rollback recovery" in which a system uses information logged during normal operation to correctly reconstruct state after a failure. However, traditional rollback recovery cannot maintain high throughput given the frequent output rate of middleboxes. Hence, we design a novel solution to record middlebox state which relies on two mechanisms: (1) 'ordered logging', which provides lightweight logging of the information needed after recovery, and (2) a `parallel release' algorithm which, when coupled with ordered logging, ensures that recovery is always correct. We implement ordered logging and parallel release in Click and show that for our test applications our design adds only 30$mu$s of latency to median per packet latencies. Our system introduces moderate throughput overheads (5-30\%) and can reconstruct lost state in 40-275ms for practical systems.},
journal = {SIGCOMM Comput. Commun. Rev.},
month = {aug},
pages = {227–240},
numpages = {14},
keywords = {middlebox reliability, parallel fault-tolerance}
}

@inproceedings{10.1145/2785956.2787501,
    author = {Sherry, Justine and Gao, Peter Xiang and Basu, Soumya and Panda, Aurojit and Krishnamurthy, Arvind and Maciocco, Christian and Manesh, Maziar and Martins, Jo\~{a}o and Ratnasamy, Sylvia and Rizzo, Luigi and Shenker, Scott},
    title = {{Rollback-Recovery for Middleboxes}},
    year = {2015},
    isbn = {9781450335423},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2785956.2787501},
    doi = {10.1145/2785956.2787501},
    abstract = {Network middleboxes must offer high availability, with automatic failover when a device fails. Achieving high availability is challenging because failover must correctly restore lost state (e.g., activity logs, port mappings) but must do so quickly (e.g., in less than typical transport timeout values to minimize disruption to applications) and with little overhead to failure-free operation (e.g., additional per-packet latencies of 10-100s of us). No existing middlebox design provides failover that is correct, fast to recover, and imposes little increased latency on failure-free operations. We present a new design for fault-tolerance in middleboxes that achieves these three goals. Our system, FTMB (for Fault-Tolerant MiddleBox), adopts the classical approach of "rollback recovery" in which a system uses information logged during normal operation to correctly reconstruct state after a failure. However, traditional rollback recovery cannot maintain high throughput given the frequent output rate of middleboxes. Hence, we design a novel solution to record middlebox state which relies on two mechanisms: (1) 'ordered logging', which provides lightweight logging of the information needed after recovery, and (2) a `parallel release' algorithm which, when coupled with ordered logging, ensures that recovery is always correct. We implement ordered logging and parallel release in Click and show that for our test applications our design adds only 30$mu$s of latency to median per packet latencies. Our system introduces moderate throughput overheads (5-30\%) and can reconstruct lost state in 40-275ms for practical systems.},
    booktitle = {Proceedings of the 2015 ACM Conference on Special Interest Group on Data Communication},
    pages = {227–240},
    numpages = {14},
    keywords = {parallel fault-tolerance, middlebox reliability},
    location = {London, United Kingdom},
    series = {SIGCOMM '15}
}

@inproceedings{de2014beyond,
    author = {De Carli, Lorenzo and Sommer, Robin and Jha, Somesh},
    title = {Beyond Pattern Matching: A Concurrency Model for Stateful Deep Packet Inspection},
    year = {2014},
    isbn = {9781450329576},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2660267.2660361},
    doi = {10.1145/2660267.2660361},
    abstract = {The ever-increasing sophistication in network attacks, combined with larger and larger volumes of traffic, presents a dual challenge to network intrusion detection systems (IDSs). On one hand, to take advantage of modern multi-core processing platforms IDSs need to support scalability, by distributing traffic analysis across a large number of processing units. On the other hand, such scalability must not come at the cost of decreased effectiveness in attack detection. In this paper, we present a novel domain-specific concurrency model that addresses this challenge by introducing the notion of detection scope: a unit for partitioning network traffic such that the traffic contained in each resulting "slice" is independent for detection purposes. The notion of scope enables IDSs to automatically distribute traffic processing, while ensuring that information necessary to detect intrusions remains available to detector instances. We show that for a large class of detection algorithms, scope can be automatically inferred via program analysis; and we present scheduling algorithms that ensure safe, scope-aware processing of network events. We evaluate our technique on a set of IDS analyses, showing that our approach can indeed exploit the concurrency inherent in network traffic to provide significant throughput improvements.},
    booktitle = {Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security},
    pages = {1378–1390},
    numpages = {13},
    keywords = {flexible intrusion detection, nids, scalable traffic analysis},
    location = {Scottsdale, Arizona, USA},
    series = {CCS '14}
}

@inproceedings{maple,
    author = {Voellmy, Andreas and Wang, Junchang and Yang, Y Richard and Ford, Bryan and Hudak, Paul},
    title = {{Maple: Simplifying SDN Programming Using Algorithmic Policies}},
    year = {2013},
    isbn = {9781450320566},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/2486001.2486030},
    doi = {10.1145/2486001.2486030},
    abstract = {Software-Defined Networking offers the appeal of a simple, centralized programming model for managing complex networks. However, challenges in managing low-level details, such as setting up and maintaining correct and efficient forwarding tables on distributed switches, often compromise this conceptual simplicity. In this pa- per, we present Maple, a system that simplifies SDN programming by (1) allowing a programmer to use a standard programming language to design an arbitrary, centralized algorithm, which we call an algorithmic policy, to decide the behaviors of an entire network, and (2) providing an abstraction that the programmer-defined, centralized policy runs, conceptually, "afresh" on every packet entering a network, and hence is oblivious to the challenge of translating a high-level policy into sets of rules on distributed individual switches. To implement algorithmic policies efficiently, Maple includes not only a highly-efficient multicore scheduler that can scale efficiently to controllers with 40+ cores, but more importantly a novel tracing runtime optimizer that can automatically record reusable policy decisions, offload work to switches when possible, and keep switch flow tables up-to-date by dynamically tracing the dependency of policy decisions on packet contents as well as the environment (system state). Evaluations using real HP switches show that Maple optimizer reduces HTTP connection time by a factor of 100 at high load. During simulated benchmarking, Maple scheduler, when not running the optimizer, achieves a throughput of over 20 million new flow requests per second on a single machine, with 95-percentile latency under 10 ms.},
    booktitle = {Proceedings of the ACM SIGCOMM 2013 Conference on SIGCOMM},
    pages = {87–98},
    numpages = {12},
    keywords = {openflow, software-defined networking, algorithmic policies},
    location = {Hong Kong, China},
    series = {SIGCOMM '13}
}

@inproceedings{katsikas2021,
    author="Katsikas, Georgios P. and Barbette, Tom and Chiesa, Marco and Kosti{\'{c}}, Dejan and Maguire, Gerald Q.",
    editor="Hohlfeld, Oliver and Lutu, Andra and Levin, Dave",
    title={{What You Need to Know About (Smart) Network Interface Cards}},
    booktitle="Passive and Active Measurement",
    year="2021",
    publisher="Springer International Publishing",
    address="Cham",
    pages="319--336",
    abstract="Network interface cards (NICs) are fundamental components of modern high-speed networked systems, supporting multi-100 Gbps speeds and increasing programmability. Offloading computation from a server's CPU to a NIC frees a substantial amount of the server's CPU resources, making NICs key to offer competitive cloud services. Therefore, understanding the performance benefits and limitations of offloading a networking application to a NIC is of paramount importance.",
    isbn="978-3-030-72582-2"
}

@article{count-min-sketch,
    title = {An improved data stream summary: the count-min sketch and its applications},
    journal = {Journal of Algorithms},
    volume = {55},
    number = {1},
    pages = {58-75},
    year = {2005},
    issn = {0196-6774},
    doi = {https://doi.org/10.1016/j.jalgor.2003.12.001},
    url = {https://www.sciencedirect.com/science/article/pii/S0196677403001913},
    author = {Graham Cormode and S. Muthukrishnan},
    abstract = {We introduce a new sublinear space data structure—the count-min sketch—for summarizing data streams. Our sketch allows fundamental queries in data stream summarization such as point, range, and inner product queries to be approximately answered very quickly; in addition, it can be applied to solve several important problems in data streams such as finding quantiles, frequent items, etc. The time and space bounds we show for using the CM sketch to solve these problems significantly improve those previously known—typically from 1/ε2 to 1/ε in factor.}
}

@inproceedings{enso,
    author = {Hugo Sadok and Nirav Atre and Zhipeng Zhao and Daniel S. Berger and James C. Hoe and Aurojit Panda and Justine Sherry and Ren Wang},
    title = {{Ens\=o: A Streaming Interface for NIC-Application Communication}},
    booktitle = {17th USENIX Symposium on Operating Systems Design and Implementation (OSDI 23)},
    year = {2023},
    isbn = {978-1-939133-34-2},
    address = {Boston, MA},
    pages = {1005--1025},
    url = {https://www.usenix.org/conference/osdi23/presentation/sadok},
    publisher = {USENIX Association},
    month = jul
}

@misc{perf,
  author = {{Perf}},
  title = {\texttt{perf}: Linux profiling with performance counters},
  note = {\url{https://perf.wiki.kernel.org}},
  year = {2023}
}

@misc{maestro-repo,
    author = {},
    title = {Maestro source code},
	note = {\url{https://github.com/snaplab-dpss/maestro/tree/nsdi24}},
    year = {2023}
}

@misc{maestro-test-suit,
    author = {},
    title = {Maestro's test suit},
	note = {\url{https://github.com/snaplab-dpss/maestro-eval/tree/nsdi24}},
    year = {2023}
}