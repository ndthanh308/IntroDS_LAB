\clearpage
\appendix

\section{Appendix}

\subsection{Code excerpts from \maestro}
\label{appendix:code}

We present here the pseudo-code of the firewall NF used throughout the paper, both its sequential and parallel shared-nothing implementations. These serve to provide a sense of what the \maestro pipeline both accepts as input (\cref{fig:fw-seq}) and automatically generates as output (\cref{fig:fw-sn}). As such, we reiterate that these are \emph{not} complete examples, but only pseudo-code, as they were shortened and simplified for clarity purposes. The complete solutions can be found on our public GitHub repository~\cite{maestro-repo}.

Notice the symmetry of the RSS hashes (lines 7 to 25 in~\cref{fig:fw-sn}), as it is what ultimately enables its shared-nothing approach. As explained in \cref{subsection:microbenchmarks}, this symmetry allows packets coming from the WAN to be sent to the same core as their corresponding symmetric packets from the LAN.

% \newpage
% \lstinputlisting[float=h,language=C,style=C,caption=Pseudo-code of the sequential firewall used as an example throughout the paper,label=fig:fw-seq]{code/fw-seq.c}

\subsection{Macrobenchmarks with Zipfian traffic}
\label{appendix:zipf}

% Figure environment removed

While in \cref{fig:technologies} we show how throughput varies for different parallelization techniques under uniform traffic, here we repeat the experiment with Zipfian traffic instead~\cite{benson2010network} (we describe this Zipfian traffic in~\cref{section:implementation}). We balanced the indirection table for each implementation to better handle the skew, as described in~\cref{subsec:skew}. The results are shown in~\cref{fig:technologies-zipf}.


% Figure environment removed

The key takeaways are the same as in~\cref{fig:technologies}: when available the shared-nothing approach is always preferred; the lock-based solutions frequently do not scale as well as their shared-nothing alternatives and suffer in more state-intensive NFs; and TM-based approaches perform unreliably.

We do, however, find differences between these results and their counterparts under uniform traffic. Although under uniform traffic it is rather clear that throughput scales up with the number of cores when using the shared-nothing approach, with Zipfian traffic this scaling is not always consistently monotonic. This is to be expected, as the efficacy of balancing load across cores may not consistently improve when more cores are added. Indeed, when many cores are used, a single elephant flow can bottleneck a single core, limiting the maximum throughput we will be able to achieve in our experimental setup. This is particularly limiting for computationally and state intensive NFs---such as the the Connection Limiter--- which are unable to perform as well with Zipfian traffic as they do with uniform. These results nevertheless confirm that \maestro generated NFs almost always perform as well with Zipfian traffic as they do with uniform.

% Figure environment removed

\subsection{Reproducibility}

We make \maestro's code publicly available in~\cite{maestro-repo}. In that repository, one can find not only the source code for the entire pipeline, but also the complete set of NFs we mention on this paper, along with their corresponding parallel solutions found by \maestro and described in~\cref{subsection:microbenchmarks}.

We also make available our test suit in~\cite{maestro-test-suit}. It contains all the required scripts to generate~\cref{fig:traffic,fig:pkt_sz,fig:churn,fig:technologies,fig:vpp-64b,fig:technologies-zipf}. They were tested on 2 machines with dual socket Intel Xeon Gold 6226R @ 2.90GHz, 96~GB of DRAM, and e810 Intel NICs~\cite{e810}, and running Ubuntu 22.04.

% \newpage
% \lstinputlisting[language=C,style=C,caption={Pseudo-code of the same firewall, but now parallelized by \maestro with a shared-nothing architecture (and described in~\cref{subsubsection:microbenchmarks:fw})},label=fig:fw-sn]{code/fw-sn.c}

