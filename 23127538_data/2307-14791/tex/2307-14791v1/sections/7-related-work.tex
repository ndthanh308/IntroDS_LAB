%-------------------------------------------------------------------------------
\section{Related Work}
\label{section:rw}
\vspace{-0.5em}
%-------------------------------------------------------------------------------

\noindent \textbf{Fast packet processing.} To address the performance challenges associated with software NFs, new packet I/O frameworks were proposed \cite{Bonelli2016,Rizzo2012,Deri2004,ebpf}. To achieve high packet processing rates these solutions explore several types of optimizations including zero-copy, kernel bypass, I/O batching, and multi-queue support~\cite{Barbette2015}. VPP~\cite{barach2018high} even expands batching to the whole packet processing pipeline in order to reduce instruction cache misses.
Most implementations of network functions today~\cite{Trevisan2016,Emmerich2015,Wu2018,Zaostrovnykh2017}, including those from \maestro, rely on Intel DPDK~\cite{Intel2010}, a kernel-bypass packet processing framework that provides a set of software libraries and drivers for fast packet processing, providing multi-core and NUMA-aware functionalities.

\noindent \textbf{NF acceleration.} PacketMill~\cite{farshin2021packetmill} accelerates NFs by carefully managing packet metadata and performing code-optimizations across the whole network stack. Another approach to improve the performance of a software NF is to leverage the platform hardware. Previous work~\cite{Papadogiannaki2017, Trevisan2016,Jamshed2012,Dobrescu2009,maple} has explored multi-core CPU architectures, showing the significant improvements they can achieve on an NF's performance, but also the challenges involved. Papadogiannaki \etal {\cite{Papadogiannaki2017}}, for instance, explored the advantages of a shared-nothing model over a lock based implementation.
The goal of \maestro is to offer the advantages of parallelization to NFs, for free.
Although their work focused on the most efficient utilization of available resources, we use their shared-nothing model as guidance for automated generation of parallel network functions.
These solutions are \emph{manual}, requiring extensive expertise and painstaking effort from the developer.

De Carli \etal~\cite{de2014beyond} proposed a concurrency model for software IDSes that uses program analysis to infer the NF's flow semantics, feeding that information to a software scheduler that steers packets to shared-nothing threads. Though the concepts share similarities, \maestro's approach differs from theirs by (1) considering a wider class of NFs more generally, rather than IDSes in particular; (2) using ESE to extract fine-grained state access patterns, as opposed to their less granular program-slicing approach; and (3) handling packet steering entirely in hardware by generating RSS configurations for NICs, avoiding the bottleneck of the software scheduler and allowing \maestro parallelized NFs to scale better.

\noindent \textbf{NF verification and synthesis.} In recent years, verification techniques have started to be applied to network functions. Some of the most relevant work includes verification of network properties \cite{kazemian2012header,khurshid2013veriflow}, configurations \cite{fogel2015batfish,beckett2017general}, and NFs \cite{zaostrovnykh2019verifying}. More recently, the research community has started exploring synthesis approaches for SDN-based control~\cite{chen2018towards}, data plane programs~\cite{gao2020switch, zhang2020gallium, synapse}, and BGP configurations~\cite{vanbever2020,vanbever2021}.
Our work fits into this line, by analyzing sequential NFs to automatically generate accelerated versions.