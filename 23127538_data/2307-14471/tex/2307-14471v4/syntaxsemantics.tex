\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]
\section{Machine State and Semantics}
% \section{Machine State \& Syntax}
\label{sec:syntax}
To develop our core logical ideas, we instantiate \iris with a simple language for streams of instructions
and a logical machine model corresponding to execution of x86-64 assembly instructions with virtual memory enabled on the
CPU.
%
% \subsection{Registers and Memory}
% Programs we demonstrate in this paper requires accessing two types of computer resource: registers and memory.
A register identifier, $\reg$, is chosen from a fixed finite set of register identifiers, $\regset$.\footnote{\add{$\reg$ abbreviates \emph{general register}, which includes integer registers (e.g., \lstinline|rax|),
control registers (e.g., \lstinline|cr3|), and segmentation registers (which we do not discuss in detail,
but are still used in a limited way in 64-bit mode on modern x86-64 processors).
}} 
We use these identifiers $\reg$ for register names such as \lstinline|rax|, \lstinline|r8|, or \lstinline|cr3|. Our model includes
all x86-64 integer registers (including stack and instruction pointers), as well as \lstinline|cr3| (for page table roots) and \lstinline|rflags| (for
flags set by comparison operations and inspected by conditional jumps).
% % Figure environment removed
For clarity and ease of representation, we use machine words, $\loc \in \Loc$, with the subscripts showing the number of bits in a word,
for memory addresses, values, and offsets, rather than distinct location types that wrap machine words.
For example, $\kw{w}_{12}$ is a 12-bit word, which can be obtained for example truncating away 52 bits of a 64-bit word ($\kw{w}_{64}$).
% \subsection{State}
\label{sec:state}
We represent the machine state mainly as a finite map of registers to register values and a map of word-aligned physical memory addresses 
to 64-bit physical memory values. 
Thus our states $\sigma$ include register maps $\sigma.\mathcal{R}: \kw{greg} \rightarrow_{\textrm{fin}} \kw{regval} $ and
memory maps $\sigma.\mathcal{M}: \Locft \rightharpoonup_{\textrm{fin}} (\Loctw \rightharpoonup_{\textrm{fin}} \Locsf )$
\add{which segment memory into page-sized increments}.
Of particular note, \lstinline|cr3|, the page table register, is included in the machine state.
\looseness=-1


% \subsection{Instructions}
\label{sec:instructions}

% % Figure environment removed

Programs in our logic are instruction sequences \instrs, which are formed by either a basic instruction \iskip, or prefixing an existing instruction
sequence with an additional instruction (\iseq\instr\instrs).
We model (and later, give program logic rules for) instructions for register loads and stores, and reading and writing memory.
The latter require page table walks.
The most important instructions that we model are memory-accessing variants of the x86-64 \lstinline|mov| instruction, which we format in Intel syntax
(destination on the left, source on the right).
Thus, a store to memory is $\textsf{mov}~[r_m]~r_r$, and a load from memory is $\textsf{mov}~r_r~[r_m]$.
Operationally, each first translates the virtual address stored in the register $r_m$ to a physical address \add{(a page table walk)},
then either updates the memory at that physical location with the contents of $r_r$ (for store)
or updates $r_r$ with the contents of that memory (for load).
Our formalization includes
additional \lstinline|mov| variants (e.g., accessing memory at constant offsets from the base register, or moves between registers),
basic integer and bitwise operations (\lstinline|add|,
\lstinline|and|, bit shifts, etc.) with their effects on \lstinline|rflags|, jumps and some (not all) conditional jumps, \lstinline|call|, \lstinline|ret|, \lstinline|push|,
and \lstinline|pop|.
% The semantics model updates to the instruction pointer, though we elide that register (\lstinline|rip|)
% from specifications in the paper for clarity.
\looseness=-1
