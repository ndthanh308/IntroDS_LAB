\section{Related Work}
\label{sec:relwork}
We will discuss two streams of related work: OS verification, and 
program logics with modalities.

\paragraph{OS Kernel Verification}
There has been relatively little prior work on formal verification of virtual memory.
Most OS verification work minimizes reasoning about virtual memory management.
The original \textsc{Verisoft} project~\cite{alkassar2008verisoft,alkassar2010pervasive,alkassar2008formal,dalinger2005verification,hillebrand2005address,alkassar2008formal,starostin2010formal} 
relied on custom hardware which always ran kernel code with virtual memory disabled, removing the circularity that is a key challenge of verifying
VMM code for real hardware: at that point page tables become a basic partial map data structure to represent user program address translations,
with an idiosyncratic format. Subsequent OS verification work
\add{targets real hardware that uses virtual addressing in the kernel, but unsoundly
uses hardware models that do not.} 
\add{Thus} they \emph{trust}
that the particular page table manipulations do not, for example, unmap kernel code
 (which can crash the machine even if done ``temporarily'').
This is true for \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS,Sewell2013translation}, whose formal machine model omits address translation,
and \textsc{CertiKOS}~\cite{gu15,gu2016certikos,gu2018certikos,chen2016interrupts}, whose refinement proofs rely on
\textsc{CompCert}'s usermode-oriented memory model~\cite{leroy2008formal,leroy2009formally} which assumes
updates to one memory address are independent of updates to another ---
which is not true of page table updates.
Other work on OS verification either never progressed to VMM verification
(\textsc{Verisoft XT}~\cite{cohen2009vcc,cohen2010local,dahlweid2009vcc,cohen2013SOFSEM}),
or uses memory-safe languages
for process isolation instead of address translation
(\textsc{Singularity}~\cite{Fahndrich2006language,Hunt2007singularity,Hunt2007sealing,Barnett2011specsharp}, \textsc{Verve}~\cite{Yang2010Verve},
and \textsc{Tock}~\cite{levy2017multiprogramming}), ensuring memory safety, but ignoring other functional uses of virtual memory
hardware, like swapping~\cite{Denning1970VM} or exploiting copy-on-write techniques for dynamic migration of virtual machines~\cite{clark2005live}.
\looseness=-1

\add{
 These limitations motivate work like ours on reasoning soundly about virtual memory management.
 As discussed earlier, 
}
\citet{kolanski08vstte} are the only other researchers to study VMM verification against a realistic hardware
model, where page table updates are performed through virtual memory accesses (later adding C-level type modeling~\cite{kolanski09tphols}).
As noted in Section \ref{sec:overly-restrictive}, Kolanski and Klein's virtual points-to is similar to that in Figure \ref{fig:strongvirtualpointsto},
with the attendant problems discussed earlier and lifted by our model. Their approach had modal elements,
but
 did not tackle evaluations that would benefit from modality.
 Our work improves significantly on the technical capabilities of ther logic and
 evaluates on kernel code that is more complete and more challenging than theirs.
\looseness=-1

\add{
 Our modal approach makes it possible to specify address space changes cleanly, which their logic cannot do at all.
 Our use of virtual pte-points-to assertions enables nearly the same proof rules
 as standard memory accesses, and constructing virtual points-to information within the logic
 (c.f.\ the logical entailment between $\textsf{R}_\textsf{walk}$ and $\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$)
 whereas Kolanski and Klein must reason semantically about when the model state supports new virtual points-to assertions.
}

\add{
Kolanski and Klein verify the critical step of updating an already-located L1 entry to map a new page
(ARM assembly corresponding roughly to Lines \ref{line:l1entry_storeC} and \ref{line:l1entry_setpresent}
in our Figure \ref{fig:mapping_codeC}), but ignore the essential code
preceding that step --- which as our \lstinline|walkpgdir| and \lstinline|pte_get_next_table| verifications
demonstrate, side-steps a significant amount of complexity and critical reasoning tasks.
We have verified the entirety of the software page table walk up to mapping a new page, aside from a trusted physical memory allocator resembling
\lstinline|malloc|~\cite{Chlipala2013Bedrock,wickerson2010explicit}.
 As a consequence of tackling this larger verification challenge, our work is the first to formally specify large
 segments of the self-referential portion of an OS kernel's virtual memory management invariants (per Sections \ref{sec:p2vC} and \ref{sec:selfconditional}),
 and to reason about converting from physical addresses to virtual addresses efficiently.
\looseness=-1
}

Due to a lack of fractional permissions in their formalism, they incidentally pick up other limitations orthogonal to their
foundational focus: by requiring
a virtual points-to have \emph{full} ownership of the page table walk memory, they limit their system to having only as many
virtual points-to assertions as there are entries in the top-level table ({512}) because they cannot share access to entries.
We inherit fractional permission support form \iris, and use it extensively (the overly-restrictive
Figure \ref{fig:strongvirtualpointsto} is already an improvement in this way).
\add{While we cannot claim credit for \textsc{Iris}'s extensive feature set, the fact that the model of our
assertions is based on a classic algebraic tool (pointwise lifting) makes our approach compatible with
other logical bases as well, such as \textsc{PulseCore}~\cite{ebner2025pulsecore} or \textsc{VST}~\cite{appel2014program}.
}
\looseness=-1
 
Kolanski and Klein prove that updates to any memory locations that are not part of the page tables
do not affect the interpretation of other memory addresses, just like on real hardware.
This implies that programs that do not modify memory mappings could be reasoned about without
concern for mappings.
 An analagous result should hold of our model (though we have not proven it).
Informally this is visible in the rules for
\texttt{mov} instructions,
which are nearly identical to rules in a VM-ignorant logic~\cite{Chlipala2013Bedrock,ni2007contexts}.
  In principle both our approach and Kolanski and Klein's could
 be extended to account for pageable points-to assertions by adding 
disjunctions to an extended points-to definition\add{,} \add{which would be}
 the appropriate next step to extend reasoning to usermode programs running with a kernel that may demand-page the program's
memory.
\looseness=-1

As noted in Section \ref{sec:backgroundonmachinemodel}, we do not formally model or reason about \add{translation lookaside buffers} \add{(}TLBs\add{)}.
 TLB flushes are necessary when a page is \emph{un}mapped, or when switching address spaces.
This occurs in few places in uniprocessor kernels (in some, only 3 locations), \add{so} full verified
kernels including \textsc{seL4}~\cite{Klein2009seL4,seL4TOCS} and \textsc{CertiKOS}~\cite{gu15,gu2016certikos}
trust TLB management. Neither of the aforementioned systems has a hardware model including a TLB, so neither is able
to verify TLB management in any form --- they \emph{must} trust its operation.
 This is true of multicore verified kernels as well~\cite{von2013clustered,gu2016certikos}, though there
 the situation becomes much more challenging: when unmapping pages, the running CPU must invalidate the relevant TLB entries locally,
 but also send an inter-procesor interrupt (IPI) to all other cores to ensure they also invalidate affected entries on their TLBs.
 No formal hardware model currently exists for IPIs on any architecture, or even for the memory-mapped IO
 used to trigger those IPIs.

The only work to tackle TLB code verification was
\citet{syeda2018program,syeda2020formal},
who are also the only prior work on verifying address-space-aware context switching.
However, they verified only the 4 instructions to switch address spaces and update the TLB on an ARM processor, in isolation
(i.e., not the full context switch including changing stacks with address spaces).
The specification they proved for those instructions did not address program invariants that may be valid in one address space and not the other,
so is not flexible enough to extend directly to a full context switching primitive as in Figure \ref{fig:swtchC}.
\add{Their logic adds an assertion tracking known-inconsistent addresses (i.e., recently-unmapped by a table update or change in page table root)
and their memory access rules require accessed memory to lie outside that set.
% However their logic is proven sound against a generalized semantics where
% any page table change adds \emph{all}
% addresses to the inconsistent set,
% which is too imprecise for finer-grained unmapping.
However in their logic,
reasoning about updates to the inconsistent set (from a page table update)
requires direct reasoning
directly about the physical memory heap, which limits modularity.
}
The right general solution would be to combine our work
and \add{an extension of} theirs, \add{a substantial project} which we leave to future work.
\add{
 No other prior work has considered address space changes during context switching. \textsc{XCAP}~\cite{ni2007contexts}
 and Bedrock~\cite{Chlipala2011Bedrock,Chlipala2013Bedrock,Chlipala2015webapp} deal
 only with usermode threading (in a single process). \textsc{CertiKOS} and \textsc{seL4} trust assembly primitives for
 context switches, and do  not model address translation for executing code.
 \looseness=-1
}

\paragraph{Program Logics with Modalities}
Modalities have long been a staple of program logics, at least {since} Dijkstra's weakest precondition calculus~\cite{dijkstra1975guarded}
and Pratt's observation the Hoare triples
could be decomposed using the weakest-precondition modality of dynamic logic~\cite{pratt1976semantical},
in a form quite similar to what \iris uses today~\cite{jung2018iris}.
Variants of Nakano's later modality~\cite{nakano2000modality} have long been used to deal with step-indexing 
for impredicative and recursive features of logics and type systems~\cite{Appel2007,hobor2010theory,birkedal2011step,birkedal2013intensional,jung2018iris}.
\looseness=-1

As noted earlier, our other-space modality derives from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
\add{Readers mostly familiar with modalities in prominent program verification approaches~\cite{Appel2007,birkedal2013intensional,birkedal2011step,hobor2010theory,jung2018iris,nakano2000modality,pnueli1977temporal,pratt1976semantical}
may not recognize hybrid logics, but as we discuss in Section \ref{sec:relwork}, they (like temporal logics) trace their roots back to Arthur Prior in the 1950s.
}
Little prior work combines these ideas with program logics. \citet{brotherston2014parametric} show that traditional
nominals extends the expressive power of separation logic. \citet{gordon2019modal}
uses nominals to refer to states of other actors in an actor language.
In parallel with our work, \citet{wagner2024realistic} use a hybrid-logic-inspired modality
to abstract reference-counting specifics from specifications of a low-level application binary interface (ABI)
--- their $@_l(P)$ indicates that $l$ is the location of a reference count for resources satisfying $P$.
% As noted throughout the paper, the inspiration for our other-space modality comes from hybrid logic~\cite{areces2001hybrid,blackburn1995hybrid,gargov1993modal,goranko1996hierarchies},
% where modalities are indexed by \emph{nominals} which are names for specific individual states in a Kripke model.
% We are aware of only two prior works combining hybrid logics with program logics specifically. 
% Brotherston and Villard~\cite{brotherston2014parametric} demonstrated that may properties true of various 
% separation logics are not definable in boolean \BI (\BBI), and showed that a hybrid extension \HyBBI allows
% most such properties to be defined (e.g., the fact that separating conjunction is cancellative is unprovable 
% in boolean \BI, but provable in \HyBBI). There, nominals named resources 
% (roughly, but not exactly, heap fragments). 
% Gordon~\cite{gordon2019modal} described a use of hybrid logic in the verification of actor programs, 
% where nominals named the local state of individual actors (with such assertions stabilized with a 
% rely/guarantee approach). 
Beyond these, there is limited work on the interaction of hybrid logic with general substructural logics, in restricted forms
that do not affect expressivity~\cite{despeyroux2014hybrid,chaudhuri2019hybrid}.
\looseness=-1
% Primarily there is a line of work on hybrid linear logic (\HyLL)~\cite{despeyroux2014hybrid}, 
% originally used as a way to more conveniently express aspects of transition systems in linear logic. 
% However, \HyLL's proof rules offer no non-trivial interactions with multiplicative connectives 
% (every \HyLL proof can in fact be embedded into regular linear logic~\cite{chaudhuri2019hybrid}, 
% unlike Brotherston and Villard's \HyBBI, which demonstrably increases expressive power over its base \BBI.

% In both \HyLL and \HyBBI, nominals denote worlds with monoidal structure (as worlds in Kripke semantics
% for either LL or \BBI necessarily have monoidal structure). Our nominals, by contrast, 
% do not name worlds in the same sense with respect to Iris's CMRAs, 
% but in fact \emph{classes} of worlds, because the names are locations 
% (a means of \emph{selecting} resources) rather than resources.  
% A key difference is that the use of nominals in those logics corresponds specifically to hypothetical 
% reasoning about resources (until a nominal is connected to a current resource, in which case conclusions 
% can be drawn about the current resource), which means the modalities themselves do not ``own'' resources. 
% Instead, assertions under our other-space modality can and do
% have resource footprints.
% Pleasantly, we sidestep most of the metatheoretical complexity of those other substructural hybrid
% systems by building our logic within a substructural metatheory (\iris).

Some logics for weak memory models~\cite{dang2019rustbelt,dang2022compass} have been formalized
in \iris using pointwise lifting, parameterizing by thread-local views of events (an operationalization of the release-acquire + nonatomic
portion of the repaired C11 memory model~\cite{lahav2017repairing}). 
There modalities $\Delta_\pi(P)$ and $\nabla_\pi(P)$
represent that $P$ held before or will hold after certain memory fences by thread $\pi$.
The definitions of those specific modalities existentially quantify over other views, related to the ``current'' view (the one where
the current thread's assertions are evaluated), and evaluate $P$ with respect to those other views. This approach to parameterizing
assertion semantics by a point of evaluation, and evaluating modalized assertions at other points quanfied in the definition of a modality,
is the classic notion of modal assertions, 
whereas hybrid logics expose the choice of evaluation point in assertions,
allowing statements of more properties. 
In these weak memory examples this additional expressive power would not be useful,
because any relevant points of evaluation (thread views) are intimately tied to memory fences performed by the program, whereas
for virtual memory management the kernel must be able to choose or construct arbitrary other address spaces.
\looseness=-1

%   is what it means
% to have a modality at all.
% It is \emph{not}, however, an instance of hybrid logic, which is specifically demarcated by an assertion language where
% \emph{assertions}, not their semantics, choose and name the evaluation points for modal assertions.
% A hybrid extension of the aforementioned logics would include assertions which named specific views at which to evaluate
% $P$, in the syntax of the assertion (e.g., $\Delta_\pi^v(P):=\lambda\_\ldotp (P\;v)$) rather than the 
% $\Delta_\pi(P):= \lambda v\ldotp (\exists v_{rel}\ldotp \ownGhost{\pi}{\mathsf{RelV}(v_{rel})\;v} \ast (P\;v_{rel})))$ actually used.
% Note the hybrid version takes the place to evaluate $P$ as a parameter, and therefore allows the \emph{derived} (modal) logic to explicitly
% reason in terms of evaluation points, rather than hiding all points of evaluation in the internal definitions of modalities.
% This prior \iris-based work also uses modalities where the interpretations are fixed a priori by logic designers. In contrast, our
% address space modalities' interpretations can be changed by program behaviors via page table updates; the equivalent in the prior work would
% be if programs could directly manipulate the buffers used to model weak memory behaviors,
% which they cannot.\footnote{Note that the views modelled modally in this prior work are abstractions of a wide range of hardware, so such
% manipulation of corresponding hardware resources is in fact impossible,
% while the address space mappings in our work reflect known hardware components present in a variety of CPUs.}


