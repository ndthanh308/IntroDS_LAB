\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]
\section{Machine State and Semantics}
% \section{Machine State \& Syntax}
\label{sec:syntax}
To develop our core logical ideas, we instantiate \textsf{Iris} with a simple language for streams of instructions, 
and a logical machine model corresponding to execution of x86-64 assembly instructions with virtual memory enabled on the 
CPU.

% \subsection{Registers and Memory}
Programs we demonstrate in this paper requires accessing two types of computer resource: registers and memory.
A register identifier, $\reg$, is chosen from a fixed finite set of register identifiers, $\regset$. 
We use these identifiers $\reg$ for register names such as \texttt{rax}, \texttt{r8}, or \texttt{cr3}. Our model includes
all x86-64 integer registers (including stack and instruction pointers), as well as \texttt{cr3} (for page table roots) and \texttt{rflags} (for
flags set by comparison operations and inspected by conditional jumps).
% % Figure environment removed
For clarity and ease of representation, we use machine words, $\loc \in \Loc$, with the subscripts showing the number of bits in a word,
for memory addresses, values, and offsets, rather than distinct location types that wrap machine words.
For example, $\kw{w}_{12}$ is a 12-bit word, which can be obtained for example truncating away 52 bits of a 64-bit word ($\kw{w}_{64}$).

% \subsection{State}
\label{sec:state}
We represent the machine state mainly as a finite map of registers to register values and a map of word-aligned physical memory addresses 
to 64-bit physical memory values. 
Thus our states $\sigma$ include register maps $\sigma.\mathcal{R}: \kw{greg} \rightarrow_{\textrm{fin}} \kw{regval} $ and
memory maps $\sigma.\mathcal{M}: \Locft \rightharpoonup_{\textrm{fin}} (\Loctw \rightharpoonup_{\textrm{fin}} \Locsf )$.
Of particular note, \texttt{cr3}, the page table register, is included in the machine state.
% As one might have already anticipated from the syntax we introduce, we do not bind any value of an evaluated expression. All the indices and accessed values are treated as globally referenced. In align with this design choice, our expression is a stream of instructions, which is not evaluated to a value to be bound, but changes the machine state through the indices (e.g. $\kw{r}\in\kw{greg}$) -- to the global maps.


% \subsection{Instructions}
\label{sec:instructions}

% % Figure environment removed

Programs in our logic are instruction sequences \instrs, which are formed by either a basic instruction \iskip, or prefixing an existing instruction
sequence with an additional instruction (\iseq\instr\instrs).
We model (and later, give program logic rules for) instructions for basic register moves, and reading and writing memory.
The latter require page table walks.
% Figure \ref{fig:coq_addr_translation} gives a slightly simplified version of our address translation code in monadic style:
% starting from the root page table address \textsf{rtv}, the virtual address \textsf{w} is either resolved to a physical address or an error is returned.
% The full set of possible errors is not relevant to this paper; our logic is tailored for kernel code which should not fault,
% so our proof rules guarantee no memory failures occur --- that the page table walk for any dereferenced address will succeed.

% Page-table walk shown in Figure \ref{fig:pagetables} is realized with physical memory \texttt{load}s and \textsf{store}s for the entries in the 
% page-tables which are simply modelled as lookup and updates to an instance of a memory map with 64 bit entries. In the address translation,
% we see a physical memory $\mathsf{load}$ (i.e. physical memory map ($\sigma.\mathcal{M}$) for each level) for each level of page-table-walk 
% concluded with alignment of the returned address for each \textit{successful} page-table-walk traversal which is what our reasoning principles 
% only consider.

The most important instructions we model are memory-accessing variants of the x86-64 \lstinline|mov| instruction, which we format in Intel syntax
(destination on the left, source on the right):
\[
\begin{array}{l}
  \hbox{(\TirNameStyle{WriteToMemFromReg})} \qquad
  \textsf{mov}~[r_m]~r_r \\
  \hbox{(\TirNameStyle{WriteToRegFromMem})} \qquad 
  \textsf{mov}~r_r~[r_m]
  \end{array}
  \]
The semantics of each is realized by first translating the virtual-memory address of a memory location stored in $r_m$ to a physical memory location
per the description in Section \ref{sec:backgroundonmachinemodel},
then either updating those memory contents with the contents of register $r_r$ (\TirNameStyle{WriteToMemFromReg}) 
or loading the value at that physical memory location into the register $r_r$
(\TirNameStyle{WriteToRegFromMem}). 
Additional \lstinline|mov| variants (e.g., accessing memory at constant offsets from the base register, or moves between registers) are also treated.
Our formalization also includes basic integer and bitwise operations (\lstinline|add|,
\lstinline|and|, bit shifts, etc.) with their effects on \lstinline|rflags|, jumps and some (not all) conditional jumps, \lstinline|call|, \lstinline|ret|, \lstinline|push|,
and \lstinline|pop|.
