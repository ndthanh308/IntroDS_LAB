\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

% lstlisting coq style (inspired from a file of Assia Mahboubi)
\lstdefinelanguage{Coq}{ 
    % Anything betweeen $ becomes LaTeX math mode
    mathescape=true,
    % Comments may or not include Latex commands
    texcl=false, 
    % Vernacular commands
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    % Gallina
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    % Sorts
    morekeywords=[3]{Type, Prop, Set, true, false, option},
    % Various tactics, some are std Coq subsumed by ssr, for the manual purpose
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    % Terminators
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    % Control
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    % Comments delimiters, we do turn this off for the manual
    morecomment=[s]{(*}{*)},
    % Spaces are not displayed as a special character
    showstringspaces=false,
    % String delimiters
    morestring=[b]",
    morestring=[d],
    % Size of tabulations
    tabsize=3,
    % Enables ASCII chars 128 to 255
    extendedchars=false,
    % Case sensitivity
    sensitive=true,
    % Automatic breaking of long lines
    breaklines=false,
    % Default style fors listings
    basicstyle=\small,
    % Position of captions is bottom
    captionpos=b,
    % flexible columns
    columns=[l]flexible,
    % Style for (listings') identifiers
    identifierstyle={\ttfamily\color{black}},
    % Style for declaration keywords
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    % Style for gallina keywords
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    % Style for sorts keywords
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    % Style for tactics keywords
    keywordstyle=[4]{\ttfamily\color{dkblue}},
    % Style for terminators keywords
    keywordstyle=[5]{\ttfamily\color{dkred}},
    %Style for iterators
    %keywordstyle=[6]{\ttfamily\color{dkpink}},
    % Style for strings
    stringstyle=\ttfamily,
    % Style for comments
    commentstyle={\ttfamily\color{dkgreen}},
    %moredelim=**[is][\ttfamily\color{red}]{/&}{&/},
    literate=
    {\\forall}{{\color{dkgreen}{$\forall\;$}}}1
    {\\exists}{{$\exists\;$}}1
    {<-}{{$\leftarrow\;$}}1
    {=>}{{$\Rightarrow\;$}}1
    {==}{{\code{==}\;}}1
    {==>}{{\code{==>}\;}}1
    %    {:>}{{\code{:>}\;}}1
    {->}{{$\rightarrow\;$}}1
    {<->}{{$\leftrightarrow\;$}}1
    {<==}{{$\leq\;$}}1
    {\#}{{$^\star$}}1 
    {\\o}{{$\circ\;$}}1 
    {\@}{{$\cdot$}}1 
    {\/\\}{{$\wedge\;$}}1
    {\\\/}{{$\vee\;$}}1
    {++}{{\code{++}}}1
    {~}{{\ }}1
    {\@\@}{{$@$}}1
    {\\mapsto}{{$\mapsto\;$}}1
    {\\hline}{{\rule{\linewidth}{0.5pt}}}1
    %
}[keywords,comments,strings]

\section{Implementing Logical Machinery \& Soundness}
We build our program logic, as an instantiation of Iris~\cite{jung2018iris}.
\subsection{Soundness}
\label{sec:soundness}
Our logic, operates on the machine state, which means we do not need to augment the machine state. The invarian that we pick, \textit{central invariant} ($\textsf{x64\_h}$), is just semantic interpretation of stores in the machine state, $\sigma.\mathcal{R}$ and $\sigma.\mathcal{M}$. This semantic interpratation ensures the correct lifting of mappings in the machine state to the assertions that the client of our logic uses, i.e. points-to assertions that are defined as the ownership of a fragment of the logical state.

We prefer to skip explaining the steps used in instantiation of Iris because it is an almost standard procedure, has already been explained for many other logic \ref{}, and we are concerned with the page-count limitation. However, it is worh noting that once you instantiate Iris for your language, it comes with the semantic definition for the weakest-precondition which we can refactor into Hoare-Doubles to specify our  selected \textsf{AMD64} instructions shown in Figure \ref{fig:wpdamd}, and show that these triples are sound.
\subsection{The Soundness Statement}
\label{def:soundness:statement}
The operational semantics of our simple lang just executes sequences of instructions in our x86-64 model. Therefore, our soundness argument is to show that any execution composed of instructions in our machine model (some of which are shown in Figure \sref{sec:semantics}) does not end-up in a invalid state.
% Figure environment removed

\begin{theorem}[Soundness of the Logic]
  \label{th:adequacy}
 Together with the assumptions on the initial state hold,
 the execution of the instruction~$\instrs$, beginning with this initial state, cannot result in a configuration where the execution is stuck.
\end{theorem}
which states that if the program~$\instr$, with the given \textsf{valid\_init} asserting a valid state initialization, satisfies a semantic Hoare
triple, then this program cannot crash: by a direct consequence of Iris's adequacy theorem~\cite[\S6.4]{iris}.

Moreover we need to show the validity of each rules in Figures \fref{fig:reasoning} and \fref{fig:laws}.
\begin{theorem}[Validity of the Reasoning Rules]
\label{th:validity}
  Each of the rules in Figures~\ref{fig:wpdamd}
  and~\ref{fig:structural} is valid.
\end{theorem}
Due to the space limits in this paper, we do not mention each proof for the rules in Figures \ref{fig:wpdamd} and \ref{fig:structural} within this section, but we provide mechanized proofs for all these in Coq as a part of our artifact submission.
However, we would like to give the definitions and constructions used in our proofs, and would like to give an outline of paper proof for \TirNameStyle{WriteToRegFromVirtMem} in Figure \ref{fig:wpdamd} within this section.

Together, Theorems~\ref{th:adequacy} and~\ref{th:validity} guarantee that, if
the Hoare triple $\textsf{valid\_init }\instrs\;\iTrue$ can be obtained by applying
the reasoning rules of our logic, then the program~$\instrs$ is safe.

\subsection{Logical Constructions}
\label{sec:invariant}
We already have the physical and logical stores and a simple invariant between them. Now, we can rely on the following Assumption \ref{assumption} from Iris to utilize its logical constructions.
% The predicate gen_heap_interp.
\newcommand{\genheapinterp}[1]{\mathit{Heap}\;#1}
\newcommand{\genmemheapinterp}[1]{\mathit{MemHeap}\;#1}
% Our predicate pred (defined in ph.v), expanded.
\newcommand{\pred}[1]{\ownGhost\gammaPred{\authfull{(\mapone\predstore)}}}
% A notation for assigning fraction 1 to every element of \predstore.
\newcommand{\mapone}[1]{1.#1}
% The predicate mapsfrom_exact, expanded.
\newcommand{\mapsfromexact}[3]{
  \ownGhost\gammaPred{\authfrag{\singletonMap{#1}{(#2, #3)}}}
}
% A metavariable for a share.
\newcommand{\sh}{L'}
% The predicate mapsfrom, expanded.
\newcommand{\mapsfromdef}[3]{
  \exists\sh.\;
  \mapsfromexact{#1}{#2}{\sh} \star \pure{\sh \subseteq #3}
}

\begin{assumption}
\label{assumption}
Iris defines two pieces of ghost state
\begin{enumerate}
\item  defines a predicate $\textsf{to\_gen\_heap }\store.\mathcal{R}$
  that ties a store~$\store.\mathcal{R}$ to this ghost state,
  and defines the points-to assertion $\ppointsto\rg\rv\qfrac\rpts$
  in terms of this ghost state.
  This is visible in the paper~\cite[\S6.3.2]{iris}
  and in Iris's \texttt{gen\_heap} library~\cite{genheap}.
  %
  We re-use this machinery without change,
  so we do not repeat these definitions.
  We mention the predicate $\genheapinterp\!$
  in our own invariant (Definition~\ref{def:invariant}),
  where it is applied to the \logical store~$\store$.
\item unlike the register points-to relation obtained by direct interpretion of $\textsf{to\_gen\_heap }\store.\mathcal{R}$ using Iris, the existing \textsf{gen\_heap\_heap},
  does not directly helps introducing the ghost we define a new algebra (\textsf{gen\_mem\_UR}) for abstracting the nested maps due to different levels of masking in memory mappings and an interpretation for this algebra. 
\end{enumerate}
\end{assumption}

\begin{definition}[Ghost State - Memory with Nested Mappings]
We define our custom-tailored algebra 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\( \textsf{gen\_memUR} \stackrel{\triangle}{=}
  \authm(\;
  \Locft \;\fpfn\;
  (\Loctw \;\fpfn\;  (\textsc{Frac }, \mathord{+}) \times (\textsc{Agree } \Loc,\mathord{=}) )
  \)
  for our nested memory mapping abstracting two different machine word masking. To interpret this nested ghost map, i.e. obtain points-to assertions out of mappings in an ordinary \textsf{gmap}, we define \textsf{to\_gen\_mem}
  \begin{lstlisting}[language=Coq]
    Definition to_gen_mem : gmap L1 ( gmap L2 V) $\rightarrow$ gen_memUR L1 L2 V := fmap ($\lambda$ m . to_gen_heap m).
    Definition to_gen_heap : gmap L V $\rightarrow$ gen_heapUR L V :=  $\lambda$  v $\ldotp$ (1, to_agree (v :leibnizO V)).
  \end{lstlisting}
 throuh using \textsf{to\_gen\_heap} from previous Iris version. \todo[inline,color=red]{Ismail give exact version commit etc.}
\end{definition}

\begin{definition}[Ghost State - Register Mappings]
We allocate $\theta$ ghost cell which stores an
element of the monoid 
\newcommand\fpfn{\rightarrow_{\textrm{fin}}}
\(
  \authm(\;
    \regset \;\fpfn\;
    (\textsc{Frac}, \mathord{+})
    \times
    (\regvaltype, \mathord{=})
  \;)
\)
% \emph{authoritative camera}
\cite[\S6.3.3]{iris}.
\end{definition}

\begin{definition}[Central Invariant]
\label{def:invariant}
The central invariant of our logic is, due to lack of need for augmenting the machine state, simply the state interpretation: 
\[
\textsf{x64\_h}\;\store \triangleq
\def\arraystretch{1.2}
\begin{array}{l@{\quad\ast\quad}l@{\quad}l}
  \textsf{to\_gen\_heap} \;\store.\mathcal{R} & \textsf{to\_gen\_mem} \; \store.\mathcal{M}
\end{array}
\]
\end{definition}

As a last definition, we give the head step relation required for the Iris instantiation for our simple language in Figure \ref{} to sequence instructions. This relation allows lifting the program expression to enable the application of changes imposed by the operational semantics on the program state (for a certain cpu, a register map, and a selected memory for an address-space) when applied for an insturction (\textsf{i}).
\begin{lstlisting}[language=Coq]
Definition exec_step (i: instr) ($\sigma$:state) : option state :=  exec_instr i $\sigma.\mathcal{C}$ $\sigma.\mathcal{R}$ ((memToPhysMem $\sigma.\mathcal{M}$)  ($\sigma.\mathcal{R}$ !! cr3)).
\end{lstlisting}
\todo[inline,color=yellow]{Colin, in case needed,not proven, could you simply say that we assume these map equalities or a paper proof etc.}. Again, due to the page limits, we can only give an outline of proof for a selected instruction (\TirNameStyle{WriteToRegFromVirtMem}) from our \textsf{AMD64} model. However, mechanized soundness proofs of other instructions can be found as a part of our submission artifact.

After obtaining ownership (points-to) predicates from application of state interpretation, now, we have well-enough definition for giving an outline for the proof of \TirNameStyle{WriteToRegFromVirtMem}.
 \begin{lemma}[\textsc{\TirNameStyle{WriteToRegFromVirtMem}}]
   \label{lemma:unlink}
\begin{align*}
\inferrule{
  \{\mathsf{P} \ast \mathsf{r}_d \mapsto_{r}  \mathsf{v} \ast \mathsf{r}_a \mapsto_{r} \{\mathsf{q}\} \; \mathsf{ vaddr} \ast \mathsf{vaddr} \mapsto_{\mathsf{v}} \mathsf{v} \}_{\mathsf{rtv}}\;\overline{is}
}{
  \{\mathsf{P} \ast \mathsf{r}_d \mapsto_{r}  \mathsf{rvd} \ast \mathsf{r}_a \mapsto_{r} \{\mathsf{q}\} \;\mathsf{ vaddr} \ast \mathsf{vaddr} \mapsto_{\mathsf{v}} \mathsf{v} \}_{\mathsf{rtv}}
\; \mathsf{ mov}~\mathsf{r}_d~\mathsf{r}_a;\;\overline{is}
}
\end{align*}
 \end{lemma}
 
 \begin{proof}
   Assuming the inference rule realized with \textsf{wpd\_def}, we expand the precondition with $\textsf{cr3} \mapsto_{\textsf{r}} \rtv$.
   Then we do two proofs, one for head reducibility of atomic step \textsf{mov\_reg64\_mem64}, the second one for the executing the expression and obtaining the new state. Steps taken in the first one are subset of the second one, so we outline the second portion of the proof, but in case of an interest in details of the proof, Coq artifact can be consulted.

   \begin{itemize}
   \item Step 1: we apply the head step relation and obtain the current valid state $\sigma1$ interpretation : $\textsf{x64\_h}\;\store$
   \item Step 2: we unfold the virtual-pointsto ($\vaddr \mapsto_{\textsf{v,rtv}} \textsf{v}$) definition, and for an existential physical page address $\paddr$, we exchange our fragmental toke ($\sumwalkabs\vaddr\qfrac\paddr$) to obtain physical table-pointsto ($\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$ in Figure \ref{fig:strongvirtualpointsto}) relation
   \item Step 3: for each physical pointsto inside $\textsf{L}_{4}\_\textsf{L}_{1}\_\textsf{PointsTo}$, there exists a \textsf{load}, i.e. a concrete memory lookup
   \item Step 4: use these concrete lookups to traverse the page tables to obtain the value \textsf{v}
     \item Step 5: do the map update the $\sigma.\mathcal{R}$ for relevant register mapping ($r_d$) with the value \textsf{v} 
   \end{itemize}
   
   \end{proof}
