\section* {\pdfbookmark[1]{Power Consistent Hash Algorithm}{S3}\textbf{III.\quad Power Consistent Hash Algorithm}} 
\medskip
\noindent
In Equation 3.1, the function $hash(key,n)$ is constructed to map $key$ to an integer in the range $[0, n-1]$. The equation, consisting of  three cases, is computed using two auxiliary functions $f()$ and $g()$.  Let $n$ denote the number of buckets, and $m$ be the smallest power of 2 such that $m \ge n$.  We have $m/2 < n \leq m$. \\
\ \\
\textbf{Equation 3.1.}
\[
  hash(key, n) = 
    \begin{cases}
	r_{1} = f(key, m)  &  
\text{if }  r_{1} < n, \\
	r_{2}= g(key, n, m/2 - 1) & 
\text{if } r_{1} \geq n \text{ and } r_{2} > m/2 - 1, \\
	f(key, m/2) & 
\text{if } r_{1} \geq n \text{ and } r_{2} = m/2 - 1.
    \end{cases}
\]
\noindent 
\ \\ \\
The example in the previous section illustrated the case of $n=11$ and $m=16$, where $16$ is the smallest power of 2 greater than 11.  The hash spaces and distributions of hash values for $hash(), f()$ and $g()$ with given parameters are shown in Table 3.1. The weighted distribution for $g()$ is given by Property 4.3 in Section IV.  In this paper, functions may be denoted by trailing parentheses, such as $f()$ and $g()$, with parameters omitted.  \\ 
\definecolor{Gray}{gray}{0.9}
\setlength{\arrayrulewidth}{0.8pt}
\begin{table}[!h]
\begin{center}
\caption*{\textbf{Table 3.1 }  Hash Spaces and Distributions}
\begin{NiceTabular}{ wl{2.5cm}wl{2cm}wl{2cm} }
\hline
\rowcolor{Gray}
\rule{0pt}{12pt} \textit{Function} & \textit{Hash space} & \textit{Distribution} \\[3 pt]
\hline
\rule{0pt}{12pt} $hash(key,n)$ & $[0, n-1]$ & uniform \\ 
\rule{0pt}{9pt} $f(key,m)$ & $[0, m-1]$ & uniform \\ 
\rule{0pt}{9pt}  $f(key,m/2)$ & $[0,m/2-1]$ & uniform  \\ 
\rule{0pt}{9pt} $g(key,n,m/2-1)$ & $[m/2-1,n-1]$ & weighted \\[3 pt]
\hline
\end{NiceTabular}
\end{center}
\end{table}
\pagebreak
\begin{lstlisting}[caption={[abc]}]
$\textbf{\textsc{Power-Consistent-Hash}}$($key, n$)
1   $r1 = f(key,m)$  
2   if $r1 < n$
3      return $r1$
4   $r2 = g(key, n, m/2-1)$
5   if $r2 > m/2 -1$
6      return $r2$
7   return $f(key, m/2)$ 
\end{lstlisting}
\ \\
The \textsc{Power-Consistent-Hash} algorithm computes $hash(key, n)$ according to Equation 3.1 and Table 3.1.  It takes two parameters $key$ and $n$, evaluates the conditions, and returns the result of $r1, r2,$ or $f(key, m/2)$ accordingly.  $key$ is a numerical hash key.  $n$ denotes the number of buckets.  When $n$ is known, the corresponding $m$ is computed only once for all possible $key$.  Lines 1 and 7 call the same function $f()$ with different values on the second parameter. A unique characteristic of the algorithm is the following: (i) Given $n$ and $m$, the algorithm first maps the key with equal probability into a hash space of size $m$ (which is a power of 2); and (ii) optionally, it remaps the key into a smaller space of size $n$. Keys mapped to the range $[0, n-1]$ in (i) are skipped in (ii).  The operation is fast, consistent, and balanced.  In fact, the algorithm runs in $O(1)$ expected time, independent of the parameter $n$. \\ \\
The following theorems derived for Equation 3.1 are quite useful. The functions $hash()$,  $f()$ and $g()$ implemented by the algorithms possess those properties.\\ \\
\textbf{Theorem 3.1.} \enspace The function $hash(key,n)$ satisfies the distribution uniformity given by Property 4.1 if $f()$ and $g()$ used by $hash(key,n)$ satisfy the distribution properties given by Properties 4.2 and 4.3, respectively. \\ \\
\textbf{Theorem 3.2.} \enspace The function $hash(key,n)$ satisfies the mapping consistency defined by Property 5.1 if $f()$ and $g()$ used by $hash(key,n)$ satisfy the mapping consistency defined by Properties 5.2 and 5.3, respectively. \\ \\
These properties are given in the next two sections. Section VI will describe the algorithms to implement $f()$ and $g()$, each having $O(1)$ expected time. This yields an expected running time of $O(1)$ in \textsc{Power-Consistent-Hash}. Moreover, $f()$ and $g()$ implemented by the algorithms satisfy Properties 4.2 and 4.3, respectively. They also satisfy the mapping consistency defined by Properties 5.2 and 5.3, respectively. By the above theorems, $hash(key,n)$ implemented by \textsc{Power-Consistent-Hash} satisfies the distribution uniformity given by Property 4.1 as well as the mapping consistency defined by Property 5.1. \\
\section* {\pdfbookmark[1]{Distribution Properties}{S4}\textbf{IV.\quad Distribution Properties}} 
\medskip
\noindent
Properties 4.1 to 4.3 describe probability distributions of hash values for functions $hash()$, $f()$, and $g()$, respectively.  $hash()$ maps keys uniformly over a range.  It employs two auxiliary hash functions $f()$ and $g()$ to achieve distribution uniformity. $f()$ maps keys uniformly as described in Property 4.2, while $g()$ maps keys following a weighted probability distribution given by Property 4.3. The distribution properties were illustrated in Section II.\\ \\
\noindent
\textbf{Property 4.1.} \enspace The function $hash()$ maps $key$ to an integer $x$ with equal probability given by $P(X=x)$.
\begin{align*}
hash(key, n) &= x, \\
P(X=x) &= \frac{1}{n}, \quad x = 0, 1, \ldots, n-1.
\end{align*}
\noindent
\ \\ \\
\textbf{Property 4.2.} \enspace The function $f()$ maps $key$ to an integer $x$ with equal probability  given by $P(X=x)$.  $m$ is a power of 2.
\begin{align*}
f(key, m) &= x, \\
P(X=x) &= \frac{1}{m},  \quad x = 0, 1, \ldots, m-1.
\end{align*}
\noindent
\\
\textbf{Property 4.3.} \enspace The function $g()$ maps $key$ to an integer $x$ with a weighted probability given by $P(X=x)$.  $s$ is an integer $\geq 0$.
\begin{align*}
g(key, n, s) &= x, \\ 
P(X=x) &=
\begin{cases}
\dfrac{s+1}{n}, &
x = s, \\ \\
\dfrac{1}{n}, &
x = s+1, \ldots, n-1.
\end{cases}
\end{align*}
\medskip 
\section* {\pdfbookmark[1]{Properties of Mapping Consistency}{S5}\textbf{V.\quad Properties of Mapping Consistency}}
\medskip
\noindent
For any given key, a hash function maps the key to an integer in a hash space, which is the set of all possible hash values of the function.  Under mapping consistency, key remapping is minimized when the hash space changes.\\ \\
\noindent
\textbf{Hash Space.} \enspace Given integer parameters $n_{1}, n_{2}, m_{1}, m_{2}$, $s$, individual hash spaces $S_{1}, S_{2}, \ldots, S_{6}$ are determined accordingly for all possible $key$ passed to the functions:
\begin{align*}
hash(key, n_{1})  & \in S_{1} = \{0,1, \ldots, n_{1}-1\}, \\
hash(key, n_{2})  & \in S_{2} = \{0,1, \ldots, n_{2}-1\}, \\
f(key, m_{1}) & \in S_{3} = \{0,1, \ldots, m_{1}-1\}, \\
f(key, m_{2}) &  \in S_{4} = \{0,1, \ldots, m_{2}-1\}, \\
g(key, n_{1}, s) &  \in S_{5} = \{s,s+1, \ldots, n_{1}-1\}, \\
g(key, n_{2}, s) &  \in S_{6} = \{s,s+1, \ldots, n_{2}-1\}.
\end{align*}
\ \\[-2 ex]
\noindent
\textbf{Example 5.1.}  \enspace This example illustrates Property 5.1.  In Table 5.1, there are 6 keys.  Columns $x$ and $y$ contain the hash values where the numbers of buckets are 10 and 19, respectively.  We have $x = y$ if $y < 10$.  Replacing 10 and 19 with $n_{2}$ and $n_{1}$, respectively, we then have $x=y$ if $y < n_{2} < n_{1}$. 
\definecolor{Gray}{gray}{0.9}
\setlength{\arrayrulewidth}{0.7pt}
\begin{table}[!h]
\begin{center}
\caption*{\textbf{Table 5.1 }  Example of Mapping Consistency}
\begin{NiceTabular}{ wc{1cm}wc{2.5cm}wc{2.5cm}}
\hline
\rowcolor{Gray}
\rule{0pt}{12pt} $key$ & $hash(key,10) = x$ & $hash(key,19) = y$ \\[3 pt]
\hline
\rule{0pt}{9pt} $k_{1}$ & 2 & 2 \\ 
\rule{0pt}{9pt} $k_{2}$ & 1 & 1  \\ 
\rule{0pt}{9pt} $k_{3}$  & 3 & 11  \\
\rule{0pt}{9pt} $k_{4}$  & 8 & 15 \\
\rule{0pt}{9pt} $k_{5}$  & 5 & 5  \\
\rule{0pt}{9pt} $k_{6}$  & 2 & 16 \\
\hline
\end{NiceTabular}
\begin{align*} 
hash(key, 10) = x, & \quad 0 \le x < 10, \\
hash(key, 19) = y, & \quad 0 \le y < 19. 
\end{align*}
\end{center}
\end{table}
\ \\
With this property, we can minimize key remapping and data redistribution when the number of buckets changes. The power consistent hash algorithm satisfies this property, and has the complexity of $O(1)$ space and $O(1)$ expected time. Similar examples can be derived for Properties 5.2 and 5.3.\\ \\
Properties 5.1 to 5.3 formalize mapping consistency for $hash()$, $f()$, and $g()$. Property 5.1 states that $hash(key, n_{1})$ and $hash(key, n_{2})$ map $key$ to the same integer $\alpha$ if $\alpha < n_{2} < n_{1}$. This property holds when the number of buckets changes from $n_{1}$ to $n_{2}$, and vice versa. 
In other words, key mapping does not change if $\alpha \in S_{2} \subset S_{1}$.  \\ \\
Similarly, in Property 5.2, $f(key, m_{1})$ and $f(key, m_{2})$ map $key$ to the same integer $\alpha$ if $\alpha < m_{2} < m_{1}$. Property 5.3 states that $g(key, n_{1}, s)$ and $g(key, n_{2}, s)$ map $key$ to the same integer $\alpha$ if $\alpha < n_{2} < n_{1}$. \\
\noindent
\ \\
\textbf{Property 5.1.} \enspace Suppose that for any $key$ and integer $n_{1}$,
\begin{alignat*}{2}
hash(key, n_{1})  &= \alpha,  \quad &&\alpha \in \{0,1, \ldots, n_{1}-1\}. \\[-1ex]
\intertext{Then} \\[-5ex]
hash(key, n_{2}) &= \alpha,  \quad &&\text{for all }n_{2} \text{ such that }  \alpha < n_{2} < n_{1}.
\end{alignat*}
\ \\
\noindent
\textbf{Property 5.2.} \enspace Suppose that for any $key$, and $m_{1}$ that is a power of 2,
\begin{alignat*}{2}
f(key, m_{1})  &= \alpha,  \quad &&\alpha \in \{0,1, \ldots, m_{1}-1\}.  \\[-1ex]
\intertext{Then}\\[-5ex]
f(key, m_{2})  &= \alpha, \quad &&\text{for all }m_{2} \text{ such that } \alpha < m_{2} < m_{1}, \text{ and}\\
&\phantom{= x} \quad && m_{2} \text{ is a power of 2}.
\end{alignat*}
\noindent 
\textbf{Property 5.3.} \enspace Suppose that for any $key$, and integers $n_{1}, s,$ where $s \geq 0$,
\begin{alignat*}{2}
g(key, n_{1},s)  &= \alpha,  \quad &&\alpha \in \{s,s+1, \ldots, n_{1}-1\}.  \\[-1ex]
\intertext{Then}\\[-5ex]
g(key, n_{2},s) &= \alpha, \quad &&\text{for all }n_{2} \text{ such that } \alpha < n_{2} < n_{1}.
\end{alignat*}


