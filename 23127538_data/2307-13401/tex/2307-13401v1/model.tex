\subsection{Task Model}
\label{sec:task}

% Figure environment removed

We consider a parallel real-time task modeled as a DAG $G = (V, E)$, where $V$ is the set of vertices and $E\subseteq  V \times V $ is the set of edges.
Each vertex $v\in V$ represents a piece of sequentially executed workload and has a WCET (worst-case execution time) $c(v)$.
An edge $(v_i, v_j)\in E$ represents the precedence constraint between $v_i$ and $v_j$, which means that $v_j$ can only start its execution after $v_i$ completes its execution.
A vertex with no incoming edges is called a \emph{source vertex} and a vertex with no outgoing edges is called a \emph{sink vertex}.
Without loss of generality, we assume that $G$ has exactly one source  (denoted as $v_{src}$) and one sink (denoted as $v_{snk}$).
If $G$ has multiple source or sink vertices, we add a dummy source or sink vertex with zero WCET to comply with the assumption.

A \emph{path} $\mypath$ is a set of vertices $(\pv_0, \cdots, \pv_k)$ such that $\forall i\in [0,k-1]$: $(\pv_i, \pv_{i+1})\in E$.
The length of a path is the total workload in this path and is defined as $len(\mypath) \coloneqq \sum_{\pv_i\in \mypath} c(\pv_i)$.
A \emph{complete path} is a path starting from the source vertex and ending at the sink vertex.
Formally, if a path $(\pv_0,\cdots,\pv_k)$ satisfies $\pv_0 = v_{src}$ and $\pv_k = v_{snk}$, then it is a complete path.
The \emph{longest path} is a complete path with the largest length among all paths in $G$.
The length of the longest path in $G$ is denoted as $len(G)$.
For a vertex set $V'\subseteq V$, we define $vol(V') \coloneqq \sum_{v\in V'}c(v)$.
The volume of $G$ is the total workload in $G$ and is defined as $vol(G) \coloneqq \sum_{v\in V} c(v)$.
If there is an edge $(u,v)$, we say that $u$ is a \emph{predecessor} of $v$, and $v$ is a \emph{successor} of $u$.
If there is a path starting from $u$ and ending at $v$, we say that $u$ is an \emph{ancestor} of $v$ and $v$ is a \emph{descendant} of $u$.
The sets of predecessors, successors, ancestors and descendants of $v$ are denoted as $pre(v)$, $suc(v)$, $anc(v)$ and $des(v)$, respectively.

A \emph{generalized path} $\chain=(\pv_0, \cdots, \pv_k)$ is a set of vertices such that $\forall i\in [0,k-1]$: $\pv_i$ is an ancestor of $\pv_{i+1}$. In particular, a vertex set containing only one vertex is a generalized path.
By definition, a path is a generalized path, but a generalized path is not necessarily a path.
Similar to paths, the length of a generalized path $\chain$ is defined as $len(\chain) \coloneqq \sum_{\pv_i\in \chain} c(\pv_i)$.


\begin{example}\label{exp:dag_example}
Fig. \ref{fig:dag_example} shows a DAG task $G$. The number inside vertices is the WCET of this vertex.
The source vertex and the sink vertex are $v_0$ and $v_5$, respectively.
For vertex set $V'=\{v_1, v_2\}$, $vol(V')=4$. The volume of the DAG task is $vol(G)=10$.
For vertex $v_4$, $pre(v_4)=\{v_1, v_2\}$, $suc(v_4)=\{v_5\}$, $anc(v_4)=\{v_0, v_1, v_2\}$, $des(v_4)=\{v_5\}$.
The longest path is $\mypath=(v_0, v_1, v_4, v_5)$, and $len(G) = len(\mypath)=6$.
$\chain=(v_0, v_2, v_5)$ is a generalized path. Note that by definition $\chain$ is not a path, because $(v_2, v_5)$ is not an edge in the DAG task.
\end{example}


\subsection{Scheduling Model}
\label{sec:schedule}
We consider that the DAG task $G$ executes on a computing platform with $m$ identical cores.
A vertex $v$ is said to be \emph{eligible} if all of its predecessors have completed their execution, thus $v$ can be immediately executed if there are available cores.
For a scheduling algorithm, the \emph{work-conserving} property means that an eligible vertex must be executed if there are available cores.
We do not restrict the scheduling algorithm, as long as it satisfies the work-conserving property.
Without loss of generality, we assume the source vertex of $G$ starts its execution at time $0$.
The \emph{response time} of $G$ is defined as the time when the sink vertex finishes its execution.
For example, a possible schedule of the DAG task $G$ in Fig. \ref{fig:dag_example} under a work-conserving scheduler is shown in Fig. \ref{fig:sequence1}. The response time of $G$ in this schedule is 7.

The problem model presented above assumes that the system contains only one DAG task.
Later in Section \ref{sec:extension}, we will extend our developed techniques to deal with systems consisting of multiple DAG tasks.




