This section uses two examples to provide the intuition that motivates this work.
The first example is relatively simple and illustrates the effect of adding edges.
The second example is more technical and explains the challenge of adding edges.

\subsection{The First Example}
\label{sec:motivation_first}

% Figure environment removed


This subsection uses an example from autonomous driving systems to illustrate the effect of adding edges.
The system has one front camera to monitor the road ahead and four LiDARs for proximity sensing.
There are two ECUs (electronic control unit) for processing the collected information.
Since deep neural networks, which are time-consuming, are usually utilized for processing the scenes captured by the camera, we suppose the execution time of the camera task is 4 and the execution time of each LiDAR task is 1.
This system can be modeled as a DAG task shown in Fig. \ref{fig:dag_intro1}. Note that by Section \ref{sec:task}, two dummy vertices with zero WCET are added to produce a DAG with single source and single sink.
For the DAG task in Fig. \ref{fig:dag_intro1}, a possible schedule is shown in Fig. \ref{fig:seq_intro1}, whose response time is 6.
If we add three edges among the four LiDAR tasks, which ensures that the four LiDAR tasks can only be executed sequentially, the schedule in Fig. \ref{fig:seq_intro1} will be impossible and Fig. \ref{fig:seq_intro2} shows a possible schedule.
In Fig.~\ref{fig:seq_intro2}, the response time is 4, better than that of Fig. \ref{fig:seq_intro1}.

In Fig. \ref{fig:seq_intro1}, it can be easily seen that the bottleneck that affects the response time is the longest path (i.e., the camera task with WCET of 4). And the four LiDAR tasks interfere with the execution of the camera task, which leads to a response time of 6.
However, in Fig. \ref{fig:seq_intro2}, by adding edges, the interference to the longest path is eliminated, which leads to a response time of 4.
This example clearly demonstrates how the worst-case interference is reduced and the worst-case response time is shortened by properly adding edges and constructing longer paths.
We remark that although adding edges is valid, removing edges is not, since edges in DAG tasks usually mean data dependencies or synchronization among vertices.


\subsection{The Second Example}
\label{sec:motivation_second}

The example in Section \ref{sec:motivation_first} demonstrates that strengthening precedence constraints by adding edges has the potential to reduce the response time of a DAG task.
However, to explore this potential to improve the worst-case response time guarantee of a DAG task, we need to solve two problems.
First, systematically designing methods of adding edges requires the guidance of related theories. 
Second, real-time scheduling requires theoretical guarantees concerning the response time of tasks.
To address these two challenges, we employ the state-of-the-art analysis technique in \cite{he2022bounding}, which utilizes the information of multiple long paths in the DAG task to shorten the response time bound.
Next, we briefly introduce this technique.

\begin{definition}[Generalized Path List]\label{def:chain_list}
A generalized path list is a set of disjoint generalized paths $(\chain_i)_0^k$ ($k \ge 0$), i.e.,
$$\forall i, j \in [0, k],\ \chain_i \cap \chain_j = \varnothing$$
\end{definition}
Here $(\chain_i)_0^k$ is the compact representation of $(\chain_0, \cdots, \chain_k)$.

\begin{theorem}[\cite{he2022bounding}]\label{thm:he_bound}
Given a generalized path list $(\chain_i)_0^k$ ($k \in [0, m-1]$) where $\chain_0$ is the longest path of $G$, the response time of DAG task $G$ scheduled by a work-conserving scheduler on $m$ cores is bounded by $R(G)$.
\begin{equation}\label{equ:he_bound}
R(G) \coloneqq \min \limits_{j \in [0, k]} \left\{ len(G)+\frac{vol(G)-\sum_{i=0}^{j} len(\chain_i)}{m-j} \right\}
\end{equation}
\end{theorem}

\begin{example}\label{exp:he_bound}
For the DAG $G$ in Fig. \ref{fig:dag_example}, we can identify a generalized path list $(\chain_i)_0^2$ where $\chain_0=(v_0, v_1, v_4, v_5)$, $\chain_1=(v_3)$, $\chain_2=(v_2)$.
Let the number of cores $m=2$. For this generalized path list, the bound in (\ref{thm:he_bound}) is
$R(G)=\min\{6+(10-6)/2, 6+(10-6-3)/(2-1)\}=\min\{8, 7\}=7$.
\end{example}

% Figure environment removed

Next, we use Fig. \ref{fig:motivation} to explain how adding edges can reduce the response time bound.
The DAG $G'$ in Fig. \ref{fig:dag_example2} is obtained by adding edge $(v_2, v_3)$ to the DAG task $G$ in Fig. \ref{fig:dag_example}.
After adding the edge, the schedule in Fig. \ref{fig:sequence1} becomes invalid and a new possible schedule is shown in Fig. \ref{fig:sequence2}.
In $G'$, we can find a generalized path list $\chain_0=(v_0, v_1, v_4, v_5)$, $\chain_1=(v_2, v_3)$.
And the bound in (\ref{thm:he_bound}) is computed as
$R(G')=\min\{6+(10-6)/2, 6+(10-6-4)/(2-1)\}=\min\{8, 6\}=6$,
which is smaller than $R(G)=7$ in Example \ref{exp:he_bound}.
It can be seen from the examples that there is a strong connection between the response time and the response time bound: for the DAG $G$ in Fig. \ref{fig:dag_example}, the response time is 7 and the bound is 7; after adding edges, for the DAG $G'$ in Fig. \ref{fig:dag_example2}, the response time is 6 and the bound is 6.

Note that adding edges in DAG tasks does not necessarily lead to a smaller response time or smaller response time bound.
We still take the DAG $G$ in Fig. \ref{fig:dag_example} to illustrate this. Let the number of cores $m=2$.
If we add an edge $(v_1, v_3)$, which transforms $G$ into another DAG $G''$, it can be easily seen that the response time of $G''$ can be 8.
In $G''$, we can find a generalized path list $\chain_0=(v_0, v_1, v_3, v_5)$, $\chain_1=(v_2, v_4)$.
And the bound in (\ref{thm:he_bound}) is computed as
$R(G'')=\min\{8+(10-8)/2, 8+(10-8-2)/(2-1)\}=\min\{9, 8\}=8$,
which is larger than $R(G)=7$ in Fig. \ref{fig:dag_example} and $R(G')=6$ in Fig. \ref{fig:dag_example2}.

Therefore, the policies for adding edges should be delicately developed.
In this paper, we carefully examine the dependencies between vertices in DAG tasks and design techniques of adding edges to reduce the response time bound, thus generally reducing the response time of DAG tasks.


