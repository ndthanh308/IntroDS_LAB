More and more real-time applications are parallelized to execute on multi-core processors for high performance and energy efficiency.
DAG (directed acyclic graph) is a widely used model to describe the structure constraints of parallel real-time tasks.
As an example, a processing chain from perception to control in the autonomous driving system can be modeled as a sporadic DAG task \cite{verucchi2020latency}.
There have been a large number of research works on real-time scheduling and analysis of DAG tasks in recent years \cite{ueter2018reservation, chen2019timing, han2019response, jiang2020real, ueter2021response, zhao2022dag, osborne2022minimizing, ueter2022parallel, bi2022response, lin2022type}, where a fundamental problem to solve is how to upper-bound the worst-case response time of a DAG task executing on a parallel processing platform.


The worst-case response time of a DAG task depends on its graph structure characteristics.
Intuitively, given the same total workload, a DAG task with looser precedence constraints among the vertices tends to have a shorter response time,
as its workload has a better chance to be executed in parallel and thus utilize computing resources better.
On the contrary, a DAG task with stricter precedence constraints tends to have a larger response time, as the workload has to be executed more sequentially. It seems that enforcing more precedence constraints on a DAG task is detrimental to its responsiveness.


However, this paper shows that actually we can improve (i.e., shorten) the worst-case response time of a DAG task by carefully enforcing extra precedence constraints, i.e., adding new edges to the original DAG\footnote{Note that adding new edges does not require changing the task itself. This can be achieved by, e.g., letting the scheduler be aware and enforce the corresponding precedence constraints when scheduling the vertices.}.
The key observation is that, by properly adding new edges and thus constructing some longer paths, we can reduce the worst-case interference to its critical path, which is the bottleneck for the DAG task to finish execution, and thus shorten the worst-case response time. The challenge is how to find the right edges to add so that the worst-case response time bound guaranteed by formal analysis is indeed improved.


In this paper, we develop techniques based on the above observation to improve the worst-case response time bound guaranteed by formal analysis.
More specifically, we identify the principles of adding edges by carefully examining the dependencies inside a DAG task and propose a simple but rather effective method to add edges based on the state-of-the-art worst-case response time analysis techniques in \cite{he2022bounding}.
As pointed out in \cite{zhao2022dag}, DAG tasks are to model the two major characteristics of parallel applications: \emph{parallelism} and \emph{dependency}.
The work in \cite{he2022bounding} utilizes long paths to explore the parallelism inside DAG tasks to improve system schedulability.
This paper is to explore the dependencies among vertices inside DAG tasks, further advancing the state-of-the-art.

We also propose a scheduling approach that applies the developed techniques to task systems consisting of multiple DAG tasks.
Experiments show that the proposed method significantly outperforms the state-of-the-art, reducing the worst-case response time bound by 21.6\% and improving the system schedulability by 22.2\% on average.

\begin{comment}
\textbf{Organization.}
%The rest of this paper is organized as follows.
Section~\ref{sec:model} defines the system model, including the task model and the scheduling model.
Section~\ref{sec:motivation} uses examples to explain the motivation of this work.
Section~\ref{sec:method} presents the method of adding edges to reduce the worst-case response time bound.
Section~\ref{sec:extension} proposes the scheduling approach for task sets consisting of multiple DAG tasks.
Section~\ref{sec:evaluation} reports the evaluation results for both scheduling one DAG task and scheduling a task set.
Section~\ref{sec:related} discusses related works and
Section~\ref{sec:conclusion} concludes the paper.
\end{comment}
