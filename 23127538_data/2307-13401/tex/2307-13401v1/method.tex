%\subsection{The First Approach: preserve the length of the longest path}
%\label{sec:preserve}

This section presents the method of adding edges to make long paths through examining the dependencies among vertices of the DAG task.
In the following, we first discuss the principles of adding edges, then present the algorithm of adding edges to reduce the response time bound of DAG task $G$.

\begin{definition}[Parallel Set] \label{def:parallel_set}
The parallel set of vertex $v$ is defined as
$para(v) \coloneqq \{u\in V \setminus \{v\}|u\notin anc(v) \land u\notin des(v) \}$.
\end{definition}
The parallel set of vertex $v$ contains vertices that can execute in parallel with $v$.
For example, in Fig. \ref{fig:dag_example}, $para(v_1)=\{v_2, v_3\}$.

Concerning adding edge $(u, v)$ for distinct vertices $u$, $v$ (i.e., $u \ne v$), if $u$ is an ancestor of $v$, since there is already precedence relation between $u$ and $v$, adding edge does not change the execution behavior of the DAG task. Therefore, if $u$ is an ancestor of $v$, there is no need for adding edge $(u, v)$. If $u$ is a descendant of $v$, adding edge $(u, v)$ leads to circles in the DAG, which violates the semantics of directed acyclic graph. Therefore, if $u$ is a descendant of $v$, we cannot add edge $(u, v)$. We summarize this into Principle \ref{prp:para}.

\begin{principle}\label{prp:para}
For distinct vertices $u$, $v$, if $u \in para(v)$, then edge $(u, v)$ can be added in the DAG task.
\end{principle}

Principle \ref{prp:para} specifies whether an edge can be added or not, but does not indicate whether an edge should be added or not. Recall that our target of adding edge is to reduce the response time bound in (\ref{thm:he_bound}). If the length of the longest path increases after adding edges, i.e., $len(G)$ becomes larger, we cannot guarantee that the response time bound in (\ref{thm:he_bound}) be reduced. We summarize this into Principle \ref{prp:longest}.

\begin{principle}\label{prp:longest}
For distinct vertices $u$, $v$, if the length of the longest path does not increase after adding edge $(u, v)$, then edge $(u, v)$ can be added in the DAG task.
\end{principle}
To realize Principle \ref{prp:longest} and make it easier to implement, we introduce the following concepts.

\begin{definition}[Left Length] \label{def:left}
In DAG $G$, the left length $l(v)$ of vertex $v$ is the maximum length of paths that start from $v_{src}$ and end at $v$.
\end{definition}
\begin{definition}[Right Length] \label{def:right}
In DAG $G$, the right length $r(v)$ of vertex $v$ is the maximum length of paths that start from $v$ and end at $v_{snk}$.
\end{definition}

The left length and right length of vertices in a DAG can be easily computed by using a simple dynamic programming with time complexity $O(|V|+|E|)$ \cite{he2019intra}.
For example, in Fig. \ref{fig:dag_example}, for vertex $v_4$, $l(v_4)=5$, $r(v_4)=2$.

\begin{lemma}\label{lem:longest}
In DAG $G$, for vertex $u$, $v$ and $u \in para(v)$, we add edge $(u, v)$ which transforms $G$ to $G'$. If in $G$, $l(u)+r(v) \le len(G)$, then $len(G')=len(G)$.
\end{lemma}
\begin{proof}
Let $\Pi$ and $\Pi'$ denote the set of complete paths in $G$ and $G'$, respectively. $\Pi'$ can be partitioned into two sets $\Pi'_1$, $\Pi'_2$ where $\Pi'_1$ is the set of complete paths that do not go through $(u, v)$, and $\Pi'_2$ is the set of complete paths that go through $(u, v)$. Obviously, $\Pi'_1= \Pi$, which means
\begin{equation}\label{equ:longest1}
\max_{\mypath \in \Pi'_1} \{len(\mypath)\} = \max_{\mypath \in \Pi} \{len(\mypath)\} = len(G)
\end{equation}
Since $l(u)+r(v) \le len(G)$, we have
\begin{equation}\label{equ:longest2}
\max_{\mypath \in \Pi'_2} \{len(\mypath)\} \le len(G)
\end{equation}
Combining (\ref{equ:longest1}) and (\ref{equ:longest2}), we reach the conclusion.
\end{proof}

Lemma \ref{lem:longest} will be used to implement Principle \ref{prp:longest} in Algorithm \ref{alg:first}.
Principle \ref{prp:longest} is to ensure that the response time bound in (\ref{thm:he_bound}) does not become larger. However, we want the response time bound to become smaller. Next, we introduce Principle \ref{prp:effective}.

\begin{definition}[Residue Graph \cite{he2022bounding}]\label{def:residue_graph}
Given a generalized path $\chain$ of DAG $G = (V, E)$, the residue graph $G_r = res(G, \chain)= (V, E)$ is defined as:
\begin{itemize}
  \item if $v \in \chain$, the WCET of $v$ in $G_r$ is $0$;
  \item if $v \in V \setminus \chain$, the WCET of $v$ in $G_r$ is $c(v)$.
\end{itemize}
\end{definition}

Note that different generalized paths in a generalized path list are disjoint. The residue graph is introduced to ensure that newly computed generalized paths have no common vertices with already computed generalized paths while maintaining the topology of the DAG task.
A residue graph is still a DAG.

\begin{principle}\label{prp:effective}
For distinct vertices $u$, $v$, if a longer generalized path can be identified in the residue graph after adding edge $(u, v)$, then edge $(u, v)$ can be added in the DAG task.
\end{principle}

Next, we introduce some concepts to realize Principle \ref{prp:effective}.
For a vertex $v$, the \emph{effective left length} $el(v)$ is the left length of $v$ in a residue graph $G_r$,
and the \emph{effective right length} $er(v)$ is the right length of $v$ in a residue graph $G_r$.

\begin{example}\label{exp:effective}
For the DAG $G$ in Fig. \ref{fig:dag_example} and a generalized path $\chain = (v_0, v_3, v_5)$, the residue graph $G_r= res(G, \chain)$ where the WCETs of $v_0$, $v_3$, $v_5$ are set to zero; edges and other vertices are unchanged.
In $G_r$, for vertex $v_4$, $el(v_4)=4$, $er(v_4)=1$.
\end{example}

\begin{lemma}\label{lem:effective}
In residue graph $G_r$, for vertex $u$, $v$ and $u \in para(v)$, we add edge $(u, v)$ which transforms $G_r$ to $G'_r$. If in $G_r$, $el(u)+er(v) > len(G_r)$, then $len(G'_r)>len(G_r)$.
\end{lemma}
\begin{proof}
In $G_r$, let the path that starts from $v_{src}$ and ends at $u$ and whose length reaches $el(u)$ be $\mypath_1$. Let the path that starts from $v$ and ends at $v_{snk}$ and whose length reaches $er(v)$ be $\mypath_2$. Since edge $(u, v)$ is in $G'_r$, we have $\mypath \coloneqq \mypath_1 \cup \mypath_2$ is a path in $G'_r$ and $len(\mypath)=el(u)+er(v) > len(G_r)$.
Therefore, $len(G'_r)>len(G_r)$.
\end{proof}

Lemma \ref{lem:effective} will be used to implement Principle \ref{prp:effective} in Algorithm \ref{alg:first}.
With these three principles, we present our method of adding edges in Algorithm \ref{alg:framework} and Algorithm \ref{alg:first}.


\begin{algorithm}[t]
    \caption{The Method Framework}\label{alg:framework}
    \DontPrintSemicolon
    \Input{DAG task $G = (V, E)$}
    \Output{DAG task $G$ with added edges}
     $G_r \leftarrow G$; $i \leftarrow 0$ \\
     \While{$vol(G_r) \neq 0$}{
        $\chain_i \leftarrow$ the longest path of $G_r$ \\
        \If{$AddEdge(\chain_i)$}{
            \Continue
        }
        $\chain_i \leftarrow \chain_i \setminus \{v \in \chain_i| c(v)\ \mathrm{of}\ G_r\ \mathrm{is}\ 0 \}$ \\
        $G_r \leftarrow res(G_r, \chain_i)$; $i \leftarrow i+1$ \\
     }
\end{algorithm}

\begin{algorithm}[t]
    \caption{$AddEdge(\chain)$}\label{alg:first}
    \DontPrintSemicolon
    \Input{a generalized path $\chain$}
    \Output{\emph{true}: add an edge; \emph{false}: not add an edge}
    \ForEach{$v \in \chain$}{
        \ForEach(\tcp*[f]{Principle \ref{prp:para}}){$u \in para(v)$}{
            \If(\tcp*[f]{Principle \ref{prp:longest}}){$l(u)+r(v) \le len(G)$}{
                \If(\tcp*[f]{Principle \ref{prp:effective}}){$el(u)+el(v) > len(G_r)$}{
                    add edge $(u, v)$ in $G$ and $G_r$ \\
                    \Return{true}
                }
            }
        }
    }
    \Return{false}
\end{algorithm}

Algorithm \ref{alg:framework} follows the same guideline as in Algorithm 2 of \cite{he2022bounding}: it computes the longest generalized path in the residue graph one by one (Line 3), and sets the WCETs of vertices in these generalized paths to zero to avoid joint vertices among different generalized paths (Line 7, 8) until the volume of the residue graph is zero (Line 2).
Whenever a longest generalized path is computed in Line 3, the \emph{AddEdge} procedure is called regarding this generalized path (Line 4). If an edge is successfully added, the topology of the DAG task changes and the longest generalized path should be recomputed (Line 3).

The \emph{AddEdge} procedure (Algorithm \ref{alg:first}) performs the task of adding edge and realizes the three proposed principles. It takes a generalized path $\chain$ as the input. For each vertex $v$ in this generalized path (Line 1), for each vertex $u$ in the parallel set of $v$ (Line 2, this line corresponds to Principle \ref{prp:para}), we check whether edge $(u, v)$ can be added or not. We first check whether it conforms to Principle \ref{prp:longest} using Lemma \ref{lem:longest} (Line 3), second check Principle \ref{prp:effective} using Lemma \ref{lem:effective} (Line 4). If edge $(u, v)$ passes these checks, we add this edge in the DAG task (Line 5).
If we cannot make generalized path $\chain$ longer by adding edges, which means that it is a ``good'' generalized path to compute the response time bound for the DAG task, we indicate that there is no need to add edges and return \emph{false} (Line 11).

%Note that during the execution of the algorithms, since we add edges in procedure \emph{AddEdge}, the topologies of $G$ and $G_r$ may change during iterations. All the computations (such as Line 3 of Algorithm \ref{alg:framework} and Line 4, 5 of Algorithm \ref{alg:first}) are conducted in the updated graph.

\textbf{Complexity.}
There are two loops in Algorithm \ref{alg:first} and each of them can run at most $|V|$ times. Therefore, the time complexity of Algorithm \ref{alg:first} is $O(|V|^2)$.
For Algorithm \ref{alg:framework}, there are two independent loops: the loop in Line 2-5 and the loop in Line 2-9.
For each iteration of the first loop, an edge is added. Since a DAG can have at most $|V|^2$ edges, the first loop can run no more than $|V|^2$ times.
For each iteration of the second loop, a generalized path is identified, which includes at least one vertex. The second loop can run no more than $|V|$ times.
Together with the $O(|V|^2)$ of Algorithm \ref{alg:first}, the time complexity of Algorithm \ref{alg:framework} is $O(|V|^4)$.

For the original DAG task $G$, after Algorithm \ref{alg:framework}, a DAG with added edges (denoted as $G'$) is computed.
Also, in Algorithm \ref{alg:framework}, during each iteration, a generalized path $\chain_i$ is computed in Line 7. These generalized paths form a generalized path list $(\chain_i)_0^k$, which can be used to compute the response time bound for DAG $G'$ using (\ref{equ:he_bound}).
Note that in Theorem \ref{thm:he_bound}, the sole requirement that a generalized path list can be used to compute the bound in (\ref{equ:he_bound}) is that the first generalized path is the longest path of the DAG task.

\begin{theorem}\label{thm:domination}
The method in Algorithm \ref{alg:framework} and Algorithm \ref{alg:first} dominates the method in \cite{he2022bounding}, i.e.,
\begin{equation}\label{equ:domination}
R(G') \le R(G)
\end{equation}
\end{theorem}
\begin{proof}
We prove it by examining the items of (\ref{equ:he_bound}).
Since the WCETs of vertices in $G'$ and $G$ are the same, $vol(G')=vol(G)$.
Although we add edges in $G'$, by Lemma \ref{lem:longest}, $len(G')=len(G)$.
For a generalized path list $(\chain_i)_0^k$ of $G$ to compute $R(G)$, since $\chain_0$ is the longest path of $G$ and $len(G')=len(G)$, $\chain_0$ is also the longest path of $G'$, which means that $(\chain_i)_0^k$ can also be used to compute $R(G')$.
Therefore, $R(G')$ cannot be larger than $R(G)$.
What's more, by Lemma \ref{lem:effective}, after adding an edge, it is ensured that there is a longer generalized path in the residue graph (see Line 4 of Algorithm \ref{alg:first}).
In summary, the conclusion is reached.
\end{proof}

\begin{example}\label{exp:perserve}
Let the number of cores $m=2$.
For the DAG task $G$ in Fig. \ref{fig:dag_example}, the computed bound is 7. After Algorithm \ref{alg:framework} and Algorithm \ref{alg:first}, $G$ is transformed into $G'$ shown in Fig. \ref{fig:dag_example2}. The computed bound is 6, less than 7. This example is explained in Section \ref{sec:motivation_second}.
\end{example}





