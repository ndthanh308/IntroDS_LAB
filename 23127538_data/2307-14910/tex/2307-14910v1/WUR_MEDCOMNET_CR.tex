\documentclass[conference,a4paper]{IEEEtran}
\usepackage{amssymb}
\usepackage{color}
\usepackage{graphicx}
%\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{cite}
\usepackage{pgfplots}
\usepackage{comment}
\usepackage{multirow}
\usepackage{mathbbol}
\usepackage{caption}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{subfig}
\usepackage{flushend}

%\usepackage[linesnumbered,lined, algoruled]{algorithm2e}


%%%%%%%%%%%%%%%%%% AZ STD COMMAND %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\def\C#1{\mathcal{#1}}
% IMAGE OPTIONS

\pgfplotsset{compat=newest}

\pgfplotsset{mystyle/.style={%
        width=6cm,
        xmin=0,xmax=0.5,
        xtick={0,10,...,50}}}

% OPERATORS
\newcommand{\floor}[1]{{\left\lfloor #1\right\rfloor}}
\newcommand{\ceil}[1]{{\left\lceil #1\right\rceil}}
\newcommand{\round}[1]{{\left\lceil #1\right\rfloor}}
\newcommand{\E}[1]{\mathop{\mathbb E}\nolimits\left[#1\right]} % Expectation
\newcommand{\pr}[1]{\Pr\left[ #1 \right]}
\renewcommand{\P}[1]{\mathrm{P}\left[ #1 \right]}

\newcommand{\mmin}[1]{{\min\left\{#1\right\}}}
\newcommand{\mmax}[1]{{\max\left\{#1\right\}}}
\newcommand{\argmax}[1]{\underset{#1}{\operatorname{arg}\,\operatorname{max}}\;}
\newcommand{\argmin}[1]{\underset{#1}{\operatorname{arg}\,\operatorname{min}}\;}
\newcommand{\id}[1]{\mathbf{1}\(#1\)} % Unit function  
\newcommand{\Heav}[1]{H\left(#1\right)} % Heaviside function
\newcommand{\eps}{\varepsilon}
\newcommand{\rect}[1]{\mathrm{rect}\!\left(#1\right)}
\newcommand{\sinc}[1]{\mathrm{sinc}\!\left(#1\right)}
\newcommand{\bin}[2]{{\left(\begin{array}{c}#1\\#2\end{array}\right)}}

\newcommand{\me}[2]{\left[ {#1} \right]_{(#2)}} % Submatrix \me{P}{i,j} produces [P]_{i,j} and denotes the element in the i-th row and j-th column of P
\newcommand{\vv}[1]{\left[ {#1} \right]} % Submatrix \vv{a,b,c} produces [a,b,c]

\newcommand{\Set}[1]{{\C #1}} 
\newcommand{\Setd}[2]{\Set{#1}=\left\{#2\right\}}  % Set definition: \Set{S}{0,1,2} produces S={01,2,} where S is in mathcal 

\newcommand{\mat}[1]{{\hbox{\textbf{#1}}}}
\newcommand{\ei}[1]{{\mat{e}_{#1}}}   % all zero vector except in the $#1$-th element which is one
\newcommand{\ind}[1]{\mathbf{\chi}\left\{#1\right\}} % Indicator function \ind{A}=1 if A is true, \ind{A}=0 otherwise. 

% FORMATTING
\newcommand{\ie}{i.e.,\,}
\newcommand{\eg}{e.g.,\,}
\newcommand{\columnbreak}{\vfill\eject} % Column break

% REFERENCES
\newcommand{\figuresname}[1]{Figs.~}
\newcommand{\eq}[1]{(\ref{#1})}
\newcommand{\Tab}[1]{Tab.~\ref{#1}}
\newcommand{\Sec}[1]{Sec.~\ref{#1}}

% COMMENTS/REVISIONS
\newcommand{\AZ}[1]{\textit{\color{magenta}AZ says: #1}}   
\newcommand{\AD}[1]{\textit{\color{blue}AD: #1}}
\newcommand{\FC}[1]{\textit{\color{red}AD: #1}}
%\newcommand{\mod}[1]{\textit{\color{blue}#1}}  
\newcommand{\NVB}{\textcolor{blue}{$\Rightarrow$}\begin{rm} \color{blue}}   
\newcommand{\NVE}{\end{rm}\textcolor{blue}{$\Leftarrow$}}   
\newcommand{\ASK}[1]{\textit{\color{red}???~#1~???}}   
\newcommand{\TBE}[1]{{\color{red} \sout{#1}}}
\newif\ifcutshort
\cutshortfalse
\newcommand{\CS}[1]{\ifcutshort \else #1 \fi}   % cutshort
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\quotes}[1]{``#1''}

%%%%%%%%%%% specific shortcuts for this paper 
\newcommand{\dr}{\rho}
\newcommand{\Ld}{\ell_d}

%%% equations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\e}[1]{%
	\ifmmode\refstepcounter{equation}%
	  \eqno\mbox{\rm(\theequation)}\label{e:#1}%
	\else(\ref{e:#1})\fi}

%%% eqalign %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\catcode`@=11
\newdimen\jot \jot=3pt
\def\openup{\afterassignment\@penup\dimen@=}
\def\@penup{\advance\lineskip\dimen@
  \advance\baselineskip\dimen@
  \advance\lineskiplimit\dimen@}
\def\eqalign#1{\null\,\vcenter{\openup\jot\m@th
  \ialign{\strut\hfil$\displaystyle{##}$&$\displaystyle{{}##}$\hfil
      \crcr#1\crcr}}\,}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{assumption}{Assumption}
\newtheorem{algo}{Algorithm}
\graphicspath{{./figure/}}


% ACRONYMS
 \usepackage[acronym]{glossaries}
 \newacronym{tdma}{TDMA}{Time Division Multiple Access}
\newacronym{ack}{ACK}{Acknowledgment}
\newacronym{dc}{DC}{Duty Cycle}
\newacronym{dr}{DR}{Data Rate}
\newacronym{dl}{DL}{downlink}
\newacronym{cca}{CCA}{Clear Channel Assessment}
\newacronym{dcw}{DCW-MAC}{Duty-Cycled Medium Access Scheme for Low-Power WUR}
\newacronym{awd}{AWD-MAC}{Asynchronous Wake-up on Demand MAC}
\newacronym{lecim}{LECIM}{Low-energy Critical Infrastructure Monitoring}
\newacronym{scm}{SCM-WUR}{Sub-Carrier Modulation Wake-up Radio Protocol}
\newacronym{opwum}{OPWUM}{Opportunistic Wake-Up MAC Protocol}
\newacronym{ed}{ED}{End Device}
\newacronym{en}{EN}{End Node}
\newacronym{rtt}{RTT}{Round Trip Time}
\newacronym{gw}{GW}{Gateway}
\newacronym{iot}{IoT}{Internet of Things}
\newacronym{ism}{ISM}{Industrial, Scientific, and Medical}
\newacronym[plural=LPWANs,firstplural=Low Power Wide Area Networks (LPWANs)]{lpwan}{LPWAN}{Low Power Wide Area Network}
\newacronym{mcs}{MCS}{Modulation and Coding Scheme}
\newacronym{mac}{MAC}{Medium Access Control}
\newacronym{pcr}{PCR}{Primary Communication Radio}
\newacronym{phy}{PHY}{Physical}
\newacronym{pmf}{PMF}{Probability Mass Function}
\newacronym{aoi}{AoI}{Age of Information}
\newacronym{qos}{QoS}{Quality of Service}
\newacronym{wsn}{WSN}{Wireless Sensor Network}
\newacronym{ul}{UL}{uplink}
\newacronym{wur}{WUR}{Wake-Up Radio}

\def \fwidth{0.95\columnwidth}
\def \fheight {0.6\columnwidth}

\definecolor{color1}{HTML}{FFB14E}
\definecolor{color2}{HTML}{FA8775}
\definecolor{color3}{HTML}{EA5F94}
\definecolor{color4}{HTML}{CD34B5}
\definecolor{color5}{HTML}{9D02D7}
\definecolor{color6}{HTML}{0000FF}

\begin{document}

\title{Low-Latency Massive Access with Multicast Wake Up Radio}

\author{\IEEEauthorblockN{Andrea Zanella, Anay Ajit Deshpande, Federico Chiariotti}
\IEEEauthorblockA{Department of Information Engineering, University of Padova\\
Via G. Gradenigo 6/B, Padova, Italy\\
Email: \texttt{\{zanella,deshpande,chiariot\}@dei.unipd.it}}}



\maketitle

%\address{Department of Information Engineering, University of Padova, Via G. Gradenigo 6/B, 35131 Padova, Italy.}

\begin{abstract}
The use of \gls{wur} in \gls{iot} networks can significantly improve their energy efficiency: battery-powered sensors can remain in a low-power (sleep) mode while listening for wake-up messages using their \gls{wur} and reactivate only when polled, saving energy. However, polling-based \gls{tdma} may significantly increase data transmission delay if packets are generated sporadically, as nodes with no information still need to be polled. In this paper, we examine the effect of multicast polling for \gls{wur}-enable wireless nodes. The idea is to assign nodes to multicast groups so that all nodes in the same group can be solicited by a multicast polling message. This may cause collisions, which can be solved by requesting retransmissions from the involved nodes. We analyze the performance of different multicast polling and retransmission strategies, showing that the optimal approach can significantly reduce the delay over \gls{tdma} and ALOHA in low-traffic scenarios while keeping good energy efficiency.
\end{abstract}

\begin{IEEEkeywords}
Wake Up Radio, Multicast Polling, Latency, Energy Efficiency
\end{IEEEkeywords}

%% main text
\section{Introduction}
\glsresetall

The explosion of the \gls{iot} has led to new developments in remote monitoring applications~\cite{wang2021evolution}, which use distributed sensors to track, e.g., environmental conditions in remote and/or wide areas \cite{zanella2023iot}, as well as manufacturing plants and cities. Since the inception of the \gls{iot}, however, energy has been a major issue for system design~\cite{georgiou2017iot}: battery-powered nodes face significant constraints in terms of computational and communication capabilities, and often resort to uncoordinated random access schemes like ALOHA to avoid signaling overhead.

However, the limits of random access schemes are well-known \cite{8030484}: unless the traffic is extremely light, these schemes suffer from packet collisions and congestion~\cite{yu2020stabilizing}, and may not allow the \gls{gw} to request new data from a specific sensor. In contrast, polling schemes avoid collisions, but can result in significant energy consumption for nodes that must constantly listen for request messages, without constraining scheduling to a fixed duty cycle. \cite{levy1990polling}. 

One possible solution to this problem is provided by \gls{wur} technology, standardized by the IEEE as part of the 802.11 group~\cite{deng2020ieee}: an extremely low-power radio, only capable of receiving simple signals and performing basic calculations, which can be kept continuously active in listening mode, while the sensor's main processor and \gls{pcr} are only turned on when needed. Typically, the \gls{wur} is used to reduce the downlink response time of a node whose \gls{pcr} is in sleep mode to save energy\cite{tang2017energy}, potentially reducing both latency and energy consumption.

However, polling one sensor at a time can still cause significant delays between the moment a measurement is generated and when it is received by the \gls{gw}~\cite{rostami2019wake}. As the latter does not know when sensors have new measurements, it can employ smart strategies based on data importance or \gls{aoi}~\cite{chiariotti2022scheduling}, but it will still waste a significant amount of time polling sensors with no data to transmit if the average traffic is low. This problem is well-known, and shared with traditional \gls{tdma}, as even advanced scheduling schemes cannot know in advance whether a specific sensor has a new packet~\cite{shiraishi2022query}.

In this work, we propose a solution that, by exploiting the standard \gls{wur} features, can combine the desirable properties of polling and random access schemes: instead of polling sensors one at a time, the \gls{gw} sends multicast polling messages to groups of sensors, resolving possible collisions only if and when they occur. The protocol includes two components: first, the nodes-grouping strategy, which is optimized to limit the collision probability while still exploiting the channel as effectively as possible, and second, the collision resolution mechanism. The latter is crucial to avoid the instability of ALOHA: if resolving a collision takes too long, the other sensors may accumulate a backlog, increasing the probability of further collisions and forcing the \gls{gw} to poll smaller groups or risk making the system unstable.

The stability of the proposed protocol and its performance in terms of average delay and energy efficiency are analyzed via Monte Carlo simulation, which shows that multicast polling can outperform both ALOHA and \gls{tdma} in light traffic conditions, at the cost of slightly lower energy efficiency. In particular, the proposed method can reduce the delay by 90\% in a network of 100 nodes, and by 99\% in a massive access scenario with 1000 sensors, with respect to both ALOHA and unicast \gls{wur} polling. At the same time, the energy consumption for the sensors is higher, but never more than twice that of \gls{tdma}, which is the most energy-conservative scheme among the ones we analyzed.

The rest of this paper is organized as follows: Sec.~\ref{sec:related} presents a review of the literature on \gls{wur}-based \gls{mac} schemes, highlighting their advantages and limitations. We then present the basic system model and our multicast polling protocol in Sec.~\ref{sec:system}, and provide some analytical results on its performance in Sec.~\ref{sec:analysis}. Full results in a more realistic setting are provided and discussed in Sec.~\ref{sec:results}. Sec.~\ref{sec:conc} concludes the paper and presents some possible avenues of future work on the subject.



\section{Related Work}\label{sec:related}
\gls{mac} protocols for \glspl{wsn} have been investigated quite thoroughly in the literature, and hundreds of schemes and variations have been proposed over the decades. However, classic protocols such as ALOHA are still used in a dominant share of \glspl{wsn} due to their simplicity and low overhead. 

Another common design philosophy involves the use of polling schemes where the \gls{gw} grants dedicated channel access to one node at a time.  This reduces complexity and avoids interference, but requires the nodes to constantly listen for polling messages, thus increasing energy consumption~\cite{feeney2001investigating}. \gls{wur} can alleviate this problem, being explicitly designed to consume very little power in the listening state. For this reason, several \gls{wur}-based \gls{mac} protocols have been recently proposed\cite{mahlknecht2009wur}. 

\subsection{The IEEE 802.11ba Standard}
The IEEE 802.11ba is a proposed extension to legacy IEEE 802.11 standard~\cite{bankov2019ieee} with the purpose of enhancing power efficiency in battery-powered \gls{iot} nodes. The IEEE802.11ba standard is primarily focused on the inclusion of a low-power \gls{wur}, which is used to listen for polling signals and activate the \gls{pcr}. The standard defines the physical and \gls{mac} parameters for communication with the \gls{wur}, as well as the wake-up procedure for the \gls{pcr} when a \gls{wur} signal is received from the \gls{gw}. It also includes the power management scheme to be implemented, the \gls{dc} specification for the \gls{wur}, and a synchronization scheme using \gls{wur} beacons. Finally, the crucial component for the mechanism proposed in this paper is the channelization of wake-up frames to be sent to \gls{wur}. The standard explains the usage of group cast wake-up messages to be sent to multiple nodes, waking up their \glspl{pcr} simultaneously. However, it does not mention the size or the periodicity of the messages to be sent out. This provides the basis for the design of our mechanism.

% Figure environment removed

\subsection{WUR MAC Protocols}

\gls{wur}-based polling protocols have been a topic of research even before the advent of IEEE 802.11ba. Polling protocols that have been proposed so far use \gls{wur} as a listening device for \gls{cca} or act as a trigger to switch on the \gls{pcr}. In \gls{dcw}~\cite{mazloum2011dcw}, the \gls{wur} receiver is periodically turned on by the node to listen to a wake-up message in order to activate the main radio for data transmission. Due to the reduced listening time of \gls{wur}, the scheme consumes extremely little power but may experience a significant delay in case the wake-up message transmission has to be repeated until it coincides with a \gls{wur} listening period. In \gls{awd}~\cite{le2015asynchronous}, the node sends out a broadcast beacon using its \gls{wur} to advertise that it is ready to receive. Upon receiving the beacon, the transmitter turns on its \gls{pcr} and transmits an ACK message. Once the receiver gets the ACK message on its \gls{wur}, it turns on its \gls{pcr} for data transmission. In~\cite{ullah2012energy}, a \gls{mac} protocol is introduced for \gls{lecim}. The protocol works on slotted ALOHA with the use of \gls{wur}. For uplink communication, the \gls{en} activates its \gls{wur} and listens to the channel for beacon frames to synchronize with the \gls{gw}. Once it receives the beacon packet, it synchronizes with the superframe of slotted ALOHA and transmits over a randomly chosen slot. If the transmission is successful, the node goes to sleep mode, otherwise, it transmits over another random slot. \gls{opwum} \cite{ait2016opwum} is a multi-hop protocol that uses the \gls{wur} to broadcast a relay request to all the neighbors of a node with packets to transmit. The nodes reply with \glspl{cca} acknowledgment, still using the \gls{wur}. Based on the shortest backoff timer from the clear channel messages, the original transmitter then chooses the next relay node among its neighbors. In \gls{scm}\cite{oller2015has}, the transmitter broadcasts a wake-up message to all nodes in  its coverage range containing a unique identifier of the intended receiver, which is the only one that activates its \gls{pcr} and listens to the channel for successive data transmissions. After the data exchange, both transmitter and receiver switch off their \glspl{pcr}, but keep listening to the channel using their \glspl{wur}.

The protocols proposed so far, especially for the use of \gls{wur} in uplink communication, employ either additional mechanisms such as \gls{cca} to determine whether the channel is free to transmit or employ ALOHA-based schemes, with a higher chance of collisions. Both these families of schemes have longer delays and consume more energy than \gls{tdma} in heavy traffic conditions because of channel sensing or retransmissions. However, \gls{tdma} may waste a lot of time in polling nodes with no new data when the traffic over the network is light. In order to overcome this problem, we propose a centralized multicast polling scheme, which not only takes into account the nodes that are most likely to have data to transmit, but also the time duration between the polls to each node. This system helps in reducing the delay considerably while maintaining a limited collision probability.

\section{System Model and Protocol Definition}\label{sec:system}
In this section, we first investigate a basic polling mechanism using \gls{wur} and then propose an extension to implement the group polling introduced in the previous section. 
Let us consider a \gls{wsn} with a single \gls{gw} serving $N$ sensors. Each sensor $n$ generates new updates according to an independent Poisson process with rate $\lambda_n$. We will say that a node is \quotes{activated} when it has a packet to transmit. We assume a pure collision channel model, i.e., if any part of a transmission collides with another, both packets are lost. For simplicity's sake, we also assume the wake-up time for the \gls{pcr} to be constant, and that wake-up messages are never lost. In addition, we assume the \gls{pcr} transmits a fixed data rate, and packets have constant size. Although these assumptions can be trivially relaxed with minimal impact on the system performance, this would make the model more cumbersome to define and analyze. 

In the traditional round-robin polling scheme, the \gls{gw} is tasked with polling every single sensor in the network in a predetermined and fixed order. If the solicited sensor has any new data, it turns on its \gls{pcr} and transmits a packet otherwise it remains silent. If the \gls{gw} receives the reply packet, it will immediately send an ACK and then proceed with the polling cycle. Otherwise, if the polled node does not send any packet, the \gls{gw} will resume the polling just after a pre-defined time interval, which depends on the maximum \gls{rtt} of the \gls{wsn}, that is much shorter than a packet transmission time. \figurename~\ref{fig:poll} shows a simple schematic of the protocol. More advanced schemes, which reduce the guard interval depending on the distance between sensor and \gls{gw} are also possible, but the basic structure of the protocol will remain the same. This polling scheme follows the IEEE 802.11ba standard, with in-band \gls{wur} wake-up signals.

\subsection{Polling slot duration}
We define as polling slot the time interval between two consecutive polling packets of the \gls{gw}. The duration of a polling slot then depends on the amount of data that the polled node needs to return to the \gls{gw}. Let $\tau_0$ denote the maximum signal propagation time from the \gls{gw} to the furthest node and return. In case of no data to be transmitted (in which case, we say the slot is \textit{idle}) the duration is $\tau_0+t_{\text{wu}}$, where $t_{\text{wu}}$ is the duration of a wake-up signal~\cite{hwang2018wake}. Instead, if the sensor has generated $k$ new packets since the last update, the polling slot duration becomes $kt_p+t_{\text{wu}}+\tau_0 $ where $t_p$ is the transmission time for a single packet. Therefore, for any $k\in\mathbb{N}$, the \gls{pmf} of the slot duration $t_n$, when sensor $n$ is polled, is  given by
\begin{equation}
   p_{t_n}(kt_p+t_{\text{wu}}+\tau_0)=\frac{(\lambda_n\tau_n)^{k}e^{-\lambda_n\tau_n}}{k!}, 
\end{equation}
and zero otherwise, where $\tau_n$ is the duration of the polling cycle for the $n$ sensor, i.e., the total time between two polling slots of that node.  

\subsection{Multicast polling scheme}
The energy efficiency of the \gls{wur} unicast polling scheme is significantly higher than for standard \gls{tdma} or legacy polling through the \gls{pcr}, as the nodes do not need to be synchronized or stay awake all the time. However, the delay of such a scheme is high, as all nodes need to be polled and new data is often queued for a relatively long time, even if the traffic is very low. This problem is an open issue in the 802.11ba standard.
The legacy alternative, i.e., a simple ALOHA scheme, is energy efficient, as sensors only wake up when they have data, but the reliable transmission requirement makes it problematic even at very low traffic loads: any collision causes retransmission after a random back-off time, increasing the delay and energy consumption, and the well-known theoretical load limit of ALOHA is below 20\%.

In order to overcome this trade-off, we propose a multicast polling scheme: instead of polling a single node at a time, the \gls{gw} polls multiple sensors. If more than one polled node has data to transmit, the packets collide, and the \gls{gw} uses a collision resolution scheme to poll the nodes separately. Naturally, the larger the group, and the higher the traffic load within the group, the higher the probability of collision, making the selection of the group size and collision resolution scheme critical for performance. Collisions affect both delay and energy consumption, as resolving a collision takes time, and each transmission, whether successful or collided, requires the same amount of energy.

If we consider the selection of a group $\C{G}$ of $G=|\C{G}|$ sensors, the transmission is successful if and only if exactly one sensor has new data to transmit. If we denote $\tau_n$ as the time since the end of the last polling slot for sensor $n$, we can easily compute the probability of exactly one node transmitting, i.e., the success probability for group $\C{G}$ as
\begin{equation}
    p_s(\C{G})=\sum_{i\in\C{G}}\left(1-e^{-\lambda_i\tau_i}\right)\exp\left(-\sum_{j\in\C{G}\setminus\{i\}}\lambda_j\tau_j\right).
\end{equation}
where the first term in the summation gives the probability that node $i$ has collected at least one packet since the last transmission, while the rightmost term is the joint probability that all the other nodes in the same group have no backlog. The probability that the slot will be idle is given by
\begin{equation}
    p_{\text{idle}}(\C{G})=\exp\left(-\sum_{i\in\C{G}}\lambda_i\tau_i\right);
\end{equation}
and the collision probability is then
\begin{equation}
p_c(\C{G})=1-p_{\text{idle}}(\C{G})-p_s(\C{G}).\label{eq:coll}
\end{equation}

\subsection{Nodes grouping}
Naturally, if $G=1$, $p_c(\C{G})=0$. However, in the general case, the success and collision probabilities depend not only on the group size but on its composition as well: finding the group with the highest success probability is a combinatorial problem similar to the well-known knapsack problem.

% Figure environment removed

We assume that the \gls{gw} knows the packet generation rate of all the sensors. Since it also knows $\tau_n$ for each sensor in the network, it can compute the collision probability for any set $\C{G}$. We then propose a simple constructive heuristic for node selection, which considers a maximum target collision probability $p_{\text{thr}}$: first, we sort the nodes in decreasing order of their probability of having packets to be transmitted. The node with the highest probability is the first to be inserted into the polling group. Then, we progressively add other nodes with the \textit{lowest} probability of having packets to be transmitted until the collision probability computed using~\eqref{eq:coll} reaches the prefixed target (or all nodes are in the group). The rationale is to group together one node with high transmission chances and a bunch of nodes with small transmission probabilities, so as to decrease the risk of idle polling, while also limiting the size of colliding nodes in case of multiple transmissions. Once the group has been polled, the procedure is repeated anew to form the next group. 

Higher values of the target threshold will lead to larger groups, with a lower probability of the slot remaining idle; however, an increased collision probability will also cause further delays. Although group-based polling is more robust than ALOHA, our results will show that increasing the load on the network will lead the algorithm to fall back on unicast polling, as the added delay may cause the system to become unstable.

\subsection{Collision resolution}
When collisions do happen, however, we have two choices to ensure full reliability. The first and simplest is to perform a linear search, polling all sensors in the group one by one. However, this requires a relatively long time, particularly if the group is large, and new packets may arrive in the meantime. If we denote the time required to complete the collision resolution process as $T_c(\C{G})$, we have
\begin{equation}
    T_c(\C{G})\geq G\left(\tau_0+t_{\text{wu}}\right)+2t_p,
\end{equation}
where the right-hand side of the inequality represents the minimum possible value obtained when only two packets collide, and no other packets arrive during the collision resolution process. This process is long, particularly when $G$ is large. Binary search can be more efficient. In case of collision, the group is split into two subgroups with similar aggregate activation probability, and each part is polled independently. The process is repeated recursively until all collisions are resolved. This requires some extra energy consumption, as multiple iterations might be needed to solve the collision, but as long as traffic is relatively sparse, the time required for the collision resolution is $O(\log_2(G))$ instead of $O(G)$, leading to significant benefits for larger groups.

\section{Performance Analysis}\label{sec:analysis}

We can now analyze the performance of unicast and multicast \gls{wur}. The performance of pure ALOHA in this scenario is not included in the paper, as it is a classical medium access scheme, and several in-depth analyses are available in the relevant literature.
\subsection{Unicast WUR}

Unicast \gls{wur}, which we also refer to as \gls{tdma}, has no collisions. Consequently, we can easily compute the duration of a polling cycle. Each wake-up signal requires $\tau_0+t_{\text{wu}}$, and each packet requires time $t_p$, so if $K$ packets are transmitted during a cycle, the total time is $T_u(K)=N\left(\tau_0+t_{\text{wu}}\right)+Kt_p$. However, the longer the duration of a cycle, the more packets are generated, so the average cycle duration is the solution of the following linear system:
\begin{equation}
    \begin{cases}
        &\mathbb{E}[K]=\sum_{n=1}^N\lambda_N \mathbb{E}[T_u];\\
        &\mathbb{E}[T_u]=N\left(\tau_0+t_{\text{wu}}\right)+\mathbb{E}[K]t_p.
    \end{cases}
    \label{eq:polling_cycle}
\end{equation}
The average duration of a polling cycle is then given by:
\begin{equation}
    \mathbb{E}[T_u]=\frac{N\left(\tau_0+t_{\text{wu}}\right)}{1-\sum_{n=1}^N\lambda_N t_p}.
\end{equation}
Naturally, the system does not work if the load is higher than 1, i.e., if $\sum_{n=1}^N\lambda_N \mathbb{E}[T_d]\geq 1$, as the polling cycle duration will become infinite. As packets may arrive at any time during the cycle, the average delay $D_u(n)$ for sensor $n$ is then simply given by:
\begin{equation}
 D_u(n)=\frac{\mathbb{E}[T^2_u]}{\mathbb{E}[T_u]}\frac{(1+\lambda_n t_p)}{2}.
 \label{eq:delay_eq}
\end{equation}
We can compute $\mathbb{E}[T^2_u]$ as
\begin{equation}
\begin{aligned}
    \mathbb{E}[T^2_u] &= \mathbb{E}[(N(t_{wu}+\tau_0)+Kt_p)^2],\\
    &= N^2(t_{wu}+\tau_0)^2 + 2N(t_{wu}+\tau_0)t_p \mathbb{E}[K] + t_p^2\mathbb{E}[K^2].
    \label{eq:polling_cycle_calc}
\end{aligned}
\end{equation}
As the number of packets $K$ follows a Poisson distribution, and defining symbol $\Lambda = \sum_n^{N-1}\lambda_n$, we can write $\mathbb{E}[K] = \Lambda\mathbb{E}[T_u]$ and $\mathbb{E}[K^2] = \Lambda\mathbb{E}[T_u] + \Lambda^2(\mathbb{E}[T_u])^2$. Substituting the values of $\mathbb{E}[K]$ and $\mathbb{E}[K^2]$ in \eqref{eq:polling_cycle_calc}, we get:
\begin{equation}
\begin{aligned}
    \mathbb{E}[T_u^2] =& N^2(t_{wu}+\tau_0)^2 + 2N(t_{wu}+\tau_0)\Lambda\mathbb{E}[T_u]\\
    &+t_p^2\Lambda\mathbb{E}[T_u]+t_p^2 \Lambda^2(\mathbb{E}[T_u])^2.
    \label{eq:tu_expectation}
\end{aligned}
\end{equation}
Substituting \eqref{eq:tu_expectation} in \eqref{eq:delay_eq}, we get:
\begin{equation}
\begin{aligned}
    D_u(n) =& \Bigg[N(t_{wu}+\tau_0)\Bigg(1-t_p\Lambda + 2Nt_p\Lambda + \\ &\frac{t_p^2\Lambda^2}{1-t_p\Lambda}\Bigg)+t_p^2\Lambda\Bigg]\frac{(1+t_p\lambda_n)}{2}.
\end{aligned}
\end{equation}
We can then consider the energy consumption of the protocol, which is the sum of several steps as shown in \figurename~\ref{fig:comp2}. We assume that the energy consumed by the \gls{wur} is negligible (being two or three orders of magnitudes lower than that of the \gls{pcr}). Each sensor then consumes energy $E_{\text{wu}}$ every time it receives a wake-up message, whether it is meant for it or not. If the address matches and the sensor has new data to transmit, the \gls{pcr} is turned on to transmit the messages and receive the corresponding ACKs.  Using cumulative ACKs can reduce energy consumption when transmitting multiple packets, but the protocol becomes slightly more involved. For simplicity of explanation, in the following we assume that each packet is individually ACKed. Therefore, denoting by $E_{\text{tx}}$ the energy required to transmit one packet and receive the corresponding ACK, a node with $k$ packets in its transmission buffer will spend a total energy of $kE_{\text{tx}}$. The average power consumption of a node $n$ is then given by:
\begin{equation}
  P_u=\frac{NE_{\text{wu}}}{\mathbb{E}[T_u]}+\lambda_nE_{\text{tx}}.
\end{equation}
The energy consumption $E_u$ for each successfully transmitted packet is hence equal to:
\begin{equation}
  E_u=\frac{P_u}{\lambda_n} = \frac{NE_{\text{wu}}}{\lambda_n\mathbb{E}[T_u]}+E_{\text{tx}}.
\end{equation}

% Figure environment removed
\subsection{Multicast WUR}

In multicast \gls{wur}, the dynamic nature of group selection makes it difficult to perform an analytical study. However, we can give upper and lower bounds to the additional delay and energy consumption introduced by the two collision resolution mechanisms when collisions do happen.

If we consider linear search, the additional energy consumption is simple: since nodes can stop listening after being polled, they spend no more than $GE_{\text{wu}}$ units of energy to listen to the round of wake-up messages, and those that had packets to send spend an additional $E_p$ for each packet. On the other hand, the expected additional delay is at least  $\frac{G(\tau_0+t_{\text{wu}})+2E_p}{2}$, in the best case scenario in which collisions involve only 2 nodes.

In binary search, the worst scenario when a collision has occurred is when all the nodes have the same activation probability, which we denote by $p_a$. In this case, the collision probability can be defined as
\begin{align}
    p_{c}(G) = 1 - (1-p_a)^G - Gp_a(1-p_a)^{G-1}\,.
\end{align}
The probability that $M$ out of the $G$ nodes in the group will be active is then
\begin{align}
    P_a (M|G) = \dfrac{G!}{M!(G-M)!} p_a^M (1-p_a)^{G-M},
\end{align}
and the probability of activation for $M\geq2$ nodes in a group of size $G$ given a collision has occurred is given by
\begin{align}
    P_a (M|G,c) = \dfrac{\frac{G!}{M!(G-M)!} p_a^M (1-p_a)^{G-M}}{1-(1-p_a)^G - Gp_a(1-p_a)^{G-1}},
\end{align}
where $c$ represents the collision event. Using binary search, the group is divided in half at each round until all collisions are resolved, i.e., each subgroup contains no more than one active node. To achieve this, the \gls{gw} has to divide and poll the subgroups in an iterative fashion. Hence, the conditional probability that a given packet is successfully transmitted by the end of the $r$-th round of polling given $M$ active users in a group of $G$ is given by:
\begin{equation}
    P_{s} (r|M,G) = \begin{cases}\prod_{\ell=1}^{M-1} \frac{G_r + 1 - \ell}{G+1-\ell} & \text{if } M \leq G_r + 1; \\
    0 & \text{otherwise,}\\
    \end{cases}
    \label{eq:success_prob}
\end{equation}
where $G_r = G-2^{-r}G$ is the size of the node's polling group at the $r$-th consecutive round of binary search, and the argument of the product is the probability that the $\ell$-th node with a pending packet is placed in a different set than the tagged one. We can use~\eqref{eq:success_prob} and apply the law of total probability to compute the probability of receiving the packet from a particular node at the $r$-th round for a group of size $G$. Additionally, the duration of the $r$-th round depends on the number of remaining collisions, as does the energy consumption. To compute the probability of resolving all collisions by the $r$-th round, we consider that each subgroup should contain only one active node: if two or more sensors are in the same polling group, the collision will recur. The total number of possible combinations of active sensors is given by:
\begin{equation}
C(G,M)=\binom{G}{M}.
\end{equation}
However, we only consider the combinations that result in each sensor being in a different group, whose number is:
\begin{equation}
    S_r(G,M)=\prod_{i=0}^{M-1}G\left(\frac{2^r-i}{2^r}\right)=G^M\prod_{i=0}^{M-1}\left(1-2^{-r}i\right).
\end{equation}
 Considering that $1-2^{-r}i \leq e^{-i/2^r}$, we can approximate and simplify this to get:
\begin{equation}
    P_{sa}(r|M)\leq\frac{G^M(G-M)!M!}{G!}\exp\left(-\frac{M^2}{2^{r+1}}\right),
    \label{eq:collision_success}
\end{equation}
which is a bound on the final probability that all collisions are resolved by the end of the $r$-th round for a given number of active nodes $M$. Note that, in this derivation, we assumed that no other nodes in the group become active, \ie, there are no new packet arrivals during the collision resolution process. Packets arriving during a collision resolution procedure should be buffered and transmitted at the following polling cycle. 

Fig.~\ref{fig:cdf} shows the theoretical bound and Monte Carlo probability of successful collision resolution. \figurename~\ref{fig:cdf_single} shows the probability of successful collision resolution for a single node using~\eqref{eq:success_prob} with group size $G=1000$ and $M=\sum_{n \in \C{G}} \lambda_n \E{\tau_n}$. As visible from the figure, the theoretical analysis slightly underestimates the probability of collision resolution in a particular round compared to Monte Carlo analysis. This is due to the fact that the theoretical analysis conservatively considers a high number of active nodes, while in the Monte Carlo analysis, the number of active nodes is almost always smaller. \figurename~\ref{fig:cdf_all} shows the theoretical number of rounds required by the binary search for group sizes $G={100,1000}$ using optimistic ($M=2$) and pessimistic ($M=\sum_{n \in \C{G}} \lambda_n \E{\tau_n}$) numbers of colliding nodes, computed using~\eqref{eq:collision_success} and compared with the Monte Carlo performance. As the figure shows, the Monte Carlo performance is in between the two theoretical curves. Interesting to notice that more than 80\% of collisions are solved within 6 rounds, both when $G=100$ and $G=1000$. 

\section{System-level Simulation and Results}\label{sec:results}

In order to verify our analysis and compare the proposed multicast \gls{wur} protocol with unicast \gls{wur} and legacy ALOHA, we performed a Monte Carlo simulation. We considered two different scenarios, with $N\in\{100,1000\}$ and the parameters given in Tab. \ref{tb:tab1}. In all scenarios, all the nodes are in the \gls{gw}'s communication range.

\begin{table}[]
\caption{Simulation Parameters}
\centering
\begin{tabular}{lc}
\toprule
Parameter & Value \\
\midrule
Simulator           & MATLAB            \\ 
Number of Nodes 	& $\{100,1000\}$    \\
Polling Time for 1 Node ($t_{\text{wu}}+\tau_0$)  & $15$ ms \\
Transmission Time for 1 packet ($t_p$)   & $1$ ms \\
WUR Energy Consumption & $365\times10^{-9}$ W/s \\
PCR Energy Consumption & $0.1$ W/s \\
Aggregate load ($\xi$) & $\{0.01,0.1,\ldots,0.5\}$ $\text{pkt}/t_p$               \\
Collision Probability Threshold & 5\%                \\
Number of iterations & 1000000               \\
\bottomrule
\end{tabular}
\label{tb:tab1}
\end{table}
% Figure environment removed

The simulation is performed with 1000000 iterations for any given number of nodes and arrival rate. Each node in the network has a random individual arrival rate in each iteration, but we fix the aggregate arrival rate $\xi=\sum_{n=1}^N\lambda_nt_p$: some nodes have a high arrival rate while some have a low arrival rate, but the total average number of packets generated in each transmission duration $t_p$ remains constant.


The energy efficiency $\eta_n$ of node $n$ is given by:
\begin{equation}
    \eta_n = \dfrac{E_{\text{tx}}K_n}{E_n},
\end{equation}
where $K_n$ and $E_n$ represent the total number of packets successfully transmitted by node $n$ and its total energy consumption, respectively, over the whole simulation.

In our evaluation, we consider the following protocols:
\begin{itemize}
    \item \gls{wur}-LS: \gls{wur} multicast polling with collision resolution using linear search;
    \item \gls{wur}-BS: \gls{wur} multicast polling with collision resolution using binary search;
    \item ALOHA: legacy slotted ALOHA protocol; as soon as nodes have data, they transmit at the next possible slot, with retransmission after a random backoff in case of collisions;
    \item TDMA: Unicast \gls{wur} polling with round robin scheduling.
\end{itemize}
%% Figure environment removed


% Figure environment removed

The two metrics that we consider in our performance evaluation are the average delay and energy efficiency. These metrics are most important in \gls{iot} applications such as tracking and monitoring in remote places. 

\figurename~\ref{fig:delay} shows the delay performance of the selected schemes as a function of the total traffic load, considering $N=100$ and $N=1000$ nodes in the network, respectively.
%% Figure environment removed
%% Figure environment removed
As the figure shows, the delay incurred by the \gls{wur}-LS and \gls{wur}-BS is lower than that attained using ALOHA in all cases, and the latter is unstable even for relatively low aggregate load levels. On the other hand, \gls{tdma} achieves a slightly lower delay if the load is extremely high (at least 0.5 pkt$/t_p$), as explicit coordination becomes the only way to manage all the generated traffic. If the load is low, the waiting time between subsequent wake-up signals for a single node is the dominant factor contributing to delay in \gls{tdma}, while collisions in ALOHA become unsustainable even for relatively low load levels. We can also note that binary search is significantly more effective at reducing the delay with respect to linear search, but only for low load levels ($\leq 0.3$ pkt$/t_p$): as the number of collided packets increases, binary search becomes less effective, requiring more and more rounds to solve all collisions. 

However, multicast polling has a cost: both schemes have a lower energy efficiency with respect to \gls{tdma} and even ALOHA, consuming almost double the energy of \gls{tdma} with unicast polling, as \figurename~\ref{fig:energy} shows. The large number of polls required by linear search collision resolution makes it generally worse than binary search in terms of energy efficiency: as the number of collisions increases, linear search tends to suffer from the same snowball effect as ALOHA (the time necessary to resolve a collision leads to a backlog of packets, which further increases the probability of future collisions), while binary search can avoid it for longer. As the aggregate load increases, both multicast schemes also gradually reduce the size of the polling groups to maintain an acceptable collision probability. For this reason, higher loads always correspond to a higher delay, but energy efficiency actually improves for binary search if the load is significant. 

%% Figure environment removed
%% Figure environment removed
%% Figure environment removed
% Figure environment removed

Additionally, to understand the difference in performance obtained by using binary search or linear search for fast collision resolution, we evaluate the \gls{wur}-LS and \gls{wur}-BS schemes for fixed group size: instead of dynamic-sized groups that keep the collision probability below a certain threshold, we consider multicast polls of a fixed group consisting of the nodes which have the highest probability of having a packet. \figuresname~\ref{fig:extra_delay} and \ref{fig:extra_energy} show the extra delay and difference in energy efficiency encountered when considering the \gls{wur}-BS scheme compared to \gls{wur}-LS scheme. The extra delay and energy efficiency difference is given by
\begin{align}
    \Delta D &= D^{\text{WUR-LS}} - D^{\text{WUR-BS}};\\
    \Delta \eta &= \eta^{\text{WUR-LS}} - \eta^{\text{WUR-BS}} . 
\end{align}

Fig.~\ref{fig:extra_delay} shows that linear search is more effective for medium-sized groups when the traffic load is high, but larger groups tend to favor binary search even when the aggregate load is high. If groups are very small, the two schemes are approximately similar in their effectiveness, but the logarithmically increasing delay of binary search is significantly lower than the linearly increasing delay of linear search when the group size grows.

At the same time, the energy efficiency of binary search is much lower than for linear search, as the possibility of collisions in later rounds requires a significantly higher expense than just a series of polls. This difference is significant, as subsequent collisions are much more expensive than individual polls. However, the energy efficiency of the multicast schemes also depends on the group sizes and delay: as each collision is solved in a much shorter time (unless the traffic is very high), binary search allows the receiver to poll fewer nodes in each group with better delay performance, avoiding the energy issue, as the previously discussed results showed.

\section{Conclusions and Future Work}\label{sec:conc}

In this work, we propose and investigate an alternative polling scheme for \gls{wur}. Instead of polling each individual node, our scheme uses multicast polls to wake up multiple nodes at once, striking a balance between the long waiting times of \gls{tdma}-like approaches and the frequent collisions of ALOHA. The resulting scheme is slightly more energy-intensive than either, but can significantly reduce delay in scenarios with relatively light traffic.

Possible avenues of future work may include considering different access priorities for nodes and/or data, multihop transmissions, or \glsfirst{aoi} approaches. Additionally, considering out of band \gls{wur} can decouple data transmission from \gls{wur} signals, possibly reducing polling delays. Another interesting avenue to pursue can be the use of machine learning to predict (potentially correlated) arrival rates based on previous arrivals, which can be then be used to devise multicast groups proactively. 
\section*{Acknowledgments}

This work was supported by the European Union's NextGenerationEU instrument, under the Italian National Recovery and Resilience Plan (NRRP) of NextGenerationEU, as part of the partnership on ``Telecommunications of the Future'' (PE0000001 - program
``RESTART''), the CHIST-ERA-19-CES-002 project "ANDROMEDA",  and the Young Researchers grant SoE0000009 ``REDIAL.''

\bibliographystyle{IEEEtran}
\bibliography{WURbibiography}

\end{document}

