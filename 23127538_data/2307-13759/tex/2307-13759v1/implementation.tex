%Written by Yan Yan (y.yan@bristol.ac.uk)

\section{Implementation}\label{sec:implementation}
We have implemented the proposed $\elgs$ scheme using the Pairing Based Cryptography (PBC) Library\cite{lynn2007implementation}. Our tests use a {\em d-type} curves ($d224$) from PBC library. %The source code is available at \cite{eggs}.
Although currently there is no agreement about a vehicle's on-board hardware capabilities, % to reduce production cost,  %the vehicle's computing power is restricted by the fact that it is powered by the fuel and battery, and thus does not have a stable power source. 
we present illustrative measures taken from an experiment done with an ASUS ZenBook3 UX390UA\footnote{Powered by Intel i7500U with 8GB RAM} and  a Raspberry Pi 3 (model B)\cite{RP3}\footnote{Powered by a 1.2GHz 64-bit quad-core ARMv8 CPU and 1GB RAM.}.

%\subsection{Signature Size}
%\Cref{Tbl: NumOfEle} summarises the number of elements in each field. 

\begin{table}
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{c|c|c|c|c}
		\hline
	 & BBS \cite{Boneh2004} & TAA \cite{5719272}  & PS-OL & Ours \\
		\hline
	 Group Sig. & $3\mathbb{G}_1 + 6\mathbb{Z}_p$ & 		     \begin{tabular}{c}
	 $5\mathbb{G}_1 + 3\mathbb{Z}_p$ (v1)\\
	 $7\mathbb{G}_1 + 3\mathbb{Z}_p$ (v2) \\
	 \end{tabular} & $3\mathbb{G}_1 + 5\mathbb{Z}_p$ & $3\mathbb{G}_1 + 5\mathbb{Z}_p$ \\
	 \hline
	 Event Sig. & \multicolumn{3}{c|}{N/A} & $2\mathbb{Z}_p$ \\
		\hline
	\end{tabular}
	}
	\caption{Comparison of signature length. \label{Tbl: SigLen}}
\end{table}


In our $\elgs$ scheme, the group signatures consists of 3 elements from $\mathbb{G}_1$ and 5 elements from $\mathbb{Z}_p$ which retains the normal size of a short group signature scheme \cite{Boneh2004,5719272,7006753} as shown in \Cref{Tbl: SigLen}. The event signatures are significantly shorter, consisting of 2 elements from $\mathbb{Z}_p$. The actual size when implemented on curve d224 is summarised in \Cref{Tbl: EgsSigSize}.
The compressed size is obtained using PBC compression algorithm on the elements in $\mathbb{G}_1$.
\Cref{Tbl: BasePerformance} shows the running time of group operations including multiplication, exponentiation and pairing. 



%\begin{table}
%	\centering
%	\begin{tabular}{c|c|c|c|c}
%		\hline
%		& $\mathbb{G}_1$ & $\mathbb{G}_2$ & $\mathbb{G}_T$ & $\mathbb{Z}^*_p$ \\
%		\hline
%		Group signatures & 3 & 0 & 0 & 5 \\ 
%		\hline
%		Event signaures & 0 & 0 & 0 & 2 \\
%		\hline
%%		PS-OL Signature\cite{hwang2013short} & 3 & 0 & 0 & 5 \\
%%		\hline
%	\end{tabular}
%	\caption{Number of elements of our $\elgs$ scheme}\label{Tbl: NumOfEle}
%\end{table}


%\begin{table}
%	\centering
%	\begin{tabular}{c|c|c|c}
%		\hline
%		& & Full & Compressed \\
%		\hline
%		\multirow{2}{*}{d159} & Group signature & 220 & 163 \\
%		 & Event signature &  40 &  40 \\
%		\hline
%		\multirow{2}{*}{d224} & Group signature & 308 & 227 \\
%		 & Event signature & 56 & 56 \\
%		\hline
%	\end{tabular}
%	\caption{$\elgs$ signature size (bytes) \label{Tbl: EgsSigSize}}
%\end{table}


\begin{table}
	\centering
	\begin{tabular}{c|c|c}
		\hline
	 & Full & Compressed \\
		\hline
	 Group Sig. & 308 & 227 \\
	 Event Sig. & 56 & 56 \\
		\hline
	\end{tabular}
	\caption{Size of signatures in $\elgs$ (bytes). \label{Tbl: EgsSigSize}}
\end{table}






%\subsection{Performance evaluation}



{\em Optimisation of $\gsig$:} This algorithm can be optimised to be pairing-free. Specifically, notice that the $R_4$ can be transformed to:
\[\small
	\begin{split}
		R_4 &= \pair(B, g_2)^{r_x} \pair(h, \omega)^{r_\alpha} \pair(h,g_2)^{r_y + r_\delta} \\
		    &= \pair(A, g_2)^{r_x} \pair(h, \omega)^{r_\alpha} \pair(h,g_2)^{\alpha \cdot r_x + r_y + r_\delta}
	\end{split}
	\]
The pairings $\pair(A, g_2)$, $\pair(h, \omega)$ and $\pair(h, g_2)$ in $R_4$ are reusable and does not depend on any variable generated during the procedure; therefore they can be computed in advance to reduce computation.

{\em Optimisation $\gver$:} The number of pairing operations can be reduced by modifying $\tilde R_4$ as below:
\[
\small
\begin{split}
\tilde R_4 & = \pair(B, g_2)^{s_x}\pair(h, w)^{s_\alpha}\pair(h, g_2)^{s_y + s_\delta} \bt{\frac{\pair(B, w)}{\pair(g_1, g_2)}}^c \\
& = \pair(\frac{B^{s_x} h^{s_y+s_\delta}}{g_1^c}, g_2)~ \pair(h^{s_\alpha} B^c, w)
\end{split}
\]
\Cref{Tbl: NumOfGO} summarised the number of group operations of $\gsig$ and $\gver$ after optimisation. Here $\mul_{\mathbb{G}_1}$, $\mul_{\mathbb{G}_T}$, $\iexp_{\mathbb{G}_1}$ and $\iexp_{\mathbb{G}_T}$ are multiplications on $\mathbb{G}_1$ and $\mathbb{G}_T$, and exponentiations on $\mathbb{G}_1$ and $\mathbb{G}_T$, respectively.


Despite the fact that processors we tested are multi-cored, neither PBC nor our implementation has utilised any parallelisation; hence it would be reasonable to expect our profiles being applicable even for single core processors. Our implementation does not have any curve dependency; therefore it can be easily ported to any other qualified curves by simply specifying a different curve parameter file.


\begin{table}[!htbp]
	\centering
%	\tablinesep=2ex\tabcolsep=10pt
	\begin{tabular}{c|c|c|c}
		\hline
		& & ZenBook  & Raspberry Pi 3 \\
		\hline
		\multirow{3}{*}{\mul} & ${\mathbb{G}_1}$  & 0.003 &  0.02 \\
		& ${\mathbb{G}_2}$  & 0.02 &  0.23 \\
		& ${\mathbb{G}_T}$  & 0.005 &  0.07 \\
		\hline
		\multirow{3}{*}{\iexp} & ${\mathbb{G}_1}$  & 0.92 &  5.65 \\
		& ${\mathbb{G}_2}$  & 6.48 & 60.47 \\
		& ${\mathbb{G}_T}$  & 2.35 & 26.52 \\
		\hline
		{\it pairing} &            & 6.19 & 61.93 \\
		\hline
	\end{tabular}
	\caption{Performance of group operations (ms). \label{Tbl: BasePerformance}}
\end{table}

\begin{table}[!htbp]
	\centering
	\begin{tabular}{c|c}
		\hline
		$\gsig$		& $3\mul_{\mathbb{G}_1} + 4\iexp_{\mathbb{G}_1} + 2\mul_{\mathbb{G}_T} + 3\iexp_{\mathbb{G}_T} $  \\
		\hline
		$\gver$	& $6\mul_{\mathbb{G}_1} + 11\iexp_{\mathbb{G}_1} + 1 \mul_{\mathbb{G}_T} + 2 {\it pairing} $  \\
		\hline
		$\esig$		& $1 \iexp_{\mathbb{G}_1}$\\
		\hline
		$\ever$	& $1 \mul_{\mathbb{G}_1} + 2 \iexp_{\mathbb{G}_1}$  \\
		\hline
	\end{tabular}
	\caption{Numbers of group operations of signatures in $\elgs$.\label{Tbl: NumOfGO}}
\end{table}

\Cref{Tbl: EggsPerformance} presents the timing profile of our $\elgs$ protocol.
%We also profiled ECDSA of OpenSSL implementation using curve secp192k1 on the same devices as a comparison.
Each result is calculated on 1000 samples. $\esig$ and $\ever$ are 10 times faster than $\gsig$ and $\gver$ respectively. $\gsig$ and $\gver$ only needs to be performed once for each event, while $\esig$ and $\ever$ are for the frequent use of  safety message authentication. Note that the time for $\open$ only includes the time for recovering $A$; the search for user identity is the equality comparison which does not involve any cryptographic operations and can be optimised to be $O(1)$ using $A$ as index in the database.
%The $\link$ algorithm is negligible on Zenbook3 ($< 0.001\text{ms}$) and takes only $0.004$ms on Raspberry Pi 3.



%Despite the fact that our E-signatures are essentially performing the same operations as ECDSA signatures. therefore it would be a space left to further optimise the implementation. However, in order to maintain the flexibility of choosing different curves, we leave this optimisation as a future task.



\begin{table}[!htbp]
	\centering
		\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\multicolumn{6}{|c|}{ZenBook3} \\
		\hline
		 $\gsig$  & $\gver$ & $\esig$ & $\ever$  & $\link$ & $\open$ \\
		 12.72 & 26.55 	&  1.25 &  2.31 & <0.001 & 0.001 \\
		\hline
%		ECDSA		&   0.26 &   0.32 \\
%		\hline
	\end{tabular}
	\\
\vspace{0.5cm}
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
	\multicolumn{6}{|c|}{Raspberry Pi 3}  \\
		\hline
		$\gsig$ & $\gver$  & $\esig$  & $\ever$  &  $\link$  & $\open$ \\
		158.62 & 201.84 &  16.02 &  24.66 & 0.004 & 0.012 \\
		\hline
%		ECDSA		&   2.58 &   2.85 \\
%		\hline
	\end{tabular}
	\caption{Timing profile of $\elgs$ (ms). \label{Tbl: EggsPerformance}}
\end{table}

