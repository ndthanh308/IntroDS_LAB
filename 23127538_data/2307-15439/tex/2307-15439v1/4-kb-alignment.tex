%!TEX root = ecai-main.tex

\section{The KB-Alignment Problem}
\label{sec:kbalign}

In this section, we define the \emph{knowledge base alignment problem (KB Alignment)}, 
and show how to solve it for the query language $\bcBCQ$ and the DL $\alc$.
%

%\begin{definition}[KB-Alignment]
%	\label{def:kb-alignment}
%	Let $\Kmc=\tup{\Tmc, \Amc}$  be a knowledge base and  $\fquery$ a query in $\bcBCQ$. An ABox-modification $\mods$ is a \emph{KB-alignment for $\Kmc$ and $\fquery$} if:        
%	%
%	\begin{enumerate}
%		\item\label{prop:cons}
%		$\tup{\Tmc,\Amc'}$ is consistent, where $\Amc' = \apply(\mods,\Amc)$, and
%		%
%		\item\label{prop:entail}
%		$\tup{\Tmc,\Amc'}\models\fquery$.
%		
%	\end{enumerate}
%	%
%	The ABox-modification $\mods$ is an \emph{optimal KB-alignment for $\Kmc$ and $\fquery$} if it additionally satisfies:
%	%
%	\begin{enumerate}
%		\item[3.]
%		$\cost(\mods) \leq \cost(\mods')$ for all KB-alignments $\mods'$ for $\Kmc$ and $\fquery$.
%	\end{enumerate}
%	%            
%	The \emph{KB-alignment problem} consists in finding, given a KB $\Kmc$  and a query $\fquery \in \bcBCQ$, an optimal KB-alignment for $\Kmc$ and $\fquery$.
%\end{definition}


\begin{definition}[KB Alignment]
    \label{def:kb-alignment}
    Given a KB $\Kmc=\tup{\Tmc, \Amc}$ and  a query $\bquery \in \bcBCQ$, the 
    problem of KB Alignment consists in finding an ABox-modification $\mods$ 
    such that for $\Amc' = \apply(\mods,\Amc)$: 
    %
    \begin{enumerate}
    	\item\label{prop:cons}
    	$\tup{\Tmc,\Amc'}$ is consistent;
    	%
    	\item\label{prop:entail}
    	$\tup{\Tmc,\Amc'}\models\bquery$; and
    	%
    	\item\label{prop:optimal}
    	$\cost(\mods) \leq \cost(\mods')$ for all ABox-modifications $\mods'$ satisfying Conditions~\ref{prop:cons} and \ref{prop:entail}. 
    \end{enumerate}
    %
    An ABox-modification $\mods$ satisfying 
    Condition~\ref{prop:cons} and~\ref{prop:entail} is a 
    \emph{solution to KB Alignment} for $\tup{\Kmc,\bquery}$; if it also 
    satisfies~\ref{prop:optimal}, it is an \emph{optimal} solution.
    %    
\end{definition}
% \oliver{I find the use of ``solution'' to KB Alignment vs. ``optimal solution'' a bit confusing. One could understand the term "solution" as the answer to instance of KB Alignment, which is not the case.}
%
%
To solve an instance of KB Alignment, it is sufficient to consider ABox-modifications with operations defined using concept and role names from the input KB and query, i.e., using names from their signature. A \emph{signature} is a finite subset of $\cset \cup \rset$.  We use $\sig(X)$ to denote the set of concept and role names occurring in $X$, where $X$ can be a KB or a query.
%%
\begin{restatable}{lemma}{sigrestr}\label{lem:signature:restriction}	
%\begin{lemma}\label{lem:signature:restriction}
   Let $\Kmc$ be a KB and $\bquery \in \bcBCQ$. If KB Alignment has a solution for $\tup{\Kmc,\bquery}$, then it has an optimal solution $\mods$ where all ABox-operations $\ins{\assert}$ and $\rem{\assert}$ in $\mods$ are such that $\assert$ is an assertion defined over $\sig(\Kmc) \cup \sig(\bquery)$.
%\end{lemma}
\end{restatable}
%
An algorithm that solves KB Alignment for $\alc$ KBs and queries in $\bcBCQ$ is introduced next.

\subsection{Solving KB-Alignment}\label{sub:sec:kb:alignment}

Algorithm~\ref{alg:kb:alignment} describes our method to solve KB Alignment. 
The approach is to  
(1) compute an upper bound on the cost of optimal 
solutions (if any), %obtained from a trivial brute-force solution, 
(2) iterate over all ABox-modifications of decreasing 
cost starting from the upper bound, and 
finally output a modification that satisfies Condition~\ref{prop:cons} to \ref{prop:optimal} from 
Definition~\ref{def:kb-alignment}, i.e., which is optimal.
 
More precisely, for the input  TBox $\Tmc$ and query $\bquery$, the algorithm first computes an ABox $\Amc'$ 
such that $\tup{\Tmc, \Amc'}$ is consistent and $\tup{\Tmc, \Amc'} \models \bquery$. 
Then, a  modification $\mods^*$ from the input ABox $\Amc$ into $\Amc'$ is 
obtained which always exists:
given two ABoxes $\Amc$ and $\Amc'$, a 
\emph{trivial modification from $\Amc$ into $\Amc'$} is defined as a 
sequence $\mods = \op_1\cdots \op_k \cdots \op_n$, where 
$\op_1 \cdots \op_k$ consists of the removal of all assertions in 
$\Amc$ and $\op_{k+1} \cdots \op_n$ consists of the insertion of all 
assertions occurring in $\Amc'$.
 %
% %  \begin{itemize}
% %  	\item
% %  	given two ABoxes $\Amc$ and $\Amc'$, a \emph{trivial modification from $\Amc$ into $\Amc'$} is a sequence $\mods = \op_1\cdots \op_\ell \cdots \op_n$, where $\op_1 \cdots \op_\ell$ consists of the removal of all assertions in $\Amc$ and $\op_{\ell+1} \cdots \op_n$ consists of the insertion of all assertions occurring in $\Amc'$.
% %  	% 	
% %  	Clearly, $\Amc'=\apply(\mods,\Amc)$.% and the order of the operations in the two sub-sequences of $\mods$ does not affect the cost $\cost(\mods)$. 	 	
% %  \end{itemize}
  %  
  %
  
  The algorithm computes one trivial modification, which, by 
  Definition~\ref{def:kb-alignment}, is a (possibly non-optimal) solution, thus $\cost(\mods^*)$ realizes the first step of the approach as it  
  is an upper bound on the cost of optimal  
  solutions. 
  Then, the \emph{for-loop} enumerates all ABox-modifications with cost smaller 
  than $\cost(\mods^*)$, that satisfy Condition~\ref{prop:cons} 
  and~\ref{prop:entail} of Definition~\ref{def:kb-alignment}, and returns one ABox modification of 
  minimal cost.

By using Lemma~\ref{lem:signature:restriction}, it is not hard to show that the 
output of Algorithm~\ref{alg:kb:alignment} is always an optimal solution.
%
 \begin{restatable}{lemma}{algcorrect}\label{lem:alg:1:sound:complete}
 %\begin{lemma}\label{lem:alg:1:sound:complete}
    If Algorithm~\ref{alg:kb:alignment} returns $\mods^*$ on input $\Kmc$ and 
    $\bquery$, then $\mods^*$ is an optimal solution to KB Alignment for 
    $\tup{\Kmc,\bquery}$.
 	%
 	If Algorithm~\ref{alg:kb:alignment} returns ``no solution'', 
 	then KB Alignment has no solution for $\tup{\Kmc,\bquery}$.
 %\end{lemma}
\end{restatable}

\begin{algorithm}[t]
	\caption{KB Alignment.}\label{alg:kb:alignment}
	\textbf{Input}: An $\alc$ KB $\Kmc=\tup{\Tmc, \Amc}$ and a query $\bquery \in \bcBCQ$.
	
	\textbf{Output}: An optimal solution of KB Alignment for $\tup{\Kmc,\bquery}$, if a solution exists; or ``no solution'', otherwise.
	
	\begin{algorithmic}[1]	
		\STATE Compute an ABox $\Amc'$ s.t.~$\tup{\Tmc, \Amc'}$ is consistent, $\tup{\Tmc, \Amc'} \models \bquery$ and $\sig(\Amc') \subseteq \sig(\Kmc) \cup \sig(\bquery)$. If  no such ABox exists, \textbf{return} ``no solution'';
		\label{alg1:line:nosolution}
		%
		\STATE Define a trivial modification $\mods^*$ from $\Amc$ into $\Amc'$;\label{alg1:line:trivial}%
		%
		\STATE Let $M$ be the set of ABox-modifications $\mods$ defined over $\sig(\Kmc) \cup \sig(\bquery)$ s.t.~$\cost(\mods) < \cost(\mods^*)$;  		 
		%  		
		\FORALL{$\mods \in M$}
		%\STATE $\Amc' := \apply(\mods,\Amc)$;  		   
		\IF{($\mods$ satisfies conditions~\ref{prop:cons} and \ref{prop:entail} in Definition~\ref{def:kb-alignment}) \AND \\ \quad ($\cost(\mods) < \cost(\mods^*)$)  }\label{alg1:line:if}%
		\STATE \hspace*{0.5cm}
        $\mods^* := \mods$;
		\ENDIF
		\ENDFOR
		\RETURN{$\mods^*$};
	\end{algorithmic}
\end{algorithm}

Hence, to see that Algorithm~\ref{alg:kb:alignment} solves the KB-alignment 
problem, it remains to show that it terminates, i.e., all its steps can \emph{effectively} 
be computed. The following arguments 
%prove that this is the case 
show this for most of the 
steps:
\begin{itemize}[leftmargin=*] 		
	%
	\item
	Since  $\Amc$ and $\Amc'$ are  finite sets, a trivial modification  $\mods^*$ can easily be computed from the ABox $\Amc'$.
	%
	\item
	Consistency of $\alc$ KBs is a decidable problem (\cite{DL-Handbook-03}), as well as entailment of $\bcBCQ$-queries in $\alc$ (see Sec.~\ref{sub:sec:cqs}), hence the conditions at line~\ref{alg1:line:if} can be effectively verified for each $\mods \in M$.
	%
	\item
	The set $M$ contains only ABox-modifications defined over the finite 
	signature $\sig(\Kmc) \cup \sig(\bquery)$. Hence, given $n > 0$, $M$ 
	contains finitely many $\mods$ with $n$ ABox-operations, and each such 
	$\mods$ has cost of at least $c\cdot n$, where $c$ is the minimal cost of 
	an ABox operation defined over $\sig(\Kmc) \cup \sig(\bquery)$.
	%
	This implies that $M$ is a finite set and contains only modifications with 
	no more than $\cost(\mods^*) / c$ operations. Thus, $M$ can be visited in 
	finite time.
\end{itemize}
%
It remains to specify how to compute the initial ABox $\Amc'$ (or to determine that it does not exist).  This requires a more involved argument presented in the following.


\subsubsection{Computing the initial ABox $\Amc'$}

The computation of the initial ABox $\Amc'$ in our algorithm is closely related to the \emph{query emptiness problem} in ontology-mediated query answering.
%based data access. 
This problem was introduced and investigated in \cite{BaaderBL16} for various DLs (including $\alc$) and the query language \CQ. We define this problem here for the more general query language $\bcCQ$.
%
It uses the notion of $\Sigma$-ABox, which refers to ABoxes that use only names from a signature $\Sigma$.

\begin{definition}[$\bcCQ$-query Emptiness]\label{def:query:emptiness}
	Let $\Tmc$ be a TBox, $\Sigma$ a signature and $\bquery \in \bcCQ$. 
	The query $\bquery$ is called \emph{empty for $\Sigma$ given $\Tmc$} if
	for all $\Sigma$-ABoxes $\Amc$ such that $(\Tmc,\Amc)$ is consistent, we have 
	$\cans{(\Tmc,\Amc)}{\bquery} = \emptyset$.

	\emph{$\bcCQ$-query Emptiness} is the problem of deciding, given a TBox 
	$\Tmc$, a signature $\Sigma$, and $\bquery \in \bcCQ$, whether $\bquery$ is 
	empty for $\Sigma$ \wrt $\Tmc$. 	
\end{definition}
 
 In \cite{BaaderBL16}, it is shown that to decide \CQ-query Emptiness in $\alc$, 
 it suffices to consider a single $\Sigma$-ABox $\Amc_{\Tmc,\Sigma}$. 
 This ABox is of exponential size and can be computed (from a given satisfiable TBox $\Tmc$ and a signature $\Sigma$) in exponential time, in the size of $\Tmc$ and the cardinality of $\Sigma$. Moreover, it satisfies the following:
 %
 \begin{itemize}[leftmargin=*]
 	\item
 	the KB $(\Tmc,\Amc_{\Tmc,\Sigma})$ is consistent, and
 	%
 	\item
 	given a pure \cq\ $\query$, $\query$ is empty for $\Sigma$ \wrt $\Tmc$ iff \\ $\cans{(\Tmc,\Amc_{\Tmc,\Sigma})}{\query} = \emptyset$.
 \end{itemize}
 %
  The arguments used to prove the second property can be easily extended to pure 
	${\bcCQ}$-queries, as the following result shows. % ^The proof can be found in the  appendix.
  
  \begin{restatable}{lemma}{ASigmaenough}\label{lem:ASigmaT:is:enough:for:BbcCO}
  %\begin{lemma}\label{lem:ASigmaT:is:enough:for:BbcCO}
  	Let $\Tmc$ be a satisfiable $\alc$ TBox, $\Sigma$ a signature and $\bquery \in \bcCQ$ a pure query. Then, $\bquery$ is empty for $\Sigma$ wrt\ $\Tmc$ iff $\cans{(\Tmc,\Amc_{\Tmc,\Sigma})}{\query} = \emptyset$.
  %\end{lemma}
\end{restatable}

For \emph{non-pure} queries, query emptiness can be reduced to the case of pure queries. This can be done as follows. 
%
Let $\Tmc$ be an $\alc$ TBox, $\Sigma$ a signature, and $\bquery \in \bcCQ$ a \emph{non-pure} query with $\ind(\bquery)=\{a_1,\ldots,a_m\}$. We select $m$ \emph{fresh} concept names $A_1,\ldots,A_m$, i.e., concept names neither occurring in $\Tmc, \bquery$ nor $\Sigma$. 
%
Then, we  define an $\alc$ TBox  $\Tmc_p$, a signature $\Sigma_p$ and a query $\bquery_p\in\bcCQ$, as follows:
%
\begin{itemize}
	\item
	$\Tmc_p = \Tmc \cup \Tmc_{\disj}$, where $\Tmc_{\disj} =\{A_i \sqcap A_j \sqsubseteq \bot \mid 1 \leq i < j \leq m\}$,
	%
	%
	\item
	$\bquery_p = \bquery_x \land \query_{\disj}$, where $\bquery_x$ is obtained from $\bquery$ by replacing each $a \in \ind(\bquery)$ by a fresh free variable $x_a$, whereas $\query_{\disj}$ is the \cq\ $\query_{\disj} = A_1(x_{a_1}) \land \ldots \land A_m(x_{a_m})$, and
	%
	%
	\item
	$\Sigma_p = \Sigma \cup \{A_1,\ldots,A_m\}$.
\end{itemize}
%
%For \emph{non-pure} queries, query emptiness can be easily reduced to the case of pure queries. Namely, it is enough to consider the query $\bquery_x$ obtained from a \emph{non-pure} query $\bquery$ by replacing each $a \in \ind(\bquery)$ by a fresh free variable $x_a$.
%%
%This is shown in the following lemma.	
%
The following lemma shows that testing whether $\bquery$ is empty for $\Sigma$ \wrt $\Tmc$ reduces to checking emptiness of $\bquery_p$ for $\Sigma_p$ \wrt  $\Tmc_p$. Since $\bquery_p$ is a pure query, this yields a reduction from query emptiness of \emph{non-pure} queries to the case of pure queries.
%
% . Its proof (see the appendix) describes how to use a \emph{non-empty} $\bquery_x$ to compute an extension $\Amc^\bquery_{\Tmc,\Sigma}$ of $\Amc_{\Tmc,\Sigma}$ that witnesses non-emptiness of $\bquery$.
 %
 \begin{restatable}{lemma}{removeindividuals}\label{lem:remove:individuals}
%\begin{lemma}\label{lem:remove:individuals}	
	%
	Let $\Tmc$ be an $\alc$ TBox, $\Sigma$ a signature, and $\bquery$ a query in $\bcCQ$. The following holds:
	%
	\begin{enumerate}
		\item
		$\bquery$ is empty for $\Sigma$ \wrt $\Tmc$ iff $\bquery_p$ is empty for $\Sigma_p$ \wrt $\Tmc_p$.
		%$\bquery$ is empty for $\Sigma$ \wrt $\Tmc$ iff $\bquery_x$ is empty for $\Sigma$ \wrt $\Tmc$.
		%
		%
		\item\label{point:2:lemma:nonpure:to:pure}
		%
		%If there is a $\Sigma_p$-ABox $\Amc_p$ s.t.~$\tup{\Tmc_p, \Amc_p}$ is consistent and $\cans{(\Tmc_p,\Amc_p)}{\query_p} \neq \emptyset$, then $\Amc_p$ can be transformed in linear time into a $\Sigma$-ABox $\Amc$ witnessing non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$. %
		If there is a $\Sigma_p$-ABox $\Amc_p$ that witnesses non-emptiness of $\bquery_p$ for $\Sigma_p$ \wrt $\Tmc_p$, then, given $t \in \cans{(\Tmc_p,\Amc_p)}{\query_p}$, $\Amc_p$ can be transformed in polynomial time (in the size of $\Amc_p$ and $t$) into a $\Sigma$-ABox $\Amc$ witnessing non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$. %
		%If there is a $\Sigma$-ABox $\Amc_x$ such that $\cans{(\Tmc,\Amc_x)}{\query_x} \neq \emptyset$, then $\Amc_x$ can be transformed in polynomial time into a $\Sigma$-ABox $\Amc$ such that $\cans{(\Tmc,\Amc)}{\query} \neq \emptyset$.		
	\end{enumerate}
	%
\end{restatable}
%\end{lemma}

Hence, if the input query $\bquery$ of Algorithm~\ref{alg:kb:alignment} is pure, by Lemma~\ref{lem:ASigmaT:is:enough:for:BbcCO} the search space for the ABox $\Amc'$ can simply be restricted to $\{\Amc_{\Tmc,\Sigma}\}$ where $\Sigma=\sig(\Kmc)\cup\sig(\bquery)$.
%
%Otherwise, Lemma~\ref{lem:remove:individuals} tells us how to obtain $\Amc'$ (if it exists). Namely, the algorithm checks whether $\bquery_x$ is non-empty for $\Sigma$ \wrt $\Tmc$, again by only looking at $\Amc_{\Tmc,\Sigma}$.
%
%If the latter is true, then  $\Amc'$ is selected as the ABox obtained from applying to $\Amc_{\Tmc,\Sigma}$ the polynomial time transformation from Lemma~\ref{lem:remove:individuals} (this transformation is part of the proof of Lemma~\ref{lem:remove:individuals}, which can be found in the Appendix).
Otherwise, Lemma~\ref{lem:remove:individuals} tells us how to obtain $\Amc'$ (if it exists). Namely, the algorithm first constructs $\Tmc_p, \bquery_p$ and $\Sigma_p$ from $\Tmc, \bquery$ and $\Sigma$. It then checks whether $\bquery_p$ is non-empty for $\Sigma_p$ \wrt $\Tmc_p$, by using $\Amc_{\Tmc_p,\Sigma_p}$.
%
If the latter is true, then  $\Amc'$ is selected as the ABox obtained from applying to $\Amc_{\Tmc_p,\Sigma_p}$ the transformation from the second statement in Lemma~\ref{lem:remove:individuals}. %(this transformation is described in the proof of Lemma~\ref{lem:remove:individuals}, which can be found in the Appendix).
%
Overall, this provides a way to compute $\Amc'$ whenever it exists.

Hence, Algorithm~\ref{alg:kb:alignment} always terminates. This, together with Lemma~\ref{lem:alg:1:sound:complete}, yields solvability of KB Alignment. A closer look at Algorithm~\ref{alg:kb:alignment} reveals that it runs in \emph{double exponential time} in the size of the input KB and query. Thus, we obtain the following result.
%
%\begin{theorem}\label{th:solvability:kb:alignment:no:nominals:CQ}
\begin{restatable}{theorem}{solvabilitykbalignment}\label{th:solvability:kb:alignment:no:nominals:CQ}
	%KB Alignment is solvable for $\alc$ and $\bcBCQ$.
	KB Alignment is solvable for $\alc$ and $\bcBCQ$ in \emph{double exponential time}.
\end{restatable}
%\end{theorem}
%

%The computational problem associated to  $\bcCQ$-query \emph{non-emptiness} is the problem of computing a $\Sigma$-ABox $\Amc$ (if it exists) that witnesses non-emptiness of a query. For a Boolean query $\bquery$, this corresponds to find a $\Sigma$-ABox $\Amc$ s.t.~$(\Tmc,\Amc) \models \bquery$.

%For a Boolean query $\bquery$, we know that $\cans{(\Tmc,\Amc)}{\bquery} \neq \emptyset$ iff $(\Tmc,\Amc) \models \bquery$.
%%
%Hence, the problem of computing the ABox $\Amc'$ in Algorithm~\ref{alg:kb:alignment} is an instance of the computational problem associated to $\bcCQ$-query non-emptiness (i.e. computing a witness $\Sigma$-ABox, if it exists), where $\Sigma=\sig(\Kmc) \cup \sig(\bquery)$.


%\begin{definition}\label{def:query:emptiness:problem}
%	Let $\Tmc$ be a TBox, $\Sigma$ a signature and $\qlang$ a query language. Then, an $\qlang$-query $\query$ is called empty for $\Sigma$ and $\Tmc$ if for all $\Sigma$-ABoxes $\Amc$ s.t.~$(\Tmc,\Amc)$ is consistent, we have $cert_{\Tmc,\Amc}(\query)=\emptyset$.
%	
%	\emph{$\qlang$-query emptiness} is the problem of deciding, given $\Tmc$, $\Sigma$ and an $\qlang$-query $\query$, whether $\query$ is empty for $\Sigma$ and $\Tmc$.
%\end{definition}


%finding $\tilde{\Amc}$ above reduces to check whether the A-Box $\Amc_\psi$ is a solution, where $\Amc_\psi$ is obtained from $\psi$ as follows:
% %
%$$
% 	\Amc_\psi := \{A(a_y) \mid A(y) \in \psi\} \cup \{r(a_y,a_z) \mid r(y,z) \in \psi\}.
%$$
%%
% The following lemma shows that it is enough to look at $\Amc_\psi$.
% 
% \begin{restatable}{lemma}{lemApsiisenough}\label{lem:A:psi:is:enough}
	% 	Let $\dl$ be a DL not including nominals, $\Tmc$ a T-Box and $\psi$ a \CQ-query. Then, an A-Box $\tilde{\Amc}$ exists iff $\Amc_\psi$ is such an A-Box.
	% \end{restatable}
% %
% Testing whether $\Amc_\psi$ satisfies the conditions required for $\tilde{\Amc}$ reduces to check whether $(\Tmc,\Amc_\psi)$ is a consistent knowledge base.  Note that $\Amc_\psi$ represents the structure of $\psi$, which means that every model of $(\Tmc,\Amc_\psi)$ entails $\psi$.
% %
% Hence, we obtain the following result.
%
%   it is shown that query emptiness is decidable for all fragments of the DL $\alci$ and $\qlang \in \{\IQ,\CQ\}$. In particular, it is shown that to decide query emptiness it suffices to consider a single A-Box $\Amc_{\Sigma,\Tmc}$. More precisely, it is shown that $\psi$ is non-empty for $\Sigma$ and $\Tmc$ iff $cert_{\Tmc,\Amc_{\Sigma,\Tmc}} (\psi) \neq \emptyset$.
%%
%Hence, the first step in the algorithm above can be effectively computed by defining $\Sigma$ as the set of concept and role names occurring in $\Tmc$ and $\psi$, computing $\Amc_{\Sigma,\Tmc}$ as described in \cite{BaaderBL16} and checking whether $cert_{\Tmc,\Amc_{\Sigma,\Tmc}} (\psi) \neq \emptyset$. From this, we obtain the following result.
%%


%Open points:
%\begin{itemize}
%\item 
%%Define cost model for modifications: a basic cost model can be based on \emph{edit} operations that are applied to $\Amc$. More precisely,
% %        \begin{itemize}
	% %            \item \emph{insert} and \emph{delete} relations between individuals in $\Amc$, i.e., edges $r(a,b)$,
	% %            \item \emph{replace} an edge $r(a,b)$ in $\Amc$ for another edge $s(a,b)$,
	% %            \item define similar operations for concept assertions $A(a)$ in $\Amc$, and
	% %            \item one question is whether we want to allow the introduction of new individuals or the deletion of existing ones, which may be necessary to obtain a path to satisfy $\psi$.
	% %        \end{itemize}
% %      All these operations have a cost. A transformation of $\Amc$ into $\tilde\Amc$ consists of a sequence of basic operations. The cost of the whole transformation can be defined as the sum of the costs of the basic operations in the sequence.

%	Some observations/examples to illustrate the cost model and its interaction with the knowledge in $\Tmc$:
%	\begin{itemize}
	%		\item I have added the requirement that $\tilde\Kmc$ should be consistent, because depending on the considered DL, the resulting $\tilde{\Kmc}$ may turn out to be inconsistent.
	%		%
	%		For instance, if $\Amc$ contains $r(a,b)$ and $\Tmc$ an inconsistency statement $\exists r \sqcap \exists s \sqsubseteq \bot$, then adding $s(a,b)$ to $\Amc$ would make $\Kmc$ inconsistent.
	%		\item The knowledge in $\Tmc$ can be relevant:
	%		
	%		\begin{tikzpicture}[font=\small]
		%		\node(T) {$\Tmc=\{\exists r \sqsubseteq \exists p.\exists s.\exists r\}$};
		%		\node(L) [below of=T,yshift=0.5cm,xshift=-0.4cm] {$\psi=s.ps.(ps)^*$};
		%		\node(A) [right of=T,xshift=2cm]{$\Amc:$};
		%		\node(a1) [right of=A,xshift=-0.5cm,fill=black,circle,inner sep=0pt,minimum size=3pt] { };
		%		\node(a2) [right of=a1, fill=black,circle,inner sep=0pt,minimum size=3pt] { };
		%		\node(a3) [right of=a2, fill=black,circle,inner sep=0pt,minimum size=3pt] { };
		%		\draw[->] (a1) to node[above]{$s$} (a2);
		%		\draw[->,dotted,red] (a2) to node[above]{$r$} (a3);
		%		\end{tikzpicture}
	%		
	%		One possibility to modify $\Amc$ to satisfy $\psi$ is to explicitly add two \emph{loop} edges labeled with $p$ and $s$ to the middle element.
	%		%
	%		However, a better solution is to just add the $r$-labelled edge. The implication in $\Tmc$ forces the middle element to have a path labelled with $ps$.
	%		
	%		\item 
	%		There may be no solution:
	%		
	%		\begin{tikzpicture}[font=\small]
		%		\node(T) {$\Tmc=\{\exists r \sqcap \exists s \sqsubseteq \bot\}$};
		%		\node(L) [right of=T,xshift=1.5cm] {$\psi=\{sr\}$};
		%		\node(A) [right of=T,xshift=3cm]{$\Amc:$};
		%		\node(a1) [right of=A,xshift=-0.5cm,fill=black,circle,inner sep=0pt,minimum size=3pt] { };
		%		\end{tikzpicture}
	%		
	%		The word $sr$ can only be obtained by adding self-edges with labels $s$ and $r$ to the unique element in $\Amc$. But this would make the resulting $\tilde\Kmc$ inconsistent. This would be different if our cost model permits insertions of new individuals.
	%	\end{itemize}
%	\item Problem should be decidable for strictly positive costs: we build a path satisfying the \tcrpq and from this we
%	can easily define $\tilde\Amc$. Details to be discussed together (but we believe this can be done by building the automaton for the \tcrpq and then finding all the direct accepting paths).(or \tcrpq?) 
%\end{itemize}
%\anni{This is definition is rather KB alignment. This could also be interesting, since it has a bit of a (weighted?) abduction flavour: The query is an observation and the old KB is not \enquote{in line} with the observation. Now the abduction problem is, how to update the KB to incorporate the observation.}

%\anni{For the approximate semantics of (C2)RPQs, the $\psi$ is (minimally) altered into a $\psi'$ s.t.\  $\mathcal{K} \models \psi'$.}		

%
%Then, for every model $\I$ of $\tilde\Kmc$ there exist $d,e\in \Delta^\I$ and $w=R_1\ldots R_\ell \in \lang(\psi)$ s.t.~$d$ is connected to $e$ in $\I$ by a role path labeled with $w$. This implies that $e \in (\exists R_1.\cdots \exists R_\ell.\top)^\I$ and that $\exists R_1.\cdots \exists R_\ell.\top$ is satisfiable wrt\ $\Tmc$.

%Consider a new ABox $\tilde\Amc_w=\{R_1(a_0,a_1),\ldots,R_\ell(a_{\ell-1},a_\ell)\}$, where $R_1\ldots R_\ell$ is one of the words $w$ satisfying the previous properties. Since $\exists R_1.\cdots \exists R_\ell.\top$ is satisfiable wrt\ $\Tmc$, the KB $\tilde\Kmc_w=(\Tmc,\tilde\Amc_w)$ is consistent\footnote{Depending on the logic, this may not be true under the UNA}. A witness of this is the interpretation $\I$ s.t.~$d \in (\exists R_1.\cdots \exists R_\ell.\top)^\I$, where each $a_i$ is mapped to the corresponding element in the path from to $e$. Furthermore, $\tilde\Kmc_w \models \psi$.
%
%As a consequence we have that: if there exists an alignment $\tilde\Kmc=(\Tmc, \tilde\Amc)$, then there is always one of the form $\tilde\Kmc_w$ for some word $w \in \L(\psi)$. 
%
