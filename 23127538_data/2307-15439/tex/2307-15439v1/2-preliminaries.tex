%!TEX root = ecai-main.tex

\section{Preliminaries}

In this section we recap basic notions on description logics, LTL, and trace alignment.

\subsection{Description Logic Knowledge Bases}

Description Logics (DLs) are a family of formal languages for representing 
knowledge and reasoning about it. In this work, we focus on the DL 
\alc~(\cite{Schmidt-SchaussS91}).

We fix three countably infinite sets of names: $\cset$ for concepts, $\rset$ for roles and $\iset$ for individuals.
%Fix three sets \cset, \rset and \iset of \emph{concept}, \emph{role} and 
%\emph{individual} names, respectively.
\emph{Concepts} in \alc are defined inductively as follows:
\[C \defequal A \mid \neg C \mid C \sqcup C \mid \exists r.C \mid \top,\]%\mid \bot
where $A \in \cset$, $r \in \rset$, 
$\top$ is the \emph{top-concept}  and  $\bot$ the \emph{bottom-concept}. 
We use the following standard abbreviations: $C \sqcap D$ for $\neg (\neg C \sqcup \neg D)$, $\forall r.C$ for $\neg (\exists r.\neg C)$, and $\bot$ for $\neg \top$.

% The DL \alci extends \alc by admitting inverse roles $r^-$ in complex concepts. The DL \el is the fragment of \alc that only has $\top$, $\exists r.C$ and $\sqcap$ as concept constructors.


DL concepts are interpreted over (first-order, FO) interpretations. 
An \emph{interpretation} $\Imc = (\Delta^\Imc, \cdot^\Imc)$ consists of a
domain $\Delta^\Imc$ and a function $\cdot^\Imc$ mapping each concept name 
$A$ to a set $A^\Imc\subseteq\Delta^\Imc$, each role name $r$ 
to a binary relation $r^\Imc\subseteq\Delta^\Imc \times \Delta^\Imc$, 
and each individual name $a$ to an element $a^\Imc\in\Delta^\Imc$. 
%%
Based on this, the semantics of (complex) concepts is defined as follows:
$(\neg C)^\Imc =  \Delta^\Imc \setminus C^\Imc$, 
$(\exists r.C)^\Imc = \{d  \in \Delta^\Imc \mid \exists e. ((d,e) \in r^\Imc \wedge e \in C^\Imc)\}$, 
$(C \sqcup D)^\Imc =  C^\Imc \cup D^\Imc$, and
$\top^\Imc = \Delta^\Imc$.%, and $\bot^\Imc = \emptyset$. 
%%The semantics of inverse roles are $(r^-)^\Imc = \{(b, a) \mid (a, b) \in r^\Imc\}$.


\emph{General concept inclusions} (GCIs) are statements 
of the form $C \sqsubseteq D$, expressing 
inclusion relationships between concepts. 
A \emph{TBox} (denoted \Tmc) is a finite set of GCIs. 
A \emph{model} of a TBox \Tmc is an interpretation \Imc that satisfies all 
GCIs in \Tmc, i.e., for all $C \sqsubseteq D \in \Tmc$, it holds that 
$C^\Imc \subseteq D^\Imc$.
%
A TBox is \emph{satisfiable} if it has a model.

Statements $A(a)$ and $r(a,b)$ are called, respectively,
\emph{concept assertion} and 
\emph{role assertion},
where $a, b \in \iset$, 
$A \in \cset$ and 
$r\in\rset$.
%
An interpretation $\Imc$ satisfies $A(a)$
if $ a^\Imc \in A^\Imc$, and 
satisfies $r(a,b)$
if $(a^\Imc, b^\Imc)  \in r^\Imc$.
%
An \emph{ABox} \Amc is a finite set of (concept or role) assertions. 
%%
An interpretation \Imc is a \emph{model} of an ABox \Amc, 
if \Imc satisfies all assertions in \Amc.
% , i.e.\  
% for all $C(a) \in \Amc$, $a^\Imc \in C^\Imc$ and for all $r(a, b)$, 
% $(a^\Imc, b^\Imc) \in r^\Imc$.


A \emph{DL knowledge base} (KB) is a pair $\Kmc = (\Tmc, \Amc)$, with $\Tmc$ a TBox and 
$\Amc$ an ABox. 
An interpretation \Imc is a \emph{model} of $\Kmc = (\Tmc, \Amc)$, written 
$\Imc\models\Kmc$, if \Imc is a model of \Tmc and \Amc. 
%
A KB is \emph{consistent} if it has a model.


\subsection{Conjunctive Queries}\label{sub:sec:cqs}
Prominent reasoning problems investigated in the last decade concern 
\emph{conjunctive queries}.
We briefly recap related definitions and results.
%%
\begin{definition}[Conjunctive query]\label{def:conjunctive:queries}
   	    %Let $\vset$ be a set of variables. A \emph{conjunctive query (\cq)} is an expression of the form $\query(\bar{x})=\exists \bar{y}.\psi$, where $\bar{x}$ and $\bar{y}$ are  tuples of variables from $\vset$ and $\psi$ is a finite conjunction of atoms of the form:
   	    Let $\vset$ be a set of variables. 
   	    A \emph{conjunctive query (\cq)} is an expression of the form 
   	    $\query=\exists \bar{y}.\psi$, where $\bar{y}$ is a  
   	    tuple of variables from $\vset$ and $\psi$ is a finite conjunction of 
   	    \emph{atoms} of the form:
   	    %
   	    	$A(z)$, for $A \in \cset$ and $z \in \vset \cup \iset$, or 
   	    	%
   	    	$r(z,z')$, for $r\in \rset$ and $z,z' \in \vset \cup \iset$.
\end{definition}
%
By $\CQ$ we denote the set of all \cq s (over $\cset$, $\rset$, $\iset$, 
$\vset$). We write $A(z)\in \query$ to state that atom $A(z)$ occurs in 
$\query$, and likewise for $r(z,z')$.
%The variables in $\bar{x}$ are \emph{free variables} of \query and those from $\bar{y}$ are the \emph{existentially quantified variables} of \query.
%A query with no free variables is called \emph{Boolean} query.
%%
%We use $\CQ$ for the set of \cq s and $\BCQ$ for the set of \emph{Boolean \cq s} (\bcq s).

In this work, we combine \cq s using Boolean connectives. 
%%
\begin{definition}[Boolean combination of \cq s]
	A formula $\bquery$ is a \emph{Boolean combination of \cq s} iff:
	\[\phi \defequal \bquery'\mid \neg \bquery\mid \bquery \lor \bquery, 
		\text{ where }\bquery'\in\CQ.\]
       %
%        \begin{itemize}
%        	   \item
%        	   every \emph{\cq}\  is a Boolean combination of \emph{\cq s}, and
%        	   %
%        	   \item
%        	   if $\bquery_1$ and $\bquery_2$ are Boolean combinations of \emph{\cq s}, then so are $\neg \bquery_1$, $\bquery_1 \lor \bquery_2$ and $\bquery_1 \land \bquery_2$.
%        \end{itemize}
       %
       %\anni{I would be in favor to capitalize "Boolean" in every occurrence. I see that here the lower case version is used for the Boolean combination and the capitalized version for the Boolean CQ. I would favor the uniform way of writing it capitalized nevertheless.}
   \end{definition}
   As standard, $\bquery_1\land\bquery_2$ abbreviates
   $\lnot(\neg \bquery_1\lor \neg\bquery_2)$.
%For an arbitrary Boolean combination of \cq s $\bquery$, we denote by $\varsq(\bquery)$, $\fvarsq(\bquery)$ and $\indsq(\bquery)$ the set of variables, free variables and individual names occurring in $\bquery$, respectively. 
Given a Boolean combination of \cq s $\bquery$, we denote by $\varsq(\bquery)$, $\fvarsq(\bquery)$ and $\indsq(\bquery)$ the set of variables, free variables and individual names occurring in $\bquery$, respectively. 
%
A query with no free variables is called \emph{Boolean}, whereas a query with $\ind(\bquery)=\emptyset$ is called \emph{pure}.
%
%%
$\BCQ$ denotes the set of \emph{Boolean \cq s} (\bcq s), 
$\bcCQ$ the set of Boolean combinations of \cq s, 
and $\bcBCQ$ the set of Boolean combinations of \bcq s.
 

The semantics of \bcq s is defined in terms of a 
satisfaction relation between interpretations and \bcq s.
 %
 \begin{definition}[Semantics of \bcq s]\label{def:sem:cqs}
 	An interpretation $\Imc$ is \emph{a model} of (or \emph{satisfies}) 
 	a {\bcq} $\query$, written $\Imc \models \query$, iff
 	there exists a mapping $\match:\varsq(\query) \cup \indsq(\query) \rightarrow \Delta^\Imc$,
 	called a \emph{match}, s.t.:
 	%
 	\begin{itemize}
 		\item
 		$\match(a) = a^\Imc$ for all $a \in \indsq(\query)$;
 		%
 		\item
 		$\match(z) \in A^\Imc$ for all $A(z) \in \query$; and
 		%
 		\item
 		$(\match(z),\match(z')) \in r^\Imc$ for all $r(z,z') \in \query$.
 	\end{itemize}
    %
%     If such a match exists, then $\Imc$ \emph{is a model} of $\query$ (denoted $\Imc \models \query$). 
	\end{definition}
%	
	These notions straightforwardly extend to $\bcBCQ$.
    %
    \begin{definition}[Semantics of Boolean combinations of \bcq s]\label{def:sem:boolean:cqs}
 	An interpretation $\Imc$ is \emph{a model} of (or \emph{satisfies}) 
 	a query $\query \in \bcBCQ$, written $\Imc \models \query$, iff:
    \begin{itemize}
    	\item $\bquery\in\BCQ$ and $\Imc\models\bquery$; or
    	\item 
    	$\bquery=\lnot\bquery_1$ and $\Imc\not\models\bquery_1$; or    	
    	\item
    	$\bquery=\bquery_1 \lor \bquery_2$ and $\Imc \models \bquery_1$ or $\Imc \models \bquery_2$.
    \end{itemize}
 \end{definition}

A query $\bquery \in \bcBCQ$ is \emph{satisfiable} wrt a KB $\Kmc$, if $\Imc \models \bquery$ for some model $\Imc$ of $\Kmc$. A knowledge base \Kmc \emph{entails} a query $\bquery$
 (written $\Kmc \models \bquery$),  if $\Imc \models \bquery$ for all models $\Imc$ of $\Kmc$.
 
In case of non-Boolean queries, one is interested in computing the certain answers. More precisely, given a KB $\Kmc=(\Tmc,\Amc)$ and $\bquery \in \bcCQ$ with free variables $\bar{x}=(x_1,\ldots,x_k)$, a tuple $\bar{a}=(a_1,\ldots,a_k)$ of individuals in $\iset$ is a \emph{certain answer of $\bquery$ wrt\ $\Kmc$} if $\Kmc \models \bquery[\bar{a}]$, where $\bquery[\bar{a}]$ is the Boolean query obtained from $\bquery$ by replacing each occurrence of $x_i$ by $a_i$ ($1 \leq i \leq k$).
%a tuple of individuals $\bar{a}=(a_1,\ldots,a_k) \in \ind(\Amc)^k$ is a \emph{certain answer of $\bquery$ wrt\ $\Kmc$} if $\Kmc \models \bquery[\bar{a}]$, where $\bquery[\bar{a}]$ is the Boolean query obtained from $\bquery$ by replacing each occurrence of $x_i$ by $a_i$ ($1 \leq i \leq k$).
 %
 We denote by $\cans{\Kmc}{\bquery}$ the set of certain answers of $\bquery$ wrt\ $\Kmc$. If $\bquery$ is a Boolean query and $\Kmc \models \bquery$, then $\cans{\Kmc}{\bquery}=\{()\}$.
 
 The entailment problem for  \bcq s wrt\ $\alc$ knowledge bases is ExpTime-complete (\cite{Lutz08,OrtizSE08}). 
 It was shown in \cite{BaaderBL15} for $\bcBCQ$ that satisfiability of a conjunction of \cq-literals (i.e.\ either a Boolean \cq\ or a negated Boolean \cq) wrt\ $\alc$ knowledge bases is an ExpTime-complete problem.
 %
 An easy consequence of this (and of $\bcBCQ$ being \emph{closed under negation}) is that satisfiability and entailment of arbitrary Boolean combinations of \bcq s w.r.t.\ $\alc$ knowledge bases are also ExpTime-complete problems.
% So, clearly, satisfiability and entailment  for queries in $\bcBCQ$ wrt\ $\alc$ knowledge bases are decidable problems.
 
%Clearly, all certain answers of a non-Boolean query with $k$ free variables can be computed by checking entailment for each $k$-tuple of ABox individuals.


\subsection{Propositional Linear Temporal Logic}
%We briefly review (propositional) linear temporal logic. 
%%All the reported definitions and results are 
%%stated in or are immediate consequence of the results in~\cite{Var95} and~\cite{Pit07}.
%%
The kind of properties we focus on in this paper concerns the evolution of 
a knowledge base over time. To express relevant properties, we need a temporal logic. 
We review the basics on propositional Linear Temporal Logic (\ltl), which 
will be later lifted to \cq s and used on to address TKB Alignment.

The language of Linear Temporal Logic (\ltl) formulas $\tquery$ is defined over a finite set of propositions $\prop$, as follows: 
\[
\tquery \defequal p \mid \tnot \tquery \mid \tquery \vee \tquery \mid \ltlX \tquery \mid \tformula \ltlU \tquery
		\text{,~ with $p \in \prop$.}
\]
%%
The set $\props(\tquery)$ denotes the finite set of propositions occurring in $\tquery$.
%
$\ltl$ formulas are interpreted over infinite words, also called~\emph{(propositional) traces}, 
$\seqP = \seqP_0 \seqP_1 \cdots \in{(2^\prop)}^\omega$.
%%
\begin{definition}[$\ltl$ semantics]\label{def:ltl-semantics}
	Given a formula $\tquery\in\ltl$, a trace $\seqP=\seqP_0 \seqP_1\cdots$, and an index $i$, 
	we inductively define when $\seqP, i$ \emph{satisfy} $\tquery$, denoted $\seqP, i \models \tquery$, as follows:
		\begin{itemize}
			\item 
			$\seqP, i \models p$, if $p\in \seqP_i$;	
			\item
			$\seqP, i \models \tnot \tquery$, if $\seqP, i \not\models \tquery$;
			\item
			$\seqP, i \models \tquery_{1} \vee \tquery_{2}$, if $\seqP, i \models \tquery_{1}$ or $\seqP, i \models \tquery_{2}$;
			\item
			$\seqP, i \models \ltlX \tquery$, if $\seqP, i + 1 \models \tquery$;
			\item
			$\seqP, i \models \tquery_{1} \ltlU \tquery_{2}$ if there exists $j \geq i$ s.t.~$\seqP, j \models \tquery_{2}$ and $\seqP, k \models \tquery_{1}$, 
			for $k=i,\ldots,j - 1$.
		\end{itemize}
	We say that $\seqP$ \emph{satisfies} $\tquery\in\ltl$, written $\seqP \models \tquery$, iff $\seqP,0\models\tquery$.
\end{definition}
%%
We denote the set of traces satisfying $\tquery$ as $\L(\tquery)=\set{\seqP\in{(2^\prop)}^\omega\mid\seqP\models\tquery}$.
It is well-known that for every $\tquery\in\ltl$ there exists a
\emph{deterministic parity automaton} (DPA) $\PA_\tquery$ accepting exactly 
$\L(\tquery)$.

A \emph{deterministic parity automaton}
is a tuple $\PA=(\alphabet,Q,\delta,q_0,\col)$, where:
$\alphabet$ is the finite input alphabet, $Q$ is the finite set of states, 
$\delta: Q\times\alphabet\ra Q$ is the transition function, 
$q_0\in Q$ is the initial state, and
$\col:Q\ra\Col$ is a 
\emph{coloring function}, mapping the states of \PA into a finite set of \emph{colors}
$\Col\subset\mathbb{N}_0$.
%%
DPAs are similar to deterministic finite-state automata (DFA),
but accept \emph{infinite} traces and thus have a different accepting condition.
%%

For a DPA $\PA$, a \emph{finite run from state $q\in Q$} is a sequence
$\ppath=q\trans{\seqP_0}q_1\trans{\seqP_1}\cdots\trans{\seqP_{n-1}}q_n$ s.t.~$\delta(q,\seqP_0)=q_{1}$ and 
$\delta(q_i,\seqP_i)=q_{i+1}$, for $0<i<n$. 
%
We define \emph{infinite} runs analogously, 
for $n=\infty$. Unless stated otherwise, runs are always infinite and start in the initial state  $q_0$ of $\PA$.

%%\anni{The following sentence is too dense for my taste and I am not sure I get what is defined there. Please \enquote{decompress} it.}
Given a run $\ppath$ of $\PA$, let $\painf_Q(\ppath,\PA)$ be the set of states occurring infinitely 
many times in $\ppath$. Obviously, $\painf_Q(\ppath,\PA)\neq\emptyset$ iff $\ppath$ is infinite.
Let $\painf(\ppath,\PA)=\set{\col(q)\in\Col \mid q\in \painf_Q(\ppath,\PA)}$ be  
the set of colors ``visited'' infinitely many times by $\ppath$.
%%
A run $\ppath$ from a state $q\in Q$ is \emph{accepting} iff
$\min\set{\painf(\ppath,\PA)}$ is even.
%%
When this is the case, $q\in Q$ is an \emph{accepting} state. 
By $\Acc(\PA)$, we denote the set of all accepting states of $\PA$ and call $\Acc(\PA)$ the \emph{accepting}
set of $\PA$.

\begin{lemma}[\cite{KingKV01}]
The accepting set $\Acc(\PA)$ of a DPA $\PA=(\alphabet,Q,\delta,q_0,\col)$ can be computed in time
$(\card{Q}+\card{\delta})\log\card{\Col}$, where
$\card{\delta}=\card{\set{(q,q')\in Q\times Q\text{ s.t.~}q'=\delta(a,q)\text{, for some }a}}$.
\end{lemma}

For a DPA $\PA=(\alphabet,Q,\delta,q_0,\col)$ and a trace 
$\seqP=\seqP_0\seqP_1\cdots$, the (unique) run \emph{induced} by $\seqP$ is the 
run $\ppath=q_0\trans{\seqP_0}q_1\trans{\seqP_1}\cdots$. 
A trace $\seqP$ is \emph{accepted} by $\PA$ iff the run $\ppath$ induced by 
$\seqP$ is accepting.
%%
By $\L(\PA)$ we denote the \emph{language} of $\PA$, i.e., the set of all traces  accepted by $\PA$.

\begin{theorem}[\cite{Var95,Pit07}]\label{thm:sat-bstates}
For every $\tquery\in\ltl$ there exists a DPA $\PA_\tquery=(2^{\prop},Q,\delta,q_0,\col)$ 
s.t.~$\L(\PA_\tquery)=\L(\tquery)$.
$\PA_\tquery$ can be computed in doubly exponential time and has doubly exponential size wrt $\tquery$.
\end{theorem}

%%The \emph{complement} of a DPA $\PA=(\alphabet,Q,\delta,q_0,\col)$ 
%%is the DPA $\comp{\PA}=(\alphabet,Q,\delta,q_0,\comp{\col})$, 
%%s.t.~$\comp{\col(q)}=\col(q)+1$, for every $q\in Q$. It is immediate to see that:
%%\begin{lemma}\label{lem:dpa-complement}
%%For every DPA $\PA$ with input alphabet $\alphabet$,
%%it holds that  $\L(\comp{\PA})=\alphabet\setminus\L(\PA)$.
%%\end{lemma}

%%Define the \emph{\buchi set} $\bstates(\PA)\subseteq Q$ of a BA $\PA=(\alphabet,Q,\delta,q_0,Q_{acc})$ 
%%as the set of states $q\in Q$ s.t.~there exists an accepting run from $q$.
%%A state $s\in\bstates(\PA)$ is called a \emph{\buchi state}. 
%%
%%The following result is an immediate consequence 
%%of this definition:
%%\begin{lemma}\label{lem:sat-buchi-states}
%%	For every \ltl formula $\tquery$, we have that $\tquery$ is satisfiable iff 
%%	$q_0\in\bstates(\PA_{\tquery})$, for $\PA_{\tquery}=(\alphabet,Q,\delta,q_0,Q_{acc})$.
%%\end{lemma}
%%
%%The following result provides a criterion to effectively compute the set of \buchi states.
%%%%
%%\begin{theorem}\label{thm:lasso}
%%Given an \ltl formula $\tquery$, consider its corresponding $\PA_\tquery=(2^{\prop},Q,\delta,q_0,Q_{acc})$.
%%A state $q\in Q$ is s.t.~$q\in\bstates(\PA_\tquery)$ iff there exists a (lasso-shaped) run 
%%$\ppath=q\trans{\seqP_0}\cdots \trans{\seqP_{m-1}}q_m\trans{\seqP_m}\cdots \trans{\seqP_{n-1}}q_n$,
%%s.t.~$q_n=q_m\in Q_{acc}$.
%%
%%When the above holds for $q=q_0$, the trace $\seqP=\seqP_0\cdots\seqP_{m-1}(\seqP_{m}\cdots\seqP_{n-1})^\omega$
%%is s.t.~$\seqP\in\L(\tquery)$.
%%\end{theorem}

\subsection{Entailment of Temporal Conjunctive Queries}
%The problem addressed in this paper 
TKB Alignment is closely related to 
checking \emph{temporal query entailment} (TQE), studied in~\cite{BaaderBL15}.
We  briefly recall the main definitions and results from that work, 
possibly adapted to our setting.
% % \anni{We should say here what the differences and our adaptations are (or where these are discussed).}
% % \fabio{I would devote a part of the introduction for this; in particular, where we discuss related work.}
%%
\begin{definition}[Temporal Knowledge Base (TKB)]\label{def:tkb}
	A \emph{temporal knowledge base} (TKB)  is a pair 
	$\tkb = (\Tmc, \Aseq)$, where $\Tmc$ is a TBox and $\Aseq= \Amc_0 \cdots \Amc_\ell$ is
	a finite sequence of ABoxes.
\end{definition}
%
A \emph{FO trace} is an infinite sequence $\seqI=\Imc_0 \Imc_1 \cdots$ 
of interpretations $\Imc_i=(\Delta,.^{\Imc_i})$ over a fixed domain $\Delta$.
%%
\begin{definition}[Model of a TKB]\label{def:tkb-model}	
    Given a TKB $\tkb = (\Tmc, \Amc_0\cdots\Amc_\ell)$,
    a FO trace $\seqI=\Imc_0\Imc_1\cdots$ is a \emph{model} of $\tkb$, iff:
	$\I_i \models \Amc_i$, for $0\leq i \leq\ell$; and
	$\I_i \models \Tmc$ for all $i \geq 0$.
	If these conditions hold, $\seqI$ \emph{satisfies} $\tkb$, written $\seqI \models \tkb$.
\end{definition}
%%
Next, we introduce the language \ltlbcq of \emph{(simple) temporal conjunctive queries} 
(TCQ), which essentially lifts propositions in \ltl to \bcq s.
%%
$\ltlbcq$ formulas are obtained as in $\ltl$, by replacing $\prop$ 
with a finite set $\PBCQ\subset\BCQ$:
	\[
		\tquery \defequal \query \mid \tnot \tquery \mid \tquery \vee \tquery \mid \ltlX \tquery \mid \tquery \ltlU \tquery
		\text{, ~with $\query \in \PBCQ$.}
    \]
%%By $\bcqs(\tquery)\subseteq  \PBCQ$ we denote the (finite) set of \bcq s occurring in an \ltl formula $\tquery$.    

$\ltlbcq$ formulas  are evaluated over FO traces.
%%

\begin{definition}[\tcq Semantics]~\label{def:tcq-semantics}
	Given a formula $\tquery \in \ltlbcq$, an infinite trace $\seqI=\I_0 \I_1 \cdots$, and an index $i$, 	
	we inductively define when $\seqI$ \emph{satisfies} $\tquery$ from $i$, denoted $\seqI, i \models \tquery$, as follows:
	\begin{itemize}
		\item 
		$\seqI, i \models \query$, if $\Imc_i \models \query$, for $\query \in \PBCQ$;
		\item
		$\seqI, i \models \tnot \tquery$ if $\seqI, i \not\models \tquery$;
		\item
		$\seqI, i \models \tquery_{1} \vee \tquery_{2}$, if $\seqI, i \models \tquery_{1}$ or $\seqI, i \models \tquery_{2}$;
		\item
		$\seqI, i \models \ltlX \tquery$, if $\seqI, i + 1 \models \tquery$;
		\item
		$\seqI, i \models \tquery_{1} \ltlU \tquery_{2}$ if there exists $j \geq i$ s.t.~$\seqI, j \models \tquery_{2}$ and $\seqI, k \models \tquery_{1}$, 
		for $k=i,\ldots,j - 1$.
	\end{itemize}
	We say that $\seqI$ \emph{satisfies} $\tquery$, written $\seqI \models \tquery$, if $\seqI,0\models\tquery$.
\end{definition}
The semantics of temporal operators for TCQs is analogous to that of $\ltl$ (see Def.~\ref{def:ltl-semantics}); however, for TCQs the base case accounts for the satisfaction of \bcq s by the FO interpretations occurring in the trace.

We observe that the variant of TCQs we use here differs from that introduced in~\cite{BaaderBL15}, in that we disallow \emph{past} operators~(\cite{Gabbay87}). %, which are instead included in~\cite{BaaderBL15}.
However, such restriction comes without loss of generality.
This is because the two semantic variations have essentially the same expressive power, as future operators have the ability to mimic the past ones~(\cite{Wilke99,KupfermanPV01}).

The notion of \emph{temporal conjunctive query entailment} used here is the 
same as that in~\cite{BaaderBL15}, once past operators are disallowed in TCQs.
%%
\begin{definition}[TCQ Entailment]\label{def:tcq-entailment}
	Given a TKB $\tkb$ and a TCQ $\tquery \in \ltlbcq$. The TKB $\tkb$ 
	\emph{entails} $\tquery$, written $\tkb \models \tquery$, 
	iff $\seqI \models \tquery$,
	for every model $\seqI$ of \tkb.
\end{definition}
%%
Checking TCQ entailment (TQE) 
is the problem of deciding whether $\tkb \models \tquery$.


% As we discuss later on,  
% this is without loss of 
% generality wrt to TKB Alignment.




% \giuseppe{Discuss the difference with the semantics provided in~\cite{BaaderBL15}, namely, use of past operators and starting point of temporal evaluation.
% Also, comment on the fact that here we define a parametric version of temporal queries, whereas they have it only for TCQ.
% Report needed known results about Temporal Query Entailment from previous work.}

%
%
%Comments in relation to our initial definitions:
%%
%\begin{itemize}
%	\item
%	The definition of  $\seqI,i \models \tquery$ is  the same as the entailment relation in the left column, but wrt\ the possibly infinite sequence $\I_0,\I_1,\ldots$ instead of the finite sequence $\tau$ of ABoxes. Restricting the semantics to finite sequences $\seqI$ should not be problem, at least for the DLs we are considering.
%	%
%	\item
%	The real difference is apparently between the notion of satisfaction of $\tquery$ by a trace $\tau$ and the notion of entailment in the temporal setting. Discussion?
%	
%	\item [FP] Here we are misusing the term ``satisfaction'', which should instead be ``entailment''. The two models are very similar (modulo finiteness/infiniteness) except we don't have past operators.
%	%  	 
%\end{itemize}



%
%\begin{itemize}
%	\item
%	We assume given a T-Box $\Tmc$ and define a number of problems on finite sequences of knowledge bases (KBs), called \emph{KB-traces}, of the form $\seqI = \Kmc_0 \cdots \Kmc_{l}$, with $\Kmc_i=\tup{\Tmc,\Amc_i}$.
%	For notation convenience, $\Tmc$ being fixed, we denote a KB-trace by the sequence of A-Boxes $\seqI = \Amc_0 \cdots \Amc_{l}$ it contains.
%	Given a KB-trace $\seqI$, we denote by $\seqI_i$ the \emph{suffix of $\seqI$ starting at $i$}, i.e., $\seqI_i=\Kmc_i\cdots \Kmc_\ell$.
%	
%	\item
%	We refer to previous paper for the definition of (Two-way) Conjunctive Regular Path Queries ($(2)CRPQ$), and call \emph{Boolean-$(2)CRPQ$} ($B(2)CRPQ$) a $(2)CRPQ$ not containing any open variable.
%	
%	\item
%
%\end{itemize}
