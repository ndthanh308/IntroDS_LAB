%!TEX root = ecai-main.tex

\subsection{Proofs from Section~\ref{sec:kbalign}}

\sigrestr*
%
\begin{proof}
	Let $\Kmc = (\Tmc,\Amc)$, $\mods=\op_0\cdots \op_n$  be an optimal solution to KB Alignment for $(\Kmc,\bquery)$ and let $\Amc' = \apply(\mods,\Amc)$. 
	%
	
	Suppose that $\mods$ contains an ABox operation $\op_i=\rem{\alpha}$ such that $\alpha \not \in \Amc$. In addition, assume that there is no $j, 0 \leq j < i$ such that $\op_j=\op_i$. We make the following case distinction:
	%
	\begin{itemize}
		\item
		$\ins{\alpha}$ does not occur in $\op_0\cdots \op_{i-1}$. Then, removing $\op_i$ from $\mods$ yields an ABox-modification $\mods'$ such that $\Amc' = \apply(\mods',\Amc)$ and $\cost(\mods') < \cost(\mods)$.
		%
		%
		\item
		There is $j, 0 \leq j < i$ such that $m_j=\ins{\alpha}$. In this case, removing $\op_i$ and all ABox operations $m_\ell = \ins{\alpha}$ ($0 \leq \ell < i$) from $\mods$ %has the same effect of the previous case.
		results in a shorter ABox-modification of lesser cost than $\mu$ and that would also result in $\Amc'$ if applied to $\Amc$.
	\end{itemize}
    %    
	Hence, we can assume  without loss of generality that each ABox operation $\rem{\alpha}$ occurring in $\mods$ is such that $\alpha \in \Amc$.
	
	Consider the ABox-modification $\mods^*$ obtained from $\mods$ by removing all operations of the form $\ins{\alpha}$ such that $\alpha$ is not defined over $\sig(\Kmc) \cup \sig(\bquery)$. Two observations regarding $\mods^*$ are in order:
	%
	\begin{itemize}
		\item
		Since every ABox operation $\rem{\alpha}$ in $\mods$ satisfies that $\alpha \in \Amc$ (by assumption), the same is the case for $\mods^*$. Hence, every ABox operation in $\mods^*$ is defined over $\sig(\Kmc) \cup \sig(\bquery)$.
		%
		\item
		By definition of $\mods^*$, we have that $\cost(\mods^*) \leq \cost(\mods')$. In addition, $\Amc^* \subseteq \Amc'$ where $\Amc^* = \apply(\mods^*,\Amc)$.
		%
		%
		Hence, since $(\Tmc,\Amc')$ is consistent, this means that $(\Tmc,\Amc^*)$ is consistent as well.
		%		
	\end{itemize}	
	%
	
	Thus, to conclude the proof of the lemma, it remains to show that $(\Tmc,\Amc^*) \models \bquery$. Let $\Imc$ be a model of $(\Tmc,\Amc^*)$. Since no individual name occurs in $\Tmc$ and assertions removed from $\Amc'$ are defined over concept and role names not contained in $\sig(\Tmc) \cup \sig(\bquery)$, it is not hard to see that: 
	%
	\begin{itemize}
		\item
		$\Imc$ can be extended into a model $\Jmc$ of $(\Tmc,\Amc')$ such that $\Imc$ and $\Jmc$ are identical on $\sig(\Tmc) \cup \sig(\bquery)$ and on the interpretation of the individuals in $\ind(\bquery)$.
		%
		%
		\item
		 Let $\query'$ be a \CQ  occurring in $\bquery$. Since $\Imc$ and $\Jmc$ are identical on $\sig(\query')$ and $\ind(\query')$, it follows that:
		%
		\begin{equation}\label{eq:base:case:signature:lemma}
			\J \models \query'\ \text{iff}\ \ \I \models \query'.
		\end{equation}
		%
		Hence, by using induction on the structure of $\bquery$ one can easily show that $\J \models \bquery$ iff $\I \models \bquery$. The base case follows from \eqref{eq:base:case:signature:lemma}, since it corresponds to the \cq s occurring in $\bquery$.
		%
		Consequently, since $(\Tmc,\Amc') \models \bquery$, it follows that $\Jmc \models \bquery$ and $\Imc\models\bquery$.						
	\end{itemize}
	
	Finally, since $\Imc$ is an arbitrary model of $(\Tmc,\Amc^*)$, we have thus shown that  $(\Tmc,\Amc^*) \models \bquery$. This completes the proof.	
	%
\end{proof}

\algcorrect*
%
\begin{proof}
	Suppose that Algorithm~\ref{alg:kb:alignment} returns an ABox-modification $\mods^*$ on input $\Kmc$ and $\bquery$. The following observations imply that $\mods^*$ is an optimal solution to KB Alignment for $(\Kmc,\bquery)$.
	%
	\begin{itemize}
		\item
		The modification $\mods^*$ is either the trivial modification computed at Line~\ref{alg1:line:trivial}, or a modification in $M$ satisfying the test at Line~\ref{alg1:line:if}. Hence, $\mods^*$ is a solution to KB Alignment for $(\Kmc,\bquery)$, because it satisfies Condition~\ref{prop:cons} and \ref{prop:entail} in Definition~\ref{def:kb-alignment}.
		%
		%
		\item
		% The previous observation tells us 
		Since $\mods^*$ is a solution to KB Alignment for $(\Kmc,\bquery)$, it follows that some optimal solution $\mods'$ to KB Alignment for $(\Kmc,\bquery)$ exists. 
		%
		By Lemma~\ref{lem:signature:restriction}, we can assume that $\mods'$ is defined over $\sig(\Kmc) \cup \sig(\bquery)$. In addition, since $\mods^*$ is a solution, it follows that 
		%
		\begin{equation}\label{eq:fact}
	   	   \cost(\mods') \leq \cost(\mods^*).
		\end{equation}
	%
	If $\cost(\mods') = \cost(\mods^*)$, then $\mods^*$ is obviously optimal. Otherwise, inequation \eqref{eq:fact} implies that $\cost(\mods') < \cost(\mods^*)$. This in turn implies that $\mods'\in M$, since either $\mods^*$ is the trivial modification computed at Line~\ref{alg1:line:trivial} in Algorithm~\ref{alg:kb:alignment} or $\mods^* \in M$.
	%
	Obviously, the \emph{for-loop} would never choose $\mods^*$ if $M$ contains a modification with smaller cost. Hence, $\cost(\mods') < \cost(\mods^*)$ cannot be the case. Therefore, $\mods^*$ must be an optimal solution.
	%
	\end{itemize}
	%
	
	Suppose that Algorithm~\ref{alg:kb:alignment} returns \enquote{no solution}. Due to Line~\ref{alg1:line:nosolution} there is then no ABox $\Amc'$ such that:
	%
	\begin{itemize}
		\item
		$(\Tmc,\Amc')$ is consistent, 
		\item $(\Tmc,\Amc') \models \bquery$, and 
		\item $\sig(\Amc') \subseteq \sig(\Kmc) \cup \sig(\bquery)$.
	\end{itemize}  
     %
     The non-existence of such an ABox $\Amc'$ implies that there is no solution $\mods$ to KB Alignment for $(\Kmc,\bquery)$ such that $\mods$ is defined over $\sig(\Kmc) \cup \sig(\bquery)$. Note that any such ABox-modification $\mods$ would yield an ABox defined over the signature $\sig(\Kmc) \cup \sig(\bquery)$, like $\Amc'$ is.
     %
     Thus, the application of Lemma~\ref{lem:signature:restriction} yields that KB Alignment has indeed no solution for $(\Kmc,\bquery)$.
     %
\end{proof}

\ASigmaenough*

To prove this lemma, we slightly extend the proof arguments given in \cite{BaaderBL16} for the \CQ query language to the more general query  language \bcCQ. To this end, we need to introduce some notions and auxiliary results from \cite{BaaderBL16}.
%
Let us start with the notion of an ABox homomorphism.
%
\begin{definition}
	Let $\Amc$ and $\Amc'$ be two ABoxes. An \emph{ABox homomorphism} from $\Amc$ to $\Amc'$ is a total function $h:\ind(\Amc) \mapsto \ind(\Amc')$ satisfying the following conditions:
	%
	\begin{itemize}
		\item
		$A(a) \in \Amc$ implies $A(h(a)) \in \Amc'$, and
		%
		\item 
		$r(a,a') \in \Amc$ implies $r(h(a),h(a')) \in \Amc'$.
	\end{itemize}
\end{definition}
 %
 The following lemma states an important property of ABox homomorphisms for query answering. It generalizes Lemma~11 in \cite{BaaderBL16} from \CQ to \bcCQ.
 %
\begin{lemma}\label{lem:queries:canonical:abox}
	Let $\Tmc$ be an $\alc$ TBox, $\bquery\in \bcCQ$ with free variables $x_1,\ldots,x_k$, $\Amc$ and $\Amc'$  ABoxes, and $\hphism$ an ABox homomorphism from $\Amc$ to $\Amc'$. If $(\Tmc,\Amc) \models \bquery[(a_1,\ldots,a_k)]$ then $(\Tmc,\Amc') \models \bquery[(\hphism(a_1),\ldots,\hphism(a_k))]$.
\end{lemma}
\begin{proof}
	%
	We assume that $(\Tmc,\Amc) \models \bquery[(a_1,\ldots,a_k)]$ holds.	
	%
	The case where $(\Tmc,\Amc')$ is not consistent is trivial. 
	%
	If $(\Tmc,\Amc')$ is consistent, it has a model. Let $\Imc$ be an arbitrary model of $(\Tmc,\Amc')$. We show that 
	%
	\begin{equation}\label{eq:hom:preserves:entailment}
		\Imc \models \bquery[(\hphism(a_1),\ldots,\hphism(a_k))].
	\end{equation}
	%
	To prove this, we define an interpretation $\Jmc$ from $\Imc$ by reinterpreting the individual names in $\Amc$, i.e
	%
	\begin{itemize}
		\item
		$\Delta^\Jmc := \Delta^\Imc$,
		%
		\item
		$X^\Jmc := X^\Imc$ for all $X \in \cset\cup\rset$, and
		%
		\item
		$a^\Jmc := \hphism(a)^\Imc$ for all $a \in \ind(\Amc)$.
	\end{itemize}
	%
	Let $\query_a$ be a \cq\ occurring in $\bquery[(a_1,\ldots,a_k)]$, and $\bquery_\hphism$ be the \cq\ that results from replacing all occurrences of all $a_i$ ($1 \leq i \leq k$)
	in $\query_a$ by $\hphism(a_i)$. Hence, 	since ${a_i}^\Jmc = \hphism(a_i)^\Imc$ for all $i, 1 \leq i \leq k$, the following holds:
	%
	\begin{equation}\label{eq:base:case}
		\Jmc \models \query_a\ \ \ \text{ iff }\ \ \ \Imc \models \query_\hphism
	\end{equation}
	%
	Therefore, by using induction on the structure of $\bquery[(a_1,\ldots,a_k)]$ and applying \eqref{eq:base:case} to the base case, one can easily show that:
	%
	\begin{equation*}
		\Jmc \models \bquery[(a_1,\ldots,a_k)]\ \text{ iff }\ \Imc \models \bquery[(\hphism(a_1),\ldots,\hphism(a_k))]
	\end{equation*}
	%
	Hence, since $(\Tmc,\Amc) \models \bquery[(a_1,\ldots,a_k)]$, to  show that \eqref{eq:hom:preserves:entailment} holds it is enough to show that $\Jmc \models (\Tmc,\Amc)$.
	%
	\begin{itemize}
		\item
		Since no individual name occurs in $\Tmc$, $\Imc \models \Tmc$ implies that $\Jmc$ is also a model of $\Tmc$. 
		%
		%
		\item
		To see that $\Jmc$ is a model of $\Amc$ as well, consider any concept assertion $A(a) \in \Amc$. The homomorphism $\hphism$ ensures that $A(\hphism(a)) \in \Amc'$. Hence, $\I \models \Amc'$ implies that $\hphism(a)^\I \in A^\I$, and it follows by definition of $\J$ that $a^\J \in A^\J$. The case of role assertions $r(a,b) \in \A$ can be shown analogously.
	\end{itemize}
	%
	Overall, we have just shown that any model $\Imc$ of $(\Tmc,\Amc')$ satisfies \eqref{eq:hom:preserves:entailment}. Thus, $(\Tmc,\Amc') \models \bquery[(\hphism(a_1),\ldots,\hphism(a_k))]$.
	%
\end{proof}

The ABox $\Amc_{\Tmc,\Sigma}$ defined in \cite{BaaderBL16} is \emph{canonical} in the following sense. For any satisfiable $\alc$ TBox $\Tmc$, the following holds:
%
\begin{enumerate}
	\item
	 $(\Tmc,\Amc_{\Tmc,\Sigma})$ is consistent. %(Lemma~10), 
	 %
	 \item\label{claim:BBL16-2}
	 A $\Sigma$-ABox $\Amc$ satisfies that $(\Tmc,\Amc)$ is consistent iff there is an ABox homomorphism from $\Amc$ to $\Amc_{\Tmc,\Sigma}$. %Lemma~12 in \cite{BaaderBL16} 
	 %	 
\end{enumerate}
%
Using these two properties about $\Amc_{\Tmc,\Sigma}$ and Lemma~\ref{lem:queries:canonical:abox}, we are now ready to conclude the proof of Lemma~\ref{lem:ASigmaT:is:enough:for:BbcCO}.
 
 \medskip
 
 \begin{proof}[Proof of Lemma~\ref{lem:ASigmaT:is:enough:for:BbcCO}]
 	The \emph{left-to-right} direction is trivial. For the opposite direction, assume that $\bquery$ is non-empty for $\Sigma$ \wrt $\Tmc$. Then, there exists a $\Sigma$-ABox $\Amc$ such that $\cans{(\Tmc,\Amc)}{\bquery} \neq \emptyset$.
 	%
 	Thus, since there exists an ABox homomorphism from $\Amc$ to $\Amc_{\Tmc,\Sigma}$ (by \ref{claim:BBL16-2}.\ above), Lemma~\ref{lem:queries:canonical:abox} yields that $\cans{(\Tmc,\Amc_{\Tmc,\Sigma})}{\bquery} \neq \emptyset$.
 \end{proof}

\removeindividuals*
%
%We start by recalling the definitions of $\Tmc_p, \Sigma_p$ and $\bquery_p$ stated in the paper. Let $\ind(\bquery)=\{a_1,\ldots,a_m\}$ and $A_1,\ldots,A_m$ be concept names not occurring in $\Tmc, \bquery$ nor $\Sigma$. The elements  $\Tmc_p, \Sigma_p$ and $\bquery_p$ are defined as follows:
%%
%\begin{itemize}
%	\item
%	$\Tmc_p = \Tmc \cup \Tmc_{\disj}$, where $\Tmc_{\disj} =\{A_i \sqcap A_j \sqsubseteq \bot \mid 1 \leq i < j \leq m\}$,
%	%
%	%
%	\item
%	$\bquery_p = \bquery_x \land \query_{\disj}$, where $\bquery_x$ is obtained from $\bquery$ by replacing each $a \in \ind(\bquery)$ by a fresh free variable $x_a$, whereas $\query_{\disj}$ is the \cq\ $\query_{\disj} = A_1(x_{a_1}) \land \ldots \land A_m(x_{a_m})$, and
%	%
%	%
%	\item
%	$\Sigma_p = \Sigma \cup \{A_1,\ldots,A_m\}$.
%\end{itemize}
%%
%We continue with the proof of Lemma~\ref{lem:remove:individuals}. 

\begin{proof}
	Let $x_1,\ldots,x_k$ be the free variables of $\bquery$ and $a_1,\ldots,a_m$ the individual names occurring in $\bquery$. Then, $\bquery_x$ has $k+m$ free variables, i.e.
	%
	\begin{equation*}
		\fvarsq(\bquery_x) =\{x_1,\ldots,x_k\} \cup \bigcup\limits_{i=1}^{m} \{x_{a_i}\},
	\end{equation*}
	%
	where each $x_{a_i}$ is fresh variable not occurring in $\bquery$. We represent the free variables as the ordered tuple $(x_1,\ldots,x_k, x_{a_1},\ldots,x_{a_m})$.
	
	Let us start with Claim 1, by showing the \emph{left-to-right} implication.
	
	($\Rightarrow$) Assume that $\bquery_p$ is non-empty for $\Sigma_p$ \wrt $\Tmc_p$. Hence, there exists a $\Sigma_p$-ABox $\Amc_p$ such that  $(\Tmc_p,\Amc_p)$ is consistent and  $\cans{(\Tmc_p,\Amc_p)}{\bquery_p} \neq \emptyset$. Thus, there exists  a tuple $t=(b_1,\ldots,b_{k+m})$ of individual names of $\iset$ such that $t \in \cans{(\Tmc_p,\Amc_p)}{\bquery_p}$. 
	%
	The following assumptions about $\Amc_p$ are without loss of generality:
	%
	\begin{enumerate}[(a)]
		\item
		 $\Amc_p$ contains no individuals from $\ind(\bquery)$. This can be assumed because neither $\bquery_p$ nor $\Tmc_p$ contain individual names,		
		%
		%
		\item
		$b_{k+1},\ldots,b_{k+m}$ are all distinct individuals of $\Amc_p$. 
		This follows from the fact that $(\Tmc_p,\Amc_p)$ is consistent, the disjointness axioms occurring $\Tmc_{\disj}$ and the form of  $\bquery_{\disj}$.
		%
		%
		\item
		For all $i \in \{1,\ldots,m\}$, $\Amc_p$  contains no assertion of the form $A_i(b)$ with $b \neq b_{k+i}$. Such an assertion would either contradict $t \in \cans{(\Tmc_p,\Amc_p)}{\bquery_p}$, or would not be necessary to ensure that $t$ belongs to $\cans{(\Tmc_p,\Amc_p)}{\bquery_p}$.
	\end{enumerate}
	%
	Let us define a $\Sigma$-ABox $\Amc$ from $\Amc_p$, by taking the following steps.
	%
	\begin{enumerate}
		\item
		Remove all assertions of the form $A_i(b)$ occurring in $\Amc_p$ ($1 \leq i \leq m$).
		%
		\item
		Rename every remaining individual name $b_{k+i}$ as $a_i$ ($1 \leq  i \leq m$).
	\end{enumerate}
     %
     This renaming is well-defined since all individual names $b_{k+1},\ldots,b_{k+m}$  are distinct (recall assumption (b)). For all $i \in \{1,\ldots,k\}$, we write $\overline{b_i}$ to denote the following individual from $\{b_1,\ldots,b_k,a_1,\ldots,a_m\}$:
     %
     \begin{itemize}
     	\item
     	$b_i$, if $b_i \neq b_{k+j}$  for all  $j \in \{1,\ldots,m\}$, or
     	%
     	\item
     	$a_j$, if $b_i = b_{k+j}$ for some  $j \in \{1,\ldots,m\}$.
     \end{itemize}
     %
      %\textcolor{red}{Do all $\overline{b_i}$ occur in $\Amc$?}               
	
	We show that $\Amc$ witnesses non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$. 
	%
	Clearly, by removing all assertions of the form $A_i(b)$ from $\Amc_p$, we have that $\Amc$ is a $\Sigma$-ABox. To see that $(\Tmc,\Amc)$ is consistent, consider a model $\Imc$ of $(\Tmc _p,\Amc_p)$. We extend $\Imc$ to interpret the individual names $a_i$ as:
	%
	\begin{itemize}
		\item
		$a_i^\Imc = b_{k+i}^\Imc$ ($1 \leq i \leq m$).
	\end{itemize} 
     %
     Since $\Imc \models \Amc_p$, by construction of $\Amc$ it is easy to see that $\Imc \models \Amc$ as well. Further, since no individual name occurs in $\Tmc$, the extended $\Imc$ is still a model of $\Tmc$. Hence, $(\Tmc,\Amc)$ is consistent.
	
	It remains to show that $\cans{(\Tmc,\Amc)}{\bquery} \neq \emptyset$. To this end, we show that $\bar{t} = (\overline{b_1},\ldots,\overline{b_k}) \in \cans{(\Tmc,\Amc)}{\bquery}$. 
	%
	Let $\Jmc$ be an arbitrary model of $(\Tmc,\Amc)$. It is enough to prove that 
	\begin{equation}\label{eq:ent:to:show}
		\Jmc \models \bquery[\:\overline{b_1},\ldots,\overline{b_k}\:].
	\end{equation}
	%
    %
    We use $\Jmc$ to build an interpretation $\Jmc_p$ such that $\Jmc_p \models (\Tmc_p, \Amc_p)$. Since $t \in \cans{(\Tmc_p,\Amc_p)}{\bquery_p}$,  we would have that $\Jmc_p \models \bquery_p[t]$. Recall that $\bquery_p = \bquery_x \land \bquery_d$, $t=(b_1,\ldots,b_{k+m})$,  and $\bquery_x$ has $k+m$ free variables.
    %
    Hence, we would have that:
    %
    \begin{equation}\label{eq:ent:that:holds}
    	\Jmc_p \models \bquery_x[b_1,\ldots,b_k,b_{k+1},\ldots,b_{k+m}].
    \end{equation}
    %
    This will then be used to show that \eqref{eq:ent:to:show} holds.
    
    Let $\Delta^{\Jmc}_0, \Delta^{\Jmc}_1 \ldots, \Delta^{\Jmc}_m$ be disjoint copies of $\Delta^\Jmc$. Given $d \in \Delta^\Jmc$, we denote by $d_i$ the corresponding copy in $\Delta^{\Jmc}_i$ ($0 \leq i \leq m$). The interpretation $\Jmc_p$ is defined as follows:
    %
    \begin{itemize}
    	\item
    	$\Delta^{\Jmc_p} := \Delta^{\Jmc}_0 \cup \cdots \cup \Delta^{\Jmc}_m$,
    	%
    	\item
    	$B^{\Jmc_p} := \{d_i \in \Delta^{\Jmc}_i \mid d \in B^\Jmc \text{ and } 0 \leq i \leq m\}$\\[.2em] \hspace*{4.5cm} for all  $B \in \cset \setminus \Sigma_p$,
    	%
    	%    	
    	\item
    	$r^{\Jmc_p} := \{(d_i,e_j) \in \Delta^{\Jmc}_i \times \Delta^{\Jmc}_j \mid (d,e) \in r^\Jmc \text{ and }$ \\[.2em] 
    	%
    	\hspace*{3cm} $0 \leq i,j \leq m\}$, for all $r\in\rset$,
    	%
    	%
    	\item
    	$A_i^{\Jmc_p} := \{d_i \in \Delta^{\Jmc}_i \mid d =a_i^\Jmc\}$ for all $1 \leq i \leq m$. %\text{ or }\\[.2em]
    	     %
    	      %\hspace*{2.4cm}(d=a_j^\Jmc,  i=k+j \text{ and } 1 \leq j \leq m) \}$,
    	
%    	 $r^{\Jmc_\disj} := \{(d_i,e_i) \in \Delta^{\Jmc}_i \times \Delta^{\Jmc}_i \mid (d,e) \in r^\Jmc\} \: \cup \\[.2em] 
%    	                        %
%    	                        \hspace*{1cm}\{(d_i,e_j) \in \Delta^{\Jmc}_i \times \Delta^{\Jmc}_j \mid d=a_i^\Jmc, e=a_j^\Jmc,$\\[.2em]
%    	                        %
%    	                        \hspace*{1.3cm}$(a_i^\Jmc,a_j^\Jmc)\in r^\Jmc \text{ and } i,j > 0\}$,
    	 %    	 
    \end{itemize}
   %
   The individual names $b_1,\ldots,b_{k+m}$  are interpreted as follows. 
   %
   \begin{itemize}
   	   \item
   	   For all $i \in \{1,\ldots,k\}$ such that $\overline{b_i}\neq a_j$ ($1 \leq j \leq m$):
   	   %
   	   \begin{equation*}
   	   	 b_i^{\Jmc_p} = d_0 \in \Delta_0^{\Jmc_p}, \text{ where } d=b_i^\Jmc.
   	   \end{equation*}
   	   
   	   %
   	   \item
   	   For all $j \in \{1,\ldots,m\}$:
   	   %
   	   \begin{equation*}
   	   	 b_{k+j}^{\Jmc_p} = d_j \in \Delta_j^{\Jmc_p}, \text{ where } d = a_{j}^{\Jmc}.
   	   \end{equation*}
   	    %
   \end{itemize}
  %
  This assignment covers all individuals names in $b_1,\ldots,b_{k+m}$, because if  $\overline{b_i}= a_j$ for some $i \in \{1,\ldots,k\}$ then $b_i=b_{k+j}$ for some $j \in \{1,\ldots,m\}$.
    
  To show that $\Jmc_p \models (\Tmc_p,\Amc_p)$, we use the property that $\alc$ is bisimulation invariant \cite{BaaderHLS17}.

  We start by defining a binary relation $\bis \subseteq \Delta^\Jmc \times \Delta^{\Jmc_p}$ as follows:
	%
	\begin{equation*}
		\bis := \{(d,d_i) \in \Delta^\Jmc \times \Delta^{\Jmc_p} \mid 0 \leq i \leq m\}.
	\end{equation*}
%
It is not hard to show that  $\bis$ is a \emph{bisimulation} between $\Jmc$ and $\Jmc_p$ \wrt the symbols in $(\cset \cup \rset) \setminus \Sigma_p$. 
%\anni{If signatures are finite, then this is not a signature.
%\\[\medskipamount]
%Generally, I don't see why you don't use $\Sigma$ in the proof, but $(\cset \cup \rset)$ instead. It is only necessary to construct one witness for query non-emptiness. That should work for the signature $\Sigma$, doesn't it?
%}
%
Hence, the bisimulation invariance of $\alc$ guarantees the following for all $\alc$ concepts $C$ defined over $(\cset \cup \rset) \setminus \Sigma_p$:
%
\begin{equation}\label{bisimulation:prop}
	d \in C^\Jmc\ \text{ iff }\ d_i \in C^{\Jmc_p},\ \text{for all } i \in \{0,\ldots,m\}.
\end{equation}
	%
Therefore, since no concept name in $\Sigma_p$ occurs in $\Tmc$ and $\Jmc \models \Tmc$, the correspondence in \eqref{bisimulation:prop} implies that $\Jmc_p \models \Tmc$. In addition, the interpretation of $A_1,\ldots,A_m$ implies that $\Jmc_p \models \Tmc_d$. Thus, we have that $\Jmc_p \models \Tmc_p$.
	%	
	Regarding $\Amc_p$, we consider the possible forms of its assertions:
	%
	\begin{itemize}
		\item
		$A_i(b) \in \Amc_p$ for some $i \in \{1,\ldots,m\}$. By assumption (c), we know that $b=b_{k+i}$. The definition of $\Jmc_p$ tells us that $b_{k+i}^{\Jmc_p}=d_i$ where $d=a_i^\Jmc$, and that $A_i^{\Jmc_p}=\{d_i\}$. Thus, $b_{k+i}^{\Jmc_p} \in A_i^{\Jmc_p}$.
		%
		%
		\item
		$A(b) \in \Amc_p$ for $A \in \Sigma$. If $b=b_{k+i}$ for some $i \in \{1,\ldots,m\}$, then $A(a_i) \in \Amc$. Hence, $\Jmc \models \Amc$ implies that $a_i^\Jmc \in A^\Jmc$.
		%		
		Let $a_i^\Jmc=d \in \Delta^\Jmc$. By construction of $\Jmc_p$, we have that $d_i \in A^{\Jmc_p}$ and $b_{k+i}^{\Jmc_p} = d_i$. Thus, it follows that $b_{k+i}^{\Jmc_p} \in A^{\Jmc_p}$.
		%
		
		In case $b\neq b_{k+i}$, we have that $A(b) \in \Amc$. Hence, $b^\Jmc\in A^\Jmc$. It is easy to see from the definition of $\Jmc_p$ that $b^{\Jmc_p} \in A^{\Jmc_p}$.
		%
		\item
		The case of the role inclusions in $\Amc_p$ can be shown similarly, by considering the interpretation of role names in $\Jmc_p$ and the renaming of $b_{k+i}$ into $a_i$.
	\end{itemize}
	%	
	
  Overall, we have shown that $\Jmc_p \models (\Tmc_p,\Amc_p)$. Hence, we have that \eqref{eq:ent:that:holds} holds. From this, we can show that \eqref{eq:ent:to:show} holds in two steps, as follows:
  %
  \begin{enumerate}
  	\item
  	  We show that for each \cq\ $\query^*$ in $\bquery[\:\overline{t}\:]$ and the corresponding one $\query^*_x$ in $\bquery_x[t]$ it holds that:
  	  %
  	  \begin{equation}\label{base:case:induction}
  	  	   \Jmc \models \bquery^*\ \ \text{ iff }\ \ \Jmc_p \models \bquery^*_x.
  	  \end{equation}
      %
      This is a consequence of the definition of $\Jmc_p$ and the fact that $\bquery[\: \overline{t} \:]$ and $\bquery_x [t]$ are Boolean queries that are identical modulo renaming of $a_i$ and $b_{k+i}$.
      %
      \item
     We apply induction on the structure of $\bquery[\: \overline{t} \:]$ to show that \eqref{eq:ent:that:holds} implies \eqref{eq:ent:to:show}, by using \eqref{base:case:induction} as the induction base case.
     %\anni{This needs to be explained in more detail.}
  \end{enumerate}

  This concludes the proof of the \emph{left-to-right} direction of Claim 1 of the lemma.
  %
%  Let $\query^*$ be a \cq\ occurring in $\bquery[\: \overline{t}\:]$ and $\query^*_x$ the corresponding one from $\bquery_x[t]$. We show that $\Jmc \models \bquery^*$ iff $\Jmc_p \models \bquery^*_x$.
%  %
%  \begin{itemize}
%  	  \item
%  	  Suppose that $\Jmc \models \bquery^*$. Then, there exists a match $\match$ for $\bquery^*$ in $\Jmc$, as stated in Definition~\ref{def:sem:cqs}. We define a mapping $\match_p$ into $\Jmc_p$ as follows:
%  	  %
%  	  \begin{itemize}
%  	  	\item
%  	  	for all  $y\in \varsq(\bquery_x^*)$: $\match_p(y)=d_0$, where $d_0$ is the copy in $\Delta_0^\Jmc$ of the domain element $d=\match(y)$.
%  	  	%
%  	  	\item
%  	  	$\match_p(b)=b$ for all $b \in \ind(\bquery_x^*)$.
%  	  \end{itemize} 
%  	  %
%  	  We show that $\match_p$ is a match for $\query_x^*$  in $\Jmc_p$. Let us consider the form of the atoms in $\query_x^*$.
%  	  %
%  	  \begin{itemize}
%  	  	   \item
%  	  	   $A(y)$ for a variable $y$. We know that $A(y)$ is also an atom in $\query^*$. Let $\match(y)=d\in\Delta^\Jmc$. Since $\match$ is a match for $\query^*$ in $\Jmc$, it follows that $d \in A^\Jmc$. Hence, the definition of $\Jmc_p$ yields that $d_0 \in A^\Jmc$.
%  	  	   %
%  	  	   Thus, $\match_p(y) \in A^\Jmc_p$.
%  	  	   %
%  	  	   \item
%  	  	   $A(b)$ for an individual name $b$.
%  	  \end{itemize}
%  \end{itemize}
%     %
    %
	We continue by showing the \emph{right-to-left} direction.
	
	($\Leftarrow$)
	%
	Suppose that $\bquery$ is non-empty for $\Sigma$ \wrt $\Tmc$. This means that there is a $\Sigma$-ABox $\Amc$ and a tuple $t=(b_1,\ldots,b_k)$ of individual names $b_1,\ldots,b_k \in \iset$ such that $(\Tmc,\Amc)$ is consistent and $t \in\cans{(\Tmc,\Amc)}{\bquery}$.
	%
	Since $\Tmc$ contains no occurrences of individual names, there exists a model $\Imc$ of $(\Tmc,\Amc)$ such that $a_i^\Imc \neq a_j^\Imc$ for all $i \neq j, 1 \leq i, j \leq m$. 
	
   Consider the ABox $\Amc_p = \Amc \cup \{A_i(a_i) \mid 1 \leq i \leq m\}$ and the interpretation $\Imc_p$ that extends $\Imc$ by defining $A_i^{\Imc_p} := \{a_i^\Imc\}$ for all $i \in \{1,\ldots m\}$. It is clear that $\Amc_p$ is a $\Sigma_p$-ABox. In addition, it is easy to see that $\Imc_p \models (\Tmc_p, \Amc_p)$. Hence, $(\Tmc_p,\Amc_p)$ is a consistent KB.
    %
    Further, since $\Tmc \subseteq \Tmc_p$ and $\Amc \subseteq \Amc_p$, every model $\Jmc$ of $(\Tmc_p, \Amc_p)$ is a model of $(\Tmc,\Amc)$. This implies that $\Jmc \models \bquery[t]$. Since each individual $a_i$ is replaced by $x_{a_i}$ to obtain $\bquery_x$ from $\bquery$, it follows that $\Jmc \models \bquery_x[(b_1,\ldots,b_k,a_1,\ldots,a_m)]$.
    %
    Moreover, the additional assertions in $\Amc_p$ ensure that $\Jmc \models \query_{\disj}[(a_1,\ldots,a_m)]$. Hence, we have that:
    %
    \begin{equation*}
    	(b_1,\ldots,b_k,a_1,\ldots,a_m) \in \cans{(\Tmc_p,\Amc_p)}{\bquery_x \land \query_{\disj}}.
    \end{equation*} 
    
     Thus, we have shown that $\bquery_p$ is non-empty for $\Sigma_p$ \wrt $\Tmc_p$.\\
     
     To conclude, let us look at Claim 2 of the lemma. Suppose there exists a $\Sigma_p$-ABox $\Amc_p$ such that $(\Tmc_p,\Amc_p)$ is consistent and $\cans{(\Tmc_p,\Amc_p)}{\bquery_p} \neq \emptyset$. In addition, let $t \in \cans{(\Tmc_p,\Amc_p)}{\bquery_p}$.
     %
     In the \emph{left-to-right} direction of the proof of Claim 1, we show how to transform $\Amc_p$ into a $\Sigma$-ABox $\Amc$ that witnesses non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$.
     %
     In particular, $\Amc$ is obtained by performing two operations:
     %
     \begin{enumerate}
     	\item
     	Removing from $\Amc_p$ all assertions of the form $A_i(b)$ for some individual $b$ and $i \in \{1,\ldots,m\}$, and 
     	%
     	\item
     	Renaming all remaining occurrences of individual names $b_{k+i}$ ($1 \leq i\leq m$). 
     \end{enumerate}  
     %
     This can be done by iterating over all assertions occurring in $\Amc_p$ and checking for the occurrence of $A_i$ and $b_{k+i}$. Since $t$ is a tuple of $k+m$ elements and all individuals names $b_{k+i}$ occur in $t$, this iteration takes polynomial time in the size of $\Amc_p$ and $t$.
\end{proof}

\solvabilitykbalignment*

\begin{proof}
	%In the proof we use ``the size of the input'' to refer to the size of an instance of KB Alignment. Note that this corresponds to the input of Algorithm~\ref{alg:kb:alignment}, i.e., the KB $\Kmc$ and the query $\bquery$.	
	To see that KB Alignment is solvable in \emph{double exponential time}, we analyze the complexity of Algorithm~\ref{alg:kb:alignment}. In the following, we use $\mathcal{N}$ to denote the combined size of the KB $\Kmc$ and the query $\bquery$ in the input of Algorithm~\ref{alg:kb:alignment}.
	%
	Let us continue by analyzing each step of the algorithm.
	%
	\begin{itemize}				
		%
		\item
		As explained in the paper, the initial ABox $\Amc'$  can be selected as $\Amc_{\Tmc,\Sigma}$ when the input query $\bquery$ is pure, where $\Sigma=\sig(\Kmc)\cup\sig(\bquery)$. Then, testing whether $(\Tmc,\Amc')$ entails $\bquery$ can be done in \emph{double exponential time} in $\mathcal{N}$. The reason is that $\Amc_{\Tmc,\Sigma}$  can be of exponential size, and entailment for $\bcBCQ$ in $\alc$ is an ExpTime-complete problem.
		%
		
		In case $\bquery$ is \emph{non-pure}, the algorithm first checks whether $\bquery_p$ is non-empty for $\Sigma_p$ \wrt $\Tmc_p$. This can be done by looking directly at $\Amc_{\Tmc_p,\Sigma_p}$ and checking whether $\cans{(\Tmc_p,\Amc_{\Tmc_p,\Sigma_p})}{\bquery_p} \neq \emptyset$. The latter can be done in \emph{double exponential time} in $\mathcal{N}$: 
		%
		\begin{itemize}
			\item
			Since the increase of the size of $\Tmc_p$ and $\Sigma_p$ \wrt $\Tmc$ and $\Sigma$ is polynomial in the size of the input query $\bquery$, it follows that  the ABox $\Amc_{\Tmc_p,\Sigma_p}$ is of size (at most) exponential and can be computed in exponential time in $\mathcal{N}$. 
			%
			Therefore, checking whether $\cans{(\Tmc_p,\Amc_{\Tmc_p,\Sigma_p})}{\bquery_p} \neq \emptyset$ can be done in \emph{double exponential time} in $\mathcal{N}$.
		\end{itemize}
		
		If the  check $\cans{(\Tmc_p,\Amc_{\Tmc_p,\Sigma_p})}{\bquery_p}\neq \emptyset$ is positive, then there is $t\in \cans{(\Tmc_p,\Amc_{\Tmc_p,\Sigma_p})}{\bquery_p}$, which can be obtained while doing the check. Then, $\Amc'$ can be selected as the ABox that results from applying to $\Amc_{\Tmc_p,\Sigma_p}$ the transformation described in the proof of Lemma~\ref{lem:remove:individuals} \wrt the tuple $t$.
		%
		This transformation is polynomial in the size of $\Amc_{\Tmc_p,\Sigma_p}$ and $t$. Since the arity of $t$ is lineal in the size of the input query $\bquery$, it follows that the obtained ABox  is of size at most exponential in $\mathcal{N}$.
		%
		
		 Overall, we have shown that the initial ABox $\Amc'$ is of size at most exponential in $\mathcal{N}$, and that the first step of Algorithm~\ref{alg:kb:alignment} can be executed in \emph{double exponential time}.
		%		
		\item
		By definition of a trivial modification, the initial modification $\mods^*$ in Algorithm~\ref{alg:kb:alignment} is a sequence of the form 
		%
		\begin{equation*}
			\op_1\cdots \op_k \cdots \op_n,
		\end{equation*}
	%
	where $\op_1 \cdots \op_k$ consists of the removal of all assertions in $\Amc$ and $\op_{k+1} \cdots \op_n$ consists of the insertion of all assertions occurring in $\Amc'$. Hence, $\mods^*$ can be computed in exponential time in $\mathcal{N}$. Further, the magnitude of the number $\cost(\mods^*)$  is at most exponential in $\mathcal{N}$. 
	%
	%
	\item
	Regarding the set $M$, it satisfies the following (as analyzed in Subsetion~\ref{sub:sec:kb:alignment}):
	%
	\begin{itemize}
		\item
		Each ABox-modication $\mods$ in $M$ is defined over the finite signature $\sig(\Kmc) \cup \sig(\bquery)$ and satisfies $\cost(\mods) < \cost(\mods^*)$, and
		%
		%
		\item
		$M$ contains only modifications with no more than $\cost(\mods^*) / c$ ABox-operations, where $c$ is the minimal cost of 
		an ABox operation defined over $\sig(\Kmc) \cup \sig(\bquery)$.		
	\end{itemize}
     %
     Since the magnitude of $\cost(\mods^*)$ is at most exponential in $\mathcal{N}$, each modification $\mods \in M$ contains a number of ABox-operations that is at most exponential in $\mathcal{N}$. Moreover, since each ABox-operation is defined over a symbol in $\sig(\Kmc) \cup \sig(\bquery)$, $M$ can be enumerated in \emph{double exponential time} in the size of $\mathcal{N}$.
     %
     %
     \item
     In the enumeration of $M$, checking whether the conditional at Line~\ref{alg1:line:if} holds, amounts to:
     %
     \begin{itemize}
     	\item
     	applying $\mods$ to the input ABox $\Amc$ to obtain an ABox $\Amc^*$,
     	\item 
     	checking whether $(\Tmc,\Amc^*)$ is consistent and $(\Tmc,\Amc^*) \models \bquery$, and
     	%
     	\item
     	verifying whether $\cost(\mods) < \cost(\mods^*)$, where $\mods^*$ is the modification of minimal cost encountered so far along the enumeration.
     \end{itemize}
       %
       From the discussions in the previous points, $\Amc^*$ is of size at most exponential and can be computed in exponential time in $\mathcal{N}$.
       %
       Moreover, since knowledge base consistency and entailment of $\bcBCQ$ can be checked in exponential time for $\alc$, then checking whether $(\Tmc,\Amc^*)$ is consistent and $(\Tmc,\Amc^*) \models \bquery$ can be done in \emph{double exponential time} in $\mathcal{N}$. Finally, since the magnitude of $\cost(\mods)$ and $\cost(\mods^*)$ are not greater than the initially computed upper bound, checking whether $\cost(\mods) < \cost(\mods^*)$ holds is not more costly than \emph{double exponential time}.
      %              
 	\end{itemize}
    
     Therefore, taking into account the previous analysis, we can conclude that Algorithm~\ref{alg:kb:alignment} runs in \emph{double exponential time} in $\mathcal{N}$. Thus, KB Alignment can be solved in \emph{double exponential time}.
\end{proof}

%\begin{proof}
%	Let $x_1,\ldots,x_k$ be the free variables of $\bquery$ and $a_1,\ldots,a_m$ the individual names occurring in $\bquery$. Then, $\bquery_x$ has $k+m$ free variables, i.e.
%	%
%	\begin{equation*}
%		\fvarsq(\bquery_x) =\{x_1,\ldots,x_k\} \cup \{x_{a_1},\ldots,x_{a_m}\},
%	\end{equation*}
%	%
%	where each $x_{a_i}$ is fresh variable not occurring in $\bquery$.  We represent the free variables as the ordered tuple $(x_1,\ldots,x_k, x_{a_1},\ldots,x_{a_m})$.
%	
%    Let us start by showing the two implications in the first claim of the lemma.
%	
%	($\Rightarrow$) Assume that $\bquery_x$ is non-empty for $\Sigma$ \wrt $\Tmc$. Hence, there exists a $\Sigma$-ABox $\Amc_x$ such that  $(\Tmc,\Amc_x)$ is consistent and  $\cans{(\Tmc,\Amc_x)}{\bquery_x} \neq \emptyset$. This gives us a tuple $t=(b_1,\ldots,b_{k+m})\in \ind(\Amc_x)^{k+m}$ such that $t \in \cans{(\Tmc,\Amc_x)}{\bquery_x}$.
%	%
%	Since neither $\bquery_x$ nor $\Tmc$ contain individual names, we can assume that $\Amc_x$ contains no individuals from $\ind(\bquery)=\{a_1,\ldots,a_m\}$.		
%	%The individuals $b_1,\ldots,b_k$ are assigned to $x_1,\ldots,x_k$, whereas $b_{k+1},\ldots,b_{k+m}$ are assigned to the variables $x_{a_1},\ldots,x_{a_m}$.
%	%
%	
%	
%	
%	
%	Based on this, the goal is to build a $\Sigma$-ABox $\Amc$ that witness non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$. To this end, we first need to extend $\Amc_x$ into a $\Sigma$-ABox $\Amc'_x$ that also witnesses non-emptiness of $\bquery_x$. We will then use $\Amc'_x$ to define $\Amc$.
%	
%	Let us continue with the construction of $\Amc'_x$, which requires to introduce the following notions. The tuple $t$ defines an equivalence relation $R_t$ over $\{x_{a_1},\ldots,x_{a_m}\}$ as follows:
%	%
%	\begin{equation}\label{equiv:relation:t}
%		R_t := \{(x_{a_i},x_{a_j}) \mid 1 \leq i,j \leq m \land b_{k+i} = b_{k+j}\}.
%	\end{equation}
%  %
%  Further, let $S$ be the set of atoms of the form $r(x_{a_i},x_{a_j})$ occurring in $\bquery_x$ such that $r\in \Sigma$, $i\neq j$ and $(x_{a_i},x_{a_j}) \in R_t$. We select a subset $S_m \subseteq S$ of maximal size satisfying the following property:
%   %
%   \begin{itemize}
%   	   \item
%   	   There is a model $\Imc$ of $(\Tmc,\Amc_x)$ such that:
%   	   %
%   	   \begin{equation}\label{loop:property}
%   	   	\text{ for all } r(x_{a_i},x_{a_j}) \in S_m:\ \ (b_{k+i}^\I,b_{k+i}^\I) \in r^\I.
%   	   \end{equation} 
%   \end{itemize}
%   %
%   Then, the ABox $\Amc'_x$ is defined as:
%   %
%   \begin{equation*}
%   	  \Amc'_x = \Amc_x \cup \{r(b_{k+i},b_{k+i}) \mid r(x_{a_i},x_{a_j}) \in S_m\}
%   \end{equation*}
%   %
%   The following observations follow from the definition of $\Amc'_x$:
%   %
%   \begin{itemize}
%   	  \item
%   	  $\Amc'_x$ is a $\Sigma$-ABox. Note the each new assertion $r(b_{k+i},b_{k+i})$ comes from $r(x_{a_i},x_{a_j}) \in S_m$, which means that $r \in \Sigma$.
%   	  %
%   	  %
%   	  \item
%   	  $(\Tmc,\Amc'_x)$ is consistent. A witness for this is the model $\Imc$ of $(\Tmc,\Amc_x)$ used to select $S_m$. It satisfies the new assertions in $\Amc'_x$, because it satisfies \eqref{loop:property}.
%   	  %
%   	  %
%   	  \item
%   	  $t \in \cans{(\Tmc,\Amc'_x)}{\bquery_x}$. This follows from that  fact that every model of $\Amc'_x$ is a model of $\Amc_x$ and that $t \in \cans{(\Tmc,\Amc_x)}{\bquery_x}$.
%   \end{itemize}
%   %
%   Hence, $\Amc'_x$ also witnesses non-emptiness of $\bquery'$ for $\Sigma$ \wrt $\Tmc$. We are now ready to define the ABox $\Amc$.
%   %
%   Let $B$ be the following subset of individuals of $\Amc'_x$:
%   %
%   \begin{equation*}
%   	   B = \{b \in \ind(\Amc'_x) \mid b \neq b_{k+i} \text{ for all } i \in \{1,\ldots,m\}\}.
%   \end{equation*}
%    %
%    The ABox $\Amc$ is obtained from $\Amc'_x$, $t$ and $R_t$ as follows.
%   	%
%   	\begin{itemize}
%   		\item
%   		The following set of concept assertions:
%   		 %
%   		 \begin{multline*}
%   		 	\{A(b) \mid A(b) \in \Amc'_x, \land\ b \in B\}  \cup \\[.2em]
%   		 	%
%   		 	\{A(a_j) \mid A(b_{k+i}) \in \Amc'_x, (x_{a_i},x_{a_j}) \in R_t \land 1 \leq i,j \leq m\}.
%   		 	%   		 	
%   		 \end{multline*} 
%   		%
%   		\item
%   		The following set of role assertions:
%   		%
%   		\begin{multline*}
%   			\{r(b,c) \mid r(b,c) \in \Amc'_x \land b,c\in B \} \cup \\[.2em]   			
%   			%
%   			\{r(b,a_j) \mid r(b,b_{k+i}) \in \Amc'_x, (x_{a_i},x_{a_j}) \in R_t, b \in B\} \cup\\[.2em]
%   			%
%   			\{r(a_j,b) \mid r(b_{k+i},b) \in \Amc'_x, (x_{a_i},x_{a_j}) \in R_t, b \in B\} \cup\\[.2em]
%   			%
%   			\{r(a_i,a_j) \mid r(b_{k+p},b_{k+\ell}) \in \Amc'_x,  (x_{a_i},x_{a_p}) \in R_t,  (x_{a_j},x_{a_\ell}) \in R_t, \}
%   		\end{multline*}
%   		%
%   	\end{itemize}
%   
%   We show that $\Amc$ witnesses non-emptiness of $\bquery$ for $\Sigma$ \wrt $\Tmc$. To see that $(\Tmc,\Amc)$ is consistent, consider a model $\Imc$ of $(\Tmc,\Amc'_x)$. We extend $\Imc$ to interpret the individual names $a_i$ as:
%  \begin{itemize}
%  		\item
%          $a_i^\Imc = b_{k+i}^\Imc$ ($1 \leq i \leq m$).                    \
%   \end{itemize} 
%    %
%    Note that this does not change the interpretation of the individual names in $\Amc'_x$, since $a_i \not\in \ind(\Amc'_x)$. Further, since no individual name occurs in $\Tmc$, the extended $\Imc$ is still a model of $\Tmc$. 
%    %
%    To see that $\Imc \models \Amc$ as well, we consider the possible forms of the assertions in $\Amc$.
%    %
%    \begin{itemize}
%    	\item
%    	For assertions of the form $A(b) \in \Amc$ for some $b \in B$, we have that $A(b)\in \Amc'_x$. Hence, $\Imc \models \Amc'_x$ implies that $b^\Imc \in A^\Imc$.
%    	%
%    	In case $A(a_j) \in \Amc$, the construction of $\Amc$ yields that $A(b_{k+i}) \in \Amc'_x$ for some $i \in \{1,\ldots,m\}$ such that $(x_{a_i},x_{a_j}) \in R_t$. This means that $b_{k+i}^\I \in A^\Imc$ (since $\Imc \models \Amc'_x$), and that $b_{k+i}=b_{k+j}$ (see \eqref{equiv:relation:t}).
%    	%
%    	Thus, since $a_j^\Imc = b_{k+j}^\Imc$, it follows that $a_j^\Imc \in A^\Imc$.
%    	%
%    	\item
%    	\textcolor{red}{the roles...}
%    \end{itemize}    
%     %
%     Hence, $(\Tmc,\Amc)$ is consistent. 
%     
%     It remains to see that $\cans{(\Tmc,\Amc)}{\bquery} \neq \emptyset$.   
%     %
%     To this end, we show that $(b_1,\ldots,b_k) \in \cans{(\Tmc,\Amc)}{\bquery}$. Let $\Jmc$ be an arbitrary model of $(\Tmc,\Amc)$. It is enough to prove that 
%     	\begin{equation}\label{eq:ent:to:show}
%     		\Jmc \models \bquery[(b_1,\ldots,b_k)].
%     	\end{equation}
%      %
%      For each equivalence class $[x_{a_j}]$ of $R_t$, we define the interpretation in $\Jmc$ of $b_{k+j}$ as 
%      %
%      \begin{equation*}
%      	b_{k+j}^\J = a_j^\J,
%      \end{equation*}
%       %
%       where $x_{a_j}$ is a fixed representative of $[x_{a_j}]$. The rest of the proof consists of showing that $\Jmc$ is a model of $(\Tmc,\Amc'_x)$ and use the fact that $t \in \cans{(\Tmc,\Amc'_x)}{\bquery_x}$ to show that \eqref{eq:ent:to:show} is true.
%       
%       It is obvious that $\Jmc$ remains a model of $\Tmc$. To see that it is a model of $\Amc'_x$, we look at the possible form of the assertions in $\Amc'_x$.
%       %
%       \begin{itemize}
%       	\item
%       	$A(b) \in \Amc'_x$ or $r(b,c) \in \Amc'_x$, where $b,c \in B$. In both cases, the assertions $A(b)$ and $r(b,c)$ belong to $\Amc$. Since $b,c \in B$ and $\Jmc \models (\Tmc,\Amc)$, it follows that $\Jmc$ satisfies these type of assertions.
%       	%
%       	%
%       	\item
%       	$A(b_{k+i}) \in \Amc'_x$ for some $i \in \{1,\ldots,m\}$. Let $x_{a_j}$ be the fixed representative of the equivalence class for $x_{a_i}$. By construction of $\Amc$, we have that $A(a_j) \in \Amc$, since $(x_{a_i},x_{a_j})\in R_t$. 
%       	%
%       	This implies that $a_j^\Jmc \in A^\Jmc$. Thus, since $b_{k+i}=b_{k+j}$ and $b_{k+j}^\Jmc = a_j^\Jmc$, it follows $b_{k+i}^\Jmc \in A^\Jmc$.
%       	%
%       	%
%       	\item
%       	$r(b_{k+p},b_{k+\ell}) \in \Amc'_x$ for some  $p,\ell \in \{1,\ldots,m\}$. Let $x_{a_i}$ and $x_{a_j}$ be the fixed representatives of the equivalence classes for $x_{a_p}$ and $x_{a_\ell}$, respectively. Again, the construction of $\Amc$ tells us that $r(a_i,a_j) \in \Amc$. This implies that $(a_i^\Jmc,a_j^\Jmc) \in r^\Jmc$, since $\Jmc \models \Amc$.
%       	%
%       	Thus, the same argument used in the previous case yields that $(b_{k+p}^\Jmc,b_{k+\ell}^\Jmc) \in r^\Jmc$.
%       	%
%       	%
%       	\item
%       	$r(b,b_{k+i}) \in \Amc'_x$ or $r(b_{k+i},b) \in \Amc'_x$. This case can be shown similarly to the previous cases.
%       \end{itemize}
%       
%       Overall, we have shown that $\Jmc \models (\Tmc,\Amc_x')$. Hence, since $t \in \cans{(\Tmc,\Amc'_x)}{\varphi_x}$, we have that:
%       %
%       \begin{equation*}
%       	\Jmc \models \bquery_x[(b_1,\ldots,b_k,b_{k+1},\ldots,b_{k+m})].
%       \end{equation*}
%      
%\end{proof}