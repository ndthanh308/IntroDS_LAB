%!TEX root = ecai-main.tex


\section{The TKB Alignment Problem}
\label{sec:tkb-align}

We generalize the verification problem of TQE
to a \emph{synthesis} version, consisting
in \emph{minimally} modifying the sequence 
$\Aseq$ of a TKB $\tkb=(\Tmc,\Aseq)$, 
to obtain a TKB $\tkb'=(\Tmc,\Aseq')$, s.t.~$\tkb'\models\tquery$. 
%% 
Observe that if $\tkb\models\varphi$, the problem amounts to checking TQE.
%%
To define the problem, we  formalize next the notions of ABox- and TKB-modification, and minimality.

To modify the ABoxes occurring in a TKB, we consider two kinds of ABox operations, namely 
\emph{insertion} and \emph{removal} of a (concept or role) assertion $\assert$, 
respectively denoted as $\ins{\alpha}$ and $\rem{\alpha}$.
%
The result of applying such operations to an ABox $\Amc$ is given by the function $\apply$:
\begin{inparaenum}[(\it i)]
    \item $\apply(\ins{\assert}, \Amc) =\Amc\cup\set{\assert}$;
    \item $\apply(\rem{\assert}, \Amc) =\Amc\setminus\set{\assert}$.
\end{inparaenum}
%
An \emph{ABox-modification} is a (possibly empty) sequence $\mods=\op_0\cdots \op_n$ of ABox operations 
$\op_i$. By $\emptymods$ we denote the empty ABox-modification.
%
The semantics of applying an ABox-modification $\mods$ to an ABox $\Amc$ is obtained by 
inductively extending $\apply$ to sequences of operations: 
%
\begin{inparaenum}[(\it i)]
	\item $\apply(\emptymods, \Amc) = \Amc;$
	\item $\apply(\op\sep\mods,\Amc) = \apply(\mods,\apply(\op,\Amc))$, where $\sep$ is the concatenation operator.
\end{inparaenum}

We assume every operation $\op$ has a strictly positive cost $\cost(\op)\in\mathbb{R^+}$.
The \emph{cost} of an ABox-modification 
$\mods=\op_1\cdots \op_n$ is defined as 
$\cost(\mods) :=\sum_{i=1}^n \cost(\op_i)$, with $\cost(\emptymods)=0$.

In addition to modifying its ABoxes, 
a TKB can be modified by adding or removing ABoxes.
Let $\atmods=\set{\fix{\mods},\add{\mods}, \del \mid \mods \text{ is an ABox-modification}}$
be the set of \emph{atomic TKB-modifications}. 
Intuitively, 
$\fix{\mods}$ stands for the modification of an ABox through the application of $\mods$,
$\add{\mods}$ for the addition of the empty ABox followed by the application of $\mods$, 
and $\del$ for ABox deletion. 

A \emph{TKB-modification} is a finite sequence $\tmods$ of atomic TKB-modifications, with $\emptymods$ denoting the empty TKB-modification.
Notice that,  by a slight abuse of notation, we use $\emptymods$ to denote both the empty ABox-modification and the empty TKB-modification; the intended 
meaning is clear from the context.
%%

The result of applying a TKB-modification 
$\tmods$ to a sequence %of ABoxes 
$\Aseq=\Amc_0\cdots\Amc_\ell$ is the sequence $\apply(\tmods,\Aseq)$, % of ABoxes, 
inductively defined as follows, where 
$\emptyAseq$ denotes the empty sequence of ABoxes,
$\emptyA$ the empty ABox, and $\Amc|\Aseq=\Amc\Amc_0\cdots\Amc_\ell$:

\begin{itemize}
    \item $\apply(\varepsilon,\Aseq) = \Aseq$;
  
    \item $\apply(\fix{\mods}, \emptyAseq) = \emptyAseq$;
  
    \item $\apply(\fix{\mods} \sep \tmods, \Amc|\Aseq) = \apply(\mods,\Amc)|\apply(\tmods,\Aseq)$;
    \item $\apply(\add{\mods}\sep\tmods, \Aseq) = \apply(\mods,\emptyA)|\apply(\tmods,\Aseq)$;
	
	\item $\apply(\del \sep \tmods, \emptyAseq)) = \apply(\tmods, \emptyAseq)$;
	
	\item $\apply(\del \sep \tmods, \Amc|\Aseq) = \apply(\tmods, \Aseq)$.
\end{itemize}
%%
For a given TKB $\tkb = (\Tmc, \Aseq)$ and a TKB-modification $\tmods$, 
we define $\apply(\tmods,\tkb) = (\Tmc, \apply(\tmods, \Aseq))$.
%%
The cost function naturally extends to TKB-modifications and ABox sequences:
%%
\begin{itemize}
	\item $\cost(\emptytmods, \Aseq) = 0$;
	\item $\cost(\fix{\mods} \sep \tmods, \emptyAseq) = \cost(\tmods,\emptyAseq)$;
	\item $\cost(\fix{\mods} \sep \tmods, \Amc|\Aseq) = \cost(\mods) + \cost(\tmods,\Aseq)$;
	\item $\cost(\add{\mods} \sep \tmods, \Aseq) = 1+ \cost(\mods) + \cost(\tmods,\Aseq)$;
	\item $\cost(\del \sep \tmods, \emptyAseq) = \cost(\tmods, \emptyAseq)$;
	\item $\cost(\del \sep \tmods, \Amc|\Aseq) = \big(\sum_{\assert \in \Amc} \cost(\rem{\assert})\big) + 1 + \cost(\tmods, \Aseq)$.
\end{itemize}
The cost of $\add{\mods}$ is that of adding the empty ABox (taken as 1) and applying $\mods$ to it; similarly, the cost of $\del$ is that of emptying 
the ABox, by removing all of its assertions, and removing the resulting empty ABox (i.e., 1).
For a TKB $\tkb=(\Tmc,\Aseq)$ and a TKB-modification $\tmods$, we let $\cost(\tmods,\tkb) =\cost(\tmods,\Aseq)$.

We can now introduce the TKB-alignment problem.
%%
\begin{definition}[TKB Alignment] \label{def:tkb-alignment}
Given a \TKB $\tkb$ and a TCQ $\varphi$, %% s.t.~$\tkb \not \models \varphi$, 
the \emph{\TKB-alignment} problem
 consists in finding a minimal-cost TKB-modification $\tmods^*$ (if any) 
s.t.~$\apply(\tmods^*,\tkb) \models \varphi$.
\end{definition}
%%

Observe that, for every TKB-modification $\tmods$ and TKB $\tkb$, 
it holds that $\apply(\tmods,\tkb) = \apply(\tmods \cdot \fix{\epsilon},\tkb)$ and
$\cost(\tmods, \tkb) = \cost(\tmods \cdot \fix{\epsilon}, \tkb)$.
That is, appending a sequence of $\fix{\epsilon}$ to $\tmods$ does not affect the result or
the cost of modifying $\tkb$.
Thus, we can always extend $\tmods$ 
to guarantee that the combined number of occurrences of 
deletions $\del$ and fixes $\fix{\mods}$ in $\tmods$ equals at least the number of ABoxes in $\Aseq$.
For technical convenience, from now on, we assume this is the case for every 
$\tmods$.

\subsection{Solving TKB Alignment}
% \anni{Wouldn't it be the better structure to first describe the \enquote{decomposition} into propositional abstraction and inner part and then get to the automata constructions?}

Our solution approach consists in reducing TKB Alignment to Shortest Path. To this end, we construct a graph, called \emph{Minimal-instantiation Graph}, with each edge labelled by an atomic TKB-modification 
and its corresponding cost, s.t.~every shortest path from a suitably defined \emph{initial} node to one node from a (suitably defined) \emph{target} set, represents an optimal solution to the original TKB Alignment instance.
The construction of such a graph is based on several intermediate structures, which we present and discuss next.

Consider a TKB $\tkb=(\Tmc,\Aseq)$ and a TCQ $\tquery$. We start with the construction of a DPA intended to accept the set of models of $\tquery$.
%%Observe that, since traces are sequences of FO interpretations, which are infinitely many (for infinite $\Delta$),
%%such a DPA cannot exist, as DPAs have finite input alphabets.
To this end, we adopt an approach similar to that of~\cite{BaaderBL15}, which uses
the  \emph{propositional abstraction} of $\tquery$.
%
%%Let $\bcqs(\tquery)$ be the (finite) set  of \bcq s occurring in $\tquery$.
If we view every \bcq~$\query\in\PBCQ$ as a proposition $\pquery$, then $\tquery$ can be viewed as an \ltl formula.
This is called the \emph{propositional abstraction} of $\tquery$, denoted $\ptquery$.
%%, and let $\pBCQ$ be the set of all propositionalized \bcq s from $\BCQ$.
Obviously, $\props(\ptquery)$ is the set of all propositions $\pquery$ occurring 
in $\ptquery$, each corresponding to exactly one BCQ $\query\in\PBCQ$.

Since $\ptquery\in\ltl$, we can now use the \buchi automaton (BA) construction 
of~\cite{Var95}, to obtain a BA that recognizes $\L(\ptquery)$ and then use the 
BA-to-DPA construction of~\cite{Pit07} to obtain the 
DPA $\PA_{\ptquery}=(2^{\props(\ptquery)},Q,q_0,\delta,\col)$ of $\ptquery$.
%%
The importance of $\PA_{\ptquery}$ lies in the fact that, 
although it reads input words $\word=\Phi_0 \Phi_1 \cdots\in {(2^{\props(\ptquery)})}^\omega$
and not FO traces $\seqI=\Imc_0\Imc_1\cdots$, it fully characterizes $\L(\varphi)$, 
as discussed below.

For $\Phi\in 2^{\props(\ptquery)}$, let 
$\chformula(\Phi)=\bigwedge_{\pquery \in \Phi} \query \wedge \bigwedge_{\pquery \in \props(\ptquery) \setminus \Phi} \neg \query$.
Since the conjuncts in $\chformula(\Phi)$ are possibly negated \bcq s from $\PBCQ$, and
not propositional abstractions,
$\chformula(\Phi)\in\bcBCQ$.
If $\chformula(\Phi)$ is consistent, i.e., admits at least one model,
$\Phi$ is called a \emph{type}.
When $\Imc\models\chformula(\Phi)$, we call $\Phi$ the \emph{type} of $\Imc$. 
This notion naturally extends to traces by
defining the \emph{trace type} of a FO trace 
$\seqI=\Imc_0\Imc_1\cdots$ 
as the word $\word=\Phi_0\Phi_1\cdots\in{(2^{\props(\ptquery)})}^\omega$ 
s.t.~$\Phi_i$ is the type of $\Imc_i$, for all $i\geq 0$.
%%
We have the following result.

\begin{restatable}{lemma}{typing}
	\label{lem:typing}
    Every FO interpretation has a unique type and every type admits an FO interpretation.
    Moreover, 
    every FO trace has a unique trace type and every trace type admits an FO trace.
\end{restatable}
The following result relates $\L(\PA_{\ptquery})$ and $\L(\tquery)$.
%
\begin{restatable}{theorem}{thmbridge}\label{thm:bridge}
Consider a TCQ $\tquery$.
For every FO trace $\seqI$ of type $\word$, 
it holds that $\seqI\in\L(\tquery)$ iff $\,\word\in\L(\PA_{\ptquery})$.
\end{restatable}
%%This result allows us to see $\PA_{\ptquery}$ as an automaton accepting $\L(\tquery)$.
%%Indeed, given $\seqI$, checking whether $\seqI\in\L(\tquery)$ is equivalent to checking
%%whether the type $\word$ of $\seqI$ is s.t.~$\word\in\L(\PA_{\ptquery})$.
%%Thus, given a trace $\seqI$, we say that $\PA_{\ptquery}$ \emph{accepts} $\seqI$ iff
%%$\PA_{\ptquery}$ accepts the type $\word$ of $\seqI$. In this sense, we can 
%%say that $\PA_{\ptquery}$ recognize $\L(tquery)$.


Since $\PA_{\ptquery}$ is independent of $\tkb$, it cannot 
be used to search for the desired minimal-cost modification.
For this, we can use a deterministic finite-state automaton (DFA) 
$\DFA$,
called the \emph{repair-template} DFA for $\tkb$ and $\tquery$.
The definition of $\DFA$ requires an auxiliary DPA, 
called the $\Tmc$-\emph{reduct} of $\PA_{\ptquery}$, 
to define the final states of $\DFA$.


\begin{definition}[$\Tmc$-reduct of $\PA_{\ptquery}$]\label{def:reduct}
Given a TBox $\Tmc$ and a TCQ $\tquery$, let 
$\PA_{\ptquery}=(2^{\props(\ptquery)},Q,\delta,q_0,\col)$. 
The $\Tmc$-reduct of $\PA_{\ptquery}$ 
is the DPA 
$\PA_{\ptquery}^{\Tmc}=(2^{\props(\ptquery)},Q^\Tmc,\delta^{\Tmc},q_0,\col^{\Tmc})$ 
s.t.:
\begin{itemize}
	\item $Q^\Tmc=Q\cup\set{q^*}$, with $q^*\notin Q$;
	\item $\delta^\Tmc(q,\Phi)=q'$, iff either:
		\begin{itemize}
			\item $\chformula(\Phi)$ is satisfiable wrt $\Tmc$ and $\delta(q,\Phi)=q'$; or
			\item $\chformula(\Phi)$ is not satisfiable wrt $\Tmc$ and $q'=q^*$; or
			\item $q=q'=q^*$;
		\end{itemize}
	\item $\col^\Tmc(q^*)=1$ and $\col^{\Tmc}(q)=\col(q)+1$, for all $q\in Q$.
\end{itemize}
\end{definition}
%%

\begin{restatable}{lemma}{reductcomplexity}\label{lem:t-reduct-complexity}
The $\Tmc$-reduct of $\PA_{\ptquery}$ can be computed in doubly exponential time and has doubly exponential size wrt \tquery.
\end{restatable}


Intuitively, the $\Tmc$-reduct of $\PA_{\ptquery}$ accepts a 
trace type $\word$ iff there exists a FO trace $\seqI$ of type $\word$ 
that does not satisfy $\tquery$ and contains only interpretations satisfying $\Tmc$.
%%
Let $\Acc(\PA^\Tmc_{\ptquery})$ be the acceptance set of $\PA^\Tmc_{\ptquery}$. We have the following.

\begin{restatable}{lemma}{lemtail}\label{lem:tail}
	
	Consider a finite sequence $\word'=\Phi_0 \cdots \Phi_{k - 1}$ of 
	types and 
	the finite run $\ppath=q_0 \trans{\Phi_0} \cdots \trans{\Phi_{k - 1}}q_k$ induced in $\PA_{\ptquery}$.
	Then,  
	$q_k \notin \Acc(\PA^\Tmc_{\ptquery})$ iff
	for every type $\word = \Phi_0 \cdots \Phi_{k - 1} \Phi_{k} 
	\Phi_{k + 1} \cdots$, having $\word'$ as a prefix, and for all 
	traces $\seqI = \Imc_0 \Imc_1 \cdots$ 
	of type $\word$, if, for all $i \geq k$, it holds that 
	$\Imc_i\models\Tmc$, then $\seqI \models \tquery$.
		
\end{restatable}
%%
Recall that we are looking for a TKB $\tkb' = (\Tmc, \Aseq' = \Amc_0\cdots\Amc_{\ell'})$, 
obtained as modification of $\tkb=(\Tmc,\Aseq)$, 
s.t.~$\tkb' \models \tquery$, i.e., all models $\seqI$ of $\tkb'$ 
(Def.~\ref{def:tkb-model}) are s.t.~$\seqI \models \tquery$ (Def.~\ref{def:tcq-entailment}).
%%
Lemma~\ref{lem:tail} implies that every model $\seqI$ of $\tkb'$ must belong to some trace type $\word_{\seqI}$ whose induced run in $\PA_{\ptquery}$ touches some $q_k \notin \Acc(\PA^\Tmc_{\ptquery})$, for $k = \ell' + 1$.
%%
Based on this, we next define the \emph{repair-template} DFA.
%%
\begin{definition}[Repair-template DFA]\label{def:rtdfa}
	Given a TKB $\tkb=(\Tmc,\Aseq)$ with $\Aseq=\Amc_0\cdots\Amc_\ell$ 
	and a TCQ $\tquery$, let $\PA_{\ptquery}^{\Tmc}=(2^{\props(\ptquery)},Q^\Tmc,\delta^{\Tmc},q_0,\col^{\Tmc})$ 
	be the $\Tmc$-reduct of $\PA_{\ptquery}=(2^{\props(\ptquery)},Q,\delta,q_0,\col)$.

	The \emph{repair-template DFA (RT-DFA) for $\tkb$ and $\tquery$} is the 
	DFA $\DFA=(\alphabet,S,s_0,\gamma,F)$ s.t.:
	\begin{itemize}
		\item $\alphabet= (\set{\fixsym,\addsym}\times2^{2^{\props(\ptquery)}})\cup\set{\delsym}$ is the alphabet;
		\item $S=2^Q\times\set{0,\ldots,\ell+1}$ is the set of states;
		\item $s_0=(\set{q_0},0)$ is the initial state;
		\item $\gamma: S \times \alphabet \ra S$ is the transition function 
		s.t.~$\gamma((Z,i),X)=(Z',i')$ iff either:
			\begin{enumerate}[leftmargin=*]
			    \item 
			        $X=\delsym$, $Z=Z'$, and $i'=\min\set{i + 1, \ell + 1}$; or
			\item all of the following hold:
				\begin{enumerate}
					\item\label{it:dfa-1} $X=(\sigma,\Upsilon)$, with $\sigma\in\set{\fixsym,\addsym}$;
					\item $q'\in Z'$ iff $\delta(q,\Phi)=q'$, for $q\in Z$ and $\Phi\in\Upsilon$;
					\item\label{it:dfa-2} there exists an ABox $\Amc$ consistent with $\Tmc$ s.t.:
					$(\Tmc,\Amc)\models 
	                        			\bigvee_{\Phi \in \Upsilon}\chformula(\Phi)\land
	                        			\bigwedge_{\Phi \not\in \Upsilon}\lnot\chformula(\Phi)$;
    			        		\item $i'=
							\begin{cases}
								\min\set{i+1,\ell+1}, \text{ if } \sigma=\fixsym\\
								i, \text{ if } \sigma=\addsym
							\end{cases}
						$
				\end{enumerate}
			\end{enumerate}
		\item $F = \set{(Z, \ell + 1) \in S \mid Z\cap\Acc(\PA_{\ptquery}^{\Tmc})=\emptyset}$ is
			the set of final states.
	\end{itemize}
\end{definition}
%%

\begin{restatable}{lemma}{rtdacomplexity}\label{lem:rtda-complexity}
The RT-DFA for a TKB  $\tkb$ and a TCQ $\tquery$ can be computed in triply exponential time and has triply exponential size wrt $\tquery$.
\end{restatable}

Observe that the right-hand side expression of the entailment ($\models$) in
Item~\ref{it:dfa-2} above is a Boolean combination of \bcq s.
The purpose of the RT-DFA is to capture the solution space of TKB Alignment for 
$(\Tmc,\Aseq)$ and $\tquery$, in the following sense:
\begin{inparaenum}[(\it i)]
    \item from every accepted word $w$, some TKB modification $\tmods$ can be derived s.t.~$\apply(\tmods, \tkb) \models \tquery$,
    and
    \item every TKB modification $\tmods$ s.t.~$\apply(\tmods, \tkb) \models \tquery$ can be derived from some accepted word $w$.
\end{inparaenum}
This is formalized next, by the notion of TKB-modification \emph{abstraction} and the subsequent result.
%%
\begin{definition}[TKB-modification abstraction]
		\label{def:abstraction}
    Consider a TKB $\tkb=(\Tmc, \Aseq)$, with $\Aseq = \Amc_0 \cdots \Amc_\ell$,
    a TCQ $\tquery$, and let $\DFA = (\alphabet, S, s_0, \gamma, F)$ 
    be the RT-DFA for $\tkb$ and $\tquery$.
    %%
    A word $w=w_0\cdots w_m\in\alphabet^*$, 
    inducing a finite run $\ppath=s_0\trans{w_0}\cdots\trans{w_{m}}s_{m+1}$
    in $\DFA$,
    is an \emph{abstraction} of 
    (or \emph{abstracts}) a TKB-modification
    $\tmods=\tmods_0\cdots\tmods_m$ iff, 
    for $j=0,\ldots, m$: 
    
        \begin{itemize}
            \item $w_j=\delsym$ and $\tmods_j = \del$; or
            
            \item
            $w_j = (\fixsym, \Upsilon)$ and, for $s_j=(Z,i)$,
            $\tmods_j=\fix{\mods}$, 
            with $(\Tmc, \apply(\mods, \Amc_i))\models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi)\land
            \bigwedge_{\Phi \not\in \Upsilon} \lnot\chformula(\Phi)$; or
            
            \item 
            $w_j = (\addsym, \Upsilon)$ and
            $\tmods_j=\add{\mods}$, 
            with $(\Tmc, \apply(\mods, \emptyA))\models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi)\land
            \bigwedge_{\Phi \not\in \Upsilon} \lnot\chformula(\Phi)$.
        \end{itemize}
        When this holds, $\tmods$ is an \emph{instantiation} of (or \emph{instantiates}) $w$.
\end{definition}

\begin{restatable}{theorem}{thmsoundcompl}\label{thm:rt-sound-compl}
	Consider a TKB $\tkb=(\Tmc,\Aseq)$, with $\Aseq=\Amc_0 \cdots \Amc_\ell$,
	a TCQ $\tquery$, and let $\DFA=(\alphabet,S,s_0,\gamma,F)$ 
	be the RT-DFA for $\tkb$ and $\tquery$.
	Then:
	\begin{enumerate}
		\item
			for every word $w \in \alphabet^*$, there exists an instantiation $\tmods$ s.t.~$w \in \L(\DFA)$ iff $\apply(\tmods,\tkb) \models \tquery$;
		\item%~\label{it:sound-comp-2}
			for every word $w \in \alphabet^*$ and every instantiation $\tmods$ of $w$,  it holds that $w \in \L(\DFA)$ iff $\apply(\tmods,\tkb) \models \tquery$;
		\item
			for every TKB-modification $\tmods$ there exists a unique abstraction $w_\tmods$ s.t.~$w_\tmods \in \L(\DFA)$ iff $\apply(\tmods,\tkb) \models \tquery$.
	\end{enumerate}
\end{restatable}
%%
%In other words, $\L(\DFA)$ partitions the set of solutions in such a way that a solution $\tmods$ belongs to the cell of a word $w$ iff $\tmods$ instantiates $w$.

Thm.~\ref{thm:rt-sound-compl} states that the language of $\DFA$ 
characterizes the set of solutions for the TKB-alignment of $\tkb$ against the 
specification $\tquery$; in particular, Item~2 ensures that every 
instantiation of some TKB-modification abstraction 
$w \in \L(\DFA)$ is a solution to TKB Alignment. 
Then, every optimal solution $\tmods^*$ is s.t.:

\begin{center}
	$\tmods^*=\argmin_\eta\set{\cost(\tmods,\tkb)\mid\tmods\text{ instantiates some } w\in\L(\DFA)}$.
\end{center}

Based on this, we can reduce the problem of finding $\tmods^*$ to that of finding a minimal path in a suitably weighted graph.

\begin{definition}[Minimal-instantiation Graph]\label{def:mmg}
	Consider a TKB $\tkb=(\Tmc,\Aseq)$, with $\Aseq = \Amc_0 \cdots \Amc_\ell$, a TCQ $\tquery$, and let $\DFA = (\alphabet, S, s_0, \gamma, F)$ be the RT-DFA for $\tkb$ and $\tquery$.
	The \emph{minimal-instantiation graph} for $\tkb$ and $\tquery$ is the weighted graph $\MMG = (N, E, \weight)$, where:
\begin{enumerate}
	\item
		$N = S$ is the finite set of nodes;
	\item
		$E \subseteq N \times \atmods \times N$, is the finite set of edges, labelled by atomic TKB-modifications;
	\item
		$\weight:E \ra \mathbb{R}^+$ is the edge weight function;
	\item\label{it:mmg-1}
		it holds that $e=((Z,i),\tmods,(Z', i'))\in E$ and $\weight(e)=c$ iff, for some $X$, $(Z',i')=\gamma((Z,i), X)$, and:
	\begin{itemize}[leftmargin=*, label=-]
		\item
			if $X = \delsym$ then $\tmods = \del$ and $c = \cost(\del,\Amc_i)$;
		\item
			if $X = (\fixsym, \Upsilon)$ then $\tmods = \\ \argmin_{\fix{\mods}} \bigset{\cost(\fix{\mods}, \Amc_i) \mid (\Tmc, \apply(\mods, \Amc_i)) \models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi) \land \bigwedge_{\Phi \not\in \Upsilon} \lnot \chformula(\Phi)}$ and $c = \cost(\tmods, \Amc_i)$;
		\item
			if $X = (\addsym, \Upsilon)$ then $\tmods =\\ \argmin_{\add{\mods}} \bigset{\cost(\add{\mods}, \emptyAseq) \mid \\ (\Tmc, \apply(\mods, \emptyA)) \models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi) \land \bigwedge_{\Phi \not\in \Upsilon} \lnot \chformula(\Phi)}$ and $c = \cost(\tmods, \emptyA)$.
	\end{itemize}
\end{enumerate}
\end{definition}
%%
%%
\begin{restatable}{lemma}{migcomplexity}\label{lem:mig-complexity}
The Minimal-instantiation Graph for a TKB  $\tkb$ and a TCQ $\tquery$ can be computed in triply exponential time and has triply exponential size wrt $\tquery$.
\end{restatable}

%%
The minimal-instantiation graph $\MMG$ is a graph whose edges are labelled with atomic TKB-modifications
and weighted with the corresponding cost. Through its labels, every finite path $s_0\trans{\tmods_0}\cdots\trans{\tmods_{m-1}}s_m$ 
of $\MMG$ defines an instantiation $\tmods=\tmods_0\cdots\tmods_{m}$ of some input word (not necessarily accepted)
$w=w_0\cdots  w_{m}$ of $D$.
Also the viceversa holds, i.e., every input word $w$ of $\DFA$ is an abstraction of the TKB-modification $\tmods$ 
defined by some path of $G$. 

Observe that, by Item~\ref{it:mmg-1} of Def.~\ref{def:mmg}, $\tmods$ includes only minimal-cost atomic TKB-modifications $\tmods_i$,
thus it is a minimal-cost TKB-modification among all those that instantiate the same $w$.
Moreover, recall that, by Theorem~\ref{thm:rt-sound-compl}, every solution to TKB Alignment is associated to an abstraction $w \in \L(\DFA)$.
Thus, since every such $w$ has a minimal-cost instantiation in some path of $\MMG$, we can search for the minimal-cost
solution by exploring the paths of $\MMG$. Indeed, it is enough to search for the minimal-cost paths of $\MMG$ which 
correspond to the words $w$ accepted by $\DFA$;  since the nodes of $\MMG$ correspond to the states of $\DFA$, this corresponds
to searching for a minimal-path of $G$ starting in $s_0$ and ending in some node that is an accepting state for $\DFA$.

%%Observe that every run in $\DFA$ is a path in $\MMG$ and vice-versa.
%%Moreover, the edges in $\MMG$ are labeled with atomic TKB-modifications and weighted with costs.
%%Consider an edge $e = ((Z, i), \tmods, (Z', i'))$ between two nodes $(Z, i)$ and $(Z', i')$.
%%Item~4 of the definition requires $\tmods$ to be a minimal-cost atomic TKB-modification such that $\gamma((Z,i), \word_\tmods) = (Z', i')$, with $\word_\tmods$ being the abstraction of $\tmods$.
%%Moreover, the weight $\weight(e)$ expresses the cost of such atomic TKB-modification. 
%%Essentially, the labels and weights capture the optimal modification $\tmods$ that is needed to trigger the transitions in $\DFA$.
%%
%%Notice that computing the correct labels and weights amounts to solve a \emph{local minimization} problem which we call KB-alignment.
%%Section~\ref{sec:kbalign} is devoted to formally define and solve such problem.
%%
%%For now, let us assume that we have such technique at hand.
%%Moreover, recall that, from Theorem~\ref{thm:rt-sound-compl} every solution to the TKB-alignment is associated to an abstraction $\word \in \L(\DFA)$.
%%From the construction of $\MMG$ we also know how to compute the cost of such solution $\word$, which amounts to the cost of the path $\pi$ in $\MMG$ that corresponds to the accepting run of $\word$ in $\DFA$.
%%Therefore, computing the optimal solution to the TKB alignment amounts to solving a minimum-cost path problem in $\MMG$, as it is stated in the next result.

\begin{restatable}{theorem}{thmtkbalign}\label{thm:tkb-alignment}
	Consider a TKB $\tkb=(\Tmc,\Aseq)$, with $\Aseq = \Amc_0 \cdots \Amc_\ell$, a TCQ $\tquery$, and let $\DFA=(\alphabet,S,s_0,\gamma,F)$ 
	be the RT-DFA for $\tkb$ and $\tquery$.
	A TKB-modification $\tmods=\tmods_0\cdots\tmods_m$ is an optimal solution of TKB Alignment for $\tkb$ and $\tquery$ iff 
	there exists a minimum-cost path $\pi=n_0\trans{\tmods_0}\cdots\trans{\tmods_{m-1}}n_m$ in $\MMG$, s.t.~$n_0=s_0$
	and $n_m\in F$.
\end{restatable}
%%
Thus, with $\MMG$ at hand, the search can easily be performed by, e.g., Dijkstra's algorithm.
However, in order to state the effective solvability of TKB Alignment, we must still guarantee that $\MMG$ is actually 
computable. In this respect, observe that we still need to explain how the labels and the weights of $\MMG$ can be obtained. 

By Def.~\ref{def:mmg} (Item~\ref{it:mmg-1}), 
computing the labels and the weights of $\MMG$ 
requires to solve, for every edge, one \emph{local minimization problem} of 
the form
$\argmin_{(\sigma,\mods)} \set{\cost((\sigma,\mods),\Aseq)}$, 
subject to a constraint of the form
$(\Tmc, \apply(\mods, \Amc)) \models \query$, with $\query\in \bcBCQ$.
%%
This is the \emph{KB-alignment} problem, 
which we formally define and 
solve in Section~\ref{sec:kbalign}.
%%
We report here that the problem can be solved in doubly exponential time.
This, together with the complexity results reported above, leads to the 
following.
%%
\begin{restatable}{theorem}{tkbalgsolv}\label{thm:tkb-alg-solv}
TKB Alignment is solvable in triply exponential time.
\end{restatable}

% \giuseppe{I added a short discussion on the comparison with Baader semantics.}

As mentioned above, one might consider the semantics on TCQs given in~\cite{BaaderBL15} and instantiate TKB alignment with it.
Such variation on the semantics has minimal impact on the solution technique, which can be adapted to that setting with minimal changes. Details are omitted, due to space constraints.

%This means that we can associate $w$ with the minimal cost of $\tmods_w$ among all possible instantiations of $w$, that is:
%
%\begin{center}
%	$\cost(w) = \min\{\cost(\tmods, \tkb) \mid \tmods \text{ is an instantiation of } w\}$.
%\end{center}
%
%\begin{itemize}
%    \item $w = w_0 \cdots w_m$
%    
%    \item $\cost(w) = \cost(w_0) + \cost(w_1 \cdots w_m)$
%    
%    \item $\cost(w_0) = $ vedi sotto
%\end{itemize}
%
%
%
%
%\begin{center}
%	$w^*=\argmin_{w\in\L(\DFA)}
%        \set{\cost(w)}$.
%\end{center}
%
%
%
%
%
%Assume $\tmods_w = \tmods_0 \cdots \tmods_m$ to be a minimum-cost instantiation of $w$, that is $\cost(w) = \cost(\tmods_w, \tkb)$.
%Observe that $\cost(\tmods_w, \tkb)$ is computed as the sum of the costs for the modifications  
%\begin{itemize}
%    \item if $w_j=\delsym$ then $\tmods_j=\del$ and $\cost(w_j) = \cost(\del,\Amc)$ 
%
%    \item if $w_j=(\fixsym,\Upsilon)$ then 
%        $\cost(w_j) = \min\set{\cost(\mods,\Amc)|(\Tmc, \apply(\mods, \Amc))\models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi)\land
%            \bigwedge_{\Phi \not\in \Upsilon} \lnot\chformula(\Phi)}\}$
%     
%\end{itemize}
%
%
%
%\giuseppe{Continue ... }
%
%Notice that, at each reading step, we account for deleting, fixing, or adding the corresponding ABoxes.
%Such modifications come with a cost, which means we need to solve a local alignment problem to find the minimal cost, namely a KB-alignment.
%
%
%
%
%For now, let us assume that we know how to compute the (minimal) cost of deleting, fixing, or adding an ABox to entail a query of the form $\chformula(\Phi_{1}) \vee \ldots \vee \chformula(\Phi_{n})$, and so that we know how to associate a cost to each transition of the RT-DFA in Definition~\ref{def:rtdfa}.

% Then, regard $\DFA$ as a weighted graph where nodes are the states and weighted edges are obtained from the transition function $\gamma$, where the weights are the costs computed by solving KB-alignment.
% Observe that a given path $\pi$ in the graph corresponds to a TKB-modification $\tmods_{\pi}$ that is obtained by lining up all the minimal-cost modifications that are found by solving the KB-alignment on each edge in $\pi$.
% This also determines the TKB $\tkb_{\pi} = \tmods_{\pi}(\tkb)$ that is obtained from $\tkb$ by applying the TKB-modification $\tmods_{\pi}$.
% In addition, the cost $\cost(\tmods_{\pi})$ corresponds to the sum of weights in $\pi$.


%%\begin{lemma}\label{lem:repair-template-soundness}
%%    Consider a TKB $\tkb=(\Tmc,\Aseq)$ with $\Aseq=\Amc_0,\ldots,\Amc_\ell$ 
%%	and a TCQ $\tquery$, let
%%    $\DFA=(\alphabet,S,s_0,\gamma,F)$
%%    be the RT-DFA for $\tkb$ and $\tquery$.
%%    Then, for every word 
%%    $w=w_0\cdots w_m\in \L(\DFA)$ and 
%%    induced accepting path 
%%    $\ppath=s_0\trans{w_0}\cdots\trans{w_{m}}s_{m+1}$,
%%    there exists a TKB-modification 
%%    $\tmods_w=\tmods_0\cdots\tmods_m$
%%    s.t.~$\tmods_w(\tkb) \models \tquery$ and, for $j=0,\ldots, m$: 
%%    \begin{itemize}
%%        \item if $w_j=\delsym$ then $\tmods_j = \del$;
%%        \item if $w_j = (\fixsym, \Upsilon)$ and 
%%            $s_j=(Z,i)$ then 
%%            $\tmods_j=\fix{\mods}$ with $\mods$ s.t.~$(\Tmc, \apply(\mods, \Amc_i))\models \bigvee_{\Phi \in \Upsilon} \Phi$;
%%        \item if $w_j = (\addsym, \Upsilon)$ then 
%%            $\tmods_j=\add{\mods}$ with $\mods$ s.t.~$(\Tmc, \apply(\mods, \emptyA)) \models \bigvee_{\Phi \in \Upsilon} \chformula(\Phi)$.
%%    \end{itemize}
%%\end{lemma}
%%
%%\begin{lemma}\label{lem:repair-template-completeness}
%%    Consider a TKB $\tkb=(\Tmc,\Aseq)$ with $\Aseq=\Amc_0,\ldots,\Amc_\ell$ 
%%	and a TCQ $\tquery$, let
%%    $\DFA=(\alphabet,S,s_0,\gamma,F)$
%%    be the RT-DFA for $\tkb$ and $\tquery$.
%%    Then, for every TKB-modification $\tmods = \tmods_0 \cdots \tmods_m$ s.t.~$\apply(\tmods,\tkb) \models\tquery$ there exists a word $w = w_0 \cdots w_m \in \L(\DFA)$ 
%%    inducing the accepting path $\ppath=s_0\trans{w_0}\cdots\trans{w_{m}}s_{m+1}$ s.t., for $j = 0, \ldots, m$:    
%%        \begin{itemize}
%%            \item if $\tmods_j = \del$ then $w_j=\delsym$;
%%            \item if $\tmods_j = \fix{\mods}$ and $s_j = (Z,i)$ then $w_j = (\fixsym, \Upsilon)$ for $\Upsilon$ s.t.~$s_{j+1}=\gamma(s_j,((\fixsym, \Upsilon)))$;
%%            \item if $\tmods_j = \add{\mods}$ and $s_j = (Z,i)$ then $w_j = (\addsym, \Upsilon)$ for $\Upsilon$ s.t.~$s_{j+1}=\gamma(s_j,((\addsym, \Upsilon)))$.
%%        \end{itemize}
%%\end{lemma}

%\begin{theorem}\label{thm:solvingTKBalign}
%	
%	The solution to TKB-Alignment with input $\tkb$ and $\tquery$ correspond to the shortest path over $\DFA$.
%	
%\end{theorem}
