\section{Detailed Descriptions of Auxiliary Functions}
\label{sec:functions-appendix}
In this section, we describe in detail the functions that are called by \EventDPOR, and were briefly described at the end of \cref{sec:algo:access-sets}
Some of these functions extend the happens-before relation $\happbf{\hb}{E}$ on an execution with
additional ordering constraints that are enforced  in the event-driven execution model, stemming from the fact that
%% induced by the event-driven execution model, in which
%% When constructing executions that respect some particular happens-before relation, one must in fact also respect additional ordering constraints 
%% induced by the event-driven execution model, in which
each handler must execute its messages in some sequential order. The following \emph{saturation operation} adds such additional orderings imposed by
any ordering relation on events.
%%
\begin{definition}[Saturation]
  \label{def:weakall}
Let $E$ be a sequence of events, and $\happbf{}{E}$ be an irreflexive partial order on the events of $E$. 
We define
$\weaksatrel{\happbf{}{E}}$ as the smallest transitive relation $\happbf{\sat}{E}$ on the events of $E$ which includes
$\happbf{}{E}$ and satisfies the constraint that  whenever $e$ and $e'$ are events in different messages on the same handler,
and there is an event $e''$ in the same message as $e$ and an event $e'''$  in the same
  message as $e'$ with $e'' \happbf{\sat}{E} e'''$,
then $e \happbf{\sat}{E} e'$.
%% \begin{enumerate}[(i)]
%% \item \label{rule:saturation-1}
%% \end{enumerate}
%% Let $\edseq{E}{E'}$ denote $\weaksatrel{\hbmseq{E}{E'}}$ ($\weakall$ stands for ``event-driven''). Let $\happbf{\weakall}{E}$ denote $\edseq{E}{\varepsilon}$, where $\varepsilon$ is the empty sequence.
\qed
\end{definition}
In the above definition, note that it is not required that $e$ is distinct from $e''$, nor that $e'$ is distinct from $e'''$.


\subsection{Reversing Races}
\label{sec:race-reversals-appendix}
A key procedure of \EventDPOR is $\reverserace({E},{\event},{\event'})$ which constructs new executions by analyzing and reversing a race in an explored execution.
This procedure is given a race $\event \revrace{\exseq} \event'$ in the currently explored execution $\exseq$ (at \cref{algacsl:race-loop} of \cref{alg:eventdpor-access}),
and returns a set of maximal executions that reverse the race.
%% in the sense that they
%% perform the second event $e'$  of the race without performing the first one, and (except for $e'$) only contain events that are not affected by the race.
More precisely, it returns a set of pairs of form $\pair{E'}{u.e'}$, such that
\begin{inparaenum}[(i)]
\item
  %% $E'.u \mtprefix E$ and
$E'.u$ is a maximal happens-before prefix of $E$ such that $E'.u.e'$ is an execution, and
\item $\dom{E'}$ is a maximal subset of $\dom{E'.u}$ such that $E' \leq E$.
\end{inparaenum}

%% Let us first define constraints that must be satisfied by $\exseq'.u.e'$.
%% Given a race $\event \revrace{\exseq} \event'$, let $\event''$ be the $\happbf{\po}{E}$-predecessor of $\event'$.
%% Define the following two subsequences of $E$:
%%   \begin{itemize}
%%   \item $\exseqmust$, defined as the subsequence  of events $\event'''$ such that
%%     $\event''' \happbf{\hb}{E} \event''$, also including $\event''$,
%%   \item $\exseqmay$, defined as the subsequence of events $\event'''$ such that
%%     $\event \nhappbf{\hb}{E} \event'''$, i.e., the events that do not happen-after $\event$.
%%   \end{itemize}
%%   Intuitively, $\exseqmust$ is the set of events that \emph{must} be present in $\exseq'.u$, for the reason that they are the predecessors that enable $\event'$. The sequence $\exseqmay$ are the events that \emph{may} be present in $\exseq'.u$ for the reason that they are not affected by the race: the events not in
%%   $\exseqmay$ happen-after $\event$ and are therefore affected by the race: when the race is reversed, they may be affected (e.g., by reading a different value).
%%   The race reversal procedure will return the set of maximal executions of form $\exseq'.u.e'$ such that
%%   $\exseqmust \sqsubseteq E'.u \sqsubseteq \exseqmay$. Of course, it need produce only one per equivalence class.


%% Let us consider two particular cases.
%%   \begin{itemize}
%%     \item
%%       If the events in $\exseqmust$ can not be ordered into an execution, then the race cannot and should not be reversed. An illustration of this phenomenon was
%%       given in \cref{fig:example1new}, where the race on \texttt{y} cannot be reversed, since $\exseqmust$ would contain the two writes to \texttt{x} which
%%       cannot be included in an execution (without the writes to \texttt{y}).
%%     \item
%%       If the events in $\exseqmay$ can be ordered into an execution (which is often the case), then that sequence will be returned as the unique maximal execution.
%% %% \bjcom{A simple illustration would be a simple event-event race}
%%   \end{itemize}
%%   If $\exseqmust$ can be reordered into an execution, but constraints imposed by the event-driven execution model prevent $\exseqmay$ from being reordered to an execution, 

The procedure $\reverserace({E},{\event},{\event'})$ is shown in \cref{alg:reverserace}. Let $E''$ be the set of events of $E$ that are not affected by the race (\cref{algl:revrace-init-notdep}):
this is the set of events $e'''$ with $\event \nhappbf{\hb}{E} \event'''$. If $E''$ can be reordered to form an execution, the code at
\crefrange{algl:revrace-init-ordering}{algl:converge-end} will have no effect;
$\reverserace$ will terminate and returns its linearization.
However, there are situations in which $E''$ cannot be reordered into an execution.
For instance, $E''$ may contain two incomplete messages on the same handler because the remaining parts of these messages happen-after $e$ in $E$.
Since an execution may contain at most one incomplete message per handler,
$\reverserace$ then performs a sequence of message removals and reorderings to produce a set of maximal wakeup sequences.
  The procedure employs the saturation operation of \cref{def:weakall} to constrain the ordering between messages on the same handler. 
% A simple example includes message-message races, illustrated by \cref{fig:example1new}, where all of message $p_1$ must be removed from $\exseqmay$ in order to form an execution.
  The procedure maintains
%%  a sequence $E''$, initialized to the events that could possible be in $E'.u$
  an ordering relation $\happbf{sc}{E''}$ on $E''$, initialized to $\weaksatrel{\happbf{hb}{E''}}$ (\cref{algl:revrace-init-ordering}).
It thereafter performs a sequence of steps in which messages are removed from $E''$ and/or the ordering relation $\happbf{sc}{E''}$ is extended. Some steps may be resolved nondeterministically: in such cases the procedure pursues all possible alternatives, potentially resulting in several returned sequences. The steps of \cref{alg:reverserace} are the following.
\input{alg-code-reverserace}

\begin{description}
  \item[\cref{algl:revrace-lin-seq}]
    After the loop from \cref{algl:revrace-msg-del-start}
    to \cref{algl:revrace-msg-del-end}, the set $S$ will contain all
    the possible sequences with at most one incomplete message per handler.
  \item[\cref{algl:revrace-rule-must}]
    If an incomplete message includes an event $e'''$ with $e''' \happbf{hb}{F} e''$, then
    any other message on the same handler which is not completely executed in $F$ must be removed.
    %% \item A message containing events that are ordered (by $\happbf{sc}{E''}$) after events in an incompletely executed message
    %%   on the same handler must be discarded.
  \item[\cref{algl:revrace-rule-choose}]
    If several incomplete messages execute on the same handler, then
    finds all the possible sequence where only one of the incomplete
    messages is present and saves them to $S$.
    
  \item[\cref{algl:revrace-rule-last}]
    Whenever a handler has an incomplete message $p$, any other message $p'$
    on that handler must be executed before $p$, represented by extending $\happbf{sc}{F}$ from the last
    event of $p'$ to the first event of $p$ and then saturating.
  \item[\cref{algl:revrace-rule-cycle}]
    If $\happbf{sc}{F}$ becomes cyclic during the filtering and ordering procedure, then each cycle should be broken by
    removing the events in a suitable message.
  \item[\cref{algl:revrace-irreversible}]
    It is possible to have two or more incomplete messages from the same handler in $F$ each having at least one
    event that happens-before $e''$. Because of this reason or
    non-deterministic choice during message deletion process described
    previously, an event $e'''$ such that
    $e''' \happbf{\hb}{F} e''$ might be deleted from
    $\exseq''$. Then the algorithm removes $F$ from $S$.
  \item[\cref{algl:revrace-msg-order}]
    By adding additional relation $\happbf{sc'}{F}$,
    the algorithm determines a total order on the messages from the same handler.
  \item[\cref{algl:revrace-next-msg-order}]
    If $\happbf{sc}{F}$ and $\happbf{sc'}{F}$ together form a
    cycle, the algorithm tries to guess another order
    $\happbf{sc'}{F}$. Systematic search of $\happbf{sc'}{F}$ is a NP-complete
    problem in general case (see \cref{thm-consistency} below). But for the
    programs we have tried so far, doing \cref{algl:revrace-msg-order}
    is sufficient.
  \item[\cref{algl:revrace-linearize}]
    The sequence $u$ is linearized by topological sort procedure while
    respecting $\happbf{sc}{F}$ and $\happbf{sc'}{F}$.
\end{description}

As an illustration, consider the race on \texttt{x} in the program of \cref{fig:example3}.
Here, there is a unique (up to equivalence) maximal execution which reverses the race, which consists of all events that post messages, all events in messages
    $p_2$ and $q_2$, and the assignment to \texttt{d} by $p_1$. The read of \texttt{x} by~$q_2$ should be ordered last, since it corresponds to the racing event $e'$.
    Message $q_1$ is removed by the rule at \cref{algl:revrace-rule-must}, whereby also the second of event of $p_1$ is removed, since it reads from the first event in $q_1$.

\paragraph{\bf Event-driven Consistency.}
When describing \cref{algl:revrace-next-msg-order} above, we stated that the problem of determininig whether a given happens-before relation
can be obtained from some execution is NP-complete. This follows from NP-completeness of the event-driven consistency problem.
The event-driven consistency problem consists in checking whether, for a given  directed graph 
$(S,\happbf{\hb}{S})$ where $S$ is a set of events and $\happbf{\hb}{S}$ is a set of edges,  there is an execution sequence $E$ such that $(S,\happbf{\hb}{S})$ is the  \emph{\hb-trace} of  $E$.

\begin{theorem}
\label{thm-consistency}
The event-driven consistency problem is NP-complete.
\end{theorem}

The proof of the above theorem can be found in \cref{sec:complexity-proof-consistency}.  Given this NP-hardness result,  we define a procedure  to reverse races (\cref{sec:race-reversals-appendix}) that makes use of a saturation procedure to constrain the ordering between messages and therefore reduces the number of cases to  consider. 


%%     \begin{itemize}
%%   \item the earliest message which is discarded, or preceded by another one on its handler,
%%   \item otherwise the entire computation preceding $\event$.
%%   \end{itemize}
    %% \bjcom{We should describe how this procedure is guided by sleep sets}

\subsection{Wakeup Tree Insertion}
\label{sec:wakeuptrees}
In this section, we formally define wakeup trees, and present the procedure $\insertwusname$ for inserting wakeup sequences, and $\insertpendingwuname$ for inserting parked wakeup sequences.

%% Define an \emph{ordered tree} as a pair
%% $\tuple{B,\prec}$, where
%% $B$ (the set of \emph{nodes}) is a finite prefix-closed set of sequences of
%% messages, with the empty sequence $\emptyseq$ being the root.
%% The children of a node $u$, of form
%% $u.p$ for some set of messages $p$, are ordered by $\prec$.
%% In the tree $\tuple{B,\prec}$, such an ordering between children is
%% extended to a total order $\prec$ on~$B$ by letting
%% $\prec$ be the induced post-order relation between the nodes in $B$.
%% Thus, if the children $u.p_1$ and $u.p_2$ are ordered as
%% $u.p_1 \prec u.p_2$, then $u.p_1 \prec u.p_2 \prec u$ in the induced post-order.

\begin{definition}[Wakeup Tree]
\label{def:Wut}
A \emph{wakeup tree} is an ordered tree $\tuple{B,\prec}$, where
$B$ (the set of \emph{nodes}) is a finite prefix-closed set of sequences of
messages, with the empty sequence $\emptyseq$ being the root.
The children of a node $u$, of form
$u.p$ for some set of messages $p$, are ordered by $\prec$.
In the tree $\tuple{B,\prec}$, such an ordering between children is
extended to a total order $\prec$ on~$B$ by letting
$\prec$ be the induced post-order relation between the nodes in $B$
(i.e., if the children $u.p_1$ and $u.p_2$ are ordered as
$u.p_1 \prec u.p_2$, then $u.p_1 \prec u.p_2 \prec u$ in the induced post-order).
\qed
\end{definition}

\input{alg-code-wakeuptree-concise}

\hasbeenremoved{The insertion of a new wakeup sequence $v$ into a wakeup tree $\wut{E'}$ should enforce property P2.
The insertion of a new wakeup sequence $v$ into a wakeup tree $\wut{E'}$ is performed by
descending step-by-step from the root of the tree. At each node $u$, it
should, for each of its children (of form $u.p$), test whether $p \in\winits{E'.u}{v'}$, where
$v'$ is obtained from $v$ by removing the events that are already in $u$.
If $p \in\winits{E'.u}{v'}$ then insertion moves to the child $u.p$. If the test fails for all
children, then $v'$ should be added as a right-most child of $u$.
}

%% whenever the exploration tree $\exseqs$ contains a node of form $\exseq.p$, then the algorithm will not add an execution of form $\exseq.w$ which is contained in
%% some execution of form $\exseq.p.w'$ for some $w'$, i.e., for which $p \in \winits{\exseq}{w}$. Such a check for redundancy is performed


%% \EventDPOR maintains a wakeup tree $\wut{E'}$ for each prefix $E'$ of the currently explored execution.
%% The algorithm strives to maintain the following two invariants.
%% \begin{enumerate}
%% \item \label{def:Wut:p1} %% modified
%%   No leaf $u$ of $\wut{E'}$ is redundant after $E'$, i.e., $\neg \redundant{E'}{\done}{u}$.
%% \item \label{def:Wut:p2} %% same
%%   For any sequences $u$, $w,$ and message $p$, such that
%%   $u.p$ is a node and $u.w$ is a leaf in $\wut{E'}$ with
%%   $u.p \prec u.w$, we have $p \not\in\winits{E'.u}{w}$.
%% \qed
%% \end{enumerate}
%% These invariants may be difficult to maintain when the check for redundancy is not exact \bjcom{Comment more?}


Insertion of a wakeup sequence $v$ into the wakeup tree $\wut{E'}$ is performed by calling the function $\insertwus{v}{E'}{u}$ with parameters $v$ and $E'$, and the parameter $u$ being the empty sequence.
The call $\insertwus{v}{E'}{\emptyseq}$ will, if $v$ conflicts with all its current leaves, extend the wakeup tree $\wut{E'}$ by a new leaf $v'$ such that $v' \mtequiv{E'} v$.
The recursive function $\insertwus{v}{E'}{u}$, shown in \cref{alg:wakeuptree},
traverses the wakeup tree $\wut{E'}$ from the root downwards, where $u$ is the current point of the traversal.
%% whether $v$ is redundant: if so, it leaves $\wut{E'}$ unchanged, if not it inserts a new leaf.
The initial call is performed with $u$ being the empty sequence.
%% The current point of the traversal is represented by the sequence $u$, hence an initial call will set this parameter to $\emptyseq$.
Each invocation of $\insertwus{v}{E'}{u}$
first checks whether a leaf has been reached or all of $v$ has already been examined, in which case nothing new should be added to $\wut{E'}$ (\cref{alg:wut-insert-empty}).
Thereafter, it considers the children of $u$ (of form $u.p$) from left to right.
For each child $u.p$, the algorithm tries to determine whether or not $p \in \winits{\exseq.u}{v}$.
If $p$ does not start after $E'.u$ then $p \in \winits{\exseq.u}{v}$ then $p \in \winits{\exseq.u}{v}$ can be checked by simple inspection at \crefrange{alg:no-message}{alg:travers-no-message} (as described in the second paragraph of \cref{sec:checkwi}).
The algorithm traverses to $u.p$ by a call to $\insertwus{v\remove p}{E'}{u.p}$ if $p \in \winits{\exseq.u}{v}$, otherwise it
considers the next child of $u$ if $p \not\in \winits{\exseq.u}{v}$.
If $p \in \winits{\exseq.u}{v}$ but $p$ does not appear in $v$, then actually no wakeup sequence need be inserted (\cref{alg:travers-no-message}).
%% The cases for which 
%%  is straight-forward, it , if $p \in \winits{\exseq.u}{v}$, insertion 
%% If $p$ does not start after $E'.u$, then the check whether $p \in \winits{\exseq.u}{v}$ is straight-forward, \revise{as described in the second paragraph of \cref{sec:checkwi}}, and
%% performed at \crefrange{alg:no-message}{alg:travers-no-message}. In case the test succeeds, but $p$ does not appear in $v$, then actually no wakeup sequence need be inserted.
If $p$ starts after $E'.u$ (\cref{alg:message}), then
\begin{itemize}
\item the case in which  $p$ is the first (if any) message on its handler in $v$, considered at \cref{alg:wut-pfirst} is performed according to the \textbf{Simple Check} in \cref{sec:checkwi};
\item if $p$ executes to completion in the sequence $v$ (\cref{alg:wut-pfull}), then $v$ contains sufficient information to decide whether $p \in \winits{\exseq.u}{v}$ using the remaining sequence of checks in \cref{sec:checkwi};
\item if none of these two cases apply, then more information is needed about which accesses $p$ performs when it is executed. Therefore the sequence $v$ is ``parked'' at the node $u.p$: the insertion of $v$ will be resumed when the node $u.p$ is extended to a maximal execution starting with $E'.u.p$, which happens at \cref{algacsl:insert-pendingwu} of \cref{alg:eventdpor-access} with $E'$ being $E'.u$.
\end{itemize}
If all children $u.p$ of $u$ have been traversed with failing tests for $p \in \winits{\exseq.u}{v}$, then $v$ is added as a new branch from $u$, ordered after the already existing children (\cref{alg:wut-insert-branch}).
%% \footnote{An optimization over the Optimal DPOR algorithm of~\cite{optimal-dpor-jacm} is that in the case where
%% $p \in \winits{\exseq.u}{v}$ but $\nextev{E.u}{p} \not\in v$ (implying that if $p \not\in \inits{\exseq.u}{v}$), the insertion leaves the
%% wakeup tree unchanged. This optimization does not miss executions,
%% since the algorithm will anyway later explore continuations of $E.u.p$ that include $E.u.v$ as a happens-before prefix.}


\input{alg-code-pendingwus}

It remains to define the procedure for inserting parked wakeup sequences (called at~\cref{algacsl:insert-pendingwu} of~\cref{alg:eventdpor-access}).
This insertion is described in~\cref{alg:pendingwus}, as the function
$\insertpendingwu{v}{E'}$, which inserts a wakeup sequence $v$ which is parked after a prefix $E'$ of the execution $E$.
The function first decomposes $E'$ as $E''.p$, and checks whether
$p \in \winits{\exseq''}{v}$.
Information about the accesses of $p$ can now be found in the execution $E$, so that the check $p \in \winits{\exseq''}{v}$ can be performed.
The check will be exact for non-branching programs, but possibly conservative in general.
If the check succeeds, then insertion proceeds one step further in the execution $E$ (\cref{alglpwu:recursive-call}), otherwise $v$ conflicts with $p$ and so should be inserted at the wakeup tree after $E''$ (\cref{alglpwu:event-insert}).
As an additional optimization, \Cref{alglpwu:former-leaf} checks whether $E''$ was the leaf that is extended to the currently explored execution.
If so, the insertion can return without inserting anything, in analogy
with how leaves are handled in wakeup tree insertion
(\cref{alg:wut-insert-empty} of \cref{alg:wakeuptree}).


%% \begin{itemize}
%% \item If $p$ does not start after $E'.u$ (\cref{alg:no-message}) then $p \in \winits{\exseq.u}{v}$ can always be decided from the happens-before relation $\happbf{hb}{E'.u.v}$ \bjcom{check which exec}, (\cref{alg:travers-no-message}).
%% \item If $p$ starts after $E'.u$ (\cref{alg:message}) then there are two conditions under which $p \in \winits{\exseq.u}{v}$ can be decided:
%%   \begin{inparaenum}[(1)]
%%   \item if $p$ is the first (if any) message on its handler in $v$, then $p \in \winits{\exseq.u}{v}$ is trivially true, since the first event of $p$ is never in conflict with any event (\cref{alg:wut-pfirst}),
%%     \item if $p$ executes to completion in the sequence $v$ (\cref{alg:wut-pfull}), then $v$ contains sufficient information to decide whether $p \in \winits{\exseq.u}{v}$: if yes the traversal can continue at $u.p$, if no the next child of $u$ is considered.
%%   \end{inparaenum}
%%   If none of these cases apply, then more information is needed about which accesses $p$ performs when it is executed. Therefore the sequence $v$ is parked at the node $u$: the insertion of $v$ will be resumed when the node $u.p$ is extended to a maximal execution starting with $E'.u.p$, which happens at \cref{algacsl:insert-pendingwu} of \cref{alg:eventdpor-access} with $E'$ being $E'.u$.
%% \end{itemize}
%% If all children $u.p$ of $u$ have been traversed with failing tests for $p \in \winits{\exseq.u}{v}$, then $v$ is added as a new branch from $u$, ordered after the already existing children (\cref{alg:wut-insert-branch}).
%% \footnote{An optimization over the Optimal DPOR algorithm of~\cite{optimal-dpor-jacm} is that in the case where
%% $p \in \winits{\exseq.u}{v}$ but $\nextev{E.u}{p} \not\in v$ (implying that if $p \not\in \inits{\exseq.u}{v}$), the insertion leaves the
%% wakeup tree unchanged. This optimization does not miss executions,
%% since the algorithm will anyway later explore continuations of $E.u.p$ that include $E.u.v$ as a happens-before prefix.}

\subsection{Checking for Redundancy}
\label{sec:checkwi}
%% An important operation in \EventDPOR is to test whether a sequence $w$ is redundant, i.e., whether it is equivalent to an already explored execution.
%% Such a test appears at \cref{algacsl:event-test} of \cref{alg:eventdpor-access}; it is defined in \cref{def:redundancy} using the concept of weak initials (\cref{def:winits}).
Let us now consider the problem of deciding whether $p \in \winits{\exseq}{w}$ for a message $p$ and an execution $\exseq.w$.

If $p$ does not start after $E$, then $p \in \winits{\exseq}{w}$ can be checked by simple inspection, as follows.
    If $\nextev{E}{p}$ is a local event or posts a message, then $p \in \winits{\exseq}{w}$ holds trivially.
  If $\nextev{E}{p}$ accesses a shared variable, then
  \begin{inparaenum}[(i)]
    \item if $p$ appears in $w$, we have $p \in \winits{\exseq}{w}$ precisely when there is no event $\event$ in $w$ such that
      $\event \happbf{hb}{E.w}{\nextev{E}{p}}$, and
    \item if $p$ does not appear in $w$, we have $p \in \winits{\exseq}{w}$ precisely when no event in $w$ conflicts with $\nextev{E}{p}$.
  \end{inparaenum}

If $p$ starts after $E$, then checking whether $p \in \winits{\exseq}{w}$
is NP-hard in the general case, as we show in \cref{thm-lowerbound}.
However, in many cases, the check can be performed by tests that run in polynomial time.
\EventDPOR employs the following sequence of checks, starting with simple ones, and resorting to an exact decision procedure only as a last step.
We assume that the event which posts message $p$ appears in $E$, otherwise
$p \in \winits{\exseq}{w}$ is trivially false.

%% The problem of how to determine whether $p \in \winits{\exseq}{w}$ is considered in \cref{sec:checkwi}, where a decision procedure is presented.
%% This procedure must sometimes extend $w$ by completing the execution of partially executed messages, in order to determine whether the order of message execution can
%% be changed without affecting the happens-before relation.

%% \begin{definition}[Completion]
%%   \label{def:completion}
%%   Let $E$ be an execution and $w$ be a sequence with $\valid Ew$, and let $p$ be a message which is partially executed in $E.w$.
%%   The \emph{$p$-completion} of $w$ after $E$, denoted $\completion{E}{w}{p}$ is the result of extending incompletely executed messages to completion,
%%   while respecting the following constraints:
%%   \begin{inparaenum}[(1)]
%%   \item first $p$ is extended to completion
%%   \item thereafter messages $q$ containing events that happen-before events in $p$ are extended,
%%     \item thereafter still incompletely executed messages that happen-before events completed in the previous step, and so on.
%%   \end{inparaenum}
%% \end{definition}

%% In \EventDPOR, the completion is constructed without actually executing the messages. Instead, the sequence of shared-variable accesses of a message is obtained from
%% previous or the current execution. \bjcom{More about this?}

\begin{description}
  \item[Simple Check]
  If $p$ is the first message (if any) on its handler in $w$, then $p \in \winits{\exseq}{w}$ is trivially true (recall our assumption that the first event of a message does not access a shared variable).
\item[Happens-Before Check]
  If $p$ is not the first message on its handler in $w$, 
  we check whether there is a happens-before dependency from a message $p'$ which precedes $p$ on its handler, as follows.
  \begin{enumerate}
  \item
   If $p$ is not executed to completion in $w$, we extend $w$ by a sequence of events performed by $p$ which performs all the shared-variable
  accesses that $p$ did not perform in $w$. If after this extension, some event of $p$ happens-after an event in a message $q$ on another handler which is
  not executed to completion in $w$, then $w$ is further extended by events of $q$ in the same way. If an event of $q$ again
  happens-after an event in an incomplete message on some other handler, this procedure is repeated recursively until convergence, resulting in an extension $w'$ of $w$.
%%  In this phase, it is checked whether the relation $\happbf{hb}{E.w}$ prevents the shared-variable accesses of $p$ to be performed before any other
%%   message on the same handler.
  \item
  Thereafter, the happens-before relation $\happbf{hb}{E.w'}$ is extended to include ordering constraints induced by the event-driven execution model.
  \begin{enumerate}[(i)]
    \item First $\hbwpref{E}{w'}$ is constructed as
    the smallest transitive relation which includes $\happbf{\hb}{E.w'}$ and in addition enforces
    $e \hbwpref{E}{w'} e'$  whenever $e$ is in a message whose first event is in $E$ and $e'$  occurs after $e$ on the same handler as $e$.
    \item
   Thereafter, $\happbf{sc}{E.w'}$ is defined as the saturation $\weaksatrel{\hbwpref{E}{w'}}$ of $\hbwpref{E}{w'}$ (see \cref{def:weakall}).
  \end{enumerate}
  If now $e' \happbf{sc}{E.w'} e$ for some event $e$ in $p$ and event $e'$ in a message which precedes $p$ on the same handler, then $p \in \winits{\exseq}{w}$ must be false.
  \end{enumerate}
\item[Witness Construction]
%%   If there is no event $e$ in $p$ with $p' \happbf{sc}{E.w'} e$, then
  If the Happens-Before Check was not negative, the next step is to construct an actual execution in which $p$ is the first message on its handler. 
  First, $\happbf{sc}{E.w'}$ is extended, by ordering
  the events in $p$ before any event in a message that precedes $p$ in $w'$ on the same handler, and thereafter saturated by the saturation operation $\weaksatrel{\cdot}$.
  If the result contains a cycle, then $p \in \winits{\exseq}{w}$ must be false. Otherwise
  we extend the saturated extension of $\happbf{sc}{E.w'}$ to a total order on the messages of each handler, by ordering
  messages that are still unordered to execute in the same order as they appear in $w'$. If this can be done without creating a cycle then
  $p \in \winits{\exseq}{w}$ is true.
\item[Decision Procedure]
  If a cycle is created, then a decision procedure is invoked as a final step.
\end{description}


