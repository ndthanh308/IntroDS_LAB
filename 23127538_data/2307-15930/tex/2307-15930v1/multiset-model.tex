\section{Computation Model}
\label{sec:model}

\hasbeenremoved{In this section, we introduce the class of event-driven programs that we consider.
We also define several semantical notions such as transitions, events, executions, and traces.}

\subsection{Programs}
\label{sec:programs}
We consider programs consisting of a finite set of \emph{threads} that interact via
a finite set of \emph{(shared) variables}.
Each thread is either a \emph{normal thread} or a \emph{handler thread}.
%% ranging over a domain $\valset$ of \emph{values} that includes a special value $\zeroval$.
%
A normal thread has a finite set of local registers and runs a deterministic code, built in a standard way
from expressions and atomic statements, using standard control
flow constructs (sequential composition, selection and bounded iteration).
Atomic statements read or write to shared variables and local registers,
including read-modify-write operations, such as \mbox{compare-and-swap}.
%% To simplify the presentation, we do not consider statements that can block
%% other threads, such as locks.
A handler thread has a \emph{mailbox} to which all threads (also handler threads) can post messages.
A mailbox has unbounded capacity, implying that the posting of a message to a mailbox can never block.
A message consists of a deterministic code, built in the same way as the code of a thread. 
We let $\post(p,h)$ denote the statement which posts the message $p$ into the mailbox of handler thread $h$.
A handler thread repeatedly extracts
a message from its mailbox, executes the code of the message to completion,
then extracts a next message and executes its code, and so on. 
Messages are extracted from the mailbox in arbitrary order.
%% , i.e., the structure of the mailbox is that of an unordered multiset.
The execution of a message is interleaved with the statements of other threads.
%% When its mailbox is empty, the handler thread waits until more messages arrive, or until the
%% program execution terminates.

The local state of a thread is a valuation of its local registers
%% (including those used by the currently executing message, if any)
together with the contents of its mailbox.
A global state of a program consists of a local state of each thread together
with a valuation of the shared variables.
The program has a unique initial state, in which mailboxes are empty.

Recall that we use \emph{message} to denote what is called \emph{event} in \cref{sec:intro}.
%% in order to avoid conflict with our use of the term event as a particular execution of a statement.

\subsection{Events, Executions, Happens-before Ordering, and Equivalence}
\label{sec:events}

We use $s,t, \ldots$ for threads,
$p,q,\ldots$ for messages and non-handler threads,
\texttt{x}, \texttt{y}, \texttt{z} for shared variables,
and \texttt{a}, \texttt{b}, \texttt{c}, \texttt{d} for local registers.
%% For uniformity, we will use the term \emph{message} to refer also to a normal thread,
%% since a normal thread can be represented as a message which is the only one executing on its handler.
%% we let each normal thread be represented as a message, which is executed by a handler thread which executes only
%% this one message, which is present in its mailbox at initialization.
%% We can then say that each statement execution is performed by a message, which executes on
%% some handler.
%% Thus, each event is in some message, which executes on some handler.
%% We then sometimes say that ``the event is executed by the message'', even if this is slightly incorrect.
We assume, %% without loss of generality,
wlog,
that the first event of a message does not access a shared variable, but only performs a local action, e.g., related to initialization
of message execution.
%% This assumption simplifies the presentation of handling the interaction between shared-variable accesses and message scheduling.
In order to simplify the presentation, we henceforth extend the term \emph{message} to refer not only to a message but also to a non-handler thread.

The execution of a program statement is an \emph{event},
which affects the global state of the program. 
An event  is denoted by a pair $\transpair pi$, where $p$ denotes the
message containing the event and $i$ is a positive integer,
denoting that the event results from the $i$-th execution step in message $p$.
\hasbeenremoved{
We call an event \emph{global} if it accesses a shared variable or posts a message.
A message is denoted by the event that posted it. 
For instance, if the second step of
message $p$ posts a message, whose first step is to post another message $q$,
then the event representing the first step of message $q$ is denoted
$\transpair{\msgof{\msgof{p}{2}}{1}}{1}$.
%% \bjcom{The following sentence may not be fully accurate. Also, skip the preceding example?}
As is customary in DPOR algorithms, we can let an event
represent the combined effect of a sequence of statements, if at most one of them affects a shared variable or the
local state of other threads.
This avoids consideration of interleavings of
local statements of different threads in the analysis.
}
An \emph{execution sequence} $\exseq$
is a finite sequence of events, starting from the initial state of the program.
%% following the execution model described in~\cref{sec:programs}.
Since thread and message codes are deterministic, an execution
sequence $\exseq$ can be uniquely characterized by the sequence
of messages (and non-handler threads) that perform execution steps in $\exseq$,
%% and each execution sequence leads to a uniquely defined program state.
%% since the code of each message is deterministic, and their interleaving is given by the execution sequence. 
where we use dot(.) as concatenation operator.
Thus $p.p.q$ denotes the
execution sequence consisting first of two events of $p$, followed by an event of~$q$. 
%% The reason for naming messages after their posting events is to be able to consider execution sequences as equivalent, i.e., having the same sets of events, even when independent messages are handled in different orders. 

We let $\enabled{E}$ denote the set of
messages that can perform a next event in the state to which $E$ leads.
A sequence $\exseq$ is \emph{maximal} if $\enabled{E} = \emptyset$.
%% i.e., no message is enabled after~$\exseq$.
We use $u,v,w, \ldots$ to range over sequences of events. 
We introduce the following notation, where $E$ is an execution sequence and $w$ is a sequence of events.
\begin{itemize}[-]
\item $\emptyseq$  denotes the empty sequence. 
\item $\valid{\exseq}{w}$ denotes that $\exseq.w$ is an execution sequence.
\item $w \remove p$ denotes the sequence
  $w$ with its first occurrence of $p$ (if any) removed.
\item $\dom{\exseq}$ denotes the set of events $\transpair{p}{i}$ in $\exseq$, that is, $\transpair{p}{i} \in \dom{\exseq}$ iff
  $\exseq$ contains at least $i$ events of $p$.
  We also write $e \in E$ to denote $e \in \dom{E}$.
\item $\nextev{\exseq}{p}$ denotes the next event to be performed by the message $p$ after the execution $E$ if $p \in \enabled{E}$,
  otherwise $\nextev{\exseq}{p}$ is undefined.
\item $\procof{\event}$ denotes the
  message that performs $e$, i.e., $e$ is of form
$\event = \transpair{\procof{\event}}{i}$ for some $i$.
%% \item   $\event \totorder{\exseq} \event'$ denotes that $\event$ occurs before $\event'$ in $\exseq$ (i.e., $\totorder{\exseq}$ is the total order on events in $\exseq$).
\item $\exseq' \prefix \exseq$ denotes that  $\exseq'$ is 
  a  (not necessarily strict) prefix of $\exseq$.
%% \item $\pre{\exseq}{\event}$, where $\event \in \exseq$ is the prefix of $\exseq$ up to, but not including, the event $\event$.
%% \item $w\lceil p$ is the prefix of $w$ that precedes $\nextev{\exseq}{p}$ if $\nextev{\exseq}p \in w$, otherwise $w\lceil p$ is $w$.
\end{itemize}
We say that \emph{$p$ starts after $E$} if $p$ has been posted in $E$, but not yet performed any events in $E$.
We say that \emph{$p$ is active after $E$} if $p$ has been posted in $E$, but not finished its execution in $E$.

%% \subsection{Happens-Before Relation and Equivalence}
%% \label{sec:hb}
\hasbeenremoved{The basis for our DPOR algorithm is the definition of a happens-before relation on the events of each execution sequence,
which captures the data and control dependencies that must be respected by any equivalent execution.}

\begin{definition}[Happens-before]
\label{def:hb-def}
Given an execution sequence $E$,
we define the \emph{happens-before relation} on $E$, denoted
$\happbf{\hb}{E}$, as the smallest irreflexive partial order on $\dom{E}$ such that
$e \happbf{\hb}{E} e'$ if $\event$ occurs before $\event'$ in $\exseq$ and either  %% $\totorder{E}$ and either
\begin{itemize}
\item
$e$ and $e'$ are performed by the same message $p$,
\item
$e$ and $e'$ access a common shared variable \texttt{x} and at least one writes to \texttt{x}, or
\item
$\procof{e'}$ is the message that is posted by $e$ and $e'$ is the first event of $\procof{e'}$. %% $\fst{\procof{e'}}$ is $e'$. %% (i.e., $e =\pbof{e'}$).
  \qed
\end{itemize}
\end{definition}
\hasbeenremoved{Intuitively, $\happbf{\po}{E}$ (\emph{program order}) is the total order of events of each message.
Note that $\happbf{\po}{E}$  does not order events of different messages relative to each other.
The relation $\happbf{\cnf}{E}$ (\emph{conflicts with}) captures data flow constraints arising from reads and writes to shared variables.
The relation $\happbf{\pb}{E}$ (\emph{posted by}) captures the causal dependency from message posting to message execution.}
%% Let $\happbf{\hb}{E}$ denote the transitive closure of the union of $\happbf{\po}{E}$, $\happbf{\cnf}{E}$, and $\happbf{\pb}{E}$.
%% \KS{This last sentence was mentioned before.}
%% The $\happbf{\hb}{E}$ relation induces in a natural way an equivalence relation on execution sequences.
The \emph{\hb-trace} (or \emph{trace} for short) of $E$ is the directed graph $(\dom{E},\ \happbf{\hb}{E})$.
%% For a message $p$, we write $p\happbf{\hb}{E} e'$ to denote that $e'$ is not in $p$ and
%% $e\happbf{\hb}{E} e'$ for some event $e$ in $p$, and similarly for $p\happbf{\cnf}{E} e'$, $p\happbf{\weakall}{E} e'$,
%% $e\happbf{\cnf}{E} p'$, etc.
%% \bjcom{Some stuff could be pruned from this paragraph}
\begin{definition}[Equivalence]
\label{def:hb-equiv}
Two execution sequences $E$ and $E'$ are 
\emph{equivalent}, denoted $E \mtequiv E'$, if they have the same trace.
We let \eqclass{E} denote the equivalence class of $E$.
  \qed
\end{definition}
Note that for programs that do not post or process messages,
%% which in our model can be represented as programs with one message per handler,
$\mtequiv$ is the standard Mazurkiewicz trace equivalence for multi-threaded programs \cite{Mazurkiewicz:traces,Godefroid:thesis,FG:dpor,abdulla2014optimal}.
We say that two sequences of events, $w$ and $w'$, with $\valid{E}{w}$ and $\valid{E}{w'}$, are
\emph{equivalent after $E$}, denoted $w \equivafter{E} w'$ if $E.w \mtequiv E.w'$.

\hasbeenremoved{
  In the event-driven execution model, the happens-before relation induces additional ordering constraints, since 
%% induced by the event-driven execution model, in which
%% When constructing executions that respect some particular happens-before relation, one must in fact also respect additional ordering constraints 
%% induced by the event-driven execution model, in which
each handler must execute its messages in some sequential order. The following \emph{saturation operation} adds such additional orderings imposed by
any ordering relation on events.
%%
\begin{definition}[Saturation]
  \label{def:weakall}
Let $E$ be a sequence of events, and $\happbf{}{E}$ be an irreflexive partial order on the events of $E$. 
We define
$\weaksatrel{\happbf{}{E}}$ as the smallest transitive relation $\happbf{\sat}{E}$ on the events of $E$ which includes
$\happbf{}{E}$ and satisfies the constraint that  whenever $e$ and $e'$ are events in different messages on the same handler,
and there is an event $e''$ in the same message as $e$ and an event $e'''$  in the same
  message as $e'$ with $e'' \happbf{\sat}{E} e'''$,
then $e \happbf{\sat}{E} e'$.
%% \begin{enumerate}[(i)]
%% \item \label{rule:saturation-1}
%% \end{enumerate}
%% Let $\edseq{E}{E'}$ denote $\weaksatrel{\hbmseq{E}{E'}}$ ($\weakall$ stands for ``event-driven''). Let $\happbf{\weakall}{E}$ denote $\edseq{E}{\varepsilon}$, where $\varepsilon$ is the empty sequence.
\qed
\end{definition}
In the above definition, note that it is not required that $e$ is distinct from $e''$, nor that $e'$ is distinct from $e'''$.
}


\hasbeenremoved{
\paragraph{\bf Event-driven Consistency.}
The event-driven consistency problem consists in checking whether, for a given  directed graph 
$(S,\happbf{\hb}{S})$ where $S$ is a set of events and $\happbf{\hb}{S}$ is a set of edges,  there is an execution sequence $E$ such that $(S,\happbf{\hb}{S})$ is the  \emph{\hb-trace} of  $E$.

\begin{theorem}
\label{thm-consistency}
The event-driven consistency problem is NP-complete.
\end{theorem}

The proof of the above theorem can be found in \cref{sec:complexity-proof-consistency}.  Given this NP-hardness result,  we define a procedure  to reverse races (\cref{sec:race-reversals-appendix}) that makes use of a saturation procedure to constrain the ordering between messages and therefore reduces the number of cases to  consider. 
}

\section{The \EventDPOR Algorithm}
\label{sec:eventdpor}

In this section, we present \emph{\EventDPOR}, a DPOR algorithm for event-driven programs.
Given a terminating program on given input,
the algorithm explores different maximal executions resulting from different thread interleavings.
\hasbeenremoved{
\EventDPOR is correct, i.e., it explores at least one execution in each equivalence class induced by $\mtequiv$.
%% \bjcom{What about the following?}
For the class of non-branching programs, it is also optimal, in the sense that it explores exactly one execution in each equivalence class.
  We first introduce essential concepts of \EventDPOR (\cref{sec:prels}) and then describe \EventDPOR itself (\cref{sec:algo:access-sets}).
Thereafter, specific parts in \EventDPOR are described:
the reversal of races (\cref{sec:race-reversals}), checking redundancy (\cref{sec:checkwi}),
and wakeup trees (\cref{sec:wakeuptrees}).
}
%% \EventDPOR is inspired by the
%% \OptimalDPOR algorithm of~\citet{optimal-dpor-jacm}, but modified according to the properties of the event-driven execution model.
%% A main difference from \OptimalDPOR is that in \EventDPOR the reversal of races may
%% require the messages on the same handler thread to execute in a different order.
%% \KS{This paragraph has repeated things which have been mentioned
%%   before... It can be trimmed.}

%% \subsection{Basic Algorithm Properties}
%% \label{sec:basic-props}
%% The \EventDPOR algorithm initially explores a maximal execution with abitrary message interleaving.
%% After exploring each maximal execution, the \EventDPOR algorithm analyses its races, which are then reversed to construct new
%% executions, that will later be extended to new maximal executions.
%% \EventDPOR explores one maximal execution sequence from each equivalence classs of \emph{Mazurkiewicz traces}.
%% The explored executions can be thought of as forming
%% a big exploration tree $\exseqs$, in which nodes correspond to explored executions, leaves correspond to maximal such sequences, and there is a total order $\treeorder$ on nodes of $\exseqs$, corresponding to the order in which they are explored.
%% %% where $\exseq \treeorder \exseq'$ if $\explore(\exseq)$ returns before $\explore(\exseq')$ according to \cref{sec:algo:access-sets}.
%% Note that, only the current maximal execution $\exseq$ is stored in its entirety
%% by the algorithm; already explored subtrees are de-allocated when the information they contain is no longer needed.

%% \bjcom{Skip these properties here?}
%% The \EventDPOR algorithm maintains the property that 
%% \begin{itemize}
%%   \item[P1:]
%%   Whenever the exploration of some subtree rooted at $\exseq \in \exseqs$ has finished,
%%   then for each maximal execution of form $\exseq.w$,
%%   the algorithm has explored an execution equivalent to $E.w$.
%% \end{itemize}
%% Property P1 guarantees correctness.
%% For non-branching programs, \EventDPOR also maintains the property that 
%% \begin{itemize}
%%   \item[P2:]
%%   After the exploration of a subtree rooted at $\exseq.p \in \exseqs$ has finished, the algorithm will thereafter not explore a maximal execution
%%   of form $E.w$, which is equivalent to some execution of form $\exseq.p.w'$.
%% \end{itemize}
%% Property P2 enforces optimality.
%% \bjcom{Revise the following}
%% Condition (2) is enforced by a check for redundancy (to be defined in \cref{def:redundancy}), which we can check precisely only for non-branching programs.
%% \KS{What is ``Condition 2''?}

\subsection{Central Concepts in \EventDPOR}
\label{sec:prels}
%% We here introduce central concepts in \EventDPOR. 
\hasbeenremoved{In this section, we define central concepts in \EventDPOR. We first define
the concepts of \emph{happens-before prefix} and \emph{weak initials},
which are used in the check for redundancy of new executions.
Thereafter, we define \emph{races}: these are used to construct new executions from already explored ones.}
%% We begin with concepts derived from the happens-before ordering and equivalence

\begin{definition}[Happens-before Prefix]
\label{def:hb-prefix}
Let $E$ and $E'$ be execution sequences.
We say that $E'$ is a {\em happens-before prefix} of $E$, denoted
$E' \mtprefix E$, if
\begin{inparaenum}[(i)]
\item
  $\dom{E'} \subseteq \dom{E}$,
\item
  $\happbf{\hb}{E'}$ is the restriction of $\happbf{\hb}{E}$ to $E'$, and
\item
  whenever $e \happbf{\hb}{E} e'$ for some $e' \in \dom{E'}$, then $e \in \dom{E'}$.
\end{inparaenum}
We let $w' \mtprefixafter{E} w$ denote that $E.w' \mtprefix E.w$.
  \qed
\end{definition}
Intuitively, $E' \mtprefix E$ denotes that the execution $E'$ is ``contained'' in the execution $E$
in such a way that it is not affected by the events in $E$ that are not in $E'$.
\footnote{The  relation $w' \mtprefixafter{E} w$ is also introduced in \citet{Maiya:tacas16}, as ``$w$ is a dependence-covering sequence of $w'$.''}
%% To illustrate, for  \cref{prog:independent-messages},
To illustrate, for the top left program of \cref{fig:example1new},
the execution $E'$ consisting of \evnt{t}{post($p_2$,$h$)} \hndlr{h}{p_2}{y\,=\,2} is a happens-before prefix of
any maximal execution of the program, since the event of $p_2$ cannot happen-after any other event than
the event that posts $p_2$, which is already in $E'$.

\begin{definition}[Weak Initials]
  \label{def:winits}
  Let $E$ be an execution sequence, and $w$ be a sequence with $\valid Ew$.
  The set $\winits{\exseq}{w}$ of \emph{weak initials of $w$ after $E$} is the set of messages $p$
  %% in $\enabled{E}$
such that $\valid \exseq p.w'$ for some $w'$ with $w \mtprefixafter{E} p.w'$.
\qed
\end{definition}
\begingroup
\setlength{\intextsep}{0em}%
\setlength{\columnsep}{.75em}%
Intuitively, $p$ is in $\winits{\exseq}{w}$ if $p$ can execute the first event in a continuation of $\exseq$ which ``contains'' $w$, in the sense of $\sqsubseteq$.
In \EventDPOR, the concept of weak initials is used to test whether a new sequence is redundant, i.e., is ``contained in'' an execution that have been explored or in
a wakeup sequence that is scheduled for exploration.
%% \cref{def:winits} provides a connection between weak initials and the properties of exploration trees given in \cref{sec:basic-props}.
%% From \cref{def:winits}, it follows that if $p \not \in \winits{\exseq}{w}$, then there can be no sequences $w', w''$ such that
%% $w.w'' \equivafter{E} p.w'$: thus any continuation of $E.w$ is guaranteed to be inequivalent to any continuation of $E.p$.
Note that in \cref{def:winits}, we can generally not choose $w'$ as $w \remove p$.
This happens, e.g., if $p$ does not occur in $w$ but instead $w$ contains another message $p'$ which executes on the same handler as $p$ and
does not conflict with $p$; in this case $w'$ must contain a completed execution of $p$ inserted before $p'$.

\begin{wrapfigure}{r}{0.46\textwidth}
  \footnotesize
  \begin{tikzpicture}[line width=1pt,framed,inner sep=1pt]
    \node[name=p,anchor=south west] at (-0.15,0.25) {{$s$}};
   \node[name=post1] at (0,0) {$\mathtt{post}(p_1,h)$};
    
    \draw[line width=0.5pt] ($(post1.north east)+(1pt,10pt)$)--($(post1.south east)+(1pt,-22pt)$);
    \draw[line width=0.5pt] ($(post1.north east)+(3pt,10pt)$)--($(post1.south east)+(3pt,-22pt)$);
    
    \node[name=q,anchor=south west] at (1.45,0.25) {{$t$}};
    \node[name=post2,anchor=west] at ($(post1.east)+(5pt,0.5pt)$) {$\mathtt{post}(p_2,h)$};
    
    \draw[line width=0.5pt] ($(post2.north east)+(1pt,10pt)$) -- ($(post2.south east)+(1pt,-22pt)$);
    \draw[line width=0.5pt] ($(post2.north east)+(3pt,10pt)$) -- ($(post2.south east)+(3pt,-22pt)$);
    
    \node[name=r,anchor=south west] at (2.7,0.25) {{$h$'s messages}};
    \node[name=m1,anchor=west] at ($(post2.east)+(8pt,0.5pt)$) {$p_1$: $\left[\texttt{x\,=\,1}\right]$};
    \node[name=m2,anchor=north west] at ($(m1.south west)+(0pt,-1pt)$) {$p_2$: $\left[\begin{array}{@{}l@{}}\texttt{y\,=\,2};\\ \texttt{z\,=\,2}\end{array}\right]$};
  \end{tikzpicture}
\vspace{-0.6cm}
  \caption{Illustrating weak initials}
  \label{prog:wi-illustration}
\end{wrapfigure}
We illustrate using the program shown on the right.
If we let $E$ be the execution $s.t$ and $w$ be the sequence $p_1$,
we have $p_2 \in \winits{\exseq}{w}$, since $w \mtprefixafter{E} p_2.p_2.p_1$.
%% If we let $E$ be \evnt{s}{post($p_1$,$h$)} \evnt{t}{post($p_2$,$h$)}, and $w$ be \hndlr{h}{p_1}{x\,=\,1},
%% we have $p_2 \in \winits{\exseq}{w}$, since $w \mtprefixafter{E} p_2.p_2.p_1$.
%% This example shows that to be able to determine whether $p_2 \in \winits{\exseq}{w}$ holds, we must know which accesses to shared variables are performed
%% by a completed execution of $p_2$ in order to determine whether any of them conflicts with the execution of $p_1$.
This illustration shows that in order to determine whether $p \in \winits{\exseq}{w}$ for a message $p$, one must know which shared-variable access will be performed by
$\nextev{E}{p}$, and, in case $p$ starts after $E$ but will execute after some other message on its handler,
also the sequences of shared-variable accesses that $p$ will perform when executing to completion.


The weak initial check problem consists in checking whether $p \in \winits{\exseq}{w}$.

\begin{theorem}
\label{thm-lowerbound}
The weak initial check problem is NP-hard. 
%\revise{This problem is NP-complete for acyclic  programs (i.e., without iterative statements) with a fixed number of thread and message creation. }
\end{theorem}

The proof of the above theorem can be found in \cref{thm-lowerbound-weak}.
In \cref{sec:checkwi}, we propose a sequence of inexpensive rendundancy checks, which have shown to be sufficient for all our benchmarks.

\endgroup % NEEDS TO HAVE AN EMPTY LINE BEFORE IT!

%% \begin{definition}[Doneset]
%%   \label{def:deneset}
%%   A doneset $\done$ is a function defined from a set of execution sequences to a set of event sequences.
%% \end{definition}
%% Let the \EventDPOR algorithm is currently exploring extensions of $E.p$.
%% In this context, $\done(\exseq)$ is the set of already explored event sequences as continuations of $E$
%% \begin{itemize}
%% \item If $p$ starts after $E$, then store the sequence of global events performed by $p$.
%% \item Otherwise store $\nextev{E}{p}$.
%% \end{itemize}

%% We can now define the notion of redundancy.
%% For an execution $\exseq$, a doneset $\done$ defined for the
%% prefixes of $\exseq$, and a message $p$, define $\since{\exseq}{\done}{p}$
%% to be the shortest suffix $w$ of $\exseq$ such that, with $\exseq = \exseq'.w$ we have $\nextev{\exseq'}{p}$ starts a
%% sequence in $\done(\exseq')$.
%% If there is no prefix $\exseq'$ of $\exseq$ where  $\nextev{\exseq'}{p}$  starts a
%% sequence in $done(\exseq')$, then $\since{\exseq}{\done}{p}$ is undefined.
%% If $\since{\exseq}{\done}{p}$ is defined, define $\before{\exseq}{\done}{p}$ by
%% $\exseq = \before{\exseq}{\done}{p}.\since{\exseq}{\done}{p}$.

%% \begin{definition}[Redundancy]
%%   \label{def:redundancy}
%%   Let $\exseq$ be an execution, and $v$ a sequence with $\valid Ev$. Let $\done$ be a mapping from prefixes of $\exseq$ to sets of messages, such that
%%   $\valid{E'}{p}$ whenever $p \in \done(E')$.
%%   We say that $v$ is \emph{redundant after $\tuple{\exseq,\done}$}, denoted
%%     $\redundant{\exseq}{\done}{v}$, if there is a message $p$, and a longest prefix $E_p$ of $E$ with $p \in \done(E_p)$ such that $p \in \winits{E_p}{w.v}$,
%%     where $E_p.w = E$.
%% %%   $E' = \before{\exseq}{\done}{p}$ and $w = \since{\exseq}{\done}{p})$.
%%   \qed
%% \end{definition}
%% %
%% Intuititively, $\redundant{\exseq}{\done}{v}$ holds if there is prefix $\exseq_p$ of $E$ and $p \in \done(\exseq_p)$, such that
%% $\exseq.v$ is a happens-before prefix of an execution which starts with $\exseq_p.p$.


%% \subsubsection*{Races}
%% \label{sec:races}
%% A central mechanism of \EventDPOR algorithm is to detect and reverse races.
%% Intuitively, a race is a conflict between two consecutive accesses to a shared variable, one of which is a write.
\begin{definition}[Races]
\label{def:races}
Let $E$ be a maximal execution sequence.
Two events $e$ and $e'$ in different messages are in a \emph{race}, denoted $e\revrace{E}e'$, if $e \happbf{\hb}{E} e'$ and
\begin{enumerate}[(i)]
\item
$e$ and $e'$ access a common shared variable and at least one is a write, and
\item  there is no event $e''$ with $e \happbf{\hb}{E} e''$ and $e'' \happbf{\hb}{E} e'$.
  \qed
\end{enumerate}
\end{definition}
Intuitively, a race arises between conflicting accesses to a shared variable, by events which are in different messages but adjacent
in the $\happbf{\hb}{E}$ order.
%% An event race $e\revrace{E}e'$ should occur in $E$ in such a way that if $\thof{e}$ is
%% suspended just before $e$, then there is an alternative continuation of the execution
%% in which $e'$ is the first event which conflicts with $e$; this is guaranteed by condition (ii).
%% Analogously,
%% a message race $p\revrace{E}e'$ should occur in $E$ in such a way that if the message $p$ is
%% suspended just before its first event in $E$, then there is an alternative continuation of the execution
%% in which $e'$ is the first event which conflicts with $p$, guaranteed by condition (ii).
%% As a particular case, if $e'$ is in another message $p'$ on the same handler as $p$, then $e'$ must be the first event in $p'$ which conflicts
%% with some event in $p$.

%% In \EventDPOR, new executions are explored by reversing races in already explored executions.
%% \EventDPOR reverses each race of form $e \revrace{E} e'$ by generating
%% an alternative execution of form $\exseq'.v$ in which the event $e'$ is performed, but not $e$.
%% to replace of $p$ after $\pre{\exseq}{\event}$ (or $\pre{\exseq}{p}$).
%% The sequence $v$ performs $e'$, the first event which conflicts with $e$ (or $p$), instead of $e$.
%% Condition (ii) of \cref{def:races} makes sure that it is possible to execute $v$ after $\pre{\exseq}{\event}$ (or $\pre{\exseq}{p}$).
%% In this alternative execution, $E'$ is a prefix of $E$, and
%% $v$, called a \emph{wakeup sequence}, is a suffix which deviates from $\exseq$.
%% A wakeup sequence consists of a \emph{notdep sequence}, denoted by $\notsucc{\event}{\exseq}$, followed by the event $e'$.
%% \begin{definition}
%%     \label{def:notdep}
%%   Let $E$ be a maximal execution sequence.
%%   \begin{itemize}
%%   \item
%%     For an event $e$ in $E$, define $\notsucc{\event}{\exseq}$, as the subsequence of $E$ consisting of the events $e'$ that occur after $\event$, such that
%%     \begin{enumerate}[(i)]
%%     \item it is not the case that $e \edseq{E}{E'} e'$ where $E'$ is $\pre{\exseq}{e}$.
%%     \end{enumerate}
%%   \item
%%     For a message $p$ and event $e$ in $E$, define $\notsucc{p}{\exseq}$
%%     as the subsequence of $E$ consisting of the events $e'$ not in $p$ that occur after the first event of $p$, such that
%%     \begin{enumerate}[(i)]
%%     \item $p \nhappbf{\hb}{E} e'$, and
%%     \item there is no event $e''$ in $E$ with $p \happbf{\hb}{E}$ and $e'' \edseq{E}{E'} e'$ where $E'$ is $\pre{\exseq}{\fst{p}}$.
%%       \qed
%%     \end{enumerate}
%%   \end{itemize}
%% \end{definition}
%% In other words, $\notsucc{\event}{\exseq}$ is formed from the events that do not happen-after $e$
%% (or $p$), but which could precede $e'$ in some execution that
%% is equivalent to $E$.
%% Note that $\notsucc{p}{\exseq}$ may include a message $p'$ that occurs after $p$ on the same handler as $p$ if $p$ and $p'$ are not in conflict; this reflects that $p'$ may occur before $p$ in an equivalent execution. On the other hand $\notsucc{\event}{\exseq}$ cannot include events that occur after $\event$ on the same handler: this reflects that $e$ is in a message that has already started before the occurrence of $e$ and cannot be suspended to schedule another message on the same handler.
%% In both cases, the sequence $v$ is constructed from the sequence $\notsucc{\event}{\exseq}$ (or $\notsucc{p}{\exseq}$)
%% as part of~\cref{alg:wakeuptree} for wakeup tree insertion, to be explained in \cref{sec:wakeup}.


%% Given an execution sequence $E$, a prefix $E'$ of $E$, and two events $e$ $e'$ in $E$, let
%% $e \hbmseq{E}{E'} e'$ denote the smallest transitive relation which includes $\happbf{\hb}{E}$ and in addition has the
%% property that $e \hbmseq{E}{E'} e'$  whenever
%% $e$ is in a message whose first event is in $E'$ and that $e'$  ccurs after $e$ on the same handler as $e$.
%% Intuitively, if $e \hbmseq{E}{E'} e'$ then $e$ must occur before $e'$ in any execution in $\mtclass{E}$ which has
%% $E'$ as a prefix.


\subsection{The \EventDPOR Algorithm}
\label{sec:algo:access-sets}

The \EventDPOR algorithm, shown as pseudocode in \cref{alg:eventdpor-access},
%% It stores generated wakeup sequences in wakeup trees: these are described in \cref{sec:wakeuptrees}.
%% for the case that each execution of a message performs the same sequence of shared-variable accesses.
performs a depth-first exploration of executions using the recursive procedure
$\explore(\exseq)$, where $\exseq$ is the currently explored execution,
which also serves as the stack of the exploration.
In addition the algorithm maintains three mappings from prefixes of $\exseq$, named $\done$, $wut$, and $\pendingwusname$.
For each prefix $\exseq'$ of $\exseq$, 
\begin{itemize}
\item $\done(\exseq')$ is a mapping whose domain is the set of messages $p$ for which the call $\explore(\exseq'.p)$ has returned.
If $p$ does not start after $E'$, then $\done(\exseq')(p)$ is the shared variable-access performed by $\nextev{E'}{p}$.
If $p$ starts after $E'$, then $\done(\exseq')(p)$ is the set of sequences of shared variable-accesses that can be performed in a completed
    execution of $p$ after $E'$.
   The information in $\done(\exseq')(p)$ is collected during the call $\explore(\exseq'.p)$
%% and entered during information collection
  (\crefrange{algacsl:collection-start}{algacsl:donesleeptree-add-ev}).
  \item $\wut{\exseq'}$ is a \emph{wakeup tree}, i.e., an ordered tree $\tuple{B,\prec}$ where
    $B$ is a prefix-closed set of sequences, whose leaves are wakeup sequences.
    For each sequence $u \in B$, the order $\prec$ orders its children (of form  $u.p$)
    by the order in which they were added to $\wut{\exseq'}$. This is also the order in which the sequences of form
    $\exseq'.u.p$ will be visited in the recursive exploration.
\hasbeenremoved{We extend $\prec$ to the post-order relation on $B$ induced by the ordering $\prec$ on children of a node.}
    %% For leaf $w \in B$ the sequence $\exseq'.w$
    %% will be explored during the call $\explore(\exseq')$ in the order given by $\prec$.}
  \item $\pendingwus{\exseq'}$ is a set of wakeup sequences $v$ that were previously being inserted into some wakeup tree $\wut{\exseq''}$, but
    were ``parked'' at the sequence $\exseq'$ because at that time there was not enough information to determine where in $\wut{\exseq''}$ to place $v$.
    Later, when a branch of $\wut{\exseq''}$ has been extended to a maximal execution,
    it should be possible to determine where to insert $v$.
 %% waiting to be inserted in an appropriate wakeup tree.
 %%    The wakeup sequences in $\pendingwus{\exseq'}$ have been previously parked there during ins is a set of wakeup sequences waiting to be inserted in an appropriate wakeup tree.
\end{itemize}
\hasbeenremoved{The already explored executions together with the sequences in the wakeup trees can be thought of as forming an exploration tree $\exseqs$.}

%% in which nodes correspond to explored executions,
%% leaves correspond to maximal such sequences,
%% and there is a total order $\treeorder$ on nodes of $\exseqs$, corresponding to the order in which they are explored.
%% where $\exseq \treeorder \exseq'$ if $\explore(\exseq)$ returns before $\explore(\exseq')$ according to \cref{sec:algo:access-sets}.
%% Note that
%% only the current maximal execution $\exseq$ is stored in its entirety by the algorithm;
%% already explored subtrees are deallocated when the information they contain is no longer needed.


Each call to $\explore(E)$ first initializes $\done(E)$ and $\pendingwus{E}$
($\wut{\exseq}$ was initialized before the call),
%% , into which information about explored subtrees of $E$ will later be inserted.
and thereafter enters one of two phases:
\emph{race detection} (\crefrange{algacsl:event-race-begin}{algacsl:event-race-end}) or
\emph{exploration} (\crefrange{algacsl:exploration-begin}{algacsl:donesleeptree-add-ev}).
%% \emph{execution exploration} (\crefrange{algacsl:exploration-begin}{algacsl:event-call-explore}), and
%% \emph{information collection} (\crefrange{algacsl:initialize-accesses}{algacsl:donesleeptree-add-ev}).
The race detection phase is invoked when $\exseq$ is a maximal execution sequence.
First, for each wakeup sequence $v$ parked at a prefix $E'$ of $E$ it invokes $\insertpendingwu{v}{E'}$ to insert $v$ into the appropriate wakeup tree
(\crefrange{algacsl:insert-parkedwus-begin}{algacsl:insert-pendingwu}).
% , to be described in \cref{sec:wakeuptrees}.
Thereafter, each race (of form $\event \revrace{\exseq} \event'$) in $\exseq$ is analyzed by $\reverserace(\exseq,e,e')$, which returns a set of
executions that reverse the race. Each such execution $E'.v$ is returned as a pair $\tuple{E',v}$, where $v$ is a wakeup sequence that should be
considered for insertion in the wakeup tree at $E'$.
%%   that it performs $\event'$ (together with all events that are needed to enable $\event'$) without performing $\event$, and furthermore is a maximal execution   with this property.
%% The function $\reverserace$ is further elaborated in \cref{sec:race-reversals}.
%%   In the execution $E'.v$, the prefix $E'$ is the maximal prefix of $E$ which does not conflict with $E'.v$ and the suffix $v$ is the wakeup sequence.
%% The subsequence $\notsucc{\event}{\exseq}$ of $\exseq$
%% consisting of the events that do not happen-after $\event$ in $\exseq$ is extracted. From this sequence, maximal executions $\exseq''$ that enable
%% $\event'$ (i.e., contain the $\happbf{\po}{E}$-predecessor of $\event'$) are extracted. Often, all events in $\notsucc{\event}{\exseq}$ can be ordered into
%% such a sequence, in which case only one such maximal $\exseq''$ need be considered.
%% %% (lines~\ref{algacsl:msg-race-assign-x} and~\ref{algacsl:normal-race-assign-x}).
%% \item Each sequence $\exseq''$ formed in the first step is extended with $\procof{\event'}$. The resulting sequence $\exseq.\procof{\event'}$ is then organized as the concatenation
%%   of a maximal consistent prefix $\exseq'$ of $\exseq$, followed by the suffix $u.\procof{\event'}$, so that
%%   $\exseq'.u.\procof{\event'} \mtequiv \exseq''.\procof{\event'}$. The sequence $v$, defined as $u.\procof{\event'}$ is the wakeup sequence.
%% %%   which, if it is not redundant, will be inserted into $\wut{\exseq'}$ .
Each wakeup sequence $v$ is checked for redundancy (\cref{algacsl:event-test}), using
the information in $\done$.
%%   according to \cref{def:redundancy}.
If $v$ is not redundant, it is inserted 
into the wakeup tree at $E'$ for future exploration (\cref{algacsl:event-insert}).
\hasbeenremoved{Wakeup tree insertion is elaborated below, and in~\cref{alg:wakeuptree}.}

\input{alg-code-access-sets}

The exploration phase (\crefrange{algacsl:exploration-begin}{algacsl:exploration-end})
is entered if exploration has not reached the end of a maximal execution sequence.
First, if $\wut{\exseq}$ only contains the empty sequence, then 
an arbitrary enabled message is entered into $\wut{\exseq}$ (\cref{algacsl:wut-empty-choose,algacsl:wut-empty-init}).
Thereafter, each sequence in $\wut{\exseq}$ is subject to recursive exploration.
We find the $\prec$-minimal child $p$ of the root of $\wut{\exseq}$ (\cref{algacsl:pick-WuT}),
and make the recursive call $\explore(\exseq.p)$ (\cref{algacsl:event-call-explore}).
Before the call, $\wut{\exseq.p}$ is initialized (\cref{algacsl:def-WuT}).
During the call $\explore(\exseq)$, information is also collected about the sequences of shared-variable accesses that can be performed by each message that is active after $\exseq$,
and subsequently stored in the mapping $\done$.
The information is collected in the variable $\accesses$, which
is initialized at \cref{algacsl:accesses-initialize}.
%% mapping each message that is active after $\exseq$ to the empty set of access sequences.
%% to be returned at \cref{algacsl:exploration-end}, and 
%% where it is used in the check for redundancy (\cref{algacsl:event-test}) and during wakeup tree insertion.
Each recursive call $\explore(\exseq.p)$ returns the sets of access sequences performed by messages that are active after $\exseq.p$ (\cref{algacsl:event-call-explore}).
After prepending the access performed by $\nextev{E}{p}$ to the sets of access sequences performed by $p$ (\cref{algacsl:extend-tmpaccesses}),
the sets  returned by $\explore(\exseq.p)$ are added to the corresponding sets in $\accesses$ (\cref{algacsl:accumulate-accesses}).
Finally, $p$ is added to the domain of $\done(E)$ (\cref{algacsl:doneset-add}).
If $p$ starts a message after $E$, then  $\done(\exseq)(p)$ is assigned the set of access sequences performed by $p$ (\cref{algacsl:donesleeptree-add}), otherwise only the access of
$\nextev{E}{p}$.
Thereafter, the subtree rooted at $p$ is removed from $\wut{\exseq}$ (\cref{algacsl:exploration-end}).
When all recursive calls of form $\explore(\exseq.p)$ have returned, the accumulated sets of access sequences are returned (\cref{algacsl:exploration-end}).

%% \begin{description}
%% \item[Exploration] is pursued if exploration has not reached the end of a maximal execution sequence.
%% It picks the next unexplored leaf of a wakeup tree, and extends it, through a sequence of recursive calls to $\explore()$, to a maximal execution, where the race detection mode is entered. After completing the race detection mode, exploration backtracks and moves to the next
%% %% by returning from the recursive calls to $\explore()$, and makes a new sequence of recursive calls to reach the next
%% unexplored leaf of a wakeup tree. During backtracking, information about explored subtrees and shared variable accesses performed by messages, which is needed for redundancy tests, are collected into the variable $\done$. This information collection is performed at \crefrange{algacsl:collection-start}{algacsl:donesleeptree-add-ev}.
%% \item[Race Detection] mode is entered when $\exseq$ is a maximal execution.
%%     In this mode, the races in $\exseq$ are detected and analyzed, and from each race, of form $\event \revrace{\exseq} \event'$, a set of alternative (non-maximal) executions is generated.
%%     Each alternative execution reverses the race $\event \revrace{\exseq} \event'$ in the sense that it performs $\event'$ without performing $\event$, and is structured as $E'.v$, where
%%     $E'$ is a prefix of the current execution $E$, and $v$ is an alternative continuation, called a \emph{wakeup sequence}.
%%     The sequence $E'.v$ is then subject to a \emph{redundancy test}, which checks whether $E'.v$ is contained in a previously explored execution, using information which is collected
%%     in the variable $\done$. If this test finds $E'.v$ not to be redundant, the procedure $\insertwusname$ is invoked, which, if needed, adds a new leaf to the wakeup tree of $E'$.
%% \end{description}
%% The initial call is $\explore(\emptyseq)$, upon which the wakeup tree $\wut{\emptyseq}$ is initialized with the empty sequence. $\explore$ thus enters exploration mode and
%% extends this empty sequence to a maximal execution with arbitrary message interleaving, whereafter it enters the race detection mode, and so on.

\EventDPOR  calls functions that are briefly described in the following paragraphs. 
More elaborate descriptions (with pseudocode) are in~\cref{sec:functions-appendix}.

\noindent\emph{$\reverserace({E},{\event},{\event'})$} is given a race $\event \revrace{\exseq} \event'$
in the execution $\exseq$ (\cref{algacsl:race-loop}),
and returns a set of executions that reverse the race in the sense that they 
perform the second event $e'$  of the race without performing the first one, and (except for $e'$) only contain events that are not affected by the race.
More precisely, it returns a set of pairs of form $\pair{E'}{u.e'}$, such that
\begin{inparaenum}[(i)]
\item
  %% $E'.u \mtprefix E$ and
$E'.u$ is a maximal happens-before prefix of $E$ such that $E'.u.e'$ is an execution, and
\item $\dom{E'}$ is a maximal subset of $\dom{E'.u}$ such that $E' \leq E$.
\end{inparaenum}
An illustration of the $\reverserace$ function was given for the race on \texttt{x} in the program of \cref{fig:example3}.

  \hasbeenremoved{
    As an illustration, consider the race on \texttt{x} in the program of \cref{fig:example3}.
Here, there is a unique (up to equivalence) maximal execution which reverses the race, which consists of all events that post messages, all events in messages
    $p_2$ and $q_2$, and the assignment to \texttt{d} by $p_1$. The read of \texttt{x} by~$q_2$ should be ordered last, since it corresponds to the racing event $e'$.
    Message $q_1$ is removed by the rule at \cref{algl:revrace-rule-must}, whereby also the second of event of $p_1$ is removed, since it reads from the first event in $q_1$.
  }
  
\noindent\emph{$\insertwus{v}{E'}{\emptyseq}$} inserts the wakeup sequence $v$ into the wakeup tree $\wut{E'}$. If there is already some sequence $u$ in $\wut{E'}$ such that $u \mtprefixafter{E'} v$ or
  $v \mtprefixafter{E'} u$, then the insertion leaves $\wut{E'}$ unaffected. Otherwise
  $\insertwus{v}{E'}{\emptyseq}$ attempts to find the $\prec$-minimal non-leaf sequence $u$ in $\wut{E'}$ with $u \mtprefixafter{E'} v$, and
  insert a new leaf of form $u.v'$ into $\wut{E'}$, such that $v \mtprefixafter{E'} u.v'$, which is ordered after all existing descendants of $u$ in $\wut{E'}$.
  The function finds such a $u$ by descending into $\wut{E'}$ one event at a time; from each node $u'$ it finds a next node $u'.p$ as the $\prec$-minimal child with 
  $u'.p \mtprefixafter{E'} v$. If, during this search, the message $p$ starts after $E'.u'$ it may happen that the wakeup tree does not contain enough subsequent events to determine whether
  $u'.p \mtprefixafter{E'} v$; in this case the sequence $v$ is ``parked'' at the node $u'.p$: the insertion of $v$ will be resumed when $E'.u'.p$ is extended to a maximal execution (at \cref{algacsl:insert-pendingwu} with $E'$ being $E'.u'$).

\noindent\emph{$\insertpendingwu{v}{E'}$} inserts a wakeup sequence $v$, which is parked after a prefix $E'$ of the execution $E$, into an appropriate wakeup tree.
The function first decomposes $E'$ as $E''.p$, and checks whether
$p \in \winits{\exseq''}{v}$, using 
information about the accesses of $p$ that can be found in $E$.
%% , so that the check $p \in \winits{\exseq''}{v}$ can be performed.
%% The check will be exact for non-branching programs, but possibly conservative in general.
If the check succeeds, then insertion proceeds recursively
one step further in the execution $E$, otherwise $v$ conflicts with $p$ and should be inserted into the wakeup tree after $E''$.
%% \Cref{alglpwu:former-leaf} checks whether $E''$ was the leaf that is extended to the currently explored execution.
%% If so, the insertion can return without inserting anything, in analogy
%% with how leaves are handled in wakeup tree insertion
%% (\cref{alg:wut-insert-empty} of \cref{alg:wakeuptree}).

\noindent\emph{Checking for Redundancy}
%% A frequent operation in \EventDPOR is to test whether a sequence $w$ is equivalent to an already explored execution, phrased as a test of form
%% Such a test appears at \cref{algacsl:event-test} of \cref{alg:eventdpor-access}; it is defined in \cref{def:redundancy} using the concept of weak initials (\cref{def:winits}).
Tests of form $p \in \winits{\exseq}{w}$ for a message $p$ and an execution $\exseq.w$
appear at
\cref{algacsl:event-test} and in the functions $\insertwusname$ and $\insertpendingwuname$.
If $p$ does not start after $E$, then the check can be straightforwardly performed using
sleep sets~\cite{Godefroid:thesis}.
If $p$ starts after $E$, then checking whether $p \in \winits{\exseq}{w}$ is NP-hard in the general case (see~\cref{thm-lowerbound}).
To avoid expensive calls to a decision procedure,
\EventDPOR employs a sequence of incomplete checks, starting with simple ones, and proceeding with a next test only if the preceding was not conclusive.
%% We assume that $p$ has been posted in $E$, otherwise $p \in \winits{\exseq}{w}$ is trivially false.
These tests are in order:
\begin{inparaenum}[1)]
  \item
  If $p$ is the first message (if any) on its handler in $w$, then $p \in \winits{\exseq}{w}$ is trivially true.
\item
  If the happens-before relation precludes $p$ from executing first on its handler, then $p \in \winits{\exseq}{w}$ is false; checking this may require
  $w$ to be extended so that $p$ (and possibly other messages) are executed to completion.
\item An attempt is made to construct an actual execution in which $p$ is the first message on its handler, which respects the happens-before ordering.
\item If all previous tests were inconclusive, a decision procedure is invoked as a final step.
\end{inparaenum}
  

  
\hasbeenremoved{\subsection{Reversing Races}
\label{sec:race-reversals}
\input{alg-code-reverserace-short}
A key procedure of \EventDPOR is $\reverserace$ which constructs new executions by analyzing and reversing a race in an explored execution.
This procedure is given a race $\event \revrace{\exseq} \event'$ in the currently explored execution $\exseq$ (at \cref{algacsl:race-loop} of \cref{alg:eventdpor-access}),
and returns a set of maximal executions that reverse the race in the sense that they 
perform the second event $e'$  of the race without performing the first one, and (except for $e'$) only contain events that are not affected by the race.
The procedure $\reverserace({E},{\event},{\event'})$, shown in \cref{alg:reverserace-short}, returns, 
for each maximal subset of $E''\cup\set{e'}$ that can be linearized to an execution that ends in $e'$, one such execution $E'.u.e'$ in which
$E'$ is a maximally long prefix of $E$; each execution $E'.u.e'$ is returned as a pair of form $\pair{E'}{u.e'}$.
}



\hasbeenremoved{
The \EventDPOR algorithm maintains the following properties
\begin{itemize}
   \item[P1:]
  whenever the exploration of some subtree rooted at some execution $\exseq.p \in \exseqs$ has completed,
  then for each maximal execution of form $\exseq.p.w$, the algorithm has explored an execution equivalent to $E.p.w$.
%% Namely, if there is no
%% prefix $E''$ of $E'$ (with $E' = E''.w$) and message $p$ with $p \in \winits{E''}{w.v}$
%% for which the subtree rooted at $E''.p$ has been explored,
%% then $E''.w.v$ is not contained in any extension of $E''.p$, implying that no maximal
%% extension of $E''.w.v$ can be equivalent to a maximal extension of $E''.p$.
%% Property P1 is the basic property which guarantees correctness. It is also used to avoid redundant exploration by enforcing that 
   \item[P2:]
whenever the exploration tree $\exseqs$ contains a node of form $\exseq.p$, then the algorithm will not add an execution of form $\exseq.w$ which is contained in
some execution of form $\exseq.p.w'$ for some $w'$, i.e., for which $p \in \winits{\exseq}{w}$.
\end{itemize}
Property P1 is the basic property which guarantees correctness. It is also used to avoid redundant exploration by enforcing P2. Such a check for redundancy is performed
before inserting a new wakeup sequence (\cref{algacsl:event-test}),
and also inside the procedure for wakeup tree insertion (\cref{alg:wakeuptree}).
}

%% The variable $\done$ maintains the following information which is needed to perform the redundancy test at \cref{algacsl:event-test}, as explained after \cref{def:winits}.
%% \begin{itemize}
%% \item
%%   For each prefix $E'$ of $E$, the domain of $\done(E')$ is
%%   set of messages $p$ for which the exploration of the subtree rooted at $E'.p$ has been completed.
%%   \item $\done(E')$ maps each message $p$ in its domain to
%% \begin{inparaenum}[(i)]
%%   \item the shared variable-access performed by $\nextev{E'}{p}$ if
%% $p$ does not start after $E'$, and
%%   \item the sequences of shared variable-accesses that can be performed in a completed
%%     execution of $p$ after $E'$, if $p$  starts after $E'$.
%% \end{inparaenum}
%% \end{itemize}
%% This information is collected and entered during information collection (\crefrange{algacsl:collection-start}{algacsl:donesleeptree-add-ev}).

%% the set of messages $p$ for which the exploration of the subtree
%% rooted at $E'.p$ has been completed, and whose range is
%%  know for which messages $p$  the exploration of the subtree
%% rooted at $E'.p$ has been completed. In addition, the redundancy test also needs to know
%% which shared variable-access (if any) it performs, i.e., whether it reads and/or writes and to which variable. In case $p$ starts after $E'$, then the redundancy tests also must know which are the possible sequences of accesses that can be performed by a completed execution of message $p$. The variable $\done$ therefore maps each prefix $E'$ of
%% the current execution to a mapping $\done(E')$ whose domain is
%% the set of messages $p$ for which the exploration of the subtree
%% rooted at $E'.p$ has been completed, and whose range is


%% Let us now go through the pseudocode of \cref{alg:eventdpor-access}.
%% The algorithm maintains the global variables $\wutname$ and $\done$ which have been described above, and $\pendingwusname$, which will be described
%% together with wakeup tree insertion in \cref{sec:wakeuptrees}. 
%% \begin{itemize}
%% \item $\wutname$, a mapping from prefixes of $\exseq$ to wakeup trees. For a prefix $E'$ of $E$, the wakeup
%%   tree $\wut{E'}$ contains sequences that continue $E'$ in a different way than in $E$, and will later be explored by the algorithm.
%%   When $\explore(\exseq)$ is first called, the wakeup tree $\wut{\exseq}$ is initialized to the empty tree. It is
%%   later extended as a result of analyzing executions that are explored during the call $\explore(E)$.
%% \item $\done$, a mapping which maps each prefix of $\exseq$ to a mapping from messages to  sequences of shared-variable accesses. For a prefix $E'$ of $E$, the set
%%   $\done(E')$ is a mapping, whose domain is the set of messages $p$ for which the subtree rooted at $E'.p$ has already been explored.
%%   If $p$ does not start after $E'$, then $\done(E')(p)$ is the shared-variable access performed by $\nextev{E'}{p}$.
%%   If $p$ starts after $E'$, then $\done(E')(p)$ is a sequence of shared-variable accesses that will be performed by a complete execution of message $p$.
%% %% \item $\doneaccesses$, a mapping from prefixes $E'$ of $\exseq$ and messages $p \in \done(E')$ that start after $\exseq'$
%% %%   (i.e., for which $\nextev{E'}{p} = \fst{p}$) to sequences of shared-variable accesses, such that $\doneaccesses(E')(p)$ is
%% \item $\pendingwusname$, a mapping from prefixes of $\exseq$ of form $\exseq'.p$, such that $p$ starts after $\exseq'$ to sets (actually queues)
%% of wakeup sequences, which are to be inserted into an appropriate wakeup tree.
%% \end{itemize}
%%
%% When $\explore(\exseq)$ is first called, the wakeup tree $\wut{\exseq}$ is initialized to the empty tree; it can
%% thereafter be extended by adding wakeup sequences that are constructed as the result of analyzing races in explored executions.
%%
%% Each call to $\explore(E)$ starts by initializing the sets $\done(E)$ and $\pendingwus{E}$.
%% %% , into which information about explored subtrees of $E$ will later be inserted.
%% Thereafter, a call to $\explore(E)$ consists of two phases:
%% race detection (\crefrange{algacsl:event-race-begin}{algacsl:event-race-end}) and
%% execution exploration (\crefrange{algacsl:exploration-begin}{algacsl:exploration-end}).
%% The race detection phase is invoked when $\exseq$ is a maximal execution sequence.
%% In this phase, first parked wakeup sequences are considered
%% (\crefrange{algacsl:insert-parkedwus-begin}{algacsl:insert-pendingwu}).
%% % , to be described in \cref{sec:wakeuptrees}.
%% Thereafter, each race in the explored execution $\exseq$ is analyzed by a call $\reverserace(\exseq,e,e')$, which returns a set of pairs $\tuple{E',v}$, each of which can form
%%  an execution $E'.v$, which reverses the race in the sense
%%   that it performs $\event'$ (together with all events that are needed to enable $\event'$) without performing $\event$, and furthermore is a maximal execution
%%   with this property. The function $\reverserace$ is further elaborated in \cref{sec:race-reversals}.
%% %%   In the execution $E'.v$, the prefix $E'$ is the maximal prefix of $E$ which does not conflict with $E'.v$ and the suffix $v$ is the wakeup sequence.
%% %% The subsequence $\notsucc{\event}{\exseq}$ of $\exseq$
%% %% consisting of the events that do not happen-after $\event$ in $\exseq$ is extracted. From this sequence, maximal executions $\exseq''$ that enable
%% %% $\event'$ (i.e., contain the $\happbf{\po}{E}$-predecessor of $\event'$) are extracted. Often, all events in $\notsucc{\event}{\exseq}$ can be ordered into
%% %% such a sequence, in which case only one such maximal $\exseq''$ need be considered.
%% %% %% (lines~\ref{algacsl:msg-race-assign-x} and~\ref{algacsl:normal-race-assign-x}).
%% %% \item Each sequence $\exseq''$ formed in the first step is extended with $\procof{\event'}$. The resulting sequence $\exseq.\procof{\event'}$ is then organized as the concatenation
%% %%   of a maximal consistent prefix $\exseq'$ of $\exseq$, followed by the suffix $u.\procof{\event'}$, so that
%% %%   $\exseq'.u.\procof{\event'} \mtequiv \exseq''.\procof{\event'}$. The sequence $v$, defined as $u.\procof{\event'}$ is the wakeup sequence.
%% %% %%   which, if it is not redundant, will be inserted into $\wut{\exseq'}$ .
%%   Each wakeup sequence $v$ is checked for redundancy (\cref{algacsl:event-test}), using
%%  the information in $\done$ as explained above.
%% %%   according to \cref{def:redundancy}.
%%   If $v$ is not redundant, it is inserted 
%%   into the wakeup tree at $E'$ for future exploration (\cref{algacsl:event-insert}).
%%   Wakeup tree insertion is elaborated in~\cref{alg:wakeuptree}.


%% The exploration phase (\crefrange{algacsl:exploration-begin}{algacsl:exploration-end})
%% is entered if exploration has not reached the end of a maximal execution sequence.
%% First, if $\wut{\exseq}$ only contains the empty sequence, then 
%% an arbitrary enabled message is entered into $\wut{\exseq}$ (\cref{algacsl:wut-empty-choose,algacsl:wut-empty-init}).
%% Thereafter, each sequence in $\wut{\exseq}$ is subject to exploration.
%% We find the left-most (i.e., minimal) single-message child $p$ of the root of $\wut{\exseq}$ (\cref{algacsl:pick-WuT}),
%% and call $\explore$ recursively for the
%% sequence $\exseq.p$ (\cref{algacsl:event-call-explore}).
%% Before the call, $\wut{\exseq.p}$ is initialized (\cref{algacsl:def-WuT}).
%% After the call, $p$ is added to $\done(E)$ (\cref{algacsl:doneset-add}),
%% and all sequences beginning with $p$ are removed from $\wut{\exseq}$ (\cref{algacsl:exploration-end}).

%% During the exploration phase, the algorithm also performs \textbf{information collection} about the sequences of shared-variable accesses that can be performed by each message; this information is stored in the mapping $\done$ and is used in the check for redundancy (\cref{algacsl:event-test}) and during wakeup tree insertion.
%% The information is collected in the variable $\accesses$ to be returned at \cref{algacsl:exploration-end}.
%% The variable $\accesses$ is initialized at \cref{algacsl:accesses-initialize}, mapping each message that has yet to perform some event(s) after $\exseq$ to the empty set of access sequences.
%% Each recursive call $\explore(\exseq.p)$ returns the set of access sequences performed by messages that are active after $\exseq.p$ (\cref{algacsl:event-call-explore}).
%% From this, the access performed by $\nextev{E}{p}$ is prepended to the concerned sequences (\cref{algacsl:extend-tmpaccesses}). If $\nextev{E}{p}$ is the first event of message $p$, then the information about the access sequences performed by $p$ is entered into $\done(\exseq)(p)$ (\cref{algacsl:donesleeptree-add}).
%% Thereafter, the access sequences in $\tmpaccesses$ are added to $\accesses$ (\cref{algacsl:accumulate-accesses}).
%% Finally, the message $p$ is added to $\done(\exseq)$ (\cref{algacsl:doneset-add}) and its subtree is reclaimed from the exploration tree (\cref{algacsl:wut-deletebranch}).
%% When all recursive calls of form $\explore(\exseq.p)$ have returned, the accumulated sets of access sequences are returned (\cref{algacsl:exploration-end}).

%% After $\explore(\exseq.p)$ has returned, its return value is stored in the mapping $\accesses$ from messages to sequences
%% of accesses. If the current event $\nextev Ep$ performs a global access, it is prepended to $\accesses(p)$ (\cref{algacsl:extend-tmpaccesses}).
%% Thereafter, if $p$ is the first event of a new message $m$, the sequences of its accesses is entered into the global variable as $\doneaccesses(\exseq)(p)$ (\cref{algacsl:donesleeptree-add}), otherwise the current set of accesses is extended \bjcom{I did not understand}.
%% %% (\cref{algacsl:doneet-addincsleeptree}).
%% After performing the recursive exploration calls to children of form $E.p$, the call $\explore(\exseq)$ returns the mapping
%% $\accesses$ resulting from the first recursive call. From the assumption that a message performs the same sequence of accesses in each
%% call, it does not matter which of the recursive calls is used for returning $\accesses$ from $\explore(\exseq)$.


%% be the set of events of $E$ that are not affected by the race (\cref{algl:revrace-init-notdep}):
%% this is the set of events $e'''$ with $\event \nhappbf{\hb}{E} \event'''$. If $E''$ can be reordered to form an execution, $\reverserace$ terminates and returns it.
%% However, there are situations in which $E''$ cannot be reordered into an execution.
%% For instance, $E''$ may contain two incompletely executed messages on the same handler because the remaining parts of these messages happen-after $e$ in $E$.
%% Since a wakeup sequence may contain at most one incompletely executed message per handler,
%% $\reverserace$ then performs a sequence of message removals and reorderings to produce a set of maximal wakeup sequences.
%%   The procedure employs the saturation operation of \cref{def:weakall} to constrain the ordering between messages on the same handler. 
%% % A simple example includes message-message races, illustrated by \cref{fig:example1new}, where all of message $p_1$ must be removed from $\exseqmay$ in order to form an execution.
%%   The procedure maintains
%% %%  a sequence $E''$, initialized to the events that could possible be in $E'.u$
%%   an ordering relation $\happbf{sc}{E''}$ on $E''$, initialized to $\weaksatrel{\happbf{hb}{E''}}$ (\cref{algl:revrace-init-ordering}).
%% It thereafter performs a sequence of steps in which messages are removed from $E''$ and/or the ordering relation $\happbf{sc}{E''}$ is extended. Some steps may be resolved nondeterministically: in such cases the procedure pursues all possible alternatives, potentially resulting in several returned sequences. The steps of \cref{alg:reverserace} are the following.
%%   \begin{description}
%%     \item[\cref{algl:revrace-rule-must}]
%%       If a partially executed message includes an event $e'''$ with $e''' \happbf{hb}{E''} e''$, then
%%       any other message on the same handler which is not completely executed in $E''$ must be removed.
%%     %% \item A message containing events that are ordered (by $\happbf{sc}{E''}$) after events in an incompletely executed message
%%     %%   on the same handler must be discarded.
%%     \item[\cref{algl:revrace-rule-choose}]
%%       If several incompletely executed messages execute on the same handler, then all except one of them must be removed. This is done nondeterministically, potentially leading to several returned wakeup sequences.
%%     \item[\cref{algl:revrace-rule-last}]
%%       Whenever a handler has an incompletely executed message $p$, any other message $p'$
%%     on that handler must be executed before $p$, represented by extending $\happbf{sc}{E''}$ from the last
%%     event of $p'$ to the first event of $p$ and then saturating.
%%   \item[\cref{algl:revrace-rule-cycle}]
%%     If $\happbf{sc}{E''}$ becomes cyclic during the filtering and ordering procedure, then each cycle should be broken by
%%       removing the events in a suitable message.
%%   \end{description}
%%     After the sequence, the resulting sequence $E''$ is linearized while respecting $\happbf{sc}{E''}$. Then the decomposition of $E''$ into $E'.u$ is determined (\cref{algl:revrace-determine-prefix}), and the event $e'$ is added at the end.



%%     \begin{itemize}
%%   \item the earliest message which is discarded, or preceded by another one on its handler,
%%   \item otherwise the entire computation preceding $\event$.
%%   \end{itemize}
%% \bjcom{We should describe how this procedure is guided by sleep sets}


