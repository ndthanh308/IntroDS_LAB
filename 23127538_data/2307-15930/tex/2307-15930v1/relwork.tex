\section{Related Work} \label{sec:related}
%=========================================

%% Several influential tools
%% such as 
%% Verisoft~\cite{Godefroid:popl97,Godefroid:verisoft-journal} and 
%% CHESS~\cite{MQBBNN:chess}
%% implement stateless model checking for concurrent programs.
%% %
%% SMC has been combined with 
%% (dynamic) partial order
%% reduction (DPOR), e.g. by~\citet{FG:dpor}, \citet{abdulla2014optimal},
%% and~\citet{RodriguezSSK15},
%% and applied to real life programs~\cite{GoHaJa:heartbeat,KoSa:spin17}.
%% The majority of SMC techniques are based on
%% exploring at least one execution for each Mazurkiewicz trace. 
%% %
%% In \citeyear{abdulla2014optimal}, \citeauthor{abdulla2014optimal} introduced a method that is optimal
%% with respect to Mazurkiewicz traces.
%% As illustrated in
%% the introduction, this approach has
%% an inherent limit on the reduction that can be achieved.

%% SMC has been implemented in many tools
%% (e.g., VeriSoft~\cite{Godefroid:verisoft-journal},
%% \textsc{Chess}~\cite{MQBBNN:chess}, Concuerror~\cite{Concuerror:ICST13},
%% \Nidhugg~\cite{tacas15:tso}, rInspect~\cite{DBLP:conf/pldi/ZhangKW15},
%% \CDSChecker~\cite{NoDe:toplas16}, \RCMC~\cite{KLSV:popl18}, and
%% \GenMC~\cite{GenMC@CAV-21}), and successfully applied to realistic
%% % concurrent
%% programs (e.g.,~\cite{GoHaJa:heartbeat} and~\cite{KoSa:spin17}).
%% To reduce the number of explored schedulings,
%% SMC tools typically employ \emph{dynamic partial order reduction}
%% (DPOR)~\cite{FG:dpor,abdulla2014optimal}. DPOR defines an equivalence relation on executions, which
%% preserves relevant correctness properties, such as reachability of local
%% states and assertion violations, and explores at least one execution in each equivalence class.
%% \hasbeenremoved{We call a DPOR algorithm \emph{optimal} if it guarantees the exploration of exactly one execution per
%% equivalence class.}

Stateless model checking has been implemented in many tools for analysis of multithreaded programs (e.g., \cite{Godefroid:verisoft-journal,MQBBNN:chess,Concuerror:ICST13,tacas15:tso,DBLP:conf/pldi/ZhangKW15,NoDe:toplas16,KLSV:popl18,GenMC@CAV-21}). It often employs DPOR, introduced by Flanagan and Godefroid~\cite{FG:dpor} to reduce the number of schedulings that must be explored. Further developments of DPOR reduce this number further, by being optimal (i.e., exploring only one scheduling in each equivalence class)~\cite{abdulla2014optimal,optimal-dpor-jacm,observers,KMGV:popl22} or by
weakening the equivalence~\cite{observers,CS-DPOR@CAV-17,DC-DPOR@POPL-18,rfsc@OOPSLA-19}.

DPOR has been adapted to event-driven multi-threaded programs. Jensen et al.~\citet{Event-DrivenSMC@OOPSLA-15} consider an execution model in which events are processed in arbitrary order (multiset semantics) and apply it to JavaScript programs.
Maiya et al.~\citet{Maiya:tacas16} consider a model where events are processed in the order they are received (FIFO semantics), and develop a tool, EM-Explorer, for analyzing Android applications which, given a particular sequence of event executions, produces a set of reorderings of its events which reverses its conflicts.
%
The above works are based on the algorithm of Flanagan and Godefroid~\citet{FG:dpor}, implying that they do not take advantage of subsequent improvements in DPOR algorithms~\cite{abdulla2014optimal,optimal-dpor-jacm,KMGV:popl22}, nor do they employ techniques such as sleep sets for avoiding redundant explorations. It is known~\cite{optimal-dpor-jacm}that even with sleep sets, the algorithm of Flanagan and Godefroid~\citet{FG:dpor} can explore an exponential number of redundant execution compared to the algorithms of~\cite{abdulla2014optimal,optimal-dpor-jacm,KMGV:popl22}. Without sleep sets, the amount of redundant exploration will increase further.
Recently, Trimananda et al.~\citet{Trimananda:vmcai22} have proposed an adaptation of stateful DPOR~\cite{YWY:stateful-dpor,YangCGK@SPIN-08} to non-terminating event-driven programs, which has been implemented in Java PathFinder. For analogous reason as for~\citet{Event-DrivenSMC@OOPSLA-15,Maiya:tacas16}, also this approach does not avoid to perform redundant explorations.
  
For actor-based programs, in which processes communicate by message-passing, Aronis et al.~\citet{observers} have presented an improvement of \OptimalDPOR in which two postings of messages to a mailbox are considered as conflicting only if their order affects the subsequent behavior of the receiver. Better reduction can then be achieved if the receiver selects messages from its mailbox based on some criterion, such as by pattern matching on the structure of the message.
However, this execution model differs from the one we consider. 

Event-driven programs where handlers select messages in arbitrary order from their mailbox can be analyzed by modeling messages (mini-)threads that compete for handler threads by taking locks, and applying any SMC algorithm for shared-variable programs with locks.
Since typical SMC algorithms always consider different lock-protected code sections as conflicting, this approach has the drawback of exploring all possible orderings of events on a handler.
There exists a technique to avoid exploring of all these orderings in programs with locks, in which lock sections can be considered non-conflicting if they do not perform conflicting accesses to shared variables. This LAPOR technique~\citet{LAPOR@OOPSLA-19} is based on optimistically executing lock-protected code regions in parallel, and aborting executions in which lock-protected regions cannot be serialized. This can led to significant useless exploration, as also shown in our evaluation in \cref{sec:eval}.

The problem of detecting potentially harmful data races in single executions of event-driven programs has been addressed by several works.
The main challenge for data race detection is to capture the often hidden dependencies for applications on Android~\cite{Hsiao:pldi14,Maiya:pldi14,Bielik:android-races,Hu:issta16} or on other platforms~\cite{Petrov:pldi12,Raychev:oopsla13,Santhiar:issta16,Maiya:issta17}.
%, and to efficiently handle long executions.
Detecting data races is a different problem than exploring all possible executions of a program, in that it considers only one (possibly long) execution, but tries to detect whether it (or some other similar execution) exhibits data races.

%% COMMENTS:
%% Bonetta et al LNCS 7484 present a run-time for event-driven programming
