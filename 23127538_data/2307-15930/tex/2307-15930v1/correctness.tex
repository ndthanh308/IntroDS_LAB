\section{Correctness and Optimality}
\label{sec:correctness}
A program is defined to be \emph{non-branching} if each
message, which executes on the same handler as  some other message, performs the same sequence of accesses (reads or writes) to shared
variables during its execution, regardless of how its execution is interleaved with other threads and messages.
%% Intuitively, messages in a
%% non-branching program must not use the values it reads from shared variables to determine which shared variables to access thereafter.
%% On the other hand, a non-branching program can use values of read variables to choose between different messages that it posts.
Note that the ``non-branching'' restriction does not apply to non-handler threads nor to messages that are the only ones executing on their handler.

The following theorems state that \EventDPOR is 
\emph{correct} (explores at least one execution in each equivalence class)
for \emph{all} event-driven programs
and \emph{optimal} (explores exactly one execution in each equivalence class)
for non-branching programs.
%% In this section, we state correctness and optimality of \EventDPOR.
Proofs can be found in \cref{sec:correctness-proof}.
%% of the supplementary material.



\hasbeenremoved{
Let us now
% present the main properties of the \EventDPOR algorithm. Throughout, we
assume a particular completed execution of \EventDPOR. This execution 
consists of a number of terminated calls to $\explore(E)$ for some values 
of the parameters $E$ and $\WuT$. Let $\exseqs$ denote the set of execution 
sequences $E$ that have been explored in some call $\explore(E)$. Define 
the ordering $\treeorder$ on $\exseqs$ by letting $E \treeorder E'$ if 
$\explore(E)$ returned before $\explore(E')$. Intuitively, if one 
were to draw an ordered tree that shows how the exploration has proceeded, then 
$\exseqs$ would be the set of nodes in the tree, and $\treeorder$ would be the 
post-order between nodes in that tree. The correctness and optimality of 
\cref{alg:eventdpor-access} are stated in the following theorems.
}

\begin{theorem}[Correctness]
\label{thm:correctness}
Whenever the call to $\explore(\emptyseq)$ returns during \cref{alg:eventdpor-access},
then for all maximal execution sequences $E$, the algorithm has explored
some execution sequence in~$\eqclass{E}$.
\end{theorem}

\hasbeenremoved{
Since the initial call to the algorithm, $\explore(\emptyseq)$, starts with
the empty sequence as argument, \cref{thm:correctness}
implies that for all maximal execution sequences $E$ the algorithm
explores some execution sequence $E'$ which is in $\eqclass{E}$.
  Note also that a sequence of form $E.w$ need not have been explored inside
the call $\explore(E)$, but can have been explored in some earlier call,
of form $\explore(E'.p)$ for some prefix $E'$ of $E$.
}

\begin{theorem}[Optimality]
\label{thm:optimality}
When applied to a non-branching program,
\cref{alg:eventdpor-access} never explores two maximal execution
sequences which are equivalent.
\end{theorem}

\hasbeenremoved{
  \Cref{thm:optimality} ensures
that all maximal execution sequences reached are non-redundant.
}
