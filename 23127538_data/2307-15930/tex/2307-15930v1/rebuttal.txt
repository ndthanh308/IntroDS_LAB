We thank all three reviewers (RA,RB,BC) for their time and comments.
We quote brief excerpts from the reviews and respond to them,

**Regarding "Weak Evaluation" (RC)** 

> The benchmarks are too simple and not complex enough to demonstrate the value of proposed approach.

For the evaluation, we have chosen to do a **comparison** of the performance of our algorithm with state-of-the-art
DPOR algorithms. Unfortunately, most prior works on event-driven programs either do not have implementations
[29,30] or have an implementation [20] which is unmaintained and unusable. As a result, our only option was to
compare against DPOR algorithms implemented in GenMC and against the Optimal DPOR algorithm implemented in
Nidhugg. This in turn meant that we could only use programs that these two tools (which do not support
event-driven programs natively) can also handle. (Otherwise we would be presenting a table which would show the
scalability of our algorithm on "more real" programs, but would have empty entries/crashes for the other
tools/algorithms.)

> It is a bit disappointing that the paper uses synthetic benchmarks...

Most of the benchmark programs we ended up using come from previous works on asynchronous/event-driven programs
[11,21,27], as mentioned in the paper. Some of them (buyers, consensus and 2PC) are distributed protocols; they
are small alright but not synthetic. The db-cache benchmark (in the appendix) is inspired by Memcached, a cache
for distributed databases developed on top of the Libevent library. From the benchmarks we use, only the
prolific benchmark is synthetic (this is mentioned in the paper), but we use it to demonstrate the complexity
differences of the various algorithms.

> The appendix Table 2 and Table 3 present benchmarks where Event-DPOR performs worse than optimal. Why were these
> benchmarks left out? Especially, 2PC? It would great to discuss these in the main body of the paper...

Due to space limitations, we could only use only a subset of all benchmarks for the paper's main body (Table 1).
Still, all our results are (and will be) available the paper's appendix (Tables 2 to 4), Having pointed out
this, a closer look at Tables 1 and 3 reveals that *both* programs of Table 3 (buyers and ping-pong) are in fact
presented in Table 1 and discussed in the main body. Regarding Table 2, only one of its three benchmarks
(posters) appears in Table 1. However, notice that all three programs of that table (writers, posters, 2PC) are
programs where all four algorithms explore the *exact same number* of executions. As a result, all three
programs effectively show a similar picture: GenMC -mo is ~3-7 times faster than optimal, and optimal is 70% to
2x faster than Event-DPOR. If the reviewer prefers, we can substitute posters with 2PC in Table 1, but note that
2PC actually shows a slightly better picture for Event-DPOR than the one we show on Table 1: Event-DPOR is slower
by a smaller factor (6.2 vs 9) than the fastest tool (GenMC -mo) and Event-DPOR beats LAPOR in 2PC (but not in
posters).

**Comparison with Related Work**

> How does the exploration of Event-DPOR compare to [28] for non-branching programs, other than the restriction to FIFO semantics?

In our paper, we describe [28] at lines 3-14 of the second paragraph in Section 2.
There we describe two reasons why [28] may perform an arbitrary amount of redundant exploration on many programs:
1. It adapts [12], which is based on persistent sets, to handle event-driven programs.
   As shown in [3], persistent-set-based DPOR may explore exponentially more interleavings than optimal algorithms.
2. It does not use sleep sets, which is the main technique to avoid redundant exploration in DPOR.
   (Figures 6 and 8 in [12] show an order of magnitude improvement by sleep sets on benchmarks).
   Let us remark that it is far from trivial to adapt sleep sets to the event-driven setting;
   in Event-DPOR we achieve this by the weak initials test (line 10 of Algorithm 1).

EM-Explorer, the implementation in [28], does not explore all inequivalent schedulings of an event-driven program, but
instead constructs the reorderings of **a single** trace. So, besides the differences in the semantics, it is also impossible
to do a meaningful comparison between EM-Explorer and our implementation.

> Missing comparison with Tasharofi et al. TransDPOR:....in FORTE 2012

TransDPOR [43] considers a model for actor systems, in which actors receive messages from other actors, but do
not share state. A main point of [43] is that it improves over the 2012 state-of-the-art [12] by exploiting the
fact that events (including message receptions) of different actors are never in conflict: this can be exploited
to limit the growths of backtrack sets (which correspond to wakeup trees in our approach), leading to fewer
explored interleavings.

Our approach subsumes [43] in several ways:
- The actor model is a special case of the event-driven model, letting actors correspond to handlers.
- Since there is no shared state, our DPOR algorithm will out-of-the-box consider events executed on different actors as non-conflicting. In addition, [43] considers events in different messages on the same actor as always conflicting, whereas our work does so only if the messages are conflicting, thereby potentially achieving better reduction.
- In particular, any program in the actor model satisfies the condition for being "non-branching" (even when codes of messages contain branches on test), implying that Event-DPOR is optimal.
- The mechanism of [43] for limiting growth of backtrack sets by exploiting transitivity is subsumed by our technique for checking redundancy before inserting wakeup sequences.

We were aware of the work [43]. In the section "Related work", we omitted it for lack of space, but included [6], which for actor systems is also an improvement over [43], but whose execution model is incomparable to ours.

**Constrained Programming Model (RC)**

> The authors mention that the approach work well for shared-memory event-driven programs with a shared thread-pool.
> This is a constrained model...

We disagree that the programming model of the paper is constrained. As we mention in the introduction, we consider a
model with an _arbitrary_ number of handler threads (whereas most other works consider the restricted case where there
is only one event handler), where events can be picked from event pools in _arbitrary_ orders (whereas many works
consider only FIFO semantics), and where there are both shared variables, message passing (event posts), and non-atomic
events. This is NOT a constrained model. In fact, we would argue that most other event-driven models proposed in the
literature are more constrained than the model we assume (and our algorithm handles).

>...It is definitely too restrictive for distributed message passing event-driven programs.

We do not quite understand which model of distributed programs is intended in this comment, nor which way our
model is "too restrictive". May we ask the reviewer to clarify? There is a variety of semantics for distributed
message passing programs, and the ones we are aware of we can handle in a similar way as we can handle actor
systems (see our response regarding work [43]). Different semantics differ in their policy for handling message
queues (FIFO, selective reception, etc.), but the policy that we consider is the least restrictive one.

**Benchmarks (RB)**

> Which of the studied benchmarks belong to that subclass of non-branching event handlers?

Four benchmarks (buyers, ping-pong and consensus in Table 1, and db-cache in the appendix) are **not** non-branching.
(For consensus, this is mentioned in the appendix, page 39.) The other benchmarks are non-branching.
As we remark in Section 1, in all the programs we tried, also those that are not non-branching,
Event-DPOR explores the optimal number of traces.
