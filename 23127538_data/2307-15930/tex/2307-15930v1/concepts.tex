\newcommand{\tikzwrapfigbg}{%
  \begin{pgfonlayer}{background}
    \path[fill=gray!10,rounded corners]
    (current bounding box.south west) rectangle
    (current bounding box.north east);
\end{pgfonlayer}}

\section{Main Concepts and Challenges}
\label{sec:concepts}
In this section, we informally present core concepts of our approach by examples\footnote{Note
  that in the remainder of the paper, we will use the term \emph{message} to refer to what was called \emph{event} in Sections~\ref{sec:intro} and~\ref{sec:related},
  for the reason that the literature on DPOR has reserved the term \emph{event} to denote an execution of a program statement. We will also use \emph{mailbox} instead of event pool.}
%% Recall that henceforth we will use the term \emph{message} to refer to what was called \emph{event} in \cref{sec:intro}.

\hasbeenremoved{By a DPOR algorithm, we refer to an algorithm that analyses a terminating program on given input,
by exploring different executions resulting from different thread interleavings. 
It equips each execution with a transitive happens-before ordering, induced by ordering accesses performed within a message or non-handler thread, as well as conflicting accesses to a shared variable
(two accesses are \emph{conflicting} if they involve the same shared variable and one of them is a write).
The happens-before relation induces an equivalence relation on executions.
A DPOR algorithm should explore at least one execution in each equivalence class.
\hasbeenremoved{
A DPOR algorithm is \emph{correct} if it  explores at least one execution in each equivalence class.
It is \emph{optimal} if, additionally, it explores exactly one execution in each equivalence class.}
}
%% The first DPOR algorithms, starting
%% with~\cite{FG:dpor} used backtrack sets to decorate prefixes of the currently explored execution sequence with alternative continuations.
%% In~\cite{FG:dpor}, these sets consisted of single threads that initiate alternative explorations. Correctness was established by proving that
%% these backtrack sets were persistent sets, which in~\cite{abdulla2014optimal} was improved into source sets. However, as demonstrated in~\cite{abdulla2014optimal},
%% having only single threads in backtrack sets is not sufficient for avoiding to explore the same equivalence class twice, or encountering sleep set blocking during execution.


\newcommand{\evnt}[2]{\mbox{$#1$: \texttt{#2}}}
\newcommand{\hndlr}[3]{\mbox{$#1$: $#2$: \texttt{#3}}}

% Figure environment removed

\subsection{Review of \OptimalDPOR}
Our DPOR algorithm for event-driven programs is an extension of \OptimalDPOR~\cite{abdulla2014optimal}.
%, which is designed for programs consisting of interacting sequential threads.
%% The overall idea of DPOR algorithms is to detect races in explored executions, and reverse them to obtain new executions that will be explored.
%% Given a program, \OptimalDPOR first explores a maximal execution $\exseq$, and then inspects $\exseq$ to find races. From each race, an alternative execution is constructed which branches off from $\exseq$ at the point where the race occurred, and whose continuations produce executions that are inequivalent to $\exseq$. The branch is called a \emph{wakeup sequence}.
Let us illustrate \OptimalDPOR on the program snippet shown in~\cref{fig:rw}.
In this code, three threads $s$, $t$, and~$u$ access
three shared variables \texttt{x}, \texttt{y}, and \texttt{z},\footnote{Throughout
  this paper, we assume that threads are spawned by a \texttt{main} thread,
  and that all shared variables get initialized to $0$, also by the main thread.}
whereas \texttt{a}, \texttt{b}, \texttt{c}, and \texttt{d} are thread-local registers.
%% Two accesses are said to be \emph{conflicting}
%% if they involve the same shared variable and one of them is a write; if they are also adjacent in the
%% dependency ordering, they are in a \emph{race}.
%% Since there are no writes to \texttt{y} and \texttt{z} here,
%% accesses to \texttt{y} and \texttt{z} are not dependent with anything else.
%% This allows DPOR algorithms to explore considerably less executions than the~$30$
%% that a na{\"\i}ve exploration would examine.
%% Similarly to many other DPOR algorithms,
\OptimalDPOR first explores a maximal execution, which it inspects to detect races.
From each race, it constructs an initial fragment of
an alternative execution which reverses the race and branches off from the explored execution just before the race.
%% In \OptimalDPOR, such a fragment is called a \emph{wakeup sequence}.
Let us illustrate with the program in~\cref{fig:rw}.
Assume that the first execution is $\exseq_1$ (cf. the tree in~\cref{fig:rw}).
The DPOR algorithm first computes its happens-before order, denoted $\happbf{\hb}{E_1}$,
which is the transitive closure of the union of:
\begin{inparaenum}[(i)]
\item
  the \emph{program order}, which totally orders the events in each thread (small blue arrows to the left of $E_1$), and
\item
  the \emph{conflict order} which orders conflicting events: two events are conflicting if they access a common shared variable and at least one is a write
  (red arcs left of $E_1$).
\end{inparaenum}
%% Let us define a \emph{happens-before prefix} of $E_1$ as a subsequence of $E_1$ such that if an event $e$ is in $E_1$, then all
%% $\happbf{\hb}{E_1}$-predecessors of $e$ are in $E_1$.
A \emph{race} consists of two conflicting events in different threads that are adjacent in the $\happbf{\hb}{E_1}$-order.
The execution $\exseq_1$ contains two races (red arcs in~\cref{fig:rw}).
Let us consider the first race, in which the first event is \evnt{s}{x=1} and the second event is \evnt{t}{b=x}.
The alternative execution is generated by concatenating 
the sequence of events in $E_1$ that do not succeed the first event in the $\happbf{\hb}{E_1}$ order (i.e., $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}$) with
the second event of the race \evnt{t}{b=x}.
%% Here, sequence not happening-after $e$ is  and the second event is 
%% $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}; \evnt{t}{b=x}$ ($t.u.t$ for short), which
This forms a \emph{wakeup sequence}, which branches off from $E_1$ just before
the race, i.e., at the beginning of the exploration (green in~\cref{fig:rw}).
%% the independent events are $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}$ together with their predecessors; by appending the second event, we form the wakeup sequence
%% $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}; \evnt{t}{b=x}$ ($t.u.t$ for short), which branches off from $E_1$ just before the race, i.e.,
%% at the beginning of the exploration (green in~\cref{fig:rw} right).
%% The second race, between \evnt{s}{x=1} and~\evnt{u}{d=x} induces the wakeup sequence $t.u.u$ formed from the
%% independent events $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}$ and the second event \evnt{u}{d\,=\,x}, also branching off at the beginning
%% (note that it does not contain the second step of~$t$ since it succeeds \evnt{s}{x=1} in the $\happbf{\hb}{E_1}$-ordering).
%%
%% The $\happbf{\hb}{E_1}$-order of $E_1$ is 
%% i.e., the order of events in a thread, and
%%   events within a thread or between conflicting accesses to a shared variable). 
%%
%%  it contains two races (marked red in~\cref{fig:rw} right).
%% It is constructed using the following principles.
%% %% that make \OptimalDPOR correct and optimal:
%% \begin{inparaenum}
%% \item[P1:]
%% It should reverse the race, i.e., contain the second event of the race (as its last), but not the first.
%% \item[P2:]
%% It should also includes all events of $E_1$ that are independent of the race, in the sense that they do not succeed the racing events
%% in the $\happbf{\hb}{E_1}$-order, together with all their predecessors in said $\happbf{\hb}{E_1}$-order
%% \end{inparaenum}
%% These principles are designed to make \OptimalDPOR correct and optimal.
%%
%% If the first execution is $\exseq_1$ (cf.~\cref{fig:rw} right), it contains two races (marked red in~\cref{fig:rw} right).
%% %% Assume that the first explored sequence
%% % (We will denote executions by the dotted sequence of scheduled thread steps.)
%% %% It then inspects $\exseq_1$ to detect races; detecting
%% For the race between \evnt{s}{x=1} and~\evnt{t}{b=x},
%% the independent events are $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}$ together with their predecessors; by appending the second event, we form the wakeup sequence
%% $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}; \evnt{t}{b=x}$ ($t.u.t$ for short), which branches off from $E_1$ just before the race, i.e.,
%% at the beginning of the exploration (green in~\cref{fig:rw} right).
The second race, between \evnt{s}{x=1} and~\evnt{u}{d=x} induces the wakeup sequence $t.u.u$ formed from the
sequence $\evnt{t}{a\,=\,y}; \evnt{u}{c\,=\,z}$ and the second event \evnt{u}{d\,=\,x}, also branching off at the beginning
(note that $t.u.u$ does not contain the second event \evnt{t}{b=x} of~$t$ since it succeeds \evnt{s}{x=1} in the $\happbf{\hb}{E_1}$-ordering).
%% \mbox{$s$: \texttt{x=1}} and~\mbox{$u$: \texttt{d=x}}, inducing the
When attempting to insert $t.u.u$, the algorithm will discover that this sequence is \emph{redundant}, since its events are
consistently contained in a continuation ($t.u.t.u$) of 
the already inserted wakeup sequence $t.u.t$, and it will therefore not insert $t.u.u$.
After this, the algorithm will reclaim the space for~$E_1$, extend $t.u.t$ into a maximal execution~$E_2$, 
in which races are detected that generate
two new wakeup sequences (which start in green and continue in blue), which are extended to two additional executions (cf.~\cref{fig:rw}).
%% In this way, \OptimalDPOR explores one trace in each equivalence class of this program.

\hasbeenremoved{In short, the \OptimalDPOR algorithm conceptually organizes all its explored execution sequences
in a tree $\exseqs$ that it explores in a depth-first manner (and gradually reclaims).
The nodes of $\exseqs$ correspond to execution sequences; leaves correspond to maximal explored executions and to complete wakeup sequences.}

%%\old{
%% The tree $\exseqs$ has two properties to guarantee optimality:
%% \begin{enumerate}[(1)]
%% \item
%%   Whenever the exploration of some subtree rooted at $\exseq \in \exseqs$ has finished,
%%   then for all maximal executions of form $\exseq.w$, the algorithm has explored a maximal execution $\mtclass{\exseq.w}$.
%% \item
%%   Let $\treeorder$ be the post-order on the nodes of $\exseqs$, induced by the
%%   depth-first exploration of the DPOR algorithm. For each internal node
%%   $\exseq$ in $\exseqs$, for each thread $s$ and sequence $w$ such that
%%   $\exseq.p$ is a node and $\exseq.w$ is a leaf with $\exseq.p \treeorder \exseq.w$,
%%   there is no continuation of $\exseq.p$ which is equivalent to $\exseq.w$.
%% \end{enumerate}
%% Property (1) implies correctness by letting $\exseq$ be the empty sequence.
%% Note that the exploration of some particular execution in $\mtclass{\exseq.w}$ need not be
%% performed during exploration of the subtree rooted at $\exseq$; it can be done during
%% the exploration of some preceding subtree, which also contains executions in
%% $\mtclass{\exseq.w}$.
%% Property (2) guarantees that no equivalence class will be explored twice.
%% For each execution $\exseq$, let us introduce the relation $\inwfirstseqs{E}$
%% on continuations of $E$, defined by letting
%% $v \inwfirstseqs{E} w$ denote that there are sequences $v'$ and
%% $w'$ such that $v.v' \equivafter{E} w.w'$. If $E.w$ is maximal, then it means
%% that there is a sequences $v'$ with $v.v' \equivafter{E} w$.

%% In order to to ensure that the resulting exploration tree will satisfy (2),
%% the new branches created by race analysis are organized in \emph{wakeup trees}.
%% Each prefix $E$ of the currently explored execution has a wakeup tree, denoted
%% $\wut{E}$, which contains extensions of $E$ that are or will be in $\exseqs$,
%% each of which is the root of a subtree in $\exseqs$.
%%
%% If the first thread explored after $E$ is $s$, then each sequence $w$ in
%% $\wut{E}$ must satisfy $s \notinwfirstseqs{E} w$, which guarantees that
%% any continuation of $E.w$ is inequivalent with any
%% continuation of $E.p$. The wakeup three
%% $\wut{E}$ is internally organized as a tree in which
%% this principle is maintained recursively,
%% i.e., whenever $u.p$ and $u.w$ are nodes in $\wut{E}$ with
%% $u.p \treeorder u.w$, and $u.w$ is a leaf,
%% then $s \notinwfirstseqs{E.u}{w}$. Again, 
%% this guarantees that the continuations of any two leaves of $\wut{E}$
%% are inequivalent.
%%}

%% % Figure environment removed

%% To see the ingredients that \EventDPOR requires,
%% consider first the program in \cref{fig:example1}.
%% It is a variation of the previous program, but now messages consist of
%% a single write access to the \emph{same} shared variable \texttt{x}.
%% Assume that the first explored execution is $E_1$; cf.~\cref{fig:example1}.
%% % The trace graph of $E_1$ is shown to the right of the same figure.
%% %% There the $\eom$ relation between the two messages induces the $\ppm$ relation between the two post events.
%% \EventDPOR detects that the two accesses to \texttt{x} are in a race.
%% It then constructs a wakeup sequence which leads to the second access (\texttt{a\,=\,x}) without executing the first. 
%% \EventDPOR infers that such a wakeup sequence can be constructed only by executing $p_2$ instead of $p_1$,
%% obtaining the wakeup sequence shown in blue,
%% which is inserted after the two post events in the exploration tree.
%% %% \EventDPOR needs to detect that messages $p_1$ and $p_2$ contain events that are in a race.
%% %% However, because of the FIFO discipline of message queues,
%% %% we cannot reverse the race simply by creating a new branch after $s.q$
%% %% where the order of messages $p_1$ and $p_2$ is reversed.
%% %% Instead, we have to go back to their posting events, which also have to be reversed.
%% %% Thus, the definition of races between messages (\cref{sec:prels})
%% %% needs to be designed in a way that such reordering is always possible.
%% This wakeup sequence will then be extended to the execution $E_2$.
%% Like in \OptimalDPOR, $E_1$'s memory can be reclaimed at this point.
%% %% and the algorithm will explore execution $E_2$ that starts by this wakeup sequence.
%% (Since this example is very simple, nothing more is added here.)

%% \endgroup % NEEDS TO HAVE AN EMPTY LINE BEFORE IT!

%% % Figure environment removed
%% \paragraph{Handling Conflicting Messages}

%% Let $E$ be the empty sequence $\emptyseq$, and 
%% In our setting, we have
%% \begin{itemize}
%% \item
%%   $q \infirstseqs{\emptyseq}{p.q}$, since $q.p \simeq p.q$,  and
%% \item
%%   $s.q \infirstseqs{\emptyseq}{p.q.m}$ since the former is a prefix of the latter, but
%% \item $q \notinfirstseqs{\emptyseq}{p.q.m}$, since any sequence that starts with $q$ must let $n$ be processed before $m$.
%% \end{itemize}

%% \begin{itemize}
%% \item
%%   whenever $E.p$ and $E.w$ are nodes in $\exseqs$, where $s$ is a single thread,
%%   $E.p \prec E.w$, and $u.w$ is a maximal execution sequence
%%   then $s \notinwfirstseqs{E} w$.
%% \end{itemize}
%% \footnote{\citet{abdulla2014optimal} used the notation
%% $s \in \winits{E}{w}$ to denote $s \inwfirstseqs{E} w$.
%% In contrast, we will employ $s \inwfirstseqs{E} w$, in order to emphasize that
%% our algorithm never actually computes the set $\winits{E}{w}$.}

%% \begingroup
%% \setlength{\intextsep}{0em}%
%% \setlength{\columnsep}{.75em}%
%% Note that the algorithm should also handle programs that include multiple levels of posting events.
%% \begin{wrapfigure}{h}{0.42\textwidth}
%%   \centering \footnotesize
%%   \begin{tikzpicture}[line width=1pt,framed,inner sep=1pt]
%%     \node[name=p,anchor=south west] at (-0.15,0.25) {{$s$}};
%%     \node[name=post1] at (0,0) {$\mathtt{post}(p_1,h)$};
    
%%     \draw[line width=0.5pt] ($(post1.north east)+(1pt,10pt)$)--($(post1.south east)+(1pt,-34pt)$);
%%     \draw[line width=0.5pt] ($(post1.north east)+(3pt,10pt)$)--($(post1.south east)+(3pt,-34pt)$);
    
%%     \node[name=q,anchor=south west] at (1.45,0.25) {{$q$}};
%%     \node[name=post2,anchor=west] at ($(post1.east)+(5pt,0.5pt)$) {$\mathtt{post}(p_2,h)$};

%%     \draw[line width=0.5pt] ($(post2.north east)+(1pt,10pt)$) -- ($(post2.south east)+(1pt,-34pt)$);
%%     \draw[line width=0.5pt] ($(post2.north east)+(3pt,10pt)$) -- ($(post2.south east)+(3pt,-34pt)$);
    
%%     \node[name=r,anchor=south west] at (3,0.2) {{$r$}'s messages};
%%     \node[name=m1,anchor=west] at ($(post2.east)+(5pt,0.5pt)$) {$p_1$: $\left[\mathtt{post}(p_3,h)\right]$};
%%     \node[name=m2,anchor=north west] at ($(m1.south west)+(0pt,-1pt)$) {$p_2$: $\left[\mathtt{post}(p_4,h)\right]$};
%%     \node[name=m3,anchor=north west] at ($(m2.south west)+(0pt,-1pt)$) {$p_3$: $\left[\texttt{x\,=\,1}\right]$};
%%     \node[name=m4,anchor=north west] at ($(m3.south west)+(0pt,-1pt)$) {$p_4$: $\left[\texttt{a\,=\,x}\right]$};
%%   \end{tikzpicture}
%% \end{wrapfigure}
%% To see this, consider the program on the left.
%% % in \cref{fig:postpost} below.
%% Assume that the first explored execution is $s.q.m_1.p_2.p_3.p_4$.
%% Again, there is a race, this time between messages $p_3$ and $p_4$ that write to \texttt{x}.
%% %% This induces $\ppm$ relations between $p_1$ and $p_2$ and between $s$ and $q$.
%% When reversing the race between $p_3$ and $p_4$,
%% \emph{both} the order between $p_1$ and $p_2$ and between $s$ and $q$ must be reversed,
%% resulting in the wakeup sequence $q.p.p_2.p_1.p_4.p_3$,
%% which is the second ---and last--- execution that will be explored.
%% % for this program.

%% \endgroup % NEEDS TO HAVE AN EMPTY LINE BEFORE IT!

%% % Figure environment removed
\hasbeenremoved{
  \paragraph{Non-atomic Messages}
A major complications in extending \OptimalDPOR to the event-driven execution model stems from non-atomic messages.
In general, a message consists of a sequence of statements.
We cannot reverse races between individual statements in two different messages that execute on the same handler in the same way as in standard DPOR,
since we cannot swap just individual statements without swapping the order of two messages entirely.
Such swapping can produce many other changes to the execution, stemming from swapping all events in the two messages.
\EventDPOR preserves \OptimalDPOR's principle to construct wakeup sequences which contain events that do not happen-after any event of the race,
followed by the second event of the race. However, it is often not possible to include all such events in an event-driven execution, in which
case \EventDPOR will include a maximal subsequence.
}
%% The execution of non-conflicting messages should not be ordered by the happens-before relation.
%% The problem is conceptually analogous to regarding messages as mini-threads,
%% which compete for a shared resource (the handler thread).
%% Most existing DPOR algorithms consider accesses to such shared resources
%% (typically protected by a lock) as always conflicting,
%% and will hence explore all serializations of such accesses.
%% The challenge for \EventDPOR is to avoid serialization-by-default,
%% in the case where messages can contain arbitrary (terminating) code.
%% 
%% \paragraph{Reversing Races Between Events on the Same Handler}
We illustrate this mechanism on the program at the bottom left of \cref{fig:example1new}.
%%, which extends the program above it by letting each message contain three accesses, two of which are pairwise conflicting.
Assume that the first explored execution is $E_1$. It contains two races between events in the two messages, one on \texttt{x} and one on \texttt{y}.
According to \OptimalDPOR's principle for race reversal, the race on \texttt{x} should induce an alternative execution composed of 
the sequence of events that do not happen-after the first event (i.e., {\hndlr{h}{p_1}{u\,=\,1}} {\hndlr{h}{p_2}{v\,=\,2}}) and the 
second event {\hndlr{h}{p_2}{a\,=\,x}}
(for brevity, we do not show the two post events).
However, since message execution is serialized, these events cannot form an execution.
Therefore, \EventDPOR forms the alternative execution (shown in blue) by appending the second event {\hndlr{h}{p_2}{a\,=\,x}} to a 
maximal subset of the events of $E_1$ which is closed under $\happbf{\hb}{E_1}$-predecessors
(i.e., if it contains an event $e$ then it also contains all its $\happbf{\hb}{E_1}$-predecessors), and which can form an execution that does not
contain the first event. 
Later, this wakeup sequence is extended to execution $E_2$.
%% In the general case, the alternative execution should be of form $E'.e'$,
%% where $E'$ is a maximal happens-before prefix of $E_1$  for which $E'.e'$ is an execution which does not contain the first event of the race. Here, a \emph{happens-before prefix} of $E_1$ as a subsequence of $E_1$ such that if an event $e$ is in $E_1$, then all $\happbf{\hb}{E_1}$-predecessors of $e$ are in $E_1$.
%% \begin{inparaenum}
%% \item[P1:] includes the event {\hndlr{h}{p_2}{a\,=\,x}}, but not {\hndlr{h}{p_1}{x\,=\,1}} implying that $p_2$ will be executed before $p_1$, and
%% \item[P2:] include the accesses that are independent of the race, i.e., {\hndlr{h}{p_1}{u\,=\,1}} and {\hndlr{h}{p_2}{v\,=\,2}}.
%% \end{inparaenum}
%% However, since message execution is serialized, ${\hndlr{h}{p_1}{u\,=\,1}}$ can be executed only by including all events of $p_2$, which is not possible since
%% then also the event {\hndlr{h}{p_2}{b\,=\,y}}, which is not independent of the race, would be included. We must therefore revise P2 into P2' which requires to include
%% a maximal subset of the independent events which (together with their predecessors) can form an execution when followed by  {\hndlr{h}{p_2}{a\,=\,x}} (the second event of the race).
%% Thus the wakeup sequence is {\hndlr{h}{p_2}{v\,=\,2}} {\hndlr{h}{p_2}{a\,=\,x}}, shown in blue to the right.
Let us then consider the race on \texttt{y}.
The constructed wakeup sequence should append the second event {\hndlr{h}{p_2}{b\,=\,y}} to a maximal subset of events
that do not happen-after the first event {\hndlr{h}{p_1}{y\,=\,1}}.
However, there is no execution that satisfies these constraints, since it would have to include
{\hndlr{h}{p_2}{a\,=\,x}} before its $\happbf{\hb}{E_1}$-predecessor {\hndlr{h}{p_1}{x\,=\,1}}.
The conclusion is that the race on \texttt{y} cannot (and should not) be considered for reversal, whereas that on \texttt{x} should be reversed.
More generally, if two messages executing on the same handler thread are in conflict, then a wakeup sequence is constructed consisting of only the second message up until and including its first conflicting event.
%% One way to understand this apparent asymmetry is that when the race is reversed
%% by posting the messages in the opposite order,
%% the part of $p_2$ before the racing event is not affected,
%% since it does not conflict with $p_1$.
%% On the other hand, $p_2$ can in general contain many statements after the racing event,
%% which may modify the shared variables in ways which can affect all of $p_1$
%% (i.e., the effect of $p_1$ can change completely when it is swapped with $p_2$).

When messages can branch on values read from shared variables,
reversing the order of two messages may change the control flow of each involved message.
Also in this case, \EventDPOR's principles for reversing races work fine.
We illustrate this on the program in \cref{fig:non-atomic-1},
consisting of two threads $s$ and $t$ and a handler thread $h$.
Thread $s$ posts a message $p_1$ to $h$ and thereafter writes to \texttt{x}.
Thread $t$ posts message $p_2$ to $h$
% , \revise{which is non-atomic}: it
that reads from \texttt{x} and \emph{may} then read from~\texttt{y}.
 
% Figure environment removed

Assume that the first execution is $E_1$, where $s$'s access to \texttt{x} goes last.
%% cf.~\cref{fig:non-atomic-1}.
% The corresponding trace graph is shown to the right.
The execution has two races:
one on \texttt{y} between {\evnt{p_1}{y\,=\,2}} and {\evnt{p_2}{b\,=\,y}}, and
one on \texttt{x} between {\evnt{p_2}{a\,=\,x}} and \evnt{s}{x\,=\,1}.
The race on \texttt{x} can be handled in the same way as in \OptimalDPOR:
%% The sequence of events that do not happen-after this race is $s.t.p_1$.
the wakeup sequence is $\evnt{s}{x\,=\,1}$, which branches off after the prefix $s.t.p_1$ (green in~\cref{fig:non-atomic-1}), and 
will subsequently be extended to execution~$E_2$.
% The corresponding trace graph is at the bottom left in \cref{fig:non-atomic-1}.
The race on \texttt{y} is a race between events in two messages on the same handler thread. As in the previous example, the wakeup sequence will
include the second message up until and including the first racing event, which is {\evnt{p_2}{b\,=\,y}}.
Included in the events that do not happen-after the first event is also $\evnt{s}{x\,=\,1}$, which must be placed after its predecessor {\evnt{p_2}{a\,=\,x}}, yielding the wakeup sequence
  {\evnt{p_2}{a\,=\,x}}; \evnt{s}{x\,=\,1}; {\evnt{p_2}{b\,=\,y}}, which
branches off after
  \evnt{s}{post($p_1$,$h$)}, 
  \evnt{t}{post($p_2$,$h$)}.
  This is the blue rightmost branch of the tree in~\cref{fig:non-atomic-1},
  and is later extended into the execution $E_3$.
Execution $E_3$ has a race on \texttt{x}. Its reversal produces the wakeup sequence \evnt{s}{x\,=\,1}, which is a tentative branch next
to  {\evnt{p_2}{a\,=\,x}}. However, this wakeup sequence is not in conflict with the left branch labeled  {\evnt{p_1}{b\,=\,y}}, which means that it will not
be inserted for the reason that it is equivalent to a subsequence of an execution starting with  {\evnt{p_1}{b\,=\,y}}, namely $E_2$.

%% % Figure environment removed
%% To further illustrate how races between events in messages on the same handler are treated as races between a message and an event,
%% consider the same program (in \cref{fig:non-atomic-1})
%% but assume that the two post events occur in the opposite direction
%% and the first explored sequence is $E'_1$ in \cref{fig:non-atomic-2}.
%% %% (The corresponding trace graph is on the right.)
%% Let us consider how to reverse the race on \texttt{y}.
%% This is now a race between $m_2$ and \evnt{m_1}{y\,=\,1}.
%% %
%% Note that in general it is meaningless to try to exploit that the
%% events \evnt{m_2}{a\,=\,x} and \evnt{p}{x\,=\,1},
%% which lie between the conflicting events and the postings of the two messages,
%% are not involved in the race,
%% since after $m_2$ and $m_1$ are swapped,
%% the message $m_1$ might contain some event that changes the value of~\texttt{x},
%% thereby affecting all of $m_2$ in ways that are hard to predict.
%% The sequence not happening-after the race consists of the two \texttt{post} events.
%% The wakeup sequence is constructed by first adding (the event in) $m_1$,
%% thereafter executing the rest of $m_1$ (there are no other events in this case),
%% and finally $m_2$ until the conflict arises; cf. the blue sequence in \cref{fig:non-atomic-2}.
%% Extending this wakeup sequence will lead to execution $E_1$ in \cref{fig:non-atomic-1}.

%% In the last case above, we let the wakeup sequence include events up till the point
%% when a happens-before edge which actually reverses the race appears.
%% This can sometimes be necessary in order to steer
%% the continuation of the wakeup sequence into a non-redundant path.
%% This phenomenon can be illustrated, again on the program in \cref{fig:non-atomic-1}
%% by letting the first explored sequence be
%%     \( q.p[1].m[1].p[2].m[2].n \).
%% The corresponding trace graph is shown in \cref{fig:non-atomic-2}.
%% Let us consider how to reverse the race on \texttt{y}.
%% The sequence not happening-after the race is \( q.p[1] \). The rule says that we should consider
%% all of $m$ as involved in the race, and therefore also $s[2]$. It may be tempting to add a rule
%% to remember that the events $m[1].p[2]$ were not involved in the race, in order to start the
%% subsequent execution of $m$ with these events. Hoever, in the general case, the message
%% $n$ can be very long with many statements after the write to $y$. When swapping the order
%% of $m$ and $n$, all these statements will be executed before $m$ is executed: Thus,
%% the variable $x$ may have been completely updated so that it is not meaningful to have
%% remembered how $m$ was executed in the first execution.
%% On ther other hand, we should probably mandate that
%% after the execution of $n$ we execute $m$ until a conflict with $m$ appears.

\hasbeenremoved{
  % Figure environment removed
%%\bjcom{Do we really need this example?}
Now
%% In order to illustrate further the effect of considering races between events in messages
%% as races between a message and an event,
consider the program in~\cref{fig:example2}.
Assume that the first explored execution is~$E_1$.
%% (Its trace graph is shown at the right.)
There is in fact only one race here: between  {\hndlr{h}{p_1}{a\,=\,y}} and \evnt{t}{y\,=\,1},
shown with a red arc with arrows in the figure.
This race will be reversed in the standard way.
The wakeup sequence, shown in blue, will be inserted after \evnt{s}{post($p_1,h$)} and will be extended to $E_2$.
On the other hand, note that the conflict between  {\hndlr{h}{p_1}{x\,=\,1}} and {\hndlr{h}{p_2}{x\,=\,2}} in $E_1$ is not a race,
since it should be regarded as a conflict between the message $p_1$ and the event  {\hndlr{h}{p_2}{x\,=\,2}}.
Viewed in this way, there is another dependency from $p_1$ to  {\hndlr{h}{p_2}{x\,=\,2}},
namely via the events  {\hndlr{h}{p_1}{a\,=\,y}}, \evnt{t}{y\,=\,1}, and \evnt{t}{post($p_2,h$)}.
Therefore the conflict between the accesses to \texttt{x} is not a race.
%% But the message $p_1$ is also involved in
%% $$\evnt{p_1}{a\,=\,y} \happbf{\fr}{E} \evnt{t}{y\,=\,1} \happbf{\po}{E} \evnt{t}{post($p_2,r$)} \happbf{\pb}{E} \evnt{p_2}{x\,=\,2}$$
%% so this conflict is not a race.
That this conflict is not a race can also be seen by trying to swap the accesses to \texttt{x}
and discover that this will induce a cycle in the happens-before relation.
% in the trace graph.
%% Furthermore, their posts are ordered $s \happbf{\pb}{E} m[1] \happbf{\fr}{E} q[2] \happbf{\po}{E} q[2] \happbf{\pb}{E} n[1]$ which induces the derived relation $m[2] \happbf{\eop}{E} n[1]$, indicating that the conflicts between the messages $m$ and $n$ cannot be reversed.
}

% Figure environment removed
\paragraph{Reordering Messages when Reversing Races}
\EventDPOR's principles for reversing races may necessitate
reordering of messages on handlers that are not involved in the race.
%% In order to illustrate further the effect of considering races between events in messages
%% as races between a message and an event,
Consider the program in~\cref{fig:example3}.
Assume that the first explored execution is~$E_1$, where we have omitted the initial sequence of post events of thread $t$ for  succinctness.
In $E_1$, message $p_1$ is processed before $p_2$, and $q_1$ is processed before $q_2$. There are three races in $E_1$, one on each of the shared variables \texttt{x}, \texttt{y}, \texttt{z}.
Let us consider the race on \texttt{x}, shown by the red arrow. A wakeup sequence which reverses  this race must include all events of $q_2$, since these are the
$\happbf{\hb}{E_1}$-predecessors of \evnt{q_2}{c\,=\,x}. It must also include
the write to \texttt{z} by $p_2$ since it is a $\happbf{\hb}{E_1}$-predecessor of events in $q_2$. On the other hand, it cannot include any part of the message $q_1$, since $q_1$ must now occur after $q_2$, and therefore it also cannot include the read of \texttt{y} by $p_1$ since its predecessor in $q_1$ is missing.
In summary, the wakeup sequence contains two fully processed messages $p_2$ and~$q_2$, the event \hndlr{h}{p_1}{d\,=\,1} of $p_1$, 
but no events from $q_1$. Such a wakeup sequence must branch off after the post events of $t$, i.e., from the root of the tree to the right in~\cref{fig:example3}. Later, this wakeup sequence is extended to a full execution $E_2$.
In total, the program of~\cref{fig:example3} has eight inequivalent executions (the other six are not shown).

\hasbeenremoved{It should be observed that the mechanism of triggering the reordering of messages $p_1$ and $p_2$ due to a race between accesses of $q_1$ and $q_2$ is necessary in this example, otherwise execution $E_2$ can not be reached from $E_1$ by a sequence of race reversals.}

%% An informal description of the exploration proceeds as follows.
%% \begin{enumerate}
%% \item
%%   Explore a maximal execution sequence $E$.
%% \item
%%   For each race of form $e\revrace{E}e'$ or $m\revrace{E}e'$ in $E$,
%% , we construct a sequence where the race is reversed (a so-called
%%   \emph{wakeup sequence}, and thereafter check whether some consistent sequence has previously
%%   been explored. If not, it is inserted into the wakeup tree at the appropriate point, for future exploration.
%%   More precisely, it is done as follows:
%% \begin{enumerate}
%% \item
%%   We first identify the events in $E$ which do not happen-after any of the racing events or messages.
%%   Intuitively,   these events are not affected by the race or its reversal. It clearly includes $\pre{\exseq}{\event}$, resp.\  $\pre{\exseq}{m}$,
%%   but also events that occur after $e$ (resp.\ $m$) but do not happen-after $e$ (resp.\ $m$).
%%   Let $\notsucc{\event}{\exseq}$   denote the subsequence of events that do not happen-after $e$.
%%   Define $\notsucc{m}{\exseq}$ analogously.
%%   Thus, note that for a race of form $m\revrace{E}e'$, the events preceding $e'$ in its message are in
%%   $\notsucc{m}{\exseq}$.
%%   Also note that $\ppm$ edges induced by happens-before edges appearing after $e$ are not included in the considerations. 
%% %% by the race. Intuitively, this part consists of the events that do not happen-after $e$ in  $E$,
%% %%   which we denote by . An unclear case is when $e$ is a post event, which may become $\ppm$-before another post event if a long
%% %%   enough prefix of $E$ is considered. However, such a $\ppm$-edge can occur only because of a message that happens-after $e$, so therefore such potential
%% %%   edges should not be considered when computing $\notsucc{\event}{\exseq}$.
%%  %%   Here, we must be careful since the happens-before relation increases as $E$ is extended. \revise{By consulting the proof of correctness}, we see that the
%%  %%  happens-before relation should not consider induced $\ppm$ relations that occur after $e$. Let us therefore define
%%  %% as  the sub-sequence of $\exseq$ consisting of the events $\event'$ such that
%%  %%  $\event {\happbf{}{\pre{E}{e'}.\thof{e'}}} \event'$ does not hold
%% \item
%%   We next form the new wakeup sequence.
%%   For a race of form $e\revrace{E}e'$, we start by forming $x = \notsucc{\event}{\exseq}.\event'.\event$.
%%   For a race of form $m\revrace{E}e'$, we form $x = \notsucc{m}{\exseq}.\event'.\hat{m'}.\tilde{m}$, where
%%   $\hat{m'}$ executes the remainder of $m'$ (i.e., the events after $e'$) to completion, and
%%   where $\tilde{m}$ executes $m$ until a conflict with $m'$ appears (such a conflict is guaranteed to appear
%%   whenever $m\revrace{E}e'$).
%%   The sequence $x$ may not be an execution sequence, since messages may not be processed in FIFO order, but for now let us ignore this.
%%   Equip $x$ with a happens-before relation $\happbf{}{x}$, following the usual rules. Note that
%%   $\happbf{}{x}$ may include edges that point ``backwards'', but this will be fixed in step (f) below.
%%   %% If $e$ is in a message $m$ posted by $\postev_m$, we also add
%%   %% a $\happbf{}{x}$ edge to $\postev_m$ from each post event that posts a message
%%   %% $m'$ with $m' \happbf{}{x} \event'$, since $e'$ will happen before $e$ in any continuation of $x$.
%% \item
%%   We thereafter check whether $x$ is redundant, i.e., whether some previously explored branch of $\exseqs$ has explored a sequence which is consistent with $x$. This happens if there is a prefix $E$ of $x$ and
%%   a previously explored branch $E.p$ in $\exseqs$ such that, with $x = E.v$ we have
%%   $p \inwfirstseqs{E} v$. In the \OptimalDPOR algorithm, this check is performed by maintaining sleep
%%   sets during the exploration. In our algorithm, we will also use sleep sets, but they need to be modified
%%   since the happens-before relation between post events can vary depending on the subsequent execution.
%%   We elaborate on this at the end of this section.
%% \item
%%   We then find a suitable prefix of $E$ from which $x$ should branch off. This is
%%   the longest prefix $E'$ of $\pre{\exseq}{\event}$ with
%%   $E' \infirstseqs{\emptyseq} x$.
%%   Let $e''$ be the first event in $x$ that such that
%%   $e''' \happbf{}{x} e''$ for some $e'''$ which occurs after $e''$ in $x$.
%%   Such an $e''$ may exist if 
%%   the reversal of $e\revrace{E}e'$ induces reversal of some post events.
%%   If there is no such event $e''$ in $x$, then $E' = \pre{E}{e}$, otherwise
%%   $E' = \pre{E}{e''}$. 
%% \item
%%   Define $v$ by $E'.v = x$.
%% \item
%%   Reschedule $v$ so that it is consistent with  $\happbf{}{x}$ and the ordering between post events in
%%   $E'$, and insert it into the wakeup tree at $E'$.
%% \end{enumerate}
%% \end{enumerate}
%% \begin{enumerate}
%% \item
%%   Modify $E$ by reversing the happens-before edge $e \happbf{}{E} e'$ so that
%%   it points from $e'$ to $e$.
%% \item
%%   Add any $\happbf{ppm}{E}$ edge that is induced by $e' \happbf{}{E} e$.
%% \item
%%   Let $e''$ be the first event in $E$ that is the target of an induced arrow that
%%   points backwards, i.e., of form $e''' \happbf{}{E} e''$, where
%%   $e'''$ occurs after $e''$ in $E$. If the previous steps added no induced
%%   $\ppm$-edges, then $e''$ is $e$.
%% \item
%%   Let $E'$ be the prefix of $E$ that precedes $e''$.
%% \item
%%   Letting $p$ be $\thof{e''}$, create a wakeup sequence
%%   $v$ such that $p \notinwfirstseqs{E'} v$.
%% \item
%%   Check whether the sequence $E'.v$ is redundant with the already explored
%%   execution tree. If not, insert it into the wakeup tree at $E'$.
%% \end{enumerate}

  
%% \subsection{Definition of Concepts}
%% Here is a repository with concepts.
%% Let $E$ be an execution sequence, and let $v$ and
%% $w$ be sequences of threads with $\valid Ev$ and $\valid Ew$.
%% \begin{itemize}
%% \item
%%   $v \infirstseqs{E} w$ denotes that there is a sequence $v'$ such that
%%  $v.v' \equivafter{E} w$.
%%  %%  Two execution sequences $E$ and $E'$ are 
%%  %% there is a sequence $v'$ such
%%  %%  that $E.v.v'$ and $E.w$ are execution sequences with
%% \item
%%   $v \inwfirstseqs{E} w$ denotes that there are sequences $v'$ and
%%   $w'$ such that $v.v' \equivafter{E} w.w'$.
%% \end{itemize}
%%   Intuitively, $v \infirstseqs{E} w$ if, after $E$, the sequence $v$ is a
%%   possible way to start an execution that is equivalent to $w$.
%%   Intuitively, $v  \inwfirstseqs{E} w$ if, after $E$, the sequences $v$ and $w$
%%   are ``consistent'' in the sense that they can be continued to sequences that
%%   are equivalent to each other. We see that if $v$ is a prefix of $w$, then
%%   $v \infirstseqs{E} w$, and that $v \infirstseqs{E} w$ implies $v \inwfirstseqs{E} w$.
%%   Moreoever, the relations enjoy the following properties:
%% \begin{itemize}
%% \item
%%   $v \infirstseqs{E.u} w$ if and only if $u.v \infirstseqs{E} u.w$
%% \item
%%   $v \inwfirstseqs{E.u} w$ if and only if $u.v \inwfirstseqs{E} u.w$
%% \item
%%   if $v \notinwfirstseqs{E} w$ and  $v \infirstseqs{E} v'$ and $w \infirstseqs{E} w'$, then $v' \notinwfirstseqs{E} w'$
%% \end{itemize}
%% Note that there is also a difference from the corresponding definitions in a framework without event handling threads,
%% e.g., that of~\citet{abdulla2014optimal}, in that $\infirstseqs{}$ is no longer transitive. Let us illustrate this by the example seen in Figure~\ref{fig:example1}.
