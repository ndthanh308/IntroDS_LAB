\section{Complexity Results}
\label{sec:np-complete}

In this section, we consider the following two problems.

\begin{description}
\item[Event-driven Consistency.]
The event-driven consistency problem consists in checking whether, for a given  directed graph 
$(S,\happbf{\hb}{S})$ where $S$ is a set of events and $\happbf{\hb}{S}$ is a set of edges,  there is an execution sequence $E$ such that $(S,\happbf{\hb}{S})$ is the  \emph{\hb-trace} of  $E$.
%% The event-driven consistency problem consists in checking whether, for a given  directed graph 
%% $(S,\happbf{\hb}{S})$ where $S$ is a set of events and $\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\cnf}{S} \cup \happbf{\pb}{S}$ is a set of labeled edges,   there is an execution sequence $E$ such that $(S,\happbf{\hb}{S})$ is the  \emph{\hb-trace} of  $E$ (i.e., $S=\dom{E}$, $ \happbf{\po}{S} =\happbf{\po}{E} $,  $\happbf{\cnf}{S} = \happbf{\cnf}{E}$  and $\happbf{\pb}{S} = \happbf{\pb}{E}$).

\item[Weak Initial Check.]
The weak initial check problem consists in checking whether  $p \in \winits{\exseq}{w}$ for a message $p$.

%\item {\bf Reversing the order of the execution of two messages.} The order reversing  problem consists in checking whether, for a given   execution sequence $E=w_1 . e_1 . w_2 . e_2 . w_3$ such that $e_1$ and $e_2$ are the two first events executed by two messages on the same thread handler, there is an  execution sequence $E'=w'_1 . e_1 . w'_2 . e_2 . w'_3$ such that $E \mtequiv E'$.
\end{description}

The following theorems summarise our results concerning these problems.
Their proofs can be found in \cref{sec:complexity-proof}.

\begin{theorem}
\label{thm-consistency}
The event-driven consistency problem is NP-complete.
\end{theorem}


\begin{theorem}
\label{thm-lowerbound}
The weak initial check problem is NP-hard.
\end{theorem}

% Their proofs can be found in \cref{sec:complexity-proof} of the supplementary material.



%  \subsection{NP-completeness of the event-driven consistency problem}
%
%\paragraph{Upper-bound} Let  $(S,\happbf{\hb}{S})$ be a directed graph (i.e., \hb-trace) 
% where $S$ is a set of events and $\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\cnf}{S} \cup \happbf{\pb}{S}$ is a set of labeled edges.
%To show that the event-driven consistency problem is NP, it suffices to first guess a total ordering $<_S$ between the messages on the same thread handler. Observe that we can have at most one incomplete message per handler which should be scheduled last with respect to $<_S$. We then use  the  total order relation $<_S$ to extend  the {\em program order} relation  $\happbf{\po}{S}$   into a total order relation $\happbf{\po}{}$ on the set of events executed by the same handler such that: $(1)$ $e \happbf{\po}{} e'$ if $e \happbf{\po}{S} e'$, and $(2)$
%$e \happbf{\po}{} e'$ whenever $e$ and $e'$ are events in two different messages $p$ and $p'$ on the same handler and $p <_S p'$. Finally,  the extended  {happens-before relation} $\happbf{\hb}{}=\happbf{\po}{} \cup \happbf{\cnf}{S} \cup \happbf{\pb}{S}$  is acyclic ({which  is equivalent  to checking sequential consistency} of the extended graph $(S,\happbf{\hb}{})$) if and only if  there is an execution sequence $E$ such that $(S,\happbf{\hb}{})$ is the  \emph{\hb-trace} of  $E$ (i.e., $S=\dom{E}$, $ \happbf{\po}{} =\happbf{\po}{E} $,  $\happbf{\cnf}{S} = \happbf{\cnf}{E}$  and $\happbf{\pb}{S} = \happbf{\pb}{E}$). Observe that checking the acyclicity  of the extended {happens-before relation} $\happbf{\hb}{S}$ can be done in polynomial time. Furthermore, the execution sequence $E$ can be obtained   via the linearlization of the extended {happens-before relation} $\happbf{\hb}{}$  (since the extend  the {\em program order} relation $\happbf{\po}{}$  forces the messages on the same handler to be executed one after the other).
%
%\paragraph{Lower-bound} We prove the lower bound by reduction from the problem of verifying the sequential consistency  of traces when  only the read-from relation is given. Hereafter, we call this problem VSC-read. The VSC-read problem consists in checking whether, given a directed graph $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$
% where $S$ is a set of write and read events, $\happbf{\po}{S}$ is the program order relation that totally order all the events of each thread, and $\happbf{\rf}{S}$ is the {\em read-from} relation that maps each read event to the  write event from which it gets its value, there is an execution sequence $E$ such that $S=\dom{E}$, $ \happbf{\po}{S} =\happbf{\po}{E} $ and 
% $\happbf{\rf}{S} \subseteq \happbf{\cnf}{E}$. 
% The VSC-read problem is known to be  NP-complete in the size of the program 
%~\cite[Theorem~4.1]{DBLP:journals/siamcomp/GibbonsK97}.
%
%We now reduce the VSC-read problem to the event-driven consistency problem. Let   $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$ be a directed graph. 
%To simplify the presentation\footnote{We assume that threads/messages are spawned/posted by a main thread, and that all shared variables get initialized to 0, also by the main thread. To make the presentation simple, we omit the events of the main thread.}, we assume w.l.o.g. that each write event is read by at least one read event. 
%The main idea of our reduction is to associate a message $p_e$  for each event $e$. The message $p_e$ will be executed by the handler $h$. The order of the execution of these messages will correspond to a linearization  of the set of event $S$ (since all these messages will be executed by the same handler $h$). However, this poses a challenge  since such  reduction from the VSC-read problem to the event-driven consistency problem will  fix the order of write events on the same
%variable (as it is implied by the conflict relation $\happbf{\cnf}{}$). To address this challenge we  rename the shared variables used by each event in $S$ and thus there will be no conflict relation between write-write events (and therefore between read-write events too). However, this leads to a new challenge which is how to make sure that between a write event $e \in S$ and a read event $e' \in S$ that is reading from $e$ there is no other scheduled write event   in $S$ on the same variable between $e$ and $e'$. To address the second challenge, we use an extra handler $h_x$ per variable $x$ that executes a number of independent messages (one  per write event on x in $S$). The order in which these messages are executed corresponds to the order in which the write events  on the same variable are scheduled. Furthermore, we make sure that each read event is scheduled after the write event it reads from and before the next scheduled write event on the same variable.
%
%Formally, for every write event $e$ in $S$ executed by a thread $t$, we create a message $p_e$ running on the thread handler $h$. The message 
%$p_e$ will be of the form [\texttt{$x_e$\,= 1};\,\texttt{$x_t$\,= 1};\, \texttt{$x_e$\,= 1};].  For a read event $e'$ in $S$ executed by a thread $t$ and reading from the write event $e$, we create a message $p_{e'}$ running on the thread handler $h$. The message 
%$p_{e'}$ will be of the form [\texttt{a=$y_e$};\,\texttt{$x_t$\,= 1};\, \texttt{a=$y_e$};]. We use the write event on $x_t$ to order the messages corresponding to events running on the same thread $t$ in $S$. In fact, we will simulate $\happbf{\po}{S}$ using $\happbf{\cnf}{S'}$ that will  totally order all the write events on $x_t$. This results in adding  a conflict relation $ \happbf{\cnf}{S'}$ between every two events corresponding to the writes on $x_t$ in two different messages $p_e$ and $p_{e'}$ iff $e \happbf{\po}{S} e'$. 
%
%The  statements on $x_e$ and $y_e$ are used to force a total order on the messages corresponding to events on the same variable such that  all the read messages are scheduled just after their corresponding write messages. To that aim we use an extra handler $h_x$ for each variable $x$ (used by the events of $S$). For each write event $e$ on the variable $x$, we create a message $p_{e,x}$ that will run the following sequence of statements [\texttt{$x_e$\,= 0};\, \texttt{$x_e$\,= 0};\,\texttt{$y_e$\,= 0};\, \texttt{$y_e$\,= 0};]. We then add a conflict relation from the first  write of $p_{e,x}$   to the first write of $p_e$ and from  the last write of $p_e$  to the second write of $p_{e,x}$. This will force the message $p_e$ to start and end before its corresponding read messages. For a read event $e'$  reading from the write event $e$,  we also add a conflict relation from the third write of $p_{e,x}$  to  the first  read of $p_{e'}$ and from the last read of $p_{e'}$ to  the last write of $p_{e,x}$. This conflict relation will force that all the message $p_{e'}$ will be executed just after the message $p_e$ without the interleaving  of  any other message that corresponds to a write event on $x$ between $p_e$ and $p_e'$.
%
%Observe that the messages $p_e$ are run one after the other (since they are on the same handler $h$). Furthermore, the constraints between the messages of the handler $h$ and the messages of the handler $h_x$ impose that the read message $p_{e'}$ is scheduled just after its corresponding write message $p_e$ and before the next scheduled write  message on the same variable.
%Let $(S',\happbf{\hb'}{S'}=\happbf{\po}{S'} \cup \happbf{\cnf}{S'}\cup  \happbf{\pb}{S'})$ be the constructed  \hb-trace from $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$. It is then easy to see that:
%
%\begin{lemma}
% There is an execution sequence $E'$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E'$  if and only if there is an execution $E$ such that $S=\dom{E}$, $ \happbf{\po}{S} =\happbf{\po}{E} $ and 
% $\happbf{\rf}{S} \subseteq \happbf{\cnf}{E}$. 
%\end{lemma}
%
%\subsection{NP-hardness proof of the weak initial check problem}
%
%
%
%
%
%
%%\paragraph{Upper-bound} 
%% Let $E$ be an execution sequence,  $w$ be a sequence with $\valid Ew$, and $p$ be a given message. We assume that $p$ starts after $E$  and that  $p$ is not the first message on its handler in $w$ (see Section \ref{sec:checkwi}).  
%% 
%% We extend $w$ by completing all the unfinished messages and then  executing the message  $p$ if $p$ was not already started in $w$. Let $E'$ be the resulting execution sequence. 
%% Let  $(S',\happbf{\hb}{S'})$  be the  \hb-trace of E'. We construct from $(S',\happbf{\hb}{S'})$ another \hb-trace $(S,\happbf{\hb}{S})$ where $S$ contains all the events of S' (modulo renaming of the events) plus two extra events $e$ and $e'$. The new event $e$ (resp. $e'$) corresponds to the first  statement of a new message constructed from  the message  $\procof{\event_1}$ (resp.  $\procof{\event_2}$) by adding to it a write statement to a fresh variable $x_{new}$ at its beginning. The happens-before relation $\happbf{\hb}{S'}$ contains $\happbf{\hb}{S}$ plus a conflict relation from $e'$ to $e$ and a program order relation from $e$ to $e_1$ and from $e'$ to $e_2$. Having this conflict relation from $e'$ to $e$ will force the message $\procof{e'}$ (i.e., $\procof{\event_2}$) to be executed before  $\procof{e}$ (i.e., $\procof{\event_1}$). Finally, it suffices to check the event-driven consistency  of $(S',\happbf{\hb}{S'})$ in order to determine the existence of an  execution sequence $E'$ of the form $w'_1 . e_1 . w'_2 . e_2 . w'_3$ such that $E \mtequiv E'$.
%
%
%We  prove the lower bound by reduction from the  VSC-read problem. The reduction is similar to the one from the  event-driven consistency problem to the  weak initial check   problem except that we need to start from an execution sequence and reversing the order of two messages leads to the pattern used in the hardness  proof of the  event-driven consistency problem. The main idea of the proof is to replace the conflict relation from   $p_e$ to $p_{e,x}$ by a sequence of conflict relations that go through two particular messages $p'_{e,x}$ and $p''_{e,x}$ if they are executed in a certain order. Otherwise there is no conflict relation from $p_e$ to  $p_{e,x}$ and so the happens-before relation is acyclic by default.
% 
%We use the same set of assumptions as in the hardness proof of the  event-driven consistency problem. 
%We now reduce the VSC-read problem to the order reversing problem. Let   $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$ be a directed graph. As in the previous proof we  associate a message $p_e$  for each event $e$. The message $p_e$ will be executed by the handler $h$. 
%For every write event $e$ in $S$ executed by a thread $t$, we have a message $p_e$. The message 
%$p_e$ is of the form [\texttt{$x_e$\,= 1};\,\texttt{$x_t$\,= 1};\, \texttt{$x'_e$\,= 1};].  For a read event $e'$ in $S$ executed by a thread $t$ and reading from the write event $e$, we have a message $p_{e'}$. The message 
%$p_{e'}$ is of the form [\texttt{a=$y_e$};\,\texttt{$x_t$\,= 1};\, \texttt{$y_{e'}$=0};]. 
%
%We use also an extra handler $h_x$ for each variable $x$ (used in the events of $S$). For each write event $e$ on the variable $x$, we have a message $p_{e,x}$ that will run the following sequence of statements [\texttt{$x_e$\,= 0};\, \texttt{$z_e$\,= 0};\,\texttt{$y_e$\,= 0};\, \texttt{$z'_e$\,= 0};]. We then add a conflict relation from  the first write of $p_{e,x}$ to the first  write of $p_e$. This will force the message $p_e$ to start after $p_{e,x}$. For a read event $e'$  reading from the write event $e$,  we also add a conflict relation from  the third write of $p_{e,x}$  to the first  read of $p_{e'}$. Observe that we do not impose a direct conflict relation from  $p_{e}$ or $p_{e'}$ to $p_{e,x}$.
%
%For each write event $e$ on the variable $x$, we have two messages $p'_{e,x}$ and $p''_{e,x}$ that run on a fresh handler $h_e$ the following sequence of statements 
%[\texttt{a\,= z};\, \texttt{$x'_e$\,= 1};] and [\texttt{$z_e$\,= 0};\, \texttt{a\,= x};] respectively. We add a conflict relation from the second last event of  $p_{e}$ to the second event of $p'_{e,x}$ and from the first write event of  
%$p''_{e,x}$  to the last event of  the second write event of  $p_{e,x}$. Observe that in the case that $p'_{e,x}$ is executed before $p''_{e,x}$, we have an indirect conflict relation from the last write of $p_e$ to  the second write of $p_{e,x}$   through $p'_{e,x}$ and $p''_{e,x}$. In the case where we execute $p''_{e,x} $ before $p'_{e,x}$, there is no  (indirect) happens-before relation from $p_{e}$ to $p_{e,x}$.
%
%
%%We add a conflict relation from the second write event of  $p_{e,x}$ to the second event of $p'_{e,x}$ and from the first write event of  
%%$p''_{e,x}$  to the last event of $p_e$. Observe that in the case that $p'_{e,x}$ is executed before $p''_{e,x}$, we have an indirect conflict relation from the second write of $p_{e,x}$ to the last write of $p_e$ through $p'_{e,x}$ and $p''_{e,x}$. In the case where we execute $p''_{e,x} $ before $p'_{e,x}$, there is no  (indirect) happens-before relation from $p_{e,x}$ to $p_e$.
%
%
%In similar manner, for each  read event $e'$ on $x$ in $S$  reading from the write event $e$, we have two messages $p'_{e',x}$ and $p''_{e',x}$ that run on a fresh handler $h_{e'}$ the following sequence of statements 
%[\texttt{a\,= z};\, \texttt{$y_{e'}$\,= 1};] and [\texttt{a=$z'_e$};\, \texttt{a\,= x};] respectively.  We add a conflict relation from the the last event of $p_{e'}$ to the second event of $p'_{e',x}$ and from the first read event of  
%$p''_{e',x}$  to the  last write event of  $p_{e,x}$. Observe that in the case that $p'_{e',x}$ is executed before $p''_{e',x}$, we have an indirect conflict relation from the last write of $p_{e'}$ to the last write of $p_{e,x}$ through $p'_{e',x}$ and $p''_{e',x}$.
%
%To set the order of all $p'_{e,x}$ and  $p''_{e,x}$ ($p'_{e',x}$ and $p''_{e',x}$), we will use  two messages $p$ and $p'$ on a fresh handler $h'$ that run the following  statements [\texttt{ $x_p$=1}; \texttt{ z=1};] and [\texttt{ $x_{p'}$=1}; \texttt{x\,= 1};] respectively. We add then a conflict relation  from the first read event of  $p'_{e,x}$ (resp. $p'_{e',x}$) to the  event of $p$ and from the  write event of  
%$p'$  to the last event of $p''_{e,x}$ (resp.  $p''_{e',x}$). Note that if $p$ is executed before $p'$ then  $p'_{e,x}$ (resp. $p'_{e',x}$) is executed before  $p''_{e,x}$ (resp. $p''_{e',x}$).
%
%
%Let $(S',\happbf{\hb'}{S'}=\happbf{\po}{S'} \cup \happbf{\cnf}{S'}\cup  \happbf{\pb}{S'})$ be the constructed  \hb-trace from $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$. It is easy to see that there is an execution sequence $E$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E$ and where the message $p'$  is executed before $p$ and   $p''_{e,x}$ (resp. $p''_{e',x}$) is executed before  $p'_{e,x}$ (resp. $p'_{e',x}$).
%
%
%\begin{lemma}
%\label{lemma2}
% There is an execution sequence $E'$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E'$ and where the first event of message $p$ is  the  first executed event in $E$    if and only if there is an execution $E''$ such that $S=\dom{E}$, $ \happbf{\po}{S} =\happbf{\po}{E} $ and 
% $\happbf{\rf}{S} \subseteq \happbf{\cnf}{E}$. 
%\end{lemma}
%
%Imposing $p$ to be executed before $p'$ will impose that every  $p'_{e,x}$ (resp. $p'_{e',x}$) is executed before  $p''_{e,x}$ (resp. $p''_{e',x}$) and so there will be an indirect relation from the last write of  (resp. $p_e$) $p_{e'}$ to the last (second) write of $p_{e,x}$ through $p'_{e,x}$ and $p''_{e,x}$ ($p'_{e',x}$ and $p''_{e',x}$). Thus, we are in similar case as in the hardness proof of the  event-driven consistency problem.
%Furthermore, we have the first event of $E'$  can be the first event of $p$ since it is independent from any other event.
%
%
%\begin{lemma} 
%\label{lemma3}
%$p \in \winits{\emptyseq}{E}$  if and only if there is an execution sequence $E'$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E'$ and where the message $p$ is  executed before $p'$.
%\end{lemma}
%
%Finally, Theorem \ref{thm-lowerbound} can be see as an immediate  corollary of  Lemma \ref{lemma2}, and Lemma \ref{lemma3}.
%
%%
%%\subsection{The Order Reversing  Problem}
%%
%%In the following, we show:
%%
%%\begin{theorem}
%%The order reversing problem is NP-complete.
%%\end{theorem}
%%
%%The rest of this section is devoted to the proof of the above theorem.
%%
%%\paragraph{Upper-bound} 
%%Let   $E=w_1 . e_1 . w_2 . e_2 . w_3$ be an execution sequence  such that $e_1$ and $e_2$ are the two first events executed by two messages on the same thread handler $h$. Let  $(S,\happbf{\hb}{S})$  be the  \hb-trace of E. We construct from $(S,\happbf{\hb}{S})$ another \hb-trace $(S',\happbf{\hb}{S'})$ where $S'$ contains all the events of S (modulo renaming of the events) plus two extra events $e$ and $e'$. The new event $e$ (resp. $e'$) corresponds to the first  statement of a new message constructed from  the message  $\procof{\event_1}$ (resp.  $\procof{\event_2}$) by adding to it a write statement to a fresh variable $x_{new}$ at its beginning. The happens-before relation $\happbf{\hb}{S'}$ contains $\happbf{\hb}{S}$ plus a conflict relation from $e'$ to $e$ and a program order relation from $e$ to $e_1$ and from $e'$ to $e_2$. Having this conflict relation from $e'$ to $e$ will force the message $\procof{e'}$ (i.e., $\procof{\event_2}$) to be executed before  $\procof{e}$ (i.e., $\procof{\event_1}$). Finally, it suffices to check the event-driven consistency  of $(S',\happbf{\hb}{S'})$ in order to determine the existence of an  execution sequence $E'$ of the form $w'_1 . e_1 . w'_2 . e_2 . w'_3$ such that $E \mtequiv E'$.
%%
%%
%%\paragraph{Lower-bound} We  prove the lower bound by reduction from the  VSC-read problem. The reduction is similar to the one from the VSC-read problem to the event-driven consistency problem except that we need to start from an execution sequence and reversing the order of two messages leads to the pattern used in the previous proof. The main idea of the proof is to replace the conflict relation from   $p_e$ to $p_{e,x}$ by a sequence of conflict relations that go through two particular messages $p'_{e,x}$ and $p''_{e,x}$ if they are executed in a certain order. Otherwise there will be no conflict relation from $p_e$ to  $p_{e,x}$ and thus our happens-before relation is acyclic by default.
%% 
%%
%%We now reduce the VSC-read problem to the order reversing problem. Let   $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$ be a directed graph. As in the previous proof we  associate a message $p_e$  for each event $e$. The message $p_e$ will be executed by the handler $h$. 
%%For every write event $e$ in $S$ executed by a thread $t$, we have a message $p_e$. The message 
%%$p_e$ is of the form [\texttt{$x_e$\,= 1};\,\texttt{$x_t$\,= 1};\, \texttt{$x'_e$\,= 1};].  For a read event $e'$ in $S$ executed by a thread $t$ and reading from the write event $e$, we have a message $p_{e'}$. The message 
%%$p_{e'}$ is of the form [\texttt{a=$y_e$};\,\texttt{$x_t$\,= 1};\, \texttt{$y_{e'}$=0};]. 
%%
%%We use also an extra handler $h_x$ for each variable $x$ (used in the events of $S$). For each write event $e$ on the variable $x$, we have a message $p_{e,x}$ that will run the following sequence of statements [\texttt{$x_e$\,= 0};\, \texttt{$z_e$\,= 0};\,\texttt{$y_e$\,= 0};\, \texttt{$z'_e$\,= 0};]. We then add a conflict relation from  the first write of $p_{e,x}$ to the first  write of $p_e$. This will force the message $p_e$ to start after $p_{e,x}$. For a read event $e'$  reading from the write event $e$,  we also add a conflict relation from  the third write of $p_{e,x}$  to the first  read of $p_{e'}$. Observe that we do not impose a direct conflict relation from  $p_{e}$ or $p_{e'}$ to $p_{e,x}$.
%%
%%For each write event $e$ on the variable $x$, we have two messages $p'_{e,x}$ and $p''_{e,x}$ that run on a fresh handler $h_e$ the following sequence of statements 
%%[\texttt{a\,= z};\, \texttt{$x'_e$\,= 1};] and [\texttt{$z_e$\,= 0};\, \texttt{a\,= x};] respectively. We add a conflict relation from the second last event of  $p_{e}$ to the second event of $p'_{e,x}$ and from the first write event of  
%%$p''_{e,x}$  to the last event of  the second write event of  $p_{e,x}$. Observe that in the case that $p'_{e,x}$ is executed before $p''_{e,x}$, we have an indirect conflict relation from the last write of $p_e$ to  the second write of $p_{e,x}$   through $p'_{e,x}$ and $p''_{e,x}$. In the case where we execute $p''_{e,x} $ before $p'_{e,x}$, there is no  (indirect) happens-before relation from $p_{e}$ to $p_{e,x}$.
%%
%%
%%%We add a conflict relation from the second write event of  $p_{e,x}$ to the second event of $p'_{e,x}$ and from the first write event of  
%%%$p''_{e,x}$  to the last event of $p_e$. Observe that in the case that $p'_{e,x}$ is executed before $p''_{e,x}$, we have an indirect conflict relation from the second write of $p_{e,x}$ to the last write of $p_e$ through $p'_{e,x}$ and $p''_{e,x}$. In the case where we execute $p''_{e,x} $ before $p'_{e,x}$, there is no  (indirect) happens-before relation from $p_{e,x}$ to $p_e$.
%%
%%
%%In similar manner, for each  read event $e'$ on $x$ in $S$  reading from the write event $e$, we have two messages $p'_{e',x}$ and $p''_{e',x}$ that run on a fresh handler $h_{e'}$ the following sequence of statements 
%%[\texttt{a\,= z};\, \texttt{$y_{e'}$\,= 1};] and [\texttt{a=$z'_e$};\, \texttt{a\,= x};] respectively.  We add a conflict relation from the the last event of $p_{e'}$ to the second event of $p'_{e',x}$ and from the first write event of  
%%$p''_{e',x}$  to  last write event of  $p_{e,x}$. Observe that in the case that $p'_{e',x}$ is executed before $p''_{e',x}$, we have an indirect conflict relation from the last write of $p_{e'}$ to the last write of $p_{e,x}$ through $p'_{e',x}$ and $p''_{e',x}$.
%%
%%To set the order of all $p'_{e,x}$ and  $p''_{e,x}$ ($p'_{e',x}$ and $p''_{e',x}$), we will use  two messages $p$ and $p'$ on a fresh handler $h'$ that run the following  statements [\texttt{ z=1};] and [\texttt{x\,= 1};] respectively. We add then a conflict relation  from the first read event of  $p'_{e,x}$ (resp. $p'_{e',x}$) to the  event of $p$ and from the  write event of  
%%$p'$  to the last event of $p''_{e,x}$ (resp.  $p''_{e',x}$). Note that if $p$ is executed before $p'$ then all $p'_{e,x}$ (resp. $p'_{e',x}$) are executed before  $p''_{e,x}$ (resp. $p''_{e',x}$) and vice-versa.
%%
%%
%%Let $(S',\happbf{\hb'}{S'}=\happbf{\po}{S'} \cup \happbf{\cnf}{S'}\cup  \happbf{\pb}{S'})$ be the constructed  \hb-trace from $(S,\happbf{\hb}{S}=\happbf{\po}{S} \cup \happbf{\rf}{S})$. It is easy to see that  there is an execution sequence $E$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E$ and where the message $p'$  is executed before $p$.
%%
%%\begin{lemma}
%% There is an execution sequence $E'$ such that $(S',\happbf{\hb}{S'})$ is the  \emph{\hb-trace} of  $E'$ and where the message $p$ is  executed before $p'$   if and only if there is an execution $E''$ such that $S=\dom{E}$, $ \happbf{\po}{S} =\happbf{\po}{E} $ and 
%% $\happbf{\rf}{S} \subseteq \happbf{\cnf}{E}$. 
%%\end{lemma}
%%
%\end{comment}
