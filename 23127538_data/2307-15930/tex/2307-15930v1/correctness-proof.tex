\section{Proof of Correctness and Optimality}
\label{sec:correctness-proof}

In this section, we prove correctness (\cref{thm:correctness}) and optimality
(\cref{thm:optimality}) of the \EventDPOR algorithm.

\subsection{Proof of \cref{thm:correctness}}

Let us first prove \cref{thm:correctness}. This theorem follows from the more general
\cref{thm:correctness-general}, which we state and prove in this section.

Let us
% present the main properties of the \EventDPOR algorithm. Throughout, we
assume a particular completed execution of \EventDPOR. This execution 
consists of a number of terminated calls to $\explore(E)$ for some values 
of the parameters $E$ and $\WuT$. Let $\exseqs$ denote the set of execution 
sequences $E$ that have been explored in some call $\explore(E)$. Define 
the ordering $\treeorder$ on $\exseqs$ by letting $E \treeorder E'$ if 
$\explore(E)$ returned before $\explore(E')$. Intuitively, if one 
were to draw an ordered tree that shows how the exploration has proceeded, then 
$\exseqs$ would be the set of nodes in the tree, and $\treeorder$ would be the 
post-order between nodes in that tree. \cref{thm:correctness} follows from the more
general \cref{thm:correctness-general}, stated here

\begin{theorem}[Correctness of \EventDPOR]
\label{thm:correctness-general}
Whenever a call to $\explore(E)$ returns during \cref{alg:eventdpor-access},
then for all maximal execution sequences $E.w$, the algorithm has explored
some execution sequence in~$\eqclass{E.w}$.
\end{theorem}

Since the initial call to the algorithm, $\explore(\emptyseq)$, starts with
the empty sequence as argument, \cref{thm:correctness-general}
implies that for all maximal execution sequences $E$ the algorithm
explores some execution sequence $E'$ which is in $\eqclass{E}$.
Note also that a sequence of form $E.w$ need not have been explored inside
the call $\explore(E)$, but can have been explored in some earlier call,
of form $\explore(E'.p)$ for some prefix $E'$ of $E$.

The proof of~\cref{thm:correctness-general} proceeds by induction on the set $\exseqs$ of execution sequences $E$ that
are explored during the considered execution, using the ordering $\treeorder$
(i.e., the order in which the corresponding calls to $\explore(E)$ return).

We first state and prove a small lemma.

\begin{lemma}
\label{lem:WuT-exseqs}
Let $\exseqs$ be the tree of explored execution sequences. and let $\treeorder$ be
the order in which the corresponding calls to $\explore(E)$ return.
Consider some point in the execution, and let  $\wut{\exseq}$ be the wakeup tree
at $\exseq$ at that point, for some $\exseq \in \exseqs$.
\begin{enumerate}
\item \label{lem:WuT-exseqs:1}
  If $w \in \wut{\exseq}$ for some $w$, then $\exseq.w \in \exseqs$.
\item \label{lem:WuT-exseqs:2}
  If $w \prec w'$ for $w,w' \in \wut{\exseq}$ then $\exseq.w \treeorder \exseq.w'$
\end{enumerate}
\end{lemma}
%
\begin{proof}
The lemma follows by noting how the exploration from any $\exseq
\in \exseqs$ is controlled by the wakeup tree $\wut{\exseq}$ at
\crefrange{algacsl:exploration-begin}{algacsl:event-call-explore}
of~\cref{alg:eventdpor-access}.
\end{proof}

%\begin{comment}
%\bjcom{All of this goes away, since it has been defined earlier}
%
%First a definition. Let $E$ be an execution sequence, $p$ be a thread, and $v$ a  a sequence with $\valid Ev$. 
%We let $p \racefree{E} v$ denote that there is a sequence $w$ with $\valid E{p.w}$ such that $v \mtprefixafter{E} p.w$.
%%% \begin{itemize}
%%% \item
%%%   $\dom{E.v} \subseteq \dom{E.p.w}$
%%% \item
%%%   The relation $\happbf{}{E.p.w} \cup \precof{E.v}$, where $\precof{E.v}$
%%%   \begin{inparaenum}[(i)]
%%%   \item
%%%     totally orders the events in $\dom{E.v}$ by $\totorder{E.v}$ and
%%%   \item
%%%     orders all events in $\dom{E.v}$ before all events not in $\dom{E.v}$,
%%%   \end{inparaenum}
%%%   is acyclic.
%%% \end{itemize}
%Intuitively, $p \racefree{E} v$ denotes that there is a sequence starting with $p$ which includes all events of $v$ and does not interfere with the ordering on $v$.
%Concretely, if $\nextev{E}{p}$ is a write or read operation on a shared variable, then
%$p \racefree{E} v$ amounts to checking whether $p$ is independent with the longest prefix of $v$ that does not contain $p$
%(which may be $v$ itself if $v$ does not contain $p$).
%If $\nextev{E}{p}$ is a post event then $p \racefree{E} v$ holds if and only if we can transform $v$ to $p.w$ by 
%\begin{inparaenum}[(i)]
%\item
%  first moving events $e$ in $v$ with $\nextev{E}{p} \happbf{\pb^*}{E.v} e$ towards the front, but respecting $\happbf{}{E.v}$,
%  so that $p$ ends up first, and 
%\item
%  thereafter adding events, which may not happen-before (acc.\ to $\happbf{}{E.p.w}$) any events already in $v$,
%\end{inparaenum}
%such that $E.p.w$ is a valid execution sequence.
%It turns out that
%\begin{itemize}
%\item in step (i) it is sufficient to move $p$ first, and to move messages resulting from $\nextev{E}{p}$ just enough to maintain FIFO execution,
%\item in step (ii) it is sufficient add events in or happening-before (acc.\ to $\happbf{}{E.p.w}$) messages (transitively) posted from $\nextev{E}{p}$.
%\end{itemize}
%%% $p \inwfirstseqs{E} w$ under the assumption that for each handler thread $t$, if $t$ is in the middle of executing a message at the end of $E.w$, then
%%% that message has no remaining events, i.e., it is truncated at the point of execution that it has reached at the end of $E.w$.
%%% If $\nextev{E}{p}$ is a write or read event, then
%%% $p \racefree{E} w$ is the same as $p \inwfirstseqs{E} w$, but
%%% if $\nextev{E}{p}$ is a post event to a handler $t$, then we must pretend that any message executed by
%%% by $t$ at the end of $w$ has no remaining events.
%As an example, in the program of \cref{fig:non-atomic-1},
%\fix{
%we have $p \racefree{\emptyseq} q.m[1]$ since the message $n$ posted by $p$ does not conflict with $m[1]$. This
%in spite of the fact that $p \notinwfirstseqs{\emptyseq} q.m[1]$, since any continuation of $m$ will conflict
%with $n$. The point of this definition is that $p \racefree{E} w$ denotes that the trace $w$ itself has 
%no conflicts that may cause $\nextev{E}{p}$ not to be a weak initial:
%such conflicts may arise only when the message executed at the end of $w$ is continued.}
%
%\bjcom{End of what goes away}
%\end{comment}

We now continue with the proof of \cref{thm:correctness-general}.

\medskip
\noindent
{\sl Base Case:}
This case corresponds to the first execution sequence $E$ for which the call
$\explore(E)$ returns. By the algorithm, $E$ is already
maximal, so the theorem trivially holds.

\medskip
\noindent
{\sl Inductive Hypothesis:}
The theorem holds for all execution
sequences $E'$ with $E' \treeorder E$.

\medskip
\noindent
{\sl Inductive Step:}
Proof by contradiction. Let us assume that there exists an execution $E$
such that when the call to $\explore(E)$ returns,
there is a maximal execution sequence $E.w$ such that
\cref{alg:eventdpor-access} has not explored
any execution sequence in $\eqclass{E.w}$.
We will show that this leads to a contradiction.
%% \bjcom{The following should be revised (but later)}
%% The proof will follow these steps:
%% \begin{enumerate}[1.]
%%   \item \label{itm:proofstep1} Choose two conflicting events in $w$. We will 
%%                                see next how to choose them. 
%%   \item \label{itm:proofstep2} Prove that there is some execution sequence 
%%                                that was explored before(by $\treeorder$ order), 
%%                                in which we see the conflicting events in 
%%                                opposite order. This execution sequence should 
%%                                respect some happens before relation from $w$, 
%%                                which we will see later in the proof.
%%   \item \label{itm:proofstep3} The algorithm will detect the race between those 
%%                                two events and reverse. As a result it will 
%%                                explore some equivalent sequence of $w$. 
%% \end{enumerate}
%% \bjcom{end of text to be revised}
So, let $E$ be the smallest such execution in the $\treeorder$ order.
Let $\done$ be the value of the mapping $\done$ when the call to $\explore(E)$ returns.
Note that for such $w$ to exist, $\exseq$ cannot be maximal, so $\done(E)$ contains at least one message.

For each message $p$ such that $p \in \done(E')$ for some $E'$ with $E' \leq E$, 
% when the call to $\explore(E)$ returns,
define $E_p'$ to be the longest such $E'$. Thus, if 
$p \in \done(E)$ then $E_p' = E$, otherwise if
$E_p'$ is defined it is a strict prefix of~$E$ with $p \in \done(E_p')$.
It follows that $E_p'.p \treeorder E$.
We further define $w_p'$ by $\exseq = E_p'.w_p'$.
For each message $p$ such that $E_p'$ is defined and $p \in \winits{E_p'}{w_p'}$, define
\begin{itemize}
%% \item the sequence $E_p'$, such that $E_p' \leq E$ and
%%   $E_p'.p \in \exseqs$, and such that $E_p'.p$ is the last execution
%%   sequence of this form in $\exseqs$ that precedes $E$ (w.r.t.\ $\treeorder$);
\item $w_p$ as the longest prefix of $w$ such that $p \in \winits{E_p'}{w_p'.w_p}$ (such a prefix must exist since one candidate is the empty sequence),
\item $e_p$ as the first event in $w$ which is not in
  $w_p$.  Such an event $e_p$ must exist, otherwise $w_p = w$, which implies
  $p \in \winits{E_p'}{w_p'.w}$,
%%   which implies $p \racefree{\exseq}{w}$,
  which together with the Inductive Hypothesis contradicts the assumption that
  the algorithm has not explored
  any execution sequence in $\eqclass{E.w}$,
\item $w_p''$ as a sequence such that $w_p'.w_p\mtprefixafter{E_p'}{p.w_p''}$.
  %% which includes the event $e_p$.
  %% Such a sequence exists by the following argument: (* THIS IS COMPLETELY WRONG *)
  %% \bjcom{The following text must be revised. It is too abstract, and should be adapted to our
  %% current execution model}
  %% \begin{quote}
  %%   By $p \in \winits{E_p'}{w_p'.w_p}$ there is a sequence $w_p''$ with $w_p'.w_p\mtprefixafter{E_p'}{p.w_p''}$. If $w_p''$ does not include $e_p$, then since
  %% $e_p$ is enabled after $E_p'.w_p'.w_p$, the only reason why $e_p$ cannot be added after $E_p'.p.w_p''$ is that some messages have been inserted before $e_p$ in
  %% its handler thread. But after executing these messages, $e_p$ can be added to $w_q''$, while preserving the property $w_p'.w_p\mtprefixafter{E_p'}{p.w_p''}$.
  %% \end{quote}
  %% Let $u_p$ be the subsequence of $p.w_p''$ consisting of the events that are not in $w_p'.w_p$. We note that $e_p$ must happen-after some event in $u_p$,
  %% otherwise we would have $w_p'.w_p.e_p \mtprefixafter{E_p'}{p.w_p''}$, implying $p \in \winits{E_p'}{w_p'.w_p.e_p}$, contradicting the maximality of $w_p$.
  %% Among the possible sequences $w_p''$ with the $w_p'.w_p\mtprefixafter{E_p'}{p.w_p''}$ that include $e_p$,
  %% choose one with the smallest number of events in $u_p$ that happen-before $e_p$.
\end{itemize}
Among the messages $p$ for which $E_p'$ is defined and $p \in \winits{E_p'}{w_p'}$, select
$q$ such that $w_q$ is the longest prefix among $w_p$.
If there are several such messages $q$ with equally long prefixes $w_q$,
%% then among these pick $q$ with a minimal number of events in $u_q$ that happen-before $e_q$ in
%% $E_q'.q.w_q''$ (note that there is at least one such event in each $u_q$).
%% If there are still several messages $q$ with a minimal number of such events,
then among these pick $q$ such that
$E_q'.q$ is minimal with respect to $\treeorder$.
Let $w_q''$ be a sequence with $w_q'.w_q\mtprefixafter{E_q'}{q.w_q''}$. 
%% \item $E_q'$, such that $E_q'  \leq E$,
%%   $E_q'.q \in \exseqs$, and $E_q'.q$ is the last execution
%%   sequence of this form that precedes $E$ (w.r.t.\ $\treeorder$). If
%%   $q \in \done(E)$ then $E_q' = E$, otherwise $E_q'$
%%   is a strict prefix of~$E$.
%% Thus, $e_q$ is the first event in $w$ which is not in $w_q$.
  %%$w'$, \bjcom{small type error here, how to avoid?}which
  %% Such an event $e_q$ must exist, otherwise  $w_q = w$, which implies $q\in \winits{E_q'}{w_q'.w}$,
  %% which implies that there exists $w''$ s.t. $E_q'.w_q'.w\simeq E_q'.q.w''$.
  %% By I.H. $\explore(E_q'.q)$ has then explored some
  %% execution sequence equivalent to $E.w$, contrary to the assumption.
%%
%% By the preceding construction, we have $\valid{E_q'}{q.w_q''}$

Let $p'$ be the message $\procof{e_q}$ of $e_q$.
We first note that $e_q$ must be a shared-variable access. To see why,
note that if $e_q$ would start the message $p'$, then no event of the message $p'$
can be in $w_q'.w_q$. Moreover, the handler of $p'$ must be free after $E_q'.w_q'.w_q$, and $E_q'.w_q'.w_q$ must contain the event which posts $p'$.
We can simply extend $w_q''$ until it starts message $p'$
and then we have a sequence $w_q'''$ with $w_q'.w_q.e_q\mtprefixafter{E_q'}{q.w_q'''}$, contradicting the
choice of $w_q$.

There are now two cases to consider.
\begin{enumerate}
\item
  $q$ does not start a message after $E_q'$. Then $E_q'$ contains the first part of message $q$ (up until but not including $\nextev{E_q'}{q}$).
  Since $w_q'.w_q\mtprefixafter{E_q'}{q.w_q''}$, it follows that $\nextev{E_q'}{q}$ does not conflict with any event in $w_q'.w_q$, and that
  we can choose $w_q''$ as $w_q'.w_q$. The only reason for $q \not\in \winits{E_q'}{w_q'.w_q.e_q}$ (which implies $w_q'.w_q.e_q \notmtprefixafter{E_q'}{q.w_q''.e_q}$)
  is that $\nextev{E_q'}{q}$ conflicts with $e_q$.
%%  It is also clear that $\nextev{E_q'}{q}$ does not conflict with any event in $w_q''$.
  This implies that the execution $E_q'.q.w_q'.w_q.e_q$ contains a race between $\nextev{E_q'}{q}$ and $e_q$.
  Let $w_q'''$ be $w_q'.w_q.e_q$ and let $E_q'.q.w_q'''.z$ be a maximal extension of $E_q'.q.w_q'''$.
  Then $\nextev{E_q'}{q} \revrace{E_q'.q.w_q'''.z} e_q$.
By the Inductive Hypothesis, $\explore(E_q'.q)$ has then explored some sequence $E_q'.q.z'$ in $\mtclass{E_q'.q.w_q'''.z}$.
When exploring it, the race $\nextev{E_q'}{q}\revmsgrace{E_q'.q.z'}{m} e_q$ between $\nextev{E_q'}{q}$ and $e_q$ will be detected (at \cref{algacsl:race-loop}). Then $\reverserace(E_q'.q.z',\nextev{E_q'}{q},e_q)$ will return maximal executions, one of which must contain $E_q'.w_q'.w_q'.e_q$ as a happens-before prefix.
\item
  $q$ starts a message after $E_q'$.
  Since $e_q$ is a shared-variable access, it can be simply added to  $p'$ in $w_q''$, obtaining $w_q'''$.
  Since $q \not\in \winits{E_q'}{w_q'.w_q.e_q}$, $w_q''$ must contain an event $e$, which is
  not in $w_q'.w_q$, which conflicts with $e_q$.
  This implies that the execution $E_q'.q.w_q'''$ contains a race between $e$ and $e_q$.
  Let $E_q'.q.w_q'''.z$ be a maximal extension of $E_q'.q.w_q'''$.
  Then $e \revrace{E_q'.q.w_q'''.z} e_q$.
By the Inductive Hypothesis, $\explore(E_q'.q)$ has then explored some sequence $E_q'.q.z'$ in $\mtclass{E_q'.q.w_q''.z}$.
When exploring it, the race $e \revmsgrace{E_q'.q.z'}{m} e_q$ between $e$ and $e_q$ will be detected (at \cref{algacsl:race-loop}). Then $\reverserace(E_q'.q.z',e,e_q)$ will return maximal executions, one of which must contain $E_q'.w_q'.w_q'.e_q$ as a happens-before prefix.
\end{enumerate}
%% Let $\done'$ be the value of the mapping $\done$ just before the call to $\explore(E_q'.q)$.
%% \begin{claim}
%% $\neg \redundant{E_q'}{\done'}{q.w_q'''}$
%% \label{claim:nonred}
%% \end{claim}
%% \begin{proof}
%% Proof by contradiction. If $\redundant{E_q'}{\done'}{q.w_q'''}$
%% then there is a message $r$, different from $q$, and a (not necessarily strict) prefix $E_r'$ of
%% $E_q'$ such that $E_r'.r \in \exseqs$ with $E_r'.r \treeorder E_q'.q$, and
%% $r \in \winits{E_q'}{w_r'''.q.w_q''}$, where $w_r'''$ is defined by $E_r'.w_r''' = E_q'$.
%% By definition of $r \in \winits{E_q'}{w_r'''.q.w_q''}$, there is
%% a sequence $w_r''$ such that $w_r'''.q.w_q'' \mtprefixafter{E_r'} r.w_r''$.
%% From $w_q'.w_q\mtprefixafter{E_q'}{q.w_q''}$ we infer $w_r'''.w_q'.w_q \mtprefixafter{E_r'}r.w_r''$.
%% This implies that $w_r$ is at least as long as $w_q$ and that the number of preceding events for $r$ is at most that for $q$.
%% But this contradicts the fact that $q$ was selected in the preceding construction.
%% \end{proof}
%% By construction, $w_q'.w_q \mtprefixafter{E_q'} q.w_q''$, but since 
%% $q \notracefree{E_q'}{w_q'.w_q.e_q}$ we have $w_q'.w_q.e_q \notmtprefixafter{E_q'} q.w_q''$.
%% This can only happen if there is some event in $q.w_q''$ which is not in $w_q'.w_q$ (i.e., in $u_q$) which happens-before $e_q$ in $E_q'.q.w_q''$. Otherwise 
%% $w_q'.w_q.e_q \mtprefixafter{E_q'} q.w_q''$
%% would follow from $w_q'.w_q \mtprefixafter{E_q'} q.w_q''$
%% by the definition of
%% $\mtprefixafter{E_q'}$, thereby violating the construction of $w_q$.
%% Let $e_q'$ be the last event in $u_q$ which happens-before $e_q$, i.e.,
%% $e_q' \happbf{\hb}{E_q'.q.w_q''} e_q$.
%% We claim that this happens-before relation between $e_q'$ and $e_q$ must be a race. For this, we check the three conditions in~\cref{def:races}.
%% \begin{enumerate}[(i)]
%% \item We check that $e_q' \happbf{\cnf}{E_q'.q.w_q''} e_q$ by checking that $e_q' \happbf{\hb}{E_q'.q.w_q''} e_q$ cannot be labeled by anything else than $\cnf$:
%%   \begin{itemize}
%%     \item $e_q' \happbf{\po}{E_q'.q.w_q''} e_q$ is impossible, since $\valid{E_q'.w_q'.w_q}{e_q}$ and $e_q'$ is not in $E_q'.w_q'.w_q$,
%% \item $e_q' \happbf{\pb}{E_q'.q.w_q''} e_q$ is impossible for the same reason,
%%   \end{itemize}
%% \item To see that there is no $e''$ with $e_q' \happbf{\weakall}{E_q'.q.w_q''} e'' \happbf{\hb}{E_q'.q.w_q''} e_q$, we note that such an  $e''$ cannot be in
%%   $w_q'.w_q$ since it can be scheduled after $w_q'.w_q$.
%%   Thus $e''$ is in $u_q$, but this contradicts that $e_q'$ is the last event in $u_q$ which happens-before $e_q$.
%% \item If $e_q'$ and $e_q$ are in different messages $m_q'$ and $m_q$, then we cannot have $\pbof{e_q'} \happbf{\weakall}{E_q'.q.w_q''} \pbof{e_q}$ since $e_q'$ does not occur in $E_q'.w_q'.w_q$ whereas $\valid{E_q'.w_q'.w_q}{e_q}$.
%% \end{enumerate}
%% Let $E_q'.q.w_q''.z$ be a maximal extension of $E_q'.q.w_q''$.
%% %% where the happens-before edge between $e_q'$ and
%% %% $e_q$ is still a race. This can be achieved in the same manner as in Case i).
%% %% \bjcom{Proof of this fact to be supplied. Or: we do not need it by the definition of race. To be checked.}
%% %%
%% %% \bjcom{This paragraph seems to say the same thing as the four bullets above.}
%% %% By the definition of $w_q'.w_q \mtprefixafter{E_q'} q.w'$ it follows that
%% %% $e_q'$ cannot happen-before any event in $w_q'.w_q$. Thus, there is no other event $e''$ in $q.w'$ such that
%% %% $e_q' \happbf{\hb}{} e'' \happbf{\hb}{} e_q$. Furthermore, we annot have $e_q' \happbf{\po}{} e_q$ or $e_q' \happbf{\eop}{} e_q$, since then
%% %% $e_q$ could not appear after $w_q$ in $w$ before $e_q'$ has occurred.
%% %% 
%% The race between $e_q'$ and $e_q$ is either a message-event race or an
%% event-event race. Let us consider the two cases.
%% \begin{itemize}
%%   \item The race is a message-event race $m'\revmsgrace{E_q'.q.w_q''.z}{m} e_q$.
%% By the Inductive Hypothesis, $\explore(E_q'.q)$ has then explored some sequence $E_q'.q.z'$ in $\mtclass{E_q'.q.w_q''.z}$.
%% When exploring it, the race $m'\revmsgrace{E_q'.q.z'}{m} e_q$ between $m'$ and $e_q$ will be detected.
%% When handling the race, the algorithm will process each maximal feasible happens-before prefix $\pexseq$ of $E_q'.q.z'$, which does not include $m'$ nor any
%% messages of a sibling-race of $m'\revmsgrace{E_q'.q.z'}{m} e_q$ such that
%% $\pexseq.e_q$ is a feasible subsequence of $E_q'.q.z'$.
%% Let $\pexseq$ be such a prefix which includes $E_q'.w_q'.w_q'$
%% (such a prefix exists by Lemma XXX), i.e., $E_q'.w_q'.w_q \mtprefix \pexseq$.
%% \item
%%   Analogously for event-event-race.
%% \end{itemize}
%% We note that any event which happens-before $e_q$ in $\pexseq.e_q$ also happens-before $e_q$ in $E_q'.q.z'$, since the removal of $e_q'$ (and its message) cannot add any events that happen-before $e_q$.

%% \bjcom{Unclear what to do with this}
%% As the next step, we prove that reversing the race will not incur any accidental rescheduling in $E_q'.w_q'.w_q$.
%% \begin{claim}
%%   Let $post$ and $post'$ be two post events in $E_q'.w_q'.w_q$, where $post$ occurs before $post'$. Then $post'$ will not be required to happen-before $post$ in the
%%   rescheduling of the wakeup sequence.
%% \label{claim:no-post-reversal}
%% \end{claim}
%% Note that $post$ or $post'$ can be $\nextev{E_q'}{q}$ if $q$ is already in $E_q'.w_q'.w_q$.
%% \begin{proof}
%%   We make a proof by contradiction. Assume that $post$ and $post'$ are post events in $E_q'.w_q'.w_q$, where $post$ occurs before $post'$.
%%   Obviously, $post'$ is not required to happen-before $post$ in $E_q'.q.w_q''.z$. In order for $post'$ to be required to happen-before $post$
%%   in the wakeup sequence,
%%   there must be events $e_p$ and $e_p'$ in $E_q'.q.w_q''.z$ such that
%%   $post \happbf{\pb}{E_q'.q.w_q''.z} e_p$ and  $post' \happbf{\pb}{E_q'.q.w_q''.z} e_p'$ and such that
%%   $e_p'$ is required to happen-before $e_p$ in the wakeup sequence. This can happen in two ways:
%%   \begin{itemize}
%%   \item $e_p' \happbf{}{E_q'.q.w_q''} e_q$ (or $e_p'$ is $e_q$), and $e_q' \happbf{}{E_q'.q.w_q''} e_p$ (or $e_q'$ is $e_p$).
%%     Since $post$ occurs before $post'$ in $E_q'.w_q'.w_q$, also $e_p$ occurs before $e_p'$ in $E_q'.q.w_q''$. This implies that
%%     $e_q'$ strictly occurs before $e_p'$. But, since the reversed race is  between $e_q'$ and $e_q$, this contradicts the construction which says that
%%     the reversed race is between $e_q$ and the closest preceding event that happens before $e_q$, which must be $e_p'$ or occur after $e_p'$.
%%   \item \bjcom{Not clear what to do with this. Remove?} 
%%     $e_p' \happbf{}{E_q'.q.w_q''} e_q$ (or $e_q'$ is $e_q$), and $e_p$ is not in $\notsucc{m'}{E_q'.q.w_q''.z}$
%%   \item $e_p$ and $e_p'$ are again post events, but then the first case is applied recursively.
%%   \end{itemize}
%% \end{proof}
%% \begin{claim}
%%   The event $\nextev{E_q'}{q}$ happens after some later event in the wakeup sequence.
%% \label{claim:q-happens-after}
%% \end{claim}
%% \begin{proof}
%%   Proof by contradiction. Suppose $q$ does not happen after some later event in the wakeup sequence. Then the wakeup sequence has $q$ as a weak initial.
%%   But the wakeup sequence has fewer events that happen-before $e_q$ than the sequence $E_q'.q.w_q''.z$. Since by construction $E_q'.q.w_q''.z$
%%   has en minimum number of events preceding $e_q$, it cannot have $q$ after $E_q'$.
%% \end{proof}
%% \bjcom{End of: Unclear what to do with this}

Let $E_q'.w_q'.w_q'.e_q$ be reordered as $E_q'.v$.
It follows that
$q \not\in\winits{E_q'}{v}$, from the assumptions made when selecting $q$.
Moreover, there cannot be any $E'',w,p$ such that $E''.w = E_q'$ and $p \in \dom{\done(E'')}$ and $p \in \winits{E''}{w.v}$,
also by the assumptions made when selecting $q$.
Thus, the wakeup sequence $v$ will be inserted into the wakeup tree $\wut{E_q'}$ (\cref{algacsl:event-race-end}) by the call $\insertwus{v}{\exseq_q'}{\emptyseq}$.
We claim that this insertion will add a sequence of form $E.p$ with
$p \in \winits{\exseq}{w_q.\procof{e_q}}$. To see why, we consider the
definition of $\insertwus{v}{E_q'}{u}$ in \cref{alg:wakeuptree}.
We first claim that during the insertion, the sequence $u$ will always
satisfy $E_q.u \leq E$ and $v$ will satisfy $u'.w_q.\procof{e_q} \infirstseqs{E_q.u} v$,
where $u.u' = w_q'$.
This is trivially true initially. To see that
it is preserved by each iteration of the loop starting at \cref{algl:wut-foreach-child},
we consider the possible children of form $u.p$. Let $r$ be the message such that
$E_q'.u.r \leq E$ (if still $E_q'.u < E$).
We know that $E_q'.u.r$ is in $\exseqs$ when $\explore(\exseq)$ is returns.
Furthermore, for each branch $u.p$ with $E_q.u'.p \treeorder E_q.u'.r$ we have that
$p \not \in \winits{\exseq.u}{u'.w_q.\procof{e_q}}$ by the Inductive
Hypothesis and the assumption that $\exseq.w$ has not been explored. On the other hand
$r \in \winits{\exseq.u}{u'.w_q.\procof{e_q}}$, implying that either
$u.r$ is already in $\wut{\exseq_q'}$ during the insertion, in which case the
loop will move to the next iteration with invariants preserved, or
$u.r$ is not already in $\wut{\exseq_q'}$ in which case it must be added during the
current insertion and produce a branch $u.v$ such that
$u'.w_q.\procof{e_q} \infirstseqs{E_q.u} v$.
Thus, when the insertion of $v$ has completed, possibly after having been parked, the exploration tree will contain
an execution of form $E.v'$ with $w_q.\procof{e_q} \mtprefixafter{E} v'$, thereby
contradicting the assumption that $w_q$ is the longest extension of $E$ that has been explored.
This concludes the proof of the inductive step,
and~\cref{thm:correctness-general} is proven.
%% \bjcom{Still to be considered is parking}
\qed

\subsection{Proof of \cref{thm:optimality}}

Let us next prove \cref{thm:optimality}. This theorem depends on \EventDPOR being able
to the following property P:
\begin{itemize}
   \item[P:]
whenever the exploration tree $\exseqs$ contains a node of form $\exseq.p$, then the algorithm will not add an execution of form $\exseq.w$ which is contained in
some execution of form $\exseq.p.w'$ for some $w'$, i.e., for which $p \in \winits{\exseq}{w}$.
\end{itemize}
If P is enforced, then~\cref{alg:eventdpor-access} cannot explore two equivalent maximal executions. To see this, let $\exseq$ be the longest common prefix of the two executions. Let the
execution of the two, which is explored first, be of form $\exseq.p.w'$. The other execution
will then be the continuation of a wakeup sequence, which is inserted as a new sequence $w$
from the node $\exseq$ in the exploration tree $\exseqs$, and thereafter extended to
$\exseq.w.v$. But if now $\exseq.p.w' \mtequiv \exseq.w.v$, then
$\exseq.w \mtprefix \exseq.p.w'$, which implies $p \in \winits{\exseq}{w}$, which contradicts
P.

It thus remains to check that property P is enforced. By inspection of
\cref{alg:eventdpor-access}, we see that whenever a new sequence is inserted into $\exseqs$,
which happens before inserting a new wakeup sequence (\cref{algacsl:event-test}),
inside procedure \insertwusname (\cref{alg:wakeuptree}) for wakeup tree insertion, and in
the procedure \insertpendingwuname (\cref{alg:pendingwus}) for inserting parked wakeup sequences.
Furthermore, for non-branching programs the test for $p \in \winits{\exseq}{w}$,
described in \cref{sec:checkwi}, is exact.
This concludes the proof of the theorem.
\qed

