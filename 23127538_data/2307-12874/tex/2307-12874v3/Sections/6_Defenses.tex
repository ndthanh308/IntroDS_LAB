\section{Defenses and Enhancements}
\label{sec:defense}

\subsection{Network}
\label{sec:network-defense}
Bui et al. \cite{bui2019pitfalls} propose various strategies to mitigate the risk of impersonation (\autoref{sec:mitm}). One recommended solution involves employing \acf{rpc} via \acf{tls} and proactively notifying the user about any difficulties encountered while initiating the \ac{rpc} server. This approach enhances the overall security of the wallet by establishing secure communication channels and promptly alerting the user to potential issues during server initialization. A fundamental architectural change is proposed, suggesting a shift from \ac{rpc} to \acf{ipc} for the wallet. By adopting \ac{ipc}, the wallet's communication mechanism is revamped, potentially enhancing security measures and mitigating vulnerabilities associated with \ac{rpc}-based implementations.

Bergman et al. \cite{bergman2021revealing} introduce separate wallet applications that protects users from deanonymization (\autoref{sec:deanonymization}). Darkwallet implements a stealthy address strategy, replacing the conventional hashed address. This involves generating a new public key for each transaction based on a public key that has already been determined. Wasabi Wallet, utilizes Chaumian CJ transactions with masked signatures. By utilizing a reputable third-party tumbler, these transactions ensure that both the sender and recipient identities remain concealed. The Samourai Wallet, conceals the user's actual address by generating a new address for each external transaction and routing payments through multiple fictitious addresses.

Venkatakrishnan et al. \cite{bojja2017dandelion} propose a novel networking policy, aims at mitigating deanonymization risks (\autoref{sec:deanonymization}) within the Bitcoin network through a comprehensive redesign. This policy addresses the threat posed by adversaries utilizing botnets by employing a message mixing technique on an undisclosed graph. Consequently, it becomes highly improbable for an adversary to uncover the identity of a user.

Rai et al. \cite{rai2018wallet} introduce a wallet application with a focus on enhancing user privacy, designed predominantly for Linux systems. This application employs unique receiving addresses for each transaction, greatly enhancing privacy protections. The seed of the wallet is represented by a 12-word mnemonic passphrase, assuring the security of key management. Additionally, this wallet application is open-source, enabling public collaboration to improve its security and privacy features.

\subsection{Application}
\label{sec:application-defense}
Bulut et al. \cite{bulut2020security} propose several measures to enhance the security of wallet applications. They emphasize the importance of encrypting communication channels and storage to mitigate the risks of eavesdropping attacks (\autoref{sec:eavesdropping}) and data leakage (\autoref{sec:storage}). Additionally, they recommend displaying the receivers' addresses to enable visual verification by users. Furthermore, they suggest implementing an integrity check mechanism and incorporating a secure failure mode option to address potential failures.

In a study conducted by Lim et al. \cite{lim2014analysis}, Bitcoin's security vulnerabilities are analysed to provide an overview of potential countermeasures. For increased security, they suggest implementing at least two-factor authentication using either Hardware Security Modules or One-Time Passwords.

Barber et al. \cite{barber2012bitter} concentrate on identifying Bitcoin system vulnerabilities and proposing solutions based on their findings. They identify malware attacks (\autoref{sec:malware}) as a cause of Bitcoin loss and recommend implementing standard threshold cryptography techniques to prevent such attacks. These methods involve arbitrarily fragmenting the private key and storing the fragments in various locations. Super wallets, which utilize threshold cryptography to distribute assets across multiple devices, are a second countermeasure they propose. They present multiple solutions, including backups and the use of pseudo-random keys, to address the inadvertent loss or theft of Bitcoins. Encryption is also identified as an effective safeguard against wallet theft; however, care must be taken to ensure that the decryption password is sufficiently complex.

Hu et al. \cite{hu2020securing} introduce a novel approach for continuous real-time verification of user identity in desktop wallets (see \autoref{sec:desktop-wallets}) using the user's mouse behavior biometrics in conjunction with a \acf{cnn}. This approach involves monitoring the user's mouse behavior during the initial wallet usage and generating a profile using a \ac{cnn} model. Subsequent logins involve measuring and comparing mouse movements to verify the user's identity. Another biometric-based approach, BioWallet for mobiles (see \autoref{sec:mobile-wallets}), employs a two-step authentication process utilizing fingerprint scanning during initialization and subsequent verification for each transaction. Users are given a limited number of attempts to correctly enter their fingerprint and password before the process is aborted.

HA-eWallet was created by Zhu et al. \cite{Zhu2017py}, which employs a novel security mechanism to prevent the loss of assets in the event of server compromise. Three of five private keys are used to sign transactions in HA-eWallet, with two encrypted keys stored on the server in discrete locations and the remaining three keys stored on the user node. This architecture guarantees that a transaction cannot be performed even if the server is compromised and the keys stored on it are obtained which mitigates phishing (\autoref{sec:phishing}) and \ac{dns} attacks (\autoref{sec:dns}).

To improve the security of wallet applications, Takahashi et al. \cite{takahashi2019multiple} developed a multi-layered security analysis approach. This approach combines static analysis of the app's source code (\autoref{sec:faulty-libraries}, \autoref{sec:programming-language}), dynamic analysis through running the app in a sandbox environment, and semantic analysis to assess the app's behavior and distinguish between benign and malicious applications (\autoref{sec:phishing}, \autoref{sec:malware}).

Ulqinaku et al. \cite{ulqinaku2019scan} highlight that clickjacking attacks (\autoref{sec:social-engineering}) can be achieved by enabling Android's touch filter mechanism but this countermeasure does not address scan-and-pay attacks. They propose modifying Android's OS system level by restricting views generated by a background service to a specific style recognizable by users. Alternatively, the use of sensitive views can be implemented, where the area displaying the QR code is marked as sensitive, preventing other applications from creating overlays.

Dai et al. \cite{dai2018sblwt}, Rezaeighaleh et al. \cite{rezaeighaleh2020multilayered}, and Gentilal et al. \cite{gentilal2017trustzone} propose dividing wallet applications into separate sections, albeit with different implementation approaches. Dai et al. utilize the \acf{tee}, specifically the \acf{see} based on the TrustZone scheme. Their approach involves splitting the wallet into an outer layer (\acf{nee}) and an inner layer (\ac{see}) responsible for storing sensitive information and performing key generation. Gentilal et al. modified an existing hardware wallet by moving its storage into the trusted zone, implementing write-cache to mitigate performance overhead. Critical wallet functions were moved to the secure world, protecting the private key from theft. Rezaeighaleh et al. created a three-layered model comprising an offline layer (backup wallet), a protected/superior wallet layer responsible for generating and storing the master seed and keys, and an online layer for limited fund transactions, ensuring only a restricted amount of coins is at risk in case of an attack. They also recommended creating multiple backup wallets as an additional security measure.

Rezaeighaleh et al. \cite{rezaeighaleh2019new} suggest a two-wallet system with multiple fallback wallets. The secondary wallet generates a key pair and exports the public key, which is subsequently compared to the verification code of the primary wallet. If they match, the primary wallet generates a key pair and encrypts the master seed with a transport key. The backup wallet imports the master seed and public key that have been encrypted, decrypting the master seed using the transport key.


\subsection{Authentication}
\label{sec:authentication-denfense}
Brute-forcing passwords requires significant computational power and time to achieve success. Khan et al. \cite{8966739} propose several steps that can further increase the difficulty of password cracking. One approach is to encourage the use of complex passwords, thereby expanding the possibilities and prolonging the cracking time. Additionally, limiting the number of login attempts allowed within a given time frame can be implemented. If exceeded, the account can be locked, and the account owner can be notified of the failed login attempts. Employing a two-layer approach, such as the use of Captchas to prevent automatic login attempts, can provide an additional defense against brute-force attacks. They also suggest utilizing multiple login URLs and modifying the ruleset of Hypertext Access files to enhance security measures.

Bulut et al. \cite{bulut2020security} present a list of recommended security objectives for developers and users. These objectives include implementing a sufficient level of authentication, such as two-factor authentication, to prevent unauthorized access. Furthermore, it is crucial to ensure that passwords are sufficiently complex to withstand brute-force (\autoref{sec:brute-force}) and dictionary attacks (\autoref{sec:dictionary}).

Jasem et al. \cite{jasem2021enhancement} modify the key generation algorithm by expanding the key space and generating new keys for each transaction, thereby decreasing the probability of deanonymization. Entropy is also added to the master seed, which is used to generate the wallet's private keys, for added security. This is accomplished by Jasim et al. \cite{jasim2019enhancing} by incorporating non-fixed ASCII encoded characters, which substantially decrease the success rate of dictionary attacks. The increased entropy of the master seed makes the construction of extensive rainbow tables a time- and resource-consuming endeavor.


\subsection{Smart Contract}
\label{sec:smart-contract-defense}
These wallets face various security vulnerabilities, and implementing effective defense mechanisms is crucial to mitigate risks. One common vulnerability is re-entrancy attacks (\autoref{sec:re-entrancy}), which can be prevented using the \quotes{Check-Effect-Interaction pattern} to ensure all internal state changes are resolved before allowing interaction with other contracts. Mutex locks can be employed to prevent cross-function re-entrancy attacks, where the contract's state is locked and can only be modified by the lock owner. Additionally, OpenZeppelin's Re-entrancy guard provides a mutex implementation for protection.

Singh et al. \cite{singh2020blockchain} address integer overflow and underflow issues (\autoref{sec:integer-overflow-underflow}) by carefully implementing arithmetic operations, comparing operators and operands before performing operations. The use of assert(), require() functions, and the SafeMath.sol library helps ensure safe arithmetic calculations. Mishandled exceptions can be mitigated by employing exception handling operators, thoroughly checking return values of functions, and throwing appropriate exceptions to handle exceptional cases.

To address timestamp dependency vulnerabilities (\autoref{sec:timestamp-dependency}), Bartoletti et al. \cite{bartoletti2017empirical} recommend using the block number instead of the block timestamp, which prevents manipulation of the timestamp by malicious miners. Employing Ethereum-based functions and implementing guard conditions can enforce transaction order and defend against Transaction Ordering Dependency attacks. Pre-commit schemes can be utilized to further enhance transaction ordering security.

Furthermore, it is crucial to eliminate destroyable contract vulnerabilities (\autoref{sec:destroyable-contract}) by exercising caution with the usage of selfdestruct() functionality. Selfdestruct should only be used when necessary and in a multi-signature scheme environment where multiple parties approve its execution. Implementing robust access control mechanisms ensures that only authorized users can access the smart contract. Careful naming of functions is essential to avoid unintended invocation of the constructor, which could lead to the re-initialization of the contract by unauthorized entities (\autoref{sec:function-visibility}, \autoref{sec:no-restricted-write}).

To optimize the execution cost of smart contracts, detecting and replacing gas costly patterns (\autoref{sec:gas-costly-pattern}) is essential. Tools like GASPER, developed by Chen et al. \cite{chen2017under}, can assist in identifying gas inefficient patterns such as dead code, opaque predicates, and expensive loop operations like SLOAD, SSTORE, and BALANCE. By replacing these patterns with more gas-efficient alternatives, the overall execution cost of the smart contract can be optimized.


\subsection{Key Recovery}
\label{sec:key-recovery-defense}
This approach is crucial in preventing the permanent loss of access credentials to wallets and the subsequent inability to use cryptocurrency coins. Rakdej et al. \cite{Rakdej2019ri} propose an extension to existing wallets that incorporates a retire option, allowing the transfer of \acf{uto} to a backup address. By setting a maximum time range between logins, exceeding which triggers the transfer, users can ensure their assets are safeguarded. The backup address can belong to a trusted individual, such as a friend or family member. Soltani et al. \cite{Soltani2019zb} introduce a secure private key recovery protocol based on Hyperledger Indy, digital wallets, and Key Escrow Providers. Multiple secret keys generated by the wallet are signed using temporary keys and sent to the providers. Upon establishing a secure communication channel, the wallet retrieves and verifies the signed secret keys to reconstruct the private key. Liu et al. \cite{Liu2017AnSecurity} propose a key management system for Bitcoin wallets featuring easy key recovery. Private keys are generated using a random seed and an easy-to-remember passphrase, with only the seed list stored locally. In case of passphrase loss, key recovery is possible through preset personal questions.

\acf{derec} presents a solution to the pervasive issue of lost coins or forgotten private keys in the cryptocurrency market. Its primary objective is to enable the recovery of misplaced or stolen cryptocurrencies, providing a safety net in an environment that many still perceive as cumbersome and risky to navigate. \ac{derec} addresses the challenges associated with accessing crypto-wallets by implementing a unique mechanism that enhances user confidence and mitigates the potential loss of valuable digital assets \cite{CGPB}. These key recovery methods provide essential mechanisms to mitigate the risk of permanent loss or forgetfulness of access credentials.
