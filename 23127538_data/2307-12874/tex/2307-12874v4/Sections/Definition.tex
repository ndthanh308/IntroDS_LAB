\section{Generalised Wallet Mechanism}
\label{sec:wallet_mechanism}

\begin{definition}[Cryptocurrency Wallet]
 A wallet is a system that typically generates a private key (\teal{$sk$}) and securely stores it in an encrypted form, enabling an authenticated owner to sign transactions that are broadcast to the blockchain.
  \end{definition}

% \begin{algorithm}
%     \label{algo:cryptocurrency-wallet}
%     \SetAlgoLined
%     \KwIn{\teal{$rdm\_seed$}: \orange{bin}, \teal{$pw$}: \orange{str}}
%     \teal{$sk$} = \olive{genPrivateKey}(\teal{$rdm\_seed$})\\
%     \teal{$pk$} = \olive{genPublicKey}({\teal{$sk$})\\
%     \teal{$enc\_sk$} = \olive{encrypt}(\teal{$sk$}, \teal{$pw$})\\
%     \teal{$address$} = \hyperref[Hashing-Table-1]{\olive{hash}}(\teal{$pk$})\\
%     \teal{$nonce$} = \olive{0}}
%     \caption{Wallet initalisation}
% \end{algorithm}



% \begin{algorithm}[H] % Specify options here instead of in the package
%     \label{algo:cryptocurrency-wallet}
%     \SetAlgoNlRelativeSize{-1} % Adjust line number size if needed
%     \KwIn{\textcolor{teal}{$rdm\_seed$}: \textcolor{orange}{bin}, \textcolor{teal}{$pw$}: \textcolor{orange}{str}}
%     \textcolor{teal}{$sk$} = \textcolor{olive}{genPrivateKey}(\textcolor{teal}{$rdm\_seed$})\\
%     \textcolor{teal}{$pk$} = \textcolor{olive}{genPublicKey}(\textcolor{teal}{$sk$})\\
%     \textcolor{teal}{$enc\_sk$} = \textcolor{olive}{encrypt}(\textcolor{teal}{$sk$}, \textcolor{teal}{$pw$})\\
%     \textcolor{teal}{$address$} = \hyperref[Hashing-Table-1]{\textcolor{olive}{hash}}(\textcolor{teal}{$pk$})\\
%     \textcolor{teal}{$nonce$} = \textcolor{olive}{0}
%     \caption{Wallet initialization}
% \end{algorithm}


\begin{algorithm}
    \caption{Wallet initialisation}
    \label{algo:cryptocurrency-wallet}
    \begin{algorithmic}[1]  % This enables line numbering
        \State \textbf{Input:} \textcolor{teal}{$rdm\_seed$}: \textcolor{orange}{bin}, \textcolor{teal}{$pw$}: \textcolor{orange}{str}
        \State \textcolor{teal}{$sk$} = \textcolor{olive}{genPrivateKey}(\textcolor{teal}{$rdm\_seed$})
        \State \textcolor{teal}{$pk$} = \textcolor{olive}{genPublicKey}(\textcolor{teal}{$sk$})
        \State \textcolor{teal}{$enc\_sk$} = \textcolor{olive}{encrypt}(\textcolor{teal}{$sk$}, \textcolor{teal}{$pw$})
        \State \textcolor{teal}{$address$} = \textcolor{olive}{hash}(\textcolor{teal}{$pk$})
        \State \textcolor{teal}{$nonce$} = \textcolor{olive}{0}
    \end{algorithmic}
\end{algorithm}



\begin{definition}[Transaction]
\label{sec:def:tnx}
A transaction (\teal{$txn$}) is a structured message created by a wallet that enables state change executions on the blockchain. These state changes include token transfer transactions and smart contract transactions. 
\end{definition}

% \subsection{Wallet Mechanism}
% \label{sec:wallet_mechanism}

% In this section, we describe the major operations within the wallet mechanism including key generation, key storage and transaction management as shown in \autoref{fig:wallet-mechanism}.

\subsection{Key Generation}
\label{sec:key_generation}

\autoref{fig:wallet-mechanism} shows the operations within the wallet mechanisms. The process typically begins with \teal{$sk$} generation using a random seed (\teal{$rdm\_seed$}). Subsequently, the public key (\teal{$pk$}) is derived from \teal{$sk$} using the asymmetric key algorithm specific to the blockchain in use. For instance, Solana utilises the ed25519 curve for key generation, while Ethereum and Bitcoin use the secp256k1 curve. Once the key pair is generated and \teal{$pk$} is obtained, the wallet generates the address (\teal{$address$}) using a hash algorithm on \teal{$pk$}. \teal{$address$} serves as a public identifier for the wallet which shows user transactions on the respective blockchain and is used to retrieve state changes including nonce (\teal{$nonce$}) via a \acf{rpc} to the blockchain. \teal{$nonce$}, initially set to zero, acts as a transaction index, ensuring the sequential ordering of transactions from the wallet.

% was in text before
% For example, Ethereum and Bitcoin use the Keccak-256 and Hash-160 algorithms \cite{jiasong2023digital}, respectively, to generate \teal{$address$} from \teal{$pk$}.

% Figure environment removed

\subsection{Key Storage}
\label{sec:key-storage}
\teal{$sk$} is stored and encrypted using a \acf{kek} which we simply refer to as password (\teal{$pw$}) as shown in \hyperref[algo:cryptocurrency-wallet]{Algorithm 1} following its generation. This encrypted private key (\teal{$enc\_sk$}) remains secure during storage, with \teal{$pw$} serving as the means to decrypt and utilise \teal{$sk$} for transactions utilising symmetric key algorithms. Secure \teal{$sk$} storage is governed by the interplay of several factors: the key management infrastructure (see \autoref{sec:infrastructure}), representing the medium where \teal{$sk$} resides, the controlling entity (see \autoref{sec:design-cust}), which denotes the entity responsible for managing and safeguarding \teal{$sk$} and several other design factors described in \autoref{sec:wallet-taxonomy}. 

% \begin{algorithm}
%     \label{algo:transaction-signing}
%     \SetAlgoLined
%     \KwIn{\teal{$nonce$}: \orange{int}, \teal{$state\_trans\_info$}: \orange{str}, \teal{$enc\_sk$}: \orange{bytes}, \teal{$pwd$}: \orange{str}}
%     \KwOut{\teal{$\sigma$}: \orange{bytes}}

%     \teal{$nonce$} += 1\\
%     % \gray{// Create the transaction object} \\
%     % \teal{$txn$} = \{\quotes{nonce}: \teal{$nonce$},
%     % \quotes{data}: \teal{$txn\_instruction$}, \quotes{txn fee}: \teal{$txn\_fee$}\}\\
%     % \gray{// Compute the hash of the transaction data} \\
%     \teal{$txn$} = \olive{createTxn}(\teal{$state\_trans\_info$}, \teal{$nonce$})\\
%     \teal{$txn\_hash$} = \olive{hash}(\teal{$txn$})\\
%     % \gray{// Sign the transaction hash with private key}
%     \teal{$sk$} = \olive{decrypt}(\teal{$enc\_sk$}, \teal{$pwd$})\\
%     \teal{$\sigma$} = \olive{sign}(\teal{$txn\_hash$}, \teal{$sk$})\\

%     \KwRet{\teal{$\sigma$}}\\

%     \caption{Transaction generation}
% \end{algorithm}




\begin{algorithm}
    \caption{Transaction Generation}
    \label{algo:transaction-signing}
    \begin{algorithmic}[1]  % This enables line numbering
        \State \textbf{Input:} \textcolor{teal}{$nonce$}: \textcolor{orange}{int}, \textcolor{teal}{$state\_trans\_info$}: \textcolor{orange}{str}, \textcolor{teal}{$enc\_sk$}: \textcolor{orange}{bytes}, \textcolor{teal}{$pwd$}: \textcolor{orange}{str}
        \State \textbf{Output:} \textcolor{teal}{$\sigma$}: \textcolor{orange}{bytes}

        \State \textcolor{teal}{$nonce$} += 1
        % \Comment{\textcolor{gray}{// Create the transaction object}}
        \State \textcolor{teal}{$txn$} = \textcolor{olive}{createTxn}(\textcolor{teal}{$state\_trans\_info$}, \textcolor{teal}{$nonce$})
        \State \textcolor{teal}{$txn\_hash$} = \textcolor{olive}{hash}(\textcolor{teal}{$txn$})
        % \Comment{\textcolor{gray}{// Sign the transaction hash with private key}}
        \State \textcolor{teal}{$sk$} = \textcolor{olive}{decrypt}(\textcolor{teal}{$enc\_sk$}, \textcolor{teal}{$pwd$})
        \State \textcolor{teal}{$\sigma$} = \textcolor{olive}{sign}(\textcolor{teal}{$txn\_hash$}, \textcolor{teal}{$sk$})

        \State \textbf{return:} \textcolor{teal}{$\sigma$}  % This adds a numbered return line
    \end{algorithmic}
\end{algorithm}


\subsection{Transaction Management}
\label{sec:transaction_management}

\subsubsection{Transaction Generation}
\label{sec:transaction_signing}
This begins with transaction message creation (\teal{$txn$}) by inputting the state transition information (\teal{$\it state\_trans\_info$}). The message (\teal{$txn$}) is then hashed to produce the transaction hash (\teal{$txn\_hash$}). Following transaction creation, the sender proceeds to sign the transaction and provides \teal{$pw$} to decrypt the private key. The signing algorithm takes the decrypted private key (\teal{$sk$}) and \teal{$txn\_hash$} as inputs to generate the signature (\teal{$\sigma$}), which authorises the transaction (see \hyperref[algo:transaction-signing]{Algorithm 2}).

% During this interaction, the sender provides details of the transaction message including the \teal{$recipient\_addr$}, which could be the token \teal{$recipient\_addr$} or the \teal{$contract\_addr$} included in the specific \teal{$txn\_instruction$}. The \teal{$txn\_instruction$} generated by the user depends on the transaction type. For instance, a token transfer instruction specifies the number and amount of tokens to be sent while a smart contract method call specifies the function to be executed along with any necessary parameters that dictate the operation's details.

% Upon initiation, the \teal{$txn\_fee$} is calculated to determine the total cost, including any transaction amount, if applicable. The transaction can proceed only if the \teal{$sender\_balance$} exceeds this total cost. This ensures that the sender has adequate funds to cover both any potential transfer amounts and the necessary txn fee, confirming resource availability for execution.

% , such as the number of tokens (\teal{$Q$}) to be transferred out to the recipient's address (\teal{$\alpha_R$}), the nonce (\teal{$N$}), and smart contract data (\teal{$D$}) required for accessing smart contract methods.

% The signature (\teal{$\sigma$}) is added to the transaction data to create a signed transaction object (\teal{$\tau_{sign}$}), which includes both the transaction data (\teal{$\tau$}) and the signature (\teal{$sign$}). The signature authorises the user-defined instruction.

\subsubsection{Transaction Broadcast}
\label{sec:transaction_broadcast}
\teal{$\sigma$} is verified using the public key to assert its validity as shown in \hyperref[algo:transaction-broadcast]{Algorithm 3}. If \teal{$\sigma$} is invalid, the transaction is rejected and not processed further. Conversely, if \teal{$\sigma$} is valid, the transaction is broadcast to the blockchain. 


\begin{algorithm}
    \caption{Transaction broadcast}
    \label{algo:transaction-broadcast}
    \begin{algorithmic}[1]  % This enables line numbering
        \State \textbf{Input:} \textcolor{teal}{$\sigma$}: \textcolor{orange}{str}, \textcolor{teal}{$pk$}: \textcolor{orange}{hex}

        % \Comment{\textcolor{gray}{// Broadcast the transaction to network for verification}}
        \State \textcolor{teal}{$verified$} = \textcolor{olive}{verify}(\textcolor{teal}{$\sigma$}, \textcolor{teal}{$sender\textunderscore pub\textunderscore key$})
        \State \textcolor{olive}{assert}(\textcolor{teal}{$verified$}, \enquote{transaction failed})
        \State \textcolor{olive}{broadcast}(\textcolor{teal}{$\sigma$}, \textcolor{teal}{$sender\textunderscore pub\textunderscore key$})

    \end{algorithmic}
\end{algorithm}

