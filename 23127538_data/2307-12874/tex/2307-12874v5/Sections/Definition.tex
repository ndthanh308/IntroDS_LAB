\section{Generalised Wallet Mechanism}
\label{sec:wallet_mechanism}


Cryptocurrency wallets facilitate state transitions by securely managing cryptographic keys and authorising transaction execution on the blockchain. To analyse wallet design and security, we first define a wallet. This definition underpins our mechanism, taxonomy, threat model, attack taxonomy, and security measures.

\begin{definition}[Cryptocurrency Wallet]
A wallet is a system that typically generates a private key, also known as the secret key (\textcolor{teal}{\textit{sk}}), and securely stores it in an encrypted form (\textcolor{teal}{\textit{enc\_sk}}), enabling an authenticated owner to sign transactions that are broadcast to the blockchain.
\end{definition}

\subsection{Key Generation}
\label{sec:key_generation}

The wallet initialisation process, detailed in \hyperref[algo:cryptocurrency-wallet]{Algorithm 1}, specifies private key generation, public key generation, public address derivation and private key encryption for secure storage. As shown in \autoref{fig:wallet-mechanism}, the internal flow of the wallet begins with private key (\teal{\textit{$sk$}}) generation from a random seed (\teal{\textit{$rdm\_seed$}}). The corresponding public key (\textcolor{teal}{\textit{pk}}) is then derived from \textcolor{teal}{\textit{sk}} using the signature scheme and curve required by the target chain. Bitcoin, Ethereum, and Avalanche\footnote{Avalanche's C-Chain is \acf{evm} compatible and therefore inherits \textit{secp256k1}. Hedera introduced optional \textit{secp256k1} accounts in 2023 for \acs{evm} compatibility; however, \textit{ed25519} remains the default.} all rely on the \textit{\acf{ecdsa}} over the \textit{secp256k1} curve by default \cite{sec2}. Solana and Hedera default to the \textit{\acf{eddsa}} curve \textit{ed25519} \cite{rfc8032}, whereas the XRP Ledger supports both \textit{\acs{ecdsa}}/\textit{secp256k1} and \textit{\acs{eddsa}}/\textit{ed25519}.


Once the key pair is generated and \textcolor{teal}{\textit{pk}} is obtained, the wallet hashes \textcolor{teal}{\textit{pk}} to produce the address (\textcolor{teal}{\textit{addr}}). Users share this address to receive funds. In account-based blockchains, the wallet queries \textcolor{teal}{\textit{addr}} via an \acf{rpc} to fetch the current nonce (\textcolor{teal}{\textit{nonce}}). The nonce is initialised to 0 and preserves the sequential order of outgoing transactions.


Beyond curve selection, contemporary wallet software adheres to a concise suite of public standards. \acf{bip} 32 \cite{bip32} and \acf{slip} 10 \cite{slip10} define \acf{hd} key derivation for \textit{secp256k1} and \textit{ed25519} curves, respectively. 

Mnemonic phrases, as defined in \acs{bip}-39 \cite{bip39_}, are the widely adopted standard for representing seeds in a human-readable form. \acs{slip}-39 \cite{slip39} extends this by applying Shamirâ€™s Secret Sharing to mnemonic phrases, enabling distributed or threshold-based recovery of wallet seeds. These mechanisms enable secure \textcolor{teal}{\textit{sk}} recovery in case of device loss or failure (see \autoref{sec:design-rec}). At the account-level, wallet use standard derivation paths such as \acs{bip}-44 \cite{bip44}, \acs{bip}-49 \cite{bip49} and \acs{bip}-84 \cite{bip84} to deterministically derive multiple accounts and address types from a single seed.

% [!b]
\begin{algorithm}
\caption{Wallet initialisation}
\label{algo:cryptocurrency-wallet}
\begin{algorithmic}[1]
    \State \textbf{Input:} \textcolor{teal}{\textit{rdm\_seed}}: \olive{bin}, \textcolor{teal}{\textit{pw}}: \olive{str}
    \State \textcolor{teal}{\textit{sk}} = \orange{{\textit{keyGen}}}(\textcolor{teal}{\textit{rdm\_seed}})
    \State \textcolor{teal}{\textit{pk}} = \orange{\textit{publicKeyGen}}(\textcolor{teal}{\textit{sk}})
    \State \textcolor{teal}{\textit{enc\_sk}} = \orange{\textit{encrypt}}(\textcolor{teal}{\textit{sk}}, \textcolor{teal}{\textit{pw}})
    \State \textcolor{teal}{\textit{addr}} = {\orange{\textit{hash}}}(\textcolor{teal}{\textit{pk}})
    \State \textcolor{teal}{\textit{nonce}} = 0
\end{algorithmic}
\end{algorithm}



\subsection{Key Storage}
\label{sec:key-storage}

Following its generation, \textcolor{teal}{\textit{sk}} is stored and encrypted using a \acf{kek} that we refer to simply as the password (\textcolor{teal}{\textit{pw}}), as shown in \hyperref[algo:cryptocurrency-wallet]{Algorithm 1}. In practice, \textcolor{teal}{\textit{pw}} is an abstract input that may be a traditional text password, a numeric PIN, a device-derived biometric secret, or a composite value obtained through multi-factor authentication. The ensuing \acf{kdf} output serves as the \acs{kek}. \acs{kek}s are typically derived with a \acf{pbkdf}, such as \textit{PBKDF2-\acs{hmac}-\acs{sha}-256} \cite{rfc8018}, \textit{scrypt} \cite{rfc7914}, or the memory-hard \textit{Argon2id} \cite{rfc9106}. The resulting \acs{kek} then protects \textcolor{teal}{\textit{sk}} under an \acf{aead} cipher such as \textit{\acs{aes}-256-\acs{gcm}}\,\cite{fips197} or \textit{XChaCha20\allowbreak -Poly1305} \cite{rfc8439}. The encrypted private key (\textcolor{teal}{\textit{enc\_sk}}) remains secure, with \textcolor{teal}{\textit{pw}} required for both decryption and transaction signing. Secure \textcolor{teal}{\textit{sk}} storage is governed by the interplay of several factors described in \autoref{sec:wallet-taxonomy}.




\subsection{Transaction Management}
\label{sec:transaction_management}

\begin{definition}[Transaction]
\label{sec:def-trans}
A transaction (\textcolor{teal}{\textit{txn}}) is a structured message created by a wallet that enables state change executions on the blockchain. These state changes include token transfers and smart contract interactions.
\end{definition}

% Figure environment removed

\subsubsection{Transaction Generation}
\label{sec:transaction_signing}

Transaction generation begins with creating the transaction message (\textcolor{teal}{\textit{txn}}) by inputting the state transition information (\textcolor{teal}{\textit{state\_trans\_info}}). The message (\textcolor{teal}{\textit{txn}}) is then hashed to produce the transaction hash (\textcolor{teal}{\textit{txn\_hash}}). Following transaction creation, the sender signs the transaction and provides \textcolor{teal}{\textit{pw}} to decrypt the private key (\textcolor{teal}{\textit{sk}}). The signing algorithm takes the decrypted private key (\textcolor{teal}{\textit{sk}}) and \textcolor{teal}{\textit{txn\_hash}} as inputs to generate the signature (\teal{$\sigma$}), which authorises the transaction (see \hyperref[algo:transaction-signing]{Algorithm 2}).

\subsubsection{Transaction Broadcast}
\label{sec:transaction_broadcast}


The signature (\teal{$\sigma$}) is verified using the sender's public key (\textcolor{teal}{\textit{pk}}) to assert its validity, as shown in \hyperref[algo:transaction-broadcast]{Algorithm 3}. If \teal{$\sigma$} is invalid, the transaction is rejected and not processed further. Conversely, if \teal{$\sigma$} is valid, the transaction is broadcast to the blockchain. 

\begin{algorithm}[!b]
    \caption{Transaction generation}
    \label{algo:transaction-signing}
    \begin{algorithmic}[1]  % This enables line numbering
        \State \textbf{Input:} \textcolor{teal}{\textit{nonce}}: \textcolor{olive}{int}, \textcolor{teal}{\textit{state\_trans\_info}} : \textcolor{olive}{str}, \textcolor{teal}{\textit{enc\_sk}}: \textcolor{olive}{bytes}, \textcolor{teal}{\textit{pw}}: \textcolor{olive}{str}
        \State \textbf{Output:} \textcolor{teal}{$\sigma$}: \textcolor{olive}{bytes}

        \State \textcolor{teal}{\textit{nonce}} += 1
        % \Comment{\textcolor{gray}{// Create the transaction object}}
        \State \textcolor{teal}{\textit{txn}} = \textcolor{orange}{\textit{txnInit}}(\textcolor{teal}{\textit{state\_trans\_info}}, \textcolor{teal}{\textit{nonce}})
        \State \textcolor{teal}{\textit{txn\_hash}} = \textcolor{orange}{\textit{hash}}(\textcolor{teal}{\textit{txn}})
        % \Comment{\textcolor{gray}{// Sign the transaction hash with private key}}
        \State \textcolor{teal}{\textit{sk}} = \textcolor{orange}{\textit{decrypt}}(\textcolor{teal}{\textit{enc\_sk}}, \textcolor{teal}{\textit{pw}})
        \State \textcolor{teal}{$\sigma$} = \textcolor{orange}{\textit{txnSign}}(\textcolor{teal}{\textit{txn\_hash}}, \textcolor{teal}{\textit{sk}})

        \State \textbf{return:} \textcolor{teal}{$\sigma$}  % This adds a numbered return line
    \end{algorithmic}
\end{algorithm}
