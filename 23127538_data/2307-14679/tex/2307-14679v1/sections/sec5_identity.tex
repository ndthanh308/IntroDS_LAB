\section{Sybil-Resistance Identity Management}
\label{sec: identity}

In this section, we introduce another vital part of \sysname, namely the identity system and its security settings. We will build a robust and privacy-preserving identity mechanism in terms of Sybil-resistance and accountability.

\subsection{Credential-Based Sybil-Resistance}
\label{subsec: identity-cred-sybil}

Sybil attack is one of the most critical problems common to all identity systems, especially in the Web3 space where community bootstrapping and convening are mainly based on token distribution \cite{borge2017proof}. \sysname wants to solve this problem from a credentials perspective, as people with more fulfillment records are typically considered more credible than those with empty ones. The verifier could require the presenter to provide relevant credentials if Sybil attacks are of concern. The airdropper may even give different weights to different credentials to flexibly adjust the airdropping strategy \cite{weyl2022decentralized}.

However, since selective disclosure is allowed in \sysname, verifiers cannot prevent presenters from repeatedly presenting the same credential. For this reason, \sysname forces the presenter to prove that it has not yet submitted a particular credential in a campaign. Specifically, when a holder $\mathcal{H}$ wants to present a credential $\mathsf{cred}$ to a verifier $\mathcal{V}$ at campaign $\varepsilon$, it first provides the set of proofs in Section \ref{sec: credential} for claims in $\mathsf{cred}$. In addition, $\mathcal{H}$ computes a nullifier $n_\mathsf{s} \leftarrow H_1(\mathsf{cred}, \mathsf{sk}_\mathcal{H}, \mathsf{id}_\varepsilon)$ where $\mathsf{id}_\varepsilon$ is the identifier of campaign $\varepsilon$ generated by $\mathcal{V}$. $\mathcal{H}$ then proves that \cirn{182} the issuer identifier $\mathsf{id}_\mathcal{I}$ of $\mathsf{cred}$ is equal to $\mathsf{id}_\mathcal{V}$, and \cirn{183} $n_\varepsilon$ is correctly calculated. The above relations can be expressed as follows:
	\begin{equation}
	\label{eq: relation-id-cred-campaign}
		\mathsf{id}_\mathcal{I} = \mathsf{id}_\mathcal{V}
		\;\;\land\;\;
		n_\mathsf{s} = H_1(\mathsf{cred}, \mathsf{sk}_\mathcal{H}, \mathsf{id}_\varepsilon).
	\end{equation}
	
$\mathcal{H}$ generates a non-interactive proof for Relation \ref{eq: relation-id-cred-campaign} by:
	\begin{equation*}
		\pi_\mathsf{s}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\big(
				\varsigma,
				(\mathsf{id}_\mathcal{V}, n_\mathsf{s}, \mathsf{id}_\varepsilon), 
				(\mathsf{cred}, \mathsf{id}_\mathcal{I}, \mathsf{sk}_\mathcal{H})
			\big),
	\end{equation*}
	and sends $\pi_\mathsf{s}$ to $\mathcal{V}$ along with $n_\mathsf{s}$. $\mathcal{V}$ puts $\mathsf{id}_\varepsilon$ and $\mathsf{id}_\mathcal{V}$ together with $n_\mathsf{s}$ into the verification algorithm:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\big(
			\varsigma,
			(\mathsf{id}_\mathcal{V}, n_\mathsf{s}, \mathsf{id}_\varepsilon),
			\pi_\mathsf{s}
		\big)
		\overn{?}=1,
	\end{equation*}
	and accepts the presentation if verification passes. Finally, $\mathcal{V}$ records $n_\mathsf{s}$ under this campaign and rejects any further presentation with the same nullifier.

\spar{Review}
$\mathcal{H}$ used a proof $\pi_\mathsf{s}$ to associate the nullifier $n_\mathsf{s}$ to $\mathsf{cred}$ and reveal it when presenting $\mathsf{cred}$. Since $\mathcal{H}$ commits to $\mathsf{cred}$ in $\pi_\mathsf{c}$ for Relation \ref{eq: relation-basic} and binds $\mathsf{sk}_\mathcal{H}$ in $\pi_\mathsf{id}$ for Relation \ref{eq: relation-holder-identity} and \ref{eq: relation-vdr}, it follows that in a particular campaign $\varepsilon$, the value of $n_\varepsilon$ is always unique. Nevertheless, $\mathcal{H}$ does not reveal exactly which $\mathsf{cred}$ credential is associated with $n_\mathsf{s}$. Thus $\mathcal{V}$ cannot locate the identity of $\mathcal{H}$ by retrieving the generation records of $\mathsf{cred}$.

\subsection{Identifier Association}
\label{subsec: identity-id-association}

It is ubiquitous for users to register multiple identifiers as pseudonyms. To preserve identity privacy, a user may strategically use different pseudonyms in different campaigns and thus accumulate credentials separately \cite{maram2021candid}. \sysname forces users to present multiple credentials in Sybil-sensitive campaigns, which are likely to be scattered under various pseudonyms. A critical insight is that identifier correlation occurs at the moment of presenting these credentials, and this information can be recorded and help other verifiers later on for Sybil-resistance.

\sysname provides a mechanism called \textit{identifier association} that requires users to provide a \textit{proof of association} when submitting credentials under multiple pseudonyms to ensure that all identifiers have been registered and associated in the registry. For this reason, the VDR in \sysname is now required to manage public key registration and record identifier associations. When a user $\mathcal{H}$ wants to interact with any verifier requesting proof of association, it must perform a two-phase protocol with the VDR to associate the identifiers that may be involved, as shown in Figure \ref{fig: identifier-association}.

\spar{Phase 1: identifier registration}
$\mathcal{H}$ first needs to register each of its identifiers separately in the VDR. As described in Section \ref{subsec: cred-id-correlation}, for an identifier $\mathsf{id}_\mathcal{H}$, there exists a node with the content $(\mathsf{id}_\mathcal{H},\mathsf{pk}_\mathcal{H})$ in the VDR. A Merkle proof $\rho_\mathsf{id}$ can be used to show that $v_\mathsf{id}=H_1(\mathsf{id}_\mathcal{H},\mathsf{pk}_\mathcal{H})$ is contained in a Merkle tree with root $r_\mathsf{id}$ (cf. Appendix \ref{subapp: misc-merkle}). Thus, $\mathcal{H}$ proves to VDR that \cirn{182} $v_\mathsf{id}$ is contained in a Merkle tree rooted at $r_\mathsf{id}$, and \cirn{183} it possesses the private key $\mathsf{sk}_\mathcal{H}$ corresponding to $\mathsf{pk}_\mathcal{H}$, i.e.,
	\begin{equation}
	\label{eq: relation-id-register}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{id}, v_\mathsf{id}, \rho_\mathsf{id})=1\\
			& \land\quad v_\mathsf{id} = H_1(\mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H})\\
			& \land\quad h_\mathsf{id} = H_1(\mathsf{id}_\mathcal{H}, \mathsf{sk}_\mathcal{H})\\
			& \land\quad \mathsf{pk}_\mathcal{H} = \mathsf{PubKeyGen}(\mathsf{sk}_\mathcal{H}).
		\end{aligned}
	\end{equation}

%	\begin{equation}
%	\label{eq: relation-vdr}
%		\begin{aligned}
%			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{id}, v_\mathsf{id}, \rho_\mathsf{id}) = 1\\
%			& \land\quad \mathsf{\Gamma}.\mathsf{Open}(\mathsf{id}_\mathcal{H}, c_\mathsf{id}, u_\mathsf{id})=1\\
%			& \land\quad v_\mathsf{id} = H_1(\mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}).
%		\end{aligned}
%	\end{equation}
	
$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-id-register} by:
	\begin{equation*}
		\pi_\mathsf{reg}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\big(
				\varsigma,
				(r_\mathsf{id}, h_\mathsf{id}),
				(v_\mathsf{id}, \rho_\mathsf{id}, \mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}, \mathsf{sk}_\mathcal{H})
			\big),
	\end{equation*}
	and sends it to the VDR along with $h_\mathsf{id}$. The VDR confirms that $r_\mathsf{id}$ is one of its recent state roots and then verifies $\pi_\mathsf{reg}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\big(
			\varsigma,
			(r_\mathsf{id}, h_\mathsf{id}),
			\pi_\mathsf{reg}
		\big)
		\overn{?}=1.
	\end{equation*}
	If verification passes, the VDR adds $h_\mathsf{id}$ into another Merkle tree, indicating that the identifier $\mathsf{id}_\mathcal{H}$ has been registered and is ready for association. Notice that $\mathcal{H}$ does not need to expose $\mathsf{id}_\mathcal{H}$ to the VDR, and the public $h_\mathsf{id}$ cannot be used to locate $\mathsf{id}_\mathcal{H}$ since it is masked with the private key $\mathsf{sk}_\mathcal{H}$.

\spar{Phase 2: identifier association}
In this phase, $\mathcal{H}$ formally associates its registered identifiers. To this end, it \cirn{182} retrieves all of the $h_\mathsf{id}^{(i)}$ published in Phase 1 and obtains Merkle proofs $\rho_\mathsf{reg}^{(i)}$ indicating that $h_\mathsf{id}^{(i)}$ is included in a Merkle tree with root $r_\mathsf{reg}$, \cirn{183} computes a nullifier $n_\mathsf{reg}^{(i)} \leftarrow H_1(\mathsf{id}_\mathcal{H}^{(i)}, \mathsf{sk}_\mathcal{H}^{(i)}, 1)$ for each $h_\mathsf{id}^{(i)}$, and \cirn{184} generates an \textit{associated identifier} $\mathsf{id}_\mathsf{a} \leftarrow H_1(\mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)})$ for the registered $\mathsf{id}_\mathcal{H}^{(i)}$. $\mathcal{H}$ proves to the VDR of the above relations, i.e.,
	\begin{equation}
	\label{eq: relation-id-association}
		\begin{aligned}
			& \mathsf{id}_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}\right)\\
			& \land\quad \bigwedge_{i=1}^n
					\mathsf{M}.\mathsf{Verify}\left( r_\mathsf{reg}, h_\mathsf{id}^{(i)}, \rho_\mathsf{reg}^{(i)} \right)=1\\
			& \land\quad \bigwedge_{i=1}^n n_\mathsf{reg}^{(i)} = H_1\left( \mathsf{id}_\mathcal{H}^{(i)}, \mathsf{sk}_\mathcal{H}^{(i)}, 1\right).
		\end{aligned}
	\end{equation}

$\mathcal{H}$ generates a \textit{proof of association} for Relation \ref{eq: relation-id-association} by:
	\begin{multline*}
		\pi_\mathsf{a}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\Big(
				\varsigma,
				\big( r_\mathsf{reg}, \mathsf{id}_\mathsf{a}, \{ n_\mathsf{reg}^{(i)} \} \big), \\[-2pt]
				\big( \{ h_\mathsf{id}^{(i)} \}, \{ \rho_\mathsf{reg}^{(i)} \}, \{ \mathsf{id}_\mathcal{H}^{(i)} \}, \{ \mathsf{sk}_\mathcal{H}^{(i)} \} \big)
			\Big),
	\end{multline*}
	and sends it to the VDR along with the state root $r_\mathsf{reg}$, the associated identifier $\mathsf{id}_\mathsf{a}$, and all nullifiers $n_\mathsf{reg}^{(i)}$. Besides, $\mathcal{H}$ needs to prove that \cirn{185} it possesses all private keys $\mathsf{sk}_\mathcal{H}^{(i)}$ corresponding to $\mathsf{id}_\mathcal{H}^{(i)}$, just as in Relation \ref{eq: relation-id-register}, without further ado.

The VDR checks that $r_\mathsf{reg}$ is indeed a recent state root and that none of the $n_\mathsf{reg}^{(i)}$ has been received. It then verifies $\pi_\mathsf{a}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\Big(
			\varsigma,
			\big(r_\mathsf{reg}, \mathsf{id}_\mathsf{a}, \big\{ n_\mathsf{reg}^{(i)} \big\} \big),
			\pi_\mathsf{a}
		\Big)
		\overn{?}=1.
	\end{equation*}
	If the verification passes, it records $\mathsf{id}_\mathsf{a}$ in a Merkle tree and puts all $n_\mathsf{reg}^{(i)}$ into a nullifier bucket, indicating that these identifiers have already been associated. Next time the VDR receives a nullifier in the bucket, it can detect this and reject the request of association.

\spar{Review}
We implement \textit{identifier association} through a two-phase procedure. In Phase 1, the holder asynchronously registers its identifiers separately to the VDR. In Phase 2, the VDR aggregates these identifiers to an \textit{associated identifier}. Why split the process into two phases? Imagine that if a user associates all its identifiers simultaneously, any third party can monitor submitted identifiers in a period and infers the components of the associated identifier.


% Figure environment removed


\subsection{Identifier Presentation}
\label{subsec: identity-id-presentation}

With the infrastructure constructed in section \ref{subsec: identity-id-association}, \sysname can now provide a more substantial level of Sybil resistance. When a verifier $\mathcal{V}$ initiates a Sybil-sensitive campaign $\varepsilon$, it can force the presenter $\mathcal{H}$ to provide a proof of association of the identifier to which the credential belongs.

Specifically, $\mathcal{H}$ \cirn{182} retrieves the VDR and obtains a Merkle proof $\rho_\mathsf{a}$ to show that $\mathsf{id}_\mathsf{a}$ is included in a Merkle tree rooted at $r_\mathsf{a}$, and \cirn{183} computes $n_{\mathsf{a}\varepsilon} \leftarrow H_1(\mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, \mathsf{id}_\varepsilon)$, where $\mathsf{id}_\varepsilon$ is the identifier of campaign $\varepsilon$. In addition to showing that the above operations are performed correctly, $\mathcal{H}$ needs to prove that \cirn{184} $\mathsf{id}_\mathsf{a}$ is correctly calculated and \cirn{185} $\mathsf{id}_\mathcal{H}$ is contained in $\mathsf{id}_\mathsf{a}$, i.e.,
	\begin{equation}
	\label{eq: relation-id-presentation}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{a}, \mathsf{id}_\mathsf{a}, \rho_\mathsf{a}) = 1 \\
			& \land\quad \mathsf{id}_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}\right)\\
			& \land\quad n_{\mathsf{a}\varepsilon} = H_1 \left( \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, \mathsf{id}_\varepsilon \right) \\
			& \land\quad \mathsf{id}_\mathcal{H} \in \left\{ \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)} \right\}.
		\end{aligned}
	\end{equation}
	
$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-id-presentation} by:
	\begin{equation*}
		\pi_\mathsf{pre}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\Big(
				\varsigma,
				\big( r_\mathsf{a}, n_{\mathsf{a}\varepsilon}, \mathsf{id}_\mathcal{H}, \mathsf{id}_\varepsilon \big),
				\big( \rho_\mathsf{a}, \mathsf{id}_\mathsf{a}, \{\mathsf{id}_\mathcal{H}^{(i)} \} \big)
			\Big),
	\end{equation*}
	and sends it to $\mathcal{V}$ along with $r_\mathsf{a}$, $n_{\mathsf{a}\varepsilon}$ and $\mathsf{id}_\mathcal{H}$. $\mathcal{V}$ puts $\mathsf{id}_\varepsilon$ into the verification algorithm:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\Big(
			\varsigma,
			\big( r_a, n_{\mathsf{a}\varepsilon}, \mathsf{id}_\mathcal{H}, \mathsf{id}_\varepsilon\} \big),
			\pi_p
		\Big)
		\overn{?}=1.
	\end{equation*}
	and accepts the presentation if the verification passes. Besides, $\mathcal{V}$ needs to verify the presented credential as in Section \ref{sec: credential}, where it can hide its identifier $\mathsf{id}_\mathcal{H}$ by Relation \ref{eq: relation-holder-identity} and \ref{eq: relation-vdr}. If all verifications pass, $\mathcal{V}$ can confirm that $\mathcal{H}$ has not participated in campaign $\varepsilon$ using any identifier associated in $\mathsf{id}_\mathsf{a}$. $\mathcal{V}$ then consumes $n_{\mathsf{a}\varepsilon}$ to a nullifier bucket. If $\mathcal{H}$ uses another $\mathsf{id}_\mathcal{H}'$ in $\mathsf{id}_\mathsf{a}$ for $\varepsilon$, it can only provide $n_{\mathsf{a}\varepsilon}$ which has already been invalidated and will not be accepted by $\mathcal{V}$ anymore.

\subsection{Associated Identifier Update}
\label{subsec: identity-update}

Once associated, a user cannot remove an identifier from the association, but can append new ones into the associated identifier. Specifically, \sysname supports the holder to append a single identifier or aggregate two associated identifiers into one.

\spar{Appending a new identifier}
\sysname allows the holder $\mathcal{H}$ to append a new identifier $\mathsf{id}_\mathcal{H}^{(n+1)}$ to an associated identifier $\mathsf{id}_\mathsf{a}$. To do so, $\mathcal{H}$ \cirn{182} retrieves the VDR for a Merkle proof $\rho_\mathsf{a}$ indicating that $\mathsf{id}_\mathsf{a}$ is included in a Merkle tree with root $r_\mathsf{a}$ as in Section \ref{subsec: identity-id-presentation}. Then, it \cirn{183} queries the VDR again for another Merkle proof $\rho_\mathsf{reg}^{(n+1)}$ indicating that $\mathsf{id}_\mathcal{H}^{(n+1)}$ is included in a Merkle tree with root $r_\mathsf{reg}$ as in Phase 2 of Section \ref{subsec: identity-id-association}. Finally, $\mathcal{H}$ \cirn{184} updates the associated identifier $\mathsf{id}_\mathsf{a}'$ and \cirn{185} generates a nullifier $n_\mathsf{a}$ to invalidate the former one. The above relations could be expressed as follows:
	\begin{equation}
	\label{eq: relation-id-append}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{a}, \mathsf{id}_\mathsf{a}, \rho_\mathsf{a}) = 1 \\
			& \land\quad \mathsf{M}.\mathsf{Verify}\left( r_\mathsf{reg}, h_\mathsf{id}^{(n+1)}, \rho_\mathsf{reg}^{(n+1)} \right) = 1 \\
			& \land\quad \mathsf{id}_\mathsf{a} = H_1\left( \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)} \right) \\
			& \land\quad \mathsf{id}_\mathsf{a}' = H_1\left( \mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}, \mathsf{id}_\mathcal{H}^{(n+1)} \right) \\
			& \land\quad n_\mathsf{a} = H_1\left( \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, 1 \right) \\
			& \land\quad n_\mathsf{reg}^{(n+1)} = H_1 \left( \mathsf{id}_\mathcal{H}^{(n+1)}, \mathsf{sk}_\mathcal{H}^{(n+1)}, 1 \right).
		\end{aligned}
	\end{equation}

$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-id-append} by:
	\begin{multline*}
		\pi_\mathsf{apd}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\Big(
				\varsigma,
				\big( r_\mathsf{a}, r_\mathsf{reg}, n_\mathsf{a}, \mathsf{id}_\mathsf{a}', n_\mathsf{reg}^{(n+1)} \big), \\[-3pt]
				\big( \mathsf{id}_\mathsf{a}, h_\mathsf{id}^{(n+1)}, \rho_\mathsf{a}, \rho_\mathsf{reg}^{(n+1)}, \{\mathsf{id}_\mathcal{H}^{(i)} \}_{i=1}^n, \mathsf{id}_\mathcal{H}^{(n+1)}, \mathsf{sk}_\mathcal{H}^{(n+1)} \big)
			\Big),
	\end{multline*}
	and sends it to the VDR along with $r_\mathsf{a}$, $r_\mathsf{reg}$, $n_\mathsf{a}$, $\mathsf{id}_\mathsf{a}'$ and $n_\mathsf{reg}^{(n+1)}$. The VDR checks that $r_\mathsf{a}$ and $r_\mathsf{reg}$ are two valid state root and neither of $n_\mathsf{a}$ and $n_\mathsf{reg}^{(n+1)}$ is recorded in the nullifier buckets. It then verifies $\pi_\mathsf{apd}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\Big(
			\varsigma,
			\big( r_\mathsf{a}, r_\mathsf{reg}, n_\mathsf{a}, \mathsf{id}_\mathsf{a}', n_\mathsf{reg}^{(n+1)} \big),
			\pi_\mathsf{apd}
		\Big)
		\overn{?}=1.
	\end{equation*}
	If the verification passes, the VDR adds $\mathsf{id}_\mathsf{a}'$ in the Merkle tree of associated identifiers and $n_\mathsf{a}$, $n_\mathsf{reg}^{(n+1)}$ in the nullifier buckets, respectively. This invalidates the former $\mathsf{id}_\mathsf{a}$ and makes $\mathsf{id}_\mathcal{H}^{(n+1)}$ unable to be associated with other identifiers.
	 
\spar{Aggregating two associated identifiers}
\sysname also allows $\mathcal{H}$ to aggregate two associated $\mathsf{id}_\mathsf{a}^{(1)}$ and $\mathsf{id}_\mathsf{a}^{(2)}$ into a new associated identifier $\mathsf{id}_\mathsf{a}'$. To do so, $\mathcal{H}$ \cirn{182} retrieves the VDR for two Merkle proofs $\rho_\mathsf{a}^{(1)}$, $\rho_\mathsf{a}^{(2)}$ indicating that $\mathsf{id}_\mathsf{a}^{(1)}$ and $\mathsf{id}_\mathsf{a}^{(2)}$ are both included in a Merkle tree with root $r_\mathsf{a}$ as in Section \ref{subsec: identity-id-presentation}. $\mathcal{H}$ then \cirn{183} updates the associated identifier $\mathsf{id}_\mathsf{a}'$ and \cirn{184} generates two nullifiers $n_\mathsf{a}^{(1)}$ and $n_\mathsf{a}^{(2)}$ to invalidate the former ones. The above relations could be expressed as follows:
	\begin{equation}
	\label{eq: relation-id-aggregate}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify} \left(r_\mathsf{a}, \mathsf{id}_\mathsf{a}^{(1)}, \rho_\mathsf{a}^{(1)} \right) = 1 \\[-1pt]
			& \land\quad \mathsf{M}.\mathsf{Verify} \left(r_\mathsf{a}, \mathsf{id}_\mathsf{a}^{(2)}, \rho_\mathsf{a}^{(2)} \right) = 1 \\[-1pt]
			& \land\quad \mathsf{id}_\mathsf{a}^{(1)} = H_1\left( \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)} \right) \\[-1pt]
			& \land\quad \mathsf{id}_\mathsf{a}^{(2)} = H_1\left( \mathsf{id}_\mathcal{H}^{(n+1)},\dots,\mathsf{id}_\mathcal{H}^{(n+m)} \right) \\[-1pt]
			& \land\quad \mathsf{id}_\mathsf{a}' = H_1\left( \mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n+m)} \right) \\[-1pt]
			& \land\quad n_\mathsf{a}^{(1)} = H_1\left( \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, 1 \right) \\[-1pt]
			& \land\quad n_\mathsf{a}^{(2)} = H_1\left( \mathsf{id}_\mathcal{H}^{(n+1)}, \dots, \mathsf{id}_\mathcal{H}^{(n+m)}, 1 \right).
		\end{aligned}
	\end{equation}

$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-id-aggregate} by:
	\begin{multline*}
		\pi_\mathsf{agg}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\Big(
				\varsigma,
				\big( r_\mathsf{a}, n_\mathsf{a}^{(1)}, n_\mathsf{a}^{(2)}, \mathsf{id}_\mathsf{a}' \big), \\[-1pt]
				\big( \mathsf{id}_\mathsf{a}^{(1)}, \mathsf{id}_\mathsf{a}^{(2)}, \rho_\mathsf{a}^{(1)}, \rho_\mathsf{a}^{(2)}, \{\mathsf{id}_\mathcal{H}^{(i)} \}_{i=1}^{n+m} \big)
			\Big),
	\end{multline*}
	and sends it to the VDR along with $r_\mathsf{a}$, $n_\mathsf{a}^{(1)}$, $n_\mathsf{a}^{(2)}$ and $\mathsf{id}_\mathsf{a}'$. The VDR checks that $r_\mathsf{a}$ is a valid state root and neither of $n_\mathsf{a}^{(1)}$ and $n_\mathsf{a}^{(2)}$ is recorded in the nullifier bucket. Finally, it verifies $\pi_\mathsf{apd}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\Big(
			\varsigma,
			\big( r_\mathsf{a}, n_\mathsf{a}^{(1)}, n_\mathsf{a}^{(2)}, \mathsf{id}_\mathsf{a}' \big),
			\pi_\mathsf{agg}
		\Big)
		\overn{?}=1.
	\end{equation*}
	If the verification passes, the VDR adds $\mathsf{id}_\mathsf{a}'$ in the Merkle tree of associated identifiers and $n_\mathsf{a}^{(1)}$, $n_\mathsf{a}^{(2)}$ in the nullifier bucket. This invalidates the former $\mathsf{id}_\mathsf{a}^{(1)}$ and $\mathsf{id}_\mathsf{a}^{(2)}$.

\subsection{Identifier Accountability}
\label{subsec: identity-accountability}

A helpful feature provided by the associated identifier mechanism is the accountability of malicious participants. In existing systems, blocking one identifier does not stop a malicious party from using other identifiers to do evil. In \sysname, however, when a verifier $\mathcal{V}$ discovers a user $\mathcal{H}$ misusing credentials or engaging in malicious behaviors, it can request identifier blocking from the VDR and thus invalidate all the identifiers and credentials under $\mathcal{H}$'s name.

In Section \ref{subsec: identity-update}, the VDR uses a nullifier $n_\mathsf{a}$ to invalidate an associated identifier $\mathsf{id}_\mathsf{a}$. It now uses the same technique to sanction identifiers. Whenever an associated identifier $\mathsf{id}_\mathsf{a}$ is presented, $\mathcal{V}$ asks $\mathcal{H}$ for the corresponding nullifier $n_\mathsf{a}$ to confirm that $\mathsf{id}_\mathsf{a}$ is valid and in its latest state. When filing a complaint with the VDR, $\mathcal{V}$ sends $n_\mathsf{a}$ along with its witnesses. VDR then adds $n_\mathsf{a}$ to the nullifier bucket if the malicious behaviors of $\mathcal{H}$ are confirmed. So that when $\mathsf{id}_\mathsf{a}$ is presented again, verifiers will know that it is invalid and reject the presentation.

\spar{Nullifier-based correlation}
As with the credential revocation in Section \ref{subsec: cred-revocation}, the above mechanism leads to correlation based on nullifiers. Whenever $\mathcal{H}$ presents its associated identifier $\mathsf{id}_\mathrm{a}$, the corresponding nullifier $n_\mathsf{a}$ is always the same. The verifier could thus use $n_\mathsf{a}$ to locate multiple presentations of $\mathcal{H}$. \sysname uses a similar approach to solve the problem, introducing a random value $u_\mathsf{a}\overm{R}\leftarrow\mathbb{Z}_p$ into $\mathsf{id}_\mathsf{a}$ and $n_\mathsf{a}$ by:
	\begin{gather*}
	\mathsf{id}_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}, u_\mathsf{a} \right), \\
	n_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}, u_\mathsf{a}, 1 \right).
	\end{gather*}
	$\mathcal{H}$ is allowed to asynchronously refresh $u_\mathsf{a}$ and thus the nullifier, for which the VDR puts the old version of $n_\mathsf{a}$ into the nullifier bucket to invalidate it.