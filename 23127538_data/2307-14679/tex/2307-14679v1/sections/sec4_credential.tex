\section{Privacy-Preserving Credential Presentation}
\label{sec: credential}

In this section, we introduce \sysname's credential system that manages the presentation and verification of credentials, as shown in Figure \ref{fig: cred-present-verify}. A significant difference from existing systems is that \sysname secures users' full privacy of their credentials and identities, providing credential selective disclosure in a highly autonomous manner.

\subsection{Selective Disclosure}
\label{subsec: cred-selective}

%When a credential contains far more information than is required for verification, presenting the raw credential directly to the verifier could violate the holder's privacy. 

\sysname allows a holder to prove to a verifier that it holds a credential with specific claims while not revealing the rest of the contents. Recall the definition in Section \ref{subsec: over-model} that a credential contains a set of claims $\{s_1,s_2,\dots,s_n\}$, where each $s_i$ is a property-value mapping. Now, a holder $\mathcal{H}$ wishes to prove to a verifier $\mathcal{V}$ that it holds a credential $\mathsf{cred}$ containing a claim $s$ that satisfies a particular predicate $\phi$, i.e., $\phi(s)=1$. To do this, $\mathcal{H}$ commits to $\mathsf{cred}$ by $c_\mathsf{c}\overm{R}\leftarrow\mathsf{\Gamma}.\mathsf{Commit}(\mathsf{cred},u_\mathsf{c})$ where $u_\mathsf{c}$ is a random value, and then proving that \cirn{182} $c_\mathsf{c}$ is a commitment to $\mathsf{cred}$, \cirn{183} $\mathsf{cred}$ has been signed by the issuer $\mathcal{I}$ and derives $\sigma_\mathcal{I}$, and \cirn{184} $\mathsf{cred}$ contains a claim $s$ that satisfies the predicate $\phi$. The above relations can be expressed as follows:
	\begin{equation}
	\label{eq: relation-basic}
		\begin{aligned}
			& \mathsf{\Gamma}.\mathsf{Open}(\mathsf{cred}, c_\mathsf{c}, u_\mathsf{c})=1\\
			& \land\quad \mathsf{VerSign}(\mathsf{pk}_\mathcal{I}, \sigma_\mathcal{I},\mathsf{cred})=1\\
			& \land\quad \phi(s) = 1\\
			& \land\quad \{s, \sigma_\mathcal{I}, \mathsf{id}_\mathcal{I}\} \in \mathsf{cred},
		\end{aligned}
	\end{equation}
	where $\{0,1\}\leftarrow\mathsf{VerSign}(\mathsf{pk},\sigma,m)$ is the signature verification algorithm.
	
%$\mathcal{H}$ then generates a non-interactive zero-knowledge proof $\pi_\mathsf{c}$ for Relation \ref{eq: relation-basic} and sends it to $\mathcal{V}$ along with the commitment $c$, the signature $\sigma_\mathcal{I}$ and $\mathcal{I}$'s identifier $\mathsf{id}_\mathcal{I}$. $\mathcal{V}$ queries the VDR for $\mathcal{I}$'s public key $\mathsf{pk}_\mathcal{I}$ and verifies the proof $\pi_\mathsf{c}$. If the verification passes, $\mathcal{V}$ acknowledges that $\mathcal{H}$ possesses a credential with a claim $s$ satisfying the predicate $\phi$.

$\mathcal{H}$ generates a non-interactive zero-knowledge proof for Relation \ref{eq: relation-basic} by:
	\begin{equation}
	\label{eq: proof-credential-selective-disclosure}
		\pi_\mathsf{c}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\big(
				\varsigma,
				(c_\mathsf{c}, \sigma_\mathcal{I}, \mathsf{id}_\mathcal{I}, \mathsf{pk}_\mathcal{I}, \phi), 
				(\mathsf{cred}, u_\mathsf{c})
			\big),
	\end{equation}
	and sends $\pi_\mathsf{c}$ to $\mathcal{V}$, along with the commitment $c_\mathsf{c}$, the signature $\sigma_\mathcal{I}$ and $\mathcal{I}$'s identifier $\mathsf{id}_\mathcal{I}$. $\mathcal{V}$ queries the VDR for $\mathcal{I}$'s public key $\mathsf{pk}_\mathcal{I}$ and verifies $\pi_\mathsf{c}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\big(
			\varsigma,
			(c_\mathsf{c}, \sigma_\mathcal{I}, \mathsf{id}_\mathcal{I}, \mathsf{pk}_\mathcal{I}, \phi),
			\pi_\mathsf{c}
		\big)
		\overn{\rm ?}=1.
	\end{equation*}
If the verification passes, $\mathcal{V}$ acknowledges that $\mathcal{H}$ possesses a credential with a claim $s$ satisfying the predicate $\phi$. For security reasons, $\mathcal{H}$ can use a random value to mask $\sigma_\mathcal{I}$ to prevent an adversary from distinguishing by signature whether two presentations derive from the same credential $\mathsf{cred}$.

\subsection{Credential Non-Transferrability}
\label{subsec: cred-non-transfer}

Despite ensuring the validity of credentials, the above mechanism cannot prevent credential transfer. A credential $\mathsf{cred}$ could be obtained and exploited by someone other than the holder $\mathcal{H}$ due to intentional transfer or data leakage \cite{thomas2019protecting}. The crux to prevent this is to confirm that the presenter holds a private key corresponding to the credential subject.

Recall from Section \ref{subsec: over-model} that the credential $\mathsf{cred}$ contains the holder's identifier $\mathsf{id}_\mathcal{H}$ as its subject. \sysname requires that when presenting a credential $\mathsf{cred}$, the presenter $\mathcal{H}$ needs to prove that \cirn{182} it holds a private key $\mathsf{sk}_\mathcal{H}$ corresponding to the credential subject $\mathsf{id}_\mathcal{H}$ stored in $\mathsf{cred}$, i.e.,
	\begin{equation}
	\label{eq: relation-holder-identity}
		\begin{aligned}
			& \mathsf{pk}_\mathcal{H} = \mathsf{PubKeyGen}(\mathsf{sk}_\mathcal{H})\\
			& \land\quad \mathsf{id}_\mathcal{H} \in \mathsf{cred},
		\end{aligned}		
	\end{equation}
	where $\mathsf{pk}_\mathcal{H}$ is the public key of $\mathcal{H}$ and $\mathsf{pk}\leftarrow\mathsf{PubKeyGen}(\mathsf{sk})$ is the function to derive the public key from the private key in the key generation algorithm.

%$\mathcal{H}$ generates a zero-knowledge proof $\pi_\mathsf{k}$ for Relation \ref{eq: relation-holder-identity} and sends it to $\mathcal{V}$ along with its identifier $\mathsf{id}_\mathcal{H}$. $\mathcal{V}$ queries the VDR for $\mathcal{H}$'s public key $\mathsf{pk}_\mathcal{H}$ and verifies $\pi_\mathsf{k}$. If the verification passes, $\mathcal{V}$ accepts that $\mathcal{H}$ is the holder of $\mathsf{cred}$.

%$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-holder-identity} by:
%	\begin{equation*}
%		\pi_k
%			\overset{\rm R}\leftarrow
%			\mathsf{\Pi}.\mathsf{Prove}\big(
%				\varsigma,
%				(\mathsf{pk}_\mathcal{H}, \mathsf{id}_\mathcal{H}),
%				(\mathsf{cred}, \mathsf{sk}_\mathcal{H})
%			\big),
%	\end{equation*}
%	and sends its identifier $\mathsf{id}_\mathcal{H}$ to the verifier $\mathcal{V}$, who uses $\mathsf{id}_\mathcal{H}$ to index $\mathsf{pk}_\mathcal{H}$ from the VDR and verifies $\pi_h$ by:
%	\begin{equation*}
%		b
%			\leftarrow
%			\mathsf{\Pi}.\mathsf{Verify}\big(
%				\varsigma,
%				(\mathsf{pk}_\mathcal{H}, \mathsf{id}_\mathcal{H}),
%				\pi_k
%			\big).
%	\end{equation*}
%
%If $b=1$, $\mathcal{V}$ accepts that $\mathcal{H}$ is the holder of $\mathsf{cred}$.

% Figure environment removed


\subsection{Identifier-Based Correlation}
\label{subsec: cred-id-correlation}

Notice that to identify the holder, $\mathcal{H}$ is asked to send its identifier $\mathsf{id}_\mathcal{H}$ to $\mathcal{V}$ during the presentation process. However, this leads to $\mathcal{V}$ being able to associate claims with $\mathsf{id}_\mathcal{H}$ and poses a greater privacy risk when $\mathcal{H}$ repeatedly uses the same identifier for multiple campaigns. In particular, when there is complicity between verifiers, they can share claims under the same identifier to obtain more information about the holder.

\sysname attempts to enable identification without requiring the holder to present its identifier. To this end, \sysname makes use of the structured data provided by the VDR. As introduced in Section \ref{subsec: over-arch}, the VDR can be abstracted as a blockchain in which all states are stored in a Merkle tree. For an identifier $\mathsf{id}_\mathcal{H}$, there exists a node in the VDR with the content $(\mathsf{id}_{\mathcal{H}},\mathsf{pk}_{\mathcal{H}})$.

To provide identification, instead of sending $\mathsf{id}_\mathcal{H}$ directly to $\mathcal{V}$, $\mathcal{H}$ randomly chooses $u_\mathsf{id}\overm{R}\leftarrow\mathbb{Z}_p$ and \cirn{183} computes $c_\mathsf{id} \overm{R}\leftarrow \mathsf{\Gamma}.\mathsf{Commit}(\mathsf{id}_\mathcal{H}, u_\mathsf{id})$. It then uses a Merkle proof $\rho_\mathsf{id}$ to show that \cirn{184} $v_\mathsf{id}=H_1(\mathsf{id}_\mathcal{H},\mathsf{pk}_\mathcal{H})$ is contained in a Merkle tree rooted at $r_\mathsf{id}$, i.e.,
	\begin{equation}
	\label{eq: relation-vdr}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{id}, v_\mathsf{id}, \rho_\mathsf{id}) = 1\\
			& \land\quad \mathsf{\Gamma}.\mathsf{Open}(\mathsf{id}_\mathcal{H}, c_\mathsf{id}, u_\mathsf{id})=1\\
			& \land\quad v_\mathsf{id} = H_1(\mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}).
		\end{aligned}
	\end{equation}

%$\mathcal{H}$ generates a zero-knowledge proof $\pi_\mathsf{id}$ for Relation \ref{eq: relation-vdr} and sends it to $\mathcal{V}$ along with $r_\mathsf{id}$, $h_\mathsf{id}$ and $e_\mathsf{id}$. $\mathcal{V}$ checks that $r_\mathsf{id}$ is a recent Merkle root in VDR and then verifies $\pi_\mathsf{id}$.

$\mathcal{H}$ generates a non-interactive zero-knowledge proof for Relation \ref{eq: relation-holder-identity} and \ref{eq: relation-vdr} by:
	\begin{multline*}
		\pi_\mathsf{id}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\big(
				\varsigma,
				(r_\mathsf{id}, c_\mathsf{id}, u_\mathsf{id}), \\[-3pt]
				(\mathsf{cred}, v_\mathsf{id}, \rho_\mathsf{id}, \mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}, \mathsf{sk}_\mathcal{H})
			\big),
	\end{multline*}
	and sends $\pi_\mathsf{id}$ to $\mathcal{V}$, along with $r_\mathsf{id}$, $c_\mathsf{id}$ and $u_\mathsf{id}$. $\mathcal{V}$ retrieves the VDR to confirm that $r_\mathsf{id}$ is a recent Merkle root and then verifies $\pi_\mathsf{id}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\big(
			\varsigma,
			(r_\mathsf{id}, c_\mathsf{id}, u_\mathsf{id}),
			\pi_\mathsf{id}
		\big)
		\overn{\rm ?}=1.
	\end{equation*}
	If the above verification passes, $\mathcal{V}$ could ensure that $\mathsf{cred}$ belongs to $\mathcal{H}$ who presents it.

\spar{Masking}
Notice that we use an ephemeral value $u_\mathsf{id}$ to mask $\mathsf{id}_\mathcal{H}$ instead of directly disclosing $v_\mathsf{id}$, since an adversary could retrieve the VDR for all identifiers and construct a pre-computed table for $v_\mathsf{id}$ and thus reveal the identity of $\mathcal{H}$. A randomly chosen $u_\mathsf{id}$ could make $c_\mathsf{id}$ different in every presentation even if with the same $\mathsf{cred}$.

\subsection{Proof Non-Forwardability}
\label{subsec: cred-prof-non-transfer}

Consider that the verifier $\mathcal{V}$ obtains $\pi_\mathsf{c}$, $\pi_\mathsf{id}$ and all public inputs from $\mathcal{H}$. Even though $\mathcal{V}$ does not possess $\mathsf{cred}$, it can still forward proofs and public inputs to another verifier $\mathcal{V}'$ to be authenticated using $\mathcal{H}$'s claims. It turns out that any verifier can replay the presentation process to others without informing the holder. To prevent proofs from getting out of the holder's control, \sysname provides the following two approaches.

\spar{Approach 1: Proof of private key}
To prevent proof forwarding, a trivial idea is to include a component known only to the verifier in public inputs. Similar to Section \ref{subsec: cred-non-transfer}, $\mathcal{H}$ can embed the verifier's public key $\mathsf{sk}_\mathcal{V}$ into the arithmetic circuit and contains a relation that there exists a private key $\mathsf{sk}_\mathcal{V}$ whose corresponding public key is $\mathsf{pk}_\mathcal{V}$, i.e.,
	\begin{equation}
	\label{eq: relation-verifier-identity}
		\mathsf{pk}_\mathcal{V} = \mathsf{PubKeyGen}(\mathsf{sk}_\mathcal{V}).
	\end{equation}

$\mathcal{H}$ does not actually possess $\mathsf{sk}_\mathcal{V}$, but it can still construct a circuit to compute $\mathsf{PubKeyGen}(\cdot)$ and compare the result with $\mathsf{pk}_\mathcal{V}$. $\mathcal{H}$ retrieves $\mathsf{pk}_\mathcal{V}$ from the VDR and compares it with the output of $\mathsf{PubKeyGen}(\cdot)$ in the circuit. Upon receiving the proof, $\mathcal{V}$ enters its private key $\mathsf{sk}_\mathcal{V}$ to verify it. If the verification fails, $\mathcal{V}$ can learn that the intended verifier of this proof is not itself and thus reject other proofs claimed by the presenter.

\spar{Approach 2: Proof of challenge}
An alternative idea is to make the proof mandatory for the components specified by the verifier. To do so, the verifier $\mathcal{V}$ randomly chooses a $e_\mathsf{c}\overm{R}\leftarrow\mathbb{Z}_p$ and sends it to $\mathcal{H}$ who must embed it in the arithmetic circuit.

Notice that $e_\mathsf{c}$ is included in the context of $\mathcal{H}$'s statement but not involved in the computation. Its inclusion in the circuit prevents it from being tampered with by any participants. $\mathcal{V}$ can verify this to ensure that the proof was generated according to its requirements. When $\mathcal{V}$ forwards the proof to another verifier $\mathcal{V}'$, $\mathcal{V'}$ will send a random $e_\mathsf{c}'$ to $\mathcal{V}$ with a value equal to $e_\mathsf{c}$ with probability $1/p$. Since $\mathcal{V}$ cannot modify the proof, $\mathcal{V'}$ will only accept this presentation with negligible probability.

\spar{Embedding into circuits}
Note that, regardless of the approach used, the above relations should be embedded in the circuit for the proof $\pi_\mathsf{c}$ (i.e., Relation \ref{eq: relation-basic}) to achieve a binding on the claims. In this way, $\mathcal{V}$ have to verify the above relations simultaneously when verifying $\pi_\mathsf{c}$, thus eliminating credential forwarding. Generating a proof alone and sending it along with $\pi_\mathsf{c}$ cannot bind the claims, still enabling the adversary to fool the verifier.

\subsection{Credential Revocation}
\label{subsec: cred-revocation}

Credentials could be misused due to malicious attacks or data leakages. \sysname grants the issuer $\mathcal{I}$ to revoke credentials issued by it, for which $\mathcal{I}$ needs to maintain a smart contract on the blockchain. When $\mathcal{I}$ issues a credential $\mathsf{cred}$ to a holder $\mathcal{H}$, it randomly chooses $u_\mathsf{rv} \overm{R}\leftarrow \mathbb{Z}_p$, computes $h_\mathsf{rv} \leftarrow H_1(\mathsf{cred}, u_\mathsf{rv})$, and places $h_\mathsf{rv}$ into a Merkle tree in the contract. $\mathcal{I}$ then sends $\mathsf{cred}$, and $u_\mathsf{rv}$ to $\mathcal{H}$, who verifies that the calculation is correct and that $h_\mathsf{rv}$ has been incorporated into the contract.

\spar{Proof of validity}
When $\mathcal{H}$ presents $\mathsf{cred}$ to a verifier $\mathcal{V}$, it should prove to $\mathcal{V}$ that $\mathsf{cred}$ has not been revoked by its issuer. To this end, it computes \cirn{182} $n_\mathsf{rv} \leftarrow H_1(\mathsf{cred}, u_\mathsf{rv}, 1)$, and proves that $h_\mathsf{rv}$ \cirn{183} is correctly evaluated and \cirn{184} is incorporated in $\mathcal{I}$'s contract, i.e.,
	\begin{equation}
	\label{eq: relation-cred-validity}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{rv}, h_\mathsf{rv}, \rho_\mathsf{rv})=1\\
			& \land\quad h_\mathsf{rv} = H_1(\mathsf{cred}, u_\mathsf{rv})\\
			& \land\quad n_\mathsf{rv} = H_1(\mathsf{cred}, u_\mathsf{rv}, 1),
		\end{aligned}
	\end{equation}
	where $\rho_\mathsf{rv}$ is a Merkle proof indicating that $h_\mathsf{rv}$ is contained in a Merkle tree with root $r_\mathsf{rv}$. $\mathcal{H}$ generates a proof for Relation \ref{eq: relation-cred-validity} by:
	\begin{equation*}
		\pi_\mathsf{rv}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\big(
				\varsigma,
				(r_\mathsf{rv}, n_\mathsf{rv}),
				(h_\mathsf{rv}, \rho_\mathsf{rv}, u_\mathsf{rv}, \mathsf{cred})
			\big),
	\end{equation*}
	and sends $r_\mathsf{rv}$ and $n_\mathsf{rv}$ to $\mathcal{V}$, who checks that $r_\mathsf{rv}$ is a recent root in $\mathcal{I}$'s contract and $n_\mathsf{rv}$ has not been recorded by $\mathcal{I}$. It then verifies the proof $\pi_r$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\big(
			\varsigma,
			(r_\mathsf{rv}, n_\mathsf{rv}),
			\pi_\mathsf{rv}
		\big)
		\overn{\rm ?}=1.
	\end{equation*}
	If the above verification passes, $\mathcal{V}$ could confirm that $\mathsf{cred}$ has not been revoked by its issuer $\mathcal{I}$.

\spar{Credential revocation}
To revoke $\mathsf{cred}$, $\mathcal{I}$ computes $n_\mathsf{rv} \leftarrow H_1(\mathsf{cred}, u_\mathsf{rv}, 1)$ and places it in the nullifier bucket of its contract. Later if $\mathcal{H}$ tries to present $\mathsf{cred}$ again, the $n_\mathsf{rv}$ it presents must have been recorded and invalidated. The verifier $\mathcal{V}$ can thus know this and reject the presentation.

\spar{Nullifier-based correlation}
The problem with the above mechanism is that when $\mathcal{H}$ presents $\mathsf{cred}$ multiple times, the corresponding nullifier $n_\mathsf{rv}$ is always consistent. A verifier could thus use $n_\mathsf{rv}$ to locate claims of $\mathcal{H}$ despite not knowing its identifier. \sysname could solve this issue by allowing the holder $\mathcal{H}$ to proactively update the nullifier. To trigger an update, $\mathcal{H}$ randomly chooses a $u_\mathsf{rv}' \overm{R}\leftarrow \mathbb{Z}_p$ and calculates $h_\mathsf{rv}' \leftarrow H_1(\mathsf{cred}, u_\mathsf{rv}')$ and $n_\mathsf{rv}' \leftarrow H_1(\mathsf{cred}, u_\mathsf{rv}', 1)$. $\mathcal{H}$ proves to $\mathcal{I}$ that the above relations and Relation \ref{eq: relation-cred-validity} hold. After verifying this, $\mathcal{I}$ puts $h_\mathsf{rv}'$ in the Merkle tree and $n_\mathsf{rv}$ in the nullifier bucket, indicating that $n_\mathsf{rv}$ is consumed and no longer valid.