\section{Miscellaneous}
\label{app: miscellaneous}

In Appendix \ref{app: miscellaneous}, we discuss some performance optimizations and practical considerations for implementing \sysname.

\subsection{Membership Proof}
\label{subapp: misc-merkle}

\spar{On-chain Merkle proof}
The Merkle tree construction is used multiple times in \sysname to provide proofs of membership, indicating that a specific element was previously committed to and recorded on the blockchain. However, explicitly maintaining a Merkle tree in a smart contract is costly and unnecessary. It turns out that only a few states should be adequately maintained by smart contracts to provide necessary functionalities for verification.

Take Phase 1 in Section \ref{subsec: identity-id-association} as an example. The VDR contract records $V=\{v_\mathsf{id}^{(0)},\dots,v_\mathsf{id}^{(n)}\}$ from all users as leaves, and maintains the state root $r_\mathsf{id}$ of the current Merkle tree with a corresponding Merkle proof $\rho_\mathsf{id}$, as shown in Figure \ref{fig: membership-proof}. When a holder $\mathcal{H}$ wants to register its identifier $\mathsf{id}_\mathcal{H}$ to the VDR, it computes $v_\mathsf{id}\leftarrow H_1(\mathsf{id}_\mathcal{H},\mathsf{pk}_\mathcal{H})$, generates a new Merkle proof $\rho_\mathsf{id}'$ for state update by:
	\begin{equation*}
		\rho_\mathsf{id}'
			\leftarrow
			\mathsf{M}.\mathsf{Prove}\left(
				\mathsf{v}_\mathsf{id},
				V
			\right),
	\end{equation*}
and sends them to the VDR. Upon receiving $v_\mathsf{id}$ and $\rho_\mathsf{id}'$ from $\mathcal{H}$, the contract verifies that $\rho_\mathsf{id}'$ is correctly computed. If this is the case, it updates $\rho_\mathsf{id}$ to $\rho_\mathsf{id}'$, and refreshes the state root $r_\mathsf{id}$ using $v_\mathsf{id}$ and $\rho_\mathsf{id}$ by:
	\begin{equation*}
		r_\mathsf{id}'
			\leftarrow
			\mathsf{M}.\mathsf{Update}\left(
				v_\mathsf{id},
				\rho_\mathsf{id}
			\right).
	\end{equation*}
When $\mathcal{H}$ associates its $\mathsf{id}_\mathcal{H}$ into an associated identifier in Phase 2, it sends a nullifier $n_\mathsf{reg}\leftarrow H_1(\mathsf{id}_\mathcal{H},\mathsf{sk}_\mathcal{H},1)$ to the VDR, who places it in the nullifier bucket to invalidate $\mathsf{id}_\mathcal{H}$.

% Figure environment removed

\spar{Caulk construction}
It is worth noting that a protocol called Caulk can theoretically replace our Merkle tree construction and provide similar zero-knowledge properties. Caulk can provide sublinear proof times and constant-level proof sizes with a lookup argument and position-hiding linkability for vector commitment schemes \cite{zapico2022caulk}.

\subsection{Credential Parsing and Formatting}
\label{subapp: credential-parsing}

Decentralized credentials, such as those under the W3C Verifiable Credential standard, are usually recorded in JSON or JSON-LD format \cite{world2022verifiable}. However, these credentials cannot be directly entered into arithmetic circuits as public statements and should be appropriately parsed and encoded. One way to address this issue is to create a zk-friendly credential format. To achieve that, we propose a straightforward credential encoding scheme that can translate individual fields in a JSON file into elements in $\mathbb{Z}_p$, which is applicable to most cryptographic primitives.

To ensure compatibility of our design with traditional credentials encoded in JSON or JSON-LD, we have also designed a parsing gadget that can translate the entire file and verify the consistency and correctness of the parsing. Moreover, we utilize the two-stage parsing scheme provided by DECO, which enables precise parsing and proof of claims that offer protection against context-integrity attacks \cite{zhang2020deco}.

\subsection{Performance of NIZK}
\label{subapp: misc-nizk}

\spar{Custom gates}
Presenters in \sysname may need to prove various complex relations, such as exponential operations on cyclic groups. While basic arithmetic circuits based on additive and multiplicative gates can certainly provide such functionalities, a considerable amount of circuits and constraints would be required for proof construction. Thanks to its highly expressive front end, the Plonk protocol allows the construction of custom gates that can perform complicated operations with lower overhead \cite{chen2023hyperplonk}.


\spar{Recursive proofs}
A holder may simultaneously provide proofs against multiple claims under different credentials in a single presentation. Generating separate proofs for each credential would proportionally increase the verifier's overhead. In contrast, using recursive proving schemes, multiple proofs can be aggregated into a new proof whose target is the verification circuits of the previous ones \cite{gabizon2019plonk}. This recursion and aggregation significantly reduce verifiers' workload and give the credentials a more powerful combinatorial nature to provide highly flexible proofs.