\section{Definitions}
\label{app: definition}

We detail in Appendix \ref{app: definition} the cryptographic primitives given in Section \ref{sec: preliminaries} and detail their security definitions.

\subsection{Non-Interactive Zero Knowledge}
\label{subapp: definition-nizk}

\begin{definition}[zkSNARK]
\label{def: zk-snark}
We call $\mathsf{\Pi}$ a zero-knowledge succinct non-interactive argument of knowledge (\textbf{zkSNARK}) for $\mathcal{R}$ if it has \textbf{zero-knowledge} (cf. Definition \ref{def: zk-zero-knowledge}), \textbf{succinctness} (cf. Definition \ref{def: zk-succinctness}), \textbf{completeness} (cf. Definition \ref{def: zk-completeness}) and \textbf{computational knowledge soundness} (cf. Definition \ref{def: zk-soundness}).
\end{definition}

\begin{definition}[Zero-Knowledge]
\label{def: zk-zero-knowledge}
Intuitively, an argument is zero-knowledge if it does not give away any information other than the truth of the statement. We say $\mathsf{\Pi}$ is \textbf{zero-knowledge} if for all $\lambda\in\mathbb{N}$, $R\in\mathcal{R}_\lambda$, $(\phi,w)\in R$ and all adversaries $\mathcal{A}$, there exists a simulator $\mathsf{Sim}$ such that,
\[
\begin{aligned}
&	\Pr
	\left[
		\begin{aligned}
			\varsigma	\overm{R}\leftarrow	\mathsf{\Pi}.\mathsf{Setup}(R)\\
			\pi			\overm{R}\leftarrow	\mathsf{\Pi}.\mathsf{Prove}(\varsigma,x,w)
		\end{aligned}:
		\mathcal{A}(R,\varsigma,\pi)=1
	\right]
=\\ & \;\;\;\;
	\Pr
	\left[
		\begin{aligned}
			\varsigma	\overm{R}\leftarrow	\mathsf{\Pi}.\mathsf{Setup}(R)\\
			\pi			\overm{R}\leftarrow	\mathsf{Sim}(R,x)
		\end{aligned}:
		\mathcal{A}(R,\varsigma,\pi)=1
	\right].
\end{aligned}
\]
\end{definition}

\begin{definition}[Succinctness]
\label{def: zk-succinctness}
We say $\mathsf{\Pi}$ is \textbf{succinct} if the verifier runtime can be bounded by a polynomial in $\lambda+|x|$ and the proof size can be bounded by a polynomial in $\lambda$. On this basis, we claim that $\mathsf{\Pi}$ is \textbf{completely succinct} if the length of the reference string $|\varsigma|$ can also be bounded by a polynomial in $\lambda$.
\end{definition}

\begin{definition}[Completeness]
\label{def: zk-completeness}
Intuitively, completeness means that given any true statement, an honest prover is necessarily able to convince an honest verifier to accept the argument. We say $\mathsf{\Pi}$ is \textbf{complete} if for all $\lambda\in\mathbb{N}$, $R\in\mathcal{R}_\lambda$ and $(x,w)\in R$,
\[
	\Pr
	\left[
		\begin{aligned}
			\varsigma	\overm{R}\leftarrow	\mathsf{\Pi}.\mathsf{Setup}(R)\\
			\pi			\overm{R}\leftarrow	\mathsf{\Pi}.\mathsf{Prove}(\varsigma,x,w)
		\end{aligned}:
		\mathsf{\Pi}.\mathsf{Verify}(\varsigma,x,\pi)=1
	\right]=1.
\]
\end{definition}

\begin{definition}[Soundness]
\label{def: zk-soundness}
We say $\mathsf{\Pi}$ is \textbf{computational knowledge sound} if for all non-uniform polynomial-time adversaries $\mathcal{A}$, there exists a non-uniform polynomial-time extractor $\mathsf{Ext}$ such that,
\[
	\Pr
	\left[
		\begin{aligned}
			\varsigma		\overm{R}\leftarrow		\mathsf{\Pi}.\mathsf{Setup}(R)\\
			(x,\pi)			\overm{R}\leftarrow		\mathcal{A}\\
			w				\leftarrow				\mathsf{Ext}(\varsigma,x,\pi)
		\end{aligned}:
		\begin{aligned}
			& (x,w)	\notin	R
				\;\;\land\;\\
			& \mathsf{\Pi}.\mathsf{Verify}(\varsigma,x,\pi)=1
		\end{aligned}
	\right]
	\leq\mathsf{negl}(\lambda).
\]
\end{definition}

\subsection{Commitment Scheme}
\label{subapp: definition-commitment}

\begin{definition}[Commitment]
\label{def: commitment}
	We call $\mathsf{\Gamma}$ a secure cryptographic commitment scheme if it has the property of \textbf{correctness} defined above, along with the properties of \textbf{hiding} (cf. Definition \ref{def: hiding}) and \textbf{binding} (cf. Definition \ref{def: binding}).
\end{definition}

\begin{definition}[Hiding]
\label{def: hiding}
	Intuitively, hiding means that the commitment $c$ should reveal nothing about the committed message $m$. We say $\mathsf{\Gamma}$ is \textbf{hiding} if for all efficient adversaries $\mathcal{A}$, two different messages $m_0,m_1\in\mathcal{M}$ and two arbitrary opening strings $u_0,u_1\in\mathcal{U}$,
	\[
		\begin{aligned}
			\Bigg\vert
				&\Pr
				\left[
					\begin{aligned}
						c_0 \overm{R}\leftarrow \mathsf{\Gamma}.\mathsf{Commit}(m_0,u_0)\\
						r_0 \leftarrow \mathcal{A}(c_0)
					\end{aligned}:
					r_0=0
				\right]-\\
				&\Pr
				\left[
					\begin{aligned}
						c_1 \overm{R}\leftarrow \mathsf{\Gamma}.\mathsf{Commit}(m_1,u_1)\\
						r_1 \leftarrow \mathcal{A}(c_1)
					\end{aligned}:
					r_1=0
				\right]
			\Bigg\vert
			\leq \mathsf{negl}(\lambda)
		\end{aligned}
	\]
	holds.
\end{definition}

\begin{definition}[Binding]
\label{def: binding}
	Intuitively, binding means a commitment $c$ could only be opened to a single message $m\in\mathcal{M}$. We say $\mathsf{\Gamma}$ is \textbf{binding} if for all efficient adversaries $\mathcal{A}$ which outputs $(c,m_0,m_1,u_0,u_1)$,
	\[
		\Pr
		\left[
			\begin{aligned}
				&m_0\neq m_1\\
				&\mathsf{\Gamma}.\mathsf{Open}(m_0,c,u_0) = \mathsf{\Gamma}.\mathsf{Open}(m_1,c,u_1)
			\end{aligned}
		\right]
		\leq\mathsf{negl}(\lambda)
	\]
	holds.
\end{definition}