\section{Key Management}
\label{sec: key-recovery}

In Section \ref{sec: identity}, we introduce the identifier association mechanism for Sybil resistance. It turns out that this mechanism can also provide the necessary information for key recovery. This section describes leveraging the established infrastructure for key recovery and management.

\subsection{Public Key Refresh}
\label{subsec: key-refresh}

Identifier association constructed in Section \ref{sec: identity} allows aggregating multiple identifiers owned by the same holder into a single associated identifier. A critical insight is that \textit{only the holder itself} knows which identifiers the associated identifier $\mathsf{id}_\mathsf{a}$ is derived from. The holder does not need to disclose this to any other party during interactions. Given this infrastructure, a user can prove ownership of an identifier when losing its corresponding private key, as shown in Figure \ref{fig: key-recovery}.

Specifically, when $\mathcal{H}$ loses the private key $\mathsf{sk}_\mathcal{H}$ of identifier $\mathsf{id}_\mathcal{H}$, it wants to convince the VDR that $\mathsf{id}_\mathcal{H}$ is owned by it. If it has previously aggregated $\mathsf{id}_\mathcal{H}$ into some associated identifier $\mathsf{id}_\mathsf{a}$, it can then construct relations to illustrate this. As in Section \ref{subsec: identity-id-presentation}, it obtains a Merkle proof $\rho_\mathsf{a}$ from the VDR to show that \cirn{182} $\mathsf{id}_\mathsf{a}$ is contained in a Merkle tree rooted at $r_\mathsf{a}$ and that \cirn{183} $\mathsf{id}_\mathsf{a}$ contains $\mathsf{id}_\mathcal{H}$ in its pre-image, i.e.,
	\begin{equation}
	\label{eq: relation-key-refresh-associated}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{a}, \mathsf{id}_\mathsf{a}, \rho_\mathsf{a}) = 1 \\
			& \land\quad \mathsf{id}_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)},\dots,\mathsf{id}_\mathcal{H}^{(n)}\right) \\
			& \land\quad n_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, 1 \right) \\
			& \land\quad \mathsf{id}_\mathcal{H} \in \left\{ \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)} \right\}.
		\end{aligned}
	\end{equation}

$\mathcal{H}$ generates \cirn{184} a new key pair $(\mathsf{pk}_\mathcal{H}',\mathsf{sk}_\mathcal{H}')$ and \cirn{185} a new nullifier $n_\mathsf{reg}'$ to invalidate the identifier for registration, i.e.,
	\begin{equation}
	\label{eq: relation-key-refresh-key-pair}
		\begin{aligned}
			\mathsf{pk}_\mathcal{H}' &\leftarrow\mathsf{PubKeyGen}(\mathsf{sk}_\mathcal{H}'),\\
			n_\mathsf{reg}' &\leftarrow H_1(\mathsf{id}_\mathcal{H},\mathsf{sk}_\mathcal{H}',1).
		\end{aligned}
	\end{equation}

$\mathcal{H}$ generates a proof for Relation \ref{eq: relation-key-refresh-associated} and \ref{eq: relation-key-refresh-key-pair} by:
	\begin{multline}
	\label{eq: proof-key-recovery}
		\pi_\mathsf{key}
			\overm{R}\leftarrow
			\mathsf{\Pi}.\mathsf{Prove}\Big(
				\varsigma,
				\big( r_\mathsf{a}, n_\mathsf{a}, n_\mathsf{reg}', \mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}' \big),\\
				\big( \mathsf{id}_\mathsf{a}, \rho_\mathsf{a}, \{\mathsf{id}_\mathcal{H}^{(i)}\}, \mathsf{sk}_\mathcal{H}' \big)
			\Big),
	\end{multline}
	and sends it to the VDR along with $r_\mathsf{a}$, $n_\mathsf{a}$, $\mathsf{id}_\mathcal{H}$ and $\mathsf{pk}_\mathcal{H}'$. The VDR checks that $r_\mathsf{a}$ is a valid root and $n_\mathsf{a}$ has not been recorded as a nullifier. Finally, the VDR verifies $\pi_\mathsf{key}$ by:
	\begin{equation*}
		\mathsf{\Pi}.\mathsf{Verify}\Big(
			\varsigma,
			\big( r_\mathsf{a}, n_\mathsf{a}, n_\mathsf{reg}', \mathsf{id}_\mathcal{H}, \mathsf{pk}_\mathcal{H}' \big),
			\pi_\mathsf{key}
		\Big)
		\overn{?}=1.
	\end{equation*}
	If the verification passes, the VDR replaces the public key of $\mathsf{id}_\mathcal{H}$ with $\mathsf{pk}_\mathcal{H}'$ in the public ledger. Thus, $\mathcal{H}$ regains a private key $\mathsf{sk}_\mathcal{H}'$ which can control $\mathsf{id}_\mathcal{H}$ and credentials under its name.

% Figure environment removed

\spar{Randomness for better security}
In Section \ref{subsec: identity-accountability}, a random value $u_\mathsf{a}$ is introduced in $\mathsf{id}_\mathsf{a}$ to prevent nullifier-based correlation. It turns out that this $u_\mathsf{a}$ can further improve the security of public key updates. When introducing this random value, instead of proving Relation \ref{eq: relation-key-refresh-associated}, $\mathcal{H}$ should prove that:
	\begin{equation}
	\label{eq: relation-key-refresh-associated-2}
		\begin{aligned}
			& \mathsf{M}.\mathsf{Verify}(r_\mathsf{a}, \mathsf{id}_\mathsf{a}, \rho_\mathsf{a}) = 1 \\
			& \land\quad \mathsf{id}_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, u_\mathsf{a} \right) \\
			& \land\quad n_\mathsf{a} = H_1\left(\mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)}, u_\mathsf{a}, 1 \right) \\
			& \land\quad \mathsf{id}_\mathcal{H} \in \left\{ \mathsf{id}_\mathcal{H}^{(1)}, \dots, \mathsf{id}_\mathcal{H}^{(n)} \right\}.
		\end{aligned}
	\end{equation}

The value of $u_\mathsf{a}$ is known only to $\mathcal{H}$ and is frequently updated during interactions. No one but $\mathcal{H}$ can prove Relation \ref{eq: relation-key-refresh-associated-2} with non-negligible probability.

\spar{Key leakage}
Unlike other key recovery schemes based on secret sharing or certificate escrow, \sysname not only helps in case of key loss but also prevents the key from being compromised. When a key is leaked or stolen by a malicious party, the holder can actively request an update of the public key, which will invalidate the old private key and thus prevent the loss of other digital assets.
