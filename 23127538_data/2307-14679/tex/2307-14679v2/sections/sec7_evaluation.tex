\section{Evaluation}
\label{sec: evaluation}

In this section, we evaluate the performance of \sysname in various tasks and examine deployment and invocation overhead of smart contracts in \sysname.

\subsection{Setup and Implementation}

\spar{Environment}
The devices chosen for our simulation resemble real-world application scenarios. The simulated credential holder runs on a regular consumer-level desktop with an Intel i5-9500F processor and 16 GB of RAM. The credential verifier runs on a desktop with an Intel i7-11700K processor, 32 GB of RAM, and 1 TB of SSD storage. Participants use a home-grade network with a bandwidth of 80Mbps (downlink) / 15Mbps (uplink).

\spar{Primitives}
We implement the arithmetic circuit in \sysname and construct zero-knowledge proofs using the Plonk implementation provided by Dusk \cite{dusk2019plonk, zkcrypto2019bls}, which uses BLS12-381 as the underlying elliptic curve, and the KZG scheme for polynomial commitment \cite{kate2010constant}. \sysname uses the BLS signature based on Jubjub \cite{zkcrypto2017jubjub}, which is a pairing-friendly curve whose base field matches the scalar field of BLS12-381. We use Poseidon as the commitment primitive, which is a zk-friendly sponge construction \cite{grassi2021poseidon}. We use a $t=12$ Poseidon-128 with $R_F=8$ and $R_P=22$, referencing the instantiation of Plonky2 \cite{mir2021plonky}.

%% Figure environment removed

% Figure environment removed

\subsection{Performance}

To evaluate the performance of \sysname in realistic scenarios, we simulate the interactions between the credential holder and the verifier (resp., the VDR) using the above devices and examine the performance of \sysname in the processes of credential presentation, associated identifier generation, and key refresh. Specifically, we focus on parameters such as time consumption of circuit setups, proof generation and verification, and also proof size.

\spar{Circuit setup}
The Plonk protocol used by \sysname uses the Kate scheme for polynomial commitment, which relies on a series of group elements in $\mathbb{G}_1$ and $\mathbb{G}_2$ as a structured reference string (SRS) \cite{kate2010constant}. Figure \ref{plot: setup} illustrates the setup elapsed time under different number of constraints, which increases with the number of constraints. In the Plonk protocol, the number of constraints is determined by both gates and wires, depending on the complexity of statements and relations. For reference, a circuit in \sysname consisting of approximately 32,500 constraints takes about 6.311s for setup. After setup, a circuit can be used repeatedly for proofs of different statements under the same relation.

\spar{Credential presentation}
The proof $\pi_\mathsf{c}$ for Relation \ref{eq: relation-basic} should be generated by the holder in the credential presentation. The operations for signature verification (statement \cirn{183}) dominate the developed arithmetic circuit with about 45,000 constraints, while only about 760 constraints are needed for commitment (statement \cirn{182}). The number of constraints corresponding to statement \cirn{184} depends on the complexity of the claim $s$ and the predicate $\phi$. For reference, we construct several proofs for common scenarios: \cirn{172} age is below/above a certain value; \cirn{173} grade is A, B, or C, but not others; \cirn{174} blood type is not AB. Table \ref{tab: proving-time-constraints} illustrates the elapsed time and constraints to generate $\pi_\mathsf{c}$ for these claims. It is apparent that for common scenarios, the proofs can be generated in less than 10s using consumer-grade devices. The proofs $\pi_\mathsf{id}$ and $\pi_\mathsf{rv}$ for Relation \ref{eq: relation-holder-identity}, \ref{eq: relation-vdr} and \ref{eq: relation-cred-validity} differ from $\pi_\mathsf{c}$ in that the proof times are independent of the inputs. As shown in Table \ref{tab: proving-time-constraints}, proving time for these two proofs are 2.338s and 2.191s, respectively.

\spar{Identifier association}
To associate its identifiers, the holder registers each identifier individually and proves validity with a $\pi_\mathsf{reg}$. The corresponding arithmetic circuit is similar to that of $\pi_\mathsf{id}$ and thus takes a similar time of 3.956s, as can be seen in Table \ref{tab: proving-time-constraints}. Phase 2 of identifier association requires aggregating all registered identifiers with a proof $\pi_\mathsf{a}$ whose circuit is bounded by the number of identifiers $n$. Similarly, the holder needs to provide $\pi_\mathsf{pre}$ on presentation, and $\pi_\mathsf{apd}$ or $\pi_\mathsf{agg}$ on update. The complexity of corresponding circuits is also only related to the number $n$ of identifiers, as shown in Figure \ref{plot: prove}.

% Figure environment removed

\spar{Public key refresh}
The public-key refresh mechanism requires the holder to provide a proof of knowledge of an associated identifier, i.e., Relation \ref{eq: relation-key-refresh-associated} and \ref{eq: relation-key-refresh-key-pair}. It is easy to see that its structure is similar to that of Relation \ref{eq: relation-id-presentation} with only one more overhead about the key relation. Overserving the curves for $\pi_\mathsf{key}$ and $\pi_\mathsf{pre}$ in Figure \ref{plot: prove}, the reader can notice how the structural similarity of arithmetic circuits affects the proving time.

\spar{Proof size and verification time}
Proofs in the Plonk mechanism are of constant length, independent of both statement size and relation complexity \cite{gabizon2019plonk}. The simplest Plonk proof consists of 9 group elements in $\mathbb{G}_1$ and 6 scalars, while the scheme used by \sysname consists of 11 $\mathbb{G}_1$ elements and 16 scalars, with the extra elements for custom gates.

The proof verification time in \sysname is also of constant order and is entirely independent of relations and gates. Specifically, it requires only 2 pairing operations on BLS12-381 and 16 multiplicative operations on the $\mathbb{G}_1$ group. This property is also illustrated in Figure \ref{plot: setup} and Table \ref{tab: proving-time-constraints}, where the verification time remains constant as the constraint varies, taking about 6.5ms on the verifier's device.

\begin{table}
	\centering
	\caption{Cost for proof generation and verification.}
	\label{tab: proving-time-constraints}
	\vspace{3pt}
	\input{tables/proof}
\end{table}

\subsection{Smart Contract Interactions}

\spar{Contract deployment and invocation}
We deployed and tested the smart contracts included in \sysname on the Goerli test network of Ethereum, including a global contract that plays the role of the VDR and the credential commitment contract maintained by credential issuers. The global contract needs to be deployed only once and is visible to all participants during the entire lifecycle of \sysname. Each issuer can deploy multiple credential contracts for committing issued credentials, whose lifecycle depends on the duration of the services provided by the issuer. We summarize the gas consumption for deploying contracts and invoking interfaces in Table \ref{tab: smart-contract}. Due to the optimization of \sysname for storage in smart contracts (cf. Appendix \ref{subapp: misc-merkle}), the gas overhead for all invocations is acceptable.

\begin{table}
	\centering
	\caption{Gas consumption of smart contracts.}
	\label{tab: smart-contract}
	\vspace{3pt}
	\input{tables/contract}
\end{table}

\spar{Proof verification}
Verification of $\pi_\mathsf{reg}$, $\pi_\mathsf{a}$ (cf. Section \ref{subsec: identity-id-association}), $\pi_\mathsf{apd}$, $\pi_\mathsf{agg}$ (cf. Section \ref{subsec: identity-update}) and $\pi_\mathsf{key}$ (cf. Section \ref{sec: key-recovery}) are produced by the VDR relations and public inputs. As mentioned above, the computational overhead of proof verification is independent of the data size. The group elements and scalars required for verification are hard-coded in these contracts,  making the computational complexity of constant order.