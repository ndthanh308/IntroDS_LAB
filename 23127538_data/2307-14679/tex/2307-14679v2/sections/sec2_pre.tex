\section{Preliminaries}
\label{sec: preliminaries}

\subsection{Notation}
\label{subsec: pre-notation}

We denote by $\lambda\in\mathbb{N}$ the security parameter and by $1^\lambda$ its unary representation. In this paper, we assume that all cryptographic algorithms take $1^\lambda$ as input, which is thus omitted from the input lists. If $\mathcal S$ is a finite set, we denote by $x\leftarrow\mathcal S$ the process of sampling $x$ according to $\mathcal S$, and by $x \overm{R}\leftarrow \mathcal S$ a random and uniform one. We denote by $\mathsf{negl}(\lambda)$ a \textit{negligible} function with respect to the security parameter $\lambda$.

Let $H_1:\{0,1\}^*\to\mathbb{Z}_p$ and $H_2:(\mathbb{Z}_p,\mathbb{Z}_p)\to\mathbb{Z}_p$ be two hash functions where $p$ is a big prime integer. We denote by $H_1(a,b)$ the process of concatenating and hashing the binary representations of $a$ and $b$, and so on for more inputs.

\subsection{Non-Interactive Zero Knowledge}
\label{subsec: pre-nizk}

Let $\mathcal{R}$ be a relation generator that takes a security parameter $\lambda$ and returns a polynomial-time decidable binary relation $R$. For pair $(x,w)\in R$, we call $x$ the \textit{statement} and $w$ the \textit{witness}. Given $1^\lambda$, we define the set of all relations that $\mathcal{R}$ may output as $\mathcal{R}_\lambda$. A \textbf{non-interactive argument of knowledge} for $\mathcal{R}$ is a tuple of three polynomial-time algorithms $\mathsf{\Pi}=(\mathsf{Setup}, \mathsf{Prove}, \mathsf{Verify})$ which runs as follows:
	\begin{itemize}
		\item $\varsigma \overm{R}\leftarrow \mathsf{Setup}(R)$: the setup algorithm takes as input a security parameter $\lambda$ and a relation $R\in\mathcal{R}_\lambda$, returning a common reference string $\varsigma$.
		\item $\pi \overm{R}\leftarrow \mathsf{Prove}(\varsigma,x,w)$: the proving algorithm takes as input a reference string $\varsigma$, a statement $x$ and a witness $w$ where $(x,w)\in{R}$, returning an argument $\pi$.
		\item $b \leftarrow \mathsf{Verify}(\varsigma,x,\pi)$: the verification algorithm takes as input the reference string $\varsigma$, a statement $x$ and an argument $\pi$, returning $b=0$ ($\mathsf{reject}$) or $b=1$ ($\mathsf{accept}$).
	\end{itemize}

\subsection{Commitment Scheme}
\label{subsec: pre-commitment}

A \textbf{commitment scheme} for a finite message space $\mathcal{M}$ is a pair of efficient algorithms $\mathsf{\Gamma}=(\mathsf{Commit},\mathsf{Open})$ which runs as follows:
	\begin{itemize}
		\item $c \overm{R}\leftarrow \mathsf{Commit}(m,u)$: the commiting algorithm takes as input a message $m\in\mathcal{M}$ and a random value $u\in\mathcal{U}$, returning a commitment $c\in\mathcal{C}$.
		\item $b\leftarrow\mathsf{Open}(m,c,u)$: the opening algorithm takes as input a message $m\in\mathcal{M}$, a commitment $c\in\mathcal{C}$ and a opening string $u\in\mathcal{U}$, returning $b=0$ ($\mathsf{reject}$) or $b=1$ ($\mathsf{accept}$).
	\end{itemize}
	For all $m\in\mathcal{M}$, if $c$ and $o$ are derived from $m$ by $\mathsf{Commit}$, then $\mathsf{Open}(m,c,o)=1$ holds with overwhelming probability.

\subsection{Merkle Tree}
\label{subsec: pre-merkle}

\textbf{Merkle tree} is a vector commitment scheme (VCS) that commits to a vector $V=(m_1,m_2,\dots,m_n)\in\mathcal{M}^n$ and then opens it at an arbitrary location $i\in\{1,2,\dots,n\}$. Merkle tree hashes all elements in $V$ and recursively hash the result in a pairwise manner using $H_2$ until obtaining a single element $r$ called the Merkle root.

Concretely, a Merkle tree could be abstracted as a tuple of three efficient algorithms $\mathsf{M}=(\mathsf{Build}, \mathsf{Prove},\mathsf{Verify})$ which runs as follows:
	\begin{itemize}
		\item $r\leftarrow\mathsf{Build}(V)$: the building algorithm takes as input all elements $V=\{m_1,\dots,m_n\}$, building a Merkle tree with root $r$.
		\item $\rho\leftarrow\mathsf{Prove}(m,V)$: the proving algorithm takes as input an element $m\in V$, returning a Merkle proof $\rho$ of size $\log_2n$ containing the values of all siblings on the path from $m$ to $r$ in the Merkle tree.
		\item $b\leftarrow\mathsf{Verify}(r,m,\rho)$: the verification algorithm takes as input an element $m$, a Merkle root $r$ and a Merkle proof $\rho$, returning $b=0$ ($\mathsf{reject}$) or $b=1$ ($\mathsf{accept}$).
	\end{itemize}