\section{Results and Discussion} \label{sec:discussion}
% Figure environment removed

The QSVT applies a function, defined by the classically pre-computed $\vec{\phi}$ angles, to the singular values  of a (block encoded) matrix. At no point does a user have access to the singular values; it can be shown that the algorithm just applies a function to the singular values: aka $M = U \Sigma V^{\dagger} \mapsto U f(\Sigma) V^{\dagger}$. However, not knowing what the singular values are has consequences when implementing matrix inversion via QSVT. As discussed in Section \ref{sec:QSP_inverison}, the inverse function is not defined at $x=0$ and so is approximated over the domain $[-1,-\frac{1}{\kappa}]  \cup [\frac{1}{\kappa}, 1]$. If any singular value of the matrix to invert falls outside of this range it will not be transformed properly. This leads to a dilemma, where one needs to know the singular values to determine an appropriate $k$; however, knowing the singular values is the same as solving the inversion problem.  This issue can be resolved in two ways.

The first strategy makes the approximation of $1/x$ arbitrarily small, by using a very large value of $k$. This is somewhat similar to how conventional computers perform mathematical operations to machine precision. However, the degree of polynomial approximating the inverse function scales as \cite{martyn2021grand} :

% https://arxiv.org/pdf/2105.02859.pdf eq 81
 \begin{equation}
\begin{aligned}
    d = \mathcal{O}(k \log(k/\epsilon)).
\end{aligned}
\end{equation}
What this means is as a better polynomial approximation is used (higher $k$ value) the greater the degree of the resulting polynomial will be. As the circuit depth of QSVT scales as $\mathcal{O}(d)$ repeats of the block encoded circuit \cite{martyn2021grand}, using an arbitrarily large $k$ could unnecessarily increase the circuit depth of a given problem. 

The second approach to determine a valid $k$, is to estimate the magnitude of the lowest singular value of a matrix $M\in \mathbb{C}^{n \times n}$ \cite{hong1992lower, piazza2002upper,huang2008estimation, zou2010estimation, zou2012lower}. In  \cite{zou2012lower}, it is shown that:
 
 \begin{equation}
\label{eq:min_sig_value}
\begin{aligned}
    \sigma_{min} \geq |det(M)| \cdot \bigg(\frac{n-1}{\| M \|_{F}^{2} - l^{2}}\bigg)^{(n-1)/2} = \sigma_{min}^{\text{approx}},
\end{aligned}
\end{equation}
which provides a lower bound on the magnitude of the smallest singular value $\sigma_{min}$ of a non-singular $n \times n$ complex matrix $M$. Here, $l= |det(M)| \cdot \big(\frac{n-1}{\| M \|_{F}^{2}}\big)^{(n-1)/2}$ and $\| M \|_{F}$ is the Frobenius norm. Evaluating equation \ref{eq:min_sig_value}, allows $k$ to be determined as: $k \geq 1/\sigma_{min}^{\text{approx}}$. However, this approach requires the determinant of the matrix to be found, which can be costly. A further approximation could be used to estimate $|det(M)|$, such as using the methods in \cite{bai1996some, ipsen2011determinant}.

% We note the preconditioning approach by Tong \textit{et al.} can increase the can also be utilised to transform the problem to have a larger $\sigma_{min}$. 

% \onecolumngrid


% Figure environment removed
 
The two-site SIAM considered in this work is defined on four qubits and so classically performing a singular value decomposition (SVD) of a $(16 \times 16)$ matrix was possible. Therefore, in order to find appropriate $k$, rather than using equation \ref{eq:min_sig_value}, we used the true $\sigma_{min}$. We found all the singular values were above $0.02$ and so used a $k=50$ approximation. This represented a scenario where all the singular values would be inverted properly via the QSVT.  We also simulated a $k=10$ polynomial approximation, where some of the singular values lay below $0.1$ and so wouldn't be inverted properly. The goal was to see what effect this would have. The $k=10$ and $k=50$ polynomial approximations of $1/x$  were represented by $303$ and $1519$ degree  polynomials respectively. Figure \ref{fig:inv_x_qsp} illustrates the  errors of these polynomial approximations compared to the true inverse function.   

For each $k$, we calculated the single particle Green's function at different $z$ for different $U,V$ parameters via QSVT. The outputs were then used to plot the spectral function, which is defined as:

\begin{equation}
\label{eq:spectral_F}
    % A(\omega) = \abs{\frac{1}{\pi} Im\big[G(\omega) \big]}
\begin{aligned}
    A(\omega) &= -\frac{1}{\pi} Tr\Bigg( Im\big[G_{H}(\omega) \big] \Bigg).
\end{aligned}
\end{equation}
The results for $U=4$ and $V=0.745$ are given in Figures \ref{fig:Green_U4_K10} and \ref{fig:Green_U4_K50}. The results for the other $U,V$ regimes are given in Appendix \ref{sec:A_omega_plots}. As this problem is defined over $4$ qubits, exact diagonalization solutions were possible to compute classically. In Figures \ref{fig:Green_U4_K10}, \ref{fig:Green_U4_K50} and those in Appendix \ref{sec:A_omega_plots}, we provide the lowest singular value of the matrix to undergo QSVT matrix inversion. As expected, we observe that whenever the singular value lies below $1/k$, the error in the spectral function becomes large. This can be seen for $k=10$, where in Figure  \ref{fig:Green_U4_K10} errors due to $\sigma$ being below $0.1$ can sometimes differ from the real answer by $\Delta A(\omega) \approx 1$. Whereas, in Figure \ref{fig:Green_U4_K50} all singular values lie above $0.02$ and the error in $A(\omega)$ remains at $\Delta A(\omega) \approx 10^{-12}$.

% Figure environment removed

%% https://physics.stackexchange.com/questions/29542/what-do-the-poles-of-a-green-function-mean-physically

Looking at the Green's function definition in equation \ref{eq:G_funct}, we see that when the real part of $z$ is equal to $\pm \lambda_{i}\mp E_{0}$ (where $\lambda_{i}$ is an eigenvalue of $H$), then the real part of the denominator in either the advanced or retard Green's function vanishes leading to a so called ``pole''. For a non-interacting system, where the eigenfunctions are represented by single-configuration states, the amplitudes and Lehmann energies $\omega$ are equal to the eigenfunctions and eigenvalues of the corresponding one-electron Hamiltonian \cite{onida2002electronic}.  The spectral function consists of a set of peaks at those eigenvalues and each peak is associated with a particle \cite{onida2002electronic, aryasetiawan1998gw}.  When interactions are considered, the eigenfunctions are no longer single-configuration states, instead they are in general normalised linear combinations of them. There will now be more non-vanishing contributions to the spectral function,  by merging these contributions they will form a structure which can be thought of as deriving from peaks when the interactions are turned off \cite{onida2002electronic}. This allows one to work in a particle-like picture; however, each peak is now associated with a ``quasiparticle'' \cite{onida2002electronic, aryasetiawan1998gw}. The spreading of the peak contains information about many-body correlation effects in the interacting system  \cite{onida2002electronic}. The spectral function is usually peaked at each energy $E_{i} = \epsilon_{i} + Re \Delta \Sigma_{i}(E_{i})$, with a lifetime given by $1/ Im \Sigma_{i}(E_{i})$ where $\Sigma$ is the self-energy operator. Further details on this are discussed in \cite{aryasetiawan1998gw}.

From the calculated Green's functions, we then plot the Mott phase transition by plotting the density of states on the Bethe lattice \cite{eckstein2005hopping} for different $U,V$ regimes at different $z$. The $k=50$ result is summarised in Figure  \ref{fig:mott_k50}. Qualitatively, our results are similar to related work -  see Figure 3 in \cite{zhang1993mott} and Figure 4 in \cite{sriluckshmy2021fully}. We provide error details and the $k=10$ result in Appendix \ref{sec:mott_appendix}. From Figure \ref{fig:mott_k50} we see that the QSVT result matches well with the true (exact diagonalization) results. The error of the QSVT approach, for the $k=50$ polynomial approximation, for each data point is around the $10^{-12}$ level. Wheres, we obtain much larger error for the $k=10$ approximations ranging from the $10^{-12}$ to $10^{-2}$ level. This is due to errors occurring when the singular values are below $0.1$, which are then not inverted properly leading to errors in the calculated single particle Green's function and thus the spectral function. 

%% SEE:
% 1. https://arxiv.org/pdf/cond-mat/9712013.pdf
% 2. Onida, Reining, and Rubio: Density-functional vs many-body


\section{Improved LCU Circuits} \label{sec:LCU_circuits}

In Section  \ref{sec:block}, we reviewed the LCU technique \cite{childs2012hamiltonian, low2017optimal} and then proposed an efficient way to construct the ``$\select$'' operator when defined as a linear combination of Pauli operators.  This strategy came from a combination of ideas presented in \cite{ralli2021implementation, bullock2003smaller, da2022linear} - see Table \ref{table:circuit_summary} which summaries the different costs. The overall cost to implement a LCU block encoding via this approach has a circuit cost scaling as  $O\big( \underbrace{|A|}_{\prep}  + \underbrace{|A|  \log_{2}(|A|)^{2}+ |A|n_{s}}_{\select} + \underbrace{|A|}_{\prep^{\dagger}}\big)$ CNOT and single-qubit gates.  Here $n_{s}$ is the number of system qubits. Our work is distinct from the approach in \cite{low2018trading}, which is a more fault tolerant approach to the problem, \cite{wan2021exponentially} that focuses on second-quantised fermionic Hamiltonians, and \cite{camps2022fable}, which uses ideas of multiplexors to reduce the gate-complexity. The FABLE approach is a different block encoding technique to the LCU method, where a defined matrix is decomposed into a block encoding. This makes a direct comparison hard. The FABLE method also requires $n+1$ ancillary qubits, rather than $\lceil \log_{2}(|A|) \rceil$ for a LCU, and has a single- and two-qubit gate cost scaling as $\mathcal{O}(2^{2n})$. We re-iterate that these block encoding methods differ in how the matrix to block encoding is defined and thus their expected applications are different. However, for problems where the Hamiltonian is defined as a linear combination of unitaries, the circuit implementation of LCU presented in this work will result in quantum circuits with exponentially fewer gates. The intuition comes from the LCU method requiring exponentially fewer ancillary qubits to perform the block encoding. For example, in \cite{camps2022fable} they apply the FABLE approach to different Hubbard Hamiltonians. In this scenario our approach will require exponentially fewer single- and two-qubit gates.
