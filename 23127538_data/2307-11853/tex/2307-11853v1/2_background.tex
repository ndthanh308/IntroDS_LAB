% \vspace{0.05in}
\section{Background and Related Work}
\label{sec:background}\label{sec:relatedwork}
\vspace{-0.05in}

\lstdefinestyle{lst}{
    float=tp,
    floatplacement=tbp,
    % abovecaptionskip=0.01in,
    numbers=left, 
    numberstyle=\scriptsize, 
    numbersep = 5pt,
    framexleftmargin = 0in,
    framexrightmargin = 0in,
    breaklines = true,
    xleftmargin = 0.18in,
    xrightmargin = 0.1in,
    basicstyle=\ttfamily\scriptsize, 
    frame=lines,
    showtabs=true,
    showspaces=true,
    showstringspaces=false,
    literate={\ }{{\ }}1,
    aboveskip=+0.15in,
    belowskip=-0.00in,
}

\begin{lstlisting}[
language=diff, 
style=lst,
caption=An example of security commit (CVE-2021-27213).,
label={lst:security commit},
mathescape=true
]
 $\textbf{commit dbeb87afefdb63de2f4cff69b6f10c5965d14b54}$ 
 Subject: [PATCH] Fixed code execution bug using SafeLoader()
 diff --git a/pystemon/config.py b/pystemon/config.py
 @@ -315,7 +315,7 @@ def _load_yamlconfig(self
 yamlconfig = None
 ...
 for includes in yamlconfig.get("includes", []):
    try:
        logger.debug("... '{0}'".format(includes))
-       yamlconfig.update(yaml.load(open(includes)))
+       yamlconfig.update(yaml.safe_load(open(includes)))
    except Exception as e:
        raise PystemonConfigException("failed to load '{0}': {1}".format(includes, e))
 return yamlconfig

\end{lstlisting}


\lstdefinestyle{lst}{
    float=tp,
    floatplacement=tbp,
    % abovecaptionskip=0.01in,
    numbers=left, 
    numberstyle=\scriptsize, 
    numbersep = 5pt,
    framexleftmargin = 0in,
    framexrightmargin = 0in,
    breaklines = true,
    xleftmargin = 0.18in,
    xrightmargin = 0.1in,
    basicstyle=\ttfamily\scriptsize, 
    frame=lines,
    showtabs=true,
    showspaces=true,
    showstringspaces=false,
    literate={\ }{{\ }}1,
    aboveskip=-0.00in,
    belowskip=-0.2in,
}

\begin{lstlisting}[
language=diff, 
style=lst,
caption=An example of non-security commit.,
label={lst:non-security commit},
mathescape=true
]
 $\textbf{commit 4cd1067faf3df14dbbe7eb6de2bd7693d5cd829a}$ 
 diff --git a/IPython/lib/security.py b/IPython/lib/security.py
 @@ -109,7 +109,7 @@ def passwd_check(hashed_passphrase, passphrase):
     except ValueError:
         $\textbf{return}$ False
-    if len(pw_digest) == 0 or len(salt) != salt_len:
+    if len(pw_digest) == 0:
         $\textbf{return}$ False
\end{lstlisting}

\subsection{Security and Non-security Commits} 
On the version control platforms such as GitHub, a commit is %a set of changes between two versions of source code to improve security, resolve functionality issues, and add new features. A commit is composed of a directory tree object hash, parent commit hash, author, committer, date and message, and the changed code. As shown in List~\ref{lst:security commit}, we include the object hash (e.g., $f8c2095$), commit message (e.g., Subject), and the code change.
mainly composed of two parts: a set of code changes between two versions and a descriptive message including the subject line and body (if any). In Listing~\ref{lst:security commit}, Lines 5-14 are the source code changes and Line 2 presents a commit message with only one subject line.

A security commit includes code changes made to a software codebase, addressing a security vulnerability defined by an individual Common Weakness Enumeration (CWE) Specification~\cite{CWE_slice}. 
Security commits are typically critical updates that need to be applied as soon as possible to prevent attackers from exploiting vulnerabilities. 
List~\ref{lst:security commit} shows a security commit example fixing the vulnerability CVE-2021-27213 by replacing \texttt{\small yaml.load()} with \texttt{\small yaml.safe\_load()} to load the content in a safer way.
%
Non-security commits are the changes made to the software codebase that do not relate to security issues. 
These changes include fixing non-security-related bugs, adding new features, improving performance, and updating documentation. 
Typically, non-security commits are not as urgent as security commits and can be applied later without affecting software security. 
In List~\ref{lst:non-security commit}, a non-security commit removes the unnecessary check on password salt length.



% \begin{lstlisting}[
% language=diff, 
% style=lst,
% caption=An example of a security commit (CVE-2021-21371).,
% label={lst:security commit},
% mathescape=true
% ]
%  $\textbf{commit f8c2095fd529e664e7fa25403a0a4a85bb3907d0}$ 
%  Subject: [PATCH] switched load() to safe_load() to not load serialized python objects.
%  diff --git a/tenable_jira/cli.py b/tenable_jira/cli.py
%  @@ -62,7 +62,7 @@ def cli(configfile,
%      # basic field set.
% -    config_from_file = yaml.load(configfile, Loader=yaml.Loader)
% +    config_from_file = yaml.safe_load(configfile)
%      fields = config_from_file.pop('custom_fields', list())
% \end{lstlisting}



% https://huntr.dev/bounties/be7f211d-4bfd-44fd-91e8-682329906fbd/

%\yunlong{The reason to use CPG is too simple. More detailed advantages can be added. The definition of AST and CFG can be removed.}

% \noindent{\bf Code Property Graph.} A code property graph (CPG)~\cite{y2014cpg} of a program is a graph representation of the program obtained by merging its abstract syntax trees (AST), control-flow graphs (CFG) and program dependence graphs (PDG) at statement and predicate nodes. %AST is a code representation generated by the syntax analysis of a compiler. CFG is a graph structure that represents all the possible traversed paths during program execution. PDG comprises of control dependency graph (CDG) and a data dependency graph (DDG) to represent the control and data dependencies, respectively~\cite{ferrante1987program}. 
% By containing unique structural information of programming language including control flow, control dependency, intra-procedural data dependency, and program syntax, CPG provides a much more comprehensive view for code static analysis compared with traditional sequential structure adopted by NLP works~\cite{guo2020graphcodebert}.


% \section{Related Work}


%In this section, we first analyze the related studies on security commit datasets, security commit detection, and graph-based source code analysis. Then, we emphasize the novelty of our study.

\subsection{Security Commit Datasets} 
Security commits provide plentiful information on both the existing vulnerabilities and the corresponding fixes. 
Thus, researchers construct such datasets for security commit detection and automated program repair~\cite{ponta2019manually, fan2020ac, wang2021patchdb, nikitopoulos2021crossvul, bhandari2021cvefixes, chen2023diversevul}.
% research groups working on security commit detection and program repair construct such datasets continuously~\cite{ponta2019manually, ponta2019manually, fan2020ac, wang2021patchdb, nikitopoulos2021crossvul, bhandari2021cvefixes, chen2023diversevul}.
However, existing datasets only focus on specific projects \cite{ponta2019manually, zhou2021spi} or contain limited security commits associated with CVEs~\cite{fan2020ac, bhandari2021cvefixes}.
% What's worse, a vast majority of security commits are not publicly published in NVD.
% ~\cite{ponta2019manually, zhou2021spi} focus on specific projects, and~\cite{fan2020ac, bhandari2021cvefixes} only contain security commits associated with CVEs. 
Although some researchers also consider both commits indexed by NVD and silent fixes~\cite{wang2021patchdb, nikitopoulos2021crossvul, chen2023diversevul}, 
% Although~\cite{wang2021patchdb, nikitopoulos2021crossvul, chen2023diversevul} pay attention to both patches indexed by NVD and silent fixes, 
they solely investigate the commits in C/C++ and Java, neglecting the popularity of Python. 
% What's worse, a vast majority of security commits are not publicly published in NVD. %and the data from MITRE~\cite{cve} are limited. 
Besides, %the security-related features from their work are language-dependent, 
the existing works adopt language-dependent security-related features, which cannot be directly migrated for collecting security commits in Python. 
% These limitations motivate us to build a large-scale real-world dataset of Python security commits from various types of projects.


\subsection{Security Commit Detection} Numerous commits are submitted to GitHub every day, while 6-10\% of them are silent security fixes~\cite{li2017large, wang2019detecting}. To identify security commits automatically and effectively, \cite{zhou2017automated} analyzes the natural language description of commit messages and bug reports. However, this approach only relies on well-maintained documentation, which is impractical for detecting silent security patches. 
Thus, some researchers detect security commits by extracting code features manually~\cite{wang2021patchdb, sawadogo2020learning}.
Wang et al.~\cite{wang2021patchrnn} ensemble two BiLSTM models to learn not only the commit message but also the code changes. %simultaneously. 
Similarly, SPI~\cite{zhou2021spi} adopts LSTM to learn the representation of commit message and utilizes CNN to learn the representation of code revision. 
As the prevalence of applying large language model on code analysis, CodeBERT~\cite{feng2020codebert} is fine-tuned to learn the semantics of code changes~\cite{zhou2021finding}. 
Zhou et al.~\cite{zhoucolefunda} increase the fix data at the function level and then generalize the code change semantic with contrasting learning.
 
% Wang et al.~\cite{wang2021patchrnn}, Wang et al.~\cite{wang2022graphspd}, Kim et al.~\cite{kim2017vuddy} vuddy, Li et al.~\cite{li2016vulpecker} vulpecker, Li et al.~\cite{li2017large}, Xiao et el.~\cite{xiao2020mvp}, Wu et al.~\cite{wu2022enhancing}, Zhou et al.~\cite{zhou2021finding}, Zhou et al.~\cite{zhoucolefunda}

%\subsection{Graph-based Source Code Analysis}

To preserve the inherent structural semantics of code, %Yamaguchi et al.~\cite{y2014cpg} introduced a novel representation named code property graph that merges concepts of classic program analysis, namely abstract syntax trees, control flow graphs and program dependence graphs, into a joint data structure. 
CLozoya et al.~\cite{cabrera2021commit2vec} and Wu et al.~\cite{wu2022enhancing} employ BiLSTM to learn the representation of commits from their AST paths. Wang et al.~\cite{wang2022graphspd} propose GraphSPD to represent C/C++ commits with code property graphs and learn the representation with GNN.

% In this paper, we first enrich the semantic variety by fully leveraging the commit message and code changes.
% To facilitate the understanding of Python security commits, we also capture both the sequential and structural semantics of code changes via graph learning-based model.

% then propose a graph-learning-based model to capture the sequential as well as structural semantics of the code change to expand the \db{} and facilitate the understanding of Python security commits.

\subsection{Novelty of Our Study}

\noindent{\bf Dataset.} We build the first security commit dataset in Python, which contains 1,258 security commits and 2,791 non-security commits extracted from over 351 popular GitHub projects, covering 119 more CWEs.
% We fully leverage the semantics from the commit message and commit code change. 
Different from the SPI~\cite{zhou2021spi} based on keyword filtering and PatchDB~\cite{wang2021patchdb} based on code similarity, we consider both commit message and code changes so that the dataset can cover more diverse security commits, especially for the commits without any clear commit message.

% Compare to SPI~\cite{zhou2021spi}, we extract keywords automatically with topic modeling algorithms and mine the commits without a clear commit message; Compare to PatchDB~\cite{wang2021patchdb}, we introduce more variance of code change semantics besides the semantics from the CVE fixes. We publish the first Python security commit dataset. 

\noindent{\bf Commit Representation.} 
To better represent the commits, we preserve the code structure via the graph representation \cpg{} and also consider the sequential information via CodeBERT~\cite{feng2020codebert}.
However, the existing works either consider the sequential information~\cite{zhou2017automated, wang2021patchrnn, zhou2021finding, zhoucolefunda} or keep the structural semantics~\cite{wang2022graphspd}.

% Compare to SOTA works(\cite{zhou2017automated},~\cite{wang2021patchrnn}, ~\cite{zhou2021finding},~\cite{zhoucolefunda}) that leverage sequential models to learn the commit representation while ignores the essential semantics from the inherent structural attribute, we propose CommitCPG represent each commit. 

% CommitCPG maintains the sequential semantic and structural semantics with a multi-attributed directed code property graph. 

% Additionally, compared with GraphSPD~\cite{wang2022graphspd} that preserved the structural information yet overlook the sequential information, we fine-tune CodeBERT~\cite{feng2020codebert} to keep the sequential information with the node embedding and forward them to the commit overall representation.

\noindent{\bf Commit Understanding.} 
% In addition to pinpointing the security commit, 
We conduct a comprehensive study on understanding how the security commits fix Python vulnerabilities. 
The commit patterns can be used to generalize vulnerability fix schemes, which may enhance software maintenance and provide insight into automated program repair.