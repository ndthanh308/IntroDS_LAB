\section{Introduction}

% why python?
% 1. Python is the most popular programming language
% 2. #vulnerability increase, while corresponding fixes are still lacking
% 3. Python is easy to learn and use; unlike C/C++, developers are not well-trained and may lack a sense of writing code properly and safely

According to the TIOBE index~\cite{tiobe2}, Python overtakes Java and C as the most popular programming language as of  April 2023. 
However, a recent study~\cite{ruohonen2021large} reveals that among 749K security issues of 197K Python packages in PyPI~\cite{pypi}, only 1,232 vulnerabilities are reported to CVE~\cite{cve} and only 556 of them have public fixes.
Thus, most security issues are not indexed and may only be resolved by ``silent" fixes, without explicit log messages indicating the vulnerabilities. % or indexing to CVE.
% most of the security issues have not been indexed or fixed ``silently" (i.e., push the commit(s) to the source code repository, without explicit log messages indicating the vulnerability or indexing to CVE).
% \sw{While a recent study~\cite{ruohonen2021large} finds over 749K security issues from 197K Python packages in PyPI~\cite{pypi} (the most popular Python package management website), there are only 1,232 vulnerabilities reported to CVE~\cite{cve}, and only 556 of them have public fixes, which suggests most of the security issues have not been indexed or fixed ``silently" (i.e., push the commit(s) to the source code repository, without explicit log messages indicating the vulnerability or indexing to CVE).}

The hidden security fixes pose a threat to the security and privacy of users, since attackers may exploit the undisclosed vulnerabilities to comprise the unpatched software systems.
% Thus, the security \sw{issue} and its corresponding fixes have been disclosed, \sw{which damages} the user's security and privacy. 
Particularly, Python is friendly to beginners; however, with limited security knowledge, learners may be unable to determine if an upstream commit is intended to address a vulnerability and hence neglect a critical security fix.
% \sw{Besides, since Python is a beginner-friendly language, novices may lack a sense of security and blindly trust repositories and install packages from these sources, assuming they are secure.} 
The implicit security commits can impair software maintenance and evolution since the downstream developers may not be aware of the criticality of these security commits.
% These undisclosed security fixes may impair the software maintenance 
% Sometimes \sw{malware} packages are allowed to be uploaded to the package repository, giving malicious actors the opportunity to use repositories to distribute viruses and launch successful attacks on \sw{both} developers' machines. 
Therefore, it is vital to identify the hidden security commits among all Python commits.

% add one 0-day example?

% existing work and their limitation
% no Python dataset
% fail to consider sequential and structural semantics at the same time
% no thorough analysis of vulnerability fixes in Python 
The existing datasets and methods are insufficient for security commit detection in Python. To identify security commits, researchers first build commit datasets~\cite{wang2021patchdb,ponta2019manually} and then either extract features manually from commit messages/code changes~\cite{li2017large,wang2021patchdb,kim2017vuddy} or learn features automatically via deep learning models, e.g., recurrent neural networks (RNN)~\cite{wang2021patchrnn,li2016vulpecker}, Transformers~\cite{zhoucolefunda,zhou2021finding}, and graph neural networks (GNN)~\cite{wang2022graphspd,wu2022enhancing}.
% (e.g., Recurrent Neural Network (RNN), Transformer and Graph Convolutional Network (GCN))~\cite{,,,}.
However, these solutions have three main constraints, namely, limited data variety, non-comprehensive code semantics, and uninterpretable learned features.
% \sw{ignorance of sequence or structural semantics, and uninterpretable learned features}. 
First, existing works~\cite{zhou2021spi,wang2021patchdb,ponta2019manually} only construct security commit datasets in C/C++ or Java, and there is no available Python dataset for security commit research.
% First, previous work~\cite{zhou2021spi,wang2021patchdb,ponta2019manually} only focuses on curating C/C++ and Java datasets, which ignores the prevalence of Python. \sw{...} 
%Second, the existing feature extraction methods are inapplicable to Python security commit detection. (ks: the model can be applied to Python, just the features are different).
Second, the existing feature extraction methods cannot be directly applied to Python security commit detection. The manually extracted features~\cite{li2017large,wang2021patchdb} are language-dependent and cannot be directly migrated to the Python language.
% Furthermore, the features extracted manually from previous work~\cite{li2017large,wang2021patchdb} cannot be transferred to Python project analysis since the features are language-dependent. 
Also, the existing deep learning features~\cite{wang2021patchrnn,zhou2021finding,zhou2021spi,wang2022graphspd} are incapable of integrating both the sequential and structural semantics of code since the RNN and Transformer-based models simply treat code as a natural language~\cite{hochreiter1997long, feng2020codebert} and the GNN-based models only focus on the code dependencies~\cite{wang2022graphspd, wu2022enhancing}.
% While the deep-learning-based methods~\cite{wang2021patchrnn,zhou2021finding,zhou2021spi,wang2022graphspd} either only focus on the sequential semantic with RNN and Transformer-based models (e.g., LSTM~\cite{hochreiter1997long} and CodeBERT~\cite{feng2020codebert}) or focus on inherent structural semantics with Graph Neural Networks~\cite{}. 
% Even~\cite{wu2022enhancing} combined the Abstract Syntax Tree (AST) with graph learning, this paper still ignored the semantics from the data flow and control flow. 
Third, though manually extracted features are interpretable, feature extraction methods  can only provide limited accuracy. In contrast, deep learning based methods may yield better accuracy, but their learned features are uninterpretable.

% \sw{In addition, although the manually formed features are interpretable, they can only achieve a relatively low accuracy; while automatically extracted features will bring higher accuracy, their learned features are uninterpretable.}


% our dataset: real-world, large, diverse
% base: cve
% pilot: increase the sample variety to compensate for the missing fixes of more 50% cves using commit msg
% augmented: increase the sample variety to compensate for the missing commit msg using patchgnn

To tackle the above challenges, we construct the first security commit dataset in Python, named \db{},\footnote{This dataset is released in \href{https://github.com/SunLab-GMU/PySecDB}{https://github.com/SunLab-GMU/PySecDB}.} by collecting the samples from CVE records and filtering the commits from GitHub. It consists of three subsets: a base dataset, a pilot dataset, and an augmented dataset.
% curated from GitHub and consisting of three subsets: base dataset, pilot dataset, and augmented dataset.
%
%\vspace{0.01in}
%\noindent {\bf Base Dataset.} 
We first build a base dataset by collecting the security commits associated with CVE IDs~\cite{cve}. Since the CVE records on Python programs are limited, we observe that  only 46\% of them provide the corresponding security commits and more security commits fall in the wild silently, without being indexed by CVE.
% contains security commits associated with CVEs~\cite{cve}. However, \sw{..} more than 50\% of CVEs have not linked the corresponding fixes to the records, which reveals that these patches exist in the wild silently. 
%
%
%\vspace{0.01in}
%\noindent {\bf Pilot Dataset.}
To enrich security commits for covering more vulnerability types, we construct a pilot dataset by filtering GitHub commits. Since only 6-10\% of GitHub commits are related to security fixes~\cite{wang2021patchdb}, filtering commit messages using relevant keywords can efficiently narrow down the list of security commit candidates.
%%
% In order to \sw{make up for such deficiency}, we construct the \textit{Pilot Dataset}. 
% \sw{Since it is well known that only 6-10\% of commits are security fixes in GitHub~\cite{wang2021patchdb}, we propose a keyword filtering algorithm with a human-in-the-loop mechanism to mine security commits effectively and efficiently.} 
The security keywords are automatically extracted from the commits in the base dataset by the Latent Dirichlet Allocation (LDA) method~\cite{blei2003latent}. Then, three  security experts manually verify the candidate commits and build the pilot dataset.
% \sw{We manually verify the commits that mention security keywords in their commit message and the validated commits from the pilot dataset.} 
Well-documented commit messages are required for the pilot dataset construction, but not all commits provide commit messages.
% It is worth to be noticed that a well-documented commit message is required for building the pilot dataset, which is usually lacking in most of the repositories. 


%%
%\vspace{0.01in}
%\noindent {\bf Augmented Dataset.}
To include more diverse security commits that do not provide sufficient commit messages, we extend the base and pilot datasets with an augmented dataset by considering the semantics of code revisions.
% To \sw{compensate for such insufficiency} and introduce more diverse samples, we extend the base and pilot datasets with the \textit{Augmented Dataset}. 
% method
We develop a new commit graph representation named \cpg{} and a graph learning model named \gnn{} %(\underline{S}ecurity \underline{CO}mmit in \underline{PY}thon) 
to capture the semantics of code changes. Inspired by~\cite{y2014cpg}, our \cpg{} is constructed by merging the code property graphs of the previous and current versions.
% cpg
% Inspired by~\cite{y2014cpg}, \cpg{} represent each commit in a directed attributed graph, merged from the code property graph of the current version source code and the previous version source code at the common statements nodes. 
In \cpg{}, each node presents a statement with its version information; each edge preserves the semantic level dependency between two statements.
% Each node stores a statement and the edges contain the dependency among each node. 
% Specifically, the nodes consider the added/deleted/updated statements, as well as the unchanged statements; the edges preserve the semantic level dependencies, including data dependency and control dependency. 
To reduce analysis overhead, we perform program slicing~\cite{weiser1984program} over \cpg{}s to remove the nodes/edges irrelevant to the commits.
% We further perform program slicing~\cite{weiser1984program} to reduce the overhead from the node and edges irrelevant to the changes. 
Given a \cpg{}, \gnn{} embeds the node statements using CodeBERT~\cite{feng2020codebert} and embeds the edge attributes as one-hot vectors to contain the edge versions and the syntax/dependency relationships.
% \sw{Given the \cpg{}, \gnn{} utilizes CodeBERT~\cite{feng2020codebert} to extract the sequential semantic of each node and encodes edges with the dependency of ``where-the-value-comes-from" between variables and the dependency of ``what-the-next-statement-to-be-executed" among each line of code. }
% verify them manually, and construct the augmented dataset with the verified candidates.
% gnn
% With the embedded \cpg{}, a graph convolutional network with multi-head attention is trained on the base and pilot datasets to distinguish security commits from non-security ones. 
% classify
% We next apply the trained model to pinpoint the security commits candidates from the wild and examine them manually, and construct the augmented dataset with the verified candidates.
Then, a graph convolutional network with multi-head attention is trained over the base and pilot datasets. Finally, we apply \gnn{} to identify the security commit candidates from the wild and build the augmented dataset after manual verification.




% CommitCPG provided comprehensive and concise semantics information of commit by merging and slicing the code property graph~\cite{y2014cpg} of the current commit and previous commit code. Given the graph representation of each commit, \gnn{} preserves the sequential semantic by encoding the statements with CodeBERT~\cite{feng2020codebert} and preserves the structural-semantic by encoding the relationship of the statements at the abstract syntax tree, data dependency, and control dependency level. With the encoded CommitCPG, \TN{} trained a multi-attributed graph convolution mechanism to adapt diverse relationships in CommitCPG.

% statistics of the collected db, #, cwe, repos

To enhance the variety of commits beyond the base dataset, we construct the pilot and augmented datasets over popular repositories.  We evaluate the efficiency of data collection using the ratio of security commits to the total number of candidates. Compared with random selection, the keyword filtering method and \gnn{} can improve the efficiency by 30 and 40 percentage points when constructing the pilot and augmented datasets, respectively.
% We expand the base dataset over popular repositories. 
% Compared with randomly verifying the candidates, the keyword filtering mechanism improves the \sw{30\%} of security commit rate and SCOPY improves by nearly 40\%.  
In total, \db{} contains 1,258 security commits associated with 119 distinctive CWEs across 351 repositories, providing sufficient diversity in vulnerability types and application scenarios.
% After two rounds of augmentation, we collect 1,258 security commits associated with 119 distinctive CWEs and these commits span across 351 repositories, revealing the diversity in vulnerability categories and application scenarios. 
We also find that unique patterns exist in the pilot and augmented datasets, respectively, since these two datasets are built from different perspectives, i.e., commit messages and code changes.
% We also detect unique patterns only appearing in the pilot dataset and augmented dataset, illustrating the variety of collected samples from the code change perspective.

% findings for software maintenance


To facilitate software maintenance, we conduct an extensive case study on the security commits in \db{} and discover four common security fix patterns, i.e., {\em add or update sanity checks}, {\em update API usage}, {\em update regular expressions}, and {\em restrict security properties}. 
% We continue to extract detailed patch templates based on the application scenarios. 
First, security commits often include sanity checks (i.e., verify if certain conditions are true) to secure critical operations, especially in the authentication and authorization scenarios. 
% The authentication and authorization will be guaranteed with a well-defined sanity check, which shields the permission from being broken and assure the resources are consumed by authorized users. 
Second, since Python provides multiple pre-built packages, security commits can address vulnerabilities by replacing APIs, e.g., APIs related to strings, paths, and commands.
% Also, we reveal a set of secure APIs that should be adopted to process path names, HTML files, and commands, in order to avoid being exploited with path traversal, and cross-site scripting vulnerabilities. 
Third, security commits can handle secure escapes by updating regular expressions, which protect software from being injected by shell commands, SQL queries, and web scripts.
% At the same time, It will deal with the escapes more properly by updating the regular expression, so as to protect the software users from being injected in the shell command, SQL queries, or scripts of web page generation. 
Fourth, security commits can update security properties (e.g., security flags, restriction arguments, and security decorators) to ensure the effectiveness of security mechanisms or policies.
% Meanwhile, the security-related arguments should be set carefully to make sure that the security mechanism or policies are working. 
These fix patterns can be generalized and formulated into intermediate representations to facilitate secure software development and automated program repair.



%%%
In summary, our paper makes the following contributions:
\begin{itemize}
    \item We construct the first security commit dataset in Python by screening CVE records and GitHub commits. 
    \item We design a keyword filtering method to identify the potential security commits based on the commit messages.
    \item Based on code changes, we propose a new commit graph representation \cpg{} and a graph learning model \gnn{} to locate the security commit candidates.
    % \item We propose a comprehensive intermediate commit representation in the directed attribute graph format and develop a robust graph-based learning algorithm to pinpoint and discover security commits by fully leveraging the sequential and inherent structural semantics from the commit code change.
    \item To facilitate software maintenance, we discover four common security fix patterns, which  provide insights in vulnerability detection and program repair in Python.    
    % To assist with the maintenance of the software, we manually analyze the fix patterns and reveal four common patterns, covering 80\% samples, which could be applied to automated program repair projects.
\end{itemize}

% \noindent {\bf Raodmap.} This paper is organized as follows: Section \ref{sec:background} introduces background information and related work. We elaborate on our data collection methodology in Section \ref{sec:design}. Section \ref{sec:implementation} presents the experimental procedures. In Section \ref{sec:experiment}, we present the exhaustive analysis result on the collected dataset, including the statistics of the dataset and the summarized four security vulnerability fix patterns. And we discussed the unreported vulnerability fixes, the ethical consideration, the other application scenarios, the commit messages of silent vulnerability fixes, and time efficiency in Section~\ref{sec:discussion}. Sections \ref{sec:threats} cover the possible threats to validity. We conclude this paper and discuss future work opportunities in Section \ref{sec:conclusion}.

