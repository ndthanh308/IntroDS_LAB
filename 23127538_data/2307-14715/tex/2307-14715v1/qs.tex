%\documentclass[pra,preprint]{revtex4}
%\documentclass[aps,showpacs,prx,twocolumn,superscriptaddress]{revtex4}
%\input{tcilatex}showpacs,
\documentclass[pra,twocolumn]{revtex4}

%\documentclass[pra,superscriptaddress,reprint,twocolumn]{revtex4}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{epsfig,amsmath}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{stmaryrd}
\usepackage{mathrsfs}
\usepackage{pifont}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{latexsym}
\usepackage{hyperref}
\usepackage{color}

\usepackage{algorithmic}
\usepackage{algorithm}

\setcounter{MaxMatrixCols}{10}
%TCIDATA{OutputFilter=Latex.dll}
%TCIDATA{Version=5.50.0.2960}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%TCIDATA{LastRevised=Wednesday, October 30, 2019 10:49:57}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}

\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}
\newcommand{\beqa}{\begin{eqnarray}}
\newcommand{\eeqa}{\end{eqnarray}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
\newcommand{\lam}{\lambda}
\newcommand{\ti}{\tilde}
\newcommand{\ga}{\gamma}
\newcommand{\Ga}{\Gamma}
\newcommand{\ka}{\kappa}
\newcommand{\da}{\dagger}
\newcommand{\De}{\Delta}
\newcommand{\al}{\alpha}
\newcommand{\si}{\sigma}
\newcommand{\Si}{\Sigma}
\newcommand{\om}{\omega}
\newcommand{\Om}{\Omega}
\newcommand{\de}{\delta}
\newcommand{\K}{{\cal K}}
\newcommand{\non}{\nonumber}
\newcommand{\pa}{\partial}
\newcommand{\new}[1]{\textcolor{blue}{#1}}
%\input{tcilatex}
\begin{document}

\title{{Enhanced quantum state preparation via stochastic prediction of neural network}}
\date{\today }

\begin{abstract}
In pursuit of enhancing the predication capabilities of the neural network, it has been a longstanding objective to create dataset encompassing a diverse array of samples. The purpose is to broaden the horizons of neural network and continually strive for improved prediction accuracy during training process, which serves as the ultimate evaluation metric. In this paper, we explore an intriguing avenue for enhancing algorithm effectiveness through exploiting the knowledge blindness of neural network. Our approach centers around a machine learning algorithm utilized for preparing arbitrary quantum states in a semiconductor double quantum dot system, a system characterized by highly constrained control degrees of freedom. By leveraging stochastic prediction generated by the neural network, we are able to guide the optimization process to escape local optima. Notably, unlike previous methodologies that employ reinforcement learning to identify pulse patterns, we adopt a training approach akin to supervised learning, ultimately using it to dynamically design the pulse sequence. This approach not only streamlines the learning process but also constrains the size of neural network, thereby improving the efficiency of algorithm.

\end{abstract}



%\pacs{}
\author{Chao-Chao Li, Run-Hong He, Zhao-Ming Wang\footnote{Corresponding author: wangzhaoming@ouc.edu.cn}}
\affiliation{College of Physics and Optoelectronic Engineering,Ocean University of China, Qingdao 266100, China}
\maketitle



\section{Introduction}

Robust quantum control is crucial for effective quantum computation and quantum information processing. The physical platform includes nuclear magnetic resonance experiments \cite{vandersypen2005nmr}, captured ions \cite{richerme2014non, yung2014transistor}, superconducting qubits \cite{devoret2013superconducting, wendin2017quantum}, nitrogen-vacancy centers \cite{childress2013diamond}, and semiconductor quantum dots \cite{zajac2018resonantly, huang2019fidelity, watson2018programmable, jang2020three, hanson2007spins, eriksson2004spin, zwanenburg2013silicon}. Among these, spin qubits in semiconductor quantum dots show promise due to their scalability and long coherence times \cite{kim2014quantum, kawakami2016gate, muhonen2014storing, maune2012coherent, bluhm2011dephasing, barthel2010interlaced, pla2013high}. The singlet-triplet ($S$-$T_{0}$) qubit, which is encoded in the singlet-triplet spin subspace of two electrons trapped in a double quantum dot (DQD), is widely used. The advantage over other qubit candidates includes fast qubit operation and independence from uniform fluctuations in the magnetic field, allowing for complete control by electrical pulses \cite{wang2014robust, taylor2005fault, wu2014two, nichol2017high}.
\par
Universal quantum computing relies on two-qubit gates capable of performing entanglement around different axes of the Bloch sphere and precise single-qubit rotations \cite{nielsen2002quantum}. Efficient and precise quantum gates control constructed by deep reinforcement learning has been investigated \cite{an2019deep}, which involves executing gates within the constraints of platform and mitigating errors during execution \cite{throckmorton2017fast}. In the case of singlet-triplet spin qubits in semiconductor DQD, fast electrical control of the exchange coupling is necessary for precise control of the rotation rate around the z-axis of the Bloch sphere \cite{wang2012composite}. The quantum state preparation (QSP) algorithm is commonly employed as a subroutine for various tasks. In particular, Refs. \cite{pinto2023simulation, zanetti2023simulating} utilize QSP to implement general quantum measurements on quantum systems and to simulate noisy quantum channels, respectively. 


\par
Typically, performing an arbitrary quantum spin gate requires numerically solving a set of coupled nonlinear equations to determine a composite pulse sequence \cite{throckmorton2017fast, wang2014robust, wang2012composite}, which is resource and time-consuming. Machine learning, a field born out of artificial intelligence, enables the analysis of vast amounts of data beyond human ability or previously imagined methods of enumeration \cite{yang2018neural, heaton2018ian}, and has shown wide applicability on quantum control \cite{zhang2018automatic, yang2020optimizing, lin2020quantum, bukov2018reinforcement, kong2020artificial, palmieri2020experimental, wang2020deep, niu2019universal, gratsea2020universal, ma2022curriculum}. It is now an active research area and has demonstrated great success in solving lots of physical problems \cite{jordan2015machine, silver2016mastering}. Ref. \cite{yang2018neural} uses supervised learning algorithm to design pulse sequences that closely match solutions of nonlinear equations. However, in practice complex pulse shapes and lengthy execution times limit the application \cite{zhang2019does}. Refs. \cite{zhang2019does, he2021deep} utilize deep reinforcement learning \cite{an2019deep, niu2019universal, lin2020quantum, wang2020deep} to design discrete dynamic pulses for driving an initial state to a fixed state or resetting an arbitrary quantum state to a specific target state. In addition, deep reinforcement learning has successfully generated arbitrary states from specific states in nitrogen-vacancy center systems \cite{haug2020classifying}. By combining Refs. \cite{he2021deep, haug2020classifying}, driving between arbitrary quantum states can be realized.
\par

For the pulse design, several optimization methods are available and have been widely used, such as greedy algorithm (GA) \cite{cormen2022introduction, balaman2019chapter},  gradient ascent pulse engineering (GRAPE) \cite{khaneja2005optimal, rowland2012implementing}, and chopped random-basis optimization (CRAB) \cite{doria2011optimal, caneva2011chopped}. These traditional methods have proven to be effective for the optimal control of lots of quantum systems. However, a major challenge with these methods is that they often converge to local optima instead of global maxima. Consequently, the search may become stuck on a local maximum, leading to an insufficient fidelity. Ref.  \cite{he2021universal} overcomes this limitation by using a revised greedy (RG) algorithm to implement a universal quantum state preparation with a high fidelity, but it is less efficient because of trial and error at every step.
\par



In this paper, we propose a stochastic prediction (SP) of neural network strategy, which can obtain reliable pulse sequences for high fidelity universal quantum state preparation. We use a large number of initial and target states to train the neural network and subsequently use the well-trained network to generate the pulse sequence, providing the control trajectory for state preparation. Our dataset solely consists of non-local optima, following the definition provided in the Ref. \cite{he2021universal}. A local optimum is defined as a scenario where the fidelity fails to improve compared to the previous step, indicating that the network has reached a local maximum. During the state preparation process, we employ the knowledge blindness of the neural network to escape these local optima. When the network encounters such a situation for the first time, it randomly predicts an action, allowing us to break free from the local optimum. Concurrently, we employ a supervised learning algorithm that dynamically determines the control pulse at each step. This approach simplifies the learning process and enhances the efficiency of algorithm when compared to other methods. Our evaluation results show that our pulse design scheme is more efficient than traditional optimization methods in a discrete control space and higher fidelity can be obtained. Compared to conventional pulse optimization methods, our scheme jumps out of the local optimum via the network of randomly predicted pulses, while improving the preparation efficiency. 


\section{model}
Semiconductor quantum dots are a promising candidate for quantum computing due to the advantage that it can be fully electrically driven \cite{zhang2018qubits}. Here, we describe the single-qubit and two-qubit models in $S$-$T_{0}$. The effective Hamiltonian of a single $S$-$T_{0}$ qubit controlled by an external electrical pulse is \cite{petta2005coherent, maune2012coherent, levy2002universal, malinowski2017notch, foletti2009universal}
\begin{equation}
H=J\sigma_z+h\sigma_x,
\label{eq:1}
\end{equation}
under the computational basis states: spin singlet state $|0\rangle=|S\rangle = (|\uparrow\downarrow\rangle-|\downarrow\uparrow\rangle)/\sqrt{2}$, and spin triplet state $|1\rangle=|T_{0}\rangle = (|\uparrow\downarrow\rangle+|\downarrow\uparrow\rangle)/\sqrt{2}$. 
$h$ is the Zeeman energy gap caused by magnetic field and it represents rotation around the x-axis of Bloch sphere. The exchange interaction $J$ causes rotation around the z-axis. $h$ is not easy to be changed experimentally, we assume it to be a constant $h=1$ \cite{wu2014two}. The reduced Planck constant $\hbar=1$ is assumed for simplicity throughout. Thus, the only controllable parameter is the exchange interaction $J$ between the two electrons, which determines the rate of rotation around the z-axis and can be adjusted by applying an external voltage. Due to the nature of the exchange coupling, $J$ is finite and non-negative \cite{zhang2019semiconductor}, and these constraints allow the construction of composite pulses for the implementation of universal quantum gates.


Quantum information processing typically requires a two-qubit entanglement gate. In semiconductor DQD, the Hamiltonian describing two entangled qubits based on Coulomb interactions can be expressed as follows \cite{haug2020classifying, shulman2012demonstration, taylor2005fault, nichol2017high, wang2015improving, van2011charge}
\begin{small} 
\begin{equation}
\begin{split}
H_{2-qubit}=
&\frac{\hbar}{2}(J_{1}(\sigma_{z}\otimes I)+J_{2}(I\otimes \sigma_{z})+h_{1}(\sigma_{x}\otimes I) \\
&+h_{2}(I\otimes \sigma_{x})+\frac{J_{12}}{2}((\sigma_{z}-I)\otimes (\sigma_{z}-I))),
\label{eq:3}
\end{split}
\end{equation}
\end{small} 
under the basis states of $\{|SS\rangle,|ST_{0}\rangle,|T_{0}S\rangle,|T_{0}T_{0}\rangle\}$. $J_{i}$ and $h_{i}$ represent the exchange interaction and magnetic field gradient across the double quantum dot, respectively, with the subscripts $i=1, 2$ denoting the corresponding qubits. Experimentally, the coupling strength $J_{12}$ between the qubits is proportional to $J_{1}J_{2}$, where both $J_{i}$ values need to be positive. For simplicity, we set $J_{12} = J_{1}J_{2}/2$ and $h_{1}=h_{2}=1$ as in Ref.~\cite{he2021universal}. To manipulate this two-qubit system, it is only necessary to control the electrical pulses that adjust $J_{1}$ and $J_{2}$.





\section{methods}


Now our task is to design discrete control pulses that can drive one arbitrary state to another arbitrary state. The pulse sequences are generated by training neural network, and 
the control trajectory is set as a segmented constant function. To optimize various parameters of the neural network, such as weights and biases, supervised learning requires a large input data set. During the process of constructing composite pulses, the trained neural network can predict the appropriate pulse based on input that is not part of the training set. To reduce computational cost, the control pulses are discretized into segmented constant function \cite{rowland2012implementing}, with the maximum evolution time $T$ uniformly divided into $N$ segments and the pulse duration $dt$ set at $T/N$. The fidelity $F$, which quantifies the distance between the evolution state and the target state, is used to assess the quality of the state preparation. $F=|\langle S_{n}| S_{tar}\rangle|^2$, where $S_{n}$ denotes the evolution state at a time step of $n$, and $S_{tar}$ represents the target state.



Our approach includes several steps: First, we construct a dataset with a large number of initial and target states and their corresponding actions, which is then used to put into a neural network for training. During training, the weights and biases of the neurons are continuously adjusted to improve the predictions of network. The trained network is saved as a model for use in future. Secondly, we begin by setting the initialization time step to $step=0$ and feeding a pair of initial state $S_{init}$ and target state $S_{tar}$ into the network model to calculate the fidelity $F$ of the initial state. And we define it as the maximum fidelity $F_{max}$. After feature extraction in the fully connected layer, we obtain the output of the actions, which is a set of discrete actions output as a probability distribution under the activation function, and the sum of these probabilities is 1. We choose the best action $a_{k}=argmax(action)$, which represents the pulse strength $J(t)$. Using the current quantum state $S_{init}$ and the action obtained from the network prediction, we calculate the evolution state $S_{n}=exp(-iH(a_{k})dt)S_{init}$ and its corresponding fidelity $F_{n}$ for the next moment. Then we compare it with the previous maximun fidelity and select the larger of the two values as $F_{max}$. The evolution state $S_{n}$ is then fed into the network model as the new initial state with the target state at the time step $step=step+1$. We repeat this process until either the time step reaches the maximum step $N$ or the fidelity exceeds a satisfactory threshold. The control trajectory for the quantum state preparation consists of the sequence of actions predicted by the neural network, with this sequence representing the solution for obtaining the maximum value of fidelity. At last, the trained neural network can formulate appropriate control trajectories for quantum states in the test set or other states in the  Hilbert space.

% Figure environment removed


\begin{algorithm}
	\caption{The pseudocode of the SP algorithm for designing control trajectory}
	\label{alg: AOA}
	\renewcommand{\algorithmicrequire}{\textbf{Input:}}
	\renewcommand{\algorithmicensure}{\textbf{Output:}}
	\begin{algorithmic}[1]
		\REQUIRE initial state $S_{init}$ and target state $S_{tar}$
		\ENSURE the maximum fidelity $F_{max}$ and pulse sequence 
		        from $step=0$ to $step_{end}$
		\STATE Calculate the initial fidelity $F$ and let $F_{max}=F$
		\STATE Initialize the time step $step=0$
		\WHILE{True}
		\STATE Feed initial and target states into the network model to predict the action probability distribution
		\STATE Choose the action $a_{k}=argmax(action)$
		\STATE Next state $S_{step}$ are the state obtained by performing $a_{k}$ and calculate the corresponding fidelity   
		       $F_{step}$
		\STATE Compare the two fidelities $F_{step}$ and $F_{max}$
		\IF {$F_{step}>F_{max}$}
		\STATE Let $F_{max}\leftarrow F_{step}$
		\ENDIF
		\STATE Let $S_{init}\leftarrow S_{step}$ and $step=step+1$
		\STATE Break if $F_{max}>0.999$ or $step>step_{max}$
		\ENDWHILE
	\end{algorithmic}
\end{algorithm}

During the dataset construction process, we exclude data points that correspond to local optima. This is determined by comparing the fidelity achieved in the subsequent step with that of the previous step. Specifically, if the fidelity does not improve, it remains unchanged or decreases, the data is deemed to be associated with a local optimum and is discarded. Consequently, the dataset solely comprises non-local optima, ensuring that the fidelity improves at each step. When the trained model is applied, the neural network exhibits the ability to escape local optima when encountering states trapped within them. Since the network has not been trained in similar scenarios, it randomly predicts the action to be performed, thereby generating a perturbation.
\par

Our work effectively tackles the dynamic decision-making problem by employing the widely utilized model of supervised learning in the field of machine learning. Within this framework, neural network are leveraged to determine action to be taken next, taking into account the current state.
In comparison to the RG algorithm, which explores suitable actions through trial and error, our approach offers a more direct and efficient means of obtaining the next action. By directly feeding the quantum state into the network model, our method proves to be more straightforward and highly efficient.
\par

The pulse design process is illustrated in Fig.~\ref{fig:1}. Algorithm.~\ref{alg: AOA} presents the pseudocode for the SP algorithm. The key feature of the SP algorithm is its randomness of prediction, which does not require the human intervention. Although the neural network may occasionally predict suboptimal actions that could result in a fidelity decrease from one step to the next, this global approach to state preparation can ultimately produce better results, avoiding the local optimality problem encountered by the traditional algorithms.


\section{Results and discussions}
In this section, we focus on the state preparation of single-qubit and two-qubit in semiconductor DQD and compare our approach with conventional optimization methods. The details of the default parameters of the algorithm are listed in Table.~\ref{table:1}.


\begin{table}[h!]
	\centering
	\caption{Default parameters of the neural network.}
	\label{table:1}
	\begin{tabular}{ccc} 
		\hline
		\textbf{Parameters} & \textbf{single-qubit} & \textbf{two-qubit}\\
		\hline
		Total evolution time & $4\pi$ & $10\pi$\\
		Action duration & $\pi/5$ & $\pi/2$\\
		Maximum time step & 20 & 20\\
		Number of allowed actions & 8 & 16\\
		Batch size & 64 & 128\\
		Neurons per hidden layer & 256/64/32/32/8 & 256/128/64/16\\
		Learning rate & 0.0005 & 0.001\\
		Number of epoch & 200 & 100\\
		Activation function & softmax & softmax\\
		\hline
	\end{tabular}
\end{table}


\subsection{Universal single-qubit state preparation}
An arbitrary single-qubit state can be represented by a point on the Bloch sphere $|\psi(\theta,\varphi)\rangle=\cos(\frac{\theta }{2})|0\rangle+e^{i\varphi}\sin(\frac{\theta }{2})|1\rangle$, where the polar angle $\theta\in[0,\pi]$ and the azimuthal angle $\varphi\in[0,2\pi)$. We take the dataset for a single-qubit state preparation as in Ref.~ \cite{he2021universal}, where 128 testing points distributed uniformly at the angles $\theta$ and $\phi$ are sampled on the Bloch sphere. Each of these points is prepared in turn as a target state, enabling us to assess the performance of our method. For one preparation task, there is one fidelity $\bar{F} $. The mean of these average fidelity $\langle \bar{F} \rangle$ is calculated over all target states. For example, the single-qubit state preparation corresponds to $128 * 127=16256$ tasks.  
 
\par
The state preparation can be achieved by performing successive rotations on a Bloch sphere, with the exchange coupling $J(t)$ as the only adjustable parameter \cite{throckmorton2017fast}.  In our approach, we use 8 discrete control pulses, $J\in\left\{0,1,2,3,4,5,6,7\right\}$. The total evolution time $T$ is set to $4\pi$, and the pulse duration $dt$ is set to $\pi/5$, resulting in a maximum allowed time step of $N=T/dt=20$ for the entire process. These parameters can be adjusted as required. 
\par

Fig.~\ref{fig:2} plots the test set accuracy, the average fidelity of the SP algorithm, and the average fidelity of the greedy algorithm versus the number of epoch during the neural network training. Classical algorithms such as the greedy algorithm are not involved in the training process, so the average fidelity of GA algorithm is a constant. Fig.~\ref{fig:2} shows that after about 75 epochs, the test set accuracy of the network and the average fidelity of the SP algorithm do not improve significantly as the number of epoch increases, indicating that the network has converged and the two trends are consistent. Furthermore, the average fidelity of the SP algorithm is significantly better than that of the greedy algorithm, demonstrating that our proposed scheme for preparing quantum states produces higher-quality results. Therefore, we conclude that our approach is viable, and the trained network can be applied to universal quantum state preparation tasks.
\par

% Figure environment removed


High efficiency quantum state preparation means high fidelity with short design time. To evaluate the efficiency of our SP algorithm against other methods. We present 
the distribution of the average fidelity $\bar{F}$ versus the average designing time $\bar{t}$ of the SP, GRAPE, CRAB, GA and RG for preparation target states in Fig.~\ref{fig:3}. The control parameters are taken as the same as in Fig.~\ref{fig:2}. The average is based on the 128 state preparation tasks. To satisfy the discrete control requirement, we discretize the continuous control of GRAPE and CRAB to the nearest allowable action at the end of the execution \cite{zhang2019does}. As shown in Fig.~\ref{fig:3}, our SP algorithm outperforms all the other four conventional optimization algorithms in terms of efficiency in the discrete control space, with GRAPE and CRAB algorithms performing poorly in the same space. During optimization, the SP algorithm reduces the required time step adaptively to efficiently find the optimal solution. In contrast, GRAPE and CRAB use a fixed number of time steps and sometimes the optimal solution is missed. 

% Figure environment removed


\subsection{Universal two-qubit state preparation}
For a two-qubit state preparation of a semiconductor DQD, the allowed control pulses for each qubit can be discretized as $\left\{(J_{1}, J_{2})|J_{1}, J_{2}\in\left\{1,2,3,4\right\}\right\}$, resulting in a total of 16 allowed actions. During this process, the total evolution time is set to $T=10\pi$ and the pulse duration to $dt=\pi/2$. The points in the data set for train and test are defined as $\left\{\left[a_{1}, a_{2}, a_{3}, a_{4}\right]^T\right\}$, where $a_{j}=e^{i\phi}c_{j}$ represents the probability amplitude of the corresponding $jth$ basis state, and $\phi\in\left\{0,\pi/2,\pi,3\pi/2\right\}$; and these $c_{j}s$ together represent the points on the hypersphere of the four-dimensional unit
\begin{equation}
\left\{
\begin{aligned}
	c_{1} &= \cos\theta_{1}, \\
	c_{2} &= \sin\theta_{1}\cos\theta_{2}, \\
	c_{3} &= \sin\theta_{1}\sin\theta_{2}\cos\theta_{3}, \\
	c_{4} &= \sin\theta_{1}\sin\theta_{2}\sin\theta_{3},
\end{aligned}
\right.
\label{eq:4}
\end{equation}
with $\theta_{i}\in\left\{\pi/8,\pi/4,3\pi/8\right\}$ \cite{he2021deep}. We select randomly 256 testing points to form the data set.
%from that data set to form the testing set.

As plotted in Fig.~\ref{fig:4}, the neural network converges after about 30 epochs. After 100 epochs of training, the average fidelity of the SP algorithm converges to 0.93. On the other hand, average fidelity of our proposed algorithm for the two-qubit state preparation still performs better than greedy algorithm. Fig.~\ref{fig:5} shows the frequency distribution of the average fidelity $\bar{F}$ for the 512 target states prepared by SP, GA and RG, respectively. The results again verify that our algorithm outperforms the other two algorithms. Although some bad spots exist, the overall performance is excellent.

% Figure environment removed

% Figure environment removed



\subsection{Universal state preparation in a noisy environment}
 
The complete quantumness is always expected when performing universal quantum state preparation. However, normally the quantum noise will destroy the quantumness and then decrease the fidelity. How the optimal pulse sequences perform when considering the noises? Next we introduce noises in the quantum line by adding the bit flip channel, phase flip channel, or amplitude damping channel, respectively. The bit flip and phase flip channels are modeled by applying an additional $X$ or $Z$ gate to the qubit with a probability of occurrence. These two noise channels are the so-called Pauli channels. We take the bit flip channel as an example, which can be expressed as
\begin{equation}
\epsilon(\rho)=(1-p)I\rho I+pX\rho X,
\label{eq:5}
\end{equation}
where $I$ is the unit matrix and $X$ is Pauli X gate. The corresponding Kraus operators for this channel are
\begin{equation}
E_{0}=\sqrt{1-p}\left[
\begin{array}{cc}
1 & 0 \\
0 & 1
\end{array}
\right],
E_{1}=\sqrt{p}\left[
\begin{array}{cc}
0 & 1 \\
1 & 0
\end{array}
\right],   
\label{eq:6}
\end{equation}
where $p$ is the probability of occurrence of bit flip. The amplitude damping channel accounts for the dissipation of energy from the quantum system and the mathematical form can be expressed as
\begin{equation}
\epsilon(\rho)=E_{0}\rho E_{0}^{\dagger}+E_{1}\rho E_{1}^{\dagger},
\label{eq:7}
\end{equation}
with Kraus operators
\begin{equation}
E_{0}=\left[
\begin{array}{cc}
1 & 0 \\
0 & \sqrt{1-p}
\end{array}
\right],
E_{1}=\left[
\begin{array}{cc}
0 & \sqrt{p} \\
0 & 0
\end{array}
\right],   
\label{eq:8}
\end{equation}
where $p$ is the dissipation factor. 
% Figure environment removed




We have found the ideal optimal pulse sequence that corresponds to the maximum fidelity through training the dataset in the absence of noises. For the noise model, we consider two cases. The first is that we use the ideal pulse sequence. We apply noise channel after each time step of the pulse to create a noisy quantum line, which is used to drive the initial state to the final state. For the second case, we directly search the optimal pulse in the noise model. 
Now for the first cases, in Fig.~\ref{fig:6} we plot the fidelity $\langle \bar{F} \rangle$ as a function of the occurrence probability (dissipation factor) $p$ for single-qubit and two-qubit state preparation. For two-qubit state preparation, we assume that both qubits noise channels are identical, and the probability or dissipation factor of the noise channels is the same ($p_{1}=p_{2}=p$). $\langle \bar{F} \rangle$ decreases with increasing $p$ as expected. For single and two qubit case and for the same $p$, $\langle \bar{F} \rangle$ decreases most significantly for the bit flip, phase flip is in the middle, and amplitude damping corresponds to the minimal impact.


\par

% Figure environment removed


It has been clearly shown that the fidelity will decrease in the presence of noise even with the ideal pulse sequence. Can we use our method to directly design the pulse sequence with noises? In this cases, the optimal pulse sequence depends not only on the system but also the noises. In a recent paper \cite{yangyang}, optimized pulse sequences for the adiabatic speedup are found by using stochastic search procedures in a noisy environment. The detrimental effects of the environment on the system are reduced for the optimal pulses compared with the ideal closed-system pulses. Now we will train the network with noises. Initially, we add a noise channel on the Hamiltonian and construct a data set incorporating the noises. Then we obtain a model after training. For the demonstration, we take a single-qubit quantum state preparation with bit flip channel as an example. 
The initial state is taken as $|0\rangle$ and target state as $|1\rangle$. Fig.~\ref{fig:7}(a) plots the mean of the average fidelity versus the flip probability for these two cases: train with (without) noise. Obviously, when using the ideal pulse sequences, $\langle \bar{F} \rangle$ decreases quickly with increasing $p$ as expected. However, when training with noises, $\langle \bar{F} \rangle$ is almost stable for different $p$. The value of $\langle \bar{F} \rangle$ oscillates around 0.965. This result indicates that once the environmental parameter is given, the neural network is able to adjust its weight parameters appropriately during the training to combat the noises. Fig.~\ref{fig:7}(b) shows the obtained control trajectories using the SP algorithm training with and without noises. These two trajectories are different from both the steps and the strengths. It only needs 8 steps when training withour noise and 16 steps are required with noises. Furthermore, we plot the corresponding motion trail of Fig.~\ref{fig:7}(b) for the reset task from $|0\rangle$ to $|1\rangle$ on the Bloch sphere in Fig.~\ref{fig:8}.      


% Figure environment removed

\par
Given the limitations of available quantum computing, we simulate quantum computing on a classical computer and generate the corresponding data. Our algorithm was implemented using PYTHON 3.8.8, TensorFlow 2.12.0, QuTip 4.7.1, MindQuantum 0.8.0, running on a computer with a 6-core 2.60 GHz CPU and 16 GB of RAM.


\section{conclusions}
In this paper, we propose an efficient SP algorithm for designing control trajectories that can prepare an arbitrary state from an arbitrary state. The scheme involves training a large number of initial and target states along with their corresponding actions using neural network. Once the network is trained, it can be used to predict control pulses without any further training. We demonstrate that the efficacy of our approach on single-qubit and two-qubit of semiconductor quantum dot, highlighting its potential application in the future quantum computation. Our SP algorithm shows its advantage over conventional pulse optimization algorithms by achieving a higher fidelity. Furthermore, the control pulses are predicted directly through the network, resulting in shorter pulse design time than other numerical optimization algorithms. At last, we consider noises including Pauli channel and amplitude damping channel. We find that our SP algorithm is still effective for the design of pulse sequences when training with noises. Our investigation shows that the machine learning is a powerful tool for the design of control pulse sequences in quantum information processing.

\begin{acknowledgements}
This paper is based upon work supported by the Natural Science Foundation of Shandong Province (Grants No. ZR2021LLZ004) and Fundamental Research Funds for the Central Universities
(Grant No. 202364008).
\end{acknowledgements}

\bibliography{xianghan}





\end{document}


