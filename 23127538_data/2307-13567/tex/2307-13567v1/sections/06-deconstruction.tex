\section{Deconstructing Chart \revise{Layout}}
\label{sec:chartDecomp}
After the axes and legend are correctly identified, Mystique removes them from the scene graph, and deconstructs the main chart content. 

\subsection{Semantic Components: \revise{GREC}}
\label{sec:GLEC}

To understand and decompose \revise{layout}, one potential way is to classify the charts based on a fine-grained taxonomy with categories. We decided not to take this approach for three reasons. First, a chart might not clearly fit into a predefined type; e.g., the chart in \cref{fig:reuseUI} \bluecircle{2} integrates elements from a treemap and a grouped bar chart into a single design. Second, many charts have nested structures~(e.g., small multiples) and require deconstruction into multiple instances of the same chart type. Finally, knowing the fine-grained chart type is still not enough to reuse \revise{its layouts}; for instance, given a stacked bar chart, we still need to obtain information such as the orientation of the stacked relationship and the distance between the groups. 
Therefore, we decided to deconstruct a chart into the following four types of semantic components \revise{that jointly reflect its layout}: \textit{grouping} (G), \textit{spatial relationships} (R), \textit{encodings} (E) and \textit{graphical constraints} (C).

\noindent \textbf{Grouping (G)} refers to the hierarchical clustering of rectangles that reflects the semantic structure of the visualization. We make a further distinction between two kinds of groups: \textit{collection} and \textit{glyph}. Rectangles in a group in the diverging stacked bar chart (\cref{fig:teaser}d) are placed in a horizontal stack relationship, and they represent different data cases; in contrast, rectangles in a group in the bullet chart (\cref{fig:teaser}c) are placed according to some graphical constraints (i.e., left and middle aligned) and they represent the same data case. We refer to the former type of group a \textit{collection}, and the latter a \textit{glyph}, based on the unified terminology used in recent visualization authoring tools \cite{satyanarayan_critical_2019} and the visualization object model used in the \markup{Mascot} grammar \cite{liu_atlas_2021}. % We detect two kinds of groups: \textit{collections} and \textit{glyphs}. 

\noindent \textbf{Spatial Relationships (R)} estimate the relative placement and organization of same-level rectangles or groups. Mystique currently supports three types of relationships: grid, stack, and packing~(\cref{fig:layouts}).

% Figure environment removed

\noindent \textbf{Encodings (E)} specify the mapping between data attributes and visual properties of rectangles or groups.

\noindent \textbf{Graphical Constraints (C)} enforce requirements (e.g., data-related alignment) on the spatial arrangements of rectangles or groups. For example, in \cref{fig:teaser}d, all the gray rectangles representing ``Neither agree nor disagree'' are aligned in the center. The primary difference between a graphical constraint~(C) and a spatial relationship~(R) is that the former can transcend groups and be applied to selected marks only, while the latter computes the positions of all the children in a group using an iterative algorithm. In certain cases, aspects of a spatial relationship may be similar to graphical constraints. For instance, in \cref{fig:teaser}(e), multiple collections of vertically stacked bars are organized as nested groups in a grid relationship, the contents of which are aligned by the bottom. Mystique treats such an alignment as a relationship parameter (called ``gravity''), not as a constraint.

% \begin{itemize}
%     \setlength{\itemsep}{2pt}
%     \setlength{\parskip}{0pt}
%     \setlength{\parsep}{0pt}
%     \item \textbf{Grouping (G)} refers to the hierarchical clustering of rectangles that reflects the semantic structure of the visualization. We make a further distinction between two kinds of groups: \textit{collection} and \textit{glyph}. \revise{Rectangles in a group in the diverging stacked bar chart (\cref{fig:teaser}d) are placed in a horizontal stack relationship, and they represent different data cases; in contrast, rectangles in a group in the bullet chart (\cref{fig:teaser}c) are placed according to some graphical constraints (i.e., left and middle aligned) and they represent the same data case.} We refer to the former type of group a \textit{collection}, and the latter a \textit{glyph}, based on the unified terminology used in recent visualization authoring tools \cite{satyanarayan_critical_2019} and the visualization object model used in the Atlas grammar \cite{liu_atlas_2021}. % We detect two kinds of groups: \textit{collections} and \textit{glyphs}. 
%     \item \textbf{Spatial Relationships (R)} estimate the relative placement and organization of same-level rectangles or groups. Mystique currently supports three types of relationships: grid, stack, and packing~(\cref{fig:layouts}).
%     \item \textbf{Encodings (E)} specify the mapping between data attributes and visual properties of rectangles or groups.
%     \item \textbf{Graphical Constraints (C)} enforce requirements (e.g., data-related alignment) on the spatial arrangements of rectangles or groups. For example, in \cref{fig:teaser}d, all the gray rectangles representing ``Neither agree nor disagree'' are aligned in the center. The primary difference between a graphical constraint and a spatial relationship is that the former computes the positions of all the children in a group using an iterative algorithm, while the latter can transcend groups and be applied to selected marks only. In certain cases, aspects of a spatial relationship may be similar to graphical constraints. For instance, in \cref{fig:teaser}(e), we have multiple collections of vertically stacked bars, and they are organized as nested groups in a grid relationship. The contents inside each grid cell are aligned by the bottom. Mystique treats such an alignment as a relationship parameter (called ``gravity''), not as a constraint.
% \end{itemize}


Consider \revise{the layout of} the treemap grouped bar chart in 
\cref{fig:reuseUI}. Excluding the axes and grid lines, the main chart area can be described as 4 high-level \textit{groups} (G), each representing a year, arranged in a \textit{grid relationship with 1 row and 4 columns} (R). Within each group, two \textit{sub-groups} (G) of rectangles, representing Imports and Exports, are arranged in a \textit{grid relationship with 1 row and 2 columns} (R). Within each subgroup, six sub-subgroups (G) in distinct colors are arranged in a \textit{packing relationship} (R), each of which is composed of rectangles arranged in a \textit{packing relationship} (R). The \textit{height} of the bars representing Imports or Exports \textit{encodes} the \textit{total trade value} (E), the \textit{area} of the rectangles \textit{encodes} the \textit{trade value} (E) for a certain country, and the \textit{color} of the rectangles \textit{encodes} the \textit{continent} (E). In this chart, there are no special graphical constraints.
This GREC model is based on the \markup{Mascot} visualization framework \cite{liu_atlas_2021}, and the four components correspond to the outputs of four grammatical rules:  glyph generation, graphics-data join, visual encoding, and spatial arrangement.

% From a graphics-centric perspective, we can describe the structure of a visualization using four types of semantic components: \textit{groups} (G), \revise{\textit{spatial relationships} (R)}, \textit{encodings} (E), and \textit{graphical constraints} (C). \Cref{sec:overview} defines and illustrates these components using the treemap grouped bar chart example. We make a further distinction between two kinds of groups: \textit{collection} and \textit{glyph}. \revise{Rectangles in a group in the diverging stacked bar chart (\cref{fig:teaser}d) are placed in a horizontal stack relationship, and they represent different data cases; in contrast, rectangles in a group in the bullet chart (\cref{fig:teaser}c) are placed according to some graphical constraints (i.e., left and middle aligned) and they represent the same data case.} We refer to the former type of group a \textit{collection}, and the latter a \textit{glyph}, based on the unified terminology used in recent visualization authoring tools \cite{satyanarayan_critical_2019} and the visualization object model used in the Atlas grammar \cite{liu_atlas_2021}. 
% % The bullet chart in \cref{fig:teaser}c is an example that contains \textit{glyph} groups.


% \revise{Mystique supports three types of spatial relationships: grid, stack, and packing. \Cref{fig:layouts} illustrates these relationships and their respective parameters.
% The primary difference between a spatial relationship and a graphical constraint is that the former computes the positions of all the children in a group using an iterative algorithm, while the latter can transcend groups and be applied to selected marks only. In certain cases, aspects of a spatial relationship may be similar to graphical constraints. For instance, in \cref{fig:teaser}(e), we have multiple collections of vertically stacked bars, and they are organized as nested groups in a grid relationship. The contents inside each grid cell are aligned by the bottom. Mystique treats such an alignment as a relationship parameter (called ``gravity''), not as a constraint. }
% % \vspace{-2mm}

\subsection{Group and Spatial Relationship Detection}
\label{sec:decompApproach}
\revise{We decided to jointly detect groups and spatial relationships because the inference of a group and the spatial relationship~(if any) in a group are inextricably linked.}
% In this step, we determine the lowest-level layout, which defines the spatial relationship inside a lowest-level semantic rectangle group. 
On the one hand, a relationship would be an effective criterion to decide whether a set of rectangles form a group; on the other hand, uncertainties may be involved if we try to infer the relationship without a complete set of rectangles from a group.
For this task, we have considered multiple approaches. 

We experimented with a \markup{SVM model~\cite{noble2006support}} trying to predict if a gap between a pair of rectangles constitutes a boundary between groups, but the results were not satisfactory~(the results are included in the supplementary materials). 
Another candidate, the decomposition approach in Chartreuse~\cite{cui_mixed-initiative_2022}, is not directly applicable because this method was primarily designed for clustering customized infographics glyphs. It is also unclear if it works on charts with nested structures.

Our final solution is a customized bottom-up hierarchical clustering algorithm~\cite{nielsen2016hierarchical} to capture the semantic groups of rectangles.
Generally, hierarchical clustering starts by treating each object as an individual cluster, and combines pairs of clusters until one final cluster containing all objects is formed. Applying this approach to our problem, the clustering algorithm consists of two steps: inferring the lowest-level groups and spatial relationships based on pairwise information for the rectangle marks (\cref{sec:lowestLayout}), and iteratively merging groups to complete a nested structure (\cref{sec:groupMerging}).
In this process, two major components need to be determined: a \textit{distance function} $D$ that computes how closely related two rectangles or two groups are, and a \textit{linkage function} $K$ that merges objects into hierarchical clusters based on the distance information. We design these functions by taking into account the semantics of grouping in data visualization. 
\revise{
To avoid overfitting
and improve generalizability, we develop and tune the algorithm on a training chart set, and evaluate the algorithm on a separate test chart set (details
in~\cref{quantatitive}).}
The pseudo-code for the algorithm is included in the supplementary materials.

% Figure environment removed

\subsubsection{Lowest-Level Groups and Spatial Relationships Detection}\label{sec:lowestLayout}
The algorithm starts with detecting the lowest-level spatial relationships and groups. 
We use local spatial relationship information, instead of a numerical value only, to characterize how related two rectangles are. 

\bpstart{Distance Function}
We define a distance function $D$ that takes a pair of rectangles as input and outputs one or more relationship categories that can describe their spatial relationship. $D$ supports five relationship categories: stack (with orientation and gap), grid (with orientation and gap), packing (with gap), overlapping, and \textit{null}. 
% $D$ evaluates the positions of the two input rectangles, and tries to find the layout categories that can describe their spatial relationship. 
We use the following criteria to decide between the stack, grid, and packing relationships: for all three, the rectangles should not overlap; grid and stack require that the union of the two rectangles' bounding boxes do not intersect with any other rectangle~(e.g., pairs~$(1,2)$ and~$(1,6)$ in \cref{fig:diagram1}a \bluecircle{1}), and packing is applicable when a universal gap parameter regardless of orientation exists~\markup{(i.e., the gap between any neighboring rectangles is constant)}. Thus, $D$ will rule out the packing relationship once inconsistent gaps are observed (e.g., $(1,2)$ and $(1,4)$ in \cref{fig:diagram1}d \bluecircle{1}).

% \bpstart{Robustness} 
% In real-world SVG examples, the positioning of rectangles is not always exact (e.g., the gaps between stacked rectangle pairs can vary between $0$ and $1$ in some training examples), resulting in inconsistent layout parameters extracted from different rectangle pairs. To accommodate such uncertainties and increase the robustness of our proposed algorithm, some small thresholds for layout parameters are tuned using the training set; e.g., we allow the gap parameter of the stack layout to range in $[-1,1]$, and the gravity baseline~(alignment along the orientation) for the grid layout to have a 2-pixel threshold. More details are included in the supplementary materials with the pseudo-code.

\bpstart{Linkage Function}~To merge rectangles into lowest-level groups, a linkage function $K$ computes the following:

\noindent\textit{1. Construct Distance Matrix} ~(\cref{fig:diagram1} \bluecircle{1}). $K$ first computes the relationship categories for every pair of rectangles using $D$, and stores the results in a matrix.
\revise{To accommodate noises of mark positioning in real-world SVG charts and increase robustness, some small thresholds for relationship parameters~(\cref{fig:layouts}) are adopted~(details in the supplementary materials).}
\Cref{fig:diagram1} \bluecircle{1} illustrates the matrix results for four different charts. Since the matrix is symmetrical, we only need to compute fewer than half of the entries (shown as white cells). \revise{Cells with red labels indicate either overlapping rectangles (\textcolor{red}{-1}) or that no relationships is applicable (\textcolor{red}{X})}.

\noindent\textit{2. Extract Common Relationship}~(\cref{fig:diagram1} \bluecircle{2}). Next, $K$ finds if a common spatial relationship exists in the distance matrix. For instance, HS (Horizontal stack) appears in all rows in \cref{fig:diagram1}a \bluecircle{1}, which means that for every rectangle $r_i$, there exists at least one other rectangle that can be paired with it to form a horizontal stack relationship. In cases like the Marimekko chart~(\cref{fig:diagram1}b) and the Pyramid chart, multiple relationship candidates are available (the latter case has both the grid and stack relationships in common) and lead to different final groups. 
To choose the common relationship, stack is given priority over grid \markup{or} packing. \markup{In all other cases only one candidate exists.}

\noindent\textit{3. Merge Rectangles into Low-level Groups}~(\cref{fig:diagram1} \bluecircle{3}). Given the common relationship $L$, $K$ randomly picks an initial pair of rectangles satisfying $L$ and merges them into a collection $C$. It will then look for other rectangles that can be added to $C$ without breaking $L$. This iterative clustering continues until no new rectangles can be found.
$K$ then proceeds to find other lowest-level collections until all rectangles are assigned, requiring that collections don't overlap with each other. 
In cases where no common relationship was found and overlapping rectangles exist~(\eg in \cref{fig:diagram1}c, rectangles 1-5 and rectangles 6-10 form two glyphs), $K$ uses the $-1$ values in the distance matrix to cluster overlapping rectangles to form lowest-level glyphs. 
At this point, since the lowest-level groups are complete, the algorithm calls the distance function $D$ again to examine the lowest-level groups to update and augment $L$ with more details like gravity.
If no common spatial relationship was extracted in the second step and no glyph was found, or the requirement of non-overlapping groups was violated, $L$ groups all rectangles together and infers that the position of each rectangle encodes data (\cref{fig:diagram1}d).

\subsubsection{Iterative Group Merging}\label{sec:groupMerging}
After all the lowest-level groups are found, we start recursively merging these groups into higher-level groups by checking potential higher-level relationships between groups. 
Similar to \cref{sec:lowestLayout}, the algorithm first constructs a distance matrix recording potential relationship information for all possible group pairs using $D_g$~(\cref{fig:diagram1} \bluecircle{4}), extracts a common relationship from the matrix~(\cref{fig:diagram1} \bluecircle{5}), and lastly merges the groups into higher-level groups using $K_g$~(\cref{fig:diagram1} \bluecircle{6}). $D_g$ and $K_g$ share the same logic with $D$ and $K$ respectively, where the only difference is the input objects.
We recursively apply this process until ending up with a single collection of groups containing all rectangles or termination during this process~(i.e., no relationship is found or collections of groups overlap). 

For example, in both \cref{fig:diagram1}a and~\cref{fig:diagram1}c, the distance matrix for groups is $\big(\begin{smallmatrix}
  null & VG\\
  VG & null
\end{smallmatrix}\big)$; thus, a higher-level vertical grid relationship is found, and two lowest-level groups are merged into one. In \cref{fig:diagram1}b, the distance matrix for groups is $\big(\begin{smallmatrix}
  null & VS\\
  VS & null
\end{smallmatrix}\big)$, leading to a higher-level group with a vertical stack relationship. In \cref{fig:diagram1}d, all rectangles are encoding-based and clustered into one group; thus there is no need to proceed to higher-level handling. The final decomposed hierarchies are shown in \cref{fig:diagram1}~\bluecircle{7}.

\subsection{Encodings Inference\label{sec:encInfer}}

% Mystique infers visual encodings after the semantic grouping and layouts are determined. There are two categories of encodings considered: encodings for groups and encodings for rectangles.

\bpstart{Encodings for Groups} In cases where the iterative group merging described in \cref{sec:groupMerging} aborts~(which means several groups sharing the same semantic structure are found while they cannot be merged further to form higher-level hierarchies), Mystique collects these groups to make the final grouping result, and marks their $x$ and $y$ positions as encoded with data; e.g., the small-multiples bar chart~(\cref{fig:teaser}g).
% An example with such encodings is a small-multiples bar chart (\cref{fig:teaser}g). 
% \leo{show figure if we have space}.

\bpstart{Encodings for Rectangles} Mystique considers six visual channels of a rectangle mark in encoding detection: $x$, $y$, $width$, $height$, $fill$, and $area$. \Cref{table:encoding-inference} summarizes our inference rules. When the lowest-level groups are glyphs, Mystique applies the rules for width/height and x/y to extract encodings for each set of corresponding rectangles~(e.g., four bars of the same color across groups in \cref{fig:teaser}c).

% % Figure environment removed

\begingroup
\renewcommand{\arraystretch}{1.1}
\begin{table}[ht]
\caption{Each visual channel is considered to be encoding data if the corresponding condition is met.}
\scriptsize
\begin{tabular*}{\linewidth}{lp{.36\textwidth}}
\Xhline{1.5\arrayrulewidth}
Channel       &      Condition        \\ \Xhline{1.5\arrayrulewidth}
fill            &     rectangles in the chart content have different fill colors                 \\ \Xhline{\arrayrulewidth}
area      &            lowest-level special relationship is packing               \\ \Xhline{\arrayrulewidth}
width / height         &       lowest-level special relationship is grid or stack, and rectangles have varying widths/heights                   \\ \Xhline{\arrayrulewidth}
x / y      &           lowest-level special relationship is a one-directional grid without the gravity parameter
                  \\ \Xhline{2.5\arrayrulewidth}
\end{tabular*}
\vspace{-3mm}
\label{table:encoding-inference}
\end{table}
\endgroup

\subsection{Graphical Constraints Detection}
Information regarding graphical constraints is recorded during the chart deconstruction.
Mystique currently checks and records two kinds of graphical constraints: (1) the alignment constraint within a glyph (e.g., the gray and blue rectangles in a glyph are left and middle aligned in \cref{fig:diagram1}c), and (2) any customized alignment of stacked bars in a grid relationship~(e.g., \cref{fig:teaser}d). The former is important when rendering a new glyph-based visualization in the reuse UI because the alignment constraints within glyph groups are not automatically enforced by spatial relationships. The latter is usually data-dependent; for instance, the stacked bar groups in \cref{fig:diagram1}a are aligned so that all the rectangles representing ``Neither agree nor disagree'' share the same center coordinate. Since such information will have to be provided by the user with a new dataset, Mystique only records the alignment constraint based on the fill color property, and asks the user to provide data-related constraint specification during the reuse stage. 

% % Figure environment removed

% \subsection{Generalizing to Circle-based Charts}
% \label{sec:circle}
% \remove{Although the current version of Mystique focuses on rectangle-based charts, the decomposition approach can be generalized and applied to charts composed of other types of marks. In a preliminary attempt, by extending the current implementation, we have successfully decomposed $13$~(3 bubble charts, 2 circle packing plots, 2 beeswarm plots, 3 scatter plots, and 3 dot plots) out of $16$ circle-based examples collected from 5 charting tools~(D3, Vega-Lite, Atlas, Charticulator, and Datylon). To achieve this, we only needed to replace the distance function $D$ with a variant that incorporates circle-specific attributes (\eg radius) and handles bounding box computation. The linkage function $K$ can be readily used without any change.  
% We include these examples with the decomposed results in the supplementary materials. The three error cases include one superimposed circle packing chart and two scatter plot matrix charts, where the algorithm clusters the circle marks across all the plots as one collection. We further discuss the implications of our approach on generalizing to more mark and chart types in \cref{sec:generalize}.}
% % believe our proposed approach has great potential to generalize to more mark and chart types with more training examples.