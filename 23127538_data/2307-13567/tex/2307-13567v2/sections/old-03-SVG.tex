% \section{SVG Visualizations in the Wild}\label{svg}
\section{Challenges in Understanding Real-World SVG Visualizations}\label{sec:svg}
% Our investigation started with the collection and curation of existing SVG charts on the web. To understand real-world practices of representing charts in the SVG format, we sampled a handful of charts from online galleries of visualization toolkits and systems and inspected the underlying SVG representations.

\subsection{Unreliable Semantic Information}\label{sec:SVGchallenges}
Given the structured format and clear element tags in the SVG specification, we initially expected that it would be straightforward to obtain semantic information such as mark attributes and hierarchical grouping. \revise{To our surprise, as we examined more online SVG charts from different sources, a majority of them are not readily usable.} 

% Figure environment removed

% Figure environment removed

The following observations constitute challenges in extracting semantic structures:\textbf{ (1) Inconsistent SVG Element Types}: the same mark type may be represented using different types of SVG elements. For instance, we have observed in multiple examples that a rectangle mark is represented using a $<$path$>$ element, and an axis is drawn as a thin rectangle. We cannot thus simply determine the mark type based on the SVG element type;\textbf{ (2) Arbitrary Grouping of Elements}: the semantic information in SVG visualizations in the wild is often unreliable. In particular, the grouping of SVG elements can be arbitrary. For example, stacked bar charts created using different tools exhibit vastly different grouping structures~(\cref{fig:svg-g}); axis labels can be either within one group or in their own individual groups; \textbf{(3) Missing Absolute Positions}: the absolute positions of elements in a chart are crucial for determining their graphical roles and spatial relationships. But in many cases, an element's position is not expressed in absolute coordinates. Instead, the positions are often described using transformations such as ``translate'' or the matrix function; \textbf{(4) Noise in Scene Graph}: it is non-trivial to distinguish visualization marks from graphical objects that are not part of the main visualization, which include off-screen tooltips, transparent or white rectangles serving as backgrounds, and   random watermarks drawn as $<$path$>$ elements.

% \remove{In addition to these complications, the vast design space of visual representations also makes reusing existing SVG visualizations a great challenge. Chart designs may vary in terms of breadth (i.e., broad chart typologies such as line, bar, and pie) and depth (i.e., design variations within a particular type, in terms of encoding, visual style, and structure such as nested layout). It is unlikely that one single approach can solve the problem of  reusing \textit{any} real-world SVG example. Previous work thus carefully defines the scope of reuse. For example, Harper et al. focus on basic chart types created using D3 where the source data is available \cite{harper_converting_2017}, Chartreuse \cite{cui_mixed-initiative_2022} handles infographics bar charts within Microsoft PowerPoint graphics assets, and Chen et al. focus on timeline infographics in raster image formats \cite{chen_towards_2020}.}


% \subsection{Scope}

% \remove{Given the challenges identified above, we decided to focus on SVG visualizations composed of \textit{rectangle marks} in this paper. Our goal is to strive for depth, instead of breadth. Rectangle-based charts are commonly seen and used on the web~(as reported in~\cite{battle_beagle_2018}), and rectangle marks afford a variety of sufficiently expressive designs,  e.g., grouped or stacked bar charts and range charts for comparison and trends, waterfall charts for trends and changes, gantt charts for timeline events, calender charts and heatmaps for quantitative data display, waffle charts and treemaps for ratios, and bespoke designs for customized needs. Furthermore, rectangle marks can be easily organized into nested structures such as small multiples and multi-level layouts. Such complex structures have not been explored in previous work.\\
% It is non-trivial to automatically reverse-engineer and obtain a deep understanding of examples composed of rectangles. Take \textit{position}, one of the most commonly used visual channels, as an example: the position of a rectangle in a chart can be determined by a range of factors such as layout (e.g., grid or packing), data (e.g., position is encoding data value), structure (e.g., nested groups), alignment (e.g., rects aligned to the top inside a grid layout), and relation to other marks (e.g., position constrained at a fixed distance from another mark). Multiple such factors may jointly determine a rectangle's position in a chart, for instance, a small multiple of bar charts in \cref{fig:teaser}(g). Given a random example, the system must be able to tease apart these factors to describe the components of a chart design precisely.}


\subsection{Preprocessing}\label{preprocessing}

Since real-world SVG charts are messy and far from ready to be reused, we perform the following preprocessing tasks to clean up a given chart: 

\bpstart{Converting to JSON Representation} The XML format used in the SVG charts is not very amenable to processing and inference, we thus first 
convert a given chart into a JSON object, recording attribute-value pairs for each element.
We also record additional information such as each element's parent. In cases where the marks' visual styles (e.g., stroke color) are stored in their parent groups, we record these styles as the attributes of marks.

\bpstart{Obtaining Absolute Position} 
To calculate the absolute position of each element, our SVG parser applies an element's transformation~(if any) to its children elements.
The transformations can accumulate across multiple levels 
and the parser will iteratively update the transformation until reaching a leaf node.

\bpstart{Identifying and Filtering Rectangle Marks} 
To capture the rectangle marks represented as $<$path$>$ elements, 
we run 
a rectangle test for each $<$path$>$ element. This test parses the \textit{d} attribute of the $<$path$>$ element, records the vertices on this path, and determines whether the vertices are forming four corners of a rectangle. A $<$path$>$ element that passes this test is converted into a rectangle element in the JSON object, and its attributes are updated accordingly. We perform similar tests for lines represented as paths. Our parser also excludes dummy rectangles, such as transparent rectangles and rectangles with zero height and width.