\section{SVG Pre-processing}\label{sec:svg}

% We first give detailed explanations for the challenges mentioned in~\cref{sec:SVGchallenges}: \textbf{ (1) Inconsistent SVG Element Types}: the same mark type may be represented using different types of SVG elements. For instance, we have observed in multiple examples that a rectangle mark is represented using a $<$path$>$ element, and an axis is drawn as a thin rectangle. Thus, We cannot determine the mark type based on the SVG element type; \textbf{(2) Missing Absolute Positions}: the absolute positions of elements in a chart are crucial for determining their graphical roles and spatial relationships. But in many cases, an element's position is not expressed in absolute coordinates. Instead, the positions are often described using transformations such as ``translate'' or the matrix function; \textbf{(3) Noise in Scene Graph}: it is non-trivial to distinguish visualization marks from graphical objects that are not part of the main visualization, which include off-screen tooltips, transparent or white rectangles serving as backgrounds, and random watermarks drawn as $<$path$>$ elements; and \textbf{ (4) Arbitrary Grouping of Elements}: the semantic information in SVG visualizations in the wild is often unreliable. In particular, the grouping of SVG elements can be arbitrary. For example, stacked bar charts created using different tools exhibit vastly different grouping structures~(\cref{fig:svg-g}); axis labels can be either within one group or in their own individual groups.

Since real-world SVG charts are messy and far from ready to be reused, we perform the following preprocessing tasks to clean up a given chart. 

\bpstart{Converting to JSON Representation} The XML format used in the SVG charts is not very amenable to processing and inference. We thus first 
convert the given chart into a JSON object, recording attribute-value pairs for each element.
We also record additional information such as each element's parent. In cases marks' visual styles (e.g., stroke color) are stored in their parent groups, we record these styles as the marks' attributes.

\bpstart{Obtaining Absolute Position} 
To calculate the absolute position of each element, our SVG parser applies an element's transformation~(if any) to its children elements.
The transformations can accumulate across multiple levels 
and the parser will iteratively update the transformation until reaching a leaf node.

\bpstart{Identifying and Filtering Rectangle Marks} 
To capture rectangle marks represented as $<$path$>$ elements, 
we run 
a rectangle test for each $<$path$>$ element. This test parses the \textit{d} attribute of the $<$path$>$ element, records the vertices on this path, and determines whether the vertices are forming four corners of a rectangle. A $<$path$>$ element that passes this test is converted into a rectangle element in the JSON object, and its attributes are updated accordingly. We perform similar tests for lines represented as paths. Our parser also excludes dummy rectangles, such as transparent rectangles and rectangles with zero height and width.

% Note that the last challenge cannot be addressed by pre-processing only; we include how Mystique determines grouping and other semantic components that jointly decide chart layouts in~\cref{sec:chartDecomp}.