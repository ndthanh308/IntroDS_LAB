\section{The FruitChain Protocol}\label{sec:description}

In this section, we devise an adaptation of the FruitChain protocol~\cite{fruitchain} to the EVP framework of~\cite{EVP} outlined in Section~\ref{sec:framework}. In our adaptation, we take into account the cost of a random oracle query as well as the costs of deciding on a new local state, validating retrieved messages, and extracting sequences of records of transactions. Before the presentation of our adaptation, we provide an overview of the original  protocol description.

\subsection{Overview of the FruitChain Protocol}\label{subsec:overview}
In the FruitChain protocol \cite{fruitchain}, miners store transactions in \textit{fruits} instead of blocks. In order for a miner to create a fruit, it needs to perform PoW, as it does to produce blocks, yet fruit mining has lower difficulty. In more detail, the miner performs a 2-for-1 PoW procedure introduced in \cite{backbone}. In particular, the miner computes hashes of a specific input, where the prefix and the suffix of the hash determine whether a block or a fruit has been mined, respectively. Fruits are stored in blocks and they need to be \textit{recent} i.e., every fruit points to a block that is not far from the latest block of the ledger. 

At a high level, the FruitChain protocol prevents selfish mining attacks~\cite{selfish} because even if an attacker withholds a block, the fruits of this block that are still recent can be stored in a later block. The restriction of recency exists so that an attacker is not able to precompute an excessive amount of fruits and reveal it later, thus disrupting the \textit{chain quality} of the protocol\footnote{Chain quality was introduced in \cite{backbone} and is related to the fraction of the adversarial blocks in a sufficiently long segment of the ledger.}.  

\subsection{Parameterization and Basic Concepts}\label{subsec:basic}
%
The FruitChain PoW protocol is parameterized by:
\begin{enumerate}
    \item A \emph{random oracle} $\oracle(\cdot)$ that outputs strings of length $\geq 2\secpar$. The oracle responds to (block and fruit) mining queries.
    \item A \emph{collision resistant hash function} (CRHF) $\digest(\cdot)$, utilized to digest sets of fruits.
    \item A \emph{block mining hardness parameter} $\pb$. This is the probability that the $\oracle(\cdot)$ response leads to the successful mining of a block. 
    \item A \emph{fruit mining hardness parameter} $\pf$. This is the probability that the $\oracle(\cdot)$ response leads to the successful mining of a fruit. Probability $\pf$ is significantly greater {than $\pb$}.
    \item A \emph{recency parameter} $\recency$ that determines how far back can a fruit ``hang'', i.e., the fruit needs to point to an earlier block in the chain which is not too far from the block which records the fruit itself. 
\end{enumerate}

The structure of a valid fruit $\fruit$ is denoted by $\fruit=\langle \previous,h_f,\nonce,$ $\msf{dig},\record,h\rangle$, where 
\begin{itemize}
    \item[-] $\previous$ points to the previous block's reference.
    \item[-] $h_f$ is the \emph{pointer} of $\fruit$ to the block that $\fruit$ is hanging from.
    \item[-] $\record$ is the record to be contained in $\fruit$.
    %\item[-] $\nonce$ is a random nonce denoting the solution to a computational puzzle that is derived from the pair $(\previous,\record)$.
    \item[-] $\nonce$ is a random nonce denoting a solution to the computational puzzle that derives from conditions (1),(2) in Definition~\ref{def:valid_fruit}.
    \item[-] $\msf{dig}$ is the digest of some set of fruits $\mbf{F}$.%, necessary for the verification of the $\fruit$'s validity (see below).
    \item[-] $h$ is the reference of $\fruit$, i.e., a hash of the previous fields.
\end{itemize}
%
\begin{definition}[Fruit validity]\label{def:valid_fruit}
A fruit $\fruit:=\langle \previous,h_f,\nonce,\msf{dig},\record,h\rangle$ is \emph{valid}, if the following hold:
\begin{enumerate}
    \item $\oracle(\previous||h_f||\nonce||\msf{dig}||\record)=h$.
    \item $[h]_{-\secpar}<D_{\pf}$, where $[h]_{-\secpar}$ denotes the last $\secpar$ bits of $h$, and $D_{\pf}$ is the difficulty value such that the probability that an input satisfies the relation is $\pf$.
    
\end{enumerate}
We say that a fruit set $\mbf{F}$ is \emph{valid}, if either it contains only valid fruits, or $\mbf{F}=\emptyset$.
\end{definition}

The structure of a valid block $\block$ is denoted by $\block:=\langle\langle \previous,h_f,\nonce,$ $\msf{dig},\record,h\rangle,\mbf{F}\rangle$, where 
\begin{itemize}
    \item[-] $\previous$ points to the previous block's reference.
    \item[-] $h_f$ is some fruit pointer.
    \item[-] $\record$ is the record to be contained in some fruit.
    \item[-] $\nonce$ is a random nonce denoting a solution to the computational puzzle that derives from condition (3),(4) in Definition~\ref{def:valid_block}.
    \item[-] $\msf{dig}$ is the digest to the set of fruits $\mbf{F}$.
    \item[-] $h$ is the reference of $\block$, i.e., a hash of the previous fields.
    \item[-] $\mbf{F}$ is the fruit set to be included in $\block$.
\end{itemize}
%
\begin{definition}[Block validity]\label{def:valid_block}
A block $\block=\langle\langle \previous,h_f,\nonce,\msf{dig},\record,$ $h\rangle,\mbf{F}\rangle$ is \emph{valid}, if the following hold:
\begin{enumerate}
\item $\msf{dig}=\digest(\mbf{F})$.
\item $F$ is a valid fruit set.
    \item $\oracle(\previous||h_f||\nonce||\msf{dig}||\record)=h$.
    \item $[h]_{:\secpar}<D_{\pb}$, where $[h]_{:\secpar}$ denotes the first $\secpar$ bits of $h$, and $D_{\pb}$ is the difficulty value such that the probability that an input satisfies the relation is less than $\pb$. 
\end{enumerate}
\end{definition}

\begin{remark}
By making a query to $\oracle(\cdot)$, the party cannot know in advance whether the response hash value $h$ will lead to the successful mining of a fruit and/or block, or neither of two. Thus, the fields $\previous$ and $\msf{dig}$ are included in a fruit (resp. $h_f$ and $\record$ are included in a block) only for mining purposes. 
\end{remark}


Let $\chain_i$ be the ledger state in the view of party $\party{i}$. By $\chain_i[j]:=\langle\langle \previous^{i,j},$ $h_f^{i,j},\nonce^{i,j},\msf{dig}^{i,j},$ $\record^{i,j},h^{i,j}\rangle,\mbf{F}^{i,j}\rangle$, we denote the $j$-th block of $\chain_i$ and by $|\chain_i|$ the length of $\chain_i$. 

\begin{definition}[Fruit recency]\label{def:fruit_recency}
A fruit  $\fruit:=\langle \previous,h_f,\nonce,\msf{dig},\record,h\rangle$ is \emph{recent} w.r.t. $\chain_i$ if it points to some of the last $\recency\cdot\kappa$ blocks of $\chain_i$, i.e., there exists some $k>|\chain_i|-\recency\cdot\kappa$ such that $h_f=h^{i,k}$. 
\end{definition}

\begin{definition}[Chain validity]\label{def:valid_chain}
A chain $\chain_i$ is \emph{valid}, if the following hold:
\begin{enumerate}
    \item The chain is rooted at the special ``genesis'' block, i.e., 
    \[\chain_i[0]=\langle\langle0,0,0,0,\bot,\oracle(0,0,0,0,\bot)\rangle,\emptyset\rangle\;.\]
    \item Each block is valid according to Definition~\ref{def:valid_block} and refers to the previous block's reference, i.e., 
    \[\forall j\in[|\chain_i|]: \previous^{i,j}=h^{i,j-1}\;. \] 
    \item For every $j\in[|\chain_i|]$ and every $\fruit:=\langle \previous,h_f,\nonce,\msf{dig},\record,$ $h\rangle\in\mbf{F}^{i,j}$, there exists some $k>j-\recency\cdot\kappa$ such that $h_f=h^{i,k}$.
\end{enumerate}
\end{definition}



%\subsection{Protocol Description}\label{subsec:protocol_description}
For completeness, we describe the FruitChain PoW protocol $\protocol$ as presented in~\cite{fruitchain}, parameterized by $\oracle(\cdot),\digest(\cdot),$ $\pb,\pf,\recency$, in Figure~\ref{fig:fruitchain_description}.

\subsection{The FruitChain Protocol in the EVP Framework}\label{subsec:fruitchain_framework}
%
We abstract the FruitChain protocol $\protocol$ as the protocol $\protocolevp$, that specifies the oracles below:
\begin{enumerate}
    \item The \emph{longest chain oracle} $\mc{O}_\msf{lc}$: receives as input a state $\chain$ and an array of blocks $\tilde{\mathbb{B}}$. It stores $\tilde{\mathbb{B}}$ in its memory.
    Given $\chain$ and all the arrays of blocks that are stored in its memory, it constructs a set $\mbf{A}$ that includes all the chains that can be formed. It checks which of these chains are valid according to Definition \ref{def:valid_chain} and constructs a set $\mbf{A}'\subset \mbf{A}$ with these chains. 
    It finds the longest chain(s) of $\mbf{A}'$ denoted by $\chain^1, \ldots, \chain^l$. If $l> 1$, then it finds $i_0 \in \lbrace 1,\ldots,l\rbrace$ such that the last block in $\chain^{i_0}$, denoted by $\chain^{i_0} [|\chain^{i_0}|]$, appears first in $\tilde{\mathbb{B}}$.
    If $|\chain^{i_0}|>|chain|$, it sets $\chain' \leftarrow \chain^{i_0}$, otherwise $\chain' \leftarrow \chain$. It sets as $h_f$ the reference of $\chain'[\mathsf{max}\{1,$ $|\chain'|-\kappa\}]$, and as $\previous$ the reference of $\chain'[|\chain'|-1]$. %It executes the procedure $\mathtt{Extract\_Fruit}(\chain')$ (without checking again if $\chain'$ is valid) and extracts the sequence of records
    %$\big(\record_{1},\ldots,\record_{\ell_2}\big)$. 
    It extracts the sequence of records
    $\big(\record_{1},\ldots,\record_{\ell_2}\big)$ included in the fruits of $\chain'$ (by executing the procedure $\mathtt{Extract\_Fruit}(\chain')$ in Figure~\ref{fig:fruitchain_description} without checking again if $\chain'$ is valid).
    It outputs $\chain',\previous,h_f$ and $\big(\record_{1},\ldots,\record_{\ell_2}\big)$. The party can make up to $1$ query per round and the single query cost is $C_\msf{lc}$.
    
    
    
   \iffalse Input: $\chain$, diffuse fruits+blocks. Output: $\chain',\previous,h_f$, sequence of records.\fi
    
    %
    \item The \emph{fruit set oracle} $\mc{O}_\msf{fs}$: receives as input a state $\chain'$ and two sets of fruits $\tilde{\mbf{F}},\tilde{\mbf{F'}}$. It finds the subset $\mbf{X}$ of $\tilde{\mbf{F'}}$ that includes all the valid fruits of $\tilde{\mbf{F'}}$ according to Definition~\ref{def:valid_fruit}. It returns the set of fruits $\mbf{F}=\tilde{\mbf{F}} \cup \mbf{X} $, the set $\mbf{F}_\msf{rec}\subseteq\mbf{F}$ of valid fruits that are recent w.r.t. $\chain'$ for recency parameter $r$ (Definition~\ref{def:fruit_recency}) and are not already in $\chain'$, and the digest $\digest(\mbf{F}_\msf{rec})$. 
    The party can make up to $1$ query per round and the single query cost is $C_\msf{fs}$.
    %
    \item The \emph{transaction oracle} $\mc{O}_\msf{tx}$: receives as input a set of transactions $\{\tx_1,\ldots,\tx_{\ell_1}\}$ and a sequence of records $(\record_1,\ldots,\record_{\ell_2})$. It computes a record of transactions $\record$ that includes all the transactions of $\{\tx_1,\ldots,\tx_{\ell_1}\}$ that are valid according to $(\record_1,\ldots,\record_{\ell_2})$, where transaction validity is defined in a protocol-specific manner. It outputs $\record$. The party can make up to $1$ query per round and the single query cost is $C_\msf{tx}$.
    %
    \item The \emph{random oracle} $\mc{O}_\msf{ro}$:  on a general query $x\in\{0,1\}^*$ checks if there is a stored pair $(x,\cdot)$. If there is not such a pair, it randomly samples an image denoted by $H(x)$ from $\{0,1\}^{2\secpar}$, stores $(x,H(x))$ and returns $H(x)$. Otherwise, it returns $(x,H(x))$.
    In our setting, the queries will have the form $\previous||h_f||\nonce||\digest(\mbf{F}_\msf{rec})||\record$ and the response will be a reference~$h$. The party can make up to $q$ queries per round and the single query cost is $C_\msf{ro}$.
    
    
 
\end{enumerate}
% Figure environment removed
\normalsize

% Figure environment removed
\normalsize

Given the description of $\mc{O}_\msf{lc},\mc{O}_\msf{fs},\mc{O}_\msf{tx},\mc{O}_\msf{ro}$, and the terminology in Subsection~\ref{subsec:basic}, the blockchain protocol $\protocolevp$ is presented in Figure~\ref{fig:fruitchain_evp}. At this point, we provide an overview of the  $\protocolevp$ protocol.\\[2pt]
%
\indent\emph{Overview of  $\protocolevp$.}
Each party stores all the fruits that are valid. Note that the validity of each fruit (cf. Definition \ref{def:valid_fruit}) does not depend on which chain constitutes the ledger, unlike the recency of the fruit (cf. Definition \ref{def:fruit_recency}). %something that does not happen with the ``recency'' of the fruit according (cf. Definition \ref{def:fruit_recency}). Recall that a fruit is recent only if it points to a block that is buried under at most $\recency\cdot\kappa$ blocks, where $\recency$ is the recency parameter and $\kappa$ the security parameter.
\par 
During each round, when a party is activated, it receives a set of transactions $\{\tx_1,\ldots,\tx_{\ell_1^T}\}$ as input from the environment, and retrieves all the fruits and blocks diffused in the previous round. Then, it gives as input to the longest chain oracle $\mc{O}_\msf{lc}$ its current chain and the blocks it retrieved, and it receives as output (i) the chain $\chain'_i$ that the party will extend and is the longest valid chain, (ii) the hash of the last block of this chain, (iii) the hash of the block to which the fruits that will be produced in this round will point and (iv) all the records of $\chain'_i$.
\par Next, the party gives as input to the fruit set oracle $\mc{O}_\msf{fs}$ the chain $\chain'_i$, the set of the valid fruits it retains and the fruits it retrieved. It receives as output (i) the updated set of the valid fruits that includes also the fruits that it retrieved and were valid (ii) the valid fruits that are recent w.r.t. $\chain'_i$  and are not already in  $\chain'_i$, and (iii) the digest of the set of these fruits which works as a ``fingerprint''.
\par  Afterwards, the party makes a query to the transaction oracle $\mc{O}_\msf{tx}$ with input the transactions $\{\tx_1,\ldots,\tx_{\ell_1^T}\}$ it received from the environment and the records $(\record_1,\ldots,\record_{\ell_2^T})$ that received from $\mc{O}_\msf{lc}$. It outputs a record that includes the transactions of $\{\tx_1,\ldots,\tx_{\ell_1^T}\}$ that were valid w.r.t. $(\record_1,\ldots,\record_{\ell_2^T})$ (transaction validity is defined in a protocol-specific way) and will be included in the instance that will be used for the queries to the random oracle $\mc{O}_\msf{ro}$.
\par Finally, it makes $q$ queries to the random oracle with input an \emph{instance} that includes: (a) the hash of the last block in $\chain'_i$, (b) the hash of the block to which the new fruits will point, (c) a nonce, (d) the digest of the recent fruits, and (e) the output of the transaction oracle. When it receives an output from the random oracle, it checks (i) if the last $\secpar$ bits are lower than $D_{\pf}$, and (ii) if the first $\secpar$ bits are lower than $D_{\pb}$. If (i) holds, a fruit has been produced, so it sends this fruit to the Diffuse functionality. If (ii) holds, then a block has been produced, so it sends this block to the Diffuse functionality and stops checking (ii) in the queries.\\[2pt] 
%
\indent\emph{Assignment of rewards.}
We consider that every fruit included in a block that is part of the ledger mints  $\reward$ rewards and sends them to the party specified in the `` coinbase '' transaction\footnote{\url{https://en.bitcoin.it/wiki/Coinbase}}  in the fruit's record $\record$. Note that the rewards and costs of querying the protocol's oracles are in the same unit.



\noindent Below, we discuss the differences between the descriptions of $\protocolevp$ and $\protocol$.

\begin{enumerate}
    \item The environment provides transactions, not records. In addition, $\protocolevp$ checks if the transactions provided by the environment are valid according to the party's local chain. We do not specify when a transaction is valid according to the party's local chain because this depends on the format of the transactions the protocol accepts.  
    \item (i) The party makes $q$ queries to the random oracle $\mc{O}_\msf{ro}$ per round (instead of $1$) (ii) each party can produce at most one block per round. These modifications are in line with the execution model of \cite{backbone}.
    \item The party returns just `$\msf{complete}$'  and the number of the round to the environment, instead of a sequence of records. Note that as the party diffuses its blocks, the environment can receive them via its interaction with the adversary. %So, there is no need for the party to execute procedure $\mathtt{Extract\_Fruit}(\chain_i)$.  
    \item The party diffuses only the blocks that it received during the previous round and the blocks and fruits that it has produced during the current round; unlike in $\protocol$, the party does not diffuse its whole chain every time it produces a new block. On the other hand, the longest chain oracle $\mc{O}_\msf{lc}$ stores all the blocks it receives from the beginning of the execution. This approach reflects the realistic setting where the parties' local chains are not communicated over the network during the mining process.
    Instead, only the newly mined blocks are normally diffused, and the miners can reconstruct all possible chains given the received blocks they have recorded throughout the execution \footnote{\url{https://wiki.bitcoinsv.io/index.php/Main_Page}}. Note that when the network is synchronous, which means that at the end of each round all the messages diffused by honest parties are delivered to every other honest party, the approach in $\protocolevp$ ``implies'' the one in $\protocol$. Namely, due to synchronicity,
    in the beginning of round $T$, every honest party $
    \party{i}$ can \emph{recursively} reconstruct the local state $\chain_j$ of another honest party $
    \party{j}$  given its view of $
\chain_j$ in the beginning of the previous round $T-1$ and the blocks of $
    \party{j}$ that $
    \party{i}$ received by the end of $T-1$ (note that all honest parties' states are initialized as $\langle\langle0,0,0,0,\bot,\oracle(0,0,0,0,\bot)\rangle,\emptyset\rangle$, so recursive reconstruction is feasible across honest parties as rounds progress).
    Besides, at any moment during round $T$, $\party{i}$ can reconstruct $\chain_j$ via its view of $\chain_j$ in the beginning of $T$ and the blocks and fruits received from $
    \party{j}$ since the beginning of the round.      
    %
    \item The recipient of the fruit's rewards is the party specified in the ``coinbase'' transaction. In \cite{fruitchain} the fruit's rewards are shared evenly among the miners of the fruits that belong to a preceding part of the ledger. Note that we follow the approach of \cite{EVP} which is equivalent to the approach of \cite{fruitchain} when we do not take into account transaction fees, which means that we assume that each fruit gives the same rewards.
    
\end{enumerate}

































