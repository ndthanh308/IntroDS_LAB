\section{Semi-automated TV GUI Generation}
Motivated by our empirical findings and the official layout criteria for Android TV~\cite{AndroidTV}, 
we here propose our semi-automated Android-based TV GUI generation approach.
Our approach develops a lightweight migration system that converts run-time GUIs in a series of phases, including component recognition and grouping, template matching, layout optimization, and GUI domain-specific languages (DSL) generation.
The overall pipeline of our approach is illustrated in Figure~\ref{fig:pipeline}.

We first gather the run-time GUI metadata generated by UI Automator\cite{uiautomator}, including screenshots and GUI metadata, and analyze hierarchical metadata to identify GUI components.
% metadata consists of the hierarchical DOM (Document Object Model) tree of GUI and rendered properties such as bounding box, layout, and type of GUI components.
Secondly, to construct a suitable GUI mapping, we design a component grouping algorithm that leverages the GUI information extracted from metadata to group isolated elements properly.
Thirdly, we compare elements' attributes and hierarchical similarities to classify grouped elements into appropriate types and match corresponding TV templates.
Then, we optimize the whole GUI layouts to adapt TV screens by OR-constraints~\cite{jiang2019orc, jiang2020orcsolver}.
Finally, given the incompatibility of phone and TV systems, a cross-platform TV GUI DSL is designed to describe generated TV GUI for further compilation and rendering. 
% To explain the approach, we first describe the methodology at a high level for each phase and then explain details. 



% Figure environment removed

\subsection{Component Grouping}
\label{sec:group}
As mentioned in Section~\ref{sec:GUIgroup}, we first group isolated GUI components to GUI groups as the basic unit of follow-up work.
We parse metadata captured by UI Automator to accurately infer the pix-based coordinate of GUI components' bounding box and classify these components to proper types like \textit{TextView}, \textit{ImageView}, and \textit{Button}.
Once each GUI component's bounding boxes and type in a rendered screen are confirmed, the next phase is to group atomic components with similar domain-specific functions to one component group.
% Group-level GUI conversion is current main-stream method and widely-used in variety app categories in terms of the summarization in Section~\ref{sec:implication}.
Figure~\ref{fig:grouping} illustrates a running example for our component grouping algorithm. %\todo{can you highlight the steps in Fig 5 e.g. (1), (2), (3) etc and refer to /explain in text below?} \fix{fixed}
Overall, the algorithm consists of three-level grouping with different assembly granularities. 
To begin, we gather all atomic components that have significant relationships, as well as all images and their text descriptions.
Second, we then group components in the same row by their hierarchy, type, and total width.
Third, we then merge adjacent rows with the same hierarchy and pix-based areas.

% Figure environment removed


\subsubsection{Atomic Components Grouping}
Regarding text pairs are very close on the Y axis, they tend to be a pair of descriptions, with the caption at the top and the additional explanation of the caption at the bottom~\cite{neil2014mobile, andriodUI, zhang2021screen}.
Texts below or on the right of images always have strong semantics with them, such as previewed movie names, image descriptions, etc~\cite{neil2014mobile, andriodUI}.
Thus, heuristics are designed to aggregate relevant components based on component type, position, size, and structural relationship.

For text pair grouping, given upper text $T_u$ and below texts set $T_s$, if texts in $T_s$ meet the following requirements, they will be grouped with $T_u$: 
(1) On X-axis, $T_u$ and $T_s$ overlap, or the gap between them must be less than $0.025 \times screen\ horizontal\ resolution$.
(2) On Y-axis, $T_s$ is the closet element around the $T_u$. The gap between them must be lower than $0.025 \times screen\ vertical\ resolution$.
% (3) $T_c$ and $T_s$ must in one GUI subtree.
% (3) If $T_c$ and $T_s$ are all leaves of some specific element type, such as \textit{ListView} and \textit{RecyclerView}, they will be grouped together, regardless of the constrains on X and Y axes.
We employ the subsequent three phases to confirm that our heuristics contains sufficient relevant component possibilities and to acquire the best applicable empirical parameters.
Following the relevant work of Xiaoyi etc.~\cite{zhang2021screen} and the official Android GUI design guidelines~\cite{AndroidTV, adaptiveUI}, we first determine all potential positions and distance range of the images and their accompanying isolated UIs.
Second, we randomly selected 10 GUI pages in each category of our collection of phone apps (90 GUI pages in total).
We experiment on the selected data to verify whether our heuristic rule can cover all the relevance possibilities.
The experimental results indicate that our heuristic principles are capable of covering all possibilities in existing GUIs. 
Finally, we assessed the impact of all empirical coefficients within the range provided by Android official guidelines on the selected pages in increments of 0.001 $\times$ the current screen's horizontal and vertical resolution. 
We ultimately determined 0.025 to be the optimal empirical coefficient.
Potential compatibility issues with phones and apps may lead to distorted or misaligned UI components in the GUI, making our heuristic principles inapplicable.
However, these circumstances can be rectified by developers through subsequent development.

For image relevant texts grouping, given texts set $T$ and image $I$, if texts in $T$ meet the following requirements, they will be grouped with $I$:
(1) On Y-axis, $T$ is the closet element below the $I$ and the gap between $T$ and $I$ must be less than $0.025 \times screen\ vertical\ resolution$.
% a predefined threshold. In this work, we set the threshold to 0.025*screen vertical resolution. In some phones with lower vertical resolution than 2340, we set the threshold as 0.03*screen vertical resolution.
(3) On X-axis, the midpoints of $T$ and $I$ are the same. If not, their overlap on X-axis must be more than 50\% of the smaller one in $T$ and $I$.
(4) If $T$ is in a grouped text pair, pack both texts as the relevant texts of $I$.  %\todo{can you refer to an example of this e.g. in Fig 5?} \fix{fixed}
% (3) If $I$'s width is less than the minimum of a GUI subtree's width, $I$ and $T$ must in one cutted subtree.


\begin{algorithm}[]
\setlength{\parskip}{0.2cm plus4mm minus3mm}
\caption{Row Components Grouping}
\label{alg:domBased}
\begin{algorithmic}[1]
\Require DOM tree $Tree$, required group width $W_{group}$
\Ensure Row components group set $G$
\State $Leaves \leftarrow []$
\ForEach{component $c \in C$}
    \If{length(getChildren ($c$)) == 0}
        \State $Leaves$.add($c$) \textcolor{gray}{//collect all leaves in $tree$}
    \EndIf
\EndFor
\ForEach {Leaf $l \in Leaves$}
    \State $node_{cur} \leftarrow l$, $W_{cur} \leftarrow $ $l$.width
    \While{$W_{cur} <= W_{group}$}
        \State $p \leftarrow$ getParent($l$) \textcolor{gray}{//Backtrack to the parent node $p$ of $l$ in $Tree$}
        \State $node_{cur} \leftarrow p$, $W_{cur} \leftarrow $ $p$.width
    \EndWhile
    \State $S \leftarrow$ trimTree($node_{cur}$) \textcolor{gray}{//Trim $tree$ at node $node_{cur}$ to get a subtree $S$}
    \State $g_l \leftarrow []$  \textcolor{gray}{// the set to collect all leaves in $S$ }
    \ForEach{$l^{\prime}  \in S$}
    \If{$l^{\prime} \in L$}
    \State $g_l$.add($l^{\prime}$)
    \EndIf
    \EndFor
    \State $G$.add($g_l$ ) \textcolor{gray}{//Add $g_l$ to $G$}
\EndFor
\State \Return $G$
\end{algorithmic}
\end{algorithm}

\subsubsection{Row Components Grouping}

According to Google's Android design guide~\cite{androidGuidelines, andriodUI}, the standard UI design typically treats each row as the fundamental unit. 
Therefore, the UI components in the phone are arranged in rows.
The metadata of the phone's GUI, as illustrated in Figure~\ref{fig:pipeline}, describes its GUI hierarchy in the form of an XML DOM tree.
UI components in the same row are in the same subtree in the DOM tree.
% UI components in the same GUI group also tend to be in the same DOM subtree.
The purpose of our row components grouping is thus to trim the subtrees from the DOM tree that contains all UI components in one row.
When the algorithm finds that components inside the same DOM subtree have occupied an entire row, it will put all of these components into one group.

% Figure environment removed

\subsection{TV Template Matching}
Algorithm~\ref{alg:domBased} demonstrates our row components grouping process.
It utilizes a DOM tree ($tree$) of metadata and a pre-defined group width parameter ($W_{group}$) as inputs. 
The latter is a critical determinant dictating when to partition a subtree representing a row on the screen. 
Specifically, when the subtree's width extends to match the phone screen's width, it is deemed to occupy an entire row. 
Given that GUI elements are always displayed with margins on both the left and right sides of the screen, we empirically define the requisite width as 0.85 times the total screen width in this work.
The output of Algorithm~\ref{alg:domBased} is the grouped components \emph{G}.
The leaf nodes in the DOM tree are the specific UI components, so Alg.~\ref{alg:domBased} first walks from the root node of the DOM tree to the terminal leaves, collecting all leaves $L$ (lines 1-6).
Following the identification of leaf nodes, the algorithm backtracks up the DOM tree from each leaf in $Leaves$ to establish respective subtrees representative of a screen row.
For each leaf $l$, if the width of the current node ($W_{cur}$) exceeds the predefined group width $W_{group}$, prune at node $l$.
If not, backtrack to the current node's parent node $p$.
If the width of $p$ still does not exceed the predefined group width $W_{group}$, the traceback procedure continues until the current node's width meets the criterion that is larger than the predefined width (lines 7-12).
We then trim the DOM tree from the node where the backtracking stops to get the cropped subtree $S$ (line 13).
To group all UI components within a single row, the algorithm subsequently collects all leaves in the subtree $S$ as a group $g_l$ (lines 14-19).



Figure~\ref{fig:rowExample} shows a running example of the Alg.~\ref{alg:domBased}.
The backtracking starts at leaf TextView \emph{Call Me By Fire} and reaches the leaf's parent subtree 1.
However, the width of subtree 1 is less than the required group width $W_{group}$.
We then keep going back to subtree 2, but the width of subtree 2 is still not satisfied.
All the way back to subtree 3, its width is more than the required group width.
The algorithm thus stops at subtree 3 and trims subtree 3 from the GUI DOM tree as a GUI component row.



\subsubsection{Multi-row Components Grouping}
Components in one component group may be spread across multiple rows, such as \textit{ListView} and \textit{GridLayout}.
In these component groups, the components of different rows tend to have the same structure and component types.
% To merge a realistic multi-row group, the heuristic 'Multiple rows in one group have the same structure and component types' is followed to infer whether adjacent rows merge or not.
Thus, given two adjacent rows $r_i$ and $r_j$, based on their bounding boxes, we compute the relative positions of the upper left and lower left corners of components in each row. If components in $r_i$ and $r_j$ have the same types and relative upper left and lower left corners, two rows will be grouped.
As shown in Figure~\ref{fig:rowExample}, subtree 3 has the same structure as the row below, so merge these two rows into one GUI group in step 4.
Note that we allow two rows in one group in the implementation with one different component.



\begin{comment}

\begin{algorithm}[h]
\setlength{\parskip}{0.2cm plus4mm minus3mm}
\caption{Group Template Matching}
\label{alg:temMatch}
\begin{algorithmic}[1]
\Require GUI group templates $TPL$, GUI group $GR$, threshold $TH$
\Ensure  Classified GUI group $GR'$
\State  Maximum number of matching attributes $maxMatchedAttr \leftarrow 0$
\ForEach{GUI group templates $t \in TPL$}
    \State $matchedAttr \leftarrow matchAttr(GR, t)$ \textcolor{gray}{//match attributes between $GR$ and $t$}

    \State $maxMatchedAttr \leftarrow max(matchedAttr, maxMatchedAttr$) \textcolor{gray}{//update the maximum number of matching attributes}
\EndFor
\State Matched template $GR' \leftarrow Grid Layout$
\If{$maxMatchedAttr > TH$}
    \State $GR' \leftarrow getTpl(maxMatchedAttr, TPL)$ \textcolor{gray}{//get the corresponding GUI group template of the $maxMatchedAttr$}
\EndIf

\State \Return $GR'$
\end{algorithmic}
\end{algorithm}


As shown in Table~\ref{tab:attribute}, we conclude five attributes for seven patterns when used in classification in case of complete data.
We conclude the matching attributes in their metadata of all GUI groups.
The attributes include the component type, position, and relationship with their sibling components.
The built-in attributes of the group \textit{Top Tab Layout}, \textit{Bottom Tab Layout}, \emph{Tool Bar}, \emph{Search}, \emph{Video/Music Player}, \emph{List View}, and \emph{Side Nav} are the component type \textit{Tab layout} and position, similar with \textit{Tool Bar}, which can be inferred from its type \textit{ActionBar} and position.
\end{comment}

We use GUI built-in and visual features to categorize groups and match related templates after component grouping.
% The matching process is shown in Alg~\ref{alg:temMatch}.
% We first summarize the unique attributes for each type of group (the input GUI group templates $TPL$ in Alg~\ref{alg:temMatch}).
We first summarize the unique attributes of each type of group.
The built-in attributes of the group \textit{Top Tab Layout}, \textit{Bottom Tab Layout}, \emph{Tool Bar}, \emph{Search}, \emph{Video/Music Player}, \emph{List View}, and \emph{Side Nav} are their component types, position and relationship with their sibling components. The unique built-in attributes of the groups \emph{Top Tab Layout}, \emph{Bottom Tab Layout} are the component types and their positions in the GUI pages. 
Both groups will use the GUI components of the tab layout class and will be situated in the upper or lower half of the GUI pages, accordingly. 
Similarly, the unique built-in attributes of the groups \emph{Tool Bar}, \emph{Search}, and \emph{Side Nav} are also their specific component types and positions. 
The group \emph{Tool Bar} is located at the top of the GUI page. 
The \emph{Search} group is located in the upper half of the GUI pages with a search box. 
The \emph{Side Nav} group is located on the leftmost side of the GUI page and has a unique side navigation property in the DOM tree. 
The group \emph{Video/Music Player} and  \emph{List View} also have player and list view attributes unique to the Dom tree, respectively. 
 The image size and related information position features are used to classify groups \textit{Icon + Info}, \textit{Pic Side Info}, \textit{Pic + Info}, and \textit{Big Pic}.
 
When matching templates, we count the number of built-in attributes that each group has in common with each template.
After matching all templates, if the maximum number of matching attributes exceeds the threshold, the most comparable template is assigned to the group. 
If it is below the threshold, the group is deemed unrecognized. In the case of unrecognized GUI groups, we provide a general Grid Layout-based template for their conversion.
The threshold is set at 2 after multiple iterations of error correction based on experimental feedback.


Figure~\ref{fig:templateMatch} demonstrates an example of classifying GUI groups.
We notice when parsing the metadata of this GUI page that there are some GUI components at the top with the fields \emph{searchText}, \emph{searchBtn}, and \emph{search\_container} in their attributes. 
These are similar to the attributes of the \emph{Search} template.
As a result, this GUI group is categorized under the category \emph{Search}.
The top of the page has a GUI group with the class type \emph{ActionBar-Tab}.
Its features of position and class type meet the template \emph{Top Tab Layout}, and hence it is classified to category \emph{Top Tab Layout}.
To proceed, we can now continue to identify GUI groups of categories \emph{Big Pic}, \emph{Pic+Info}, and \emph{Bottom Tab Layout} from the page.

% Figure environment removed

Following the identification of GUI groups in the phone page, we convert these categorized phone GUI groups into matching TV GUI groups using the mapping rule in Table~\ref{tab:matchRules}.

\subsection{Layout optimization}
Due to various screen sizes and design principles, direct layout mapping may lead to issues like large white space on the right or too much content squeezed into a small area.
The Android TV design guidelines~\cite{TVDesign, AndroidTVDe} state that TV layouts should be landscape and have more card-like components since this is more suited to TV interaction and enables the display of only the most essential image and text contents.
So, if we just map each GUI group into the TV screen one by one, or simply change the GUI orientation from portrait to landscape without optimizing the layout, the final produced TV layout would be quite inflexible and violate the design standards of TV GUIs. %\todo{you don't mention TV design standards previously - see my note earlier - be good to briefly discuss these in prev section or beginning of this one?  Or here??}\fix{fixed}

On phone GUIs, huge images frequently take up a whole row, as in Figures~\ref{fig:phoneGroups} and \ref{fig:templateMatch}.
However, the design guidelines for Android TV~\cite{AndroidTV, TVDesign, AndroidTVDe} state that images taking up an entire row would seem to be quite odd and significantly worsen the user experience.
Additionally, if one image is too big, the remaining components will be too small for viewers watching the TV from far away to see.
Currently, as \emph{Desktop mode} in Figure~\ref{fig:currentExamples}, Android's adaptive technology immediately projects onto the TV based on the proportion of its components. 
The slider picture occupied the whole TV screen and entirely obscured the location of other components after being adjusted by the adaptive layout, resulting in an odd overall effect.

To overcome these issues, we propose a TV-based GUI layout OR-constraints~\cite{jiang2019orc, jiang2020orcsolver} to optimize converted TV layouts.
The OR-constraint is a combination of soft constraints, with the whole thing being a hard constraint.
The hard restrictions must be met, but the soft constraints are not required.
We set soft constraints for each component in one row, and all components in one row must meet the hard constraints for the Android TV layout. 
Unlike template-based approaches, which necessitate pre-designing templates and manually specifying rules for when each alternative should be invoked, constraints-based layout optimization can be more flexible and adaptive for a variety of screens without fixed templates and rules.
Different from the Android adaptive GUI layout, the constraint-based layout optimization approach, in conjunction with the TV group template and guidelines, can arrange the layout of UI components on the whole screen. 
This prevents the scenario when some UI components, due to the original size of the phone, are too huge to be transferred to the TV.
%\todo{Would be good to define 'too large' and 'too small' somewhere e.g. in the empirical study, do you identify minimum size of particular TV GUI elements in the study?\fix{fixed}  Are there Android TV guidelines that specify minimu size?  What about 'too big' - any guidelines found in empirical study? Android TV guidelines on this e.g. don't want huge button image, but large video player box probably fine??? \fix{fixed} Are there some elements that can be flexible e.g. video player box - which can be expanded to full TV space?  But what if has specific aspect ratio...?  Is there an ordering e.g. size the ones that have min/max, do the more flexible ones later???}



% Constraint modelling is a widely-used scientifically approach in proven math, in which the outcome of each decision is constrained by a minimum and maximum range of limits~\cite{grant1991constraint}.
% We assign weights for every soft constraint, determining the order in which the soft constraints are satisfied.
%\todo{where did these come from?:}\fix{fixed}
% In our study, we formulate layout constraints and use the SMT solver~\cite{barrett2018satisfiability} to solve these constraints in order to get optimum layouts.

We summarize the layout requirements from the TV design guidelines~\cite{andriodUI, AndroidTV, TVDesign} and our empirical study.
We convert these requirements into constraints, and force converted GUI groups to optimize their layouts to satisfy these constraints.
We lift three predefined heuristics as basic constraints for TV GUI layout:
(1) Arrange GUI widgets from left to right.
(2) If there is not enough space in the current row for the following widget, it will begin on the leftmost side of the next row.
(3) Each component should be put within a predefined size range.
% The preferred size, as well as the minimum and maximum sizes, are all predetermined.
% (4) Assign each UI component a weight based on its size in the original phone GUI.
% If there isn't enough space in the converted TV GUI, components will be removed in order of their weights, from small to large.
Every TV GUI design must adhere to these three hard constraints.
At the same time, TV GUIs also have one soft constraint:
(4) There should be no black gaps on either side of the TV screen, which means the UI Component should fill the whole width of the screen.
% In a phone-TV GUI pair, the mobile GUI tends to have more content than the TV GUI, so we extend the TV GUI vertically.
If there isn't enough space in the converted TV GUI, components will be removed in order of their size in the phone GUI, from small to large.
The Z3 SMT solver~\cite{de2008z3} is used to solve OR-constrains.

%\todo{A concrete example would really help in explaining this:}
The following part shows how we formulate these constraints.
Given a row with $n$ components $W$.
For each component $w_i \in W$, assume its left $w^{left}_i$, width $w^{width}_i$, top $w^{top}_i$, and current available width in the row $r_a$.
Let $w^{height}_j \in W$ denotes the max components height in the current row.
The maximum/minimum widths and heights of components $w_i$ are represented as $width^{max}_i$, $width^{min}_i$, $height^{max}_i$, and $height^{min}_i$.
For the constraint (1), we convert it to the following formula:
\begin{equation}
\begin{aligned}
    C_{1} := (w^{left}_i = w^{left}_{i-1} + w^{width}_{i-1}) \land (w^{top}_i = w^{top}_{i-1}) 
    \\ \land (r_a >= width^{min}_i)
\end{aligned}
\end{equation}
For the constraint (2), it is formulated as
\begin{equation}
\begin{aligned}
    C_{2} := (w^{left}_i = 0) \land ( w^{top}_i >=  w^{top}_j + w^{height}_j)
    \\
    \land (r_a < width^{min}_i)
\end{aligned}
\end{equation}
For constraint (3), we assign preferred widths, and heights for common GUI component types. 
% The preferred values are default values for every component. 
So,
\begin{equation}
\begin{aligned}
        C_{3} := (width^{min}_i <= w^{width}_i <= width^{max}_i) \land \\(height^{min}_i <= w^{height}_i <= height^{max}_i)
\end{aligned}
\end{equation}

For constraint (4), let $r_{tv}$ represent the maximum width of the TV screen in one row, and its logical expression is
\begin{equation}
    C_{soft}^1 := \sum_{i=1}^n (w_i^{width}) = r_{tv}
\end{equation}

Each row represents a single formula unit. If a GUI group covers multiple rows, the GUI group is referred to as a formula unit.
% If a GUI group is completely contained in a row, the current row is the basic unit to be solved. 
% If the GUI group crosses rows, all the rows in which the pattern is located are a basic unit.
For each formula unit, $C_1$ and $C_2$ are OR constraints, and $C_3$ is a hard constraint.
In addition to three basic constraints, some weighted soft constraints $C_{soft}$ are followed. 

The final formula is thus:
\begin{equation}
\label{eq:or}
    C_{unit} := ((C_{1}\ \lor \ C_{2})\ \land \ C_{3}) \lor
    C_{soft}^k
\end{equation}
where $k$ represents the number of soft constraints.
We can dynamically apply new soft constraints to Equation~\ref{eq:or} dependent on the demands of the TV GUI.


% According to current TV GUI design guidelines, there is no constraint on the final height that all widgets occupy in our work.

% In addition to basic constraints, specific constraints apply specific component group too.
% For example, we can see that the related information are always on the right of TV player on TV.
% So, we add a soft constraint for the TV player group: 'Related information is on the right of the TV player, and its top is the same as the TV's top'.
% Assume $w_l$ donates the related information of TV player,
% \begin{equation}
%     C_{soft}^2  := (w^{left}_l = w^{left}_{TV} + w^{width}_{TV}) \land (w^{top}_{TV} = w^{top}_{l}) 
% \end{equation}
% Another important heuristics for soft constraints is 'Assign the weight of soft constraints of the transformed components based on the size of the components in the phone's GUI'.
% If the original component covers more phone screen areas, we prioritize satisfying the component's soft constraints.


\subsection{DSL for GUI Code Synthesis}

In the dynamic world of app development, distinct environments and languages often shape apps for phones and TVs. To bridge this gap, we introduce a platform-agnostic GUI Domain Specific Language (DSL) designed for efficient code synthesis~\cite{mernik2005and, hudak1997domain}. This card-style DSL, bolstered by a specialized GUI block library, captures the nuances of TV GUIs. It seamlessly interprets the type, size, position, and relationships of each GUI row, translating each component into a DSL statement. By focusing on the core types and layouts of the GUI components, we ensure the DSL remains streamlined and concise. A standout feature of our DSL is its ability to consistently represent GUI layouts, promoting a unified design language across platforms.

GUI groups, distinguished by their attributes such as position, kind, size, and hierarchical relationships, form the foundation of our DSL representation. To rigorously define our DSL, we use a context-free grammar (CFG) formalism~\cite{engelfriet1997context}.
Within the CFG, non-terminal symbols act as abstract placeholders, encapsulating the essential building blocks of our DSL. The accompanying production rules, on the other hand, precisely dictate how these non-terminals can be transformed or expanded, thereby translating abstract concepts into concrete representations within the GUI layout domain.

\begin{table}[!htp]
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\centering
\caption{Context-Free Grammar for our DSL}
\label{tab:cfg_dsl}
\begin{tabular}{|l|l|}
\hline
\textbf{Non-terminal \& Description} & \textbf{Production} \\
\hline
\( S \): Statement structure in DSL & \( S \to L_i (C_1(P_1, P_2, \ldots P_m), \ldots, C_j(P_1, P_2, \ldots, P_m)) \) \\
\hline
\( L \): Layout type & \( L \to \text{Row} | \text{Col} \) \\
\hline
\( C \): GUI group category & $C \to$ ToolBar|List|Tab|Srch|Grid|Player|PicInfo|IcoInfo|Chan \\
\hline
\( P \): Properties of a GUI group\footnotemark & \( P \to \text{Image/Icon\ Title} | \text{Size} | \text{Text} | \text{Selected} | \text{Image/Icon\ Source} \)\\
\hline
\end{tabular}
\end{table}
\footnotetext{The property type of a GUI group is fixed, but its content can vary.}

Table~\ref{tab:cfg_dsl} encapsulates the CFG definition of our DSL.
The column titled \textit{Non-terminal\ \&\ Description} enumerates our grammar's primary constructs alongside concise descriptions. These non-terminals serve as the essential scaffolds in constructing GUI layouts within our DSL. For instance, the non-terminal \textit{S} articulates the DSL's overview statement structure, encapsulating the complete GUI layout. 
\textit{L} designates the layout pattern of a series of GUI groups, distinguishing between horizontal (\textit{Row}) and vertical (\textit{Col}) UI component alignments. 
The category of a TV GUI group is captured by \textit{C}, with categories spanning from \textit{ToolBar} to \textit{Chan}, elucidated in Section~\ref{sec:GUIgroup}. 
Lastly, \textit{P} represents properties associated with \textit{C}, such as the image size or image title in the \textit{Pic+Info} GUI group or the selected state of \textit{TabLayout}.
The GUI group's property type remains constant, yet the precise content within this property exhibits variability. As an illustration, distinct images may possess divergent image titles.
The \textit{Production} column elucidates the transformation rules for each non-terminal, guiding their expansion to depict specific GUI layout elements in the DSL.






Figure~\ref{fig:dsl} exhibits an instance of our lightweight DSL. The second line of DSL encapsulates the layout of the first row in the TV GUI. The term \textit{Row} is our layout phrase ($L$), stipulating the horizontal positioning of all input components. The $Tab$ in $Tab(VARIETY)$ symbolizes the \emph{Top Tab Layout} category in TV GUI groups ($C$), and $VARIETY$ in $Tab(VARIETY)$ signifies the text property ($P$) within the group. 
In lines 3, 4, and 5, $PicInfo$ signifies the category encompassing $Pic + Info$. Within this classification, the image size is determined by the primary parameter, with potential classifications being large, medium, or small. Concurrently, the secondary parameter delineates the image's source.

% Figure environment removed
\setlength{\textfloatsep}{10pt}


The DSLs will be translated into real-world code according to the platform's requirements and render the TV interface.
We pre-write the TV GUI style library and install a client app with the TV GUI style library on TV. 
According to the DSL keywords, the style library calls the associated GUI code, converts it to real-world code, and invokes the system to render it.
% \todo{The compiler - your compiler?  There is zero detail about this in the paper - how the DSL is converted to Android TV code ; why its needed va go straight to code?}


\subsection{Implementation}
% The Z3 SMT solver~\cite{de2008z3} is used to solve OR-constrains.
Uiautomator2\cite{uiautomator2}, Fastbot~\cite{cai2020fastbot}, and Droidbot~\cite{li2017droidbot} are used to capture GUI metadata.
All algorithms in the pipeline are implemented by Python3.
Our pipeline generates DSL for TV layout, then sends the intermediates to TV.
We pre-install a client app on TV to receive generated DSL and translate DSL to real-world code to render TV screens.
The TV client app is built on the Leanback~\cite{leanback} library.
Leanback is a library for TV user interface and is provided by Google.
To produce a GUI, Leanback must be developed based on the interface. With our DSL, Leanback input is automatically generated without the need for the developer to again spend time creating the GUI.
According to the optimized size of each GUI component, each GUI group type is split into three subclasses during implementation: large, medium, and small. 
Based on Leanback, we developed templates for all the subclasses of the 9 TV GUI groups we summarized.
According to the GUI DSL, the client app calls the corresponding template, generates the corresponding TV GUI code, and renders it.


%\todo{I think need a bit more detail on this:

%-put solver in the OR-constraints section?

%-explain how the DSL compiler works in more detail / simple example??

%-unclear how "sends to TV" - does the TV run its own special app that converts DSL to TV code???  This is very unclear - and important!

%-What is the Leanback library? WHy is it used?

%-Why Java 1.8? who cares?

%}
%\fix{fixed}