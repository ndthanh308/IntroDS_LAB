\section{Related Work}

\begin{comment}
\subsection{Cross-platform app analysis}
Large scale studies have been performed on analyzing the metadata of mobile apps. 
Ali et al.~\cite{ali2017same} conducted a cross-platform study on apps between iOS version and Android version. 
They collected 80,169 pairs of iOS and Android apps and analyze the differences in user's ratings and reviews of the same app in Apple app store and Google Play store.
Carbunar et al.~\cite{carbunar2015longitudinal} observed 160,000 apps on Google Play store over a period of six months. 
They conducted temporal analysis on how the characteristics of these apps (such as the update frequency, the price, etc.) changed with the increased number of downloads. 
Syer et al.~\cite{syer2013revisiting} presented a comparative study of 15 open-source Android apps with 5 open-source desktop applications on the code level.
The issues have been investigated include the size of the code bases and the time taken to fix bugs in the projects.
Similar works also studied the differences of bug fix on iOS and Android~\cite{aljedaani2019comparison, bhattacharya2013empirical}. 
Chia et al.~\cite{chia2012app} conducted a cross-platform study on usage of user-consent permissions in mobile apps and web apps.
The scope of this study includes facebook apps, chrome extensions, and Android apps. 
Other works focused on analyzing the evolution of Android permission model and usage. 
Chen et al.~\cite{chen2021comparative} carried out a large-scale analysis of the commonalities and difference of apps between mobile phone and smart watch in terms of code and non-code similarity. 
Different from these works, we are focusing more on the GUI migration across different platform in this work.

\subsection{GUI study}
Current GUI study focus on GUI design and GUI development.
% Developing the GUI of an app routinely involves two separate but related activities: design a GUI and implement a GUI. 
Designing a GUI requires proper user interaction, information architecture and visual effects of the GUI.
Implementing a GUI focuses on making the GUI work with proper layouts and widgets of a GUI framework.

\end{comment}
 

\begin{comment}
\subsubsection{GUI Design}
To assist the mobile GUI design, many studies are working on large-scale design mining including investigating the UI design patterns~\cite{alharbi2015collect}, color evolution~\cite{jahanian2017colors,jahanian2017mining}, UI-related users' review~\cite{fu2013people,martin2016survey}.
Liu et al~\cite{liu2018learning} follow the design rules from Material Design to annotate the mobile GUI design to represent its semantics.
Swearngin et al~\cite{swearngin2018rewire} adopt the image processing method to help designs with converting the mobile UI screenshots into editable files in Photoshop, so that designers can take it as a staring point for further customization. 
To render inspirations to the designer, Chen et al~\cite{chen2019storydroid} propose a program-analysis method to efficiently generate the storyboard with UI screenshots, given one app executable file.
Fischer et a~\cite{fischer2018imaginenet} transfer the style from fine art to GUI.
All of these works are helping simplify the design process for professional design. 
In contrast, our study is to parse the UI design styles as semantic vectors or heuristics as the fundamental for related application like UI design consistency detection.
\end{comment}

\begin{comment}
\subsubsection{GUI Parse}
Zhang et al. trains a on-device model to detect phone UI elements via collected 77,637 labelled IOS and Android phone screenshots~\cite{zhang2021screen}. 
Their approach parses the GUI and automatically create metadata for mobile apps from  their pixel level. 
Some retrieval-based methods~\cite{behrang2018guifetch, reiss2018seeking, zheng2019faceoff} are also used to parse and encode GUI too. 
Reiss~\cite{reiss2018seeking} parses developers' sketch into structured queries to search related UIs of Java-based desktop software in the database. GUIfetch~\cite{behrang2018guifetch} customizes Reiss's method~\cite{reiss2018seeking} into Android app UI search by considering the transitions between UIs. 
Deka et al~\cite{deka2017rico} leverages auto-encoder to support UI searching by inputting
the rough sketch. 
Similar to Reiss's work~\cite{reiss2018seeking}, Zheng et al~\cite{zheng2019faceoff} parse the DOM (Document Object Model) tree of user-created rough website to locate similar well-designed website by measuring tree distance. 
Note that all of these works either take the wireframe/sketch or partial source code as the input for searching the UI design.

Compared with those works, our task focus on the adaptive GUI between phones and TV.
There is not enough high-quality TV app GUI data available in current app stores for deep learning.
So, we fuse pixel-level and DOM-tree level GUI features of mobile apps, and propose a on-device component grouping approach.
\end{comment}

\subsection{GUI implementation}
Implementing a GUI focuses on making the GUI work with proper layouts and widgets of a GUI framework.
Nguyen and Csallner~\cite{nguyen2015reverse} reverse engineer the UI screenshots by rule-based image processing method and generate GUI code. 
They support only a small set of most commonly used GUI components. 
More powerful deep learning-based methods~\cite{beltramelli2018pix2code, chen2018ui, moran2018machine} have been recently proposed to leverage the big data of automatically collected UI screenshots and corresponding code.
Some recent works explore issues between UI designs and their implementations. 
Moran et al.~\cite{moran2018automated} check if the implemented GUI violates the original UI design by comparing the image's similarity with computer vision techniques. 
The follow-up work~\cite{moran2018detecting} further detects and summarizes GUI changes in evolving mobile apps. 
Similarly, the semantic vector for the UI design from our work can help detect the inconsistency among UI designs within the same app.

Different from those works on GUI implementation which are highly related to conventional GUI development, we are targeting at specifically GUI projecting from small-screen mobile phones to the corresponding one on large-screen TVs. 


\subsection{GUI component grouping}
There are some similar components of clustering and page segmentation algorithms in web page analysis.
Yandrapally et al.~\cite{yandrapally2020near} propose a near-duplication detection algorithm to study near-duplication components in web pages.
They characterize and merge functional near-duplicates by summarizing categories in existing web pages.
Crescenzi et al.~\cite{crescenzi2005clustering} propose a structural abstraction clustering algorithm for web pages that groups web pages based on this abstraction.
To assess end-to-end web tests, Yandrapally et al.~\cite{yandrapally2021mutation} utilize VIPS~\cite{cai2003vips} for web page segmentation and XPaths of web elements inside these fragments for establishing their equivalence.
VIPS~\cite{cai2003vips} is a popular page segmentation, it proposes an automatic top-down, tag-tree independent approach to detect web content structure. 
% It simulates how a user understands web layout structure based on his visual perception.
Mahajan et al.~\cite{mahajan2018automated, mahajan2021effective} design a clustering technique for web elements that are based on a combination of visual aspects and DOM-based XPath similarity.

Although our study focuses on the grouping and segmentation of mobile GUIs, their work on the clustering of web components enlightens us, and we incorporate their insights into mobile GUI grouping.






\subsection{GUI migration across platforms}
\label{sec:guiMigration}
Due to the difficulty of GUI migration across different platforms, very few related works are carried out for solving this problem.
Pihlajam~\cite{pihlajamaki2016desktop} observed multiple games across web and mobile platforms for summarizing several UI patterns for user interface adaptation. 
Wong et al.~\cite{wong2008transformation} developed a scalable GUI system that dynamically transforms platform-specific GUI widgets migrated within an application between any of a plurality of heterogeneous device platforms. 
Verhaeghe et al.~\cite{verhaeghe2019gui} developed a set of rules for GUI Migration using MDE from GWT to Angular 6.

Although these studies explore the mapping (or partial mapping) between different platforms and programming languages, none of these works are investigating app GUI adaptation between phones and TV. 
Instead of the white-box migration or layout migration, our study focuses more on black-box GUI adaptation without the source code of the original  GUI on the phone.
That black-box characteristics and significant differences in screen sizes motivate us to develop a brand new approach to bridge the gap between phone and TV GUI.
Besides, time and resource consumption must be considered because of phones' current hardware limitations.

\begin{comment}
In addition to the above works, some studies carry works on adaptive layouts between different resolution pages with an end-to-end mapping~\cite{kumar2011bricolage, laine2021responsive, zheng2019content}.
Xinru Zheng et al.~\cite{zheng2019content} propose a deep generative model for graphic design layouts to synthesize layout designs based on the visual and textual semantics of user inputs.
% These works can be divided into two trends: optimization-based and generation-based.
% Optimization-based approches~\cite{kumar2011bricolage, laine2021responsive} capture the structural relationships between elements, and utilize optimization approaches to balance local and global concerns to automatically transfer design and content between different resolution Web pages.
Recent state-of-art approach~\cite{laine2021responsive} in website adaptive layout uses integer programming to set predefined constrains for components layouts.
Besides, they think it is hard to address adaptive layouts with data-driven methods after assessing current approaches and datasets. 
% Generation-based approaches~\cite{zheng2019content} always train deep learning models to immigrate GUIs.

% They use text encoder, image encoder and attribute encoder to encode three types of input respectively, and fuse all features.
% Then, feed fused features into a layout generative model.
% Instead of end-to-end mapping, 

Current data-driven approaches cannot collect enough high-quality training pairs.
Because of different design styles and development teams, even the GUI of the phone and TV of the same app is too different to find one-to-one corresponding GUI content.
So, inspired by our empirical study results in Section~\ref{sec:rq1} and Markku's assessment, instead of direct end-to-end deep learning models for this task, we split the task into five stages based on a mixture of deep learning, heuristics and optimization methods: components detection and grouping, template matching, layout optimization and GUI code synthesis.  
\end{comment}

\begin{comment}
\subsection{GUI Code Synthesis}
\chen{code synthesis is similar to code generation, not DSL!}
How to automatically translate the layout into compilable code and render it to the phone or TV interface is is still a nearly unexplored research area.
Current code synthesis research pay more attention on code domain with strict rules, such as database SQL and shell scripts.
Most of these research focus on generating \textbf{D}omain \textbf{S}pecific \textbf{L}anguage (DSL) with machine learning~\cite{balog2016deepcoder,zohar2018automatic} or template matching\cite{hu2019code, syriani2018systematic, chen2019code} rather than real code or scripts, because standard code always have more keywords and grammar rules, which enlarge the search space and complicate code synthesis.
Although code synthesis is an active field as suggested by these breakthroughs,
how to generate GUI code still needs further exploration.
Pix2code~\cite{beltramelli2018pix2code} proposes a markup-like DSL to describe the layouts and relationship of visual inputs, but the DSL support too few types of UI components and do not support different styles derived from the same type of components, which is unsuitable for complicated GUI transformation.

In this paper, we design a DSL for TV GUI code synthesis with only one syntax.
We support different styles derived from the same component. 
For example, image types can be selected according to their size, or different styles can be selected according to the position of descriptive text.
With an extension based on our syntax, all types of TV GUIs can be covered.
\end{comment}

\subsection{Practical tools in industry}
Finally, it is worth mentioning some related non-academic projects.
There are many third-party libraries or frameworks which support cross-platform adaptation such as React.js~\cite{React}, Flutter~\cite{Flutter}, and also default Android development ~\cite{AndroidTV}. 
Although these frameworks can cover multiple platforms such as smartphones, desktops, and tablets, TV is rarely covered due to its ultra-large screen. 
Developers have to commit much additional effort to design new layouts that can be easily understood from 10 feet away and provide navigation that works with just a directional pad and a select button to make their app successful on TV devices. 
That is one reason why few apps support GUI adaptation, and the small number of smart TV users further discourages app developers.

Samsung supports screen mirroring from the Samsung device to the TV including photos, videos, presentations, and games~\cite{Dex}. 
There are also other similar connections between smartphones and TV such as Chromecast\cite{chromecast}, Xiaomi TV stick~\cite{miTV} or wired connection via HDMI, etc.
%Android Auto can convert portrait to landscape of phone when driving~\cite{anAu}, but only customizes a few interfaces.  
Most of them are working well in only video projection or some customized apps, and they require additional support from the TV side.
Directly showing phone GUI on TV will bring many rendering issues such as small components, large black margins, unreasonable interaction, etc. 
To overcome those issues, we propose an automated approach to project the phone GUI to the TV on the run time.