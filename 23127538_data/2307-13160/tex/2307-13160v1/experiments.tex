
In this section, we present the experimental valuation of our approach over a variety of benchmarks. First, we show that our approach can handle novel examples that cannot be addressed by other existing tools such as \cite{DBLP:conf/cav/GehrMV16,DBLP:conf/pldi/GehrSV20,DBLP:conf/atva/HuangDM21,DBLP:conf/flops/NarayananCRSZ16}. 
Then we compare our approach with the state-of-the-art tool GuBPI \cite{Beutner2022b}. %w.r.t. NPDs. 
Finally, even though the problem of path probability estimations is not the focus of our work, we demonstrate that our approach can work well for this problem, and we also compare the performance of our approach with GuBPI.



We have implemented a parser from probabilistic programs to WPTS's in F\#, our algorithms in Matlab, and used the LP solver in Matlab (resp. Mosek \cite{mosek}) for solving linear (resp. semidefinite) programming, respectively.  
%The invariants are generated by the tool StInG \cite{SankaranarayananSM04}. 
All results were obtained on an Intel Core i7 (2.3 GHz) machine with 16 GB of memory, running MS Windows 10. 



\subsection{Experimental Setup}

Below we clarify our experimental setting for the input programs with invariant, the input truncation and approximation functions and the polynomial approximation for the score statement at program termination in the non-score-recursive case. 


\smallskip
\noindent{\em Program Input.} All the benchmarks in our experiments are of the form ``$\textbf{while }\phi\textbf{ do }S_1\textbf{ od };S_2$'' where $S_1,S_2$ are program statements without loops and $\phi$ is the loop guard which is a predicate over $\pvars$. We set two locations for all benchmarks, i.e., $\lin$ before $\textbf{while}$ and $\lout$ after $S_2$. Our algorithms also work for general programs with multiple locations. To reduce the influence from the choice of the invariant, we derive an invariant $I$ simply from the loop guard $\phi$ so that $I(\lin)=\phi$ and $I(\lout)=\neg\phi$.

\smallskip
\noindent{\em Partition of Initial Program Valuations.} We partition the set $\calV$ of initial program valuations into $m$ disjoint subsets by splitting the quantity of one dimension uniformly.


\smallskip
\noindent{\em Truncation Function.}
For the truncation function $\trunc$, we first restrict the range of all program variables to the domain satisfying the loop guard $\phi$. That is, $\Phi_1=\{\pv\mid   \pv \models \phi  \}$. Then we empirically specify a large enough bounded range $\Phi_2$ over program variables that captures the major behaviour of the program. That is, $ \Phi_2=\{\pv\mid \pv\in [\zeta_1-\delta,\zeta_2+\delta], [\zeta_1,\zeta_2]=\supp{\mu_{init}}  \}$ for some constant $\delta>0$. Finally, $\trunc$ is defined by $\trunc(x):=\Phi_1(x)\wedge\Phi_2(x)$ for all $x\in\pvars$.


\smallskip
\noindent{\em Approximation Functions.}
To derive the approximation functions $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$, we consider two cases: 
\begin{itemize}
	\item in the case that $\Pi$ is non-score-recursive, $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$ are obtained as follows.
	\begin{itemize}
		\item If the score function at termination is non-polynomial, we determine $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$ by bounds and also the monotonicity of the score function 
  over the set $B''=B'\setminus B$ (see definitions of $B,B'$ in \textbf{Step A1} in \cref{sec:algorithm}). 
		\item Otherwise, we directly use the polynomial score function as $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$.
	\end{itemize}
	\item  in the case that $\Pi$ is score-recursive, $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$ are derived by using our  OST approach in Section~\ref{sec:ostapproach} but without truncation operation, i.e., by directly applying \cref{thm:puwf-normalizing}. 
\end{itemize} 


\smallskip
\noindent{\em Polynomial Approximation.} In the case that $\Pi$ is non-score-recursive and the score function $g$ at termination is non-polynomial, there are two situations that polynomial approximation should be applied. The first is that $g$ is handled by polynomial approximation of it over the set $B'$, which will be later used in (D1) in \textbf{Step A3} in \cref{sec:algorithm}. The second is that $\calM_{\mathrm{up}},\calM_{\mathrm{low}}$ are determined by polynomial approximation of $g$ over the set $B''$, which will be used in (D2) in \textbf{Step A3} in \cref{sec:algorithm}. Concretely, we apply polynomial interpolation to approximate the non-polynomial score function $g$. That is, given an error bound $\epsilon>0$ we aim to find a polynomial approximation $g'$ for $g$ such that $|g(\pv)-g'(\pv)|\le \epsilon'$ for all program valuations $\pv\in B'$ (or $\pv\in B''$). The above operation can be easily extended to produce piecewise polynomial approximations if $B,B''$ are split into multiple partitions. For the first situation, the approximation error caused by polynomial interpolation is taken into account when calculating interval bounds for NPD (see \cref{app:score-error} in \cref{app:sec5}). 


\subsection{Results}

\smallskip 
\noindent{\em NPD - Novel Examples.} 
We consider $10$ novel examples adapted from the literature, %\cite{Beutner2022b,DBLP:conf/pldi/WangS0CG21,ronquist2021universal}, 
where all $7$ examples with prefix ``\textsc{Pd}'' or ``\textsc{RdWalk}'' are from \cite{Beutner2022b}, the two ``RACE'' examples are from \cite{DBLP:conf/pldi/WangS0CG21}, and the last example is from statistical phylogenetics   \cite{ronquist2021universal} (see also \cref{sec:overview}). Concretely, the ``RACE(V2)'' and ``BIRTH'' examples are both score-recursive probabilistic programs with weights greater than $1$, and thus their integrability condition should be verified by the existence of suitable concentration bounds (see~\cref{thm:ost-variant}); other examples are non-score-recursive probabilistic while loops with unsupported types of scoring by previous tools (e.g., polynomial scoring). Therefore, no existing tools w.r.t. NPD can tackle these novel examples. The results are reported in \cref{table:1}, where the first column is the name of each example, the second column contains the parameter of each example used in our approach (i.e., the degree of the polynomial template and the bounded range of program variables), the third column is the used solver, and the fourth and fifth columns correspond to the runtime of upper and lower bounds computed by our approach, respectively. We set the partition number $m=60$. Our runtime is reasonable, that is, most examples can obtain tight bounds within $100$ seconds, and the simulation results by Pyro~\cite{bingham2019pyro} ($10^6$ samples per case) match our derived bounds. Due to space limitation, we display part of the comparison in \cref{fig:results1}, see \cref{app:experiments} for other figures.




\begin{table*}
%	\vspace{-1.7em}
	\caption{Results for Novel Examples}
	\label{table:1}
	%\begin{footnotesize}
	\resizebox{\textwidth}{!}{%
		\begin{threeparttable}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Benchmark}}}  &
				\multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Parameters}}}      &
				\multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Solver}}}      &
				\multicolumn{1}{c|}{\textbf{Upper}}      &
				\multicolumn{1}{c|}{\textbf{Lower}}   \\ \cline{4-5}
				\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{}  &  \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{\textbf{ Time (s)}} & 
				\multicolumn{1}{c|}{\textbf{ Time (s)}}                    \\ \hline \hline
				\multirow{1}{*}{\textsc{Pd(v1)}} 
				& $d=6$, $pos, dis \in [0,5]$   & SDP & $54.65$  & $52.39$        \\
				\hline
				\multirow{1}{*}{\textsc{Race(v1)}} 
				&$d=6$, $h,t\in [0,5]$ & LP &$87.43$ & $86.27$  \\  
				\hline
				\multirow{1}{*}{\textsc{Race(v2)}\tnote{*}}
				&$d=6$, $h,t\in [0,5]$ &  LP & $81.19$ & $81.18$   \\   \hline 
				\multirow{1}{*}{\textsc{RdWalk(v1)}} 
				& $d=6$, $x,y\in [0,5]$ &  LP  & $46.65$  & $47.72$   \\ 
				\hline
				\multirow{1}{*}{\textsc{RdWalk(v2)}} 
				& $d=6$, $x,y\in [0,5]$ &  LP  & $97.45$  & $103.65$   \\ 
				\hline
				\multirow{1}{*}{\textsc{RdWalk(v3)}} 
				& $d=6$, $x,y\in [0,5]$ &  LP & $250.70$  & $252.49$   \\ 
				\hline
				\multirow{1}{*}{\textsc{RdWalk(v4)}} 
				& $d=6$, $x,y\in [0,5]$ &  LP & $98.75$  & $98.21$    \\ 
				\hline
				\multirow{1}{*}{\textsc{PdMB(v3)}}
				& $d=4$, $pos,dis\in [0,5]$ &   LP  & $15.26$  & $14.57$   \\  
				\hline
				\multirow{1}{*}{\textsc{PdMB(v4)}}  
				& $d=4$, $pos,dis\in [0,5]$ &  LP   & $16.07$  & $16.12$   \\  
				\hline
				\multirow{1}{*}{\textsc{Birth}\tnote{*}}& $d=6$, $lambda \in [0,3], time\in [0,10]$ & LP 	& $14.72$ & $16.66$          \\  
				\hline
			\end{tabular}
			
			\begin{tablenotes}
				\footnotesize
				\item[*] It is a score-recursive probabilistic program with weights greater than $1$.
			\end{tablenotes}
	\end{threeparttable}}
	%	\end{footnotesize}
%	\vspace{-1.5em}
\end{table*}

% Figure environment removed



~\\\smallskip 
\noindent {\em NPD - Comparision with GuBPI \cite{Beutner2022b}.} Since the parameters used in GuBPI and our approach are completely different, it is infeasible to compare the two approaches directly. Instead, we choose the parameters to our algorithms that can achieve at least comparable results with GuBPI. The main parameters are shown in \cref{table:2} and we set the partition number $m=60$.
 We consider the Pedestrian example ``\textsc{Pd}'' from \cite{Beutner2022b} (see also \cref{sec3:pedestrian}), and its variants. More concretely, we enlarged the standard deviation of the observed normal distribution to be $5$ for all other $6$ examples whose prefix name are ``\textsc{Pd}''; for the four ``\textsc{PdBeta}'' examples, we also add different beta distributions in the loop bodies. The last example is from \cite{DBLP:conf/cav/GehrMV16}. We report the results in \cref{table:2} whose layout is similar to \cref{table:1} except that the column ``\#'' displays whether or not the bounds are trivial, i.e., $[0,\infty]$.
% the fifth column ``Solvable'' means whether or not the results are trivial (i.e., the bound $[0,\infty]$ is useless). 
 We also compare our results with GuBPI's and simulation results ($10^6$ samples per case), and show part of the comparison in \cref{fig:results2}, see \cref{app:experiments} for other figures.  Our runtime is up to 6 times faster than GuBPI while we can still obtain tighter or comparable bounds for all examples.  Specifically, for the first example ``\textsc{Pd}'', our upper bounds are a bit higher than GuBPI's when the value of $start$ falls into $[0,0.7]$ (which is not suprising as the deviation of the normal distribution in this example is quite small, i.e., $0.1$, and our approach constructs over-approximation constraints while GuPBI uses recursion unrolling to search for the feasible space exhaustively), but our lower bounds are greater than GuBPI's, and our NPD bounds are tighter in the following.\footnote{When the value of $start$ approaches $3$, our NPD bounds is close to zero, but the upper bounds may be lower than zero, which is caused by numerical issues of semi-definite programming. The problem of numerical issues is orthogonal to our work and remains to be addressed in both academic and industrial fields.} For all $6$ variants of ``\textsc{Pd}'' where the deviation of the normal distrbution is enlarged, our NPD bounds are tighter than GuBPI's, in particular, our upper bounds are much lower than GuBPI's. For the four ``\textsc{PdBeta}'' examples, we also found that GuBPI produced zero-valued unnormalized lower bounds, thus its results w.r.t. NPD are trivial, i.e., $[0,\infty]$. However, we can still produce non-trivial results and our runtime is at least 2 times faster than GuBPI. 

\begin{table*}
%	\vspace{-1.7em}
	\caption{Comparison with GuBPI}
	
	\label{table:2}
	\resizebox{\textwidth}{!}{%
		%\begin{footnotesize}
		\begin{threeparttable}
			\begin{tabular}{|c|c|c|c|c|c|c|}
				\hline
				\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Benchmark}}}  &
				\multicolumn{4}{c|}{\multirow{1}{*}{\textbf{Our Tool}}}      &
				\multicolumn{2}{c|}{\multirow{1}{*}{\textbf{GuBPI}}}    \\ \cline{2-7}
				\multicolumn{1}{|c|}{} &   \multicolumn{1}{c|}{\textbf{Parameters}}  & \multicolumn{1}{c|}{\textbf{ Solver}} & 
				\multicolumn{1}{c|}{\textbf{ Time (s)}} &
				\multicolumn{1}{c|}{\solvable} &
				\multicolumn{1}{c|}{\textbf{ Time (s)}}   &    
				\multicolumn{1}{c|}{\solvable}            \\ \hline \hline
    \multirow{1}{*}{\textsc{Pd}} & $d=10$, $pos, dis \in [0,5]$   &  SDP & $3176.685$   & $\bullet$ & $5266.063$   &   $\bullet$    \\ 
				\hline
				\multirow{1}{*}{\textsc{PdLD}} & $d=6$, $pos, dis \in [0,5]$   &  LP & $41.99$ & $\bullet$ & $648.151$   &   $\bullet$   \\ 
				\hline
				\multirow{1}{*}{\textsc{PdBeta(v1)}} & $d=6$, $pos, dis \in [0,5]$   &  LP & $99.86$ & $\bullet$ & $645.055$   &   $\circ$    \\ 
				\hline
				\multirow{1}{*}{\textsc{PdBeta(v2)}} & $d=6$, $pos, dis \in [0,5]$   &  LP & $228.43$ & $\bullet$ & $653.237$   &   $\circ$   \\ 
				\hline
				\multirow{1}{*}{\textsc{PdBeta(v3)}} & $d=6$, $pos, dis \in [0,5]$   & LP & $101.36$ & $\bullet$ & $657.645$   &   $\circ$  \\ 
				\hline
				\multirow{1}{*}{\textsc{PdBeta(v4)}} & $d=6$, $pos, dis \in [0,5]$   &  LP & $208.86$ & $\bullet$ & $686.207$   &   $\circ$   \\ 
				\hline
				\multirow{1}{*}{\textsc{PdMB(v5)}} & $d=6$, $pos, dis \in [0,5]$   &  LP & $88.41$  & $\bullet$ & $391.772$    &   $\bullet$    \\ 
				\hline
					\multirow{1}{*}{\textsc{Para-recur}} & $d=8$, $p\in [0,1]$   & LP & $36.61$  & $\bullet$ & $253.728$    &   $\bullet$   \\ 
				\hline
			\end{tabular}
			%\end{footnotesize}
			\begin{tablenotes}
				\footnotesize
				\item[*] $\circ$ marks the trivial bound $[0, \infty]$, while $\bullet$ marks the non-trivial ones.
			\end{tablenotes}
			
	\end{threeparttable}}
%	\vspace{-1.5em}
\end{table*}



~\\\smallskip 
\noindent {\em Path Probability Estimation.} 
 We consider five recursive examples in \cite{Beutner2022b}, which were also cited from the PSI repository \cite{DBLP:conf/cav/GehrMV16}. Since all five examples are non-paramteric and with unbounded numbers of loop iterations, PSI cannot handle them correctly as mentioned in \cite{Beutner2022b}.  We estimated the path probability of certain events, i.e., queries over program variables, and report the results in \cref{table:3}. For the first three examples, we obtained tighter lower bounds than GuBPI and same upper bounds, while our runtime is at least 2 times faster than GuBPI. Moreover, we found a potential error of GuBPI. That is, the fourth example ``\textsc{cav-ex-5}" in \cref{table:3} is an AST program with no scores, which means its normalizing constant should be exactly one. However, the upper bound of the normailising constant obtained by GuBPI is smaller than $1$ (i.e., $0.6981$). A stochastic simulation using $10^6$ samples yielded the results that fall within our bounds but violate those computed by GuBPI. Thus, GuBPI possibly omitted some valid program runs of this example and produces wrong results. 
 All our results match the simulation results ($10^6$ samples per case).

\begin{table*}
%	\vspace{-1.7em}
	\caption{Results for Path Probability Estimation}
	
	\label{table:3}
	\resizebox{\textwidth}{!}{%
		\begin{threeparttable}
			%\begin{footnotesize}
			\begin{tabular}{|c|c|c|c|c|c|c|c|}
				\hline
				\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Benchmark}}}  &
				\multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Query}}}      &
				\multicolumn{3}{c|}{\multirow{1}{*}{\textbf{Our Tool}}}      &
				\multicolumn{2}{c|}{\multirow{1}{*}{\textbf{GuBPI}}}  &
				\multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Simul}}} 
				\\ \cline{3-7}
				\multicolumn{1}{|c|}{} & \multicolumn{1}{c|}{} & 
    \multicolumn{1}{c|}{\textbf{Parameters}}  & 
    % \multicolumn{1}{c|}{\textbf{ Solver}} & 
				\multicolumn{1}{c|}{\textbf{ Time (s)}} &
				\multicolumn{1}{c|}{\textbf{ Bounds}} &
				\multicolumn{1}{c|}{\textbf{ Time (s)}}   &    
				\multicolumn{1}{c|}{\textbf{ Bounds}} &            \\ \hline \hline
				\multirow{2}{*}{\textsc{cav-ex-7}}&Q1 & $ 6, [0,30], [0,4] $&    $15.062$  &  $[0.9698,1.0000]$ &  $38.834$   & $[0.7381,1.0000]$&   $0.9938$\\ \cline{2-8}
				&Q2 & $ 6, [0,40], [0,4] $&    $16.321$   & $[0.9985,1.0000]$  &  $37.651$   & $[0.7381,1.0000]$ &  $0.9993$ \\ 
				\hline
				\multirow{2}{*}{\textsc{AddUni(L)}}&Q1 & $ 6, [0,10], [0,1] $&     $8.85$  &  $[0.9940,1.0000]$ &  $21.064$   & $[0.9375,1.0000]$&   $0.9991$\\ \cline{2-8}
				&Q2 & $ 6, [0,15], [0,1] $&   $8.80$   & $[0.9995,1.0000]$  &  $14.941$   & $[0.9375,1.0000]$ &  $0.9999$ \\ 
				\hline
				\multirow{1}{*}{\textsc{RdBox}}&Q1 & $ 4, [-0.8,0.8], [0,10] $&     $25.87$  &  $[0.9801,1.0000]$ &  $173.535$   & $[0.9462,1.0000]$&  $0.9999$ \\
				\hline
				\multirow{2}{*}{\textsc{cav-ex-5}  \tnote{*}}&Q1 & $ 6, [20,\infty], [0,10] $&     $33.17$  &  $[0.8123,0.9707]$ &  $229.623$   & $[0.5768,0.6374]$&   $0.9098$ \\ \cline{2-8}
				&Q2 & $ 6, [20,\infty], [0,20] $&    $54.373$   &  $[0.8970,1.0000]$ &  $224.504$   & $[0.5768,0.6375]$ &  $0.9645$  \\ 
				\hline
				\multirow{2}{*}{\textsc{GWalk}  \tnote{**}}&Q1 & $ 8, [1,\infty], [0,0.1] $&    $7.255$  &  $[0.0023,0.0023]$ &  $33.246$   & $[0.0023,0.0024]$&  $0.0023$ \\ \cline{2-8}
				&Q2 & $ 8, [1,\infty], [0,0.2] $&   $8.197$   & $[0.0025,0.0025]$  &  $31.728$   & $[0.0025,0.0025]$ &  $0.0025$  \\ 
				\hline
			\end{tabular}
			%\end{footnotesize}
			\begin{tablenotes}
				\footnotesize
				\item[*] GuBPI's result contradicts ours, and we found GuBPI produces wrong results for this example.
				\item[**] As we care about path probabilities, we compared bounds of unnormalized distributions for this example (the NPD can be derived in the same manner above).
               % \item[***] Solvers are all LP.
				%		This is an AST program with no scores, so the normalizing constant should be one. However, the upper bound of the normailizing constant obtained by GuBPI is smaller than $1$ (i.e., $0.6981$). A stochastic simulation using $10^6$ samples yielded the result that fall within our bounds but violate those computed by GuBPI. Thus, GuBPI possibly omits some valid program runs and produces a trivial result.
			\end{tablenotes}
			
	\end{threeparttable}}
%	\vspace{-1.5em}
\end{table*}


