\section{Standard algorithm} \label{sec:standard_alg}

Much of the literature on the original technique refers to it as the ``Fast Inverse Square Root" algorithm, but since this use of the word ``inverse" is somewhat ambiguous, we will refer to it as the Fast Reciprocal Square Root (FRSR) algorithm. The Quake code for FRSR is paraphrased in Listing \ref{lst:Quake}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[caption=Quake FRSR algorithm, label={lst:Quake}, language=C]
float FRSR_Quake(float x)
{
    int X = *(int *)&x;
    int Y = 0x5F3759DF - (X>>1);
    float y = *(float *)&Y;
    return y * (1.5f - 0.5f*x*y*y);
}
\end{lstlisting}
\end{minipage}

It makes use of an important property of the distribution of numbers encoded in the IEEE 754 floating point format, which has been expressed by \citet{blinn1997} as follows: ``If you only deal with positive numbers, the bit pattern of a floating-point number, interpreted as an integer, gives a piecewise linear approximation to the logarithm function''.\footnote{This property breaks down for subnormal floating point arguments, so that the FRSR algorithm only applies to positive normal floats. If it is required to support subnormal arguments, a conditional branching approach such as the one described in \citet{walczyk2021} can be used.} Strictly, the mapping also introduces a scale and bias, but this fact is not relevant to the analysis since the scale is cancelled out when the inverse bit interpretation occurs, and the effect of the bias can be counteracted by suitably modifying the hexadecimal constant. Hence, we will use $L(x), \hspace{2pt} x>0$ to mean the piecewise linear function which has the value $\log_2{x}$ at points where $x$ is a a power of two, and is linear between each successive pair of such points. We will call $L(x)$ the \textit{pseudolog} of $x$ (see Figure \ref{fig:pseudolog}). A major advantage of using this approach is that it decouples the analysis from the floating point representation, and we can now treat all values as real numbers. The standard FRSR algorithm can then be expressed as shown in Algorithm \ref{alg:FRSR}.

% Figure environment removed

\begin{algorithm}
\caption{Standard FRSR algorithm}
\label{alg:FRSR}
\begin{algorithmic}[1]
\STATE \textbf{function} FRSR($x$)
\STATE $X = L(x)$                                      \label{alg:FRSR:line:X}
\STATE  $Y = \frac{c}{2}-\frac{1}{2}X$   \label{alg:FRSR:line:Y}
\STATE  $y = L^{-1}(Y)$                           \label{alg:FRSR:line:y}
\STATE  $z = xy^2$                                  \label{alg:FRSR:line:z}
\STATE  \textbf{return} $ y(c_0+c_1z) $ \label{alg:FRSR:line:return}
\end{algorithmic}
\end{algorithm}

The constant $\frac{c}{2}$ of line \ref{alg:FRSR:line:Y} corresponds, via a scale and bias, to FRSR's ``magic constant'' (the reason for dividing $c$ by $2$ will become apparent), and the coefficients $c_0$ and $c_1$ represent the generalised values which researchers have used to improve upon the $\frac{3}{2}$ and $-\frac{1}{2}$ of the Newtonian iteration of Listing \ref{lst:Quake}.
