\section{Methods}
In this section, we first introduce the Weisfeiler-Lehman test generalized for hypergraph, named hypergraph Weisfeiler-Lehman test. Then, we define the hypergraph Weifeiler-Lehman sequence and general hypergraph kernel based on them. In the following, we present two instances of this kernel: the hypergraph Weisfeiler-Lehman subtree kernel and the hypergraph Weisfeiler-Lehman hyperedge kernel. Finally, we compare our method to Graph Weisfeiler-Lehman Kernel from a mathematical perspective. % and the General Hypergraph Neural Network (HGNN$^+$) Framework.


% Figure environment removed

\subsection{Hypergraph Weisfeiler-Lehman Test}
Based on the concept of the Weisfeiler-Lehman test \cite{graph_wl} of isomorphism on graphs, in this subsection, we generalize it into hypergraphs as presented in Algorithm \ref{alg:hg_wl}.


\begin{algorithm}%[!htbp]
	%\textsl{}\setstretch{1.8}
	\renewcommand{\algorithmicrequire}{\textbf{Input:}}
	\renewcommand{\algorithmicensure}{\textbf{Output:}}
	\caption{The hypergraph Weisfeiler-Lehman test of hypergraph isomorphism algorithm.}
	\label{alg:hg_wl}
	\begin{algorithmic}[1]
		\Require Hypergraph $\mathcal{G}=\{\mathcal{V}, \mathcal{E} \}$ and $\mathcal{G'} = \{ \mathcal{V}', \mathcal{E}' \}$, vertex $v \in \mathcal{V}$, and $v' \in \mathcal{V}'$, hyperedge $e \in \mathcal{E}$ and $e' \in \mathcal{E}'$, vertex label map: $\ell^v := v/v' \rightarrow c$, hyperedge label map $\ell^e := e/e' \rightarrow c$, number of iterations $h$, multiset sorting function $sort(\cdot)$, concatenating elements in multiset and stringify function: $str(\cdot)$, string compression function $f(\cdot)$, concatenating function to concate a new stringify function with the old one: $strcat(\cdot, \cdot) $, $\cdot / \cdot$ operation denotes the `` or ''. 
            \State $l_0^v(v) \gets \ell^v(v)$, $v \in \mathcal{V}$ \Comment Initialize $\mathcal{G}$ vertex labels.
            \State $l_0^v(v') \gets \ell^v(v')$, $v' \in \mathcal{V}'$ \Comment Initialize $\mathcal{G}'$ vertex labels.
            \State $l_0^e(e) \gets \ell^e(e)$, $e \in \mathcal{E}$ \Comment Initialize $\mathcal{G}$ hyperedge labels.
            \State $l_0^e(e') \gets \ell^e(e')$, $e' \in \mathcal{E}'$ \Comment Initialize $\mathcal{G}'$ hyperedge labels.
            \State $i \gets 0$
            \While{$ i < h$ and $\{l_i^v(v) \mid v \in \mathcal{V}\} = \{l_i^v(v') \mid v' \in \mathcal{V}'\}$}
		\State $i \gets i + 1$
		\State \emph{// Each hyperedge gathers its vertex neighbor labels.}
            \For{$e/e' \in \mathcal{E}/\mathcal{E}'$}
            \State \emph{// 1. Gathering hyperedge's vertex neighbor labels into multiset.}
            \State $M^v_i(e) \gets \{l^v_{i-1}(v) \mid v \in \mathcal{N}_v(e) \}$ 
            \State $M^v_i(e') \gets \{l^v_{i-1}(v') \mid v' \in \mathcal{N}_v(e') \}$ 
            \State \emph{// 2. Sorting multiset and stringify.}
            \State $S_e / S_{e'} \gets str(sort(M^v_i(e))) / str(sort(M^v_i(e')))$
            \State \emph{// 3. Hyperedge label compression and Relabeling.}
            \State $S_e / S_{e'} \gets strcat(l_{i-1}^e(e), S_e) / strcat(l_{i-1}^e(e'), S_{e'})$
            \State $l_{i}^e(e) / l_{i}^e(e') \gets f(S_e) / f(S_{e'})$
            \EndFor
            \State \emph{// Each hyperedge gathers its vertex neighbor labels.}
            \For{$v/v' \in \mathcal{V}/\mathcal{V}'$}
            \State \emph{// 1. Gathering vertex's hyperedge neighbor labels into multiset.}
            \State $M^e_i(v) \gets \{l^e_i(e) \mid e \in \mathcal{N}_e(v) \}$ 
            \State $M^e_i(v') \gets \{l^e_i(e') \mid e' \in \mathcal{N}_e(v') \}$ 
            \State \emph{// 2. Sorting multiset.}
            \State $S_v / S_{v'} \gets str(sort(M^e_i(v))) / str(sort(M^e_i(v')))$
            \State \emph{// 3. Vertex label compression and Relabeling.}
            \State $S_v / S_{v'} \gets strcat(l_{i-1}^v(v), S_v) / strcat(l_{i-1}^v(v'), S_{v'})$
            \State $l_{i}^v(v) / l_{i}^v(v') \gets f(S_v) / f(S_{v'})$
            \EndFor
            \EndWhile
            % \If{$i=h$ and $\{l_h^v(v) \mid v \in \mathcal{V}\} = \{l_h^v(v') \mid v' \in \mathcal{V}'\}$}
            % \State Output $True$
            % \Else
            % \State Output $False$
            % \EndIf
            \State Comparing $\{l_h^v(v) \mid v \in \mathcal{V}\}$ and $\{l_h^v(v') \mid v' \in \mathcal{V}'\}$
		\Ensure  Whether $\mathcal{G}$ and $\mathcal{G}'$ are isomorphism or not.
	\end{algorithmic}  
\end{algorithm}

The key idea of the series Weisfeiler-Lehman test algorithm is to augment the vertex labels by the sorted set of vertex labels of neighboring vertices and compress those augmented labels into new labels. These steps are repeated until the vertex label sets of the two input graphs differ or the number of iterations reaches $h$. The definition of neighbor is the biggest obstacle to extending it from graphs to hypergraphs. In simple graphs, each edge only links two vertices. Thus, we say that two vertices are neighbors to each other if there is an edge between them. However, the edge (hyperedge) can link more than two vertices in hypergraphs. The definition of neighbor relation is more difficult in hypergraphs. Motivated by \cite{hgnnp}, we adopt the hyperedge's vertex neighbors $\mathcal{N}_v(e)$ and vertex's hyperedge neighbors $\mathcal{N}_e(v)$ to represent the complex neighbor relation in hypergraphs. This way, the complex neighbor relation in a hypergraph is transferred hierarchically, and the hyperedge bridges the relationship between the vertex set and another, as shown in Figure \ref{fig:neighbor}. Given a hypergraph $\mathcal{G} = \{ \mathcal{V}, \mathcal{E} \}$, for each vertex $v \in \mathcal{V}$ its hyperedge neighbors $\mathcal{N}_e(v)$ and for each hyperedge $e \in \mathcal{E}$ its vertex neighbors $\mathcal{N}_v(e)$ can be formulated as
\begin{equation}
\label{eq:hg_nbr}
    \left\{
        \begin{aligned}
            \mathcal{N}_e(v)& = \{ e \mid \mathbf{H}(v,e) = 1, e \in \mathcal{E} \}\\
            \mathcal{N}_v(e)& = \{ v \mid \mathbf{H}(v,e) = 1, v \in \mathcal{V} \}
        \end{aligned}
    \right. ,
\end{equation}
where $\mathbf{H} \in \{0, 1\}^{|\mathcal{V}| \times |\mathcal{E}|}$ is the hypergraph incidence matrix. With the definition of two neighbor functions $\mathcal{N}_e(\cdot)$ and $\mathcal{N}_v(\cdot)$, we can easily quantify the complex beyond-pairwise correlation in hypergraphs.
In the following, we will introduce the generalized hypergraph Weisfiler-Lehman algorithm based on the two neighbor functions, as presented in Algorithm \ref{alg:hg_wl}.


Supposing we have two hypergraphs $\mathcal{G}=\{\mathcal{V}, \mathcal{E} \}$ and $\mathcal{G'} = \{ \mathcal{V}', \mathcal{E}' \}$, the goal of the algorithm is to test whether the two input hypergraphs are isomorphic. Assuming each vertex $v/v' \in \mathcal{V}/\mathcal{V'}$ in the two hypergraphs is associated with labels via vertex label map $\ell^v := v/v' \rightarrow c$. Similarly, the label of each hyperedge $e/e' \in \mathcal{E}/\mathcal{E}'$ is given by the hyperedge label map $\ell^e := e/e' \rightarrow c$. At first, the number of vertices must be the same ($|\mathcal{V}| = |\mathcal{V'}|$), or they are not isomorphic. In each iteration, the labels of vertices are organized using a multiset \cite{multiset}, which allows for multiple instances for each of its elements compared to a set from a mathematical perspective. The multisets $\{l_i^v(v) \mid v \in \mathcal{V}\}$ and $\{l_i^v(v') \mid v' \in \mathcal{V}'\}$ are the primary identifiers in $h$ times iterations. If they are all the same, the two hypergraphs are isomorphic; otherwise, they are not. The initial elements of the vertex/hyperedge label multiset are initialized by the original vertex/hypergraph map $\ell^v(\cdot)/\ell^e(\cdot)$. Each iteration includes two sub-processes: vertex labels $\rightarrow$ hyperedge labels and hyperedge labels $\rightarrow$ vertex labels. 

In the first sub-process (vertex labels $\rightarrow$ hyperedge labels), for each hyperedge $e \in \mathcal{E}$, we construct a multiset $M^v_i(e)$ with the labels from its vertex neighbor set $\mathcal{N}_v(e)$, and its elements are converted to strings to create a string $S_e$. The sorted order of the multisets ensures that all identical strings are mapped to the same number, as they occur in a consecutive block. To incorporate the root hyperedge information, we add a prefix $l^e_{i-1}(e)$ to the string $S_e$. Then, the sting $S_e$ is compressed with a compression function $f(\cdot)$ to generate a short label for each hyperedge $e$. Those short labels serve as the most recent labels for the hyperedges in the hypergraph. Note that the compression function $f(\cdot)$ must be an injective function, meaning that $f(l)=f(l')$ if and only if $l=l'$. In the second sub-process (hyperedge labels $\rightarrow$ vertex labels), the hyperedge labels' neighbor gathering, sorting, and compression are conducted similarly to the first sub-process. 

Finally, after $h$ iterations, the hypergraph Weisfiler-Lehman test algorithm can determine whether the two hypergraphs are isomorphic. Similar to the original Weisfeiler-Lehman algorithm \cite{graph_wl, graph_wl_valid}, the hypergraph Weisfeiler-Lehman can be applied to almost all hypergraphs (Section \ref{sec:exp:hypergraph} of Experiments). However, there are still some cases where it fails. Figure \ref{fig:alg_failed} illustrates an example in which the proposed hypergraph Weisfeiler-Lehman algorithm fails. In $i$-th iteration, the algorithm encodes the specified subtree with a height of $i$ for each vertex in the hypergraph. Thus, comparing the vertex label multiset $l_i^v(v)$  is equivalent to comparing the rooted subtree with a height of $i$ for the given vertex $v$. Additionally, in each iteration, the former rooted subtree information can be reused during the two-stage relabeling process. This approach avoids redundant computations involved in rebuilding the subtree with a specified height. Therefore, the devised hypergraph Weisfeiler-Lehman test algorithm is effective and efficient for the hypergraph isomorphism test.

% Figure environment removed

% \subsubsection{Complexity}
\textbf{Complexity. }
\label{sec:fw_complexity}
The runtime complexity of the proposed hypergraph Weisfeiler-Lehman test algorithm with $h$ iterations is $\mathcal{O}\left(hm\right)$. Here, $m$ is the capacity of the hypergraph, which can be computed as the number of non-zero elements in the hypergraph incidence matrix $\mathbf{H}$. The value of $m$ can be computed by either $m = |\mathcal{V}|\bar{d}_v$, or $m = |\mathcal{E}|\bar{d}_e$. $\bar{d}_v$ and $\bar{d}_e$ are the average degrees of vertices and hyperedges, which can be computed by $\bar{d}_v = \frac{1}{|\mathcal{V}|} \sum_{v \in \mathcal{V}} d_v$ and $\bar{d}_e = \frac{1}{|\mathcal{E}|} \sum_{e \in \mathcal{E}} d_e$, respectively.
% in the worst c $(|\mathcal{E}| \hat{d}_e + |\mathcal{V}| \hat{d}_v)$ $\hat{d}_e$ and $\hat{d}_v$ are the maximum degrees of the hyperedge and vertex, respectively. 
Here we first consider the subprocess of vertex labels $\rightarrow$ hyperedge labels. Clearly, the worst runtime of the neighbor gathering and stringify are $\mathcal{O}(\bar{d}_e)$. Due to the multiset only containing finite labels, we can use the radix sort algorithm\cite{radix_sort} to achieve the time complexity $\mathcal{O}(\bar{d}_e)$. The string concatenation, string compression, and the relabeling cost $\mathcal{O}(1)$ time complexity. Thus, the runtime of the first subprocess is $\mathcal{O}(|\mathcal{E}|\bar{d}_e)$ for all hyperedges. Similarly, the runtime of the second subprocess is $\mathcal{O}(|\mathcal{V}|\bar{d}_v)$ for all vertices. Hence, all those steps with $h$ iterations result in a total runtime of $\mathcal{O}\left(hm\right)$.

%用 “leftangle”....
% % Figure environment removed
% Figure environment removed

\subsection{Hypergraph Weisfeiler-Lehman Kernel Framework}
In this subsection, we define the hypergraph Weifeiler-Lehman sequences and present the definition of the general hypergraph Weifeiler-Lehman kernel based on the proposed hypergraph Weifeiler-Lehman test algorithm. 

\subsubsection{Hypergraph Weisfeiler-Lehman Sequence}
In iteration $i$ of the hypergraph Weifeiler-Lehman algorithm, we generate two labeling functions $l_i^v$  and $l_i^e$ for vertices and hyperedges, respectively. Note that those labeling functions are concordant for the input hypergraph $\mathcal{G}$ and $\mathcal{G}'$. If two vertices in the hypergraph $\mathcal{G}$ or hypergraph $\mathcal{G}'$ share the same label, it indicates that these vertices possess identical rooted subtrees. Here, we treat each iteration (including two subprocesses) as a function $r((\mathcal{V}, \mathcal{E}, l_i^v, l_i^e)) = (\mathcal{V}, \mathcal{E}, l_{i+1}^v, l_{i+1}^e)$ that transforms the input hypergraphs in the same manner. After $h$ iterations, we obtain a sequence of $h+1$ hypergraphs (including the original hypergraph). This sequence is known as the hypergraph Weisfeiler-Lehman sequence, and it can be defined as follows.

\begin{definition} 
\label{def:hg_seq}
Given a hypergraph $\mathcal{G} = (\mathcal{V}, \mathcal{E}, \ell^v, \ell^e)$ and relabeling function $r := (\mathcal{V}, \mathcal{E}, l_i^v, l_i^e) \rightarrow (\mathcal{V}, \mathcal{E}, l_{i+1}^v, l_{i+1}^e)$, $\mathcal{G}_i$ indicates the relabeled hypergraph after $i$ iterations. Then, the \textbf{ hypergraph Weisfiler-Lehman sequence } can be defined as
\begin{equation}
    \{ \mathcal{G}_0, \cdots, \mathcal{G}_h \} = \{ (\mathcal{V}, \mathcal{E}, l_{0}^v, l_{0}^e), \cdots, (\mathcal{V}, \mathcal{E}, l_{h}^v, l_{h}^e) \}, 
    \nonumber
\end{equation}
where $\mathcal{G}_0 = \mathcal{G}$ and $l_0 = \ell_0$, the \textbf{ hypergraph Weisfeiler-Lehman sequence} up to height $h$ of hypergraph $\mathcal{G}$.
\end{definition}

In Definition \ref{def:hg_seq}, $\mathcal{G}_0$, $l_0^v$, and $l_0^e$ are initialized from the original hypergraph $\mathcal{G}$. The relabeling function $r := \mathcal{G}_{i-1} \rightarrow \mathcal{G}_i$ outcomes the relabeled hypergraph from the last iteration $\mathcal{G}_{i-1}$. In the sequence, the vertex set $\mathcal{V}$, and hyperedge set $\mathcal{E}$ are identical, while the vertex and hyperedge labels change in each iteration.

\subsubsection{General Hypergraph Weisfeiler-Lehman Kernel}
Given hypergraphs, we can obtain the hypergraph Weisfeiler-Lehman sequences by Algorithm \ref{alg:hg_wl}. To generalize the hypergraph embeddings from those sequences for computation, we then define the general hypergraph Weisfeiler-Lehman kernel. 

\begin{definition}
\label{def:hg_wl_fw}
Let $k$ be any kernel for hypergraphs that we will call the base kernel, given two hypergraphs $\mathcal{G}$ and $\mathcal{G}'$, the \textbf{hypergraph Weisfeiler-Lehman kernel} with $h$ iterations can be defined as 
\begin{equation}
    k_{\text{WL}}^{(h)}(\mathcal{G}, \mathcal{G}') = k(\mathcal{G}_0, \mathcal{G}_0') + k(\mathcal{G}_1, \mathcal{G}_1') + \cdots + k(\mathcal{G}_h, \mathcal{G}_h'),
\end{equation}
where $\{ \mathcal{G}_0, \mathcal{G}_1, \cdots, \mathcal{G}_h \}$ and $\{ \mathcal{G}_0', \mathcal{G}_1', \cdots, \mathcal{G}_h' \}$ are the \textbf{hypergraph Weisfeiler-Lehman sequence} of hypergraph $\mathcal{G}$ and $\mathcal{G}'$, respectively.
\end{definition}

Definition \ref{def:hg_wl_fw} presents a comprehensive framework for kernel-based hypergraph embedding, capable of incorporating discrete rooted subtrees with varying heights into consideration. When given an explicit strategy of the basic kernel, like label types counting, the hypergraph Weisfeiler-Lehman kernel will transform the original hypergraph structure into a vector embedding in the Hilbert space. This embedding representation enables various tasks, including hypergraph classification, retrieval, and similarity measurement, to be accomplished. 

\begin{theorem}
Let the base kernel $k$ be any positive semidefinite kernel on hypergraphs. Then, the corresponding hypergraph Weisfeiler-Lehman kernel $k_{\text{WL}}^{(h)}$ is positive semidefinite.
\end{theorem}

\begin{proof}
Let $\phi$ be the feature mapping corresponding to the kernel $k$:
$$
k(\mathcal{G}_i, \mathcal{G}_i') = \langle \phi(\mathcal{G}_i), \phi(\mathcal{G}_i') \rangle .
$$
We have 
$$
\mathcal{G}_i = \underbrace{r \cdots r}_{i}(\mathcal{G}) = R^i(\mathcal{G}) \quad \text{and} \quad \mathcal{G}_i' = \underbrace{r \cdots r}_{i}(\mathcal{G}') = R^i(\mathcal{G}').
$$
Thus, we have 
$$
k(\mathcal{G}_i, \mathcal{G}_i') = k(R^i(\mathcal{G}), R^i(\mathcal{G}')) = \langle \phi(R^i(\mathcal{G})), \phi(R^i(\mathcal{G}')) \rangle.
$$
We can build a composition function $\psi(\cdot)$ of $\phi(\cdot)$ and $R^i(\cdot)$. Then, we have
$$
k(\mathcal{G}_i, \mathcal{G}_i') = \langle \psi(\mathcal{G}), \psi(\mathcal{G}') \rangle .
$$
Since the sum of positive semidefinite kernel is a positive semidefinite kernel and $k$ is a positive semidefinite kernel of $\mathcal{G}$ and $\mathcal{G}'$, the $k_{\text{WL}}^{(h)}$ is positive semidefinite. 
\end{proof}


In the following, we will implement two basic kernel instances based on the general hypergraph Weisfeiler-Lehman kernel framework: subtree kernel and hyperedges kernel.


\subsection{Hypergraph Weisfeiler-Lehman Subtree Kernel}
Based on the Algorithm \ref{alg:hg_wl}, this subsection presents a natural instance named hypergraph Weisfeiler-Lehman subtree kernel. Since the vertex label in iteration $i$ compress a unique rooted subtree with height $i$, it is an intuitive strategy to use the frequency of discrete labels to describe the original hypergraph structure. By generalizing the Weisfeiler-Lehman subtree kernel \cite{graph_wl_subtree} from graphs to hypergraphs, we define the \textbf{hypergraph Weisfeiler-Lehman subtree kernel} as follows. 

\begin{definition}
\label{def:hg_wl_subtree}
    Let $\mathcal{G}$ and $\mathcal{G}'$ be hypergraphs. Define $\Sigma_i \subseteq \Sigma $ as the vertex label set that occurs in iteration $i$ of the hypergraph Weisfeiler-Lehman algorithm. Let $\{ \mathcal{G}_0, \mathcal{G}_1, \cdots, \mathcal{G}_h\}$ and $\{ \mathcal{G}_0', \mathcal{G}_1', \cdots, \mathcal{G}_h'\}$ be the hypergraph Weisfeiler-Lehman sequences of hypergraph $\mathcal{G}$ and $\mathcal{G}'$, respectively. Let $\Sigma_0$ be the original label set from the hypergraph $\mathcal{G}$ and $\mathcal{G}'$. Assume all $\Sigma_i$ are pairwise disjoint. Without loss of generality, assume that every $\Sigma_i = \{ \sigma_i^1, \sigma_i^2, \cdots, \sigma_i^{|\Sigma_i|} \}$ is ordered. Define a map $c:= \{ \mathcal{G}_i, \mathcal{G}_i' \} \times \sigma_i^j \rightarrow \mathbb{N}, i \in [0, 1, \cdots, h]$, such that $c(\mathcal{G}_i, \sigma_i^j)$ is the number of occurrences of the label $\sigma_i^j$ in the hypergraph $\mathcal{G}_i$. Then, the Weisfeiler-Lehman subtree kernel on two hypergraph $\mathcal{G}$ and $\mathcal{G}'$ with $h$ iterations is defined as
    \begin{equation}
        k_{\text{WLsubtree}}^{(h)}(\mathcal{G}, \mathcal{G}') = \langle \phi_{\text{WLsubtree}}^{(h)}(\mathcal{G}), \phi_{\text{WLsubtree}}^{(h)}(\mathcal{G}') \rangle ,
    \end{equation}
    where
    \begin{small}
    \begin{equation}
        \phi_{\text{WLsubtree}}^{(h)}(\mathcal{G}) = \left( c(\mathcal{G}_0, \sigma_0^{1}), \cdots, c(\mathcal{G}_0, \sigma_0^{|\Sigma_0|}), \cdots, c(\mathcal{G}_h, \sigma_h^{|\Sigma_h|}) \right) ,
        \nonumber
    \end{equation}
    \end{small}
    and 
    \begin{small}
    $$
    \phi_{\text{WLsubtree}}^{(h)}(\mathcal{G}') = \left( c(\mathcal{G}_0', \sigma_0^{1}), \cdots, c(\mathcal{G}_0', \sigma_0^{|\Sigma_0|}), \cdots, c(\mathcal{G}_h', \sigma_h^{|\Sigma_h|}) \right) .
    $$
    \end{small}
\end{definition}

% \begin{theorem}
%     Given connected hypergraphs $\mathcal{G}$ and $\mathcal{G}'$, let $\Sigma = \{ \Sigma_0, \Sigma_1, \cdots, \Sigma_h \}$ be the label sets in iterations of the hypergraph Weisfeiler-Lehman subtree kernel. $\Sigma_i = \{ \sigma_i^1, \sigma_i^2, \cdots, \sigma_i^{|\Sigma_i|} \}$ is the ordered label set of iteration $i$. Assume with the compression function $f:= s \rightarrow s'$, the length of the compressed string $s'$ is strictly shorter than the length of the input string $s$. Then, $\Sigma_i$ and $\Sigma_j$ are disjoint for any $i, j \in [0, 1, \cdots, h]$.
% \end{theorem}

% \begin{proof}
%     Suppose there is an intersection between $\Sigma_i$ and $\Sigma_j$, and the element $\sigma_* = \sigma_i^a = \sigma_j^b$ belongs to the intersection, where $\sigma_i^a \in \Sigma_i$ and $\sigma_j^b \in \Sigma_j$. Without loss of generality, assume that $i < j$. 

%     If $j = i + 1$, according to the hypergraph Weisfeiler-Lehman algorithm, the string compression function is an injective function, the
%     label $\sigma^k_j, k\in [1, 2, \cdots, |\Sigma_j|]$ from $\Sigma_j$ can be calculated by $l_j^v(v) = f(strcat(l_i^v(v), S_v)), v \in \mathcal{V}$. balabala

%     If $ i > 0 $ and $j = i + 1$,
% \end{proof}

For the convenience of computation, the hypergraph Weisfeiler-Lehman subtree kernel can be further written as

\begin{small}
\begin{equation}
    \begin{aligned}
        k_{\text{WLsubtree}}^{(h)} (\mathcal{G}, \mathcal{G}') &= k(\mathcal{G}_0, \mathcal{G}_0') + k(\mathcal{G}_1, \mathcal{G}_1') + \cdots + k(\mathcal{G}_h, \mathcal{G}_h') \\
        &= \sum_{i=0}^{h} \sum_{v \in \mathcal{V}} \sum_{v' \in \mathcal{V}'} \delta \left( l_i^v(v), l_i^v(v') \right) \\
        &= \sum_{i=0}^{h} \sum_{j=1}^{|\Sigma_i|} c(\mathcal{G}_i, \sigma_i^j) \cdot c(\mathcal{G}_i', \sigma_i^j)
    \end{aligned} ,
\end{equation}
\end{small}
where $\delta(a, b)$ is the Dirac kernel, that is, it is $1$ when $a$ and $b$ are equal and $0$ otherwise. $c(\mathcal{G}_i, \sigma_i^j)$ is the element counting function as defined in Definition \ref{def:hg_wl_subtree}.

% \subsubsection{Complexity}
\textbf{Complexity. }
\label{sec:subtree_complexity}
The runtime complexity of the proposed hypergraph Weisfeiler-Lehman subtree kernel on $N$ hypergraphs with $h$ iterations is $\mathcal{O}\left(Nh\bar{m} + N^2hd\right)$, where $\bar{m}$ is the average hypergraph capacity (referring to Section \ref{sec:fw_complexity}) of $N$ hypergraph. $d$ denotes the dimension of the final hypergraph feature, which equals the sum of $\{|\Sigma_0|, |\Sigma_1|, \cdots, |\Sigma_h| \}$. The computation of the hypergraph Weisfeiler-Lehman subtree kernel can be divided into two stages: building the hypergraph Weifeiler-Lehman sequence and counting the vertex labels for each iteration. Clearly, referring to Section \ref{sec:fw_complexity}, the complexity of the first stage is $\mathcal{O}(Nh\bar{m})$. As for the second stage, we multiply all feature vectors to get the kernel values of all hypergraph pairs. Since the dimension of each feature vector is $d$, the computation of the second stage requires a runtime $\mathcal{O}(N^2hd)$. Hence, all those steps result in a total runtime of $\mathcal{O}\left(Nh\bar{m} + N^2hd\right)$.


\subsection{Hypergraph Weisfeiler-Lehman Hyperedge Kernel}
This subsection presents another instance of the general hypergraph Weisfeiler-Lehman hyperedge kernel: hypergraph Weisfeiler-Lehman hyperedge kernel. Unlike the subtree kernel, this instance counts the frequency of different types of hyperedges. Since each hyperedge can link more than two vertices, we treat it as an ordered set for comparison. Compared with the previous subtree kernel, the hyperedge kernel can directly represent the information of high-order connections in each iteration.
It can be defined as follows.
\begin{definition}
    Let $\mathcal{G}$ and $\mathcal{G}'$ be hypergraphs. Define $\Sigma_i \subseteq \Sigma $ as the vertex label set that occurs in iteration $i$ of the hypergraph Weisfeiler-Lehman algorithm. Let $\{ \mathcal{G}_0, \mathcal{G}_1, \cdots, \mathcal{G}_h\}$ and $\{ \mathcal{G}_0', \mathcal{G}_1', \cdots, \mathcal{G}_h'\}$ be the hypergraph Weisfeiler-Lehman sequences of hypergraph $\mathcal{G}$ and $\mathcal{G}'$, respectively. Let $\Sigma_0$ be the original label set from the hypergraph $\mathcal{G}$ and $\mathcal{G}'$. Assume all $\Sigma_i$ are pairwise disjoint. 
    Define map $z_i := e \rightarrow (l_i^v(v_1), \cdots, l_i^v(v_{|e|})), v_j \in e, l_i^v(v_j) \in \Sigma_i, e \in \mathcal{E}$ as the hyperedge code to denote the hyperedge in $i$-th iteration. Assume each hyperedge code is a sorted vertex label tuple. Define $ \Omega_i \subseteq \Omega $ as the hyperedge code set that occurs in iteration $i$. 
    Without loss of generality, assume that every $\Sigma_i = \{ \sigma_i^1, \sigma_i^2, \cdots, \sigma_i^{|\Sigma_i|} \}$ and $\Omega_i = \{ \omega_i^1, \omega_i^2, \cdots \omega_i^{|\Omega_i|} \}$ are ordered. 
     Define a map $p:= \{ \mathcal{G}_i, \mathcal{G}_i' \} \times \omega_i^j \rightarrow \mathbb{N}, i \in [0, 1, \cdots, h]$, such that $p(\mathcal{G}_i, \omega_i^j)$ is the number of occurrences of the hyperedge code $\omega_i^j$ in the hypergraph $\mathcal{G}_i$. Then, the Weisfeiler-Lehman hyperedge kernel on two hypergraph $\mathcal{G}$ and $\mathcal{G}'$ with $h$ iterations is defined as
    \begin{equation}
        k_{\text{WLhyperedge}}^{(h)}(\mathcal{G}, \mathcal{G}') = \langle \phi_{\text{WLhyperedge}}^{(h)}(\mathcal{G}), \phi_{\text{WLhyperedge}}^{(h)}(\mathcal{G}') \rangle ,
    \end{equation}
    where
    \begin{small}
    \begin{equation}
        \phi_{\text{WLhyperedge}}^{(h)}(\mathcal{G}) = \left( p(\mathcal{G}_0, \omega_0^{1}), \cdots, p(\mathcal{G}_0, \omega_0^{|\Omega_0|}), \cdots, p(\mathcal{G}_h, \omega_h^{|\Omega_h|}) \right) ,
        \nonumber
    \end{equation}
    \end{small}
    and 
    \begin{small}
    $$
    \phi_{\text{WLhyperedge}}^{(h)}(\mathcal{G}') = \left( p(\mathcal{G}_0', \omega_0^{1}), \cdots, p(\mathcal{G}_0', \omega_0^{|\Omega_0|}), \cdots, p(\mathcal{G}_h', \omega_h^{|\Omega_h|}) \right) .
    $$
    \end{small}
\end{definition}

Similarly, the hypergraph Weisfeiler-Lehman hyperedge kernel can be further written as 
\begin{small}
\begin{equation}
\label{eq:k_hyperedge}
    \begin{aligned}
        k_{\text{WLhyperedge}}^{(h)} (\mathcal{G}, \mathcal{G}') &= k(\mathcal{G}_0, \mathcal{G}_0') + \cdots + k(\mathcal{G}_h, \mathcal{G}_h') \\
        &= \sum_{i=0}^{h} \sum_{e \in \mathcal{E}} \sum_{e' \in \mathcal{E}'} \delta \left( z_i(e), z_i(e') \right) \\
        &= \sum_{i=0}^{h} \sum_{j=1}^{|\Omega_i|} p(\mathcal{G}_i, \omega_i^j) \cdot p(\mathcal{G}_i', \omega_i^j)
    \end{aligned} ,
\end{equation}
\end{small}
where $\delta(a, b)$ is the Dirac kernel. 


% \subsubsection{Complexity}
\textbf{Complexity. }
The runtime complexity of the proposed hypergraph Weisfeiler-Lehman hyperedge kernel on $N$ hypergraphs with $h$ iterations is $\mathcal{O}\left(Nh\bar{m} + N^2hd'\right)$. $d'$ is the dimension of the final feature, which equals the sum of $\{|\Omega_0|, |\Omega_1|, \cdots, |\Omega_h| \}$. As Section \ref{sec:subtree_complexity}, the runtime of building the hypergraph Weisfeiler-Lehman sequence is $\mathcal{O}(Nh\bar{m})$. For each hypergraph, the runtime of building hyperedge codes with $h$ iteration is $\mathcal{O}(h|\mathcal{E}|\bar{d}_v)$, which equals $\mathcal{O}(hm)$. Thus, for $N$ hypergraph, the runtime of building hyperedge codes is $\mathcal{O}\left(Nh\bar{m} \right)$. As for the hyperedge code counting stage, the complexity of pairs of $N$ hypergraphs is $\mathcal{O}(N^2hd')$ as shown in Equation \eqref{eq:k_hyperedge}. Hence, all those steps result in a total runtime of $\mathcal{O}\left(Nh\bar{m} + N^2hd'\right)$.


\subsection{Computing in Practice}
Due to the large and uncertain dimensions of the generated feature from the hypergraph Weisfeiler-Lehman kernel, we adopt the commonly used normalization trick \cite{svm_trick} to reduce the dimension of the feature for training and testing hypergraphs. Given the feature matrices $\mathbf{X}_{tr} \in \mathbb{R}^{N_{tr} \times d}, \mathbf{X}_{te} \in \mathbb{R}^{N_{te} \times d}$ extracted with a specifical hypergraph Weisfeiler-Lehman kernel $K$, the $N_{tr}$ and $N_{te}$ denote the number of training hypergraphs and the testing hypergraphs, respectively. We compress them based on the training hypergraphs with the function $Z:= \mathbb{R}^{N \times d} \rightarrow \mathbb{R}^{N \times N_{tr}}$. The compressed features can be computed by $\check{\mathbf{X}}_{tr} = Z(\mathbf{X}_{tr}) \in \mathbb{R}^{N_{tr} \times N_{tr}}$ and $\check{\mathbf{X}}_{te} = Z(\mathbf{X}_{te}) \in \mathbb{R}^{N_{te} \times N_{tr}}$, respectively. Each entry of the compressed features $\check{\mathbf{X}}_{tr}$ and $\check{\mathbf{X}}_{te}$ can be computed as
\begin{equation}
    \check{\mathbf{X}}_{i,j} = \frac{k(\mathcal{G}_i, \mathcal{G}_j)}{\sqrt{k(\mathcal{G}_i, \mathcal{G}_i) k(\mathcal{G}_j, \mathcal{G}_j)}} , \qquad j = 1, \cdots, N_{tr} ,
\end{equation}
where the $i$ is in range $[1, N_{tr}]$ or $[1, N_{te}]$ for training and testing, respectively. The function $Z$ can be defined as
\begin{equation}
    Z(\mathbf{X}) = \frac{\mathbf{X} \mathbf{X}_{tr}^\top}{\sqrt{(\mathbf{X} \circ \mathbf{X} \mathbf{1}_d) \otimes (\mathbf{X}_{tr} \circ \mathbf{X}_{tr} \mathbf{1}_d)^\top}} ,
\end{equation}
where $\circ, \otimes$ denote the pointwise product, and outer product. $\mathbf{1}_d \in \{1\}^{d \times 1}$ is the vector of ones. Note that in the embedding process of the testing hypergraphs, those unseen structures like rooted subtrees and hyperedges are dropped. In this way, the final features from training hypergraphs and testing hypergraphs are comparable to each other.

% \subsection{Analysis}

\subsection{Relation to Graph WL Subtree Kernel}
\label{sec:relation_graph_wl_and_hypergraph_wl}
In this subsection, we prove that the hypergraph Weisfeiler-Lehman subtree kernel can degenerate into the graph Weisfeiler-Lehman subtree kernel confronting the simple graph structure.


\begin{lemma}
    \label{lemma:bijective}
    Given a graph $G = \{ V, E \}$, let the $c$ and $c'$ be the graph/hypergraph Weisfeiler-Lehman subtree kernel's compression functions compress the rooted string $s$/$s'$ to a unique label $l$/$l'$, respectively. Exist a bijective function $\phi$ that maps the graph Weisfeiler-Lehman subtree kernel's rooted string $s$ to hypergraph Weisfeiler-Lehman kernel' rooted string $s'$. 
\end{lemma}
% 双射 -> 集合元素数量相等

\begin{proof}
    \textbf{Proof of surjection:} In the $i$-th iteration, given vertex $v$, the compressed rooted string of the graph Weisfeiler-Lehman subtree kernel \cite{graph_wl_subtree} is $l_{i-1}(v)|\langle l_{i-1}(v_j), v_j \in \mathcal{N}(v)\rangle$, where $\mathcal{N}(v) = \{v_1, v_2, \cdots\}$ is the neighbor vertex set of the vertex $v$. $\langle \cdot \rangle$ is the multi-set sorting function. $\cdot|\cdot$ is the string concatenation operation. Finally, in $i$-th iteration, the rooted string of the graph Weisfeiler-Lehman subtree kernel of the vertex $v$ can be formulated as
    \begin{equation}
    \label{eq:graph_rooted_string}
        l_{i-1}(v)|\langle l_{i-1}(v_1), l_{i-1}(v_2), \cdots, l_{i-1}(v_m) \rangle .
    \end{equation}
    By composing label function $l(\cdot)$, we can construct an injective function $f$ that maps an order vertex set to the rooted string. Then, the rooted string of vertex $v$ can be written as $f(v, v_1, v_2, ..., v_m)$.

    Similarly, given the vertex $v$, in the $i$-th iteration, the compressed rooted string of the hypergraph Weisfeiler-Lehman subtree kernel is $l_{i-1}^v(v)|\langle l_i^e(e_j), e_j \in \mathcal{N}_e(v)\rangle$, where $\mathcal{N}_e(v) = \{ e_1, e_2, \cdots \}$ is the hyperedge neighbor set of the given vertex $v$. Then, each hyperedge label can be computed by $l^e_i(e) = l^e_{i-1}(e) | \langle l^v_{i-1}(v_j), v_j \in \mathcal{N}_v(e) \rangle$, where $\mathcal{N}_v(e) = \{ v_1, v_2, \cdots \}$ is vertex neighbor set of the given hyperedge $e$. Finally, in $i$-th iteration, the rooted string of the hypergraph Weisfeiler-Lehman subtree kernel of the vertex $v$ can be formulated as
    \begin{equation}
        \label{eq:initial_hg_rooted_string}
        \begin{aligned}
        l_{i-1}^v(v)|\langle & l_{i-1}^e(e_1)|\langle l^v_{i-1}(v^{e_1}_1), l^v_{i-1}(v^{e_1}_2), \cdots \rangle,  \\
        & l_{i-1}^e(e_2)|\langle l^v_{i-1}(v^{e_2}_1), l^v_{i-1}(v^{e_2}_2), \cdots \rangle,  \\
        &\cdots \\
        & l_{i-1}^e(e_m)|\langle l^v_{i-1}(v^{e_m}_1), l^v_{i-1}(v^{e_m}_2), \cdots \rangle \rangle
        \end{aligned} ,
    \end{equation}
    where $\{ v^{e_j}_1, v^{e_j}_2 \}$ denotes the vertex set that linked by hyperedge $e_j$. Considering that each edge in the given graph $G$ only connects two vertices and one of the connected vertex must be the vertex $v$, the Equation \eqref{eq:initial_hg_rooted_string} can be further written as:
    \begin{equation}
        \label{eq:hg_rooted_string}
        \begin{aligned}
        l_{i-1}^v(v)|\langle & l_{i-1}^e(e_1)|\langle l^v_{i-1}(v), l^v_{i-1}(v_1) \rangle,  \\
        & l_{i-1}^e(e_2)|\langle l^v_{i-1}(v), l^v_{i-1}(v_2) \rangle,  \\
        &\cdots \\
        & l_{i-1}^e(e_m)|\langle l^v_{i-1}(v), l^v_{i-1}(v_m) \rangle \rangle
        \end{aligned} .
    \end{equation}
    Since the degree of the hyperedge in the simple graph is constant to $2$, the hyperedge label $l^e_0(e)$ is all the same: $l^e_0(e_1) = l^e_0(e_2) = \cdots = l^e_0(e_m) $.

    When $i=0$, the two algorithms both count the number of different types of labels, thus yielding the same number of rooted strings. 

    When $i=1$, by composing the label function $l^v(\cdot)$ and initial hyperedge label $l^e_0(e)$, we can construct an inject function $f'$ that map the vertex set to string. Then, the rooted string of the vertex $v$ extracted from the hypergraph Weisfeiler-Lehman can be written as $f'(v, v_1, v_2, \cdots, v_m)$, which can be mapped the rooted string extracted from the graph Weisfeiler-Lehman. Since the input graph is the same and the number of the rooted subtree of height $1$ is also the same, the number of the unique labels in iteration $1$ of the two algorithms is the same.

    When $i>1$, the $l_{i-1}^e(e)$ is a function with respect to the $\{ l_{i-2}^e(e), l_{i-2}^v(v), l_{i-2}^v(v') \}$, where $v$ and $v'$ is the specified root vertex and another vertex that linked by edge $e$, respectively. For the specified vertex $v$, the related vertex set $\{v, \{v, v_1\}, \{v, v_2\}, \cdots, \{v, v_m\}\}$ that determining the rooted string can then be reduced to $\{v, v_1, v_2, \cdots, v_m\}$. We can also construct an injective function $f'$ for mapping. Then, the rooted string can be written as $f'(v, v_1, v_2, \cdots, v_m)$. Hence, in $i>1$ iteration, the number of the compressed label of the two algorithms are also the same. 

    Since the two algorithms yield the same number of unique compressed labels in each iteration, the number of the rooted strings extracted from the two algorithms with $h$ iterations is the same. Those rooted strings can also be determined from the same sorted vertex set. Thus, the surjection holds.
    
    \textbf{Proof of injection:} First, we construct a map $\phi := s \rightarrow s'$ from the graph Weisfeiler-Lehman rooted string to the hypergraph Weisfeiler-Lehman rooted string. Given a rooted string $s$ like Equation \ref{eq:graph_rooted_string}, we first extract the stem vertex set $\{ v, v_1, v_2, \cdots, v_m \}$ with injective function $f$. Note that the first element of the stem vertex set is the root vertex $v$ and the rest is the neighbor vertex set of the vertex $v$. Then, we transform the stem vertex set into an expanded set $\{v, \{v, v_1\}, \{v, v_2\}, \cdots, \{v, v_m\}\}$. In the rooted string of the hypergraph Weisfeiler-Lehman subtree kernel like Equation \eqref{eq:hg_rooted_string}, the updated hyperedge label $l_{i-1}^e(e_j)|\langle l^v_{i-1}(v), l^v_{i-1}(v_j)$ is a function of the $\{v, v_j\}$ and the initial hyperedge label $\ell(e)$ is all the same. Hence, the rooted string $s'$ can also be computed from the stem vertex set $\{ v, v_1, v_2, \cdots, v_m \}$, which can be denoted by the injective function $g$. Then, the map $\phi :\ s \rightarrow s'$ can be implemented as a composition function $ \phi = g \circ f$. 
    
    Next, we prove $\forall s_1, s_2 \in S, \phi(s_1) = \phi(s_2) \Rightarrow s_1 = s_2$.  $S$ denotes the final rooted string set extracted by the graph Weisfeiler-Lehman subtree kernel. From the definition of the algorithm \cite{graph_wl_subtree}, we know that any two elements in the $S$ are different and indicate different rooted subtree structures. Assume we have two rooted strings $s_1$ and $s_2$ that $\phi(s_1) = \phi(s_2)$, then the root vertex of the $\phi(s_1)$ and $\phi(s_2)$ are the same, which is termed by vertex $v$. Clearly, the operation of the injective function $g$ is reversible. Then the two same rooted strings $\phi(s_1)$ and $\phi(s_2)$ can be transformed into the stem vertex set $\{v, \{v, v_1\}, \{v, v_2\}, \cdots, \{v, v_m\}\}$. After removing the root vertex for each element and applying the inverse function of $f$, the $\phi(s_1)$ and $\phi(s_2)$ will produce the same rooted string $s_1$ and $s_2$. Since the assumption to be false leads to a contradiction, it is concluded that the injection holds.

    Finally, since the surjection and injection hold, according to the definition of the bijection, Lemma \ref{lemma:bijective} holds.
\end{proof}


\begin{theorem}
\label{theorem:equal}
    Given a set of graph $\mathcal{G} = \{ G_1, G_2, \cdots, G_n \}$, the kernel matrix $\mathbf{K} \in \mathbb{R}^{n \times n}$ and $\mathbf{K}' \in \mathbb{R}^{n \times n}$ are generated by the graph Weisfeiler-Lehman subtree kernel and the hypergraph Weisfeiler-Lehman subtree kernel, respectively. Then, the $\mathbf{K}$ and $\mathbf{K}'$ are identical. 
\end{theorem}

\begin{proof}
    Given graph $G_i \in \mathcal{G}$, the feature vector $x_i \in \mathbb{R}^{c \times 1}$ and $x_i' \in \mathbb{R}^{c \times 1}$ are the graph embeddings extracted from the graph/hypergraph Weisfeiler-Lehman subtree kernel, respectively. Since each element in the feature vector corresponds to a unique rooted string and with Lemma \ref{lemma:bijective}, there exists a permutation matrix $\mathbf{P} \in \{0, 1\}^{N \times N}$, such that $x_i' = \mathbf{P} x_i$. The entries of kernel matrix $\mathbf{K}$ and $\mathbf{K}'$ can be calculated by:
    \begin{equation}
        \left\{
            \begin{aligned}
                \mathbf{K}_{ij} &= k(G_i, G_j) = \langle x_i, x_j \rangle = x_i^\top  x_j \\
                \mathbf{K}'_{ij} &= k'(G_i, G_j) = \langle x'_i, x'_j \rangle = {x'}_i^\top x'_j \\
            \end{aligned}
        \right. ,
    \end{equation}
    where $\langle \cdot, \cdot \rangle$ denotes the inner product operation of two vectors. According to the permutation matrix, we have 
    \begin{equation}
        \begin{aligned}
        {x'}_i^\top x'_j &= (\mathbf{P} x_i)^\top (\mathbf{P} x_j) \\
        &= x_i^\top \mathbf{P}^\top \mathbf{P} x_j \\
        &= x_i^\top x_j
        \end{aligned} .
    \end{equation}
    Hence, each element in position $i, j$ of kernel matrix $\mathbf{K}$ and $\mathbf{K}'$ are identical. The theorem holds.
\end{proof}


% \subsubsection{Relation to HGNN+ Framework}
% balabala
