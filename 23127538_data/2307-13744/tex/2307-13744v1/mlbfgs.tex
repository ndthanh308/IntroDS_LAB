\begin{algorithm}[!htb]
\caption{\method{} algorithm ($T$, $M$, parameter block $\left \{ \btheta^i \right \}_{i=1}^p$)}
\label{alg:method}
\begin{algorithmic}[1]
\STATE Initialize $\btheta_0$, $\Mp{0}^i=\btheta_0^i$, $\Mg{0}^i=\bm{g}_0^i$ \\
|
\FOR{$t = 1, \cdots, \text{max}\_\text{iter}$}
    \STATE Randomly choose mini-batch input $\tX_t \in \mathcal{X}$
    \STATE Perform model forward and backward, compute gradients $\bm{g}_t$ given $\tX_t$
    % \STATE \blue{Weight decay}: $\bm{g}_t = \bm{g}_t + wd\cdot\btheta_t$
    \FOR{each parameter block $i$}
    \STATE $\Mp{t}^i = \beta\cdot\Mp{t-1}^i + (1-\beta)\cdot\btheta_t^i, \quad \Mg{t}^i = \beta\cdot\Mg{t-1}^i + (1-\beta)\cdot\bm{g}_t^i$ \\
    % \STATE $\Mg{t}^i = \beta\cdot\Mg{t-1}^i + (1-\beta)\cdot\bm{g}_t^i$ \\
    |
    \IF{$t\leq 2T$}
        \STATE {\color{blue}Warmup with SGD}: $\btheta_{t+1}^i = \btheta_t^i - \eta_t\cdot\bm{g}_t^i$
    \ELSE
        \STATE {\color{blue}Pre-condition}: $\Delta\btheta_{t}^i = \HI_k^i\cdot\bm{g}_t^i$ {\color{blue}\COMMENT{Algorithm~\ref{alg:HessianVecProd}}}
        \STATE $\btheta_{t+1}^i = \btheta_t^i - \eta_t\cdot\Delta\btheta_{t}^i$ 
    \ENDIF \\
    |
    \IF{$t \% T == 0$ and $t>T$}
        \STATE $k = k+1$
        \STATE $\bm{s}_k^i = \Mp{t}^i - \Mp{t - T}^i, \quad \bm{y}_k^i = \Mg{t}^i - \Mg{t - T}^i$
        % \STATE $\bm{y}_k^i = \Mg{t}^i - \Mg{t - L}^i$
        \STATE {\color{blue}Apply damping}: $\hat{\bm{y}}_k^i=\tau\cdot\bm{y}_k^i + (1-\tau)\cdot\bm{s}_k^i$
        \STATE {\color{blue}Update Hessian}: $\HI_{k}^i = \emph{UpdateHessian}(\HI_{k-1}^i, \bm{s}_k^i, \hat{\bm{y}}_k^i, M)$
    \ENDIF \\
    |
    \ENDFOR \\
    |
    \STATE \textit{All-Gather} $\left \{ \btheta^i_{t+1} \right \}_{i=1}^p$ across all nodes.
\ENDFOR
\end{algorithmic}
\end{algorithm}