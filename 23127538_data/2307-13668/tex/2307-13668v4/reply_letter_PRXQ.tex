\documentclass{article}
\usepackage[margin=2.22cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvipsnames]{xcolor}
\usepackage[square, numbers]{natbib}
\usepackage{libertine}
\usepackage{enumitem}
\usepackage{xparse}
\usepackage{microtype}
\usepackage{braket}

\usepackage{biblatex} %Imports biblatex package
\addbibresource{references.bib}

\usepackage{ulem}

\title{\textbf{LX17910 Stephen:\\
               Reply to referees}}
\date{\today}


\hypersetup{
    colorlinks = true,
    linkcolor  = blue,
    citecolor  = blue,
    urlcolor   = blue,
}

\definecolor{DarkerBlue}{HTML}{1F77B4}

% get rid of annoying underfull hbox warnings...
\hbadness=99999  % or any number >=10000

\usepackage[breakable, theorems, skins]{tcolorbox}
\tcbset{enhanced}

\NewDocumentCommand{\bgbox}{ O{gray!20} O{red} m }{%
\begin{tcolorbox}[%
        breakable,
        left=0pt,
        right=0pt,
        top=0pt,
        bottom=0pt,
        colback=#1,
        colframe=#2,
        width=\dimexpr\linewidth\relax, 
        enlarge left by=0mm,
        boxsep=5pt,
        arc=0pt,outer arc=0pt,
        ]
        #3
\end{tcolorbox}
}

\DeclareRobustCommand{\bgboxgray}[2][gray!20]{%
\begin{tcolorbox}[%
        breakable,
        left=0pt,
        right=0pt,
        top=0pt,
        bottom=0pt,
        colback=#1,
        colframe=#1,
        width=\dimexpr\linewidth\relax, 
        enlarge left by=0mm,
        boxsep=5pt,
        arc=0pt,outer arc=0pt,
        ]
        #2
\end{tcolorbox}
}

\newcommand{\ChangesBox}[1]{%
    \bgbox{%
        {\noindent #1}
    }
    \vspace{0.5cm}
}


\newcommand{\ChangesMade}[1]{%
    \bgbox{%
    {\noindent\textsf{\textsc{summary of changes:}}\\%
    \noindent #1}
    }
    \vspace{0.5cm}
}

\definecolor{david}{RGB}{150,0,100}
\newcommand{\david}[1]{{\color{david}\footnotesize{(DTS) #1}}}
\newcommand{\rv}[1]{{\color{red}\footnotesize{(RV) #1}}}
\newcommand{\ww}[1]{{\color{olive}\footnotesize{(WWH) #1}}}
\newcommand{\wwc}[1]{{\color{olive}{#1}}}
\newcommand{\tcw}[1]{{\color{brown}\footnotesize{(TCW) #1}}}
\newcommand{\rahul}[1]{{\color{red}\footnotesize{(Rahul) #1}}}
\definecolor{arpit}{RGB}{200,0,0}
\newcommand{\arpit}[1]{{\color{arpit}{#1}}}

\definecolor{DarkerGray}{HTML}{444444}
\newenvironment{referee}{\begin{quote}\it\color{DarkerBlue}}{\end{quote}}

\newcommand{\CZ}{\mathsf{CZ}}
\renewcommand{\theequation}{R.\arabic{equation}}
\renewcommand{\thefigure}{R.\arabic{figure}}

\begin{document}



\newpage

\noindent Dear Dr. Thingna, \\[0.33cm]

\noindent We are grateful for your handling of our manuscript ``Engineering Floquet codes by rewinding''. We firstly thank Referee A for their positive feedback and for their support of publication in PRX Quantum. We do not agree with the subjective characterization made in the other report or comments of our ideas being obvious and consider this as a retrospective judgment. We note that even though rewinding was used before, it was merely stated as a sequence of steps without any physical explanation, and hence, its applications were not made clear. 

We, however, agree that we did not do a good job at elucidating the key insights of our work, especially the generality of the rewinding idea, our understanding of it in terms of the condensation picture, and utilization of it for multiple objectives. Hence, we have now made substantial additions and modifications to the manuscript to achieve that elucidation and to address the other points raised by the referees. We believe that, with these changes, our manuscript satisfies the publication requirements of PRX Quantum. We hope you will agree. \\[0.33cm]

\noindent Sincerely,\\
\noindent Arpit Dua, Nathanan Tantivasadakarn, Joseph Sullivan, and Tyler Ellison \\[0.5cm] 

\noindent In what follows, the comments of the referees are in blue {\it italics}, our response is in regular text, and the additions/modifications to the paper are written in red. We have also attached a PDF of the manuscript in which the new or changed parts are highlighted in red.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\section*{Report of Referee A}
\vspace{0.75cm}

\begin{referee}
In the paper "Engineering Floquet Codes by Rewinding," the authors construct novel Floquet codes, error-correcting protocols defined by a sequence of non-commuting Pauli operators, also called checks. They construct Floquet codes defined by checks that are local in two spatial dimensions, whose associated ISGs are equivalent to the two-dimensional color code. Interestingly, they give a schedule that implements an order-3 automorphism to the codestates after one period. This is the first time that such an automorphism has been shown in the literature.

In the paper, three more classes of Floquet codes are presented, each defined by checks that are local in three spatial dimensions. Their ISGs can be related to the 3D toric code (and two copies thereof), the X-cube model, a stabilizer model for a fracton phase, and a fermionic 3D toric code, a bosonic topological phase with point-like excitations that behave like fermions.

For all four classes of Floquet codes, they present different schedules on the same set of checks and highlight interesting differences in the transformation of the ISGs. A recurring theme is the notion of a rewinding schedule, a schedule that is mirror-symmetric within one period, i.e., reverses the sequence halfway through a period. The authors show that the rewinding schedules apply a trivial automorphism to the system after a full period. This property is important for designing checks and schedules at boundaries with the same periodicity as the bulk sequence. Moreover, the authors discuss how a rewinding schedule affects the ISGs of the 3D codes in different and interesting ways. For the code in the X-cube phase, the rewinding schedule avoids a phase transition/splitting out of the X-cube phase into decoupled stacks of 2D Toric Code, which was present in another "X-Cube Floquet Code." For the fermionic 3D Toric Code, the rewinding schedule avoids measuring non-local operators along non-contractible loops, thereby achieving the generation (and preservation) of a logical qubit.

Overall, the paper constitutes a significant contribution to the Floquet Code literature by presenting new examples of Floquet codes in two and three spatial dimensions. Focusing on rewinding schedules also provides an interesting perspective for the design and analysis of Floquet codes in general, particularly when designing boundaries.
Below, I have attached some points that I think are worth clarifying or extending. If these points are addressed, I support the publication of this manuscript in PRX Quantum.

\end{referee}

We thank the referee for their kind comments and suggestions and for supporting the publication of our manuscript in PRX Quantum.

\begin{referee}

Suggestions and Points Needing Clarification:

p. 5, left: The paragraph explaining the Z3 automorphism in the 3-round cycle left me a bit puzzled. In particular, the precise meaning of the sentence, "Since there are no non-local stabilizer generators of the check group, the automorphism occurs due to multiplication with products of dynamically generated logical operators belonging to the check group," is unclear to me. In which sense is the Pauli operator that is multiplied onto the logical representative to obtain an operator that commutes with the checks of the next round a "logical"? As far as I understand, the transformation of logical operators in dynamical codes requires multiplying with elements in the ISG at that time. In the case presented here, there might be a non-local element of that ISG involved (which cannot be generated only by local elements in the same ISG). If I understand correctly, I highly suggest avoiding the term "logical operator" in this context. Otherwise, I suggest elaborating more explicitly on how multiplying with a non-trivial logical Pauli p (defining a non-trivial logical coset pS$\neq$ S, where S is the ISG) is a valid operation to infer the transformation of a different logical Pauli operator. Alternatively, make the explanation more explicit (possibly connecting it to the following paragraphs of the same section) to avoid confusion.
\end{referee}
We thank the referee for stating their confusion. It is true that we evolve the logical operators by multiplying them with instantaneous stabilizers. However, after a full period, the product of instantaneous stabilizers between measurement rounds can be a logical operator for a given ISG. This is the case for the $\mathbb{Z}_2$ Floquet toric code, where in each round, the logical operators are updated by multiplying by checks, and after a period, we have multiplied by a logical operator of the ISG -- namely a fermion string operator. This fermion string operator is a logical operator of the ISG but is a non-local stabilizer of the check group. The distinction we would like to make for the Floquet color code is that the product of instantaneous stabilizers used to update the logical operators is a dynamically generated logical operator, i.e., it is neither a logical operator of the static subsystem code nor a nonlocal stabilizer. This is because we do not have any non-local stabilizers of the check group in the Floquet color code. Instead, the product of check operators that gets multiplied to the logical is simply equivalent to a logical operator of the ISG and this multiplication yields the automorphism. Another way to look at this is that there would be no automorphism of the logical operators of ISG0 if all you were multiplying with were stabilizers of ISG0. 

We have made the following additions to the manuscript to make this clear for the reader. 
\begin{quote}\color{arpit}
In other words, the product of the check operators that get multiplied by the logical operators after a full cycle is itself a logical operator of the ISG, but it is neither a logical operator nor a nonlocal stabilizer of the check group.
\end{quote}
This is in addition to the definition of ``dynamically generated logical operators'' that appears earlier.



\begin{referee}
p. 13, right at the start of the Section V, concretely the second paragraph, the authors directly dive into
details of the schedule and mention terms that the introduced only in previous sections. Although one can
guess that a similar system of qubits and checks as in the previous section is considered, this is not
mentioned explicitly. I suggest to add a small paragraph explaining basics of the model considered. For
example, one could mostly refer to previous sections if the details agree. This would not add much text with
the upside of making the sections more self-contained. 
\end{referee}
We thank the referee for this suggestion. We have now added the following sentences to make the lattice clear and the section more self-contained. 
\begin{quote}\color{arpit}
    This Floquet code is again based on a coupled layer construction and uses stacks of 2D Floquet TCs on the square-octagon lattices, as used for our 3D Floquet bTC in the previous section. Hence, the microscopic lattice is same as given in Fig.~6, and the effective underlying lattice for the B-ISG is the same as given in Fig.~10(a). However, the sequence of measurements is different and hence, the stabilizers supported on those lattices are different.
\end{quote}

\begin{referee}
Moreover, I suggest to shortly comment how their
model differs from the X-cube model in Ref. 13 beyond the "splitting" phenomenon.
\end{referee}
We are thankful for the comment. The splitting also happens in the former X-cube, but it was not identified in the previous work. The key difference is the rewinding of the measurement schedule, which in turn avoids getting stacks of toric code as ISG; in fact, each of our ISG is a nontrivial fracton order. To clarify the point about splitting, we have added the following sentences. 

\begin{quote}\color{arpit}
  We note that such splitting of topological order also happens in the (non-rewinding) X-cube Floquet of Ref.~\cite{XcubeFloquet2022}, however it was not identified in that work.   
\end{quote}

\begin{referee}
p. 15, left In the introductory paragraph of Sec. VI, two consecutive sentences start with "This". Moreover,
the second sentence uses the term "only encodes[...]". I assume, the authors implicitly make the
comparison to a "static", stabilizer, 3D Toric Code. I think both points can be addressed by slightly changing
the end of the paragraph. 
\end{referee}
We thank the referee for this comment and have addressed it explicitly using the following modified sentences.

\begin{quote}\color{arpit}
    The construction is based on the 3D generalization of Kitaev's honeycomb model introduced in Ref.~\cite{Mandal2009}, which has a fixed point gapped Hamiltonian of the (static) 3D fTC, found in a particular limit of the parameters.
    Even though the 3D fTC encodes three logical qubits, our Floquet code with 3D fTC ISGs only encodes a single logical qubit on a system with periodic boundary conditions due to inadvertently measuring a subset of the logical operators.
\end{quote}
\begin{referee}
p. 18, right The last paragraph of subsection 2. uses the term "surface code". I think to be in line with the
rest of the manuscript, to avoid confusion which model is referred to, I suggest to use the term toric code
here as well, possibly with an additional 2-3D prefix. 
\end{referee}
Since we used the phrase surface code before in the section with boundaries, we have now explicitly written in the brackets that we are referring to the toric code with boundaries as the surface code. 
\begin{referee}
Typos
p.2: In the last paragraph of Section I, Section IV is reference twice. The first should probably be II.
p.14, left The first paragraph ends with "[...] non-local stabilizers as shown in Fig. 14 [...]". I think it should
refer to Fig. 15.
\end{referee}
We thank the referee for mentioning these typos and have now corrected them. The full paragraph on page 2 now reads as follows:
\begin{quote}\color{arpit}
The paper is organized as follows. In Sec.~I, we state preliminary definitions, formalize the notion of rewinding measurement schedules, and state general properties of rewinding schedules -- such as trivial logical automorphisms after a measurement cycle. We also discuss the basic ideas behind interpreting Floquet codes as sequences of condensations in a parent stabilizer code and the evolution of checks associated with those condensations. In Sec.~II, we review the Floquet code of Ref.~\cite{Paetznick2023Performance}, referred to as the Floquet TC, and describe the rewinding schedule for the boundary construction using the evolution of checks.  
Sec.~III and Sec.~IV describe the constructions of the 3D Floquet TC and the 3D Floquet fTC, respectively. In Appendix.~A, we discuss the Floquet color codes with $\mathbb{Z}_3$ automorphism and trivial automorphisms, respectively. In Appendix~B, we discuss the counting of logical qubits in the 3D Floquet TC. In Appendix~C, we provide a description of a particular ISG of the X-cube Floquet code in terms of the effective qubits created by the checks. 
\end{quote}

% \ChangesMade{%
% \begin{itemize}
%     \item 
%     \item 
%     \item 
% \end{itemize}
% }

\section*{Report of Referee B}
\begin{referee}
The manuscript “Engineering Floquet codes by rewinding” details three
new Floquet codes: the 2D Floquet color code, the 3D Floquet toric
code, and the 3D Floquet fermionic toric code. The authors describe
rewinding, in which the sequence of measurements reverses in a period,
as a useful construct for engineering codes with a desired topological
order and for constructing boundaries for the codes. The latter claim
is somewhat undermined by the fact that the authors do not construct
boundaries for the 2D Floquet color code they propose. Overall, while
the technical content of the paper seems sound, we are not convinced
the paper meets PRX Quantum’s criteria of a remarkable step forward or
a high degree of innovation. We detail our concerns below.

The title and introduction of the paper appear to indicate that
rewinding will be presented as a central theme of the manuscript. As
the authors note, rewinding is not new to this paper, but was previously presented in Ref. 5 (Haah and Hastings) for constructing boundaries for the Honeycomb code. However, if the authors made a
strong case that they were extending the concept of rewinding and illustrating its generality, there could be an argument for the manuscript being published in PRX Quantum. We did not find this to be
the case as currently written – while each of the example codes discusses a rewinding schedule, this seems to be an afterthought for the 2D Floquet color code, and the paper seems to be missing a
discussion of using rewinding for constructing codes/boundaries more
generally. Without more emphasis on the general construct of rewinding, the main contribution of the paper seems to be the three
new codes. 
\end{referee}

We thank the referee for making this suggestion and considering publication in PRX Quantum if we sufficiently argue the generality of our results. Our utilization of rewinding goes beyond earlier works, which merely stated the sequence of steps without general insights. We use the condensation picture of Floquet codes for the evolution of condensation terms under the measurements. Firstly, we claim that for all our Floquet codes, we can construct a parent stabilizer code on which the measured checks can be thought of as condensation operators. The parent stabilizer code can be constructed by taking the stabilizers of the check group and adding commuting Pauli terms that are products of checks around closed loops. The condensation operators can sometimes evolve under the sequence of measurements, and we can use rewinding to control the growth of these condensation terms. We apply this understanding to our 3D examples of Floquet codes. In the specific codes we discussed, we show how the size of the condensation operators can determine the instantaneous stabilizer groups (ISGs), and thus, rewinding helps to achieve the desired ISGs. 

We have now added the following paragraph to the introduction which elucidates this.
\begin{quote}\color{arpit}
\textcolor{black}{An essential tool employed in our constructions is the concept of ``rewinding'' a measurement schedule, where at some point within a period, the sequence of measurements is reversed. A similar strategy was stated in Ref.~\cite{Haah2022boundarieshoneycomb} to adapt the honeycomb code to a system with boundary.} We adopt a physical description of rewinding in terms of the evolution of measured checks. Firstly, we claim that for every Floquet code discussed in our work, there is an associated nontrivial parent stabilizer code. We can consider the sequence of measurements in a Floquet code as performing a sequence of condensations on this parent stabilizer code. The operators associated with condensation in one step can sometimes survive as finite-weight stabilizers under subsequent measurements; this is the case we are interested in and we refer to this as the evolution of the condensation checks. Under rewinding, the evolution of condensation checks is reversed before all of them evolve into non-local stabilizers. In our examples of the 3D Floquet TC and X-cube Floquet code, the evolved condensation checks at each step determine the topological order of the instantaneous stabilizer groups (ISGs), and rewinding helps to achieve the desired ISGs by not evolving beyond a certain point and reversing the evolution. 
Sometimes, these non-local stabilizers can be the logical operators of the Floquet code, like in the case of the 2D Floquet TC on a planar layout, and in those cases, rewinding helps to avoid measuring logical information. Hence, our understanding of rewinding in terms of the evolution of condensation checks leads to a physical interpretation for the ISGs and boundaries of Floquet codes constructed using rewinding schedules, including the construction in Ref.~\cite{Haah2022boundarieshoneycomb}.  
Therefore, we argue that rewinding is beneficial for creating a desired set of ISGs on both toric and planar layouts. 
We expect the tools we explicitly utilized for our microscopic constructions of Floquet codes to be useful in the construction of a wider class of Floquet codes, including those with quantum low-density parity check (LDPC) codes as ISGs.\end{quote}

We also add the following subsection in Sec. II to describe the condensation in a parent stabilizer code and the evolution of checks. 
\begin{quote}\color{arpit}
\subsection*{Condensation in a parent stabilizer code 
and the evolution of checks}
\label{subsec:condensation}
The measurements in the Floquet codes discussed in our work can be interpreted as a sequence of condensations in a parent stabilizer code. Let us first clarify what is meant by condensation. If we start with a topologically ordered state, condensing a nontrivial topological excitation means that those excitations are proliferated and can now be created without any energetic cost. In other words, the resulting ground state involves a superposition of the presence and absence of that excitation in any location. 
One way to implement this condensation in the Hamiltonian picture is to add the creation operator of the excitation as a term in the Hamiltonian and tune its strength to a large relative value. In scenarios involving measurements such as Floquet codes, this condensation can be performed by measuring the creation operator of the excitation, which, in turn, adds it to the stabilizer group of the instantaneous state.  

We claim that for all the Floquet codes discussed in this work\footnote{For the 3D Floquet fTC, we state the rewinding schedule without relying on a condensation picture, even though we do not see any obstruction in constructing a parent stabilizer code using the above-mentioned definition. This is because our construction of 3D Floquet fTC generalizes the construction of the 2D Floquet TC to a trivalent lattice in three dimensions.}, a parent stabilizer code can be constructed by taking the stabilizers of the associated check group and adding in a maximal set of commuting local Pauli terms, that are products of ISG checks around closed loops. For the 2D Floquet TC, previous work has shown that the color code can be interpreted as a parent stabilizer code~\cite{Kesselring2022condensation}, and it can be derived using this constructive definition. In Appendix~A, in which we construct the Floquet color code, we explicitly construct the parent stabilizer code by taking the stabilizers of the check group and closed loops of checks measured in the three rounds. For the 3D Floquet TC and the X-cube Floquet code, the construction involves coupling layers of 2D Floquet TCs. Even though the layers are coupled, we can form a maximal set of local commuting terms to consist of products of checks around closed loops within 2D layers; the resulting parent stabilizer code for both 3D Floquet TC and the X-cube Floquet code is simply stacks of color codes, as one might intuitively expect for the coupled layer construction. This is described explicitly in Sec IV B.2.

We now discuss how the checks evolve under a sequence of measurements.
The evolution of an element of an ISG depends on whether it commutes with the checks in the subsequent round of measurements. In the 2D Floquet TC, any element in the current ISG that commutes with all of the checks measured in the subsequent round is a (static) stabilizer of the check group of the Floquet code; there are no products of checks, except stabilizers of the check group, in the current ISG that survive into the subsequent round as stabilizers. 
In the 3D Floquet TC, this is not the case. 
There are checks whose products are not stabilizers of the full check group and still survive as stabilizers into the next round because they commute with all of the checks of that next round. These checks are associated with condensation of nontrivial excitation across orthogonal layers in the ISG of a stack of 2D toric codes. In general, it is the checks that condense an excitation of the ISG and not just that of the parent stabilizer code, whose products we expect to survive into subsequent rounds. Note that from here on, we will refer to these checks as the condensation checks\footnote{even though all checks can be interpreted as performing condensations in a parent stabilizer code} below, and they are said to evolve into bigger condensation checks under subsequent rounds of measurements. In subsequent rounds of the 3D Floquet code, this growth of condensation checks can keep happening until \textit{all} of them become non-local stabilizers. In order to obtain a desired ISG, we utilize rewinding to avoid this situation, i.e., we reverse the evolution before \textit{all} condensation checks evolve into non-local stabilizers. 
There is a physical explanation of the evolution of condensation checks in terms of the topological data of the parent stabilizer code. We provide this explanation for the 3D Floquet TC in Sec. IV B.2.
\end{quote}


Besides this, we have added a section on interpreting the rewinding schedule of the 2D Floquet toric code of Ref.~\cite{Paetznick2023Performance} in terms of the evolution of the condensation operators at the boundary. This makes it explicit that the boundary condensation operators evolve into a non-local operator that is a logical operator supported at the boundary under the 3-round schedule and that using rewinding, one can avoid this evolution of constant-weight condensation operators into non-local logical operators. This section is as follows:

\begin{quote}\color{arpit}
We note that on a torus, we could also just use the 3-round sequence GBR instead of the 6-round rewinding sequence GBRBGR. However, the 3-round sequence does not work for 2D Floquet TC on a planar layout. Below, we discuss the 3-round sequence does not work for the planar layout, using the evolution of condensation checks at the boundary. 
\subsection{Rewinding Boundary for 2D Flouqet TC: evolution of condensation checks}
Let us consider how to create a boundary of the 2D TC using condensation checks. In order to create the $e$-boundary, we first note that the $e$-excitations (violations of vertex $X$ stabilizers) are created by single qubit Pauli $Z$ operators. To define the boundary, we add these single-qubit Pauli $Z$ stabilizers at the boundary to the stabilizer group. Due to this, the $X$ stabilizers at the boundary are no longer in the stabilizer group, and the four-qubit $Z$ stabilizer generators can be broken down into two-qubit Pauli $Z$ stabilizers. Similarly, we can define the $m$-boundary. 

Now, for the 2D Floquet TC, each ISG is a TC on an effective lattice, and for one of the ISGs, we have the effective terms (Pauli $Z$ operators on the effective qubits) at the boundary as defined above. Under subsequent rounds, the condensation checks at the boundary evolve into larger-weight operators. As long as these boundary condensation checks are constant weight, they condense either the $e$ or $m$ bulk excitation at the boundary. In particular, we consider a truncation through green checks for the 3-round schedule. In this case, after a full cycle GBR, if we measure G-checks again, the condensation checks would evolve into a non-local operator that is a logical operator of the ISG. The evolution of the boundary condensation checks in the 3-round RGB schedule is shown in Fig.~3. To not measure the logical information, instead of following up with G after the GBR part of the schedule, a rewinding schedule GBRBGR is used instead. This ensures that after the R-round, we reverse back to the B-round and G-round with constant weight condensation checks.  
In Fig.~3, we illustrate the boundary for the case of the rewinding schedule GBRBGR. In this case, no logical information is measured, and we get the desired ISGs. 
\end{quote}

Please see the manuscript for the added figure. 

Lastly, we add the following subsection in Sec. III, which explains the evolution of condensation checks in the 3D Floquet toric code using the topological data of the parent stabilizer code that is the stack of 2D color codes.
\begin{quote}\color{arpit}
\subsubsection*{Evolution of condensation checks using topological data of the parent stabilizer code}
\label{sec:condensation_3DFloquet_TC}
As mentioned in Sec.~II.C, the reason for the growth of condensation checks is that after their measurements, the next round of checks may only commute with certain products of the condensation checks. It is these products of condensation checks that survive as stabilizers into the next round. Rewinding helps to ensure that not all condensation checks evolve into non-local stabilizers. In the case of the 3D Floquet TC, if all condensation checks become non-local, we obtain an ISG that is FDQC-equivalent to a 3-foliated stack of 2D TCs. Hence, rewinding helps to avoid this ISG, and instead, we obtain 3D TC(s) as ISGs. We now discuss how the evolution of condensation checks can be described using the braiding and fusion data of the excitations in the parent stabilizer code of the 3D Floquet code, i.e., stacks of 2D color codes. 

We first state why a stack of color codes is the parent stabilizer code for the 3D Floquet TC. Invoking our construction from Sec.~II.C, we can consider products of checks around closed loops that commute with each other and the stabilizers of the check group shown in Fig.~7. The product of green checks around each octagon, products of blue checks around each octagon, products of red checks around each octagon, and products of red checks around each square form closed-loop stabilizers that, along with the stabilizers of the full check group of Fig. 7, form the stabilizer generators of a parent stabilizer code. This code is FDQC-equivalent to a 3-foliated stack of 2D color codes. This is also what one may intuitively expect given that the parent stabilizer code for the 2D Floquet code is the color code~\cite{Kesselring2022condensation} and we use a coupled layer construction involving a stack of 2D Floquet codes to get the 3D Floquet code. 

Using the notation of Ref.~\cite{Kesselring2022condensation} for the anyons of the color code, the measurements of the 2D Floquet code correspond to condensing the anyons $rX$, $gY$ and $bZ$ in order. After each condensation, we obtain 2D TC ISGs and transition between them without loss of logical information. The deconfined and confined anyons for the steps when $gY$ and $bZ$ anyons are condensed are shown at the top in Fig. 13.  

In the 3D Floquet code, if we ignore the interlayer measurements that condense pairs of $e$-anyons, only the $rX$-$gY$-$bZ$ sequence of condensations would be performed in each color code layer of the parent code. To be consistent with our Pauli notation used for the 3D Floquet code, consider that we do the interlayer pair condensation across orthogonal color code layers along with the $gY$ condensation. 
In the round of $gY$ condensation, it is $gX\equiv gZ$ and $rY\equiv bZ$ that form the $e$ and $m$ anyons of the 2D TC ISG, respectively. This is illustrated in the table on the top left of Fig.~13. The condensation operator is a two-qubit Pauli $YY$ operator, as shown in in Fig.~13. In the parent code of stack of 2D color codes, the Pauli $Y$ operators act on orthogonal color code layers. Application of a single $Y$ operator in one color code layer creates $rY$, $gY$ and $bY$ anyons. However, because $gY$ is already condensed, meaning it is equivalent to vacuum $\mathbf{1}$, $gY\equiv \mathbf{1}$, we are left with $rY$ and $bY$, which are equivalent and correspond to the $e$-anyons as mentioned. This is illustrated in the figure at the bottom left of Fig.~13. Thus, the two-qubit Pauli $Y$ condensation operator creates two pairs of $e$ anyons, one pair in each of the orthogonal color code layers. 

In the following round, $bZ$ is condensed, and thus, $rY$ and $gY$ are confined. Thus, we can no longer use the equivalences $gY\equiv 1$ and $rY\equiv bY$. Moreover, $bY\equiv bX$ and $rZ\equiv gZ$ are the deconfined anyons, and we choose to label $bY\equiv bX$ as the $e$-anyon. This is illustrated in the table on the top right of Fig.~13. The confined excitations $rY$ and $gY$ need to be canceled out to find an evolved condensation check. This is possible if we take the 
product of two pair condensation checks (the two-qubit Pauli $Y$ operator across orthogonal layers) and the condensation operator for $gY$ (the green checks). This product cancels out the confined excitations $gY$ and $rY$ and creates two pairs of $bY$ on orthogonal color code layers. This is illustrated in the figure at the bottom right of Fig.~13. Thus, again, we have a pair of $e$-anyons that are condensed across orthogonal layers. The requirement of the cancelation of the confined excitations serves as an alternate physical explanation for the evolution of condensation checks into bigger condensation checks. Moreover, there are two inequivalent flavors of such composites corresponding to the two sublattices and hence, the B-ISG is FDQC-equivalent to two copies of 3D TC, as described microscopically earlier. This is up to the caveat that a non-local stabilizer fixes the state of the two copies of 3D TC such that only one logical qubit remains. A similar description in terms of condensation holds for the R-ISGs.   
\end{quote}
Please see the manuscript for the added figure. 

We have also moved the Floquet color code to the appendix because the referee has correctly noted that our key examples, where the physical understanding of rewinding in the condensation picture is applied in this work, are the 3D Floquet codes. 
However, we conjecture that our explicit presentation of the parent stabilizer code of the Floquet color code and understanding of rewinding in terms of the condensation picture are helpful for the Floquet color code and its boundaries. We note that using truncation of the lattice similar to the 2D Floquet toric code and rewinding, we are able to construct boundaries for the Floquet color code. We did not cover this in our paper and left them for a future paper because our goal was to construct boundaries in such a way that one of the ISGs is equivalent to the color code on a triangular geometry that allows for transversal Clifford gates and we were not able to achieve that particular feature in our construction of the Floquet color code boundaries.  

We have now added the following modified sentences to the manuscript with regards to the above. 
\begin{quote}\color{arpit}
% The reason we mention these Floquet color codes in this paper is that our understanding of the corresponding measurement schedules in terms of the evolution of condensation operators acting on a parent stabilizer code can be helpful to understand the order three and trivial automorphisms that we demonstrate. We write the parent stabilizer code on which the action of the condensation operators can be considered to yield the ISGs. We believe this picture of evolving condensation operators is also useful to construct desired ISGs in the case with the boundaries; we do not work the boundaries out but conjecture that they could be constructed with rewinding schedules.
Besides the above-mentioned 3D examples, we also construct a new 2D Floquet code for which we expect rewinding and the interpretation of condensation in a parent stabilizer code to be useful. In Appendix A, we construct the 2D Floquet color code, which exhibits ISGs that are FDLQC-equivalent to the 2D color code. This should not be confused with the CSS honeycomb code of Refs.~\cite{Davydova2022,Kesselring2022condensation,bombin2023unifying}, which also has been referred to as the Floquet color code in Ref.~\cite{Kesselring2022condensation}\footnote{In contrast to our Floquet color code, the ISGs of the CSS honeycomb code are FDLQC-equivalent to the 2D TC.}. We consider two different measurement schedules for the Floquet color code. The first exhibits an order three automorphism of the logical operators, while the second is a rewound version with a trivial automorphism. Notably, one of the ISGs is equivalent to the conventional color code up to concatenation with a 3-qubit repetition code -- thus allowing for the transversal implementation of certain logical Clifford gates. The rewound version is expected to yield gapped boundaries by truncating the checks at the boundaries; however, we were not able to construct boundary conditions that maintain the transversality of the above-mentioned logical Clifford gates. We also explicitly write the parent stabilizer code of the Floquet color code, which is FDQC-equivalent to two copies of the 2D color code. 
\end{quote}

and later in the text,

\begin{quote}\color{arpit}
    In Appendix~A, in which we construct the Floquet color code, we explicitly construct the parent stabilizer code by taking the stabilizers of the check group and closed loops of checks measured in the three rounds. 
\end{quote}

\begin{referee}
While these are interesting and worth publishing, they do
not particularly stand out among other new Floquet codes (e.g. Ref 6
and arXiv:2308.03750). For the new example codes to merit publishing
in PRX Quantum, we believe a stronger case would need to be made for
why they have particularly favorable attributes.
\end{referee}
As discussed above, we believe the tools used in these higher-dimensional constructions, in particular the explicit microscopic description of condensation picture and utilization of rewinding in terms of that for achieving desired ISGs on both toric and planar layouts, apply generally and would be relevant for the construction of Floquet codes for more general classes of codes including those with LDPC codes as ISGs. We have now highlighted our observation that all our Floquet codes can be considered as a sequence of condensations in a parent stabilizer code and that one needs to consider the evolution of the condensation operators as one chooses a sequence of measurements. We expect this idea not to be limited to the various examples we have presented in the paper and to apply more generally.
Secondly, we argue that our constructions are among the first explicit/microscopic Floquet code constructions in 3D (along with Ref.~\cite{davydova2023quantum} which appeared around the same time) for 3D stabilizer codes such as 3D toric codes, which are known to have advantages for error correction and computation.

\begin{referee}
- The figure captions are not stand alone as currently written- e.g.
Fig. 1 does not explain the difference between lower case and upper
case letters in (a). 
\end{referee}
We thank the referee and note that the caption of Fig. 1 explained the lower case and upper case labels, i.e., the labels x, y, and z are used for the edges corresponding to the XX, YY, and ZZ check operators, respectively. To be explicit, we have now added a sentence (highlighted in green below) in the caption such that it reads as follows
\begin{quote}\color{Blue}
     The ruby lattice on which the Floquet color code is defined. \textcolor{arpit}{Uppercase letters, $X$, $Y$ and $Z$ denote Pauli operators.} The edges of the hexagon are labeled as $x$ and $y$, which correspond to the $XX$ and $YY$ check operators. All the edges connecting different colored hexagons are labeled as $z$ corresponding to a $ZZ$ check operator.
\end{quote}

\begin{referee}
    (In the example of Fig 1 (a) there also seems to
be a mistake: around the rightmost green plaquette the operators
should be ZZZZZZ rather than YYYYYY.)
\end{referee}
We note that the choice of stabilizer generator on the right side is correct. It does not involve all the check operators on the inner hexagon. The $ZZZZZZ$ stabilizer is already chosen as a separate stabilizer generator, so if the inner hexagon piece of the concerned inflated hexagon stabilizer had $ZZZZZZ$ on it, one could keep the part of this stabilizer supported on the outer hexagon, by choosing a different basis. 

\begin{referee}
- The figure ordering seems strange, with for example Fig 10 being
referred to in the main text before Figs 8 and 9. (page 9).
\end{referee}
\begin{referee}
- Please define all acronyms and abbreviations when introduced -- e.g.
LGI on page 17 (Local Generating set above Intersection?) and ERG on
page 16.
\end{referee}
We thank the referee for the above two remarks. We have now rearranged the figures and addressed the LGI and ERG abbreviations.

\begin{referee}
- On page 14, the statement "grow into non-local stabilizers as shown
in Fig 14" could use some further explanation, it is not immediately
clear from the figure.
\end{referee}

We thank the referee and have now added the sentence (in green) to explicitly explain ``grow into non-local stabilizers as shown in Fig. 14''. 
\begin{quote}\color{arpit}
    \textcolor{Blue}{If we had used the schedule GBR, then the R-round would be followed by the G-round, and all the condensation operators would evolve into non-local stabilizers as shown in Fig.~14 and result in an ISG of a subspace of stacks of 2D TC.} This is because after a full cycle GBRG where no extra condensation operators are measured, the measurements of the local checks in the BRG part of the sequence (without the 2-qubit condensation operators) result in an ISG of stacks of toric code while the 2-qubit condensation operators measured in the first G-round evolve into logical operators of the stacks; this leads to an ISG that is a subspace of the stack of 2D toric codes.
\end{quote}

In summary, we thank the referee for their feedback and have made extensive changes to address their concerns. Please check the attached pdf of the manuscript with highlighted changes to see all the changes and new figures. 


\printbibliography
\end{document}

