%-------------------------------------------------------------------------------
\section{Implementation}
\label{sec:implementation}
%-------------------------------------------------------------------------------
We present a simple extension for any OIDC server to handle ICT Requests including a PoP for the verification of the Client's public key.
The implementation is available on GitHub\footnote{\url{https://github.com/oidc2/op-extension}}.
However, we recommend it only for testing purposes.

To request a token, a Client sends a Token Request to the so-called \texttt{/token} Endpoint of the OpenID Provider.
That is a special path in the URL of the OIDC server.
Moreover, there is also a \texttt{/userinfo} Endpoint that returns information about the user upon a Userinfo Request.

Many services are not directly reachable on the Internet but via a reverse proxy.
A reverse proxy is an HTTP server that resides in the same network as the server, terminates the TLS connection between client and server, and relays data to and from the application server from and to the client.

We propose the generic extension to an OIDC server in \fig{oidc2_implementation_architecture} so that the OIDC server can handle ICT Requests.
% Figure environment removed
We define a novel \texttt{/ict} Endpoint which runs as a microservice separately from the OIDC server.
The \texttt{/ict} Endpoint and the OIDC server operate behind a reverse proxy.
The reverse proxy forwards any conventional OIDC requests to the OIDC server and ICT Requests to the \texttt{/ict} Endpoint.

The \texttt{/ict} Endpoint expects an AT with Scopes for identity claims, e.g., \texttt{profile} for name and birth date, and a scoped context for end-to-end authentication, e.g., \texttt{e2e\_auth\_email} for the email context, in the ICT Request.
It extracts the AT, and includes it in a Userinfo Request to the OIDC server.
After reception of the user information, the \texttt{/ict} Endpoint checks whether the EU possesses the private key $K^-_C$ for the public key $K^+_C$ contained in the ICT request, which is explained later.
If the check was successful, the \texttt{/ict} Endpoint issues an ICT with appropriate information and signs it with the private key $K^-_{OP}$ of the OP.
Thus, $K^-_{OP}$ must be available to the \texttt{/ict} Endpoint.
This is a reason why we recommend this simple prototype only for testing purposes but not for production.
Finally, the \texttt{/ict} Endpoint returns the ICT to the Client.

To save communication overhead between the \texttt{/ict} Endpoint and the Client, we propose the following PoP.
The Client chooses a nonce, concatenates it with a timestamp, signs the concatenation with its private key $K^-_C$, and includes concatenation and signature in the ICT Request.
The \texttt{/ict} Endpoint verifies the signature with the public key $K^+_C$ and caches the nonce for 30 seconds.
To counter replay attacks, the \texttt{/ict} Endpoint accepts only ICT Requests with timestamps in the concatenation that deviate at most 15 seconds from its own time and whose nonce is not in the cache.
