%-------------------------------------------------------------------------------
\section{Related Technologies}
\label{sec:related_technologies}
%-------------------------------------------------------------------------------
% Überblick über diese Section:
We review related technologies for end-to-end authentication and compare them to OIDC².

% \subsection{Service Accounts}
% \label{sec:service_accounts}
% %-----------------------------------
% A service account is a service-specific account on the AS of the service provider.
% For authentication, the user logs in to this account either with his credentials or with his SSO identity.
% When communicating with another user, the identity of the user is presented to the other user as stored in the service account.
% Thus, the other user must trust the service provider to indicate the correct stored information.
% Moreover, the other user does not see how the user was authenticated.
% %
% He must also trust a potential SSO provider that it does not impersonate the user and that it thoroughly verified the user's identity when creating his account.
% The offered service may be useful in spite of the insufficient authentication possibilities.
% Therefore, adding an end-to-end authentication layer in user-to-user services may be helpful so that users can authenticate each other with mechanisms of their choice and trust.
% This is provided for selected services in \sect{applications} using OIDC².

% \vspace{-0.1cm}

% \subsection{Public Key Infrastructure (PKI) and S/MIME}
% \label{sec:pki}\label{sec:smime}
% %-----------------------------------
% In a public key infrastructure (PKI) \cite{Weise2001}, a certificate authority (CA) certifies that an entity's (E) real-world identity and long-term public key $K^+_E$ belong together.
% For this purpose, the CA verifies the entity's real-world identity and requires from the entity a proof of possession (PoP) of the private key $K^-_E$ that belongs to the public key $K^+_E$.
% This may be performed with the well-known challenge/response method \cite{Kushwaha2021}. 
% After verification, the CA signs the entity's real-world identifier and public key $K^+_E$ with its private key $K_{CA}^-$. 
% This signed long-term attestation is called a certificate.
% %
% The entity can present its certificate for authentication purposes.
% The authenticating third party must trust the certificate's issuer, the CA, and validate the certificate.
% That is, the certificate is valid (not yet expired) and the CA's signature on the certificate is correct for which the third party uses the CA's public key $K^+_{CA}$.
% Furthermore, the third party requires from the entity a PoP of the private key $K_E^-$ that belongs to the public key $K_E^+$ in the certificate.
% Again, challenge/response may be used.
% If any of the above mentioned checks fails, the authentication has failed.
% %
% X.509 (\rfc{5280}) is a common format for encoding certificates.
% It is mostly used for authenticating clients or servers in TLS connections by their domain names, or users in email communication with S/MIME (\rfc{8551}) by their name and email address.

% A PKI is considered heavy-weight.
% Certificates typically have a long validity.
% If the private key of a certificate is leaked, the certificate should be revoked.
% To that end, the PKI adds the certificate on its revocation list.
% Thus, to verify a certificate's validity, a third party also needs to check that the certificate is not on the PKI's revocation list.
% As this is a cumbersome process, it is often ignored, which may compromise security.

% Secure / Multipurpose Internet Mail Extensions (S/MIME) is a standard for PKI-based email authentication and encryption (\rfc{8551}) where senders of an email are authenticated with X.509 certificates (\rfc{5280}).
% To get such an X.509 S/MIME certificate, the user is authenticated by the CA, e.g., with his passport, to prove his name and sends an email to prove his email address.
% When sending emails with S/MIME, the certificate is attached to the email and the entire email is signed with the private key of the user.
% This signature protects the integrity of the email and the sending user is authenticated with his certificate.
% %
% Getting the X.509 certificate and installing it on all email clients is a cumbersome process with bad usability.
% Thus, only $2.50 \%$ of over $81$ million investigated emails \cite{Stransky2022} were signed with S/MIME.

% In OIDC², we use short-term certificates, which are issued after login.
% Therefore, we do not need revocation lists and also do not install long-term certificates on the clients which obsoletes key management.

% \vspace{-0.1cm}

% \subsection{Web of Trust (WoT) and PGP}
% \label{sec:wot}\label{sec:pgp}
% %-----------------------------------
% In the Web of Trust (WoT) \cite{Ulrich2011}, users meet in person and exchange their long-term public keys after verifying each other's identities.
% Those are trusted keys, which may be used for authentication purposes.
% For better usability, hashes of public keys, called fingerprints, may be exchanged instead of lengthy public keys themselves.

% Furthermore, a verifying user (VU) may verify another user's (U) real-world identity.
% Then, the VU signs U's verified real-world identifiers and long-term public key $K_U^+$ with his private key $K_{VU}^-$.
% This signed attestation is called a key signature.
% %
% U can pass the key signature to another authenticating user (AU) for authentication purposes.
% If the AU has already verified the user's identity, he authenticates the user by his public key fingerprint and a PoP of the related private key $K^-_U$.
% Otherwise, if the AU trusts the VU, the AU verifies the provided key signature with the VU's public key $K_{VU}^+$, and requires a PoP from the user.
% If both are successful, the AU has successfully authenticated the user based on the key signature; otherwise the key signature is rejected.

% Pretty Good Privacy (PGP) \rfc{4880} is a common standard for encoding keys and for signed or encrypted messages.
% It is mostly used for authenticating users in email communication.
% In addition, PGP makes use of community-based public key servers.
% A user can sign his public key $K^+_U$, name, and email address with his private key $K_U^-$ and publish it on a key server.
% Other users can then search for this signed identity information by his public key fingerprint.
% %
% Generating such a PGP key, publishing it to a key server, and exchanging the fingerprints is an elaborate process which leads to bad usability.
% This is probably the biggest reason why only $0.30 \%$ of over $81$ million investigated emails \cite{Stransky2022} were signed with PGP.

% In OIDC², users do not have to meet in person, and also do not need elaborate key management.

% \subsection{Confidante and Keybase}
% \label{sec:confidante}
% %-----------------------------------
% Confidante is a web-based mail client for Gmail \cite{gmail}.
% With Confidante \cite{Lerner2017}, a user generates a PGP key pair and uploads the private key $K^-_U$ encrypted with a passphrase to his protected account on the Keybase platform \cite{keybase}.
% For signing emails, the private key is downloaded and decrypted with the passphrase.
% Moreover, the public key $K^+_U$ is uploaded to a public key server on Keybase, together with a link to a set of posts in social media accounts of the user.
% These posts contain a PoP of the private key $K^-_U$.
% This PoP is some information about the user's social media account, signed with $K^-_U$.
% When receiving an email signed with Confidante, the web-based mail client extracts $K^+_U$ and looks up its entry on Keybase.
% It verifies the linked PoPs on the sender's social media accounts, and if successful, it presents to the receiving user these social media accounts as the identities of the sending user.
% %
% Confidante uses PGP but does not require complex key management.
% However, it requires that senders have a Keybase account and well-known social media accounts, that they have generated a PGP public/private key pair, uploaded it to Keybase, and posted appropriate PoPs on social media.
% This is a challenge for many users.
% Moreover, the receiving user must trust the sender's social media accounts.
% This is difficult when the receiver does not know the sender.

% With the OIDC² extension for email, as described in \sect{email}, a user can sign messages without any complex initial setup.
% Moreover, a user can authenticate yet unknown senders if he trusts their OpenID Providers. 

\subsection{Identity Providers and Certificates}
\label{sec:idp}
%-----------------------------------
% Einführung PKI, X.509, S/MIME und Nachteile:
In a Public Key Infrastructure (PKI) \cite{Weise2001}, a Certificate Authority (CA) verifies that an entity's real-world identity and long-term public key $K^+_E$ belong together, records them in a document, signs it, and issues it in the common X.509 certificate format (\rfc{5280}).
Such X.509 certificates are used e.g. in the Secure / Multipurpose Internet Mail Extensions (S/MIME) standard (\rfc{8551}) to authenticate and encrypt email.
However, due to the cumbersome identity verification and certificate installation process, only $2.50 \%$ of over $81$ million emails examined in a study \cite{Stransky2022} were signed with S/MIME.

% Einführung SAML2-basierter Cisco Draft:
To simplify this process, Cisco proposed an expired Internet draft \cite{I-D.biggs-acme-sso} where an Identity Provider (IdP) issues X.509 certificates to its users.
According to their white paper \cite{WebexWhitepaper}, Cisco uses these certificates for end-to-end user authentication in the Webex videoconferencing service.
If the session partner trusts the issuing IdP, the partner can authenticate the holder of this certificate, e.g., with a challenge/response method \cite{Kushwaha2021}.
The draft \cite{I-D.biggs-acme-sso} is designed for the SAML2 authentication standard \cite{saml2core}, but OIDC performs better for mobile devices and cloud computing \cite{Naik2016}.
This may be one reason why the design has not been adopted by other applications and IdPs.

% Abgrenzung von OIDC² zu Cisco draft:
Conceptually, the presented approach is similar to OIDC²; we continue with the differences.
X.509 is a binary format limited to a small set of standardized identity-related fields \cite{RFC8551}.
OIDC² instead uses JSON Web Tokens (JWT) in \rfc{7519} to represent claims about the user.
JWTs are more flexible because the IdP can provide any claims in a JSON object, many of which are already standardized in the OIDC core specification \cite{OidcCore} and eKYC \cite{OidcEkyc}.
JSON is also easier to parse in web applications than X.509 certificates.
Also, long-lived user certificates require more attention than short-lived ICTs.
In particular, certificate revocation lists must be managed and verified.
In addition, certificates may need to be installed on different devices, which adds overhead and can create security issues.

\subsection{Self-Sovereign Identity (SSI)}
\label{sec:ssi}
%-----------------------------------
% Einführung in SSI; Erklärung der Verwendung und Speicherung von public/private key:
In Self-Sovereign Identity (SSI) \cite{Muehle2018}, participating entities generate their own asymmetric key pairs $K^\pm$.
Entities are identified by by their decentralized identifier ${DID}$, which is linked to at least one public key $K^+$.
Entities store their private key $K^-$ in their digital wallet, e.g. an app on their smartphone.
This can be used for end-to-end authentication with the key pair $K^\pm$.

% Begriffsdefinition Holder, Issuer, Verifier, Verifiable Credential, Verifiable Presentation:
SSI describes three entities: the Issuer (I), the Holder (H), and the Verifier (V).
The issuer knows or verifies the credentials of the holder and issues them to the holder as a Verifiable Credential (VC).
This VC is signed by the issuer with his private key $K^-_I$; it contains the issuer's ${DID}_I$ and the credentials and ${DID}_H$ of the holder.
The holder holds this VC in his wallet and presents it to a verifier as a Verifiable Presentation (VP).
This VP is signed by the holder with his private key $K^-_H$; it contains the VC and the verifier's ${DID}_V$.
The verifier verifies this VP by checking the issuer's signature on the VP and the issuer's signature on the VC.
If the verifier accepts the issuer as a trusted authority for issuing the holder's credentials, then the verifier trusts that these credentials belong to the holder.

% Implementierungen mit Blockchain und OIDC; Beispiel US Mobile Driving License:
Early implementations of SSI made use of blockchain technology \cite{Ferdous2019} and used a public distributed ledger \cite{Ioini2018} to store the mapping of a ${DID}$ to its associated public keys.
Modern approaches are based on OAuth 2.0 and OpenID Connect, such as the mobile driving license in the United States standardized in ISO/IEC 18013-5:2021 \cite{ISO18013-5}.
This approach implements the Self-Issued OpenID Provider v2 (SIOPv2) \cite{siopv2} draft in the wallet app for key management.
Driving license offices provide OAuth 2.0 based interfaces defined in the OpenID for Verifiable Credential Issuance (OpenID4VCI) draft \cite{openid4vci} to issue driving licenses as VCs in the W3C format \cite{w3cVc}.
Drivers present these VCs as VPs to police officers using OAuth 2.0 based interfaces between smartphones defined in the OpenID for Verifiable Presentations (OpenID4VP) draft \cite{openid4vp}.
Another OIDC draft describes the issuance of identity claims of the ID Token as a VC \cite{userinfoVc}.
This is similar to our approach, but requires the full OpenID4VC infrastructure to be deployed, which is currently rare.

% Probleme an SSI Lösungen: Long-term keys, die revokierbar sein müssen oder nicht übertragen werden können.
Although SSI is now being rolled out for government use cases, there are still open issues regarding usability \cite{Sartor2022}\cite{Zaeem2021} and identity recovery \cite{Zhou2019}.
Since the private key is a long-term key that could be leaked during its lifetime, the system requires a key revocation list.
But as argued by Ronald L. Rivest more htan two decades ago \cite{Rivest1998}, revocation lists should be avoided for security reasons.
Modern technologies such as Hardware Security Modules (HSM) or Trusted Platform Modules (TPM) address this problem by protecting the private key inside the hardware.
Here, the private key cannot be exported and can only be used for signing after the platform integrity has been verified and the user has been authenticated.
This creates problems when a user wants to use VCs from other devices.
In addition, if the device is lost or broken, the user needs a recovery method for the private key and DID that must be configured in advance.

% Was OIDC² besser macht:
OIDC² does not have these problems.
It uses short-lived ephemeral key pairs and ICTs, requires no specific hardware or software platform, and leverages existing account recovery capabilities.
Compared to SSI approaches, it does not require currently rarely deployed frameworks such as installed wallet apps, issued VCs, and a huge amount of implemented new standards.
Instead, OIDC² requires a small extension of OPs to use existing OIDC accounts.
% All it takes is an existing OIDC-based user account and implemented OAuth 2 and OIDC features plus our tiny extension.
In contrast, the ICT may also contain claims that the issuing OP is not a trusted source of, which will be discovered in \sect{trust_relationship}.

\subsection{OpenPubkey}
% Vorstellung von OpenPubkey:
BastionZero has developed OpenPubkey \cite{openpubkey} which is very similar to OIDC².
The RP of an EU can create a Client Instance Claim (CIC) that contains, among others, the RP's public key $K^+_C$.
When requesting an ID Token (see \fig{oidc_authentication_flow}), the RP can optionally provide a nonce in the Authentication Request (1), which we omitted in \sect{oidc}.
The OP will then insert this nonce into the ID Token before issuing it (4).
With OpenPubkey, the RP offers its hashed CIC as a nonce to be inserted into the ID Token.
After receiving the ID Token, the RP appends the CIC and signs it with its private key $K^-_C$, resulting in a PubKey (PK) Token.
The RP can use this PK Token to authenticate as the EU.

However, from our point of view, this approach makes the whole OIDC ecosystem insecure.
In an SSO context, the RP is often a login service (see the AS in \fig{oidc_sso}) that the EU usually authorizes to access his profile information.
If the service is malicious, the RP can request a PK Token with its own public key $K^+_C$ to impersonate the EU without his knowledge.
The authors' solution to this problem is to have the authenticating user only accept e2e authentications from a trusted RP, identified by its Client ID contained in the PK Token.
First, this leaves a high burden on the user, which is unacceptable since it is difficult for the user to identify trusted RPs.
Second, the EU's trust in a service, such as an online store, may be sufficient to be authenticated by that store, but it may not be sufficient to allow the store to impersonate him.
Third, in open communication systems such as email, there are many clients, and it is unlikely that all of them are trusted.
This limits the use of OpenPubkey to a small set of explicitly trusted services and clients.
We believe that these three problems are unacceptable.
In contrast, with OIDC², the EU does not risk being impersonated when logging in to a malicious service.

% We describe their solution using \fig{oidc_authentication_flow}.
% The RP can optionally provide a nonce in the Authentication Request (1), which we omitted in \sect{oidc}.
% The OP will then insert the provided nonce into the ID Token before issuing it (4).
% With OpenPubkey, the RP uses this mechanism to insert its hashed Client Instance Claim (CIC) into the ID Token, which contains its public key $K^+_C$.
% By appending the CIC to the ID Token and signing it with the private key $K^-_C$, the RP obtains a PK Token, which it uses to authenticate e2e as the EU.

% As specified in OIDC \cite{OidcCore}, the OP inserts this nonce unchanged into the ID Token, signs it with its private key $K^+_{OP}$, and issues it to the Client.
% In order to commit to this ID Token and to prove possession of the corresponding private key $K^-_C$, the Client appends its own signature, which makes it a PK Token.
% The advantage here is that this PK Token can be used for e2e authentication, and its issuance does not require any changes to the OP's implementation.

% Erklärung anhand von fig. 2a
% Im ID TOken ist Nonce die von RP vorgegeben wird, was in sec 2 unterschlagen wurde
% RP gibt Nonce vor und OP fügt nonce in id token aus
% Benutzer kann dieses id token signieren und sich damit gegenüber eine 3rd party ausweisen, ähnlich wie mit ICT.

% Schwachstelle an diesem Approach ist, dass auch andere RPs ID Token mti eigenem Public Key als Nonce vorgeben können und sich somit den end-user e2e impersonieren können
% Was an OpenPubkey unschön ist:
% We also considered this approach, but rejected it for the following reasons.
% The ID Token is designed to authenticate the user to the Relying Party via the OP.
% Passing it to other users for e2e authentication raises privacy issues by exposing potentially private claims.
% Furthermore, injecting a meaningful hash as a meaningless nonce is a hacky solution that causes problems when combined with other technologies that also use this trick to inject information into the ID Token.
% Was an OpenPubkey fatal ist:
% In addition, the Client uses the PK Token for e2e authentication without being authorized to do so, so any Client or Relying Party (RP) requesting an ID Token can create it.
% For example, a news site where users log in through an OP can request the user's name for their news forum profile.
% Since the CIC hash is indistinguishable from a normal nonce, the user will not notice this injection during the Authentication Request to the news site's RP.
% The End-User (EU) authorizes the RP to obtain their profile information in an ID Token for legitimate reasons.
% The RP can then turn the ID Token into a PK Token, since it owns the key pair $K^\pm_C$, and use the PK Token to impersonate the EU e2e to other users.

% The misconception here is that whenever the EU authorizes an RP to access his profile information, that RP can impersonate the EU.
% For example, news sites where the EU logs in with his SSO identity can abuse this to impersonate the user without his knowledge.
% Therefore, we believe this solution is not secure enough.
% % Wie die Autoren versuchen es zu fixen:
% The authors think that checking the RP's Client ID in the \texttt{aud} claim and only accepting trusted ones might suffice.
% However, in open communication systems like email, this requires every email client to explicitly trust every other existing email Client.
% The authors also propose a third-party server, called an MFA cosigner, to certify that the RP possesses the private key, making the PK Token more trustworthy.
% However, since the RP owns the private key, it will pass this challenge.

% Was OIDC² besser macht:
OIDC² solves this problem by introducing a new ID Certification Token (ICT) that can only be requested by an RP with sufficient scope for e2e authentication.
This means that an EU can control whether to issue only an ID Token or also an ICT.


% We solve this by requiring the EU to explicitly authorize the RP for e2e authentication.
% If so, the OP verifies that the RP possesses the private key $K^-_C$ and issues the Identity Certification Token (ICT) explicitly designed for e2e authentication.
% This ICT contains a specific authentication context, e.g. email, which must be approved by the EU.
% This increases transparency for the EU and gives him full control over whether and in which context his RP can authenticate with his claims.


%       - Dem Benutzer die Client ID als Absicherung anzuzeigen ist auch nicht zielführend, da dies beispielsweise bei Google einen zufallsgenerierter String enthält. Beispiel Thunderbird: 406964657835-aq8lmia8j95dhl1a2bvharmfk3t1hgqj.apps.googleusercontent.com
