%-------------------------------------------------------------------------------
\section{Evaluation}
\label{sec:evaluation}
%-------------------------------------------------------------------------------
We evaluate the performance of the provided \texttt{/ict} Endpoint, written in Go, compared to the \texttt{/token} Endpoint of the Keycloak~22.0.1 and Authentik~2023.6.1 OIDC server software.
They are written in Java and Go, respectively.

We conduct the following two experiments.
(A) A Client sends a Refresh Token to the \texttt{/token} Endpoint of the OIDC server and obtains an ID Token, an RT, and an AT.
(B) A Client generates a PoP, sends an AT to the new \texttt{/ict} Endpoint, and obtains an ICT.
Both experiments are conducted over one minute, i.e., a token is requested, returned, and then the next request is sent.
We ran each experiment 20 times and computed mean requests per minute including confidence intervals with a confidence level of 95\% (${CI}_{0.95}$) using the Student's t-distribution.
We automate this process with the help of a web application\footnote{The application is programmed in Angular~15 and its code is available on GitHub \url{https://github.com/oidc2/benchmark}}. 

The OIDC server, its user database based on PostgreSQL~15.2, and the new \texttt{/ict} Endpoint run in separate Docker containers\footnote{\url{https://github.com/oidc2/op-extension/blob/main/docker-compose.yaml}}.
The host is a Lenovo ThinkPad T14s with an 2.1 GHz AMD Ryzen 5 PRO 4650U processor, 16 GB RAM, and a 512 GB SSD with Windows~11 22H2 x64, and running the Docker engine\footnote{\url{https://www.docker.com/}}~24.0.2 in WSL~2\footnote{\url{https://learn.microsoft.com/en-us/windows/wsl/}}.
While Authentik can import and export any private keys, Keycloak cannot export private keys and it can import only RSA keys.
Therefore, we chose RS256 for signatures, i.e., a 2048 bit RSA key with the SHA-256 hashing algorithm to make experiments with different server software comparable.

With Keycloak, a mean request rate of 994.00 IDTs (A) (${CI}_{0.95}$: [992.97; 995.03]) and 988.20 ICTs (B) (${CI}_{0.95}$: [986.72; 989.68]) could be served per minute\footnote{The values per experiment run are available here: \url{https://github.com/oidc2/benchmark/blob/main/results}.}.
In contrast, with Authentik, 190.95 IDTs (A) (${CI}_{0.95}$: [190.35; 191.35]) and 891.65 ICTs (B) (${CI}_{0.95}$: [886.04; 897.26]) could be served per minute.
Thus, the tested version of Keycloak is more efficient than the tested version of Authentik.
Moreover, the provided \texttt{/ict} Endpoint is as efficient as the built-in \texttt{/token} Endpoint or even more efficient.

We compare the work done by the \texttt{/token} Endpoint and the \texttt{/ict} Endpoint. 
%
(A) The \texttt{/token} Endpoint validates the RT, creates an IDT, and signs the AT and the IDT with its private key.
The integrity of the RT is secured differently\footnote{Authentik uses a nonce for the RT stored in the database while Keycloak secures the RT with an HMAC.}.
%
(B) The \texttt{/ict} Endpoint validates the PoP for the Client's public key, and requests user information using an AT from the \texttt{/userinfo} Endpoint, which validates the AT.
Then the \texttt{/ict} Endpoint creates and signs the ICT.

The effort for creating and signing an IDT in (A) and an ICT in (B) is possibly similar, as both require RT/AT validation, a database request, and a token signature.
Thus, creating an RT and AT, and signing the AT in (A) is apparently equal or more time consuming than creating the PoP at the Client and validating the PoP at the \texttt{/ict} Endpoint in (B).
