%-------------------------------------------------------------------------------
% \vspace{-0.4cm}
\section{Implementation}
\label{sec:implementation}
% \vspace{-0.2cm}
%-------------------------------------------------------------------------------
We present a simple extension for any \ac{oidc} server to handle \ac{ict} Requests including a \ac{pop} for the verification of the Client's public key.
The implementation is available on GitHub\footnote{\url{https://github.com/oidc2/op-extension}}.
However, we recommend it only for testing purposes.

To request a token, a Client sends a Token Request to the so-called \texttt{/token} Endpoint of the \ac{op}.
That is a special path in the URL of the \ac{oidc} server.
Moreover, there is also a \texttt{/userinfo} Endpoint that returns information about the user upon a Userinfo Request.

Many services are not directly reachable on the Internet but via a reverse proxy.
A reverse proxy is an \ac{http} server that resides in the same network as the server, terminates the TLS connection between client and server, and relays data to and from the application server from and to the client.

We propose the generic extension to an \ac{oidc} server in \fig{oidc2_implementation_architecture} so that the \ac{oidc} server can handle \ac{ict} Requests.
% Figure environment removed
We define a novel \texttt{/ict} Endpoint which runs as a microservice separately from the \ac{oidc} server.
The \texttt{/ict} Endpoint and the \ac{oidc} server operate behind a reverse proxy.
The reverse proxy forwards any conventional \ac{oidc} requests to the \ac{oidc} server and \ac{ict} Requests to the \texttt{/ict} Endpoint.

The \texttt{/ict} Endpoint expects an \ac{at} with Scopes for identity claims, e.g., \texttt{profile} for name and birth date, and a scoped context for \ac{e2e} authentication, e.g., \texttt{e2e\_auth\_email} for the email context, in the \ac{ict} Request.
It extracts the \ac{at}, and includes it in a Userinfo Request to the \ac{oidc} server.
After \jp{receiving} user information, the \texttt{/ict} Endpoint checks whether the \ac{eu} possesses the private key $K^-_C$ for the public key $K^+_C$ contained in the \ac{ict} request, which is explained later.
If the check was successful, the \texttt{/ict} Endpoint issues an \ac{ict} with appropriate information and signs it with the private key $K^-_{\ac{op}}$ of the \ac{op}.
Thus, $K^-_{\ac{op}}$ must be available to the \texttt{/ict} Endpoint.
This is a reason why we recommend this simple prototype only for testing purposes but not for production.
Finally, the \texttt{/ict} Endpoint returns the \ac{ict} to the Client.

To save communication overhead between the \texttt{/ict} Endpoint and the Client, we propose the following \ac{pop}.
The Client chooses a nonce, concatenates it with a timestamp, signs the concatenation with its private key $K^-_C$, and includes concatenation and signature in the \ac{ict} Request.
The \texttt{/ict} Endpoint verifies the signature with the public key $K^+_C$ and caches the nonce for 30 seconds.
To counter replay attacks, the \texttt{/ict} Endpoint accepts only \ac{ict} Requests with timestamps in the concatenation that deviate at most 15 seconds from its own time and whose nonce is not in the cache.
