\documentclass[11pt,twoside]{article}
\usepackage[english]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[top = 3cm ,bottom = 3cm,left= 3cm,right = 3cm]{geometry}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[all]{xy}
\usepackage{lipsum}
\usepackage{fancyhdr}

\usepackage{authblk}

\usepackage [
n,
advantage,
operators,
sets,
adversary,
landau,
probability,
notions,
logic,
ff,
mm,
primitives,
events,
complexity,
oracles,
asymptotics,
keys
]{cryptocode}
\createprocedureblock{game}{center,boxed}{}{}{}
\usepackage{lipsum}

\usepackage{float}
\floatstyle{ruled} % Defines the "rule" style for next environments defined using newfloat.
\newfloat{protocol}{htb!}{Protocol}

\usepackage{hyperref}
\usepackage{cleveref}
\crefname{protocol}{Protocol}{Protocols}
\Crefname{protocol}{Protocol}{Protocols}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE]{\title{Provably secure KEM-based protocols over unauthenticated channels}}
\fancyhead[LO]{\author{Rodrigo Martín Sánchez-Ledesma \textit{et al.}}}
\fancyfoot[C]{\thepage}

\setlength{\headheight}{13.59999pt}

\raggedbottom

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\title{Provably secure KEM-based protocols over unauthenticated channels}
\author[1,2]{\rm Rodrigo Martín Sánchez-Ledesma}
\author[2]{\rm David Domingo Martín}
\author[3]{\rm Iván Blanco Chacón}
\author[1]{Ignacio Luengo Velasco}
\affil[1]{Universidad Complutense de Madrid}
\affil[ ]{\texttt {\{rodrma01, iluengo\}@ucm.es}}
\affil[2]{Indra Sistemas de Comunicaciones Seguras S.A}
\affil[ ]{\texttt {\{rmsanchezledesma, ddomingo\}@indra.es}}
\affil[3]{Universidad de Alcalá}
\affil[ ]{\texttt {ivan.blancoc@uah.es}}
\date{December 2023}

\begin{document}

\maketitle
\textbf{Abstract:} In this paper we propose a number of KEM-based protocols to establish a shared secret between two parties, and study their resistance over unauthenticated channels. This means analyzing the security of the protocol itself, and its robustness against Man-in-the-Middle attacks. We do this by constructing a variation of known unauthenticated models that applies the techniques used to constructed the protocols, and formalize their security under this model. We compare them with their KEX-based counterparts to highlight the differences that arise naturally, due to the nature of KEM constructions, in terms of the protocol itself and the types of attacks that they are subject to. We provide practical go-to KEM-based protocols instances to migrate to, based on the conditions of currently-in-use KEX-based protocols.

\section{Introduction}

Secure key exchange protocols are a fundamental part of cryptography and perhaps one of the most important paradigms in asymmetric cryptography. This kind of protocols allows two parties without any previous common knowledge of any shared information to be in possession of a shared secret. This secret is then usually used to encrypt the information transmitted from one to another, by means of some symmetric encryption algorithm. It is therefore imperative for this kind of protocols to be secure and provide assurance that, at the end of it, the generated shared secret is only known by the two parties involved.

The paradigm of safely exchanging message over unreliable channel has been an object of study for a long time, by first trying to model the paradigm, and then coming up with solutions within this model. Among them, we highlight \cite{10.1007/3-540-44987-6_28,cryptoeprint:1998/009}, which provide a complete solution for modeling the differences between reliable (i.e. authenticated) and unreliable (i.e. unauthenticated) channels, and proving the security of protocols, which include key agreement protocols, in the latter, and how to construct them from protocols on the former.

Currently, secure key exchange protocols are mostly based on KEX-type solutions like Diffie-Hellman variants (DH, ECDH, ...) and similar algorithms. In the 90's, a series of quantum algorithms were published, including Shor's algorithm \cite{Shor_1997}, that were shown to effectively solve the mathematical problems behind most public-key cryptography algorithms, including those at the basis of current Diffie-Hellman instances, like the discrete logarithm problem or the factorization of integers problem. These critical findings, along with the practical advance on the development of quantum computers and the difficulty and cost of migrating schemes, forced the cryptography community to start finding alternatives that are resistant to quantum computing. In this scenario, in 2016, the National Institute for Standards and Technologies (NIST) announced the launch of a competition, with the objective of coming together with quantum-resistant cryptographic solutions for public-key cryptography needs, specifically suitable digital signature and key establishment. With regards to key establishment, the call specified that looked for Key Encapsulation Mechanisms specifications, which not only are efficient and versatile but also easy to derive from weaker Public Key Encryption algorithms, based on transformations such as Fujisaki-Okamoto and variants \cite{cryptoeprint:2017/604,cryptoeprint:2002/174}.

Based on the wide spread of KEX-based protocols, it is important that quantum-resistant Key Establishment schemes are as little disruptive as possible, to facilitate their adoption so that any information that is stored when quantum computers are available does not pose a threat.

\subsection{Our contributions}

Due to the concerns regarding 'quantum-resistant' cryptography, it is the objective of this work to come up with KEM-based protocols that are easy to adopt for solutions which already have in place a key establishment protocol based on quantum-compromised key exchange algorithms, while proving to be secure over unauthenticated channels, a necessary requirement in the vast majority of situations. This analysis include considering the plausible presence of Man-in-the-Middle attackers, whose aim is to eavesdrop the communication between the two parties, by means of modifying the messages exchanged during the key establishment protocol, in a way its presence goes unnoticed.

We first construct a variation of the AKE model presented on \cite{cryptoeprint:1998/009}, which varies the way authentication is achieved, reducing the number of public key operation needed to obtain it. This authentication will be obtained by a secure verification of tampering within the exchange produced, once it is finished. This measures are expected to be simpler and provide easier adoption in most communication protocols. Then, we show that all properties and results obtained under that model translates to our model, including those pertaining to key exchange protocols defined on \cite{10.1007/3-540-44987-6_28}. This model will be the base to generate and formally verify the protocols that will appear on this work.

Then, we analyze a number of KEX-based protocols for secure key establishment, breaking them by the number of messages exchanged. We show that applying the results from the modified AKE model, the protocols are shown to be secure under not reliable channels. Then we will analyze how the specific nature of Key Encapsulation Mechanism forces more difficulties in order to come with secure KEM-based key establishment protocols, and the measures needed to ensure their security. Lastly, we will specify a number of KEM-based protocols, using the same classification as above and their formal security under our new model.

Special focus will be put around the figure of a MitM: we will analyze the possibilities of such an attacker in KEX-based protocols and how to detect and avoid them, which will conform the base of the authentication measures of our model. Then we will see that the measures applied in this setting do not translate naturally to KEM-based protocols, under the same conditions, and the specific measures required to block this kind of attacks in KEM-based protocols, depending on the inherent conditions of the key encapsulation mechanism in use. Despite the conceptual differences between the two paradigms, the measures under which our model will base the security over unreliable channels will be the same: along with the primary objective, which is to derive a shared secret key, the protocol will also generate another output, which will be referred to as 'session entropy'. This value will conceptually be a summary of the session between the two parties, as it will be directly inferred by the shared values used throughout the process. This value is important as it will determine whether the session has been successful or it has been tampered.

\section{Preliminaries}

\textbf{Definition 2.1:}
A key encapsulation mechanism is a triple of algorithms KEM = (KGen, Encaps, Decaps). The key generation algorithm KGen generates a key pair $(\pk, \sk)$. The encapsulation algorithm Encaps, given a public key value $\pk$, outputs the pair (K, ct), where \textit{ct} is called the encapsulation of a random value \textit{x} that determines the shared key K, by means of an underlying PKE scheme. The deterministic decapsulation algorithm Decaps, given the secret key $\sk$ and the encapsulation, outputs the same key K by extracting the random value from the encapsulation \textit{ct}. \vspace{2mm} \\
\textbf{Definition 2.2:}
(Indistinguishability against KEM scheme) We define the IND-\textit{atk} game, $atk \in \{CPA, CCA\}$ as in the figure below and the IND-\textit{atk} advantage of an adversary \textbf{A} against the above KEM scheme as 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM}} := \abs{\prob{\texttt{IND-atk} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{$\indcpa^\adv(\secpar)$ $\pcbox{\indcca^\adv(\secpar)}$}{\phantomsection\label{kemgame}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) \sample \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}}(\pk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}

  {\procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\bot$} \\
        else \\
        \text{return \texttt{Decaps}(sk,ct)}
   }}
\end{pchstack}
\\
\textbf{Definition 2.3:}
A Commitment Scheme is a triple (Setup, Com, Open) such that:
\begin{itemize}
    \item $CK \sample \texttt{Setup}(\secparam)$ generates the public commitment context. It is often omitted mentioning the public context CK when clear.
    \item for any $ m \in M$, message space, $(c, d) \sample \texttt{Com}$($m$) is the commitment/opening pair for $m$. $c$ = $c(m)$ serves as the commitment value, and $d$ = $d(m)$ as the opening value.
    \item Open($c$, $d$) = $m'\in M \cup \{\bot\}$, where $\bot $ is returned if c is not a valid commitment to any message.
\end{itemize}
We define the hiding and binding games and advantages as follows:
\begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Hiding}{\phantomsection\label{Hiding}
      CK \sample \texttt{Setup}(\secparam) \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_b), d(x_b)) \sample \texttt{Com}(x_b)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
      {\procedure[linenumbering]{Binding}{\phantomsection\label{Binding}
      CK \sample \texttt{Setup}(\secparam) \\
      (c, d, d') \sample \adv (\secparam)  \\
      m = Open(c, d)  \\
      m' = Open(c, d')  \\
      \pcreturn (m \neq m') \wedge (m, m' \neq \bot)
    }}
\end{pchstack}
\begin{center}
    \begin{align*}
        \advantage{\texttt{Hiding}}{\texttt{CS}} := \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}} \leq \text{negl($\lambda)$} \\
        \advantage{\texttt{Binding}}{\texttt{CS}} := \prob{\texttt{Biding} \Rightarrow 1} 
        \leq \text{negl($\lambda)$} \\
    \end{align*}
\end{center}
Then, we define the central element of the authentication security of our model to give a proper definition for the element that will be used to detect session interference by an attacker, and that will be central to the authentication security of our model. \vspace{2mm} \\
\textbf{Definition 2.4: }
We define the \textit{entropy session} as a deterministic digest of shared elements involved within a protocol key establishment. Formally, 
\begin{align*}
    Entropy := G(A_1, ..., A_n)
\end{align*}
where $A_i$ , $i \in \{1, .., n\}$ are elements known to both parties at the end of the protocol session, and G is a pseudo random function. \vspace{2mm} \\
Within each protocol, the specific values that will conform this entropy session value will be established.

Due to common uses of this value, its size should be as small as possible, to facilitate usability. Nevertheless, the bigger this value is, the higher the protection it provides, as increases the computational complexity of the attacks against it.

\section{Authenticated Key Exchange model variation}

\subsection{BCK model}

The main dilemma that this work and others before try to deal with is the execution of communications or key exchange protocols over non reliable channels. Nowadays, this is the case for most communications and key exchange protocols. This means, they are carried on under channels where messages might not only be delayed or lost, but also actively modified or even completely substituted. Therefore, is it necessary to come with ways of ensuring that no message can be modified, that is, to provide assurance that what is received by a party is what the other party actually intended. Over key exchange protocols, this amounts to ensure that a safe and secret shared key has been established between parties, without any knowledge of it by any other party not intended.

Among the cryptographic literature pertaining to this problematic, the work of \cite{10.1007/3-540-44987-6_28} and \cite{cryptoeprint:1998/009} is highlighted. In it, a theoretic model of this situation is first described. Then, a number of techniques are defined to construct secure protocols, and formally prove their security under this model, over unauthenticated channels. \\
The way this is done is by defining first what is considered the \textit{Authenticated Model} (AM): Under this model, any attacker willing to confront a set of parties $P_1, .., P_n$ is able to delay and hold onto messages, but is forced, for every message that is delivered, to be done in good faith, that is, without any modification to it. When a message is sent by a party, the message is added to a set M of undelivered messages. When a party receives a message, this message is deleted from M (therefore, since the adversary is restricted to deliver faithful messages, if a party $P_j$ receives a message m from a party $P_i$, this must mean that $P_i$ sent message m to $P_j$). The attacker is also able to corrupt any party at wish. This means, learning all information (public and private) pertaining to it. If a party is corrupted, then the attacker is allowed to impersonate them, but such action is recorded accordingly in the party's protocol output. The global output of the protocol is the concatenation of the output of each party at the end of it, plus the output of the attacker. Each party's output is engrossed by every activation regarding the protocol flow. The adversary's output is defined to be "all the information seen (and derived) by the adversary throughout the computation, together with its random input. This includes registration of important events that occurred during the execution, such as corruption of parties".

Then, the \textit{Unauthenticated Model} (UM) is defined: Under this model, an attacker is not constrained to faithful delivery of message. Messages can be partially modified or even fully forged. The key component is that, under this model, the protocol is augmented with what is called a "Initialization function" I, which models an "initial phase of out-of-band and authenticated information exchange between the parties". This component is essential to the UM model, as seeks to provide the necessary authentication source that is lost once migrating to insecure channels.

When both models are explained, the following definition is given pertaining equivalence between two protocols over distinct models:\\
\textbf{Definition 3.1} \cite{cryptoeprint:1998/009}: Let $\pi$ and $\pi'$ be message-driven protocols for n parties. We say that  $\pi'$ emulates $\pi$ over unauthenticated networks if, for any UM-adversary \textit{U}, there is a AM-adversary \textit{A} such that their respective global outputs are computationally indistinguishable. \\
Then, the notion of a compiler is defined, to provide a bridge between protocols in both models: \\
\textbf{Definition 3.2} \cite{cryptoeprint:1998/009}: A compiler C is an algorithm that takes for input descriptions of protocols and outputs descriptions of protocols. An authenticator is a compiler C where for any protocol $\pi$, the protocol C($\pi$) emulates $\pi$ over unauthenticated networks.\vspace{2mm}\\
It is clear from the above definition of the models that the key component to provide authentication over unauthenticated models is the initialization function \textit{I}, which provides with the secure an authenticated information needed to provide the aforementioned assurance. In all the literature that works on this or similar ideas, as far as we are aware, this initialization function is used to safely exchange public or secret information, such that this elements are the seed the authentication is build upon.
\subsubsection{Key exchange protocols and SK security}
A key exchange protocol is a special type of the message driven protocol described above. In \cite{10.1007/3-540-44987-6_28}, is defined that the local output of said protocols are of the form ($P_i$, $P_j$, s, $\kappa$), representing the parties involved, the session identifier and the key derived from the execution of it. If the $\kappa$ value is null, then the exchange was unsuccessful and is considered as an aborted session. Otherwise, the session is consider completed an $\kappa$ is stored as the 'secret' of the exchange. Then, a number of actions are defined as possibilities for the adversary to perform against any given session. \vspace{2mm}\\
In \cite{10.1007/3-540-44987-6_28}, a complete definition of the concept of \textit{SK security} is introduced. The objective is "to define what is meant for a key-exchange protocol to be secure". SK security, intuitively, is about adding to the UM attacker the possibility to 'test' a session-key at any given time during the execution of a simulation. In it, the challenger will draw a random bit and, depending on this value, the adversary will learn the true value of the key derived from the session they chose (among completed, uncorrupted sessions) or a value drawn at random. The challenge to the adversary is being able to correctly distinguish between them. The security of the exchange is therefore tied to any adversary's possibility of distinguishing. Formally, given the following adversary's possibilities:
\begin{itemize}
    \item NewSession(A, B, s, r): the adversary issues the NewSession query to party A, specifying its intended partner B, the session identifier s, and the role r (initiator or responder) of A in the session. A will follow the protocol definition and may return an output message intended for B.
    \item Send(A, B, m): represents activation of A by an incoming message m (possibly including a session identifier) from party B. A will follow the protocol and may reject, accept, or return an output message intended for B.
    \item Corrupt(A): the adversary learns the whole state of A including any long-term keys. The corruption event is recorded in the local output of A. Subsequently A can never be activated but the adversary can take the role of A in the protocol.
    \item RevealKey(A, B, s): the adversary learns the session key accepted in the session s by A with partner B, if it exists. The reveal event is recorded in the local output of A.
    \item RevealState(A, B, s): the adversary learns the state information associated with session s at A, such as ephemeral keys. The reveal state event is recorded in the local output of A.
    \item Expire(A, B, s): if there is a completed session s at A with B then any session key associated with that session is deleted from the memory of A. The Expire event is recorded in the local output of A.
    \item Test(A, B, s): this query can be asked only once and can only be made to a completed session s at A with partner B. Furthermore there cannot have been any of the following queries made: RevealKey(A, B, s) or RevealState(A, B, s) or Corrupt(A) or Corrupt(B). If the bit b specified by the challenger is b = 1 then the session key is returned. Otherwise b = 0 and a random key from the keyspace is returned.
\end{itemize}
We define the SK-security of a protocol as follows:\\
\textbf{Definition 3.3:} \cite{cryptoeprint:2023/167} A key exchange protocol $\Pi$ is $\epsilon$-SK-secure if the following holds for any adversary $\mathcal{A}$:
\begin{enumerate}
    \item two honest parties (i.e. uncorrupted parties who faithfully execute the protocol instructions) completing matching sessions of the protocol $\Pi$ will output the same key, except with negligible probability.
    \item the advantage of the adversary $\mathcal{A}$ in the key indistinguishability experiment described above is:
    \begin{align*}
        \advantage{Key-Ind}{\Pi}[(\mathcal{A})] = 2\cdot\abs{P[b' = b] - \frac{1}{2}} \leq \epsilon
    \end{align*}
\end{enumerate}
\subsection{Our model}
In the model defined and used throughout this work, we follow the same ideas defined in \cite{10.1007/3-540-44987-6_28} and \cite{cryptoeprint:1998/009}, but with an important modification regarding the authentication source. In our model, the authentication will not be provided by an initial safe cryptographic exchange of elements, but rather of a 'final' authentication between parties of certain values that will be generated within each protocol execution. This means, upon finalization of each protocol's message exchange and, as part of its execution, an element will be generated to both parties in the protocol execution, from elements shared or generated during the protocol execution. This value will be verified to be the same by both parties at the end of it, by means of a 'verification phase' modeled by I$_1$. If this verification is satisfactory, then we establish that \textit{m} received by the receiving party $P_j$ was indeed sent by the sending party $P_i$.

While our \textit{Authenticated Model} (AM) remains unchanged, our \textit{Unauthenticated Model} (UM) is defined as follows: Under this model, like the UM previously detailed, an attacker is no longer constrained to faithful delivery of message like in the AM. Messages can be partially modified or even fully forged. The key component is that, under this model, the protocol is augmented with what is called a "verification function" I$_1$, which models a final phase of out-of-band and authenticated information verification between the parties of shared information generated or transmitted during the protocol execution. This component is essential to our UM model, as seeks to provide the necessary authentication source that is lost once migrating to insecure channels, as the previous UM model did with their initialization function. \\
Notice that this verification phase and the values generated to perform the validation will be constructed from elements formed and transmitted during the protocol run. The idea behind is that, if the protocols are constructed in a certain way, any adversary modification of them will not go unnoticed in the verification values generated, and will not be validated during $I_1$. \vspace{1mm} \\
We give now the definition of MT-authenticators introduced on \cite{cryptoeprint:1998/009}, with regards to the newly introduced UM model: Consider the message transmission (MT) protocol designed for authenticated networks. The protocol takes the empty input. Upon activation within $P_i$ on external request ($P_j$;\textit{m}), party $P_i$ sends the message ($P_i$;$P_j$;\textit{m}) to party $P_j$, and outputs '$P_i$ sent \textit{m} to $P_j$'. Upon receipt of a message ($P_i$;$P_j$;\textit{m}), $P_j$ outputs '$P_j$ received \textit{m} from $P_i$'.
Then, let $\lambda$ be a protocol that emulates this protocol in unauthenticated networks. Define a compiler $C_\lambda$ as follows:

Given a protocol $\pi$, the generated
protocol $\pi'$ = $C_\lambda(\pi)$, running within party $P_i$, first invokes $\lambda$. Next, for each message that $\pi$ sends, $\pi'$ activates $\lambda$ with external request for sending that message to the specified recipient. Whenever
$\pi'$ is activated with some incoming message, it activates $\lambda$ with this incoming message. When $\lambda$ outputs '$P_i$ received \textit{m} from $P_j$' (which happens when party $P_i$ validates the entropy value generated on its end from message \textit{m} transmission against the value generated by $P_j$, by means of $I_1$), protocol $\pi$ is activated with incoming message \textit{m} from $P_j$. \\
The objective of the remainder of this section is to show that, under this new UM model, all relevant results provided on \cite{cryptoeprint:1998/009} and \cite{10.1007/3-540-44987-6_28} hold. We start by showing that, under a MT-authenticator $\lambda$ as defined above, the compiler $C_\lambda$ constructed from it is an authenticator: \vspace{1mm} \\
\textbf{Theorem 3.3}: Under the new UM model, let $\lambda$ be an MT-authenticator, and
let $C_\lambda$ be a compiler constructed based on $\lambda$ . Then $C_\lambda$ is an authenticator.
\begin{proof}
    See \cite{cryptoeprint:1998/009}.
\end{proof}
The proof given in \cite{cryptoeprint:1998/009}, even with the authentication differences between UMs, applies. That is because despite variations, we are still provided with $\lambda$ being a MT-authenticator. In our model, this will intuitively mean that if an attacker is able to modify (or even fully forge) a message transmission, validation through $I_1$ wont be successful, or equivalently, if the output '$P_i$ received \textit{m} from $P_j$' is generated from $\lambda$, this will necessarily mean that $I_1$ will produce an affirmative validation (and therefore will not happen that the triple ($P_j$; $P_i$;\textit{m}) is not currently in the set M of undelivered messages in the AM, and $P_j$ is uncorrupted). The differences between models will provably arise from the considerations under which a message not sent under the AM could appear on the UM, but this cases are modeled the same nevertheless, so the proof applies. \vspace{1mm} \\
We define now the MT-authenticator that will serve as the foundation of the secure UM protocol defined in the following sections:
\begin{pchstack}[boxed, center, space=1em]
    \procedure{Commitment-based MT Authenticator}{%
     (c, d) \sample \texttt{Com(m)} \> \> \\
     \> \sendmessageright{top=\text{c}} \> \\
     \> \> N \sample \{0,1\}^n \\ 
     \> \sendmessageleft{top=\text{N}} \> \\ 
     Entropy_A = \texttt{G}(c, N, m) \> \> \\
     \> \sendmessageright{top=\text{d}} \> \\
     \> \> m = Open(c, d) \\
     \> \> Entropy_B = \texttt{G}(c, N, m)}
\end{pchstack}
The idea behind the above authenticator is the following:
\begin{itemize}
    \item An initiator who wishes to send a message \textit{m} to a responder first generates a commitment \textit{c} of such message, and sends it.
    \item The responder, upon reception of such message, just generates a random share \textit{N} and transmits it to the initiator. 
    \item When the initiator receives this random share \textit{N}, liberates the opening \textit{d} associated with the previous commitment, so the receiver can access the message \textit{m}.
    \item Both ends generate a summary of the exchange, by deriving an Entropy value from the commitment \textit{c}, the random share \textit{N} and the actual message \textit{m}. Once the exchange is finished, the responder will validate its entropy value against the one obtained by the initiator, in a secure and authenticated way, as modeled by $I_1$.
\end{itemize}
The security of the above protocol resides in the security properties of commitment schemes, the hiding and binding properties, and the elements that conform the Entropy value:
\begin{itemize}
    \item The hiding property provides assurance that just from knowing the commitment value c the actual value m committed remains unknown until knowing d, which prevents the attacker from knowing m at the time of the random share generation.
    \item The binding property provides assurance that, once the commitment is generated, this value is tied to m and an attacker is not able to generate different opening values that map to any other valid messages.
\end{itemize}
We formalize this idea, by proving that the Commitment-based protocol described above emulates MT in unauthenticated networks: \vspace{2mm} \\
\textbf{Proposition 3.4:} The Commitment-based MT-authenticator, when instantiated with a secure commitment scheme, emulates MT over unauthenticated channels with advantage $\epsilon \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}})$, where l = $n_p^2 \cdot n_m$ and $n_p$ is the number of parties running the protocol, $n_m$ the maximum number of message sent by each party and $n_e$ the length of the entropy value generated.
\begin{proof}
    We follow the same demonstration idea of \cite{cryptoeprint:1998/009,10.1007/3-540-44987-6_28,cryptoeprint:2023/167}. An AM-adversary can perfectly simulate an UM-adversary unless the event \textit{"In the UM there is the output “Q received m from P” for some parties P and Q, but there was no previous output “P sent m to Q”} happens. We then bound the probability of this event happening on any particular (P, Q, m), and then bound probability of distinguishing between adversaries as the probability of the above event happening on a particular exchange times the maximum number of exchanges generated.\\
    The probability of this event happening on any particular (P, Q, m) is reduced to the probability of an UM adversary to generate different elements to those exchanged in a way that the later verification phase $I_1$ between P and Q is successful. We model that in the game  G$_{Entropy}$ and the advantage against the scheme as
    \begin{align*}
        \advantage{}{\texttt{CS-MT}} := \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1}}
    \end{align*}
    We show that $\advantage{}{\texttt{CS-MT}} \leq \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}}$. 
    \begin{pchstack}[ boxed , center, space=1em]
      {\procedure[linenumbering]{Game G$_{Entropy}$}{\phantomsection\label{CSMT}
          (c,d) \sample \texttt{Com(m)}  \\
          c^* \sample \adv_1^O(c) \\
          N \sample \{0,1\}^n \\
          N^* \sample \adv_2^O(c, N) \\
          v_1 = O(c, N^*, m) \\
          d^* \sample \adv_3^O(c, N, d) \\
          m' = Open(c^*, d^*) \\
          v_2 = O(c^*, N, m') \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G00}
          (c,d) \sample \texttt{Com(m)}  \\
          c^* \sample \adv_1^O(c) \\
          N \sample \{0,1\}^n \\
          N^* \sample \adv_2^O(c, N) \\
          v_1 = O(c, N^*, m) \\
          m' = Open(c^*, d) \\
          v_2 = O(c^*, N, m') \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G10}
          (c,d) \sample \texttt{Com(m)}  \\
          c^* \sample \adv_1^O(c) \\
          N \sample \{0,1\}^n \\
          v_1 = O(c, N, m) \\
          m' = Open(c^*, d) \\
          v_2 = O(c^*, N, m') \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    We define the intermediate games $G_0$ and $G_1$, where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange. \\
    Therefore, the value $\abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain value m, we are able to generate (d, $d^*$) openings such that both are valid openings of different messages m,  m' when put together with the commitment c, whose probability is modeled by the advantage of the game $G_{Binding^*}$ defined below. If it is not satisfied, the games $G_{Entropy}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{pchstack}[boxed, center]
      {\procedure[linenumbering]{Game G$_{Binding^*}$}{\phantomsection\label{Gbinding'}
          c \sample \texttt{Com(m$_0$)} \\
          (d, d') \sample \adv (c)  \\
          m = Open(c, d)  \\
          m' = Open(c, d')  \\
          \pcreturn (m \neq m') \wedge (m, m' \neq \bot)
        }}
    \end{pchstack}
    \begin{align*}
        \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value c, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the random challenge value sent by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that, given c commitment of a certain value m, we are able to extract information about the value m, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the value m, the attacker is unable to obtain enough information to elaborate of a guess of $N^*$ to provoke a collision and being able to modify it does not provide any advantage. Consequently, the difference lemma can be applied and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value c, which is $\frac{1}{2^{n_e}}$. \\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}}
    \end{align*}
    Then, considering all possible messages between parties, which equals the maximum number of messages sent by each party times the square of the number of parties, we arrive to the desired bound.
\end{proof}
\subsubsection{SK security under new model}
Under our model, we adopt the definition and the setting for key exchange protocols and 'session-key security' explained in \cite{10.1007/3-540-44987-6_28}, but introducing the authentication differences pertaining to our model. Since the key exchange procedures are a special case of message-driven protocols, the notion of entropy and posterior verification are translated onto this protocols too. An entropy value (pertaining to specific elements, depending upon the protocol in consideration) is generated by each party running the key exchange protocol. Once the protocol's message exchange is finished, the 'responder' verifies its entropy value against the one generated on the 'initiator' side, in a secure and authenticated way, as modeled by $I_1$. If this verification is affirmative and the key value $\kappa$ is not null (that is, a previous abort did not happen), the session is considered completed and the secret value $\kappa$ is appended as local output to both parties. If this verification is not affirmative, we consider the session aborted and $\kappa$ is set to null, even in the case when a non-null secret value of the key was reached at the end of the protocol's message exchange. 

We also need to slightly adapt what means for an adversary to corrupt a party, regarding the authentication procedure, since in our model there is no notion of long-term key to be compromised. We consider that, when a party is corrupted, the adversary access all entropy values generated by this party in every session procedure from the moment it gets corrupted (previous run of the corrupted party were correctly validated by $I_1$, as the party would not have been corrupted at that time). We could consider that, from the moment the party A is corrupted, the adversary is able to modify all entropy values generated by A from that point on but, since it is corrupted, it will not get activated. \\
With this modifications, we state that the following important result still holds under this new model: \vspace{1mm} \\
\textbf{Theorem 3.5:} Let $\pi$ be a SK-secure protocol in the AM and let $C_\lambda$ be a compiler base on MT-authenticator $\lambda$. Consider $\pi' = C_\lambda(\pi)$ the protocol that emulates $\pi$ in our modified UM model. Then, $\pi'$ is a SK-secure protocol in our modified UM model.
\begin{proof}
    See \cite{cryptoeprint:2023/167}
\end{proof}
We note that the proof presented in \cite{cryptoeprint:2023/167} to prove this result under the original model still applies to our model. The definitions of \cite{cryptoeprint:2023/167} still model the notion of the key indistinguishability experiment (without any long-term key) and SK-security under our model, as we have included the necessary entropy validation of our general message-driven model inside the definition of 'completeness' of a key exchange protocol execution. We note that this requirement is the appropriate execution over key exchange protocols. The key event 'forge' that models the proof is the well-known event that a party $P_j$ successfully receives a message \textit{m} from another party $P_i$ but $P_i$ never sent it. This event might happen with different probability under the two UM models, but it triggers the same consequences on both models, which is the only notion applied on the proof. In other words, what is consider in both models as 'successfully send' may vary: intuitively, in the original model this would amount to obtain the long-term secret or break the cryptographic primitives involved within the MT authenticator and, in our model, amounts to generate a collision on the entropy values generated or break the cryptographic primitives involved within the MT authenticator. Nevertheless, the fact that this same event is what drives the adversary's possibilities of distinguishing remains the same, therefore the proof remains true. \\
We now turn to the analysis of practical protocols under our model.
\section{KEX-based protocols}

Cryptographic protocols based on key exchange algorithms are vastly used in a number of different scenarios, a great deal of those through insecure channels. These protocols are defined in terms of the number of exchanged messages needed to complete them, and the information sent on each message.

\subsection{2-pass protocol}

The minimum requirement for an successful KEX-based shared secret establishment is 2 messages. The protocol would go as follows:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEX-based protocol on the \textit{AM} \pcbox{UM}}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> K_{ab} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> \pcbox{Entropy = \texttt{G}(p_{k_a}, p_{k_b}, K_{ab})} \\ 
     \> \sendmessageleft{top=\text{p$_{k_b}$}} \> \\ 
     K_{ba} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     \pcbox{Entropy = \texttt{G}(p_{k_a}, p_{k_b}, K_{ba})} \> \>}
\end{pchstack}

\begin{itemize}
    \item The initiator generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KeyGen() function of the specific KEX selected. Then, the public value $p_{k_a}$ is sent to the responder.
    \item  The responder, upon reception of the initiator's public key $p_{k_a}$, generates another key pair ($s_{k_b}$, $p_{k_b}$) with the same algorithm KeyGen(), to then execute the KeyAgreement function, with inputs its own secret key $s_{k_b}$ and the other end's public key $p_{k_a}$. The execution of this function yields a secret key $K_{ab}$. Then, the responder sends its own public key $p_{k_b}$ to the initiator.
    \item With the responder's public key, the initiator executes the same KeyAgreement function, on its own private key and the received public key, to derive the shared secret $K_{ba}$. If no interference has happened, the KEX algorithm ensures that $K_{ab}$ = $K_{ba}$.
\end{itemize}

\subsubsection{Security of the above protocol \label{3.1.1}}

The security of the protocol itself, without any interference, i.e., on the authenticated model, is based upon the security of the underlying key exchange algorithm selected, and the unique possession by both ends of their respective secret keys.

Over insecure channels, i.e., on the unauthenticated model, neither party has any assurance that the public key values received indeed corresponds to the actual values sent by the other party. This particular situation is the very foundation of the presence of the session entropy value calculated by both ends on the protocol. But, even the presence of such value is not enough to avoid MitM interference. The attack against this protocol goes as follows:

\begin{itemize}
    \item When the initiator sends its public key $p_{k_{a}}$, the attacker intercepts it and instead transmits the public key $p_{k_{eb}}$ of its key pair generated. Then, the responder will execute the corresponding KeyAgreement function over the fraudulent public key $p_{k_{eb}}$, generating a secret $K_{eb}$, and its session entropy, based on the secret, its own public key $p_{k_{b}}$ and the fraudulent public key value $p_{k_{eb}}$. Then, the responder transmits $p_{k_{b}}$.
    \item The attacker would then need to intercept this public value and substitute with the public key value $p_{k_{ea}}$ of a newly generated key pair ($s_{k_{ea}}$, $p_{k_{ea}}$). But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $p_{k_{ea}}$ and $p_{k_a}$ is the same as the session entropy generated by the responder (to which the attacker, as has actively modified the natural course of the protocol, has access to). Therefore, the attacker would need to loop through key pairs ($s_{k_{ea_i}}$, $p_{k_{ea_i}}$) until one satisfies the required condition.
\end{itemize}
The actual success probability of this attack is closely tied with the size of the session entropy generated, but is nevertheless a plausible loophole for an attacker to exploit.

\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.75cm]{MitM attack on 2-pass KEX-based protocol}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright*[2.5cm]{\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_{eb}}, p_{k_{eb}}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright*[2.5cm]{\text{p$_{k_{eb}}$}} \> \\
     \> \> \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> \> \> K_{be} \sample \texttt{KEX}(p_{k_{eb}}, s_{k_b}) \\
     \> \> \> \>  Entropy_{be} = \texttt{G}(p_{k_{eb}}, s_{k_b}, K_{be}) \\
     \> \> \> \sendmessageleft*[2.5cm]{\text{$p_{k_b}$}} \> \\
     \> \> K_{eb} = \texttt{KEX}(p_{k_b}, s_{k_{eb}}) \> \> \\
     \> \> Entropy_{eb} = \texttt{G}(p_{k_{eb}}, p_{k_b}, K_{eb}) \> \> \\
     \> \> \texttt{While $Entropy_{ea} \neq Entropy_{eb}$ do:} \> \> \\
     \> \> \quad (s_{k_{ea}}, p_{k_{ea}}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \> \quad K_{ea} \sample \texttt{KEX}(p_{k_a}, s_{k_{ea}}) \> \> \\
     \> \> \quad Entropy_{ea} = \texttt{G}(p_{k_a}, p_{k_{ea}}, K_{ea}) \> \> \\
     \> \sendmessageleft*[2.5cm]{\text{$p_{k_{ea}}$}} \> \> \> \\
     K_{ae} = \texttt{KEX}(p_{k_{ea}}, s_{k_a}) \> \> \> \> \\
     Entropy_{ae} = \texttt{G}(p_{k_a}, p_{k_{ea}}, K_{ae}) \> \> \> \>}
\end{pchstack}

\subsubsection{Practical example \label{3.1.2}}
We provide a practical example of the above protocol, by instantiating the general KEX scheme with a basic Diffie-Hellman procedure, over a generic finite cyclic group:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass DH-based protocol in the AM}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     a \sample \mathbb{N} \> \> \\
     \> \sendmessageright*[2.5cm]{\text{$g^a$}} \> \\
     \> \> b \sample \mathbb{N} \\ 
     \> \> K_{ab} = (g^a)^b = g^{ab} \\ 
     \> \sendmessageleft*[2.5cm]{\text{$g^b$}} \> \\ 
     K_{ba} = (g^b)^a = g^{ba} \> \>}
\end{pchstack}

This protocol was proven secure on the AM model in \cite{cryptoeprint:1998/009}. It is not secure in the UM model.

\subsection{3-pass protocol}
To avoid the weaknesses of the above protocol it is necessary to impose some kind of restriction on the generation of values to any potential attacker. We apply the same ideas as on the CS MT authenticator described above to define the following protocol:
\begin{pchstack}[boxed, center]
    \procedure{3-pass KEX-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> (c, d) \sample \texttt{Com}(p_{k_b}) \\ 
     \> \sendmessageleft{top=\text{c}} \> \\ 
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> K_{ba} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> Ent = \texttt{G}(p_{k_a}, p_{k_b}, K_{ba}) \\
     \> \sendmessageleft{top=\text{d}} \> \\ 
     p_{k_b} = Open(c(p_{k_b}), d(p_{k_b})) \> \> \\
     K_{ab} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     Ent = \texttt{G}(p_{k_a}, p_{k_b}, K_{ab})}
\end{pchstack}
\begin{itemize}
    \item First, the responder generates a key pair ($s_{k_{a}}$, $p_{k_{a}}$) and sends the commitment of its public key to the initiator.
    \item The initiator stores this value and generates its own key pair ($s_{k_{b}}$, $p_{k_{b}}$) and sends it to the responder.
    \item The responder, upon reception of the public key value of the initiator, derives the shared secret value $K_{ba}$ from its own private key, and the public key received, along with its session entropy from the shared values involved in the protocol. Then, the responder sends the public key value previously committed, along with the opening value required to open the commitment.
    \item The initiator verifies that the value committed matches the commitment stored (as part of the opening function), and then proceeds to derive the shared secret $K_{ab}$ and its session entropy.
\end{itemize}
\subsubsection{Security of the above protocol}
If the CS selected to use in this protocol is secure, that is, verifies the hiding and biding properties defined above, this protocol is secure. The hiding property of the scheme ensures that no information about the committed value is shared beforehand, and the biding property ensures that the MitM attack described above cannot happen, as an attacker has a negligible possibility of producing a different key pair that commits to the same value as the one committed.

Note that the same ideas used to construct the CS MT authenticator are present here: the commitment of a value beforehand, so it binds the adversary to commit-related values and an entropy value influenced only by elements exchanged on the first and second iteration, never on the last (as this would open a plausible door for an adversary to exploit). The specific values that conform the entropy validation must be selected carefully, so that they provide the necessary authentication while not proving a security over-kill that an adversary can exploit, as will become apparent later.

\subsubsection{Practical example \label{3.2.2}}
We give a practical example of the above 3-pass protocol by building on the example laid out in \ref{3.1.2}:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass DH-based protocol on the UM}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> (b, g^b) \sample \mathbb{N} \\ 
     \> \> (c, d) \sample \texttt{Com($g^b$)} \\ 
     \> \sendmessageleft{top=\text{c}} \> \\ 
     (a, g^a) \sample \mathbb{N} \> \> \\
     \> \sendmessageright{top=\text{$g^a$}} \> \\
     \> \> K_{ba} = (g^a)^b = g^{ab} \\ 
     \> \> Entropy = H(g^a, g^b, c) \\
     \> \sendmessageleft{top=\text{d}} \> \\ 
     g^b = \texttt{Open}(c, d) \> \> \\
     K_{ab} = (g^b)^a = g^{ba} \> \> \\
     Entropy = H(g^a, g^b, c)}
\end{pchstack}
We claim that the described protocol is SK-secure in our UM model, and lay out the proof on Annex C. \vspace{2mm}\\
\textbf{Proposition 4.1:} The above protocol is SK-secure on the UM, based on the security of the Decisional Diffie-Hellman (DDH) assumption and the Commitment Scheme.

\section{KEM-based protocols}

When working with Key Encapsulation Mechanisms, two important differences must be highlighted:
\begin{enumerate}
    \item The KEM mechanism is, in general, not contributory, as opposed to the KEX mechanisms considered in the previous section. That means that the final shared key does not come from a mutual contribution of both ends, but is unilaterally generated by one end and transmitted to the other.
    \item The public values that will be exchanged in the protocol are not independent. That is, it will not be formed by two public keys generated by both users, but formed by a public key and an encapsulation, whose value depends on the public key value.
\end{enumerate}
These two differences will drive the security analyses made on KEM-based protocols, and its contrasts with their KEX-based counterparts.

\subsection{2-pass protocol  \label{4.1}}

The 2-pass KEM-based protocol is, in appearance, a drop-in replacement of its KEX-based counterpart, in the sense that the KEX instances were substituted by Encaps and Decaps procedures:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEM-based protocol on the AM \pcbox{UM}}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (ct_b, K) \sample \texttt{Encaps}(p_{k_a}) \\
     \> \> \pcbox{Entropy = \texttt{G}(p_{k_a}, ct_b, K)} \\
     \> \sendmessageleft{top=\text{ct$_b$}} \> \\ 
     K = \texttt{Decaps}(ct_b, s_{k_a}) \> \> \\
    \pcbox{Entropy = \texttt{G}(p_{k_a}, ct_b, K)} \> \>}
\end{pchstack}

\begin{itemize}
    \item The initiator generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KeyGen() function of the specific KEM selected. Then, the public value $p_{k_a}$ is sent to the responder.
    \item  The responder, upon reception of the initiator's public key $p_{k_a}$, executes the encapsulation function on the public key received. The execution of this function yields a secret key K, and an encapsulation $ct_b$ of the secret that conforms the generated shared secret. Then, the responder sends the aforementioned encapsulation.
    \item The initiator executes the decapsulation function, with inputs the encapsulation $ct_b$ received and its own secret key, to derive the shared secret K.
\end{itemize}
\subsubsection{Security}
Under the AM model, that is, under the assumption that the integrity of each message received is intact, the protocol is SK-secure, as proven in \cite{cryptoeprint:2023/167}. 

Under our UM model, a number of different considerations arise regarding the protocol's practical security: the attacker's possibility to generate the same shared secret on both ends, a replica for KEM-based protocols of the attack against 2-pass KEX-based protocol, and a combination of them.
\paragraph{Attack on same key on both ends}
Despite its clear similarities to the 2-pass KEX-based protocol, a MitM attacker not only has the ability to establish a shared secret with each party but also, in general, the ability to generate the exact same shared secret on both, and thus all three parties possess the same shared secret value. This is a direct consequence of the non-contributory nature of Key Encapsulation Mechanisms. The attack would go as follows:
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1cm]{MitM attack on KEM schemes}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright*[2.5cm]{\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright*[2.5cm]{\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \sendmessageleft*[2.5cm]{\text{Ct$_b$}} \> \\
     \> \> (x, K) = \texttt{Decaps$^*$}(Ct_b, s_{k_e}) \> \> \\
     \> \> (Ct_e, K) = \texttt{Encaps$^*$}(x, p_{k_a}) \> \> \\
     \> \sendmessageleft*[2.5cm]{\text{Ct$_e$}} \> \> \> \\
     K = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \>}
\end{pchstack}
\begin{itemize}
    \item The initiator generates its KEM key pair ($s_{k_{a}}$, $p_{k_{a}}$) and sends its public key to the responder.
    \item The MitM attacker intercepts the public key value sent, generates another key pair ($s_{k_{e}}$, $p_{k_{e}}$) and substitutes the public key value sent by the initiator with its own public key $p_{k_{e}}$.
    \item The responder executes the encapsulation function with the public key value received. At this moment, all information about the key is established. The responder sends the encapsulation of the secret required to derive the shared key.
    \item The MitM attacker intercepts the encapsulation sent and, as it has been encapsulated using its public key value, decapsulates it using the secret key. Through this process, the attacker is able to learn the secret $x$ that was encapsulated, and that forms the shared key. Therefore, the attacker simply re-encapsulates this exact same value with the initiator's public key, and sends this encapsulation Ct$_e$ to them.
    \item The initator executes the decapsulation function on the encapsulation received, and its own secret key, to derive the same shared key \textit{K} as the responder and the MitM attacker.
\end{itemize}
This possibility highlights the requirement of the entropy session to be contributed by the public values involved in the key derivation, as this addition is all that is required to  thwart the attack, for deterministic-based KEMs. \vspace{1mm} \\
The previous attack is carried on by slightly tweaking the \textit{Encaps} and \textit{Decaps} definition provided, on the attacker's side. The \textit{Encaps}* function takes also as argument the secret value to be encapsulated. Meanwhile, the \textit{Decaps}* function also outputs the secret value that was encapsulated.
\paragraph{Replica attack on KEX-based protocol \label{4.1.1.2}}
When the above protocol's session entropy is contributed with public values involved in the exchange, the attack detailed above does not, in general, apply (see Section \ref{4.1.1.3}). Nevertheless, the attack on the session entropy value shown in Section \ref{3.1.1} still applies, as a commitment value is not present in the 2-pass KEM-based protocol either:
\begin{itemize}
    \item When the initiator sends a public key value $p_{k_{a}}$, the attacker intercepts it and transmits instead the public key value $p_{k_{e}}$ of a newly generated key pair ($s_{k_{e}}$, $p_{k_{e}}$). Then, the responder will execute the \textit{Encaps} function over the fraudulent public key $p_{k_{e}}$, generating a secret $K_{be}$, and the corresponding session entropy, based on this secret, the encapsulation $Ct_{b}$ generated and the fraudulent public key value $p_{k_e}$. Then, the responder sends this encapsulation to the initiator.
    \item The attacker would then need to intercept the encapsulation value $Ct_{b}$ and transmit instead an encapsulation value $Ct_{e_{i_{0}}}$ of an execution of the \textit{Encaps} function on the initiator's public key $p_{k_{a}}$. But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $Ct_{e}$ and $p_{k_a}$ its the same as the session entropy generated by the responder (which the attacker is able to calculate, as possesses all elements involved in its generation). Therefore, the attacker would generate enough encapsulation values $Ct_{e_{i}}$, looping through \textit{Encaps} executions, until one encapsulation $Ct_{e_{i_{0}}}$ satisfies the required condition.
\end{itemize}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.75cm]{MitM attack on 2-pass KEM-based protocol}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright*[2cm]{\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright*[2cm]{\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K_{be}) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \>  Entropy_{be} = \texttt{G}(p_{k_e}, Ct_b, K_{be}) \\
     \> \> \> \sendmessageleft*[2cm]{\text{Ct$_b$}} \> \\
     \> \> K_{eb} = \texttt{Decaps}(Ct_b, s_{k_e}) \> \> \\
     \> \> Entropy_{eb} = \texttt{G}(p_{k_e}, Ct_b, K_{eb}) \> \> \\
     \> \> \texttt{While $Entropy_{ea} \neq Entropy_{eb}$ do:} \> \> \\
     \> \> \quad (Ct_e, K_{ea}) \sample \texttt{Encaps}(p_{k_a}) \> \> \\
     \> \> \quad Entropy_{ea} = \texttt{G}(p_{k_a}, Ct_e, K_{ea}) \> \> \\
     \> \sendmessageleft*[2cm]{\text{Ct$_e$}} \> \> \> \\
     K_{ae} = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \> \\
     Entropy_{ae} = \texttt{G}(p_{k_a}, Ct_e, K_{ae}) \> \> \> \>}
\end{pchstack}
Note that in the above setting, if the underlying PKE is deterministic, an attacker is not able to generate the same key on both ends, since, in case that the key value is fixed to be the same on both ends, the attacker would need a different encapsulation value generated on each iteration, over the same secret 't' that generates the shared key, and this cannot be achieved on a deterministic PKE. 
\paragraph{Combination under probabilistic PKE algorithm \label{4.1.1.3}}
In the above setting, if the underlying PKE is deterministic, an attacker is not able to generate the same key on both ends. This is due to the fact that, in case that the key value is fixed to be the same on both ends, the attacker would need a different encapsulation value generated on each iteration, over the same secret \textit{t} that generates the shared key, and this cannot be achieved on a deterministic PKE. 

On the other hand, if the underlying PKE scheme is indeed probabilistic and has not undergone a de-randomization procedure, the two attacks can happen simultaneously, as each execution of the encapsulation procedure on the same secret value yields different results.
\subsection{3-pass protocol}
In the KEX-based protocol entourage, the natural way to avoid the attacks over the 2-pass protocol was to add a commitment of the public key value of the responder before actually sending its value, so that an attacker does not have a free pass over fraudulent key pair generation. When migrating to the KEM setting, this addition is not as simple because, as discussed above, the public value generated by the responder, i.e. its encapsulation, is not independent from the public value generated by the initiator, i.e. the public key, and therefore cannot commit to a value of it before actually receiving the initiator's public key while maintaining a 3-pass message exchange between them.

It is therefore required for the responder to find a way to commit to a value before receiving the initiator's public key, such that the commitment made effectively blocks the attacker's ability to generate different session entropy values. It is essential to precisely choose which values will conform the final session entropy value, as different choices lead to different protocols (and, thus, different security requirements). \\
We describe in this section the simplest way to achieve a 3-pass KEM-based SK-secure protocol, by incorporating two independent entropy values to be corroborated: the first entropy session value is only conformed by elements exchanged in the first two messages. The second is formed by values generated transmitted (or generated) from that third message, and directly pertaining to the final session key derived.

\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEM-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> N \sample \{0,1\}^n \\
     \> \> (c, d) \sample \texttt{Com} (N) \\
     \> \sendmessageleft{top=c} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\  
     \> \> Entropy = \texttt{G}(N, \pk, c) \\
     \> \> Entropy_{add} = \texttt{G}(ct, K) \\
     \> \sendmessageleft{top=\text{(ct, d)}} \> \\ 
     K = \texttt{Decaps}(\sk, ct) \> \> \\ 
     N = Open(c, d) \> \> \\
     Entropy = \texttt{G}(N, \pk, c) \> \> \\
     Entropy_{add} = \texttt{G}(ct, K)}
\end{pchstack}

\begin{itemize}
    \item First, the responder generates a random value \textit{N} and sends a commitment of it to the initiator.
    \item The initiator stores this value and generates a key pair ($s_{k}$, $p_{k}$) and sends it to the responder.
    \item The responder, upon reception of the public key value $\pk$ of the initiator, executes the \textit{Encaps} function, deriving a shared secret \textit{K} and a encapsulation value \textit{ct}, along with its session entropies, from the random element \textit{N}, its commitment \textit{c} and the public key value $\pk$, and the encapsulation value \textit{Ct} and the shared key \textit{K}. Then, the responder sends the opening value \textit{d} of the random element \textit{N} previously committed, along with the encapsulation value \textit{Ct} needed by the initiator to derive the same key.
    \item The initiator verifies that the value committed matches the commitment stored (as part of the opening function), and then decapsulates the encapsulation received with its own secret key, to access the shared secret value \textit{K}.
\end{itemize}

\subsubsection{Security of the above protocol}
Unlike the KEX scenario, here the responder has not committed itself to a element directly involved in the shared secret derivation, but instead to a random element with no direct relevance to the shared secret derivation. The reason for it is that, as discussed above, it is impossible for the receiver to commit to a value that takes a role in the KEM procedure (i.e., the encapsulation) without knowing first the public key value of the initiator. \\
Note that the random element committed by the responder does not influence the shared secret derived, but is critical to the security of the scheme, as it provides with a second source of randomness to the entropy value being derived, not known to any possible adversary at the time of public key value transmission(s). \\
We now formally state the SK-security of the above protocol in our UM model, and provide the complete proof in Annex C: \vspace{2mm} \\
\textbf{Proposition 5.1:} The above protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the Hiding and Binding security properties, and the KEM scheme is IND-CPA secure. \vspace{2mm} \\
The additional entropy $Entropy_{add}$ added to be validated during the out-of-phase $I_1$ procedure is needed to ensure that no message goes unauthenticated, as this breach would allow an attacker to trivially distinguish between keys on the receiver side, since it would be able to generate whatever key they desire. It is also important that this value is not added to the main entropy validation, as this values together would provide the attacker with an entry-point attack against the overall protocol. Without this additional entropy validation, and adversary could simply modify the encapsulation value \textit{ct} and the secret derived in both ends would not match. This would not provide any meaningful advantage to the attacker in practical situations, other than practical Denial of Service practices, but would have been nevertheless a breach in the theoretic security of the protocol. \vspace{1mm} \\
\textbf{Note:} It is possible to derive a 3-pass KEM-based protocol which is secure in the UM model without the need for an additional session entropy value. This alternative 3-pass KEM-based protocol with only one entropy value (contributed by the encapsulation value and the secret key derived) to be corroborated is described in detail in Annex A.

\subsection{4-pass protocol}
The modifications applied to the 3-pass KEM-based protocol were intended to provide a way for the responder to restrict the attacker's possibility while maintaining a true 3-pass exchange between them, i.e., without any party sending two consecutive messages, in a scenario in which the responder depends on the public key value sent by the inititator to generate its associate public value, the encapsulation value of the secret element. When given a 4-pass protocol, these modifications are no longer required, and we can directly apply our CS-based compiler to the 2-pass KEM-based protocol, to arrive to the following protocol:
\begin{pchstack}[boxed, center, space=1em]
    \procedure{4-pass KEM-based protocol (optimized)}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     m \sample \texttt{\{0,1\}$^n$} \> \> \\
    (d(m), c(m)) \sample \texttt{Com}(m) \> \> \\
     \> \sendmessageright*[2.5cm]{\texttt{(\pk, c(m))}} \> \\
     \> \>  N_B \sample \texttt{\{0,1\}$^n$} \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\ 
     \> \> (d(ct), c(ct)) \sample \texttt{Com} (ct) \\
     \> \sendmessageleft*[2.5cm]{\texttt{(c(ct), $N_B$)}} \> \\ 
      N_A \sample \texttt{\{0,1\}$^n$} \> \> \\
     Ent_A = \texttt{G}(m, c(m), N_B, \pk) \> \> \\ 
     \> \sendmessageright*[2.5cm]{\texttt{(d(m), $N_A$)}} \> \\
     \> \> m = Open(c(m), d(m)) \\
     \> \> Ent_A = \texttt{G}(m, c(m), N_B, \pk) \> \> \\ 
     \> \> Ent_B = \texttt{G}(ct, c(ct), N_A) \> \> \\ 
     \> \sendmessageleft*[2.5cm]{\texttt{d(ct)}} \> \\ 
     ct = Open(c(ct), d(ct)) \> \> \\
     K = \texttt{Decaps}(\sk, ct) \> \> \\
     Ent_B = \texttt{G}(ct, c(ct), N_A)}
\end{pchstack}
\begin{itemize}
    \item First, the initiator generates a key pair $(\sk, \pk)$ and a random value \textit{m} uniformly, and sends the public key value $\pk$ and a commitment \textit{c(m)} of \textit{m}.
    \item The responder, upon reception of the public key value $\pk$, executes the \textit{Encaps} function on the public key received, generating the secret key value \textit{K} and an encapsulation \textit{ct}. Then, generates a commitment \textit{c(ct)} of this encapsulation value and sends it, along with a random challenge $N_B$.
    \item The inititator, upon reception of the commitment value \textit{c(ct)}, generates its own challenge $N_A$ and sends it along with the opening value \textit{d(m)} of \textit{m}.
    \item The responder verifies the commitment received at the beginning with the opening value received in this iteration and the actual value committed and, upon successful verification, calculates its entropy session value and sends the opening value \textit{d(ct)} of the encapsulation value \textit{ct} committed before.
    \item The initiator verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the \textit{Decaps} function, and its corresponding session entropy.
\end{itemize}
\subsubsection{Security}
The initiator's commitment is sent to ensure that the message to acknowledge reception of the commitment of the encapsulation is sent by the inititator and not a fake generation by an attacker. This intermediate message is essential to provide assurance that there is a separation between the responder sending the committed value and the actual value, so that a MitM opponent cannot modify this commitment in order to send a distorted encapsulation value that passes the verification, provided that this random value is added to the session entropy derivation. \\
With the presence of the initiator's random value inside the session entropy, we ensure the following:
\begin{itemize}
    \item An attacker, because of the security properties of commitment schemes, can only succeed if is able to generate a fraudulent encapsulation value before the commitment of the real encapsulation generated by the responder reaches the initiator, and that this fake encapsulation generates the same session entropy value on the initiator's side that the one that the responder calculates.
    \item But, to do so the attacker needs to know all values involved on within the session entropy generation, including the random value committed by the initiator at the beginning. And this value is not actually shared until after the initiator receives a commitment of the encapsulation value. Therefore, the attack cannot succeed.
\end{itemize}
This is perhaps best shown by pointing out the fact that the first time the attacker is able to learn the session entropy values that the parties will calculate is well after it has been forced to commit to a encapsulation value (and, thus, a shared secret value) and to a random value. Therefore, it is not possible to replicate the attack.

The hiding property of the commitment applied ensures that no information can be obtained by only knowing the commitment, and the binding property provides assurance that, given a commitment, the advantage of generating a fraudulent opening and value that verifies the commitment is negligible. Formally, we have: \vspace{2mm}\\
\textbf{Proposition 4.5}: If the commitment scheme is hiding and binding, and the KEM scheme is IND-CPA secure, the 4-pass protocol is SK-secure in our UM.
 \begin{proof}
     We apply Theorem 3.5 to the 2-pass KEM-based protocol SK-secure in the AM and the compiler constructed from the CS MT-authenticator.
 \end{proof}
 The only modification over a canonical application of the CS-based compiler is the inclusion of the $\pk$ value in the first entropy session value. This is however perfectly valid, since we can add any value transmitted in the first or second message of the CS MT-authenticator without any repercussion to the validity of the authenticator. \\
 This protocol, as opposed to the 3-pass protocol, provides mutual authentication between parties, as the responder authenticates value $Entropy_B$ against the initiator, and the initiator does the same against the responder with value $Entropy_A$.

\section{Conclusions}
First, we have defined an alternative Unauthenticated Model, following the same ideas first explained in \cite{cryptoeprint:1998/009}, but providing a different source of authentication, not based on the assumption of a initial safe exchange of cryptographic material, but rather a final safe verification phase of protocol-generated elements. This modification is consistent with the use of key exchange protocols under different security scenarios from the ones provided by the original authentication source. With the appropriate modification, we have shown that all relevant results from their model still apply to ours.

We have shown how to construct secure KEM-based protocols from 3 and 4 passes over this new UM, which requires to consider the plausible presence of MitM attackers. We have done so by first studying how equivalent KEX-based protocols would be constructed in this model, and the difficulties that naturally arise from the differences between standard KEX constructions like the Diffie-Hellman paradigm and KEM constructions.

The protocols constructed follow on the steps taken in the KEX settings, that is, generating an additional value that 'resumes' the session exchange between the two parties, and forcing any attacker to commit to a specific value before it has all the necessary information to calculate such value, so its presence is detected by inconsistencies in this digest. \vspace{1mm} \\
For the 3-pass protocol a commitment value of the responder's public value is not possible, due to the dependent nature of the encapsulation value. Nevertheless, an attacker can still be blocked if the entropy value is segmented in two, the first one pertaining to elements exchange on the first two messages, and the second one related to the actual session key generated. A more complex 3-pass KEM-based protocol, which does not require entropy segmentation is explained in the Annex.

For the 4-pass protocol, it is indeed possible for the responder to generate a commitment of its public value, but it is required to show an actual separation, in terms of the initiator's interaction, between the commitment value and the actual value. Therefore, a 'proof of identity' is generated, by means of yet another commitment, this time of a random value large enough to ensure the initiator's identity. With this measures, we show the impossibility of a MitM attack and, consequently, the security of the protocol over our UM. \\
These protocols, based on the authentication differences between the model started by \cite{cryptoeprint:1998/009} and followed by \cite{cryptoeprint:2023/167}, account for fewer public key operations to derive the authentication source. The authentication source provided in this new model is intended for correspondence with more practical application to communication protocols.

\bibliography{lib.bib}
\bibliographystyle{alpha}

\nocite{cryptoeprint:2019/1356}

\section*{A: Another 3-pass KEM-based construction}

As the session entropy value is determined by the value of the shared key, along with the public values of the public key involved within its encapsulation and the encapsulation value of the secret, the restriction must be imposed within those values. \vspace{2mm} \\
Since any added value to the procedure would only modify how the values involved with the session entropy are generated, but not constrain the attack of Section \ref{4.1.1.2} and, considering that any value shared by one party, even when encrypted by means of public-key cryptography, to another could be accessed by the eavesdropper (by means of playing with the public key used to encrypt), the only plausible value for the responder to commit to is the secret value that is randomly generated at the beginning of the encapsulation procedure and that determines the final shared key value and the encapsulation value.
\subsection*{A.1: Analysis on the commitment scheme to apply \label{4.2.1}}
The selection of such value as the value to be committed forces the protocol to be extremely meticulous in relation to the information that will be divulged by the responder in order to allow the initiator to verify the committed value. Since the actual value \textit{x} will be anyways made available to the initiator, by construction of any key encapsulation scheme (and to any eavesdropper successfully in the middle), we will distinguish between commitment protocols in which the identity is part of the opening or not:
\begin{itemize}
    \item Case 1 - The Commitment Scheme selected divulges the committed value as part of the opening: In this scenario, as the secret value to be committed is encapsulated to the initiator, it is only required to transmit any other values that conform the opening. Those values, as the committed value is actually part of the opening (and therefore, not additional information about it is required), will not necessary divulge information about this value. Thus, if there exists a scheme  with the condition that, when this information is paired with the commitment value, do not divulge any information about the secret value, the rest of opening could go in clear.
    \item Case 2 - The Commitment Scheme selected does not divulge the committed value as part of the opening: In this situation, the opening transmits information about the committed value that cannot be transmitted in clear.
\end{itemize}
It should be noted that the information that conforms the opening is not suited to be encrypted by symmetric cryptography, due to the following reasons:
\begin{enumerate}
    \item Any use of the shared secret generated by the encapsulation procedure conforms, from the theoretical point of view, a break of the IND security of the scheme.
    \item No prior knowledge of a symmetric shared key is available to both ends.
    \item No other element is available to perform an encryption that any party without knowledge of the exchange is not able to decrypt.
\end{enumerate}

\subsection*{A.2: KEM variant definition}
In order to accommodate the above proposal, minor variations are required to the standard KEM definition: \vspace{2mm} \\
\textbf{Definition 4.1}: A key encapsulation mechanism KEM$_{commit}$ = (KGen, KCom, Encaps*, Decaps*) of a given KEM  and Commitment Scheme consists of four algorithms:
\begin{itemize}
    \item The key generation algorithm KGen matches the key generation algorithm of the KEM being modified.
    \item The random generation algorithm KCom generates a random value, according to the distribution branded by the Encaps algorithm of the KEM mechanism (i.e. Gen) and generates a commitment of it (i.e. Com).
    \item The encapsulation algorithm Encaps*, provided a public key pk and the secret element generated by the Com function, uses the given entropy as value to be encapsulated, according to the Encaps function of the KEM scheme.
    \item  The deterministic decapsulation algorithm Decaps* matches the Decaps function of the KEM being modified, and it also outputs the secret value that conforms the final key.
\end{itemize}
Therefore, a 3-pass protocol based on the above KEM$_{commit}$ definition goes as follows:
\begin{itemize}
    \item First, the responder generates a secret value, according to the underlying distribution of the KEM scheme selected, calculates its commitment value and sends it to the initiator.
    \item The initiator stores this value and generates a key pair ($\sk$, $\pk$) and sends its public key value to the responder.
    \item The responder, upon reception of the public key value of the initiator, executes the Encaps* function on the public key received and the secret value generated at the beginning of the process. Then, the responder sends the encapsulation generated (which contains the secret value committed), along with any additional opening value required to open the commitment.
    \item The initiator verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the Decaps function, and its corresponding session entropy.
\end{itemize}
\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEM$_{commit}$-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> (c, d) \sample \texttt{Com} (x) \\
     \> \sendmessageleft{top=c} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) \sample \texttt{Encaps$^*$}(\pk, x) \\ 
     \> \> d_{add} = d\setminus\{x\} \\
     \> \> ct_{d} \sample \texttt{Enc}(\pk, d_{add}) \\ 
     \> \> Entropy = \texttt{G}(\pk, c, K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     d_{add}' = \texttt{Dec}(\sk, ct_d) \> \> \\
     x' = Open(c, d_{add}' \cup \{x\}) \> \> \\
     (x, K) = \texttt{Decaps$^*$}(\sk, ct) \> \> \\ 
     \texttt{Abort if x $\neq$ x'} \> \> \\ 
     Entropy = \texttt{G}(\pk, c, K)}
\end{pchstack}
\textbf{Definition 4.2} (IND-atk KEM$_{commit}$-based protocol) We define the IND-\textit{atk}, $atk \in \{\texttt{CPA}, \texttt{CCA}\}$ game as in the figure below and the IND-\textit{atk} advantage of an adversary $\mathcal{A}$ against the above KEM$_{commit}$-based protocol as 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$_{commit}$}} := \abs{\prob{\texttt{IND-atk} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_2$: IND-CPA \pcbox{CCA}}{\phantomsection\label{mygame}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)) \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{ Encaps^*, \pcbox{Decaps}}(\pk, ct^*, K_b^*, ct_{d}, c) \\
      \pcreturn b = b'
    }}
  \begin{pcvstack}

  \procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\tau$} \\
        else \\
        \text{ return \texttt{Decaps}(sk,ct)}
   }
  \procedure[linenumbering] {Oracle $Encaps^*$}{%
         x \sample \texttt{Gen}(\secparam) \\
        (d(x),c(x)) \sample \texttt{Com}(x) \\
        (ct, K^*) = \texttt{Encaps$^*$}(\pk, x)
   }
  \end{pcvstack}
\end{pchstack}
With the above definition, it is clear that the IND-\textit{atk} security of the constructed scheme is directly dependant upon the IND-\textit{atk} security of the KEM scheme and the hiding property of the commit function of the commitment scheme. \vspace{2mm}\\
\textbf{Theorem 4.3}: Let KEM$^*$ := (KGen, KCom, Encaps$^*$, Decaps$^*$) be a KEM$_{commit}$-based scheme. Then, the scheme is IND-\textit{atk} secure, assuming that the underlying KEM scheme is IND-\textit{atk} secure, the commit function satisfies the hiding property, and provided that the encryption scheme of the additional opening data is IND-CPA secure. Furthermore, 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$^*$}} \leq \advantage{\texttt{IND-atk}}{\texttt{KEM}} + 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})  \\
\end{align*}
\begin{proof}
We define the intermediate games G$_0$ and G$_1$:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G0}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}}(\pk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}
    
  {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G1}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}, Encaps^*}(\pk, ct^*, K_b^*, c(x^*)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
The Game G$_0$ represents the IND-atk security of the KEM protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-atk}}{\texttt{KEM}}
\end{align*}
Additionally, the intermediate game G$_1$ adds the commit value to the information available to the adversary. Therefore, the value $\abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$
represents the advantage in breaking the IND-atk security of KEM provided by the commit value of x$^*$ which, as the underlying commitment scheme satisfies the hiding property, it will always be bounded by the advantage provided in breaking the IND-CPA hiding security of the commitment (as this advantage represents the 'extra' information leaked by the commit function). Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{commit}$ is defined by:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_{commit}$}{\phantomsection\label{Gcommitx}
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      c(x^*) \sample \texttt{Com}(x^*)  \\
      b' \sample \adv(c(x^*), K_b^*) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{commit}'$}{\phantomsection\label{Gcommit'}
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv(c(x_b), K_b) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{committrue}$}{\phantomsection\label{Gcommittrue}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
To prove it, let us consider the event that knowing the commit of the secret value produces an improvement over a random guess (whose probability is twice the advantage in the game G$_{commit}$). If is not satisfied, the games G$_0$ and G$_1$ are equivalent and consequently the difference lemma can be applied \cite{cryptoeprint:2004/332}, arriving to the desired relation. \\
The game G$_{commit}$ is actually equivalent to G$_{commit}'$, as the result of applying \textbf{H}, modeled as a random oracle, to a uniform sampled value is equivalent to directly sampling $K_1$. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}} = \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
And this game is trivially harder than the game G$_{committrue}$, as being in possession of the tuple (x$_0$, x$_1$) makes it clearly easier to solve (same objective with additional information). This last game is in turn the precise definition of the hiding property of the commitment scheme. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}} \leq \abs{\prob{\texttt{G$_{committrue}$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
Together, we have:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
\vspace{2mm} \\
On the other hand, the game G$_2$ represents the IND-CCA security of the KEM$^*$ protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CCA}}{\texttt{KEM$^*$}}
\end{align*}
and, consequently, the value $\abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage in breaking the IND-CCA security of KEM$^*$ provided by the encrypted opening information shared. This value is bounded by the advantage provided in breaking the IND-CPA security of the encryption scheme (as this advantage represents the 'extra' information leaked by the commit function) and the advantage of knowing the opening, together with the commitment. Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{opening}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{opening}$ is defined by:
\begin{pchstack}[boxed, center, space=1em]
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}$}{\phantomsection\label{Gopening}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      (c(x^*), d(x^*)) \sample \texttt{Com}(x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)\setminus\{x^*\}) \\
      b' \sample \adv^{\oracle}(ct_{d}, K_b^*, \pk) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{openingtrue}$}{\phantomsection\label{Gopeningtrue}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2^{\oracle}(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
  \end{pcvstack}
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}'$}{\phantomsection\label{Gopening'}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv^{\oracle}(K_b, ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
    \procedure[linenumbering] {Oracle $\oracle(d)$}{%
        \text{return \texttt{Info}(d, c(x$^*$))}
   }
  \end{pcvstack}
\end{pchstack}
To prove it, a similar argument to the one before can be applied first to reach the bound 
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} 
\end{align*}
considering the difference lemma event as the event that knowing the encrypted opening provides an advantage over a random guess (whose probability is twice the advantage in the game G$_{opening}$). \vspace{2mm} \\
The advantage against the game G$_{openingtrue}$ (and, consequently, over the intermediate game G$_1$, against the IND-atk security of the KEM$^*$ scheme) would come from being able to extract information about the opening from its encryption and, simultaneously, that such information, when put together with the commitment (represented by the oracle $\oracle$), reveals information about the secret value that allows to elaborate on the guess. Formally: 
\begin{align*}
     \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}
\end{align*}
where the value $\advantage{\texttt{IND-CPA}}{\texttt{Opening}}$ is defined as the advantage in winning the game G$_{aux-open}$: 
\begin{pchstack}[boxed, center, space=1em]
       {\procedure[linenumbering]{Game G$_{aux-open}$}{\phantomsection\label{Gclearopening}
          (x_0, x_1) \sample \adv_1 (\secparam)  \\
          b \sample \bin  \\
          (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
          (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
          b' \sample \adv_2^{\oracle}(d(x_b)\setminus\{x_b\}) \\
          \pcreturn b = b'
        }}
        \procedure[linenumbering] {Oracle $\oracle(d)$}{%
            \text{return \texttt{Info}(d, c(x$_b$))}
       }
\end{pchstack}
\begin{align*}
    \advantage{\texttt{IND-CPA}}{\texttt{Opening}} := \abs{\prob{\texttt{G$_{aux-open}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
For the product above, let us consider the event E$_{openingtrue}$ of winning the game G$_{openingtrue}$, with an advantage over the random guess, as the intersection of the two events E$_{enc}$ and E$_{opening}$ defined above. That is: the event that knowing the encryption of the opening provides an advantage in distinguishing over the random guess, and the event that this information, when paired with the commitment, provides a significant advantage in distinguishing over a random guess.

The probability of the event E$_{openingtrue}$ (which is twice the advantage of the game G$_{openingtrue}$) is then the probability of the intersection of the two events, which is determined by the formula $$P(E_{enc}) \cdot P(E_{opening}|E_{enc})$$ in which both terms are twice the advantage against the following games, respectively:
\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_{aux1}$}{\phantomsection\label{Genc}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
   {\procedure[linenumbering]{Game G$_{aux2}$}{\phantomsection\label{Gopeningaux}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      \alpha \sample \adv_2(ct_d) \\
      b' \sample \adv_3^{\oracle}(\alpha) \\
      \pcreturn b = b'
    }}
\end{pchstack}
It is clear that this games are harder that the games G$_{ind-cpa}$ and G$_{aux-open}$, respectively:
\begin{itemize}
    \item In the first one the adversary does not directly chooses which plaintexts will be ciphered.
    \item The second game, the adversary is provided with information about the opening value provided by successfully breaking the game G$_{aux1}$, but this advantage can only be as good as the opening value itself, which is known in the game G$_{aux-open}$.
\end{itemize}
Therefore arriving to the required bound:
\begin{align*}
    2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} = P(E_{enc}) \cdot P(E_{opening}|E_{enc}) = \\
    (2 \cdot \abs{\prob{\texttt{G$_{aux1}$} \Rightarrow 1} - \frac{1}{2}}) \cdot (2 \cdot \abs{\prob{\texttt{G$_{aux2}$} \Rightarrow 1} - \frac{1}{2}}) \leq
    (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}}) \cdot (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})
\end{align*}
\vspace{5mm} \\
All together, this means that 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$^*$}} = \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}) +  2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + \advantage{\texttt{IND-atk}}{\texttt{KEM}}
\end{align*}
\end{proof} 
As discussed in Section \ref{4.2.1}, two scenarios could be considered, in the hypothesis around the opening value of theorem 4.3:
\begin{enumerate}
    \item The opening value, without the actual committed value, does not divulge any information about the value even when paired with the Commit value. Then the advantage of extracting information about the committed value (and thus about the key) is negligible and the protocol verifies Theorem 4.3, without requirement about encrypted opening.
    \item The opening value without the committed value divulges information about the committed value, when paired with the commitment, or the committed value is npt part of the opening. Then, the opening value would be required to be encrypted, with an encryption scheme that satisfies it is IND-CPA secure. Then, the protocol verifies Theorem 4.3.
\end{enumerate}
Note that the reductions applied to prove the advantage's bound explicitly show the difficulties of an attacker against the modified KEM scheme defined, as it doesn't know the secret value used to derive the key and therefore its commitment might prove even harder to crack, and the same with the opening values chosen to generate such commitment.
\subsection*{A.3: Security}
The advantage of committing to a precise value of the secret element used to derive the shared key is clear: The attack against the 2-pass KEM-based protocol exploited the fact that an attacker could encapsulate different instances of this secret element (which, in turn, generates different encapsulation and shared key values) until one produces a combination that yields the same session entropy value generated by the responder.
With the inclusion of a commitment scheme around this secret element, the biding property of the scheme ensures that an attacker's ability to generate a different instance such that the commitment value made by the responder matches the one generated by them is negligible. Therefore, the value of the secret key is determined when sending the commit value and, consequently, fixing yet another value that conforms the entropy session.

We now give a sketch of the formal proof the SK-security of this protocol in our UM model:\\
\textbf{Proposition:} The above protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the Hiding and Binding security properties, and the KEM-commit scheme is IND-CPA secure. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq \advantage{\texttt{IND-CPA}}{\texttt{KEM-commit}}[] + l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
\end{align*}
\begin{proof}
    As with the 3-pass KEM-based proof, we can directly apply the bulk of the proof of Theorem 2 in \cite{cryptoeprint:2023/167} to prove the required bound: \\
    As such, we have 
    \begin{align*}
        Pr[U \: \texttt{wins}] \leq P[A \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where U is an adversary against the protocol in the UM, A is an adversary against the same protocol, but in the AM, and forge is the event that U successfully sends a message \textit{m} to some party $P_j$ from $P_i$ but $P_i$ never sent that message. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(U)] \leq \advantage{SK}{\pi}[(A)] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(A)]$  was proven in \cite{cryptoeprint:2023/167} to be bounded by the IND-CPA security of the underlying KEM procedure, times the square of the number of parties and the maximum number of session executed between any two parties. Even though we are considering now a modified KEM procedure, the proof remains the same.  
    
    Then we just need to give a bound on the probability of the event 'forge'.\vspace{2mm} \\
    This probability, for any fixed tuple $(P_i, P_j, m)$ is modeled by the game G$_{ent-com}$: 
    \begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Game G$_{ent-com}$}{\phantomsection\label{3pkemCScom}
          x \sample \texttt{Gen}() \\
          (c,d) \sample \texttt{Com(x)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{$Encaps^*$}(\pk^*, x) \\
          d_{add} = d\setminus\{x\} \\
          ct_{d} \sample \texttt{Enc}(\pk^*, d_{add}) \\ 
          v_1 = O(\pk^*, c, K) \\
          (ct_d^*, ct^*) \sample \adv_3^O(c, ct_d, ct, \pk) \\
          d_{add}' = \texttt{Dec}(\sk, ct_d^*) \\
          x' = Open(c^*, d_{add}' \cup \{x\}) \\
          (K^*, x') = \texttt{$Decaps^*$}(ct^*, \sk) \\
          v_2 = O(\pk, c^*, K^*) \\
          \pcreturn (v_1 = v_2) \wedge (v_i \neq \bot)
        }}
      {\procedure[linenumbering]{Game G$_2$}{\phantomsection\label{3pkemCScomaux}
          x \sample \texttt{Gen}() \\
          (c,d) \sample \texttt{Com(x)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{$Encaps^*$}(\pk^*, x) \\
          d_{add} = d\setminus\{x\} \\
          ct_{d} \sample \texttt{Enc}(\pk^*, d_{add}) \\ 
          v_1 = O(\pk^*, c, x) \\
          (ct_d^*, ct^*) \sample \adv_3^O(c, ct_d, ct, \pk) \\
          d_{add}' = \texttt{Dec}(\sk, ct_d^*) \\
          x' = Open(c^*, d_{add}' \cup \{x\}) \\
          (K^*, x') = \texttt{$Decaps^*$}(ct^*, \sk) \\
          v_2 = O(\pk, c^*, x') \\
          \pcreturn (v_1 = v_2) \wedge (v_i \neq \bot)
        }}
    \end{pchstack}
    This game is extremely similar to the one defined to prove the authenticator property of the CS MT defined above, but only adding the elements pertaining to the KEM procedures. The only major difference is the presence of the derived key in the entropy calculation, as opposed to the \textit{x} secret value that should be present to mimic the CS MT proof. Under the supposition $K = O(\pk, x)$, this game is actually equivalent to game $G_2$. \vspace{2mm} \\
    Since the encapsulation value do not influence the final 'entropy' values generated, and the public key value can be considered as a random element drawn (in the same way as the equivalent nonce is drawn in the proof of CS MT), the proof described there applies here, with only modifying the games accordingly. Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
    \end{align*}

    And then, since this bound happens for any adversary U in the UM, we have that the above protocol is SK-secure in the UM model.
\end{proof}

We note two aspects that might have gone unnoticed in the above proof: first, the supposition regarding the way the shared key is derived. This supposition might seem restrictive at first, but it is only the natural construction in most KEM construction in consideration nowadays. 

The second deals with the implicit verification of matching secrets by the inititator at the end of the procedure. We can suppose this elements are actually equal, since the game (and therefore the proof) deals with 'completed sessions' and a inequality between those values yields a null session. Note that, were this verification not happening, the protocol would not be SK-secure, as the commitment would not be effectively playing any role in the key derivation.

\subsection*{A.4: Practical instance}
We propose a practical instance of the 3-pass KEM based protocol idea described above, with an IND-CCA KEM instance based upon an IND-CPA PKE scheme that is de-randomized inside the encapsulate procedure, combined with a commitment scheme based upon a collision-resistant hash function: \vspace{4mm}

\begin{pchstack}[boxed, center, space=1em]
    \procedure{Example 3-pass KEM$_{commit}$-based protocol instance}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> m \sample \texttt{\{0,1\}$^n$} \\
     \> \> c(x) = H(x||m) \\
     \> \sendmessageleft{top=c(x)} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) = \texttt{Encaps}(\pk, x) \\ 
     \> \> ct_{d} \sample \texttt{Enc}_{\text{PKE}}(\pk, m) \\
     \> \> Entropy = \texttt{G}(p_k, c(x), K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     m' = \texttt{Dec}_{\text{PKE}}(\sk, ct_d) \> \> \\
     (x', K) = \texttt{Decaps}(\sk, ct) \> \> \\ 
     \texttt{Abort if H(x'||m') $\neq$ c(x)} \> \> \\
     Entropy = \texttt{G}(p_k, c(x), K)}
\end{pchstack}
A plausible algorithm selection could be the NIST's selection for PQC-KEM standardization, CRYSTALS-Kyber \cite{conf/eurosp/BosDKLLSSSS18}, which satisfies that its underlying PKE is IND-CPA, and any collision resistant hash function, with an appropriate output length.

\section*{B: Optimizing the 4-pass KEM-based protocol in the UM}
From the 2-pass KEM-based secure protocol in the AM, and the compiler $C_\lambda$ based on the CS-based MT authenticator we have the following (unoptimized) protocol, formed by 3 $\cdot$ 2 = 6 messages: \vspace{2mm} \\
The first three messages are the MT-authentication of the message \textit{m} (along with the inclusion of extra element $\pk$ sent on the first message) sent by the initiator, and we define this exchange as $\lambda_I$. The second part of the exchange amounts to the MT-authentication of element \textit{ct} sent by the responder, and we define this exchange as $\lambda_R$. Then
\begin{itemize}
    \item Sending together 2º message of $\lambda_I$ with the 1º message of $\lambda_R$ as the second message of the protocol, and
    \item Sending the 3º message of $\lambda_I$ with the 2º of $\lambda_R$ as the 3º message of the protocol.
\end{itemize}
we have the optimized 4-pass protocol.
\begin{pchstack}[boxed, center, space=1em]
    \procedure{6-pass KEM-based protocol (unoptimized)}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     m \sample \texttt{\{0,1\}$^n$} \> \> \\
    (d(m), c(m)) \sample \texttt{Com}(m) \> \> \\
     \> \sendmessageright{top=\texttt{(\pk, c(m))}} \> \\
     \> \>  N_B \sample \texttt{\{0,1\}$^n$} \\
     \> \sendmessageleft{top=\texttt{$N_B$}} \> \\
     Entropy_A = \texttt{G}(\pk, m, c(m), N_B) \> \> \\
     \> \sendmessageright{top=\texttt{d(m)}} \> \\
     \> \> m' = Open(c(m), d(m)) \\
     \> \> Entropy_A = \texttt{G}(\pk, m', c(m), N_B) \> \> \pclb
     \pcintertext[dotted]{$\lambda_I - \lambda_R$ division} \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\ 
     \> \> (d(ct), c(ct)) \sample \texttt{Com} (ct) \\
     \> \sendmessageleft{top=\texttt{c(ct)}} \> \\ 
      N_A \sample \texttt{\{0,1\}$^n$} \> \> \\
     \> \sendmessageright{top=\texttt{$N_A$}} \> \\ 
     \> \> Entropy_B = \texttt{G}(ct, c(ct), N_A) \> \> \\ 
     \> \sendmessageleft{top=\texttt{d(ct)}} \> \\ 
     ct' = Open(c(ct), d(ct)) \> \> \\
     K = \texttt{Decaps}(\sk, ct) \> \> \\
     Entropy_B = \texttt{G}(ct, c(ct), N_A)}
\end{pchstack}
Despite reordering some messages, all the 'local' orders between authentication elements are respected: no challenge is unveiled before the commitment of the element they are challenging, and no opening is sent before is associated commitment. \vspace{2mm} \\
The actual 2-pass KEM-based protocol used as base for constructing this 4-pass protocol is not exactly the one defined above, but rather an 'artificial' modification in which two messages are transmitted on the first iteration (so that, once the compiler is applied, only one of them is actually committed, but both of them contribute to the entropy value). This is however perfectly valid, since we can add any value transmitted in the first or second message of the CS MT-authenticator without any repercussion to the validity of the authenticator. \\
It is easy to prove that any additional value included in the entropy value that is sent on the first two messages of the CS-based MT-authenticator still produces a valid MT-authenticator, as in this two messages, there are still values under the protection of the hiding property of the CS and therefore not all information is available to an attacker. \\
With this in mind, the SK-security of the 4-pass KEM-based protocol on the UM is a direct application of Theorem 3.5.


\section*{C: Proof of SK-security of the 3-pass protocols in the UM}
In this section, we provide the direct proofs of the SK-security of the 3-pass based protocols described above.

\subsection*{C.1: Proof 3-pass KEX-based protocol}

\textbf{Proposition 4.1} The 3-pass DH-based protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the hiding and binding security properties, and the DDH assumption. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq l \cdot (\advantage{\texttt{DDH}}{\texttt{DH}}[] + \advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
\end{align*}
\begin{proof}
    We can directly apply the bulk of the proof of Theorem 2 in \cite{cryptoeprint:2023/167} to prove the required bound, since the only use of $\pi' = C_\lambda(\pi)$ is to define the distinguisher's advantage as $\pi'$ $\epsilon$-emulation of $\pi$ in the UM, which is of no interest in this proof. \\
    As such, we have 
    \begin{align*}
        Pr[U \: \texttt{wins}] \leq P[A \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where U is an adversary against the protocol in the UM, A is an adversary against the same protocol, but in the AM, and forge is the event that U successfully sends a message \textit{m} to some party $P_j$ from $P_i$ but $P_i$ never sent that message. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(U)] \leq \advantage{SK}{\pi}[(A)] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(A)]$, when taking into consideration that any additional elements not pertaining to the natural DH setting do not influence any generation, was proven in \cite{10.1007/3-540-44987-6_28} to be bounded by the DDH assumption, times the square of the number of parties and the maximum number of session executed between any two parties. Then we just need to give a bound on the probability of the event 'forge'. \vspace{2mm} \\
    This probability, for any fixed tuple $(P_i, P_j, m)$ is modeled by the game G$_{DH}$. We also define, for the sake of the proof, the intermediate games $G_0$ and $G_1$:
    \begin{pchstack}[ boxed , center, space=1em]
      {\procedure[linenumbering]{Game G$_{DH}$}{\phantomsection\label{3pkDHCS}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          g^{a^*} \sample \adv_2^O(c, g^a) \\
          K = (g^{a^*})^b = g^{ba^*} \\
          v_1 = O(c, g^{a^*}, g^b) \\
          d^* \sample \adv_3^O(c, g^b, d) \\
          g^{b^*} = \texttt{Open}(c^*, d^*) \\
          K^* = (g^{b^*})^a  = g^{ab^*} \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G02}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          g^{a^*} \sample \adv_2^O(c, g^a) \\
          K = (g^{a^*})^b = g^{ba^*} \\
          v_1 = O(c, g^{a^*}, g^b) \\
          g^{b^*} = \texttt{Open}(c^*, d) \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G12}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          K = (g^a)^b = g^{ba} \\
          v_1 = O(c, g^a, g^b) \\
          g^{b^*} = \texttt{Open}(c^*, d) \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange. \\
    Therefore, the value $\abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain public key value $g^a$, we are able to generate (d, $d^*$) openings such that both are valid openings of different public keys $g^a$,  $g^{a^*}$ when put together with the commitment c, whose probability is modeled by the advantage of the game $G_{Binding^*}$. If it is not satisfied, the games $G_{DH}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{align*}
        \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value c, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the commitment value received by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain value $g^{b}$, we are able to extract information about the value $g^{b}$, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the value $g^{b}$, the attacker is unable to obtain enough information to elaborate of a guess of $g^{a^*}$ to provoke a collision and being able to modify the value is not an advantage. Consequently, the difference lemma can be applied, and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value c, which is $\frac{1}{2^{n_e}}$. \vspace{2mm}\\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}}
    \end{align*}
     Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
    \end{align*}

    This proves part 2) of the definition of SK-security. We still have to show 1), that is, that two uncorrupted parties who run the protocol honestly get, if their respective session are completed , the same derived key, expect with negligible probability. But this follows from the proof above, as 2) shows that except with negligible probability, an attacker is not able to successfully modify the public key values exchanged between two parties. And, since the key derived is determined by those values, we get that except with (the same) negligible probability, the final key derived in two completed and matching sessions is the same.

    And then, since this bound happens for any adversary U in the UM, we have that the above protocol is SK-secure in the UM model.
\end{proof}

\textbf{Note:} The end of the proof shows that we could actually include the derived key \textit{K} as part of the values that conform the opening, since its determinism in the generation from the public key values does not open any possibilities for an attacker to exploit.

\subsection*{C.2: Proof 3-pass KEM-based protocol}

\textbf{Proposition 5.1:} The 3-pass KEM-based protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the Hiding and Binding security properties, and the KEM scheme is IND-CPA secure. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq l \cdot (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{KEM}}[] + \advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e - 1}})
\end{align*}
\begin{proof}
    as in the above proof, we can directly apply the bulk of the proof of Theorem 2 in \cite{cryptoeprint:2023/167} to prove the required bound: \\
    As such, we have 
    \begin{align*}
        Pr[U \: \texttt{wins}] \leq P[A \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where U is an adversary against the protocol in the UM, A is an adversary against the same protocol, but in the AM, and forge is the event that U successfully sends a message \textit{m} to some party $P_j$ from $P_i$ but $P_i$ never sent that message. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(U)] \leq \advantage{SK}{\pi}[(A)] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(A)]$, when taking into consideration that any additional elements not pertaining to the natural KEM setting do not influence any generation, was proven in \cite{cryptoeprint:2023/167} to be bounded by the IND-CPA security if the KEM procedure, times the square of the number of parties and the maximum number of session executed between any two parties. Then we just need to give a bound on the probability of the event 'forge'. \vspace{2mm} \\
    In this case, we distinguish two different events: the probability that an attacker successfully modifies the values \textit{$\pk$}, \textit{c} or \textit{d}, and the probability that an attacker successfully modifies \textit{ct}. 
    The first probability, for any fixed tuple $(P_i, P_j, m)$ is modeled by the game G$_{KEM}$. We also define the intermediate games $G_0$ and $G_1$:
    \begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Game G$_{KEM}$}{\phantomsection\label{3pkemCS2}
          N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{Encaps}(\pk^*) \\
          v_1 = O(c, \pk^*, N) \\
          d^* \sample \adv_3^O(c, N, d, ct) \\
          N^* = \texttt{Open}(c^*, d^*) \\
          K = \texttt{Decaps}(ct, \sk) \\
          v_2 = O(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G01}
           N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{Encaps}(\pk^*) \\
          v_1 = O(c, \pk^*, N) \\
          N^* = \texttt{Open}(c^*, d) \\
          K \sample \texttt{Decaps}(\sk, ct) \\
          v_2 = O(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G11}
           N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          (ct, K) \sample \texttt{Encaps}(\pk) \\
          v_1 = O(c, \pk, N) \\
          N^* = \texttt{Open}(c^*, d) \\
          K \sample \texttt{Decaps}(\sk, ct) \\
          v_2 = O(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange. \\
    Therefore, the value $\abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain random value \textit{N}, we are able to generate (d, $d^*$) openings such that both are valid openings of different random values \textit{N}, \textit{$N^*$} when put together with the commitment c, whose probability is modeled by the advantage of the game $G_{Binding^*}$. If it is not satisfied, the games $G_{KEM}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{align*}
        \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value c, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the public key value sent by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain random value \textit{N} we are able to extract information about such value, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the random value \textit{N}, the attacker is unable to obtain enough information to elaborate on an alternative public key value to $\pk$ that provokes a collision, and being able to modify the public key is not an advantage. Consequently, the difference lemma can be applied, and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value c, which is $\frac{1}{2^{n_e}}$. \vspace{2mm}\\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}}
    \end{align*} \vspace{2mm}
    
    The second probability is branched depending on the probability of successfully modifying the public key value exchanged before. That is 
    \begin{align*}
        & P[\texttt{forge ct}] = \\ 
        & P[\texttt{forge ct} | \texttt{forge $\pk$}] \cdot P[\texttt{forge $\pk$}] + P[\texttt{forge ct} |\neg \texttt{forge $\pk$}] \cdot P[\neg \texttt{forge $\pk$}]
    \end{align*}
    If a successful forge of the $\pk$ value happens, the probability of forging \textit{ct} is 1. If this event does not happens, the success in forging \textit{ct} is tied to the information about the derived key K obtain from examining the \textit{ct} value, which will always by (strictly) bounded by the passive indistinguishability of the KEM procedure, plus the probability of a random collision. Then, the probability of the event 'forge $\pk$' is bounded by the advantage of the above game. All together, this means 
    \begin{align*}
        & P[\texttt{forge ct}] = \\ 
        & P[\texttt{forge ct} | \texttt{forge $\pk$}] \cdot P[\texttt{forge $\pk$}] + P[\texttt{forge ct} |\neg \texttt{forge $\pk$}] \cdot P[\neg \texttt{forge $\pk$}] = \\
        & P[\texttt{forge $\pk$}] + (\advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \frac{1}{2^{n_e}}) \cdot P[\neg \texttt{forge $\pk$}] < \\
        & \advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}
    \end{align*}
    The probability of the intersection is best analyzed when dividing the event of modifying c, N or $\pk$ into two disjoint sub-events: the event that $\pk$ does not get modified and the event that it does, respectively. With this consideration, we have 
    \begin{align*}
        Pr[A \cap B] = Pr[(A_1 \cup A_2) \cap B] = Pr[A_1 \cap B] + Pr[A_2 \cap B] = Pr[A_1 \cap B] + Pr[A_2] 
    \end{align*}
    as $A_2 \subseteq B$. The first term is negligible in comparison, as is formed by product of advantages. The second term is formed by the advantage against the game $G_{KEM}$, as modifying $\pk$ can be achieved by breaking either first the hiding property and then modifying the value, or modifying the value first and then breaking the binding property, plus the random collision probability. With this, we have:
    \begin{align*}
        Pr[A \cap B] = Pr[A_1 \cap B] + Pr[A_2] > \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e}}
    \end{align*}
    Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] < l \cdot (\advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e - 1}})
    \end{align*}
    
    This proves part 2) of the definition of SK-security. We still have to show 1), that is, that two uncorrupted parties who run the protocol honestly get, if their respective session are completed , the same derived key, expect with negligible probability. But this follows from the proof above, as 2) shows that except with negligible probability, an attacker is not able to successfully modify the initator's encapsulation value. And, since the key derived is determined by this values, we get that except with (the same) negligible probability, the final key derived in two completed and matching sessions is the same.
    
    Then, since this bound happens for any adversary U in the UM, we have that the above protocol is SK-secure in the UM model, with the desired bound.
\end{proof}
\textbf{Note:} The achieved bound represents a very conservative security reduction and provides the attacker with more 'possibilities' than the real model actually represents. This is done in order to simplify the proof as much as possible.

\end{document}
