\documentclass[11pt,twoside]{article}
\usepackage[english]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[top = 3cm ,bottom = 3cm,left= 3cm,right = 3cm]{geometry}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{typicons}
\usepackage{marvosym}
\usepackage{lipsum}
\usepackage{soul,color}
\usepackage{fancyhdr}
\usepackage{authblk}
\usepackage [
n,
advantage,
operators,
sets,
adversary,
landau,
probability,
notions,
logic,
ff,
mm,
primitives,
events,
complexity,
oracles,
asymptotics,
keys
]{cryptocode}
\createprocedureblock{game}{center,boxed}{}{}{}
\usepackage{lipsum}

\renewcommand{\pcadvantagename }{\mathsf{Adv}}
\renewcommand{\pcadvantagesuperstyle}[1]{\mathrm{{#1}}}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}

\DeclareRobustCommand{\hlred}[1]{{\sethlcolor{red}\hl{#1}}}
\DeclareRobustCommand{\hlor}[1]{{\sethlcolor{orange}\hl{#1}}}

\usepackage{float}
\floatstyle{ruled} % Defines the "rule" style for next environments defined using newfloat.
\newfloat{protocol}{htb!}{Protocol}

\usepackage{hyperref}
\usepackage{cleveref}
\crefname{protocol}{Protocol}{Protocols}
\Crefname{protocol}{Protocol}{Protocols}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE]{\title{Provably Secure CS-based Protocols over Unauthenticated Channels}}
\fancyhead[LO]{\author{Rodrigo Martín Sánchez-Ledesma \textit{et al.}}}
\fancyfoot[C]{\thepage}

\setlength{\headheight}{13.59999pt}

\raggedbottom

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\title{Provably Secure Commitment-based Protocols over Unauthenticated Channels}
\author[3]{\rm Iván Blanco Chacón}
\author[2]{\rm David Domingo Martín}
\author[1]{Ignacio Luengo Velasco}
\author[1,2]{\rm Rodrigo Martín Sánchez-Ledesma \Letter}
\affil[1]{Universidad Complutense de Madrid}
\affil[ ]{\texttt {rodrma01@ucm.es}}
\affil[2]{Indra Sistemas de Comunicaciones Seguras S.A}
\affil[ ]{\texttt {\{rmsanchezledesma, ddomingo\}@indra.es}}
\affil[3]{Universidad de Alcalá}
\affil[ ]{\texttt {ivan.blancoc@uah.es}}
\date{September 30th, 2024}

\begin{document}

\maketitle
\begin{abstract}
In this work we construct an alternative \textit{Unauthenticated Model}, intended to build a theoretic security framework to cover communications protocols whose characteristics may not always concur with the specifics of already existing models for authenticated exchanges. This model is constructed from the notion of commitment schemes, employing ephemeral information, therefore avoiding the exchange of long-term cryptographic material. From this model, we propose a number of Commitment-based protocols to establish a shared secret between two parties, and study their resistance over unauthenticated channels. This means analyzing the security of the protocol itself, and its robustness against Man-in-the-Middle attacks, by formalizing their security under this  model. The key-exchange protocols are constructed from KEX and KEM primitives, to show that this model can be applied to both established and new paradigms. We highlight the differences that arise naturally, due to the nature of KEM constructions, in terms of the protocol itself and the types of attacks that they are subject to. We provide practical go-to protocols instances to migrate to, both for KEM-based and KEX-based cryptographic primitives.
\end{abstract}
\textbf{Keywords}: Authentication, Protocol, KEM, Commitment

\section{Introduction}

Secure key exchange protocols are a fundamental part of cryptography and perhaps one of the most important paradigms in asymmetric cryptography. This kind of protocols allows two parties, without the need of any previous common knowledge of any shared information, to be in possession of a shared secret. This secret is then usually used to encrypt the information transmitted from one to another, by means of  symmetric cryptography \cite{doi:10.1137/S0097539702403773}. It is therefore imperative that these protocols are secure and provide assurance that, at the end of it, the generated shared secret is only known by the two parties involved.

The paradigm of safely exchanging message over unreliable channel has been object of study for a long time: first, trying to model the paradigm, then coming up with solutions within this model. Among them, we highlight \cite{10.1007/3-540-44987-6_28,cryptoeprint:1998/009}, which provide a complete solution for modeling the differences between reliable (i.e. authenticated) and unreliable (i.e. unauthenticated) channels, and proving the security of protocols, which include key agreement protocols, in the latter, and how to construct them from protocols on the former.

Currently, secure key exchange protocols are mostly based on KEX-type solutions like Diffie-Hellman variants (DH, ECDH, ...) and similar algorithms. In the 90's, a series of quantum algorithms were published, including Shor's algorithm \cite{Shor_1997}, that were shown to effectively solve the mathematical problems behind most public-key cryptography algorithms, like the discrete logarithm problem or the factorization of integers problem. These critical findings, along with the practical advance on the development of quantum computers and the difficulty and cost of such a migration, forced the cryptography community to start looking for alternatives that are resistant to quantum computing. In this scenario, in 2016, the National Institute for Standards and Technologies (NIST) announced the launch of a process, with the objective of coming together with quantum-resistant cryptographic solutions for public-key cryptography needs, specifically suitable digital signature and key establishment. With regards to key establishment, the call specified that looked for Key Encapsulation Mechanisms specifications, which not only are efficient and versatile but also easy to derive from weaker Public Key Encryption algorithms, based on transformations such as Fujisaki-Okamoto and variants \cite{10.1007/978-3-319-70500-2_12,10.1007/978-3-540-40974-8_12}.

Based on the wide spread of KEX-based protocols, it is important that quantum-resistant Key Establishment schemes are as little disruptive as possible, to facilitate their early adoption, in an attempt to minimize the currently protected information that becomes vulnerable once Cryptographically Relevant Quantum Computers (CRQC) become available.

\subsection{Motivation}
The topic of secure protocols from KEX primitives over unauthenticated channels is far from new. The pioneer works of \cite{10.1007/3-540-44987-6_28} and \cite{cryptoeprint:1998/009} have been thoroughly studied and applied, and subsequent important works have been derived after, like \cite{10.1007/11535218_33,10.1007/978-3-540-75670-5_1}. Regarding protocols based on quantum-resistant primitives, there already exists works in the same direction. In \cite{10.1007/978-3-031-35486-1_24}, the authors expanded the unauthenticated model of \cite{10.1007/3-540-44987-6_28}, to consider authentication via KEM schemes, a critical step towards post-quantum secure protocols over unauthenticated channels.

In the original unauthenticated model of \cite{cryptoeprint:1998/009}, the authors present a model in which, intuitively, authentication is achieved by an initial authenticated exchange of cryptographic keys between the users which intend to communicate. Then, a number of techniques can be applied from these keys to provide the necessary authentication, even when the subsequent communications are performed over an insecure channel. This model builds a frame to construct secure and authenticated protocols to be performed over unauthenticated channels, if the steps of the model are followed. This means that an initial out-of-bound authenticated key exchange of long-term cryptographic keys is required for the protocol to have all its desirable properties. While this requirement remains the appropriate for a vast number of protocols, it could be an overkill in some other, e.g, among real-time secure communication protocols, in which the notion of a previous authenticated exchange between parties before this communication might not be common, specially when this notion of authenticated exchange usually involves present exchange between peers. \vspace{2mm} \\
The work presented here tries to address this situation, building an alternative model to the originally presented in \cite{10.1007/3-540-44987-6_28}, in which authentication is achieved not through an initial authenticated exchange of cryptographic material but rather of a final authenticated exchange of information derived from the cryptographic session established. This value will intuitively corroborated between parties before the communication starts, in an authenticated way.

In comparison, our model requires fewer public key operations to achieve authentication while eliminating the need for long-term secrets, at the expense of requiring and authentication exchange in each session established between peers, as opposed to a single cryptographic material exchange. 


\subsection{Our contributions}

Due to the concerns regarding \textit{quantum-resistant} cryptography, it is the objective of this work to come up with KEM-based protocols that are easy to adopt for solutions which already have in place a key establishment protocol based on quantum-vulnerable key exchange algorithms, while proving to be secure over unauthenticated channels, a necessary requirement in the vast majority of situations. This analysis includes considering the plausible presence of Man-in-the-Middle attackers, whose aim is to eavesdrop the communication between the two parties, by means of modifying the messages exchanged during the key establishment protocol, in a way its presence goes unnoticed.

We first construct a variation of the AKE model presented on \cite{cryptoeprint:1998/009}, which varies the way authentication is achieved, reducing the number of public key operation needed to obtain it. This authentication will be obtained by a secure verification of tampering within the exchange produced, once it is finished. The measures employed are expected to be simple and provide easy adoption within communication protocols. Most importantly, we will show that all properties and results obtained under the original model translates to our model, including those pertaining to key exchange protocols defined on \cite{10.1007/3-540-44987-6_28}. This model will be the base to generate and formally verify the protocols that will appear on this work.

Then, we analyze a number of KEX-based protocols for secure key establishment, breaking them by the number of messages exchanged. We show that applying the results from the modified AKE model, the protocols are shown to be secure under unreliable channels. We will also analyze how the specific nature of Key Encapsulation Mechanism forces more difficulties in order to come up with secure KEM-based key establishment protocols, and the measures needed to ensure their security. Lastly, we will specify a number of KEM-based protocols, using the same classification as above and their formal security under our new model.

Special focus will be put around the figure of a MitM: we will analyze the possibilities of such an attacker in KEX-based protocols and how to detect and avoid them, which will conform the base of the authentication measures of our model. Then we will see that the measures applied in this setting do not translate naturally to KEM-based protocols, under the same conditions, and what specific measures are required to block this kind of attacks, depending on the inherent conditions of the KEM in use. Despite the conceptual differences between the two paradigms, the measures under which our model will base the security over unreliable channels will be the same: along with the primary objective, which is to derive a shared secret key, the protocol will also generate another output, which will be referred to as \textit{session entropy}. This value will conceptually be a summary of the session between the two parties, as it will be directly inferred by the shared values used throughout the process. This value is important as it will determine whether the session has been successful or it has been tampered.

It is important to note that this model does not attempt to substitute the original, well-established authentication model originally presented in \cite{10.1007/3-540-44987-6_28}. This model is the standard paradigm in a great number of practical applications and protocols, all of which  can assume the presence of an out-of-bound authenticated exchange of cryptographic material (which, in practice, usually involves in-person exchange).

There are scenarios, however, in which this assumption might pose a requirement too big to be satisfied. It is under these scenarios under which we think or model could be of interest, as it makes no use of long-term cryptographic material to be authenticated. \\
At the very least, this model helps capture the intuition behind purely ephemeral-based approaches to AKE, and the kind of tools they might require. The protocols presented throughout this work rely heavily on the out-of-bound final authentication phase $I_f$ detailed in Section ref. 

The way such exchanges are performed, and what they might entail, will be dependent on each practical application of the presented model and are outside of the scope of this work. Nevertheless, we can name some simple examples: the use of biometric indicators or other identity-authentication tools that each application might provide, the presence of trusted third party identity providers, or the existence of authenticated channels only suitable for small chunks of information.

Any of these examples could be used as an authenticator of the information to be authenticated, which could be represented as short codes of some sort. This notion of short code authentication is already in use in a number of secure communications protocols, thus our modified model provides a theoretic security framework for instantiating these kind of protocols. \\
Note that, while the authentication phase presented in this work and in \cite{10.1007/3-540-44987-6_28} might seem relatively the same (and, up to a point, they are), there is one key difference: The elements to be authenticated, under \cite{10.1007/3-540-44987-6_28}, are purely of cryptographic nature, and therefore require to be processed by the application of protocol build upon the model. In the other hand, the elements exchanged under our model need not be cryptographic, and therefore can account for human-verifiable elements of authentication that do not require to be processed by the underlying protocol. This difference also opens up the possibilities for the way of exchanging the information.

\section{Preliminaries}

\begin{definition}
A public-key encryption scheme PKE = (KGen, Enc, Dec) consists of three algorithms and a
finite message space M. The key generation algorithm KGen outputs a key pair $(\pk, \sk)$, where pk also defines a randomness space R = R($\pk$). The encryption
algorithm Enc, on input $\pk$ and a message $\textit{m} \in M$, outputs an encryption c $\sample$ Enc($\pk$, \textit{m}) of \textit{m} under the public key $\pk$. If necessary, we make the used randomness of encryption explicit by writing \textit{c} := Enc(pk, \textit{m}; r), where r $\sample$ R and R is the randomness space. The decryption algorithm Dec, on input $\sk$ and a ciphertext \textit{c}, outputs either a message \textit{m} = Dec($\sk$, \textit{c}) $\in$ M or a special symbol $\bot \notin $ M to indicate that \textit{c} is not a valid ciphertext.
\end{definition}
\begin{definition}
A key encapsulation mechanism is a triple of algorithms KEM = (KGen, Encaps, Decaps). The key generation algorithm KGen generates a key pair $(\pk, \sk)$. The encapsulation algorithm Encaps, given a public key value $\pk$, outputs the pair (K, ct), where \textit{ct} is called the encapsulation of a random value \textit{x} that determines the shared key K. The deterministic decapsulation algorithm Decaps, given the secret key $\sk$ and the encapsulation, outputs the same key K by extracting the random value from the encapsulation \textit{ct}.
\end{definition}
\begin{definition}
(Indistinguishability against KEM scheme) We define the IND-\textit{atk} game, $atk \in \{CPA, CCA\}$ as in the figure below and the IND-\textit{atk} advantage of an adversary $\mathcal{A}$ against the above KEM scheme as 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM}}[(\mathcal{A})] := \abs{\prob{\texttt{IND-atk$^{\mathcal{A}}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{$\indcpa^\adv$ $\pcbox{\indcca^\adv}$}{\phantomsection\label{kemgame}
      (\pk,\sk) \sample \texttt{KGen}  \\
      b \sample \bin  \\
      (ct^*, K_0^*) \sample \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}}(\pk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}

  {\procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\bot$} \\
        else \\
        \text{return \texttt{Decaps}(sk,ct)}
   }}
\end{pchstack}
\end{definition}

\begin{definition}
A Commitment Scheme is a triple (Setup, Com, Open) such that:
\begin{itemize}
    \item $CK \sample \texttt{Setup}(\secparam)$ generates the public commitment context. It is often omitted mentioning the public context CK when clear.
    \item for any $ m \in M$, message space, $(c, d) \sample \texttt{Com}$($m$) is the commitment/opening pair for $m$. $c$ = $c(m)$ serves as the commitment value, and $d$ = $d(m)$ as the opening value.
    \item Open($c$, $d$) = $m'\in M \cup \{\bot\}$, where $\bot $ is returned if c is not a valid commitment to any message.
\end{itemize}
We define the hiding and binding games and advantages of an adversary $\mathcal{A}$ and security parameter \textit{n} as follows:
\begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Hiding$^\adv(n)$}{\phantomsection\label{Hiding}
      CK \sample \texttt{Setup}(\secparam) \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_b), d(x_b)) \sample \texttt{Com}(x_b)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
      {\procedure[linenumbering]{Binding$^\adv(n)$}{\phantomsection\label{Binding}
      CK \sample \texttt{Setup}(\secparam) \\
      (c, d, d') \sample \adv (\secparam)  \\
      m = Open(c, d)  \\
      m' = Open(c, d')  \\
      \pcreturn (m \neq m') \wedge (m, m' \neq \bot)
    }}
\end{pchstack}
\begin{center}
    \begin{align*}
        \advantage{\texttt{Hiding}}{\texttt{CS}}[(\mathcal{A}, n)] := \abs{\prob{\texttt{Hiding$^\adv$} \Rightarrow 1} - \frac{1}{2}} \leq \text{negl(n)} \\
        \advantage{\texttt{Binding}}{\texttt{CS}}[(\mathcal{A}, n)] := \prob{\texttt{Binding$^\adv$} \Rightarrow 1} 
        \leq \text{negl(n)} \\
    \end{align*}
\end{center}
\end{definition}
Then, we define the central element of the authentication security of our model to give a proper definition for the element that will be used to detect session interference by an attacker, and that will be central to the authentication security of our model.
\begin{definition}
We define the \textit{entropy session} as a deterministic digest of shared elements involved within a protocol key establishment. Formally, 
\begin{align*}
    Entropy := G(A_1 || ... || A_j)
\end{align*}
where $A_i$ , $i \in \{1, .., j\}$ are elements known to both parties at the end of the protocol session, and G is a CHF.
\end{definition}
Within each protocol, the specific values that will conform this entropy session value will be established.

A compromise must be reached in terms of the actual output length of the CHF used to derive the \textit{entropy} values. One the side, due to practical uses regarding rel-time authentication over voice, its length should be small, to facilitate usability. On the other size, the bigger this length value is, the higher the protection it provides, as increases the computational complexity of the attacks against it.
\begin{definition} (Decisional Diffie-Hellman Assumption) Consider a multiplicative cyclic group $G$ of order $q$ and generator $g$. 
Then the probability distributions of $Q_0 = \{(g^a, g^b, g^{ab}) : a, b \in \mathbb{Z}_q\}$ and $Q_1 = \{(g^a, g^b, g^c) : a, b, c \in \mathbb{Z}_q\}$ 
are computationally indistinguishable.
\end{definition}

\section{Authenticated Key Exchange model variation}

\subsection{CK model}

The main dilemma that this work and others before try to deal with is the execution of safe communication protocols over non reliable channels. This means, they are carried on under channels where messages might not only be delayed or lost, but also actively modified or even completely substituted. Therefore, is it necessary to come with ways of ensuring that no message can be modified, i.e., to provide assurance that what is received by a party is what the other party actually intended. Over key exchange protocols, this amounts to ensure that a safe and secret shared key has been established between parties, without any knowledge of it by any other party not intended.

Among the cryptographic literature pertaining to this problematic, the work of \cite{10.1007/3-540-44987-6_28} and \cite{cryptoeprint:1998/009} is highlighted. In it, a theoretic modeling of this situation is first described. Then, a number of techniques are defined to construct secure protocols, and formally prove their security under this model, over unauthenticated channels.
\begin{definition} \cite{10.1007/3-540-44987-6_28}: \textbf{Message-driven protocols} are collections of interactive procedures, run on currently by parties, that specify a particular processing of incoming messages and the generation of outgoing messages. Protocols are initially triggered at a party by an external "call" and later by the arrival of messages. Upon each of these events, and according to the protocol specification, the protocol processes information and may generate and transmit a message and/or wait for the next message to arrive.
\end{definition}

\begin{definition}
\cite{10.1007/3-540-44987-6_28}: Protocols can trigger the initiation of sub-protocols (i.e. interactive subroutines) or other protocols, and several copies of such protocols may be simultaneously run by each party. Each copy of a protocol run at a party is defined a \textbf{session}. Technically, a session is an interactive subroutine executed inside a party. Each session is identified by the party that runs it, the parties with whom the session communicates and by a session-identifier. These identifiers are used in practice to bind transmitted messages to their corresponding sessions.
\end{definition}
Regarding the theoretic model construction, first the \textit{Authenticated Model} (AM) is defined: Under this model, any attacker willing to confront a set of parties $P_1, .., P_n$ is able to delay and hold onto messages, but is forced, for every message that is delivered, to be done in good faith, without any modification to it. When a message is sent by a party, the message is added to a set $M$ of undelivered messages. When a party receives a message, this message is deleted from $M$ (therefore, since the adversary is restricted to deliver faithful messages, if a party $P_j$ receives a message $m$ from a party $P_i$, this must mean that $P_i$ sent message $m$ to $P_j$). The attacker is also able to corrupt any party at wish. This means, learning all information (public and private) pertaining to it. If a party is corrupted, then the attacker is allowed to impersonate them, but such action is recorded accordingly in the party's protocol output. The global output of the protocol is the concatenation of the output of each party at the end of it, plus the output of the attacker. Each party's output is engrossed by every activation regarding the protocol flow. The adversary's output is defined to be "\textit{all the information seen (and derived) by the adversary throughout the computation, together with its random input. This includes registration of important events that occurred during the execution, such as corruption of parties}".

Then, the \textit{Unauthenticated Model} (UM) is defined: Under this model, an attacker is not constrained to faithful delivery of message. Messages can be partially modified or even fully forged. The key component is that, under this model, the protocol is augmented with what is called a \textit{Initialization function} $I$, which models an "\textit{initial phase of out-of-band and authenticated information exchange between the parties}". This component is essential to the UM model, as seeks to provide the necessary authentication source that is lost once migrating to insecure channels.

In all the literature that works upon similar ideas, this initialization function is used to safely exchange public or secret information, in a way that the information exchanged conforms the seed in which authentication is build upon. \\
Now, it is require to define what does it mean for two protocols to be equivalent, under these models:
\begin{definition} \cite{10.1007/978-3-031-35486-1_24}:
The AM-UM distinguishing experiment, $G^{AM-UM-dist}_{\Pi_{AM}-\Pi_{UM}}(\mathcal{D})$ proceeds as follows:
\begin{enumerate}
    \item A uniform bit b $\in \{0, 1\}$ is chosen. If b = 0, $\mathcal{D}$ will interact with the AM protocol $\Pi_{AM}$ and an adversary in it. Otherwise, $\mathcal{D}$ will interact with the UM protocol $\Pi_{UM}$ and an adversary in it.
    \item To conclude the experiment, $\mathcal{D}$ will halt and output b'.
    \item The experiment will output 1 if and only if b = b'.
\end{enumerate}
We define the advantage of the distinguisher $\mathcal{D}$ to be
    \begin{align*}
        \advantage{\textnormal{AM-UM-dist}}{\Pi_{AM}-\Pi_{UM}}[(\mathcal{D})] = 2\cdot\abs{P[G^{AM-UM-dist}_{\Pi_{AM}-\Pi_{UM}}(\mathcal{D}) = 1] - \frac{1}{2}}
    \end{align*}
\end{definition}

\begin{definition} \cite{10.1007/978-3-031-35486-1_24}: 
Let $\pi$ and $\pi'$ be message-driven protocols for $n$ parties. We say that  $\pi'$ emulates $\pi$ over unauthenticated networks if, for any UM-adversary \textit{U}, there is a AM-adversary \textit{A} such that, for each distinguisher $D$ playing the AM-UM distinguishing game, we have
\[\advantage{\textnormal{AM-UM-dist}}{\Pi_{AM}-\Pi_{UM}}[(\mathcal{D})] \leq \epsilon\]
This means, their respective global outputs are computationally indistinguishable.
\end{definition}

Then, the notion of a compiler is defined, to provide a bridge between protocols in both models:

\begin{definition} \cite{cryptoeprint:1998/009}: A compiler C is an algorithm that takes for input descriptions of protocols and outputs descriptions of protocols. An authenticator is a compiler C where for any protocol $\pi$, the protocol C($\pi$) emulates $\pi$ over unauthenticated networks.
\end{definition}

\subsubsection{Key exchange protocols and SK security}
A key exchange protocol is a special type of the message-driven protocol described above, introduced in \cite{10.1007/3-540-44987-6_28}: the local output of said protocols are of the form ($P_i$, $P_j$, s, $\kappa$), representing the parties involved, the session identifier and the key derived from the execution of it. Regarding the status of a session, it is considered that if the key value $\kappa$ is null, then the exchange was unsuccessful and is considered an aborted session. Otherwise, the session is considered completed and $\kappa$ is stored as the \textit{secret} of the exchange. The state of such sessions consist of:
\begin{itemize}
	\item The status of the SK-session: completed, aborted or in process.
	\item Any intermediate value generated from the protocol execution, and relevant to complete it.
	\item The session key $\kappa$ derived from the exchange.
\end{itemize}
A complete definition of the concept of \textit{SK security} also needs to be introduced. SK security, intuitively, is about adding to any adversary the possibility to \textit{test} a session key at any given time during the execution of a simulation. In it, the challenger will draw a random bit and, depending on it, the adversary will either learn the true value of the key derived from the session they chose (among completed, uncorrupted sessions) or a value drawn at random. The challenge to the adversary is being able to correctly distinguish between them. The security of the exchange is therefore tied to any adversary's possibility of distinguishing. Formally, given the following adversary's possibilities:
\begin{itemize}
    \item \textit{NewSession(A, B, s, r)}: the adversary issues the NewSession query to party $A$, specifying its intended receiver $B$, the session identifier $s$, and the role $s$ (initiator or responder) of $A$ in the session. $A$ will follow the protocol definition and may return an output message intended for $B$.
    \item \textit{Send(A, B, m)}: represents activation of $A$ by an incoming message $m$ (possibly including a session identifier) from party $B$. $A$ will follow the protocol and may reject, accept, or return an output message intended for $B$.
    \item \textit{Corrupt(A)}: the adversary learns the whole state of $A$, including any information necessary to impersonate $A$ in an authenticated way (which may pertain to learn any long-term secret or other information, depending on each particular model). The corruption event is recorded in the local output of $A$. Subsequently $A$ can never be activated but the adversary can take the role of $A$ in the protocol.
    \item \textit{RevealKey(A, B, s)}: the adversary learns the session key accepted in the session $s$ by $A$ with party $B$, if it exists. The reveal event is recorded in the local output of $A$.
    \item \textit{RevealState(A, B, s)}: the adversary learns the state information associated with session $s$ at $A$, such as ephemeral keys. The reveal state event is recorded in the local output of $A$.
    \item \textit{Expire(A, B, s)}: if there is a completed session $s$ at $A$ with $B$ then any session key associated with that session is deleted from the memory of $A$. The \textit{Expire} event is recorded in the local output of $A$.
    \item \textit{Test(A, B, s)}: this query can be asked only once and can only be made to a completed session $s$ at $A$ with party $B$. Furthermore there cannot have been any of the following queries made: \textit{RevealKey(A, B, s)} or \textit{RevealState(A, B, s)} or \textit{Corrupt(A)} or \textit{Corrupt(B)}. If the bit $b$ specified by the challenger is $b = 1$ then the session key is returned. Otherwise $b = 0$ and a random key from the keyspace is returned.
\end{itemize}
we define the SK-security of a protocol as follows:
\begin{definition} \cite{10.1007/978-3-031-35486-1_24} The definition of the SK-exchange indistinguishability experiment $ G^{Key-Ind}_{\Pi}(\mathcal{A})$ is as follows
    \begin{enumerate}
        \item The challenger chooses a bit $b$ needed to set the \textit{Test} response.
        \item Every party and additional initial material is initialized.
        \item $\mathcal{A}$ may issue any queries as described above.
        \item At one point, $\mathcal{A}$ stops and outputs a bit $b^{\prime}$ to indicate its guess for $b$, based on the
response to the \textit{Test} query. The experiment outputs 1 iff $b^{\prime} = b$.
    \end{enumerate}
\end{definition}

\begin{definition} \cite{10.1007/978-3-031-35486-1_24} A key exchange protocol $\Pi$ is $\epsilon$-SK-secure if the following holds for any adversary $\mathcal{A}$:
    \begin{enumerate}
        \item two honest parties (i.e. uncorrupted parties who faithfully execute the protocol instructions) completing matching sessions of the protocol $\Pi$ will output the same key, except with negligible probability.
        \item the advantage of the adversary $\mathcal{A}$ in the key indistinguishability experiment described above is:
        \begin{align*}
            \advantage{Key-Ind}{\Pi}[(\mathcal{A})] = 2\cdot\abs{P[b' = b] - \frac{1}{2}} \leq \epsilon
        \end{align*}
    \end{enumerate}
\end{definition}

\subsection{Our model}
In the model defined and used throughout this work, we follow the same ideas defined in \cite{10.1007/3-540-44987-6_28} and \cite{cryptoeprint:1998/009}, but with an important modification regarding the authentication source. In our model, the authentication will not be provided by an initial authenticated exchange of cryptography material, but rather of a \textit{final} authenticated verification of certain values that will be generated within each protocol run. Thus, upon finalization of each protocol's message exchange and, as part of its execution, each party will generate an element as specified by it, from elements shared or generated during the protocol execution. This value will be verified by the receiver to match the corresponding generated by the initiator, in an authenticated way, by means of a '\textit{verification phase}' modeled by $I_f$. If this verification is satisfactory, then we establish that \textit{m} has been correctly received by party $P_j$ from party $P_i$, and in particular $P_j$ validates, in an authenticated way, $P_i$ as the party with whom they have executed the protocol. This means that a message will only be considered as successfully received by a party $P_j$ if it involves a successful validation by means of $I_f$ of the established elements by each particular protocol. Intuitively, the idea behind this process is that it will mean that $m$ was indeed sent by party $P_i$ to party $P_j$, as the possibilities for an adversary to forge this value and get validated between $P_j$ and $P_i$ will be negligible.

While our \textit{Authenticated Model} (AM) remains unchanged, our \textit{Unauthenticated Model} (UM) requires the following modification: Under this new model, protocols are now augmented with a "\textit{verification function}" $I_f$, as defined above. This component is essential to our UM model, as seeks to provide the necessary authentication source that is lost once migrating to insecure channels, as the previous UM model did with the initialization function $I_0$. While the specifics of how these kind of functions work will be dependent upon each protocol description, the theoretical behavior must always be the same: an authenticated verification of a value generated by each party during the protocol run, in which the responder must corroborate the value generated by the initiator with it's own. \\
%Practical details like how these kind of verification can be built, or if it provides mutual authentication, etc... is out of the scope of this work.\\
Notice that this verification phase and the values generated to perform the validation will be constructed from elements formed and transmitted during the protocol run.

The idea behind is that, if the protocols are constructed in a certain way, any adversary modification of them will not go unnoticed in the verification values generated, and will not be validated during $I_f$. And, it will be tied to the identity of the sender of the message since the process $I_f$ involves an authenticated exchange, in which the responder will validate the identity of the initiator. The particular way in which the $I_f$ process achieves this authentication will depend on the specific characteristics of the protocol and is outside of the scope of this work, but we will give a number of examples. Note that the theoretic construction of $I_f$ is not supposing mutual authentication.

We also need to define what it means for an adversary to corrupt a party $A$, since in our model there is not a notion of long-term key to be compromised: we need to represent exactly the same notion as in the original model, i.e., the capacity to impersonate in an authenticated way the party which has been corrupted. Therefore, in our model, the corruption of party $A$ means that an adversary has the capacity to override the authenticated validation performed by $I_f$ as if it were the corrupted party. The specific way in which this can be practically achieved depends, naturally, on the nature of $I_f$.  \\
We provide the definition of MT-authenticators, as introduced in \cite{cryptoeprint:1998/009}, with regards to the newly introduced UM model:

Consider the message transmission (MT) protocol designed for authenticated networks. The protocol takes the empty input. Upon activation within $P_i$ on external request ($P_j$;\textit{m}), party $P_i$ sends the message ($P_i$;$P_j$;\textit{m}) to party $P_j$, and outputs '$P_i$ sent \textit{m} to $P_j$'. Upon receipt of a message ($P_i$;$P_j$;\textit{m}), $P_j$ outputs '$P_j$ received \textit{m} from $P_i$'. \\
Then, let $\lambda$ be a protocol that emulates the MT protocol over unauthenticated networks. Define a compiler $C_\lambda$ as follows:

Given a protocol $\pi$, the generated
protocol $\pi'$ = $C_\lambda(\pi)$, running within party $P_j$, first invokes $\lambda$. Next, for each message that $\pi$ sends, $\pi'$ activates $\lambda$ with external request for sending that message to the specified recipient. Whenever
$\pi'$ is activated with some incoming message, it activates $\lambda$ with this incoming message. When $\lambda$ outputs '$P_j$ received \textit{m} from $P_i$' (which, in particular, happens when party $P_j$ successfully validates the entropy value generated on its end from message \textit{m} transmission against the value generated by $P_i$, by means of $I_f$), protocol $\pi$ is activated with incoming message \textit{m} from $P_i$. \\
The objective of the remainder of this section is to show that, under this new UM model, all relevant results provided on \cite{cryptoeprint:1998/009} and \cite{10.1007/3-540-44987-6_28} hold. We start by showing that, under a MT-authenticator $\lambda$ as defined above, the compiler $C_\lambda$ constructed from it is an authenticator:
\begin{theorem}
Under the new UM model, let $\lambda$ be an MT-authenticator, and
let $C_\lambda$ be a compiler constructed based on $\lambda$ . Then $C_\lambda$ is an authenticator.
\end{theorem}
\begin{proof}
    The proof laid out in \cite{cryptoeprint:1998/009} applies, 		despite the construction differences with the original UM. That is because despite variations, we are still provided with $\lambda$ being a MT-authenticator. In our model, this will intuitively mean that if an attacker is able to modify (or even fully forge) a message transmission, validation through $I_f$ wont be successful, or equivalently, if the output '$P_i$ received \textit{m} from $P_j$' is generated from $\lambda$, this will necessarily mean that $I_f$ will produce an affirmative validation (and therefore will not happen that the triple ($P_j$,$P_i$,\textit{m}) is not currently in the set $M$ of undelivered messages in the AM, and $P_j$ is uncorrupted).

We cover the most delicate part of the proof: we would need to prove that it is a legitimate behavior to assume that, except with negligible probability, if the activation of the MT-authenticator $\lambda$ generates an output "\textit{party $P_j^{\prime}$ has received message m from $P_i^{\prime}$}", then the element $(P_i, P_j, m)$ is still in the set of undelivered messages, in the AM, when both parties are uncorrupted. And, this is still true as, in our model, the successful reception of a message in the UM involves the affirmative validation of $I_f$, for the uncorrupted sender $P_i^{\prime}$ and, since by hypothesis we are working with a protocol $\lambda$ that emulates MT over unauthenticated network, this situation can only arise with negligible probability, for non-corrupted parties. We refer to \cite{cryptoeprint:1998/009} for the detailed proof.
\end{proof}
We define now the MT-authenticator that will serve as the foundation of the secure UM protocols defined in the following sections:
\begin{pchstack}[boxed, center, space=1em]
    \procedure{Commitment-based MT Authenticator}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     (c, d) \sample \texttt{Com(m)} \> \> \\
     \> \sendmessageright{top=\text{c}} \> \\
     \> \> N \sample \{0,1\}^n \\ 
     \> \sendmessageleft{top=\text{N}} \> \\ 
     E_A = \texttt{G}(B, c, N, m) \> \> \\
     \> \sendmessageright{top=\text{d}} \> \\
     \> \> m^{\prime} = Open(c, d) \\
     \> \> E_A^{\prime} = \texttt{G}(B, c, N, m^{\prime}) \\
	 \> \> \texttt{If $I_f(E_A, E_A^{\prime})$ = 1} \\
	 \> \> \texttt{"$B$ received $m$ from $A$"}
     }
\end{pchstack}
The idea behind the above authenticator is the following:
\begin{itemize}
    \item Alice, who wishes to send a message \textit{m} to Bob, first generates a commitment \textit{c} of such message, and sends it.
    \item Bob, upon reception of such message, just generates a random share \textit{N} and transmits it to Alice. 
    \item When Alice receives this random share \textit{N}, liberates the opening \textit{d} associated with the previous commitment, so Bob can access the message \textit{m}.
    \item Both ends generate a summary of the exchange, by deriving an Entropy value from the commitment \textit{c}, the random share \textit{N}, the actual message \textit{m} and the identity of the intended recipient $B$, which is added to ensure that an attacker cannot redirect legitimate messages to other uncorrupted not-intended destinations. Once the exchange is finished, the responder will validate its entropy value against the one obtained by Alice, in a secure and authenticated way, as modeled by $I_f$.
\end{itemize}
The security of the above protocol resides in the security properties of commitment schemes, the hiding and binding properties, and the elements that conform the Entropy value:
\begin{itemize}
    \item The hiding property provides assurance that just from knowing the commitment value $c$, the actual message $m$ committed remains unknown until knowing d, which prevents the attacker from knowing $m$ at the time of the random share generation.
    \item The binding property provides assurance that, once the commitment is generated, this value is tied to $m$, and an attacker is not able to generate different opening values that map to any other valid messages.
\end{itemize}
We formalize this idea, by proving that the Commitment-based protocol described above emulates MT in unauthenticated networks:
\begin{proposition}
The Commitment-based MT-authenticator, when instantiated with a secure commitment scheme, emulates MT over unauthenticated channels with advantage $\epsilon \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{1}{2^{n_e - 1}})$, where l = $n_p^2 \cdot n_m$ and $n_p$ is the number of parties running the protocol, $n_m$ the maximum number of message sent by each party and $n_e$ the length of the entropy value generated.
\end{proposition}
\begin{proof}
    We follow the same demonstration ideas of \cite{cryptoeprint:1998/009,10.1007/3-540-44987-6_28,10.1007/978-3-031-35486-1_24}. An AM-adversary can perfectly simulate an UM-adversary unless the event \textit{"In the UM there is the output “Q received m from P” for some parties P and Q, but there was no previous output “P sent m to Q”, for uncorrupted parties P, Q"} happens. We first bound the probability of this event happening on any particular $(P, Q, m)$, and then limit the probability of distinguishing between adversaries by the probability of the above event happening on a particular exchange times the maximum number of exchanges generated.\\
    Under our UM, if the output \textit{"Q received m from P"} happens, in particular it means that $Q$ has validated $P$ as the party at the other end of the communication. This means that we can establish $P$ as the sender, and $Q$ as the final receiver. It remains to see that, except with negligible probability, it cannot happen that $P$ intended to contact another party $Q^{\prime} \neq Q$ or send another message $m^{\prime} \neq m$.
    
Therefore, the probability of this event happening on any particular $(P, Q, m)$ is reduced to the probability of an UM adversary to generate different elements, or a different receiver, to those intended in a way that the later verification phase $I_f$ between $P$ and $Q$ is successful. We model that in the game  G$_{Entropy}$ and the advantage against the scheme as
    \begin{align*}
        \advantage{}{\texttt{CS-MT}} := \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1}}
    \end{align*}
    We show that $\advantage{}{\texttt{CS-MT}} \leq \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}$. 
    \begin{pchstack}[ boxed , center, space=1em]
      {\procedure[linenumbering]{Game G$_{Entropy}$}{\phantomsection\label{CSMT}
          (c,d) \sample \texttt{Com(m$^{\prime}$)}  \\
          c^* \sample \adv_1^{O_{Q}, O_{Q'}}(c) \\
          N \sample \{0,1\}^n \\
          N^* \sample \adv_2^{O_{Q}, O_{Q'}}(c, N) \\
          v_1 = O_{Q'}(c, N^*, m^{\prime}) \\
          d^* \sample \adv_3^{O_{Q}, O_{Q'}}(c, N, d) \\
          m = Open(c^*, d^*) \\
          v_2 = O_{Q}(c^*, N, m) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G00}
          (c,d) \sample \texttt{Com(m$^{\prime}$)}  \\
          c^* \sample \adv_1^{O_{Q}, O_{Q'}}(c) \\
          N \sample \{0,1\}^n \\
          N^* \sample \adv_2^{O_{Q}, O_{Q'}}(c, N) \\
          v_1 = O_{Q'}(c, N^*, m^{\prime}) \\
          m = Open(c^*, d) \\
          v_2 = O_{Q}(c^*, N, m) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G10}
          (c,d) \sample \texttt{Com(m$^{\prime}$)}  \\
          c^* \sample \adv_1^{O_{Q}, O_{Q'}}(c) \\
          N \sample \{0,1\}^n \\
          v_1 = O_{Q'}(c, N, m^{\prime}) \\
          m = Open(c^*, d) \\
          v_2 = O_{Q}(c^*, N, m) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    where $O_{P}(x_1, x_2, x_3) = O(P, x_1, x_2, x_3)$ represents the entropy calculation that will undergo each party, where $P$ is the identity of the intended receiver. Note that this value is added to bind the original receiver intended with the final receiver, and ensures that an adversary cannot simply redirect the original messages to another party, but that, in the proof, it will just model another deterministic \textit{entropy oracle}, determined from the beginning of the protocol exchange. \\
    We define the intermediate games $G_0$ and $G_1$, where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange.
    
Therefore, the value $\abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain value m, we are able to generate (d, $d^*$) openings such that both are valid openings of different messages m,  m' when put together with the commitment c, whose probability is modeled by the advantage of the game $G_{Binding^*}$ defined below. If it is not satisfied, the games $G_{Entropy}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{pchstack}[boxed, center]
      {\procedure[linenumbering]{Game G$_{Binding^*}$}{\phantomsection\label{Gbinding'}
          c \sample \texttt{Com(m$_0$)} \\
          (d, d') \sample \adv (c)  \\
          m = Open(c, d)  \\
          m' = Open(c, d')  \\
          \pcreturn (m \neq m') \wedge (m, m' \neq \bot)
        }}
    \end{pchstack}
    \begin{align*}
        \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value c, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the random challenge value sent by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that, given c commitment of a certain value m, we are able to extract information about the value m, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the value m, the attacker is unable to obtain enough information to elaborate of a guess of $N^*$ to provoke a collision and being able to modify it does not provide any advantage. Consequently, the difference lemma can be applied and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value c, or when specifying a different receiver $Q$ than the one $Q^{\prime}$ originally intended, which is $\frac{2}{2^{n_e}}$. \\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{Entropy}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}
    \end{align*}
    Then, considering all possible messages between parties, which equals the maximum number of messages sent by each party times the square of the number of parties, we arrive to the desired bound.
\end{proof}
\subsubsection{SK security under new model}
Under our model, we adopt the definition and the setting for key exchange protocols and \textit{session-key security} explained in \cite{10.1007/3-540-44987-6_28}, but introducing the authentication differences pertaining to our model.

Since the key exchange procedures are a special case of message-driven protocols, the notion of entropy and posterior verification are translated onto these protocols. An entropy value (pertaining to specific elements, depending upon the protocol in consideration) is generated by each party running the key exchange protocol. Once the protocol's message exchange is finished, the protocol will trigger the responder to verify its entropy value against the one generated on the initiator's side, in a secure and authenticated way, as modeled by $I_f$. If this verification is affirmative and the key value $\kappa$ is not null (that is, a previous abort did not happen), the session is considered \textit{completed} and the secret value $\kappa$ is appended as local output to both parties. If this verification is not affirmative, we consider the session aborted and $\kappa$ is set to null, even in the case when a non-null secret value of the key was reached at the end of the protocol's message exchange. \\
A couple of notions regarding the adversaries abilities in a SK-exchange need to be adapted with our model modification:
\begin{itemize}
	\item The notion of what \textit{Corrupt(A)} means, defined at the beginning of the definition of our model.
	\item Then, the notion of a successful \textit{Send(A, B, m)}, which now, along with the peculiarities of each particular protocol, implies a successful validation by $I_f$.
\end{itemize}
With this modifications, we state the following theorem, which still holds under our new model:
\begin{theorem}
\label{ThCompilerSK}
Let $\pi$ be a SK-secure protocol in the AM and let $C_\lambda$ be a compiler based on MT-authenticator $\lambda$. Consider $\pi' = C_\lambda(\pi)$ the protocol that emulates $\pi$ in our modified UM model. Then, $\pi'$ is a SK-secure protocol in our modified UM model.
\end{theorem}
\begin{proof}
    The proof presented in \cite{10.1007/978-3-031-35486-1_24} to prove this result under the original model still applies to our model. The definitions of \cite{10.1007/978-3-031-35486-1_24} still model the notion of the key indistinguishability experiment (without any long-term key) and SK-security under our model, with two modifications: First, we have included the necessary entropy validation process $I_f$ of our general message-driven model inside the definition of \textit{completeness} of a key exchange protocol execution (i.e., the key $\kappa$ will only be non-null if the exchange has been successful, and that includes the $I_f$ phase), as part of the message exchange of the SK-protocol. Then, the \textit{Corrupt} capability of an adversary has been re-defined to atone for identity usurpation under the new UM, i.e., corruption of the $I_f$ process, which represents the authentication phase equivalent to the presence of long-term keys in the original UM.
    
We note that these requirements are the appropriate execution over key exchange protocols. The key event '\textit{forge}' that models the proof is the well-known event that a party $P_j$ successfully receives a message \textit{m} from another party $P_i$, but $P_i$ never sent it. And the probabilities modeled in \cite{10.1007/978-3-031-35486-1_24} remain the same, under the new UM model.
\end{proof}
\section{KEX-based protocols}

Cryptographic protocols based on key exchange algorithms are vastly used in a number of different scenarios, a great deal of those through insecure channels. These protocols are defined in terms of the number of exchanged messages needed to complete them, and the information sent on each message. We provide in this section with a selected overview of how these KEX-based protocols would look like, under our new models.

\subsection{2-pass protocol}

The minimum requirement for a KEX-based shared secret establishment is 2 messages. The protocol would go as follows:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEX-based protocol on the \textit{AM} \pcbox{UM}}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> K_{ab} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> \pcbox{E = \texttt{G}(B, p_{k_a}, p_{k_b}, K_{ab})} \\ 
     \> \sendmessageleft{top=\text{p$_{k_b}$}} \> \\ 
     K_{ba} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     \pcbox{E = \texttt{G}(B, p_{k_a}, p_{k_b}, K_{ba})} \> \>}
\end{pchstack}

\begin{itemize}
    \item Alice generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KGen() function of the specific KEX selected. Then, the public value $p_{k_a}$ is sent to Bob.
    \item  Bob, upon reception of Alice's public key $p_{k_a}$, generates another key pair ($s_{k_b}$, $p_{k_b}$) with the same algorithm KGen(), to then execute the KeyAgreement function, with inputs its own secret key $s_{k_b}$ and the other end's public key $p_{k_a}$. The execution of this function yields a secret key $K_{ab}$. Then, Bob sends its own public key $p_{k_b}$ to Alice.
    \item With Bob's public key, Alice executes the same KeyAgreement function, on its own private key and the received public key, to derive the shared secret $K_{ba}$. If no interference has happened, the KEX algorithm ensures that $K_{ab}$ = $K_{ba}$. On the UM, as part of the protocol, the entropy elements and the verification phase would appear.
\end{itemize}

\subsubsection{Security of the above protocol \label{3.1.1}}

The security of the protocol itself, without any interference, i.e., on the authenticated model, is based upon the security of the underlying key exchange algorithm selected, and the unique possession by both ends of their respective secret keys.

Over insecure channels, i.e., on the unauthenticated model, neither party has any assurance that the public key values received indeed corresponds to the actual values sent by the other party. This particular situation is the very foundation of the presence of the session entropy value calculated by both ends on the protocol. But, even the presence of such value is not enough to avoid MitM interference. The attack against this protocol goes as follows:

\begin{itemize}
    \item When Alice sends its public key $p_{k_{a}}$, Mallory intercepts it and instead transmits the public key $p_{k_{eb}}$ of its key pair generated. Then, Bob will execute the corresponding KeyAgreement function over the fraudulent public key $p_{k_{eb}}$, generating a secret $K_{eb}$, and its session entropy, based on the secret, its own public key $p_{k_{b}}$ and the fraudulent public key value $p_{k_{eb}}$. Then, Bob transmits $p_{k_{b}}$.
    \item Mallory would then need to intercept this public value and substitute with the public key value $p_{k_{ea}}$ of a newly generated key pair ($s_{k_{ea}}$, $p_{k_{ea}}$). But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $p_{k_{ea}}$ and $p_{k_a}$ is the same as the session entropy generated by Bob (to which Mallory, as has actively modified the natural course of the protocol, has access to). Therefore, Mallory would need to loop through key pairs ($s_{k_{ea_i}}$, $p_{k_{ea_i}}$) until one satisfies the required condition.
\end{itemize}
The actual success probability of this attack is closely tied with the size of the session entropy generated, but is nevertheless a plausible loophole for an attacker to exploit.

\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.75cm]{MitM attack on 2-pass KEX-based protocol}{%
     \textbf{Alice}  \> \> \textbf{Mallory} \> \> \textbf{Bob} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_{eb}}, p_{k_{eb}}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright{top=\text{p$_{k_{eb}}$}} \> \\
     \> \> \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> \> \> K_{be} \sample \texttt{KEX}(p_{k_{eb}}, s_{k_b}) \\
     \> \> \> \>  E_{be} = \texttt{G}(B, p_{k_{eb}}, s_{k_b}, K_{be}) \\
     \> \> \> \sendmessageleft{top=\text{$p_{k_b}$}} \> \\
     \> \> K_{eb} = \texttt{KEX}(p_{k_b}, s_{k_{eb}}) \> \> \\
     \> \> E_{eb} = \texttt{G}(B, p_{k_{eb}}, p_{k_b}, K_{eb}) \> \> \\
     \> \> \texttt{While $E_{ea} \neq E_{eb}$ do:} \> \> \\
     \> \> \quad (s_{k_{ea}}, p_{k_{ea}}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \> \quad K_{ea} \sample \texttt{KEX}(p_{k_a}, s_{k_{ea}}) \> \> \\
     \> \> \quad E_{ea} = \texttt{G}(B, p_{k_a}, p_{k_{ea}}, K_{ea}) \> \> \\
     \> \sendmessageleft{top=\text{$p_{k_{ea}}$}} \> \> \> \\
     K_{ae} = \texttt{KEX}(p_{k_{ea}}, s_{k_a}) \> \> \> \> \\
     E_{ae} = \texttt{G}(B, p_{k_a}, p_{k_{ea}}, K_{ae}) \> \> \> \>}
\end{pchstack}

\subsubsection{Practical example \label{3.1.2}}
We provide a practical example of the above protocol, by instantiating the general KEX scheme with a basic Diffie-Hellman procedure, over a generic finite cyclic group:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass DH-based protocol in the AM}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     a \sample \mathbb{N} \> \> \\
     \> \sendmessageright*[2.5cm]{\text{$g^a$}} \> \\
     \> \> b \sample \mathbb{N} \\ 
     \> \> K_{ab} = (g^a)^b = g^{ab} \\ 
     \> \sendmessageleft*[2.5cm]{\text{$g^b$}} \> \\ 
     K_{ba} = (g^b)^a = g^{ba} \> \>}
\end{pchstack}

This protocol was proven secure on the AM model in \cite{cryptoeprint:1998/009}. It is not secure in the UM model.

\subsection{3-pass protocol}
To avoid the weaknesses of the above protocol it is necessary to impose some kind of restriction on the generation of values to any potential attacker. We apply the same ideas as on the CS MT authenticator described above to define the following protocol:
\begin{pchstack}[boxed, center]
    \procedure{3-pass KEX-based protocol}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> (c, d) \sample \texttt{Com}(p_{k_b}) \\ 
     \> \sendmessageleft{top=\text{c}} \> \\ 
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> K_{ba} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> E_B = \texttt{G}(A, p_{k_a}, p_{k_b}, K_{ba}) \\
     \> \sendmessageleft{top=\text{d}} \> \\ 
     p_{k_b} = Open(c(p_{k_b}), d(p_{k_b})) \> \> \\
     K_{ab} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     E_B^{\prime} = \texttt{G}(A, p_{k_a}, p_{k_b}, K_{ab})}
\end{pchstack}
\begin{itemize}
    \item First, Bob generates a key pair ($s_{k_{a}}$, $p_{k_{a}}$) and sends the commitment of its public key to Alice.
    \item Alice stores this value and generates its own key pair ($s_{k_{b}}$, $p_{k_{b}}$) and sends it to Bob.
    \item Bob, upon reception of the public key value of Alice, derives the shared secret value $K_{ba}$ from its own private key, and the public key received, along with its session entropy from the shared values involved in the protocol. Then, Bob sends the public key value previously committed, along with the opening value required to open the commitment.
    \item Alice verifies that the value committed matches the commitment stored (as part of the opening function), and then proceeds to derive the shared secret $K_{ab}$ and its session entropy.
\end{itemize}
\subsubsection{Security of the above protocol}
If the CS selected to use in this protocol is secure, that is, verifies the \textit{hiding} and \textit{biding} properties defined above, this protocol is secure. The \textit{hiding} property of the scheme ensures that no information about the committed value is shared beforehand, and the \textit{biding} property ensures that the MitM attack described above cannot happen, as an attacker has a negligible possibility of producing a different key pair that commits to the same value as the one committed.

Note that the same ideas used to construct the CS MT authenticator are present here: the commitment of a value beforehand, so it binds the adversary to commit-related values and an entropy value influenced only by elements exchanged on the first and second iteration, never on the last (as this would open a plausible door for an adversary to exploit). The specific values that conform the entropy validation must be selected carefully, so that they provide the necessary authentication while not proving a security over-kill that an adversary can exploit, as will become apparent later.

\subsubsection{Practical example \label{3.2.2}}
We give a practical example of the above 3-pass protocol by building on the example laid out in \ref{3.1.2}:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass DH-based protocol on the UM}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     \> \> b \sample \mathbb{N} \\ 
     \> \> (c, d) \sample \texttt{Com($g^b$)} \\ 
     \> \sendmessageleft{top=\text{c}} \> \\ 
     a \sample \mathbb{N} \> \> \\
     \> \sendmessageright{top=\text{$g^a$}} \> \\
     \> \> K_{ba} = (g^a)^b = g^{ab} \\ 
     \> \> E_B = H(A, g^a, g^b, c) \\
     \> \sendmessageleft{top=\text{d}} \> \\ 
     g^b = \texttt{Open}(c, d) \> \> \\
     K_{ab} = (g^b)^a = g^{ba} \> \> \\
     E_B^{\prime} = H(A, g^a, g^b, c)}
\end{pchstack}
We claim that the described protocol is SK-secure in our UM model, and lay out the proof on Annex C.
\begin{proposition} The above protocol is SK-secure on the UM, based on the security of the Decisional Diffie-Hellman (DDH) assumption and the Commitment Scheme.
\end{proposition}

\section{KEM-based protocols}

When working with Key Encapsulation Mechanisms, two important differences must be highlighted:
\begin{enumerate}
    \item KEM mechanisms are, in general, not contributory, as opposed to the KEX mechanisms considered in the previous section. That means that the final shared key does not come from a mutual contribution of both ends, but is unilaterally generated by one end and transmitted to the other.
    \item The public values that will be exchanged in the protocol are not independent. That is, it will not be formed by two public keys generated by both users, but formed by a public key and an encapsulation, whose value depends on the public key value.
\end{enumerate}
These two differences will drive the security analyses made on KEM-based protocols, and its contrasts with their KEX-based counterparts.

\subsection{2-pass protocol  \label{4.1}}

The 2-pass KEM-based protocol is, in appearance, a drop-in replacement of its KEX-based counterpart, in the sense that the KEX instances were substituted by Encaps and Decaps procedures:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEM-based protocol on the AM \pcbox{UM}}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (ct_b, K) \sample \texttt{Encaps}(p_{k_a}) \\
     \> \> \pcbox{E = \texttt{G}(p_{k_a}, ct_b, K)} \\
     \> \sendmessageleft{top=\text{ct$_b$}} \> \\ 
     K = \texttt{Decaps}(ct_b, s_{k_a}) \> \> \\
    \pcbox{E = \texttt{G}(p_{k_a}, ct_b, K)} \> \>}
\end{pchstack}

\begin{itemize}
    \item Alice generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KGen() function of the specific KEM selected. Then, the public value $p_{k_a}$ is sent to Bob.
    \item  Bob, upon reception of Alice's public key $p_{k_a}$, executes the encapsulation function on the public key received. The execution of this function yields a secret key K, and an encapsulation $ct_b$ of the secret that conforms the generated shared secret. Then, Bob sends the aforementioned encapsulation.
    \item Alice executes the decapsulation function, with inputs the encapsulation $ct_b$ received and its own secret key, to derive the shared secret K.
\end{itemize}
\subsubsection{Security}
Under the AM model, that is, under the assumption that the integrity of each message received is intact, the protocol is SK-secure, as proven in \cite{10.1007/978-3-031-35486-1_24}. 

Under our UM model, a number of different considerations arise regarding the protocol's practical security: the attacker's possibility to generate the same shared secret on both ends, a replica for KEM-based protocols of the attack against 2-pass KEX-based protocol, and a combination of them.
\paragraph*{Attack on same key on both ends}
Despite its clear similarities to the 2-pass KEX-based protocol, a MitM attacker not only has the ability to establish a shared secret with each party but also, in general, the ability to generate the exact same shared secret on both, and thus all three parties possess the same shared secret value. This is a direct consequence of the non-contributory nature of Key Encapsulation Mechanisms. The attack would go as follows:
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1cm]{MitM attack on KEM schemes}{%
     \textbf{Alice}  \> \> \textbf{Mallory} \> \> \textbf{Bob} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright*[2.5cm]{\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright*[2.5cm]{\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \sendmessageleft*[2.5cm]{\text{Ct$_b$}} \> \\
     \> \> (x, K) = \texttt{Decaps$^*$}(Ct_b, s_{k_e}) \> \> \\
     \> \> (Ct_e, K) = \texttt{Encaps$^*$}(x, p_{k_a}) \> \> \\
     \> \sendmessageleft*[2.5cm]{\text{Ct$_e$}} \> \> \> \\
     K = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \>}
\end{pchstack}
\begin{itemize}
    \item Alice generates its KEM key pair ($s_{k_{a}}$, $p_{k_{a}}$) and sends its public key to Bob.
    \item Mallory intercepts the public key value sent, generates another key pair ($s_{k_{e}}$, $p_{k_{e}}$) and substitutes the public key value sent by Alice with its own public key $p_{k_{e}}$.
    \item Bob executes the encapsulation function with the public key value received. At this moment, all information about the key is established. Bob sends the encapsulation of the secret required to derive the shared key.
    \item Mallory intercepts the encapsulation sent and, as it has been encapsulated using its public key value, decapsulates it using the secret key. Through this process, the attacker is able to learn the secret $x$ that was encapsulated, and that forms the shared key. Therefore, the attacker simply re-encapsulates this exact same value with Alice's public key, and sends this encapsulation Ct$_e$ to them.
    \item Alice executes the decapsulation function on the encapsulation received, and its own secret key, to derive the same shared key \textit{K} as Bob and Mallory.
\end{itemize}
This possibility highlights the requirement of the entropy session to be contributed by the public values involved in the key derivation, as this addition is all that is required to  thwart the attack, for deterministic-based KEMs. \vspace{1mm} \\
The previous attack is carried on by slightly tweaking the \textit{Encaps} and \textit{Decaps} definition provided, on the attacker's side. The \textit{Encaps}* function takes also as argument the secret value to be encapsulated. Meanwhile, the \textit{Decaps}* function also outputs the secret value that was encapsulated.
\paragraph*{Replica attack on KEX-based protocol \label{4.1.1.2}}
When the above protocol's session entropy is contributed with public values involved in the exchange, the attack detailed above does not, in general, apply (see Section \ref{4.1.1.3}). Nevertheless, the attack on the session entropy value shown in Section \ref{3.1.1} still applies, as a commitment value is not present in the 2-pass KEM-based protocol either:
\begin{itemize}
    \item When Alice sends a public key value $p_{k_{a}}$, the attacker intercepts it and transmits instead the public key value $p_{k_{e}}$ of a newly generated key pair ($s_{k_{e}}$, $p_{k_{e}}$). Then, Bob will execute the \textit{Encaps} function over the fraudulent public key $p_{k_{e}}$, generating a secret $K_{be}$, and the corresponding session entropy, based on this secret, the encapsulation $Ct_{b}$ generated and the fraudulent public key value $p_{k_e}$. Then, Bob sends this encapsulation to Alice.
    \item Mallory would then need to intercept the encapsulation value $Ct_{b}$ and transmit instead an encapsulation value $Ct_{e_{i_{0}}}$ of an execution of the \textit{Encaps} function on Alice's public key $p_{k_{a}}$. But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $Ct_{e}$ and $p_{k_a}$ its the same as the session entropy generated by Bob (which Mallory is able to calculate, as possesses all elements involved in its generation). Therefore, the attacker would generate enough encapsulation values $Ct_{e_{i}}$, looping through \textit{Encaps} executions, until one encapsulation $Ct_{e_{i_{0}}}$ satisfies the required condition.
\end{itemize}
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.75cm]{MitM attack on 2-pass KEM-based protocol}{%
     \textbf{Alice}  \> \> \textbf{Mallory} \> \> \textbf{Bob} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright{top=\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K_{be}) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \>  E_{be} = \texttt{G}(B, p_{k_e}, Ct_b, K_{be}) \\
     \> \> \> \sendmessageleft{top=\text{Ct$_b$}} \> \\
     \> \> K_{eb} = \texttt{Decaps}(Ct_b, s_{k_e}) \> \> \\
     \> \> E_{eb} = \texttt{G}(B, p_{k_e}, Ct_b, K_{eb}) \> \> \\
     \> \> \texttt{While $E_{ea} \neq E_{eb}$ do:} \> \> \\
     \> \> \quad (Ct_e, K_{ea}) \sample \texttt{Encaps}(p_{k_a}) \> \> \\
     \> \> \quad E_{ea} = \texttt{G}(B, p_{k_a}, Ct_e, K_{ea}) \> \> \\
     \> \sendmessageleft{top=\text{Ct$_e$}} \> \> \> \\
     K_{ae} = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \> \\
     E_{ae} = \texttt{G}(B, p_{k_a}, Ct_e, K_{ae}) \> \> \> \>
     }
\end{pchstack}
Note that in the above setting, if the underlying PKE is deterministic, an attacker is not able to generate the same key on both ends, since, in case that the key value is fixed to be the same on both ends, the attacker would need a different encapsulation value generated on each iteration, over the same secret 't' that generates the shared key, and this cannot be achieved on a deterministic PKE. 
\paragraph*{Combination under probabilistic PKE algorithm \label{4.1.1.3}}
In the above setting, if the underlying PKE is deterministic, an attacker is not able to generate the same key on both ends. This is due to the fact that, in case that the key value is fixed to be the same on both ends, the attacker would need a different encapsulation value generated on each iteration, over the same secret \textit{t} that generates the shared key, and this cannot be achieved on a deterministic PKE. 

On the other hand, if the underlying PKE scheme is indeed probabilistic and has not undergone a de-randomization procedure, the two attacks can happen simultaneously, as each execution of the encapsulation procedure on the same secret value yields different results.
\subsection{3-pass protocol}
In the KEX-based protocol entourage, the natural way to avoid the attacks over the 2-pass protocol was to add a commitment of the public key value of the responder before actually sending its value, so that an attacker does not have a free pass over fraudulent key pair generation. When migrating to the KEM setting, this addition is not as simple because, as discussed above, the public value generated by the responder, i.e. its encapsulation, is not independent from the public value generated by Alice, i.e. the public key, and therefore cannot commit to a value of it before actually receiving Alice's public key while maintaining a 3-pass message exchange between them.

It is therefore required for the responder to find a way to commit to a value before receiving Alice's public key, such that the commitment made effectively blocks the attacker's ability to generate different session entropy values. It is essential to precisely choose which values will conform the final session entropy value, as different choices lead to different protocols (and, thus, different security requirements). \\
We describe in this section the simplest way to achieve a 3-pass KEM-based SK-secure protocol, by incorporating two independent entropy values to be corroborated: the first entropy session value is only conformed by elements exchanged in the first two messages. The second is formed by values generated transmitted (or generated) from that third message, and directly pertaining to the final session key derived.

\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEM-based protocol}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     \> \> N \sample \{0,1\}^n \\
     \> \> (c, d) \sample \texttt{Com} (N) \\
     \> \sendmessageleft{top=c} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\  
     \> \> E_{B_1} = \texttt{G}(A, N, \pk, c) \\
     \> \> E_{B_2} = \texttt{G}(A, ct, K) \\
     \> \sendmessageleft{top=\text{(ct, d)}} \> \\ 
     K = \texttt{Decaps}(\sk, ct) \> \> \\ 
     N = Open(c, d) \> \> \\
     E_{B_1}^{\prime} = \texttt{G}(A, N, \pk, c) \> \> \\
     E_{B_2}^{\prime} = \texttt{G}(A, ct, K)}
\end{pchstack}

\begin{itemize}
    \item First, Bob generates a random value \textit{N} and sends a commitment of it to Alice.
    \item Alice stores this value and generates a key pair ($s_{k}$, $p_{k}$) and sends it to Bob.
    \item Bob, upon reception of the public key value $\pk$ of Alice, executes the \textit{Encaps} function, deriving a shared secret \textit{K} and a encapsulation value \textit{ct}, along with its session entropies, from the random element \textit{N}, its commitment \textit{c} and the public key value $\pk$, and the encapsulation value \textit{ct} and the shared key \textit{K}. Then, Bob sends the opening value \textit{d} of the random element \textit{N} previously committed, along with the encapsulation value \textit{ct} needed by Alice to derive the same key.
    \item Alice verifies that the value committed matches the commitment stored (as part of the opening function), and then decapsulates the encapsulation received with its own secret key, to access the shared secret value \textit{K}.
\end{itemize}

\subsubsection{Security of the above protocol}
Unlike the KEX scenario, here Bob has not committed itself to a element directly involved in the shared secret derivation, but instead to a random element with no direct relevance to the shared secret derivation. The reason for it is that, as discussed above, it is impossible for Bob to commit to a value that takes a role in the KEM procedure (i.e., the encapsulation) without knowing first the public key value of Alice. \\
Note that the random element committed by Bob does not influence the shared secret derived, but is critical to the security of the scheme, as it provides with a second source of randomness to the entropy value being derived, not known to any possible adversary at the time of public key value transmission(s). 
\begin{proposition} The 3-pass KEM-based protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the Hiding and Binding security properties, and the KEM scheme is IND-CPA secure. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq l \cdot ( \advantage{\texttt{IND-CPA}}{\texttt{KEM}}[] + \advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{3}{2^{n_e}})
\end{align*}
where l = $n_p^2 \cdot n_m$ and $n_p$ is the number of parties running the protocol, $n_m$ the maximum number of message sent by each party and $n_e$ the length of the entropy value generated.
\end{proposition}

\begin{proof}
    Note that, as this protocol is not directly constructed as an application of the Commitment-based compiler, we cannot directly apply theorem to prove the result. Nevertheless, we can apply the bulk of the proof of Theorem 2 to prove the required bound: \\
    As such, we have 
    \begin{align*}
        Pr[\mathcal{U} \: \texttt{wins}] \leq P[\mathcal{A} \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where $\mathcal{U}$ is an adversary against the protocol in the UM, $\mathcal{A}$ is an adversary against protocol in the AM, and forge is the event that $\mathcal{U}$ successfully sends a message \textit{m} to some party $Q$ from $P$, but $P$ never sent that message to that party. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(\mathcal{U})] \leq \advantage{SK}{\pi}[(\mathcal{A})] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(\mathcal{A})]$, when taking into consideration that any additional elements not pertaining to the natural KEM setting do not influence any generation, was proven in \cite{10.1007/978-3-031-35486-1_24} to be bounded by the IND-CPA security if the KEM procedure, times the square of the number of parties and the maximum number of session executed between any two parties. Then we just need to give a bound on the probability of the event \textit{forge}. \vspace{2mm} \\
    In this case, we distinguish two different events: the probability that an attacker successfully modifies the values \textit{$\pk$}, \textit{c} or \textit{d}, and the probability that an attacker successfully modifies \textit{ct}. 
    The first probability, for any fixed tuple $(P, Q, m)$ is modeled by the game G$_{KEM}$. We also define the intermediate games $G_0$ and $G_1$:
    \begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Game G$_{KEM}$}{\phantomsection\label{3pkemCS2}
          N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^{O_{Q'}, O_{Q}}(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^{O_{Q'}, O_{Q}}(c, \pk) \\
          (ct, K) \sample \texttt{Encaps}(\pk^*) \\
          v_1 = O_{Q'}(c, \pk^*, N) \\
          d^* \sample \adv_3^{O_{Q'}, O_{Q}}(c, N, d, ct) \\
          N^* = \texttt{Open}(c^*, d^*) \\
          K = \texttt{Decaps}(ct, \sk) \\
          v_2 = O_{Q}(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G01}
           N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^{O_{Q'}, O_{Q}}(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^{O_{Q'}, O_{Q}}(c, \pk) \\
          (ct, K) \sample \texttt{Encaps}(\pk^*) \\
          v_1 = O_{Q'}(c, \pk^*, N) \\
          N^* = \texttt{Open}(c^*, d) \\
          K \sample \texttt{Decaps}(\sk, ct) \\
          v_2 = O_{Q}(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G11}
           N \sample \{0,1\}^n \\
          (c,d) \sample \texttt{Com(N)}  \\
          c^* \sample \adv_1^{O_{Q'}, O_{Q}}(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          (ct, K) \sample \texttt{Encaps}(\pk) \\
          v_1 = O_{Q'}(c, \pk, N) \\
          N^* = \texttt{Open}(c^*, d) \\
          K \sample \texttt{Decaps}(\sk, ct) \\
          v_2 = O_{Q}(c^*, \pk, N^*) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange. \\
    Therefore, the value $\abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain random value \textit{N}, we are able to generate ($d$, $d^*$) openings such that both are valid openings of different random values \textit{N}, \textit{$N^*$} when put together with the commitment $c$, whose probability is modeled by the advantage of the game $G_{Binding^*}$. If it is not satisfied, the games $G_{KEM}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{align*}
        \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value $c$, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the public key value sent by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that given $c$ commitment of a certain random value \textit{N} we are able to extract information about such value, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the random value \textit{N}, the attacker is unable to obtain enough information to elaborate on an alternative public key value to $\pk$ that provokes a collision, and being able to modify the public key is not an advantage. Consequently, the difference lemma can be applied, and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value $c$, or when modifying the intended receiver $Q'$, which is $\frac{2}{2^{n_e}}$. \vspace{2mm}\\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{KEM}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}
    \end{align*} \vspace{2mm}
    
    The second probability is branched depending on the probability of successfully modifying the public key value exchanged before. That is 
    \begin{align*}
        & P[\texttt{forge ct}] = \\ 
        & P[\texttt{forge ct} | \texttt{forge $\pk$}] \cdot P[\texttt{forge $\pk$}] + P[\texttt{forge ct} |\neg \texttt{forge $\pk$}] \cdot P[\neg \texttt{forge $\pk$}]
    \end{align*}
    If a successful forge of the $\pk$ value happens, the probability of forging \textit{ct} is 1. If this event does not happens, the success in forging \textit{ct} is tied to the information about the derived key $K$ obtain from examining the \textit{ct} value, which will always by (strictly) bounded by the passive indistinguishability of the KEM procedure, plus the probability of a random collision. Then, the probability of the event 'forge $\pk$' is bounded by the advantage of the above game. All together, this means 
    \begin{align*}
        & P[\texttt{forge ct}] = \\ 
        & P[\texttt{forge ct} | \texttt{forge $\pk$}] \cdot P[\texttt{forge $\pk$}] + P[\texttt{forge ct} |\neg \texttt{forge $\pk$}] \cdot P[\neg \texttt{forge $\pk$}] = \\
        & P[\texttt{forge $\pk$}] + (\advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \frac{1}{2^{n_e}}) \cdot P[\neg \texttt{forge $\pk$}] < \\
        & \advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{3}{2^{n_e}}
    \end{align*}
    The probability of the intersection is best analyzed when dividing the event of modifying $c$, $N$ or $\pk$ into two disjoint sub-events: the event $A_1$ that $\pk$ does not get modified and the event $A_2$ that it does, respectively. With this consideration, we have 
    \begin{align*}
        Pr[A \cap B] = Pr[(A_1 \cup A_2) \cap B] = Pr[A_1 \cap B] + Pr[A_2 \cap B] = Pr[A_1 \cap B] + Pr[A_2] 
    \end{align*}
    as $A_2 \subseteq B$. The first term is negligible in comparison, as is formed by product of advantages. The second term is formed by the advantage against the game $G_{KEM}$, as modifying $\pk$ can be achieved by breaking either first the hiding property and then modifying the value, or modifying the value first and then breaking the binding property, plus the random collision probability. With this, we have:
    \begin{align*}
        Pr[A \cap B] = Pr[A_1 \cap B] + Pr[A_2] > \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}
    \end{align*}
    Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] < l \cdot (\advantage{\texttt{IND-CPA}}{\texttt{KEM}} + \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{3}{2^{n_e}})
    \end{align*}
    
    This proves part 2) of the definition of SK-security. We still have to show 1), that is, that two uncorrupted parties who run the protocol honestly get, if their respective session are completed, the same derived key, expect with negligible probability. But this follows from the proof above, as 2) shows that except with negligible probability, an attacker is not able to successfully modify the initator's encapsulation value. And, since the key derived is determined by this values, we get that except with (the same) negligible probability, the final key derived in two completed, matching sessions is the same.
    
    Then, since this bound happens for any adversary $\mathcal{U}$ in the UM, we have that the above protocol is SK-secure in the UM model, with the desired bound.
\end{proof}
Note that the achieved bound represents a very conservative security reduction, and provides the attacker with more 'possibilities' than the real model actually represents. This is done in order to simplify the proof as much as possible. \vspace{2mm} \\
The additional entropy $E_{B_2}$ added to be validated during the authentication phase $I_1$ procedure is needed to ensure that no message goes unauthenticated, as this breach would allow an attacker to trivially distinguish between keys on the receiver side, since it would be able to generate whatever key they desire. It is also important that this value is not added to the main entropy validation, as this values together would provide the attacker with an entry-point attack against the overall protocol. Without this additional entropy validation, and adversary could simply modify the encapsulation value \textit{ct} and the secret derived in both ends would not match. This would not provide any meaningful advantage to the attacker in practical situations, other than practical Denial of Service practices, but would have been nevertheless a breach in the theoretic security of the protocol. \vspace{1mm} \\
\textbf{Note:} It is possible to derive a 3-pass KEM-based protocol which is secure in the UM model without the need for an additional session entropy value. This alternative 3-pass KEM-based protocol with only one entropy value (contributed by the encapsulation value and the secret key derived) to be corroborated is described in detail in Annex A.

\subsection{4-pass protocol}
The modifications applied to the 3-pass KEM-based protocol were intended to provide a way for the responder to restrict the attacker's possibility while maintaining a true 3-pass exchange between them, i.e., without any party sending two consecutive messages, in a scenario in which the responder depends on the public key value sent by the inititator to generate its associate public value, the encapsulation value of the secret element. When given a 4-pass protocol, these modifications are no longer required, and we can directly apply our CS-based compiler to the 2-pass KEM-based protocol, to arrive to the following protocol:
\begin{pchstack}[boxed, center, space=1em]
    \procedure{4-pass KEM-based protocol (optimized)}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     m \sample \texttt{\{0,1\}$^n$} \> \> \\
    (d(m), c(m)) \sample \texttt{Com}(m) \> \> \\
     \> \sendmessageright*[2.5cm]{\texttt{(\pk, c(m))}} \> \\
     \> \>  N_B \sample \texttt{\{0,1\}$^n$} \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\ 
     \> \> (d(ct), c(ct)) \sample \texttt{Com} (ct) \\
     \> \sendmessageleft*[2.5cm]{\texttt{(c(ct), $N_B$)}} \> \\ 
      N_A \sample \texttt{\{0,1\}$^n$} \> \> \\
     E_A = \texttt{G}(m, c(m), N_B, \pk) \> \> \\ 
     \> \sendmessageright*[2.5cm]{\texttt{(d(m), $N_A$)}} \> \\
     \> \> m = Open(c(m), d(m)) \\
     \> \> E_A^{\prime} = \texttt{G}(m, c(m), N_B, \pk) \> \> \\ 
     \> \> E_B = \texttt{G}(ct, c(ct), N_A) \> \> \\ 
     \> \sendmessageleft*[2.5cm]{\texttt{d(ct)}} \> \\ 
     ct = Open(c(ct), d(ct)) \> \> \\
     K = \texttt{Decaps}(\sk, ct) \> \> \\
     E_B^{\prime} = \texttt{G}(ct, c(ct), N_A)}
\end{pchstack}
\begin{itemize}
    \item First, Alice generates a key pair $(\sk, \pk)$ and a random value \textit{m} uniformly, and sends the public key value $\pk$ and a commitment \textit{c(m)} of \textit{m}.
    \item Bob, upon reception of the public key value $\pk$, executes the \textit{Encaps} function on the public key received, generating the secret key value \textit{K} and an encapsulation \textit{ct}. Then, generates a commitment \textit{c(ct)} of this encapsulation value and sends it, along with a random challenge $N_B$.
    \item The inititator, upon reception of the commitment value \textit{c(ct)}, generates its own challenge $N_A$ and sends it along with the opening value \textit{d(m)} of \textit{m}.
    \item Bob verifies the commitment received at the beginning with the opening value received in this iteration and the actual value committed and, upon successful verification, calculates its entropy session value and sends the opening value \textit{d(ct)} of the encapsulation value \textit{ct} committed before.
    \item Alice verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the \textit{Decaps} function, and its corresponding session entropy.
\end{itemize}
\subsubsection{Security}
Alice's commitment is sent to ensure that the message to acknowledge reception of the commitment of the encapsulation is sent by the inititator and not a fake generation by an attacker. This intermediate message is essential to provide assurance that there is a separation between the responder sending the committed value and the actual value, so that a MitM opponent cannot modify this commitment in order to send a distorted encapsulation value that passes the verification, provided that this random value is added to the session entropy derivation. \\
With the presence of Alice's random value inside the session entropy, we ensure the following:
\begin{itemize}
    \item An attacker, because of the security properties of commitment schemes, can only succeed if is able to generate a fraudulent encapsulation value before the commitment of the real encapsulation generated by the responder reaches Alice, and that this fake encapsulation generates the same session entropy value on Alice's side that the one that the responder calculates.
    \item But, to do so the attacker needs to know all values involved on within the session entropy generation, including the random value committed by Alice at the beginning. And this value is not actually shared until after Alice receives a commitment of the encapsulation value. Therefore, the attack cannot succeed.
\end{itemize}
This is perhaps best shown by pointing out the fact that the first time the attacker is able to learn the session entropy values that the parties will calculate is well after it has been forced to commit to a encapsulation value (and, thus, a shared secret value) and to a random value. Therefore, it is not possible to replicate the attack.

The hiding property of the commitment applied ensures that no information can be obtained by only knowing the commitment, and the binding property provides assurance that, given a commitment, the advantage of generating a fraudulent opening and value that verifies the commitment is negligible. Formally, we have:

\begin{proposition} If the commitment scheme is hiding and binding, and the KEM scheme is IND-CPA secure, the 4-pass protocol is SK-secure in our UM.
\end{proposition}
 \begin{proof}
     We apply Theorem \ref{ThCompilerSK} to the 2-pass KEM-based protocol SK-secure in the AM and the compiler constructed from the CS MT-authenticator.
 \end{proof}
 The only modification over a canonical application of the CS-based compiler is the inclusion of the $\pk$ value in the first entropy session value. This is however perfectly valid, since we can add any value transmitted in the first or second message of the CS MT-authenticator without any repercussion to the validity of the authenticator. \\
 This protocol, as opposed to the 3-pass protocol, provides mutual authentication between parties, as the responder authenticates value $E_B$ against Alice, and Alice does the same against Bob with value $E_A$.

\section{Conclusions}
First, we have defined an alternative \textit{Unauthenticated Model}, following the same ideas first explained in \cite{cryptoeprint:1998/009}, but providing a different source of authentication, not based on the assumption of a initial safe exchange of cryptographic material, but rather a final safe verification phase of protocol-generated elements. This modification is consistent with the use of key exchange protocols under different security scenarios from the ones provided by the original authentication source. With the appropriate modification, we have shown that all relevant results from their model still apply to ours.

We have shown how to construct secure KEM-based protocols from 3 and 4 passes over this new UM, which requires to consider the plausible presence of MitM attackers. We have done so by first studying how equivalent KEX-based protocols would be constructed in this model, and the difficulties that naturally arise from the differences between standard KEX constructions like the Diffie-Hellman paradigm and KEM constructions.

The protocols constructed follow on the steps taken in the KEX settings, that is, generating an additional value that 'resumes' the session exchange between the two parties, and forcing any attacker to commit to a specific value before it has all the necessary information to calculate such value, so its presence is detected by inconsistencies in this value. \vspace{1mm} \\
For the 3-pass protocol a commitment value of the responder's public value is not possible, due to the dependent nature of the encapsulation value. Nevertheless, an attacker can still be blocked if the entropy value is segmented in two, the first one pertaining to elements exchange on the first two messages, and the second one related to the actual session key generated. A more complex 3-pass KEM-based protocol, which does not require entropy segmentation is explained in the Annex.

For the 4-pass protocol, it is indeed possible for the responder to generate a commitment of its public value, but it is required to show an actual separation, in terms of Alice's interaction, between the commitment value and the actual value. Therefore, a 'proof of identity' is generated, by means of yet another commitment, this time of a random value large enough to ensure Alice's identity. With this measures, we show the impossibility of a MitM attack and, consequently, the security of the protocol over our UM. \\
These protocols, based on the authentication differences between the model started by \cite{cryptoeprint:1998/009} and followed by \cite{10.1007/978-3-031-35486-1_24}, account for fewer public key operations to derive the authentication source. The authentication source provided in this new model is intended for correspondence with more practical application to communication protocols.

\bibliography{lib.bib}
\bibliographystyle{alpha}

\nocite{10.1007/978-3-030-81652-0_16}
\nocite{10.1007/11426639_8}

\section*{A: Another 3-pass KEM-based construction}

As the session entropy value is determined by the value of the shared key, along with the public values of the public key involved within its encapsulation and the encapsulation value of the secret, the restriction must be imposed within those values. \vspace{2mm} \\
Since any added value to the procedure would only modify how the values involved with the session entropy are generated, but not constrain the attack of Section \ref{4.1.1.2} and, considering that any value shared by one party, even when encrypted by means of public-key cryptography, to another could be accessed by the eavesdropper (by means of playing with the public key used to encrypt), the only plausible value for the responder to commit to is the secret value that is randomly generated at the beginning of the encapsulation procedure and that determines the final shared key value and the encapsulation value.
\subsection*{A.1: Analysis on the commitment scheme to apply \label{4.2.1}}
The selection of such value as the value to be committed forces the protocol to be extremely meticulous in relation to the information that will be divulged by the responder in order to allow the initiator to verify the committed value. Since the actual value \textit{x} will be anyways made available to the initiator, by construction of any key encapsulation scheme (and to any eavesdropper successfully in the middle), we will distinguish between commitment protocols in which the identity is part of the opening or not:
\begin{itemize}
    \item Case 1 - The Commitment Scheme selected divulges the committed value as part of the opening: In this scenario, as the secret value to be committed is encapsulated to the initiator, it is only required to transmit any other values that conform the opening. Those values, as the committed value is actually part of the opening (and therefore, not additional information about it is required), will not necessary divulge information about this value. Thus, if there exists a scheme  with the condition that, when this information is paired with the commitment value, do not divulge any information about the secret value, the rest of opening could go in clear.
    \item Case 2 - The Commitment Scheme selected does not divulge the committed value as part of the opening: In this situation, the opening transmits information about the committed value that cannot be transmitted in clear.
\end{itemize}
It should be noted that the information that conforms the opening is not suited to be encrypted by symmetric cryptography, due to the following reasons:
\begin{enumerate}
    \item Any use of the shared secret generated by the encapsulation procedure conforms, from the theoretical point of view, a break of the IND security of the scheme.
    \item No prior knowledge of a symmetric shared key is available to both ends.
    \item No other element is available to perform an encryption that any party without knowledge of the exchange is not able to decrypt.
\end{enumerate}

\subsection*{A.2: KEM variant definition}
In order to accommodate the above proposal, an alternative KEM construction is required:
\begin{definition}
A key encapsulation mechanism KEM$_{commit}$ = (KGen, KCom, Encaps*, Decaps*) of a given KEM  and Commitment Scheme consists of four algorithms:
\begin{itemize}
    \item The key generation algorithm KGen matches the key generation algorithm of the KEM being modified.
    \item The random generation algorithm KCom generates a random value, according to the distribution branded by the Encaps algorithm of the KEM mechanism (i.e. Gen) and generates a commitment of it (i.e. Com).
    \item The encapsulation algorithm Encaps*, provided a public key pk and the secret element generated by the Com function, uses the given entropy as value to be encapsulated, according to the Encaps function of the KEM scheme.
    \item  The deterministic decapsulation algorithm Decaps* matches the Decaps function of the KEM being modified, and it also outputs the secret value that conforms the final key.
\end{itemize}
\end{definition}
Therefore, a 3-pass protocol based on the above KEM$_{commit}$ definition goes as follows:
\begin{itemize}
    \item First, Bob generates a secret value, according to the underlying distribution of the KEM scheme selected, calculates its commitment value and sends it to the initiator.
    \item Alice stores this value and generates a key pair ($\sk$, $\pk$) and sends its public key value to Bob.
    \item Bob, upon reception of the public key value of Alice, executes the Encaps* function on the public key received and the secret value generated at the beginning of the process. Then, Bob sends the encapsulation generated (which contains the secret value committed), along with any additional opening value required to open the commitment.
    \item Alice verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the Decaps function, and its corresponding session entropy.
\end{itemize}
\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEM$_{commit}$-based protocol}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> (c, d) \sample \texttt{Com} (x) \\
     \> \sendmessageleft{top=c} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) \sample \texttt{Encaps$^*$}(\pk, x) \\ 
     \> \> d_{add} = d\setminus\{x\} \\
     \> \> ct_{d} \sample \texttt{Enc}(\pk, d_{add}) \\ 
     \> \> Entropy = \texttt{G}(\pk, c, K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     d_{add}' = \texttt{Dec}(\sk, ct_d) \> \> \\
     x' = Open(c, d_{add}' \cup \{x\}) \> \> \\
     (x, K) = \texttt{Decaps$^*$}(\sk, ct) \> \> \\ 
     \texttt{Abort if x $\neq$ x'} \> \> \\ 
     Entropy = \texttt{G}(\pk, c, K)}
\end{pchstack}

\begin{definition} (IND-atk KEM$_{commit}$-based protocol) We define the IND-\textit{atk}, $atk \in \{\texttt{CPA}, \texttt{CCA}\}$ game as in the figure below and the IND-\textit{atk} advantage of an adversary $\mathcal{A}$ against the above KEM$_{commit}$-based protocol as 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$_{commit}$}} := \abs{\prob{\texttt{IND-atk} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_2$: IND-CPA \pcbox{CCA}}{\phantomsection\label{mygame}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)) \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{ Encaps^*, \pcbox{Decaps}}(\pk, ct^*, K_b^*, ct_{d}, c) \\
      \pcreturn b = b'
    }}
  \begin{pcvstack}

  \procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\tau$} \\
        else \\
        \text{ return \texttt{Decaps}(sk,ct)}
   }
  \procedure[linenumbering] {Oracle $Encaps^*$}{%
         x \sample \texttt{Gen}(\secparam) \\
        (d(x),c(x)) \sample \texttt{Com}(x) \\
        (ct, K^*) = \texttt{Encaps$^*$}(\pk, x)
   }
  \end{pcvstack}
\end{pchstack}
\end{definition}

With the above definition, it is clear that the IND-\textit{atk} security of the constructed scheme is directly dependant upon the IND-\textit{atk} security of the KEM scheme and the hiding property of the commit function of the commitment scheme.

\begin{theorem}
Let KEM$^*$ := (KGen, KCom, Encaps$^*$, Decaps$^*$) be a KEM$_{commit}$-based scheme. Then, the scheme is IND-\textit{atk} secure, assuming that the underlying KEM scheme is IND-\textit{atk} secure, the commit function satisfies the hiding property, and provided that the encryption scheme of the additional opening data is IND-CPA secure. Furthermore, 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$^*$}} \leq \advantage{\texttt{IND-atk}}{\texttt{KEM}} + 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})  \\
\end{align*}
\end{theorem}

\begin{proof}
We define the intermediate games G$_0$ and G$_1$:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G0}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}}(\pk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}
    
  {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G1}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{\pcbox{Decaps}, Encaps^*}(\pk, ct^*, K_b^*, c(x^*)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
The Game G$_0$ represents the IND-atk security of the KEM protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-atk}}{\texttt{KEM}}
\end{align*}
Additionally, the intermediate game G$_1$ adds the commit value to the information available to the adversary. Therefore, the value $\abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$
represents the advantage in breaking the IND-atk security of KEM provided by the commit value of x$^*$ which, as the underlying commitment scheme satisfies the hiding property, it will always be bounded by the advantage provided in breaking the IND-CPA hiding security of the commitment (as this advantage represents the 'extra' information leaked by the commit function). Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{commit}$ is defined by:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_{commit}$}{\phantomsection\label{Gcommitx}
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      c(x^*) \sample \texttt{Com}(x^*)  \\
      b' \sample \adv(c(x^*), K_b^*) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{commit}'$}{\phantomsection\label{Gcommit'}
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv(c(x_b), K_b) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{committrue}$}{\phantomsection\label{Gcommittrue}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
To prove it, let us consider the event that knowing the commit of the secret value produces an improvement over a random guess (whose probability is twice the advantage in the game G$_{commit}$). If is not satisfied, the games G$_0$ and G$_1$ are equivalent and consequently the difference lemma can be applied \cite{cryptoeprint:2004/332}, arriving to the desired relation. \\
The game G$_{commit}$ is actually equivalent to G$_{commit}'$, as the result of applying \textbf{H}, modeled as a random oracle, to a uniform sampled value is equivalent to directly sampling $K_1$. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}} = \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
And this game is trivially harder than the game G$_{committrue}$, as being in possession of the tuple (x$_0$, x$_1$) makes it clearly easier to solve (same objective with additional information). This last game is in turn the precise definition of the hiding property of the commitment scheme. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}} \leq \abs{\prob{\texttt{G$_{committrue}$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
Together, we have:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
\vspace{2mm} \\
On the other hand, the game G$_2$ represents the IND-CCA security of the KEM$^*$ protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CCA}}{\texttt{KEM$^*$}}
\end{align*}
and, consequently, the value $\abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage in breaking the IND-CCA security of KEM$^*$ provided by the encrypted opening information shared. This value is bounded by the advantage provided in breaking the IND-CPA security of the encryption scheme (as this advantage represents the 'extra' information leaked by the commit function) and the advantage of knowing the opening, together with the commitment. Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{opening}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{opening}$ is defined by:
\begin{pchstack}[boxed, center, space=1em]
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}$}{\phantomsection\label{Gopening}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      (c(x^*), d(x^*)) \sample \texttt{Com}(x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)\setminus\{x^*\}) \\
      b' \sample \adv^{\oracle}(ct_{d}, K_b^*, \pk) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{openingtrue}$}{\phantomsection\label{Gopeningtrue}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2^{\oracle}(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
  \end{pcvstack}
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}'$}{\phantomsection\label{Gopening'}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv^{\oracle}(K_b, ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
    \procedure[linenumbering] {Oracle $\oracle(d)$}{%
        \text{return \texttt{Info}(d, c(x$^*$))}
   }
  \end{pcvstack}
\end{pchstack}
To prove it, a similar argument to the one before can be applied first to reach the bound 
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} 
\end{align*}
considering the difference lemma event as the event that knowing the encrypted opening provides an advantage over a random guess (whose probability is twice the advantage in the game G$_{opening}$). \vspace{2mm} \\
The advantage against the game G$_{openingtrue}$ (and, consequently, over the intermediate game G$_1$, against the IND-atk security of the KEM$^*$ scheme) would come from being able to extract information about the opening from its encryption and, simultaneously, that such information, when put together with the commitment (represented by the oracle $\oracle$), reveals information about the secret value that allows to elaborate on the guess. Formally: 
\begin{align*}
     \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}
\end{align*}
where the value $\advantage{\texttt{IND-CPA}}{\texttt{Opening}}$ is defined as the advantage in winning the game G$_{aux-open}$: 
\begin{pchstack}[boxed, center, space=1em]
       {\procedure[linenumbering]{Game G$_{aux-open}$}{\phantomsection\label{Gclearopening}
          (x_0, x_1) \sample \adv_1 (\secparam)  \\
          b \sample \bin  \\
          (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
          (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
          b' \sample \adv_2^{\oracle}(d(x_b)\setminus\{x_b\}) \\
          \pcreturn b = b'
        }}
        \procedure[linenumbering] {Oracle $\oracle(d)$}{%
            \text{return \texttt{Info}(d, c(x$_b$))}
       }
\end{pchstack}
\begin{align*}
    \advantage{\texttt{IND-CPA}}{\texttt{Opening}} := \abs{\prob{\texttt{G$_{aux-open}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
For the product above, let us consider the event E$_{openingtrue}$ of winning the game G$_{openingtrue}$, with an advantage over the random guess, as the intersection of the two events E$_{enc}$ and E$_{opening}$ defined above. That is: the event that knowing the encryption of the opening provides an advantage in distinguishing over the random guess, and the event that this information, when paired with the commitment, provides a significant advantage in distinguishing over a random guess.

The probability of the event E$_{openingtrue}$ (which is twice the advantage of the game G$_{openingtrue}$) is then the probability of the intersection of the two events, which is determined by the formula $$P(E_{enc}) \cdot P(E_{opening}|E_{enc})$$ in which both terms are twice the advantage against the following games, respectively:
\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_{aux1}$}{\phantomsection\label{Genc}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
   {\procedure[linenumbering]{Game G$_{aux2}$}{\phantomsection\label{Gopeningaux}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      \alpha \sample \adv_2(ct_d) \\
      b' \sample \adv_3^{\oracle}(\alpha) \\
      \pcreturn b = b'
    }}
\end{pchstack}
It is clear that this games are harder that the games G$_{ind-cpa}$ and G$_{aux-open}$, respectively:
\begin{itemize}
    \item In the first one the adversary does not directly chooses which plaintexts will be ciphered.
    \item The second game, the adversary is provided with information about the opening value provided by successfully breaking the game G$_{aux1}$, but this advantage can only be as good as the opening value itself, which is known in the game G$_{aux-open}$.
\end{itemize}
Therefore arriving to the required bound:
\begin{align*}
    2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} = P(E_{enc}) \cdot P(E_{opening}|E_{enc}) = \\
    (2 \cdot \abs{\prob{\texttt{G$_{aux1}$} \Rightarrow 1} - \frac{1}{2}}) \cdot (2 \cdot \abs{\prob{\texttt{G$_{aux2}$} \Rightarrow 1} - \frac{1}{2}}) \leq
    (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}}) \cdot (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})
\end{align*}
\vspace{5mm} \\
All together, this means that 
\begin{align*}
    \advantage{\texttt{IND-atk}}{\texttt{KEM$^*$}} = \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}) +  2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + \advantage{\texttt{IND-atk}}{\texttt{KEM}}
\end{align*}
\end{proof} 
As discussed in Section \ref{4.2.1}, two scenarios could be considered, in the hypothesis around the opening value of theorem 4.3:
\begin{enumerate}
    \item The opening value, without the actual committed value, does not divulge any information about the value even when paired with the Commit value. Then the advantage of extracting information about the committed value (and thus about the key) is negligible and the protocol verifies Theorem 4.3, without requirement about encrypted opening.
    \item The opening value without the committed value divulges information about the committed value, when paired with the commitment, or the committed value is npt part of the opening. Then, the opening value would be required to be encrypted, with an encryption scheme that satisfies it is IND-CPA secure. Then, the protocol verifies Theorem 4.3.
\end{enumerate}
Note that the reductions applied to prove the advantage's bound explicitly show the difficulties of an attacker against the modified KEM scheme defined, as it doesn't know the secret value used to derive the key and therefore its commitment might prove even harder to crack, and the same with the opening values chosen to generate such commitment.
\subsection*{A.3: Security}
The advantage of committing to a precise value of the secret element used to derive the shared key is clear: The attack against the 2-pass KEM-based protocol exploited the fact that an attacker could encapsulate different instances of this secret element (which, in turn, generates different encapsulation and shared key values) until one produces a combination that yields the same session entropy value generated by the responder.
With the inclusion of a commitment scheme around this secret element, the biding property of the scheme ensures that an attacker's ability to generate a different instance such that the commitment value made by the responder matches the one generated by them is negligible. Therefore, the value of the secret key is determined when sending the commit value and, consequently, fixing yet another value that conforms the entropy session.

We now give a sketch of the formal proof the SK-security of this protocol in our UM model:\\
\textbf{Proposition:} The above protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the Hiding and Binding security properties, and the KEM-commit scheme is IND-CPA secure. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq \advantage{\texttt{IND-CPA}}{\texttt{KEM-commit}}[] + l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
\end{align*}
\begin{proof}
    As with the 3-pass KEM-based proof, we can directly apply the bulk of the proof of Theorem 2 in \cite{10.1007/978-3-031-35486-1_24} to prove the required bound: \\
    As such, we have 
    \begin{align*}
        Pr[U \: \texttt{wins}] \leq P[A \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where U is an adversary against the protocol in the UM, A is an adversary against the same protocol, but in the AM, and forge is the event that U successfully sends a message \textit{m} to some party $P_j$ from $P_i$ but $P_i$ never sent that message. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(U)] \leq \advantage{SK}{\pi}[(A)] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(A)]$  was proven in \cite{10.1007/978-3-031-35486-1_24} to be bounded by the IND-CPA security of the underlying KEM procedure, times the square of the number of parties and the maximum number of session executed between any two parties. Even though we are considering now a modified KEM procedure, the proof remains the same.  
    
    Then we just need to give a bound on the probability of the event 'forge'.\vspace{2mm} \\
    This probability, for any fixed tuple $(P_i, P_j, m)$ is modeled by the game G$_{ent-com}$: 
    \begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Game G$_{ent-com}$}{\phantomsection\label{3pkemCScom}
          x \sample \texttt{Gen}() \\
          (c,d) \sample \texttt{Com(x)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{$Encaps^*$}(\pk^*, x) \\
          d_{add} = d\setminus\{x\} \\
          ct_{d} \sample \texttt{Enc}(\pk^*, d_{add}) \\ 
          v_1 = O(\pk^*, c, K) \\
          (ct_d^*, ct^*) \sample \adv_3^O(c, ct_d, ct, \pk) \\
          d_{add}' = \texttt{Dec}(\sk, ct_d^*) \\
          x' = Open(c^*, d_{add}' \cup \{x\}) \\
          (K^*, x') = \texttt{$Decaps^*$}(ct^*, \sk) \\
          v_2 = O(\pk, c^*, K^*) \\
          \pcreturn (v_1 = v_2) \wedge (v_i \neq \bot)
        }}
      {\procedure[linenumbering]{Game G$_2$}{\phantomsection\label{3pkemCScomaux}
          x \sample \texttt{Gen}() \\
          (c,d) \sample \texttt{Com(x)}  \\
          c^* \sample \adv_1^O(c) \\
          (\sk, \pk) \sample \texttt{KGen()} \\
          \pk^* \sample \adv_2^O(c, \pk) \\
          (ct, K) \sample \texttt{$Encaps^*$}(\pk^*, x) \\
          d_{add} = d\setminus\{x\} \\
          ct_{d} \sample \texttt{Enc}(\pk^*, d_{add}) \\ 
          v_1 = O(\pk^*, c, x) \\
          (ct_d^*, ct^*) \sample \adv_3^O(c, ct_d, ct, \pk) \\
          d_{add}' = \texttt{Dec}(\sk, ct_d^*) \\
          x' = Open(c^*, d_{add}' \cup \{x\}) \\
          (K^*, x') = \texttt{$Decaps^*$}(ct^*, \sk) \\
          v_2 = O(\pk, c^*, x') \\
          \pcreturn (v_1 = v_2) \wedge (v_i \neq \bot)
        }}
    \end{pchstack}
    This game is extremely similar to the one defined to prove the authenticator property of the CS MT defined above, but only adding the elements pertaining to the KEM procedures. The only major difference is the presence of the derived key in the entropy calculation, as opposed to the \textit{x} secret value that should be present to mimic the CS MT proof. Under the supposition $K = O(\pk, x)$, this game is actually equivalent to game $G_2$. \vspace{2mm} \\
    Since the encapsulation value do not influence the final 'entropy' values generated, and the public key value can be considered as a random element drawn (in the same way as the equivalent nonce is drawn in the proof of CS MT), the proof described there applies here, with only modifying the games accordingly. Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{1}{2^{n_e}})
    \end{align*}

    And then, since this bound happens for any adversary U in the UM, we have that the above protocol is SK-secure in the UM model.
\end{proof}

We note two aspects that might have gone unnoticed in the above proof: first, the supposition regarding the way the shared key is derived. This supposition might seem restrictive at first, but it is only the natural construction in most KEM construction in consideration nowadays. 

The second deals with the implicit verification of matching secrets by the inititator at the end of the procedure. We can suppose this elements are actually equal, since the game (and therefore the proof) deals with 'completed sessions' and a inequality between those values yields a null session. Note that, were this verification not happening, the protocol would not be SK-secure, as the commitment would not be effectively playing any role in the key derivation.

\subsection*{A.4: Practical instance}
We propose a practical instance of the 3-pass KEM based protocol idea described above, with an IND-CCA KEM instance based upon an IND-CPA PKE scheme that is de-randomized inside the encapsulate procedure, combined with a commitment scheme based upon a collision-resistant hash function: \vspace{4mm}

\begin{pchstack}[boxed, center, space=1em]
    \procedure{Example 3-pass KEM$_{commit}$-based protocol instance}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> m \sample \texttt{\{0,1\}$^n$} \\
     \> \> c(x) = H(x||m) \\
     \> \sendmessageleft{top=c(x)} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) = \texttt{Encaps}(\pk, x) \\ 
     \> \> ct_{d} \sample \texttt{Enc}_{\text{PKE}}(\pk, m) \\
     \> \> Entropy = \texttt{G}(p_k, c(x), K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     m' = \texttt{Dec}_{\text{PKE}}(\sk, ct_d) \> \> \\
     (x', K) = \texttt{Decaps}(\sk, ct) \> \> \\ 
     \texttt{Abort if H(x'||m') $\neq$ c(x)} \> \> \\
     Entropy = \texttt{G}(p_k, c(x), K)}
\end{pchstack}
A plausible algorithm selection could be the NIST's selection for PQC-KEM standardization, CRYSTALS-Kyber \cite{conf/eurosp/BosDKLLSSSS18}, which satisfies that its underlying PKE is IND-CPA, and any collision resistant hash function, with an appropriate output length.

\section*{B: Optimizing the 4-pass KEM-based protocol in the UM}
From the 2-pass KEM-based secure protocol in the AM, and the compiler $C_\lambda$ based on the CS-based MT authenticator we have the following (unoptimized) protocol, formed by 3 $\cdot$ 2 = 6 messages: \vspace{2mm} \\
The first three messages are the MT-authentication of the message \textit{m} (along with the inclusion of extra element $\pk$ sent on the first message) sent by the initiator, and we define this exchange as $\lambda_I$. The second part of the exchange amounts to the MT-authentication of element \textit{ct} sent by the responder, and we define this exchange as $\lambda_R$. Then
\begin{itemize}
    \item Sending together 2nd message of $\lambda_I$ with the 1st message of $\lambda_R$ as the second message of the protocol, and
    \item Sending the 3rd message of $\lambda_I$ with the 2nd of $\lambda_R$ as the 3rd message of the protocol.
\end{itemize}
we have the optimized 4-pass protocol.
\begin{pchstack}[boxed, center, space=1em]
    \procedure{6-pass KEM-based protocol (unoptimized)}{%
     \textbf{Alice} \> \> \textbf{Bob} \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     m \sample \texttt{\{0,1\}$^n$} \> \> \\
    (d(m), c(m)) \sample \texttt{Com}(m) \> \> \\
     \> \sendmessageright{top=\texttt{(\pk, c(m))}} \> \\
     \> \>  N_B \sample \texttt{\{0,1\}$^n$} \\
     \> \sendmessageleft{top=\texttt{$N_B$}} \> \\
     Entropy_A = \texttt{G}(\pk, m, c(m), N_B) \> \> \\
     \> \sendmessageright{top=\texttt{d(m)}} \> \\
     \> \> m' = Open(c(m), d(m)) \\
     \> \> Entropy_A = \texttt{G}(\pk, m', c(m), N_B) \> \> \pclb
     \pcintertext[dotted]{$\lambda_I - \lambda_R$ division} \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\ 
     \> \> (d(ct), c(ct)) \sample \texttt{Com} (ct) \\
     \> \sendmessageleft{top=\texttt{c(ct)}} \> \\ 
      N_A \sample \texttt{\{0,1\}$^n$} \> \> \\
     \> \sendmessageright{top=\texttt{$N_A$}} \> \\ 
     \> \> Entropy_B = \texttt{G}(ct, c(ct), N_A) \> \> \\ 
     \> \sendmessageleft{top=\texttt{d(ct)}} \> \\ 
     ct' = Open(c(ct), d(ct)) \> \> \\
     K = \texttt{Decaps}(\sk, ct) \> \> \\
     Entropy_B = \texttt{G}(ct, c(ct), N_A)}
\end{pchstack}
Despite reordering some messages, all the 'local' orders between authentication elements are respected: no challenge is unveiled before the commitment of the element they are challenging, and no opening is sent before is associated commitment. \vspace{2mm} \\
The actual 2-pass KEM-based protocol used as base for constructing this 4-pass protocol is not exactly the one defined above, but rather an 'artificial' modification in which two messages are transmitted on the first iteration (so that, once the compiler is applied, only one of them is actually committed, but both of them contribute to the entropy value). This is however perfectly valid, since we can add any value transmitted in the first or second message of the CS MT-authenticator without any repercussion to the validity of the authenticator. \\
It is easy to prove that any additional value included in the entropy value that is sent on the first two messages of the CS-based MT-authenticator still produces a valid MT-authenticator, as in this two messages, there are still values under the protection of the hiding property of the CS and therefore not all information is available to an attacker. \\
With this in mind, the SK-security of the 4-pass KEM-based protocol on the UM is a direct application of Theorem \ref{ThCompilerSK}.


\section*{C: Proof of SK-security of the 3-pass KEX-based protocol in the UM}
In this section, we provide the direct proofs of the SK-security of the 3-pass KEX-based protocol described above.

\begin{proposition}
The 3-pass DH-based protocol is SK-secure in our UM model, if the underlying commitment scheme satisfies the hiding and binding security properties, and the DDH assumption. Formally: 
\begin{align*}
    \advantage{\texttt{SK}}{\pi}[(UM)] \leq l \cdot (\advantage{\texttt{DDH}}{\texttt{DH}}[] + \advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{2}{2^{n_e}})
\end{align*}
where l = $n_p^2 \cdot n_m$ and $n_p$ is the number of parties running the protocol, $n_m$ the maximum number of message sent by each party and $n_e$ the length of the entropy value generated.
\end{proposition}
\begin{proof}
    We can directly apply the bulk of the proof of Theorem 2 in \cite{10.1007/978-3-031-35486-1_24} to prove the required bound, since the only use of $\pi' = C_\lambda(\pi)$ is to define the distinguisher's advantage as $\pi'$ $\epsilon$-emulation of $\pi$ in the UM, which is of no interest in this proof. \\
    As such, we have 
    \begin{align*}
        Pr[U \: \texttt{wins}] \leq P[A \: \texttt{wins}] + \frac{P[\texttt{forge}]}{2}
    \end{align*}
    Where U is an adversary against the protocol in the UM, A is an adversary against the same protocol, but in the AM, and forge is the event that U successfully sends a message \textit{m} to some party $P_j$ from $P_i$ but $P_i$ never sent that message. We can rewrite the above as 
    \begin{align*}
        \advantage{SK}{\pi}[(U)] \leq \advantage{SK}{\pi}[(A)] + P[\texttt{forge}]
    \end{align*}
    The term $\advantage{SK}{\pi}[(A)]$, when taking into consideration that any additional elements not pertaining to the natural DH setting do not influence any generation, was proven in \cite{10.1007/3-540-44987-6_28} to be bounded by the DDH assumption, times the square of the number of parties and the maximum number of session executed between any two parties. Then we just need to give a bound on the probability of the event 'forge'. \vspace{2mm} \\
    This probability, for any fixed tuple $(P_i, P_j, m)$ is modeled by the game G$_{DH}$. We also define, for the sake of the proof, the intermediate games $G_0$ and $G_1$:
    \begin{pchstack}[ boxed , center, space=1em]
      {\procedure[linenumbering]{Game G$_{DH}$}{\phantomsection\label{3pkDHCS}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          g^{a^*} \sample \adv_2^O(c, g^a) \\
          K = (g^{a^*})^b = g^{ba^*} \\
          v_1 = O(c, g^{a^*}, g^b) \\
          d^* \sample \adv_3^O(c, g^b, d) \\
          g^{b^*} = \texttt{Open}(c^*, d^*) \\
          K^* = (g^{b^*})^a  = g^{ab^*} \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G02}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          g^{a^*} \sample \adv_2^O(c, g^a) \\
          K = (g^{a^*})^b = g^{ba^*} \\
          v_1 = O(c, g^{a^*}, g^b) \\
          g^{b^*} = \texttt{Open}(c^*, d) \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
        
      {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G12}
          (b, g^b) \sample \mathbf{N} \\
          (c,d) \sample \texttt{Com($g^b$)}  \\
          c^* \sample \adv_1^O(c) \\
          (a, g^{a^*}) \sample \mathbf{N} \\
          K = (g^a)^b = g^{ba} \\
          v_1 = O(c, g^a, g^b) \\
          g^{b^*} = \texttt{Open}(c^*, d) \\
          v_2 = O(c^*, g^a, g^{b^*}) \\
          b_1 = (v_1 == v_2) \\
          b_2 = (v_i \neq \bot) \\
          \pcreturn b_1 \wedge b_2
        }}
    \end{pchstack}
    where intuitively each game represents an additional layer where the attacker behaves like the AM model: in game $G_0$, the attacker does not modify the flow of the last exchange and in game $G_1$ the attacker only modifies the first exchange. \\
    Therefore, the value $\abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the opening value received by the responder, which is bounded by the advantage in breaking the binding security of the commitment scheme. Formally: \begin{align*}
    \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding} \Rightarrow 1}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain public key value $g^a$, we are able to generate (d, $d^*$) openings such that both are valid openings of different public keys $g^a$,  $g^{a^*}$ when put together with the commitment c, whose probability is modeled by the advantage of the game $G_{Binding^*}$. If it is not satisfied, the games $G_{DH}$ and $G_0$ are equivalent and the difference lemma \cite{cryptoeprint:2004/332} can be applied. Consequently: 
    \begin{align*}
        \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq \abs{\prob{\texttt{Binding$^*$} \Rightarrow 1}}
    \end{align*}
    And the game $G_{Binding^*}$ is clearly harder that the game $G_{Binding}$, as in the later, the adversary is the one to draw the commitment value c, as opposed to the former. Therefore arriving to the desired bound.\vspace{2mm} \\
    Then, the value $\abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}$ represents the advantage of the attacker in generating a collision between the oracle output from both parties when being able to modify the commitment value received by the responder, which is bounded by the advantage in breaking the hiding security of the commitment scheme. Formally: 
    \begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}}
    \end{align*}
    To prove it, let us consider the event that given c commitment of a certain value $g^{b}$, we are able to extract information about the value $g^{b}$, whose probability is modeled by the advantage of the game $G_{Hiding}$. If it is not satisfied, the games $G_0$ and $G_1$ are equivalent, as without the value $g^{b}$, the attacker is unable to obtain enough information to elaborate of a guess of $g^{a^*}$ to provoke a collision and being able to modify the value is not an advantage. Consequently, the difference lemma can be applied, and the desired bound is reached. \vspace{2mm}\\
    Lastly, the advantage of the game $G_{1}$ is exactly the probability of a random collision between inputs when modifying the commitment value $c$, or the intended receiver $Q'$, which is $\frac{2}{2^{n_e}}$. \vspace{2mm}\\
    When put together, we have the following:
    \begin{align*}
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1}} \leq \\ 
        & \abs{\prob{\texttt{G$_{DH}$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_{0}$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1}} \leq \\
        & \advantage{\texttt{Hiding}}{\texttt{CS}} + \advantage{\texttt{Binding}}{\texttt{CS}} + \frac{2}{2^{n_e}}
    \end{align*}
     Therefore, when taking into consideration every possible pair of parties and messages between them, we have
    \begin{align*}
        P[\texttt{forge}] \leq l \cdot (\advantage{\texttt{Hiding}}{\texttt{CS}}[] + \advantage{\texttt{Binding}}{\texttt{CS}}[] + \frac{2}{2^{n_e}})
    \end{align*}

    This proves part 2) of the definition of SK-security. We still have to show 1), that is, that two uncorrupted parties who run the protocol honestly get, if their respective session are completed , the same derived key, expect with negligible probability. But this follows from the proof above, as 2) shows that except with negligible probability, an attacker is not able to successfully modify the public key values exchanged between two parties. And, since the key derived is determined by those values, we get that except with (the same) negligible probability, the final key derived in two completed and matching sessions is the same.

    And then, since this bound happens for any adversary U in the UM, we have that the above protocol is SK-secure in the UM model.
\end{proof}

\textbf{Note:} The end of the proof shows that we could actually include the derived key \textit{K} as part of the values that conform the opening, since its determinism in the generation from the public key values does not open any possibilities for an attacker to exploit.

\end{document}
