\documentclass[11pt,twoside]{article}
\usepackage[english]{babel} 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[top = 3cm ,bottom = 3cm,left= 3cm,right = 3cm]{geometry}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[all]{xy}
\usepackage{lipsum}
\usepackage{fancyhdr}

\usepackage{authblk}

\usepackage [
n,
advantage,
operators,
sets,
adversary,
landau,
probability,
notions,
logic,
ff,
mm,
primitives,
events,
complexity,
oracles,
asymptotics,
keys
]{cryptocode}
\createprocedureblock{game}{center,boxed}{}{}{}
\usepackage{lipsum}

\usepackage{float}
\floatstyle{ruled} % Defines the "rule" style for next environments defined using newfloat.
\newfloat{protocol}{htb!}{Protocol}

\usepackage{hyperref}
\usepackage{cleveref}
\crefname{protocol}{Protocol}{Protocols}
\Crefname{protocol}{Protocol}{Protocols}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE]{\title{Provably secure KEM-based protocols over unauthenticated channels}}
\fancyhead[LO]{\author{Rodrigo Martín Sánchez-Ledesma \textit{et al.}}}
\fancyfoot[C]{\thepage}

\setlength{\headheight}{13.59999pt}

\raggedbottom

\usepackage{titlesec}
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\title{Provably secure KEM-based protocols over unauthenticated channels}
\author[1,2]{\rm Rodrigo Martín Sánchez-Ledesma}
\author[2]{\rm David Domingo Martín}
\author[3]{\rm Iván Blanco Chacón}
\author[1]{Ignacio Luengo Velasco}
\affil[1]{Universidad Complutense de Madrid}
\affil[ ]{\texttt {\{rodrma01,iluengo\}@ucm.es}}
\affil[2]{Indra Sistemas de Comunicaciones Seguras S.A}
\affil[ ]{\texttt {\{rmsanchezledesma,ddomingo\}@indra.es}}
\affil[3]{Universidad Alcalá de Henares}
\affil[ ]{\texttt {ivan.blancoc@uah.es}}
\date{July 8, 2023}

\begin{document}

\maketitle
\textbf{Abstract:} In this paper we propose a number of KEM-based protocols to establish a shared secret between two parties, and study their resistance over unauthenticated channels. This means analyzing the security of the protocol itself, and its robustness against Man-in-the-Middle attacks. We compare them with their KEX-based counterparts to highlight the differences that arise naturally, due to the nature of KEM constructions, in terms of the protocol itself and the types of attacks that they are subject to. We provide practical go-to KEM-based protocols instances to migrate to, based on the conditions of currently-in-use KEX-based protocols.

\section{Introduction}

Secure key exchange protocols are a fundamental part of cryptography and perhaps one of the most important paradigms in asymmetric cryptography. This kind of protocols allows two parties without any previous common knowledge of any shared information to be in possession of a shared secret. This secret is then usually used to encrypt the information transmitted from one to another, by means of any symmetric encryption algorithm. It is therefore imperative for this kind of protocols to be secure and provide assurance that, at the end of it, the generated shared secret is only known to the two parties involved.

Currently, this kind of protocols are mostly based on KEX-type solutions like Diffie-Hellman variants (DH, ECDH, ...) and similar algorithms. In the 90's, a series of quantum algorithms were published, including Shor's algorithm \cite{Shor_1997}, that were shown to effectively solve the mathematical problems behind most public-key cryptography algorithms, including those who were the basis of current Diffie-Hellman instances, like discrete logarithm problem or the factorization of numbers problem. This critical findings, along with the practical advance on the development of quantum computers and the difficulty and cost of migrating schemes, forced the cryptography community to start finding alternatives that are resistant to quantum computing. In this scenario, in 2016, the National Institute for Standards and Technologies (NIST) announces the launch of a competition, with the objective of coming together with quantum-resistant cryptographic solutions for public-key cryptography needs, specifically being suitable digital signature and key establishment. With regards to key establishment, the call specified that looked for Key Encapsulation Mechanisms specifications, which not only are efficient and versatile but also easy to derive from weaker Public Key Encryption algorithms, based on transformations such as Fujisaki-Okamoto and variants \cite{cryptoeprint:2017/604} \cite{cryptoeprint:2002/174}.

Based on the wide spread of KEX-based protocols, it is important that quantum-resistant solutions are as little disruptive as possible, to facilitate their adoption as soon as possible, so that any information that is stored when quantum computers are available no longer poses a threat.

\subsection{Our contributions}

Because of the above reasons, it is the objective of this paper to come with KEM-based protocols that are easy to adopt for solutions which already have in place a key establishment protocol based on compromised key exchange algorithms, while proving secure over unauthenticated channels, which is a necessary requirement in the vast majority of situations. This analysis include considering the plausible presence of Man-in-the-Middle attackers, whose aim is to eavesdrop the communication between the two parties, by means of modifying the messages exchanged during the key establishment protocol, so that its presence goes unnoticed.

We will first analyze a number of KEX-based protocols for secure key establishment, breaking them by the number of messages exchange, and their measures to counterfeit MitM attacks. Then we will analyze how the specific nature of Encapsulation Mechanism forces more difficulties in order to come with secure KEM-based key establishment protocols and the measures needed to ensure such security. Lastly, we will specify a number of KEM-based protocols, using the same classifications as above and their security under the same assumptions as in the key exchange scenario.

Special focus will be put around the figure of a MitM: we will analyze the possibilities of such an attacker in KEX-based protocols and how to detect and avoid them. Then we will see that the measures applied in this setting do not translate naturally, under the same conditions, and what measures are required to block this kind of attacks in KEM-based protocols, depending on the inherent conditions of the key encapsulation mechanism in use. Despite the conceptual differences between the two methods, the measures that will be put in place to avoid such an attack are the same: along with the primary objective, which is the shared secret key, the protocol will also generate a second output, which will be referred to as 'session entropy'. This value will conceptually be a 'summary' of the session between the two parties, as it will be directly inferred by the shared values used throughout the process. This value is important as it will determine whether the session has been successful or it has been tampered with. How this value can then be used between the two parties to check for a MitM presence is outside the scope of this work and will not be addressed.

\section{Preliminaries}

\textbf{Definition 2.1}: A key encapsulation mechanism KEM = (KGen, Encaps, Decaps) consists of three algorithms. The key generation algorithm KGen generates a key pair $(\pk, \sk)$. The encapsulation algorithm Encaps, provided a public key value $\pk$, outputs the pair (K, c), where c is the encapsulation of a random value 'x' that determines the shared key K, by means of an underlying PKE scheme. The deterministic decapsulation algorithm Decaps, provided the secret key $\sk$ and the encapsulation, outputs the same key K by extracting the random value from the encapsulation. \vspace{2mm}\\
Depending on the probabilistic nature of the underlying PKE scheme, we will distinguish between:
\begin{itemize}
    \item Probabilistic-based KEM, if two encapsulations of the same secret with the same public key give rise to different results.
    \item Deterministic-based KEM, if two encapsulations of the same secret with the same public key give rise to the same result. Note that this doesn't necessarily mean that the PKE scheme is itself deterministic, as it could have undergone a de-randomization transformation.
\end{itemize}
Regardless of the probabilistic nature of the underlying PKE scheme, the KEM scheme is always probabilistic. \vspace{2mm}\\
\textbf{Definition 2.2} (IND-CCA KEM scheme) We define the IND-CCA game as in the figure below and the IND-CCA advantage of an adversary \textbf{A} against the above KEM scheme as 
\begin{align*}
    \advantage{\texttt{IND-CCA}}{\texttt{KEM}} := \abs{\prob{\texttt{IND-CCA} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{$\indcca^\adv(\secpar)$}{\phantomsection\label{kemgame}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{Decaps}(\sk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}
  \begin{pcvstack}

  \procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\tau$} \\
        else \\
        \text{return \texttt{Decaps}(sk,ct)}
   }
  \end{pcvstack}
\end{pchstack}
\textbf{Definition 2.3}: A Commitment Scheme is a triple (Setup, Com, Open) such that:
\begin{itemize}
    \item $CK \sample \texttt{Setup}(\secparam)$ generates the public commitment context.
    \item for any $ m \in M$, $(c, d) \sample \texttt{Com}$(m) is the commitment/opening pair for m. c = c(m) serves as the commitment value, and d = d(m) as the opening value.
    \item Open(c, d) = $m'\in M \cup \bot$, where $\bot $ is returned if c is not a valid commitment to any message. It is often omitted mentioning the public context CK when clear.
\end{itemize}
The following properties must be achieved:
\begin{pchstack}[boxed, center, space=1em]
      {\procedure[linenumbering]{Hiding}{\phantomsection\label{Hiding}
      CK \sample \texttt{Setup}(\secparam) \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_b), d(x_b)) \sample \texttt{Com}(x_b)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
      {\procedure[linenumbering]{Biding}{\phantomsection\label{Biding}
      CK \sample \texttt{Setup}(\secparam) \\
      (c, d, d') \sample \adv (\secparam)  \\
      m = Open(c, d)  \\
      m' = Open(c, d')  \\
      \pcreturn m = m' \neq \bot
    }}
\end{pchstack}
\begin{align*}
    \advantage{\texttt{Hiding}}{\texttt{CS}} := \abs{\prob{\texttt{Hiding} \Rightarrow 1} - \frac{1}{2}} \leq \text{negl($\lambda)$} \\
    \advantage{\texttt{Biding}}{\texttt{CS}} := \prob{\texttt{Biding} \Rightarrow 1} 
    \leq \text{negl($\lambda)$} \\
\end{align*}
\textbf{Definition 2.4}: We define the \textit{entropy session} as a deterministic digest of shared elements involved within a protocol key establishment. This means, determined upon shared secret values and transmitted public values. Within each protocol, the specific values that will conform this entropy session value will be established. The necessity of involving the public values will become apparent on KEM-based protocols.

Due to common uses of this value, its size is restrained to be as small as possible, to facilitate usability. Nevertheless, the bigger this value is, the higher the protection it provides, as it increases the computational complexity of the attacks against it, as it will become clear below.

\section{KEX-based protocols}

Cryptographic protocols based on key exchange algorithms are vastly used in all sorts of different scenarios, a great deal of those through insecure channels. This protocols are defined in terms of the number of exchanged messages needed to complete it, and the information sent on each message.

\subsection{2-pass protocol}

The minimum requirement for an successful KEX-based shared secret establishment is 2 messages. The protocol would go as follows:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEX-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> K_{ab} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> Entropy = \texttt{G}(p_{k_a}, p_{k_b}, K_{ab}) \\ 
     \> \sendmessageleft{top=\text{p$_{k_b}$}} \> \\ 
     K_{ba} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     Entropy = \texttt{G}(p_{k_a}, p_{k_b}, K_{ba}) \> \>}
\end{pchstack}

\begin{itemize}
    \item The initiator generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KeyGen() function of the specific KEX selected. Then, the public value $p_{k_a}$ is sent to the responder.
    \item  The responder, upon reception of the initiator's public key $p_{k_a}$, generates another key pair ($s_{k_b}$, $p_{k_b}$) with the same algorithm KeyGen(), to then execute the KeyAgreement function, with inputs its own secret key $s_{k_b}$ and the other end's public key $p_{k_a}$. The execution of this function yields a secret key $K_{ab}$. Then, the responder sends its own public key $p_{k_b}$ to the initiator.
    \item With the responder's public key, the initiator executes the same KeyAgreement function, on its own private key and the received public key, to derive the shared secret $K_{ba}$. If no interference has happened, the KEX algorithm ensures that $K_{ab}$ = $K_{ba}$.
\end{itemize}

\subsubsection{Security of the above protocol \label{3.1.1}}

The security of the protocol itself, without any interference, is based on the security of the underlying key exchange algorithm selected, and the unique possession by both ends of their respective secret keys.

Over insecure channels, neither party has any assurance that the public key values received indeed corresponds to the actual values sent by the other party. This particular situation  is the very foundation of the presence of the session entropy value calculated by both ends on the protocol. But, even in the above scenario, the presence of such value, which seeks to represent a digested version of all shared values (public and private) involved in the key establishment process, is not enough to avoid MitM interference. The attack against this protocol goes as follows:

\begin{itemize}
    \item When the initiator sends its public key, the attacker intercepts this value and substitutes it for the corresponding public key of a key pair generated by them. Then, the responder will execute the KeyAgreement function over the fraudulent public key $p_{k_{eb}}$, generating a secret $K_{eb}$, and its session entropy, based on this secret, its own public key and the fraudulent public key value $p_{k_{eb}}$. Then, the responder sends its public key to the initiator.
    \item The attacker would then need to intercept this public value and substitute with the public key value $p_{k_{ea}}$ of a newly generated key pair ($s_{k_{ea}}$, $p_{k_{ea}}$). But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $p_{k_{ea}}$ and $p_{k_a}$ its the same as the session entropy generated by the responder (to which the attacker, as has actively modified the natural course of the protocol, has access to). Therefore, the attacker would need to loop through key pairs ($s_{k_{ea_i}}$, $p_{k_{ea_i}}$) until one satisfies the required condition.
\end{itemize}
Obviously, the actual success probability of this attack is closely tied with the size of the session entropy generated, but is nevertheless a plausible loophole for an attacker to exploit.

\subsection{3-pass protocol}

The above attack is based on the MitM ability to generate key pairs ($s_{k_{ea_i}}$, $p_{k_{ea_i}}$) to substitute the key pair generated by the responder without any restriction. Therefore, to avoid such an attack it is necessary to impose some kind of restriction on the generation. This will be achieved by the responder committing to a public key value before actually sending it. The protocol then would go as follows:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEX-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> (s_{k_b}, p_{k_b}) \sample \texttt{KGen} (\secparam) \\ 
     \> \> (c(p_{k_b}), d(p_{k_b})) \sample \texttt{Com}(p_{k_b}) \\ 
     \> \sendmessageleft{top=\text{c(p$_{k_b}$)}} \> \\ 
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> K_{ba} = \texttt{KEX}(p_{k_a}, s_{k_b}) \\ 
     \> \> Entropy = \texttt{G}(p_{k_a}, p_{k_b}, S_k) \\
     \> \sendmessageleft{top=\text{(p$_{k_b}$, d(p$_{k_b}$))}} \> \\ 
     K_{ab} = \texttt{KEX}(p_{k_b}, s_{k_a}) \> \> \\
     Entropy = \texttt{G}(p_{k_a}, p_{k_b}, S_k) \> \> \\
     p_{k_b}' = Open(c(p_{k_b}), d(p_{k_b})) \> \> \\
     \text{Verify $p_{k_b}'$ = $p_{k_b}$}}
\end{pchstack}

\begin{itemize}
    \item First, the responder generates a key pair ($s_{k_{b}}$, $p_{k_{b}}$) and sends the commitment of its public key to the initiator.
    \item The initiator stores this value and generates its own key pair ($s_{k_{b}}$, $p_{k_{b}}$) and sends it to the responder.
    \item The responder, upon reception of the public key value of the initiator, derives the shared secret value $K_{ba}$ from its own private key, and the public key received, along with its session entropy from the shared values involved in the protocol. Then, the responder sends the public key value previously committed, along with the opening value required to open the commitment.
    \item The initiator verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret $K_{ab}$ and its session entropy.
\end{itemize}
\subsubsection{Security of the above protocol}
If the Commitment Scheme selected to use in this protocol is secure, that is, verifies the hiding and biding properties defined above, this protocol is secure. The hiding property of the scheme ensures that no information about the committed value is shared beforehand, and the biding property ensures that the MitM attack described above cannot happen, as an attacker has a negligible possibility of producing a different key pair that commits to the same value as the one committed.

\section{KEM-based protocols}

When working with Key Encapsulation Mechanisms, two important differences must be highlighted:
\begin{enumerate}
    \item The KEM protocol is, in general, not contributory, as opposed to the KEX mechanisms considered in the previous section. That means that the final shared key does not come from a mutual contribution of both ends, but is unilaterally generated by one end and transmitted to the other.
    \item The public values that will be exchanged in the protocol are not independent. That is, it will not be formed by two public keys generated by both users, but formed by a public key and an encapsulation, whose value depends on the public key value.
\end{enumerate}
This two differences will drive the security analyses made on KEM-based protocols, and its contrasts with their KEX-based counterparts. \vspace{2mm} \\
It is worth noting that a number of KEM proposals from the PQC-NIST competition have taken steps to ensure that the key derivation is contributory, up to some degree. Nevertheless, as all analyses will be made without fixating any particular KEM instance, it will be supposed that the underlying KEM is not contributory.

\subsection{2-pass protocol  \label{4.1}}

The 2-pass KEM-based protocol is, in appearance, a drop-in replacement of its KEX-based counterpart:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{2-pass KEM-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \\
     \> \> (ct_b, K) \sample \texttt{Encaps}(p_{k_a}) \\
     \> \> Entropy = \texttt{G}(p_{k_a}, ct_b, K) \\
     \> \sendmessageleft{top=\text{ct$_b$}} \> \\ 
     K = \texttt{Decaps}(ct_b, s_{k_a}) \> \> \\
    Entropy = \texttt{G}(p_{k_a}, ct_b, K) \> \>}
\end{pchstack}

\begin{itemize}
    \item The initiator generates a cryptographic key pair ($s_{k_a}$, $p_{k_a}$), by means of the KeyGen() function of the specific KEM selected. Then, the public value $p_{k_a}$ is sent to the responder.
    \item  The responder, upon reception of the initiator's public key $p_{k_a}$, executes the encapsulation function on the public key received. The execution of this function yields a secret key K, and an encapsulation $ct_b$ of the secret that conforms the generated shared secret. Then, the responder sends the aforementioned encapsulation.
    \item The initiator executes the decapsulation function, with inputs the encapsulation $ct_b$ received and its own secret key, to derive the shared secret K.
\end{itemize}

\subsubsection{Security}
A number of different security considerations are required on the above protocol: the attacker's possibility to generate the same shared secret on both end, a replica for KEM-based protocols of the attack against 2-pass KEX-based protocol, and a combination of both.
\paragraph{Attack on same key on both ends}
Despite its clear similarities in the above protocol, a MitM attacker not only has the ability to establish a shared secret with each party but also, in general, the ability to make it the exact same shared secret on both, and thus all three parties have the same shared secret value. This a direct consequence of the non-contributory nature of Key Encapsulation Mechanisms. The attack would go as follows:
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.2cm]{MitM attack on KEM schemes}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright{top=\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \sendmessageleft{top=\text{Ct$_e$}} \> \\
     \> \> (x, K) = \texttt{Decaps'}(Ct_b, s_{k_e}) \> \> \\
     \> \> (Ct_e, K) = \texttt{Encaps'}(x, p_{k_a}) \> \> \\
     \> \sendmessageleft{top=\text{Ct$_a$}} \> \> \> \\
     K = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \>}
\end{pchstack}
\begin{itemize}
    \item The initiator generates its KEM key pair ($s_{k_{a}}$, $p_{k_{a}}$) and sends its public key to the responder.
    \item The MitM attacker intercepts the public key value sent, generates another key pair ($s_{k_{e}}$, $p_{k_{e}}$) and substitutes the public key value sent by the initiator with its own public key $p_{k_{e}}$.
    \item The responder executes the encapsulation function with the public key value received. At this moment, all information about the key is established. The responder sends the encapsulation of the secret required to derive the shared key.
    \item The MitM attacker intercepts the encapsulation sent and, as it has been encapsulated using its public key value, decapsulates it using the secret key. Through this process, the attacker is able to learn the secret $x$ that was encapsulated, and that forms the shared key. Therefore, the attacker simply re-encapsulates this exact same value with the initiator's public key, and sends this encapsulation to them.
    \item The initator executes the decapsulation function on the CT received, and its own secret key, to derive the same shared key as the responder and the MitM attacker.
\end{itemize}
This possibility highlights the requirement of the entropy session to be contributed by the public values involved in the key derivation, as this addition is all that is required to  thwart the attack, for deterministic-based KEMs. \vspace{2mm} \\
\textbf{Note:} The following attack is carried on by slightly tweaking the Encaps and Decaps definition provided. The Encaps' function takes as argument not only the public key to encapsulate with, but also the secret value to be encapsulated. Meanwhile, the Decaps' function outputs, along with the secret key K, the secret value that was encapsulated.
\paragraph{Replica attack on KEX-based protocol \label{4.1.1.2}}
When the above protocol's session entropy is contributed by the public values involved (as specified in the 2-pass protocol described in \ref{4.1}) the attack detailed above does not, in general, apply (see Section \ref{4.1.1.3}). Nevertheless, the same attack on the session entropy value shown in Section \ref{3.1.1} still applies, as a commitment value is not present in the 2-pass KEM-based protocol either. The attack goes as follows:
\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-1.75cm]{MitM attack on 2-pass KEM-based protocol}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     \> \sendmessageright{top=\text{p$_{k_a}$}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> \> \sendmessageright{top=\text{p$_{k_e}$}} \> \\
     \> \> \> \> (Ct_b, K_{be}) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \>  Entropy_{be} = \texttt{G}(p_{k_e}, Ct_b, K_{be}) \\
     \> \> \> \sendmessageleft{top=\text{Ct$_b$}} \> \\
     \> \> K_{eb} = \texttt{Decaps}(Ct_b, s_{k_e}) \> \> \\
     \> \> Entropy_{eb} = \texttt{G}(p_{k_e}, Ct_b, K_{eb}) \> \> \\
     \> \> \texttt{While $Entropy_{ea} \neq Entropy_{eb}$ do:} \> \> \\
     \> \> (Ct_e, K_{ea}) \sample \texttt{Encaps}(p_{k_a}) \> \> \\
     \> \> Entropy_{ea} = \texttt{G}(p_{k_a}, Ct_e, K_{ea}) \> \> \\
     \> \sendmessageleft{top=\text{Ct$_e$}} \> \> \> \\
     K_{ae} = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \> \\
     Entropy_{ae} = \texttt{G}(p_{k_a}, Ct_e, K_{ae}) \> \> \> \>}
\end{pchstack}
\begin{itemize}
    \item When the initiator sends its public key, the attacker intercepts this value and substitutes it for its corresponding public key of a key pair generated by them. Then, the responder will execute the Encapsulation function over the fraudulent public key $p_{k_{e}}$, generating a secret $K_{be}$, and its session entropy, based on this secret, the encapsulation $Ct_{b}$ generated and the fraudulent public key value $p_{k_e}$. Then, the responder sends this encapsulation to the initiator.
    \item The attacker would then need to intercept this encapsulation value and substitute with the encapsulation value $Ct_{e}$ of an execution of the Encapsulation function on the initiator's public key. But this value must be such that the session entropy generated by the shared secret $K_{ae}$ and the public values $Ct_{e}$ and $p_{k_a}$ its the same as the session entropy generated by the responder (which the attacker is able to calculate). Therefore, the attacker would need to loop through encapsulation values $Ct_{e}$ until one satisfies the required condition.
\end{itemize}
Note that in the above setting, if the underlying PKE is deterministic, an attacker is not able to generate the same key on both ends, since, in case that the key value is fixed to be the same on both ends, the attacker would need a different encapsulation value generated on each iteration, over the same secret 't' that generates the shared key, and this cannot be achieved on a deterministic PKE. 
\paragraph{Combination under probabilistic PKE algorithm \label{4.1.1.3}}
On the other hand, if the underlying PKE scheme is indeed probabilistic and has not undergone a de-randomization procedure, the two attacks can happen simultaneously, as each execution of the encapsulation procedure on the same secret value yields different results. It is worth noting that the vast majority of the KEM proposals from the PQC-NIST competition have an underlying deterministic PKE algorithms and therefore would not be subject to the combination of both, over a 2-pass protocol. \vspace{2mm} \\
This consideration is of importance as it will model the construction of the 3-pass KEM-based protocol.

\subsection{3-pass protocol}

In the KEX-based protocol entourage, the natural way to avoid the attacks over the 2-pass protocol was to add a commitment of the public key value of the responder before actually sending its value, so that an attacker does not have a free pass over fraudulent key pair generation. When migrating to the KEM setting, this addition is not as simple because, as discussed above, the public value generated by the responder, i.e. its encapsulation, its not independent from the public value generated by the initiator, i.e. the public key, and therefore cannot commit to a value of it before actually receiving the initiator's public key while maintaining a 3-pass message exchange between them.

It is therefore required by the responder to find a way to commit to a value before receiving the initiator's public key, such that the commitment made effectively blocks the attacker's ability to generate different session entropy values. As this session entropy value is determined by the value of the shared key, along with the public values of the public key involved within its encapsulation and the encapsulation value of the secret, the restriction must be imposed within those values. \vspace{2mm} \\
Since any added value to the procedure would only modify how the values involved with the session entropy are generated, but not constrain the attack of Section \ref{4.1.1.2} and, considering that any value shared by one party, even when encrypted by means of public-key cryptography, to another could be accessed by the eavesdropper (by means of playing with the public key used to encrypt), the only plausible value for the responder to commit to is the secret value that is randomly generated at the beginning of the encapsulation procedure and that determines the final shared key value and the encapsulation value.
\subsubsection{Analysis on the commitment scheme to apply \label{4.2.1}}
The selection of such value as the value to be committed forces the protocol to be extremely meticulous in relation to the information that will be divulged by the responder in order to allow the initiator to verify the committed value. Since the actual value x will be anyways made available to the initiator, by construction of any key encapsulation scheme (and to any eavesdropper successfully in the middle), we will distinguish between commitment protocols in which the identity is part of the opening or not:
\begin{itemize}
    \item Case 1 - The Commitment Scheme selected divulges the committed value as part of the opening: In this scenario, as the secret value to be committed is encapsulated to the initiator, it is only required to transmit any other values that conform the opening. Those values, as the committed value is actually part of the opening (and therefore, not additional information about it is required), will not necessary divulge information about this value. Thus, if there exists a scheme  with the condition that, when this information is paired with the commitment value, do not divulge any information about the secret value, the rest of opening could go in clear.
    \item Case 2 - The Commitment Scheme selected does not divulge the committed value as part of the opening: In this situation, the opening transmits information about the committed value that cannot be transmitted in clear.
\end{itemize}
It should be noted that the information that conforms the opening is not suited to be encrypted by symmetric cryptography, due to the following reasons:
\begin{enumerate}
    \item Any use of the shared secret generated by the encapsulation procedure conforms, from the theoretical point of view, a break of the IND-CCA2 security of the protocol.
    \item No prior knowledge of a symmetric shared key is available to both ends.
    \item No other element is available to perform an encryption that any party without knowledge of the exchange is not able to decrypt.
\end{enumerate}

\subsubsection{KEM variant definition}
In order to accommodate the above proposal, minor variations are required to the standard KEM definition: \vspace{2mm} \\
\textbf{Definition 4.1}: A key encapsulation mechanism KEM$_{commit}$ = (Gen, Com, Encaps*, Decaps*) of a given KEM  and Commitment Scheme consists of four algorithms:
\begin{itemize}
    \item The key generation algorithm Gen matches the key generation algorithm of the KEM being modified.
    \item The random generation algorithm Com generates a random value, according to the distribution branded by the Encaps algorithm of the KEM mechanism, and generates a commitment of it, by means of the Commit function of the commitment scheme.
    \item The encapsulation algorithm Encaps*, provided a public key pk and the secret element generated by the Com function, uses the given entropy as value to be encapsulated, according to the Encaps function of the KEM scheme.
    \item  The deterministic decapsulation algorithm Decaps* matches the Decaps function of the KEM being modified, and it also outputs the secret value that conforms the final key.
\end{itemize}
Therefore, a 3-pass protocol based on the above KEM$_{commit}$ definition goes as follows:
\begin{pchstack}[boxed, center, space=1em]
    \procedure{3-pass KEM$_{commit}$-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> (d, c) \sample \texttt{Com} (x) \\
     \> \sendmessageleft{top=c} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) = \texttt{Encaps$^*$}(\pk, x) \\ 
     \> \> d_{add} = d\setminus\{x\} \\
     \> \> ct_{d} \sample \texttt{Enc}(\pk, d_{add}) \\ 
     \> \> Entropy = \texttt{G}(\pk, ct, K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     d_{add}' = \texttt{Dec}(\sk, ct_d) \> \> \\
     (x, K) = \texttt{Decaps$^*$}(\sk, ct) \> \> \\ 
     Entropy = \texttt{G}(\pk, ct, K) \> \> \\
     x' = Open(c, d_{add}' \cup \{x\}) \> \> \\
     \texttt{Verify x' = x}}
\end{pchstack}

\begin{itemize}
    \item First, the responder generates a secret value, according to the underlying distribution of the KEM scheme selected, calculates its commitment value and sends it to the initiator.
    \item The initiator stores this value and generates a key pair ($\sk$, $\pk$) and sends its public key value to the responder.
    \item The responder, upon reception of the public key value of the initiator, executes the Encaps* function on the public key received and the secret value generated at the beginning of the process. Then, the responder sends the encapsulation generated (which contains the secret value committed), along with any additional opening value required to open the commitment.
    \item The initiator verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the Decaps function, and its corresponding session entropy.
\end{itemize}
\textbf{Definition 4.2} (IND-CCA KEM$_{commit}$-based protocol) We define the IND-CCA game as in the figure below and the IND-CCA advantage of an adversary \textbf{A} against the above KEM$_{commit}$-based protocol as 
\begin{align*}
    \advantage{\texttt{IND-CCA}}{\texttt{KEM$_{commit}$}} := \abs{\prob{\texttt{IND-CCA} \Rightarrow 1} - \frac{1}{2}}
\end{align*}

\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_2$: $\indcca^\adv(\secpar)$}{\phantomsection\label{mygame}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)) \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{Decaps, Encaps^*}(\pk, ct^*, K_b^*, ct_{d}, c) \\
      \pcreturn b = b'
    }}
  \begin{pcvstack}

  \procedure[linenumbering] {Oracle $Decaps(ct)$}{%
        \text{if ct = ct$^*$} \\
        \text{ return $\tau$} \\
        else \\
        \text{ return \texttt{Decaps}(sk,ct)}
   }
  \procedure[linenumbering] {Oracle $Encaps^*$}{%
         x \sample \texttt{Gen}(\secparam) \\
        (d(x),c(x)) \sample \texttt{Com}(x) \\
        (ct, K^*) = \texttt{Encaps$^*$}(\pk, x)
   }
  \end{pcvstack}
\end{pchstack}
With the above definition, it is clear that the IND-CCA security of the constructed protocol is directly dependant on the IND-CCA security of the KEM scheme and the hiding property of the commit function of the Commitment Scheme. \vspace{2mm}\\
\textbf{Theorem 4.3}: Let KEM$^*$ := (KGen, KGenCommit, Encaps$^*$, Decaps) be a KEM-based protocol. Then, the protocol is IND-CCA secure, assuming that the underlying KEM protocol is IND-CCA secure, the commit function satisfies the hiding property, and provided that the encryption scheme of the additional opening data is IND-CPA secure. Furthermore, 
\begin{align*}
    \advantage{\texttt{IND-CCA}}{\texttt{KEM$^*$}} \leq \advantage{\texttt{IND-CCA}}{\texttt{KEM}} + 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})  \\
\end{align*}
\begin{proof}
We define the intermediate games G$_0$ and G$_1$:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_0$}{\phantomsection\label{G0}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{Decaps}(\pk, ct^*, K_b^*) \\
      \pcreturn b = b'
    }}
    
  {\procedure[linenumbering]{Game G$_1$}{\phantomsection\label{G1}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen}(\secparam) \\
      (d(x^*), c(x^*)) \sample \texttt{Com}(x^*)  \\
      b \sample \bin  \\
      (ct^*, K_0^*) = \texttt{Encaps}(\pk,x^*)  \\
      K_1^* \sample \textit{K}  \\
      b' \sample \adv^{Decaps, Encaps^*}(\pk, ct^*, K_b^*, c(x^*)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
The Game G$_0$ represents the IND-CCA security of the KEM protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CCA}}{\texttt{KEM}}
\end{align*}
Additionally, the intermediate game G$_1$ adds the commit value to the information available to the adversary. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}}
\end{align*}
represents the advantage in breaking the IND-CCA security of KEM provided by the commit value of x$^*$ which, as the underlying commitment scheme satisfies the hiding property, it will always be bounded by the advantage provided in breaking the IND-CPA hiding security of the commitment (as this advantage represents the 'extra' information leaked by the commit function). Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{commit}$ is defined by:
\begin{pchstack}[ boxed , center, space=1em]
  {\procedure[linenumbering]{Game G$_{commit}$}{\phantomsection\label{Gcommitx}
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      c(x^*) \sample \texttt{Com}(x^*)  \\
      b' \sample \adv(c(x^*), K_b^*) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{commit}'$}{\phantomsection\label{Gcommit'}
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv(c(x_b), K_b) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{committrue}$}{\phantomsection\label{Gcommittrue}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      c(x_0) \sample \texttt{Com}(x_0)  \\
      c(x_1) \sample \texttt{Com}(x_1)  \\
      b' \sample \adv_2(c(x_b)) \\
      \pcreturn b = b'
    }}
\end{pchstack}
Let us consider the event that knowing the commit of the secret value produces an improvement over a random guess (whose probability is defined by two times the advantage in the game G$_{commit}$). If is not satisfied, the games G$_0$ and G$_1$ are equivalent and consequently the difference lemma can be applied \cite{cryptoeprint:2004/332}. This game is actually equivalent to G$_{commit}'$, as the result of applying \textbf{H}, modeled as a random oracle, to a uniform sampled value is equivalent to directly sampling $K_1$. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}$} \Rightarrow 1} - \frac{1}{2}} = \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
And this game is trivially harder than the game G$_{committrue}$, as being in possession of the tuple (x$_0$, x$_1$) makes it clearly easier to solve (same objective with additional information). This last game is in turn the precise definition of the hiding property of the commitment scheme. This means that 
\begin{align*}
    \abs{\prob{\texttt{G$_{commit}'$} \Rightarrow 1} - \frac{1}{2}} \leq \abs{\prob{\texttt{G$_{committrue}$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
Together, we have:
\begin{align*}
    \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}}
\end{align*}
\vspace{2mm} \\
On the other hand, the game G$_2$ represents the IND-CCA security of the KEM$^*$ protocol. Therefore,
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} = \advantage{\texttt{IND-CCA}}{\texttt{KEM$^*$}}
\end{align*}
and thus
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}}
\end{align*}
represents the advantage in breaking the IND-CCA security of KEM$^*$ provided by the encrypted opening information shared. This value is bounded by the advantage provided in breaking the IND-CPA security of the encryption scheme (as this advantage represents the 'extra' information leaked by the commit function) and the advantage of knowing the opening, together with the commitment. Formally:
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{opening}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
where G$_{opening}$ is defined by:
\begin{pchstack}[boxed, center, space=1em]
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}$}{\phantomsection\label{Gopening}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      x^* \sample \texttt{Gen} (\secparam)  \\
      K_0^* = \textbf{H}(x^*) \\
      K_1^* \sample \textit{K}  \\
      b \sample \bin  \\
      (c(x^*), d(x^*)) \sample \texttt{Com}(x^*)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x^*)\setminus\{x^*\}) \\
      b' \sample \adv^{\oracle}(ct_{d}, K_b^*, \pk) \\
      \pcreturn b = b'
    }}
  {\procedure[linenumbering]{Game G$_{openingtrue}$}{\phantomsection\label{Gopeningtrue}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2^{\oracle}(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
  \end{pcvstack}
  \begin{pcvstack}
  {\procedure[linenumbering]{Game G$_{opening}'$}{\phantomsection\label{Gopening'}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \texttt{Gen} (\secparam)  \\
      K_0 = \textbf{H}(x_0) \\
      K_1 = \textbf{H}(x_1) \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv^{\oracle}(K_b, ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
    \procedure[linenumbering] {Oracle $\oracle(d)$}{%
        \text{return \texttt{Info}(d, c(x$^*$))}
   }
  \end{pcvstack}
\end{pchstack}
A similar argument to the one above can be applied to reach the bound 
\begin{align*}
    \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} \leq 2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} 
\end{align*}
when considering the event that knowing the encrypted opening provides an advantage over a random guess (whose probability is defined by two times the advantage in the game G$_{opening}$). \vspace{1mm} \\
The advantage against the game G$_{openingtrue}$ (and, consequently, over the intermediate game G$_1$, against the IND-CCA security of the KEM$^*$ scheme) would come from being able to extract information about the opening from its encryption and, simultaneously, that such information, when put together with the commitment (represented by the oracle $\oracle$), reveals information about the secret value that allows to elaborate on the guess. Formally: 
\begin{align*}
     \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} \leq 2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}
\end{align*}
where the value $\advantage{\texttt{IND-CPA}}{\texttt{Opening}}$ is defined as the advantage in winning the game G$_{aux-open}$: 
\begin{pchstack}[boxed, center, space=1em]
       {\procedure[linenumbering]{Game G$_{aux-open}$}{\phantomsection\label{Gclearopening}
          (x_0, x_1) \sample \adv_1 (\secparam)  \\
          b \sample \bin  \\
          (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
          (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
          b' \sample \adv_2^{\oracle}(d(x_b)\setminus\{x_b\}) \\
          \pcreturn b = b'
        }}
        \procedure[linenumbering] {Oracle $\oracle(d)$}{%
            \text{return \texttt{Info}(d, c(x$_b$))}
       }
\end{pchstack}
\begin{align*}
    \advantage{\texttt{IND-CPA}}{\texttt{Opening}} := \abs{\prob{\texttt{G$_{aux-open}$} \Rightarrow 1} - \frac{1}{2}}
\end{align*}
For the product above, let us consider the event E$_{openingtrue}$ of winning the game G$_{openingtrue}$, with an advantage over the random guess, as the intersection of the two events E$_{enc}$ and E$_{opening}$ defined above. That is: the event that knowing the encryption of the opening provides an advantage in distinguishing over the random guess, and the event that this information, when paired with the commitment, provides a significant advantage in distinguishing over a random guess.

The probability of the event E$_{openingtrue}$ (which is two times the advantage of the game G$_{openingtrue}$) is then the probability of the intersection of the two events, which is determined by the formula $$P(E_{enc}) \cdot P(E_{opening}|E_{enc})$$ in which both terms are defined by two times the advantage against the following games, respectively:
\begin{pchstack}[boxed, center, space=1em]
  {\procedure[linenumbering]{Game G$_{aux1}$}{\phantomsection\label{Genc}
      (\pk,\sk) \sample \texttt{KGen} (\secparam)  \\
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      ct_{d} \sample \texttt{Enc}(\pk, d(x_b)\setminus\{x_b\}) \\
      b' \sample \adv_2(ct_{d}, \pk) \\
      \pcreturn b = b'
    }}
   {\procedure[linenumbering]{Game G$_{aux2}$}{\phantomsection\label{Gopeningaux}
      (x_0, x_1) \sample \adv_1 (\secparam)  \\
      b \sample \bin  \\
      (c(x_0), d(x_0)) \sample \texttt{Com}(x_0)  \\
      (c(x_1), d(x_1)) \sample \texttt{Com}(x_1)  \\
      \alpha \sample \adv_2(ct_d) \\
      b' \sample \adv_3^{\oracle}(\alpha) \\
      \pcreturn b = b'
    }}
\end{pchstack}
It is clear that this games are harder that the games G$_{ind-cpa}$ and G$_{aux-open}$, respectively:
\begin{itemize}
    \item In the first one the adversary does not directly chooses which plaintexts will be ciphered.
    \item The second game, the adversary is provided with information about the opening value provided by successfully breaking the game G$_{aux1}$, but this advantage can only be as good as the opening value itself, which is known in the game G$_{aux-open}$.
\end{itemize}
Therefore arriving to the required bound:
\begin{align*}
    2 \cdot \abs{\prob{\texttt{G$_{openingtrue}$} \Rightarrow 1} - \frac{1}{2}} = P(E_{enc}) \cdot P(E_{opening}|E_{enc}) = \\
    (2 \cdot \abs{\prob{\texttt{G$_{aux1}$} \Rightarrow 1} - \frac{1}{2}}) \cdot (2 \cdot \abs{\prob{\texttt{G$_{aux2}$} \Rightarrow 1} - \frac{1}{2}}) \leq
    (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{PKE}}) \cdot (2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}})
\end{align*}
\vspace{5mm} \\
All together, this means that 
\begin{align*}
    \advantage{\texttt{IND-CCA}}{\texttt{KEM$^*$}} = \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq \abs{\prob{\texttt{G$_2$} \Rightarrow 1} - \prob{\texttt{G$_1$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_1$} \Rightarrow 1} - \prob{\texttt{G$_0$} \Rightarrow 1}} + \abs{\prob{\texttt{G$_0$} \Rightarrow 1} - \frac{1}{2}} \\
    \leq 4 \cdot (\advantage{\texttt{IND-CPA}}{\texttt{PKE}} \cdot \advantage{\texttt{IND-CPA}}{\texttt{Opening}}) +  2 \cdot \advantage{\texttt{IND-CPA}}{\texttt{Commit}} + \advantage{\texttt{IND-CCA}}{\texttt{KEM}}
\end{align*}
\end{proof} 
As discussed in Section \ref{4.2.1}, two scenarios could be considered, in the hypothesis around the opening value of theorem 4.3:
\begin{enumerate}
    \item The opening value, without the actual committed value, does not divulge any information about the value even when paired with the Commit value. Then the advantage of extracting information about the committed value (and thus about the key) is negligible and the protocol verifies Theorem 4.3, without requirement about encrypted opening.
    \item The opening value without the committed value divulges information about the committed value, when paired with the commitment, or the committed value is npt part of the opening. Then, the opening value would be required to be encrypted, with an encryption scheme that satisfies it is IND-CPA secure. Then, the protocol verifies Theorem 4.3.
\end{enumerate}
Note that the reductions applied to prove the advantage's bound explicitly show the difficulties of an attacker against the following protocol, as it doesn't know the secret value used to derive the key and therefore its commitment might prove even harder to crack, and the same with the opening values chosen to generate such commitment.
\subsubsection{Security}
The advantage of committing to a precise value of the secret element used to derive the shared key is clear: The attack against the 2-pass KEM-based protocol exploited the fact that an attacker could encapsulate different instances of this secret element (which, in turn, generates different encapsulation and shared key values) until one produces a combination that yields the same session entropy value generated by the responder.
With the inclusion of a commitment scheme around this secret element, the biding property of the scheme ensures that an attacker's ability to generate a different instance such that the commitment value made by the responder matches the one generated by them is negligible. Therefore, the value of the secret key is determined when sending the commit value and, consequently, fixing yet another value that conforms the entropy session.

One major caveat of this solution is that, for it to fully block the attacker's options, the encapsulation value must be generated in a deterministic way, from inputs the public key value and the secret element, e.g, the underlying PKE scheme inside the Encapsulation procedure must either be deterministic or have gone through a process of de-randomization. Otherwise, an attacker could still generate different encapsulation values of the same secret element until one yields the session entropy value desired. \vspace{2mm}\\
As discussed above, this secret element is the only plausible value that blocks the 2-pass attack on a 3-pass protocol. Therefore, with the considerations around probabilistic PKE, we have the following proposition:\vspace{2mm}\\
\textbf{Proposition 4.4}: It is not possible to generate a 3-pass KEM-based secure protocol over an unauthenticated channel over a KEM with an probabilistic \texttt{Encaps$^*$} function (or, equivalently, with a probabilistic PKE algorithm without de-randomization).
\subsubsection{Practical instance}
We propose a practical instance of the 3-pass KEM based protocol idea described above, with an IND-CCA KEM instance based upon an IND-CPA PKE scheme that is de-randomized inside the encapsulate procedure, combined with a commitment scheme based upon a collision-resistant hash function: \vspace{4mm}

\begin{pchstack}[boxed, center, space=1em]
    \procedure{Example 3-pass KEM$_{commit}$-based protocol instance}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     \> \> x \sample \texttt{Gen}(\secparam) \\
     \> \> m \sample \texttt{\{0,1\}$^n$} \\
     \> \> c(x) = H(x||m) \\
     \> \sendmessageleft{top=c(x)} \> \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     \> \sendmessageright{top=\pk} \> \\
     \> \> (ct, K) = \texttt{Encaps}(\pk, x) \\ 
     \> \> ct_{d} \sample \texttt{Enc}_{\text{PKE}}(\pk, m) \\
     \> \> Entropy = \texttt{G}(p_k, ct, K) \\
     \> \sendmessageleft{top=\text{(ct, ct$_d$)}} \> \\ 
     m' = \texttt{Dec}_{\text{PKE}}(\sk, ct_d) \> \> \\
     (x', K) = \texttt{Decaps}(\sk, ct) \> \> \\ 
     Entropy = \texttt{G}(p_k, ct, K) \> \> \\ 
     \text{Verify H(x'||m') = c(x)} \> \>}
\end{pchstack}
A plausible algorithm selection could be the NIST's selection for PQC-KEM standardization, CRYSTALS-Kyber \cite{conf/eurosp/BosDKLLSSSS18}, which satisfies that its underlying PKE is IND-CPA, and any collision resistant hash function, with an appropriate output length.

\subsection{4-pass protocol}
The modifications applied to the 3-pass KEM-based protocol were intended to provide a way for the responder to restrict the attacker's possibility while maintaining a true 3-pass exchange between them, i.e., without any party sending two consecutive messages, in a scenario in which the responder depends on the public value (the public key) sent by the inititator to generate its associate public value (the encapsulation value of the secret element). When given a 4-pass protocol, this modifications are no longer required, and the following protocol can be applied:

\begin{pchstack}[boxed, center, space=1em]
    \procedure{4-pass KEM-based protocol}{%
     \textbf{Initiator} \> \> \textbf{Responder} \\
     (\pk,\sk) \sample \texttt{KGen} (\secparam) \> \> \\
     m \sample \texttt{\{0,1\}$^n$} \> \> \\
    (d(m), c(m)) \sample \texttt{Com}(m) \> \> \\
     \> \sendmessageright{top=\texttt{(\pk, c(m))}} \> \\
     \> \> (ct, K) \sample \texttt{Encaps}(\pk) \\ 
     \> \> (d(ct), c(ct)) \sample \texttt{Com} (ct) \\
     \> \sendmessageleft{top=\texttt{c(ct)}} \> \\ 
     \texttt{Process commit} \> \> \\
     \> \sendmessageright{top=\texttt{(m, d(m))}} \> \\
     \> \> m' = Open(c(m), d(m)) \\
     \> \> \texttt{Verify m' = m} \\
     \> \> Entropy = \texttt{G}(p_k, ct, m, K) \> \> \\ 
     \> \sendmessageleft{top=\texttt{(ct, d(ct))}} \> \\ 
     K = \texttt{Decaps}(\sk, ct) \> \> \\
     Entropy = \texttt{G}(p_k, ct, m, K) \> \> \\ 
     ct' = Open(c(ct), d(ct)) \> \> \\
     \texttt{Verify ct' = ct}}
\end{pchstack}

\begin{itemize}
    \item First, the initiator generates a key pair $(\sk, \pk)$ and a random value 'm' uniformly, and sends to the responder the public key value $\pk$ and a commitment of the random value 'm'.
    \item The responder, upon reception of the public key value of the initiator, executes the Encaps function on the public key received, generating the secret key value K and an encapsulation ct. Then, the responder generates a commitment of this encapsulation value and sends it to the initiator.
    \item The inititator, upon reception of the commitment value of the encapsulation sent by the responder, sends the opening value of the random element 'm' generated before.
    \item The responder verifies the commitment received at the beginning with the opening value received in this iteration and the actual value committed and, upon successful verification, calculates its entropy session value and sends the encapsulation value committed before.
    \item The initiator verifies that the value committed matches the commitment stored, and then proceeds to derive the shared secret key using the Decaps function, and its corresponding session entropy.
\end{itemize}
\subsubsection{Security}
The inititator's commitment is sent to ensure that the message to acknowledge reception of the commitment of the encapsulation is sent by the inititator and not a fake generation by an attacker. This intermediate message is essential to provide assurance that there is a separation between the responder sending the committed value and the actual value, so that a MitM opponent cannot modify this commitment in order to send a distorted encapsulation value that passes the verification, provided that this random value is added to the session entropy derivation.

With the presence of the initiator's random value inside the session entropy, we ensure the following:
\begin{itemize}
    \item An attacker, because of the security properties of commitment schemes, can only succeed if is able to generate a fraudulent encapsulation value before the commitment of the real encapsulation generated by the responder reaches the initiator, and that this fake encapsulation generates the same session entropy value on the initator's side that the one that the responder calculates.
    \item But, to do so the attacker needs to know all values involved on within the session entropy generation, including the random value committed by the initiator at the beginning. And this value is not actually shared until after the initiator receives a commitment of the encapsulation value. Therefore, the attack cannot succeed.
\end{itemize}
This is perhaps best shown by pointing out the fact that the first time the attacker is able to learn the session entropy values that the parties will calculate is well after it has been forced to commit to a encapsulation value (and, thus, a shared secret value) and to a random value. Therefore, it is not possible to replicate the attack. \vspace{2mm} \\
The hiding property of the commitment applied ensures that no information can be obtained by only knowing the commitment, and the biding property provides assurance that, given a commitment, the advantage of generating a fraudulent opening and value that verifies the commitment is negligible. \vspace{2mm} \\
\textbf{Proposition 4.5}: If the commitment scheme is hiding and biding, and the KEM scheme is IND-CCA, the 4-pass protocol is secure against MitM attackers, provided mutual verification by the generated session entropy is performed.

\begin{pchstack}[boxed, center, space=1em]
    \procedure[colspace=-2cm]{MitM scenario on 4-pass KEM-based protocol}{%
     \textbf{Initiator}  \> \> \textbf{MitM} \> \> \textbf{Responder} \\
     (s_{k_a}, p_{k_a}) \sample \texttt{KGen} (\secparam) \> \> \> \> \\
     m_a \sample \{0,1\}^n \> \> \> \> \\
     (d(m_a), c(m_a)) \sample \texttt{Com}(m_a) \> \> \> \> \\
     \> \sendmessageright{top=\texttt{(p$_{k_a}$, c(m$_a$))}} \> \> \> \\
     \> \> (s_{k_e}, p_{k_e}) \sample \texttt{KGen} (\secparam) \> \> \\ 
     \> \> m_e \sample \{0,1\}^n \> \> \\
     \> \> (d(m_e), c(m_e)) \sample \texttt{Com}(m_e) \> \> \\
     \> \> \> \sendmessageright{top=\texttt{(p$_{k_e}$, c(m$_e$))}} \> \\
     \> \> \> \> (Ct_b, K_{be}) \sample \texttt{Encaps}(p_{k_e}) \\
     \> \> \> \> (d(Ct_b), c(Ct_b)) \sample \texttt{Com}(Ct_b) \\
     \> \> \> \sendmessageleft{top=\texttt{c(Ct$_b$)}} \> \\
     \> \> (Ct_e, K_{ea}) \sample \texttt{Encaps}(p_{k_a}) \> \> \\
     \> \> (d(Ct_e), c(Ct_e)) \sample \texttt{Com}(Ct_e) \> \> \\
     \> \sendmessageleft{top=\texttt{c(Ct$_e$)}} \> \> \> \\
     \texttt{Process commit} \> \> \> \> \\
     \> \sendmessageright{top=\texttt{(m$_a$, d(m$_a$))}} \> \> \> \\
     \> \> Entropy_{ea} = \texttt{G}(p_{k_a}, Ct_a, K_2, m_a) \> \> \\
     \> \> \> \sendmessageright{top=\texttt{(m$_e$, d(m$_a$))}} \> \\
     \> \> \> \> m_e' = Open(c(m_e), d(m_e)) \\
     \> \> \> \> \texttt{Verify m$_e$' = m$_e$} \\
     \> \> \> \> Entropy_{be} = \texttt{G}(p_{k_e}, Ct_b, K_{be}, m_e) \\
     \> \> \> \sendmessageleft{top=\texttt{(Ct$_b$, d(Ct$_b$))}} \> \\
     \> \> K_{be} = \texttt{Decaps}(Ct_b, s_{k_e}) \> \> \\
     \> \> Entropy_1 = \texttt{G}(p_{k_e}, Ct_b, K_{be}, m_e) \> \> \\
     \> \sendmessageleft{top=\texttt{(Ct$_e$, d(Ct$_e$))}} \> \> \> \\
     K_{ae} = \texttt{Decaps}(Ct_e, s_{k_a}) \> \> \> \> \\
     Ct_e' = Open(c(Ct_e), d(Ct_e)) \> \> \> \> \\
     \texttt{Verify Ct$_e$' = Ct$_e$} \> \> \> \> \\
     Entropy_{ae} = \texttt{G}(p_{k_a}, Ct_e, K_{ae}, m_a) \> \> \> \>}
\end{pchstack}

\section{Conclusions}

We have shown how to construct secure KEM-based protocols from 3 and 4 passes, in an unauthenticated scenario, which requires consider the plausible presence of MitM attackers. We have done so by first studying how equivalent KEX-based protocols are usually constructed, and the difficulties that naturally arise from the differences between standard KEX constructions like the Diffie-Hellman paradigm and KEM constructions. \vspace{2mm}

The protocols constructed follow on the steps taken in the KEX settings, that is, generating an additional value that 'resumes' the session exchange between the two parties, and forcing any attacker to commit to a specific value before it has all the necessary information to calculate such value, so its presence is detected by inconsistencies in this digest. \vspace{2mm}

For the 3-pass protocol a commitment value of the responder's public value is not possible, due to the dependent nature of the encapsulation value. Nevertheless, an attacker can still be blocked if forced to commit to the secret value encapsulated. Since this value forms the shared secret value, it is critical to ensure that no information whatsoever is leaked by this modification. With the appropriate measures in place, we prove the IND-CCA2 security of the modified KEM scheme, KEM$_{commit}$. This measures are nevertheless restricted to work only over certain types of KEMs, i.e, those whose PKE scheme is deterministic (or has undergone a de-randomization procedure). \vspace{2mm}

For the 4-pass protocol, it is now possible for the responder to generate a commitment of its public value, but it is required to show an actual separation, in terms of the initiator's interaction, between the commitment value and the actual value. Therefore, a 'proof of identity' is generated, by means of yet another commitment, this time of a random value large enough to ensure the initiator's identity. With this measures, we show the impossibility of a MitM attack and, consequently, the security of the protocol over unauthenticated channels.


\bibliography{lib.bib}
\bibliographystyle{alpha}

\nocite{cryptoeprint:2019/1356}

\end{document}
