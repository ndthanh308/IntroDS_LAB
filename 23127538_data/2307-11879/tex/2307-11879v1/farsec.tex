\paragraph*{The flow admission and routing problem under minimal security constraints~(FARSec).} Given a network $N=(V,E,s)$, a finite set of flows $F$, and a security requirement $\mathcal{S}$, find a path for each flow (mapping solution) $\mathbb{S}: F\to E^*$, such that: i) the paths are simple and valid for the flows and network; ii) the required security level of the allocated flows is lesser or equal than the security value of each of the links in the assigned paths or the empty path if the latter is not possible. These two conditions are hereafter referred to as \emph{the properties of a FARSec solution}.

As an example, consider the set of flows as shown in Table~\ref{tab:ex_flows} and the network shown in Figure~\ref{fig:ex_topo}. The solution $\mathbb{S}=\{(0001,(N_1,N_4)(N_4,N_2)),(0010,\epsilon),(0011,(N_3,N_4)(N_4,N_2)), (0100,(N_4,N_3)(N_3,N_1))\}$ is a FARSec solution. Note that, the flow with header $0010$ is assigned an empty path as all available paths from the source ($N_2$) to the destination ($N_4$) traverse links which have lower security level than the required one ($2$). In this case, in order not to compromise the security of the running application (with header $0010$) the traffic is dropped. 

\begin{table}[!htb]
	\centering
	\begin{tabular}{|c|c|c|c|c|c|}
		\hline
		\textbf{header} & \textbf{source} 	& \textbf{destination} & \textbf{min. sec.} \\ \hline
		0001           & $N_1$         & $N_2$ & 3  \\ \hline
		0010           & $N_2$         & $N_4$ & 2  \\ \hline
		0011           & $N_3$         & $N_2$ & 1  \\ \hline
		0100           & $N_4$         & $N_1$ & 2  \\ \hline
	\end{tabular}
	\caption{Example flows}
	\label{tab:ex_flows}
\end{table}

\subsection{Computing the solution for the FARSec problem}
In order to compute a solution for a given FARSec problem instance, different strategies are possible. The naive option is to go through each of the flows to allocate and recursively search for a path starting at the source node whose edges have greater or equal security level as the requested one. However, in the worst case, exponential number of paths should be checked. Indeed, a better strategy is to search for one path for each source / destination pair; that is the path with the maximal minimum security level. Subsequently, for each requested flow, if the path with the maximal minimum security level has no edge with a level less than the required security level, this path can be assigned to the flow; otherwise, the flow must be dropped (the empty path must be assigned). The latter strategy reduces the problem to computing all-pairs \emph{widest paths}. There are many possibilities how to compute all-pairs widest paths. Some of them are better for dense graphs, and others for sparse ones. Without any knowledge of which sort of input graphs are to be treated, a good option is to use a modified version of the simple and efficient ($\Theta(|V|^3)$) algorithm known as the Floyd-Warshall algorithm, originally proposed by Bearnand Roy\cite{allpairs} (later, independently discovered by Robert Floyd and Stephen Warshall, see for example \cite{floydallpairs}). 

The difference between computing the shortest paths and the widest paths can be easily explained via the following recurrences. First, the shortest path from a source node $a$ to a destination node $b$ can be computed with the recurrence $SP(a,b)= \mathbf{min}\{SP(a,u)+s((u,b))|(u,b)\in E\}$, where $s$ is the weight function of the graph (in our case the security level). This formulation is known and can be used to implement many algorithms such as Dijkstra's algorithm or Roy's algorithm for all pairs. The recurrence to describe the widest path ($a\to b$) is as follows: $WP(a,b)=\mathbf{max}\{\textbf{min}\{WP(a,u),s((u,b))\}|(u,b) \in E\}$. Although these recurrences may look very different, in fact, there are only two different operators. Namely, $\mathbf{min}$ shortest paths is replaced by $\mathbf{max}$ in widest paths and $+$ in shortest paths  is replaced by $\mathbf{min}$. Indeed, the widest paths search to maximize the minimal security level. We present the modified Roy's algorithm to compute the all-pairs widest paths in Algorithm~\ref{algo:widest} while Algorithm~\ref{algo:FARSec} presents how to solve the FARSec problem by mapping each flow to a path, whenever possible.
\begin{algorithm}[!htb]
    %\small
    \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}\SetKw{KwBy}{by}
    \DontPrintSemicolon
    \Input{A secure network graph $(V,E,s)$}
    \Output{$P$, the most secure paths matrix where $P_{i,j}$ contains the secure most path from the node $i\to j$ for all $i,j\in V$}
    \textbf{Step 0}: Initialize $\omega$, $P$ and $\Pi$ as a $|V|\times|V|$ integer matrices and set $P_{i,j}\leftarrow\epsilon$, $\Pi_{i,j}\leftarrow$\textsc{NULL}, and $\omega_{i,j}\leftarrow0$ for all $i,j\in\{1,\ldots,|V|\}$\tcp{$\omega$ represents the smallest security level of the path, $\Pi$ the next hop in the path, and $P$ the final paths}
    \textbf{Step 1}: \ForEach{$(u,v)\in E$}
    {
        Set $\omega_{u,v}\leftarrow s((u,v))$\tcp{The existing security level of the link}
        Set $\Pi_{u,v}\leftarrow v$\;
    }
    \textbf{Step 2}: \ForEach{$v\in V$}
    {
        Set $\omega_{v,v}\leftarrow \infty$\;
        Set $\Pi_{v,v}\leftarrow v$
    }
    \tcp{Start the standard Floyd-Warshall algorithm}
    \textbf{Step 3}: \For{$k\leftarrow 1; k \leq |V|; k\leftarrow k+1$}
    {
        \For{$i\leftarrow 1; i \leq |V|; i\leftarrow i+1$}
        {
            \For{$j\leftarrow 1; j \leq |V|; j\leftarrow j+1$}
            {
                %original if dist[i][j] > dist[i][k] + dist[k][j] then
                \If{$\omega_{i,j} < \mathbf{min}\{\omega_{i,k},\omega_{k,j}\}$}
                {
                    Set $\omega_{i,j}\leftarrow \mathbf{min}\{\omega_{i,k},\omega_{k,j}\}$\;
                    Set $\Pi_{i,j}\leftarrow\Pi_{i,k}$\;
                }
            }
        }
    }
    \tcp{At this point we must reconstruct the paths}
    \textbf{Step 4}: \For{$i\leftarrow 1; i \leq |V|; i\leftarrow j+1$}
    {
        \For{$j\leftarrow 1; j \leq |V|; j\leftarrow j+1$}
        {
            \If{$\Pi_{i,j} \not=$  \textsc{NULL}}
            {
                $curr \leftarrow i$\;
                \While{$curr\not= j$}
                {
                    Set $P\leftarrow P\cdot (curr, \Pi_{curr,j})$\;
                    Set $curr\leftarrow \Pi_{curr,j}$\;
                }
                  
            }
            
        }
    }
    \textbf{Step 5}: \Return{$P$}
    \caption{All-pairs widest paths}\label{algo:widest}
\end{algorithm}

\begin{algorithm}[!htb]
    %\small
    \SetKwInOut{Input}{input}\SetKwInOut{Output}{output}\SetKw{KwBy}{by}
    \DontPrintSemicolon
    \Input{A secure network graph $(V,E,s)$, a set of flows $F$, and a security requirement 
    $\mathcal{S}$}
    \Output{A mapping $\mathbb{S}$, from $F$ to $E^*$}
    \textbf{Step 0}: Set $\mathbb{S}\leftarrow\emptyset$, and initialize $L$ as a $|V|\times|V|$ integer matrix, where $L_{i,j}=\infty$, $\forall i,j\in\{1,\ldots,|V|\}$ \tcp{$L$ contains the bottleneck security level for each path.}
    \textbf{Step 1}: Use Algorithm~\ref{algo:widest} to compute $P$\;
    \textbf{Step 2}:  \For{$i\leftarrow 1; i \leq |V|; i\leftarrow k+1$}
    {
        \For{$j\leftarrow 1; j \leq |V|; j\leftarrow j+1$}
        {
            \For{$k\leftarrow 1; k \leq |P_{i,j}|; k\leftarrow k+1$}
            {
                \If{$s({P_{i,j}}_k) < L_{i,j}$}
                {
                    Set $L_{i,j}\leftarrow s({P_{i,j}}_k)$\tcp{Update the real bottleneck value}
                }
            }
        }
    }
    \tcp{Do the main mapping here}
    \textbf{Step 3}: \ForEach{$f\in F$}
    {
        \If{$\mathcal{S}(h(f)) \leq L_{o(f),d(f)}$}
        {
            Set $\mathbb{S}\leftarrow\mathbb{S}\cup\{(f,P_{o(f),d(f)})\}$\;
        }
        \Else
        {
            Set $\mathbb{S}\leftarrow\mathbb{S}\cup\{(f,\epsilon)\}$\tcp{If there is no secure enough path, drop the traffic}
        }
    }
    \textbf{Step 4}: \Return{$\mathbb{S}$}
    \caption{FARSec solution}\label{algo:FARSec}
\end{algorithm}

To assess the correctness of Algorithm~\ref{algo:FARSec} we first consider that the algorithm always terminates as there are loops only of finite length. Additionally, as the widest paths computation ensures that there does not exist a path which has a lager minimal security path and this path is assigned to the flow only if the requirement is lesser or equal than the bottleneck of this path (otherwise the empty path is assigned), the following statement holds.

\begin{proposition}
Given a secure network graph $(V,E,s)$, a set of flows $F$, and a security requirement $\mathcal{S}$, $\mathbb{S}$ computed by Algorithm~\ref{algo:FARSec} holds the properties of a FARSec solution, i.e.,
\begin{enumerate}
    \item $\forall f=(o,d,h)\in F\; ((\mathbb{S}(o,d)\not=\epsilon) \implies ( (\forall i\in\{1,\ldots,|\mathbb{S}(o,d)|-1\} \; \mathbf{dst}(\mathbb{S}(o,d)_i)=\mathbf{src}(\mathbb{S}(o,d)_{i+1})) \wedge (\forall x\in\{1,\ldots,|\mathbb{S}(o,d)|-1\}\;(\nexists y\in\{x+1,\ldots,|\mathbb{S}(o,d)|\}\;(\mathbf{src}(\mathbb{S}(o,d)_x)=\mathbf{dst}(\mathbb{S}(o,d)_y)))) ) )$ (paths are simple valid if not the empty path)
    \item $\forall f=(o,d,h)\in F\; ((\mathbb{S}(o,d)\not=\epsilon) \implies (\forall i\in\{1,\ldots,|\mathbb{S}(o,d)|\} \mathbb{S}(o,d)_i \geq \mathcal{S}(h)))$ (assigned paths respect the minimal security constraints if assigned)
    \item  $\forall f=(o,d,h)\in F\; ((\mathbb{S}(o,d)=\epsilon) \implies (\nexists p\in E^* ((p\not=\epsilon) \wedge (\mathbf{src}(p_1)=o) \wedge ((\mathbf{dst}(p_{|p|})=d) \wedge (\forall i\in\{1,\ldots,|p|-1\} \; \mathbf{dst}(p_i)=\mathbf{src}(p_{i+1})) \wedge (\forall x\in\{1,\ldots,|p|-1\}\;(\nexists y\in\{x+1,\ldots,|p|\}\;(\mathbf{src}(p_x)=\mathbf{dst}(p_y))) ) \wedge (\forall j\in\{1,\ldots,|p|\} p_j \geq \mathcal{S}(h)) ) ) )$ (there does not exist a valid and simple path for the flow that respects the security constraints if the path is not assigned by the algorithm)
\end{enumerate}
\end{proposition}

It is good to have security guarantees in order to ensure dependability on such critical systems. However, an interesting aspect to consider is the computational complexity of the overall proposed approach. Differently, from the naive possibly exponential computation, our proposed approach has a polynomial worst-case guarantee. 

\subsubsection{Complexity analysis of the proposed FARSec solution}
It is easy to see that the FARSec solution (as shown in Algorithm~\ref{algo:FARSec}) has a $\mathcal{O}(|V|^4+|F|)$ time complexity, as for each pair of nodes the assigned path (is simple and thus) has at most $\mathcal{O}(|V|^2)$ edges (hence the $|V|^2$ term), and then all flows are visited once. We note that the bottleneck weights can be obtained directly from the computation of the widest paths. However, when implementing the approach it is often desirable to have dedicated functions for code re-usability and testability purposes. One function computing only the widest paths and the other computing a bottleneck weights for a path. In case of computing both combined, the running time would be $\Theta(|V|^3+|F|)$, which is not such a significant improvement for a small number of nodes. Furthermore, for networks where nodes have relatively short paths (for example double-stared networks, which are common network architectures), the time complexity of computing the bottleneck of the path gets dramatically decreased (as there does not exist a simple and valid path with $\mathcal{O}(|V|^2)$ nodes in such topologies). For our particular instances of interest both of the aforementioned conditions are true, i.e., the number of nodes is rather small and the paths are short. 