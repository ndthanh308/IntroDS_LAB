In this section, we propose a detailed characterisation for the types of edits and revisions based on ten dimensions, summarised in Table \ref{table:charac}, as a means to evaluate revision policies. In the next paragraphs, we assume that either a genuine or a constructed incremental sequence of target prefixes has been selected according to the current needs. We will use Figure \ref{fig:contructed-example} and its gold standard as examples.\footnote{More examples are available in the code repository.}

To characterise edits, we consider the state of an output label in the current prefix in relation to its state in the previous prefix, which are different by definition. They relate to a label's development in time (vertically in their IC column) or to the prefix they belong to (horizontally in their IC row). The dimensions to characterise edits serve the purpose of defining the qualities of the revisions, which operate on prefixes.

\subsubsection{Edits}

The main aspect to account for is whether labels need to be edited in the first place and, if yes, whether they are edited into the desired state. Edits on correct labels are \textit{inconvenient}, and also \textit{defective}, since the label will fatally change into a wrong label. This happens, for instance, at $l_2$ in step $4$, as the correct label $D$ is edited into a wrong $B$. Edits on incorrect labels are \textit{convenient} and can be \textit{effective} (if it enters into a correct state, like $l_4$ at $t=5$, which changes from an incorrect $D$ to a correct $C$) or \textit{ineffective} (if it enters into another incorrect state, \textit{e.g.}~$l_3$ at $t=9$, which changed from an incorrect $A$ to a still incorrect $D$). 

Other dimensions can be used to analyse the behaviour of the processor. \textit{Innovative} edits cause the label to change into a new state. For instance, $l_6$ becomes a $C$ for the first time at $t=9$. In the next step, it is edited back into its previous state $A$, and we consider it to be a \textit{repetitive} edit.

Local \textit{recurrence} refers to whether the edit occurs in isolation in neighbouring time steps (edit subsequences in an IC's column). \textit{Oscillation} refers to how many edits occur in its complete column, just one (\textit{stable}) or more (\textit{oscillating}). For instance, $l_3$ has two groups of recurrent edits along the time axis, whereas $l_2$ has one \textit{steady} and stable edit. 

\textit{Company} characterises whether the edit occurs with other edits in a prefix (same IC's row). In Figure \ref{fig:contructed-example}, $l_6$ is edited together with other labels at $t=9$, whereas $l_1$ is edited in isolation at $t=6$. \textit{Accompanied} edits can be either \textit{connected} (\textit{i.e.}~with directly neighbouring edited labels, as in $t=4$) or \textit{disconnected} to the other edits in its prefix.

\textit{Short} or \textit{long range} refers to how far the edited label is from the current time step, defined by a distance parameter $d$. If we set $d=2$, the edit that changes $l_4$ into a $C$ at $t=5$ is short range because it is less than 2 time steps away from the current token being processed. On the other hand, $l_3$ is edited at $t=9$, very distant from the right frontier.

Edits can also be \textit{definite} or \textit{temporary}. Definite edits make the label enter into its final state, like $l_2$ at $t=4$. Temporary edits are those like the $B$ for $l_3$ at $t=5$: It still gets edited further before a final decision is reached (here, also a $B$). Besides, edits can occur in \textit{intermediate} steps during processing, when the input sequence is incomplete, or at the \textit{final} time step, when the full sequence is available. 


\subsubsection{Revisions}

 Similar to edits, revisions are \textit{inconvenient} if they occur on correct prefixes (that should not change), and thus also \textit{defective}, because correctness necessarily decreases. The prefix at $t=3$ is correct, so the revision at $t=4$ causes the labels to become wrong. \textit{Convenient} revisions are \textit{effective} if they improve correctness, like at $t=6$ where the number of correct labels in the prefix increases from $3$ to $4$, otherwise they can be \textit{ineffective} (edits occur but correctness remains the same, like at $t=9$) or again \textit{defective}.

Revisions are \textit{locally recurrent} when other revisions occur in neighbouring time steps. We see that from $t=4$ to $t=6$. The revision at $t=2$ is \textit{steady}, as no other revisions occur immediately before or after it. If only one revision occur while a sequence is processed, it is \textit{stable}, otherwise it is \textit{oscillating.} In our example, all revisions are therefore oscillating.

\textit{Company}, \textit{connectedness} and \textit{distance} refer to what types of edits the revision causes. At the second time step, the prefix contains only a \textit{disconnected} and \textit{short range} edit, whereas at the fifth time step we observe \textit{accompanied} edits, one \textit{connected} and one \textit{disconnected} group and one short and two long range edits.

\textit{Definite} revisions create prefixes that will not be further edited. In our example, this only happens in the last time step; all others are \textit{temporary}. \textit{Intermediate} revisions happen when the input is not yet completed, otherwise they are \textit{final}.

\subsubsection{Recomputations}

In models that detach recomputations from revisions, the recomputations should also be evaluated. Recomputations are \textit{active} if they actually result in a revision, otherwise they are \textit{inactive}. The quality of the resulting revisions can then be evaluated with the characteristics above.
