\documentclass[a4paper,11pt]{article}


%\documentclass[preprint,11pt]{revtex4-2}

\PassOptionsToPackage{color}{xy}

%----------------------------------------------
% Margins and spacing
%----------------------------------------------
\usepackage[margin=2.2cm]{geometry}
\renewcommand{\baselinestretch}{1.2}
% Machins de SP:
%\setlength{\parindent}{0cm}
%\setlength{\parskip}{2ex plus 0.5ex minus 0.5ex}

%----------------------------------------------
% Fonts
%----------------------------------------------
\usepackage{mathrsfs}
\usepackage{dsfont}
\usepackage{bbm}
\usepackage{palatino}


%----------------------------------------------
% Packages
%----------------------------------------------
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{graphicx, calc}
\graphicspath{{./figures/}}
\usepackage[font=small]{caption}
\usepackage{titlesec}
\usepackage{subcaption}
\usepackage{float}
\usepackage{array}
\usepackage{multirow}
\usepackage{bm}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}  
\usepackage{stmaryrd}
%\usepackage{cite}
\usepackage[colorlinks=true,urlcolor=black,linkcolor=Mahogany,citecolor=Mahogany,plainpages=false,pdfpagelabels]{hyperref}

% array package
\newcolumntype{X}[1]{>{\centering\let\newline\\\arraybackslash}p{#1}}

%----------------------------------------------------------
% bibliography
\usepackage[backend=bibtex,maxcitenames=4,maxalphanames=100,maxbibnames=100,isbn=false]{biblatex}
\addbibresource{biblio_database.bib}
%----------------------------------------------------------

%--------------------------------------------------------------
%TIKZ
\usepackage{tikz}
\usepackage{verbatim}
\usetikzlibrary{shapes.geometric,plotmarks,backgrounds,fit,calc,circuits.ee.IEC}
\usetikzlibrary{decorations.pathreplacing}
%--------------------------------------------------------------

%------------------------------------------------
%text alignment in captio for revtex
%------------------------------------------------
%
%\makeatletter
%\renewcommand\@makecaption[2]{%
%  \par
%  \vskip\abovecaptionskip
%  \begingroup
%   \small\rmfamily
%    \begingroup
%     \samepage
%     \flushing
%     \let\footnote\@footnotemark@gobble
%     \@make@capt@title{#1}{#2}\par
%    \endgroup
%  \endgroup
%  \vskip\belowcaptionskip
%}
%\makeatother
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ragged2e}
\DeclareCaptionJustification{justified}{\justifying}
\captionsetup{justification=justified,singlelinecheck=false}

%----------------------------------------------
% QCIRCUIT package
%----------------------------------------------
\usepackage{qcircuit}
% new commands added to qcircuit package
\def\A#1{\save []="#1" \restore}
\def\qww{\qw & \qw}
\def\mX{\measure{\makebox[.9em][c]{$X$}}}
\def\mZ{\measure{\makebox[.9em][c]{$Z$}}}
% CNOT target, control, and vertival wire in RED
\newcommand{\targred}{*+<.02em,.02em>{\xy ="i","i"-<.39em,0em>;"i"+<.39em,0em> **[red]\dir{-}, "i"-<0em,.39em>;"i"+<0em,.39em> **[red]\dir{-},"i"*[red]\xycircle<.4em>{} \endxy} \qw}
    % Inserts a CNOT target.
\newcommand{\controlred}{*[red]!<0em,.025em>-=-<.2em>{\bullet}}
    % Inserts an unconnected control.
\newcommand{\qwxred}[1][-1]{\ar @[red] @{-} [#1,0]}
    % Defines a wire that connects vertically.  By default it connects to the object above the current object.
\newcommand{\ctrlred}[1]{\controlred \qwxred[#1] \qw}
    % Inserts a control and connects it to the object #1 wires below.
\newcommand{\meterb}[1]{*=<1.8em,2.2em>{\xy 0;<0em,-.8em>:
0*{\begingroup
\everymath{\scriptstyle}
\tiny #1 \endgroup},<0em,.3em>*{\xy ="j","j"-<.778em,-.322em>;{"j"+<.778em,.322em> \ellipse ur,_{}},"j"-<0em,-.2em>;p+<.5em,.9em> **\dir{-},"j"+<2.2em,2.2em>*{},"j"-<2.2em,2.2em>*{} \endxy} 
\endxy} \POS ="i","i"+UR;"i"+UL **\dir{-};"i"+DL **\dir{-};"i"+DR **\dir{-};"i"+UR **\dir{-},"i" \qw}
    % A meter that allows for a measurement operator to be added below

%----------------------------------------------
% NEWCOMMAND
%----------------------------------------------
\newcommand{\pone}{\mathcal{Q}_1} % notation for P1 codes
%\newcommand{\cp}{\mathcal{P}}     % notation of classical polar codes
\newcommand{\qp}{\mathcal{Q}}     % notation for quantum polar codes
%\definecolor{auburn}{rgb}{0.43, 0.21, 0.1}
\newcommand{\pstab}[2]{{\tiny $(#1\!\times\!10^{#2})$}}

\newcommand{\ee}{\text{\Large\ensuremath{\mathfrak{e}}}}
\newcommand{\eee}{\text{\normalsize\ensuremath{\mathfrak{e}}}}

% figure caption -- use Fig. instead of Figure
\makeatletter
\renewcommand{\fnum@figure}{Fig. \thefigure}
\makeatother


%% Ket: |a>
\newcommand{\ket}[1]{{\ensuremath{\lvert#1\rangle}}}
\newcommand{\bra}[1]{{\ensuremath{\langle#1\lvert}}}
\newcommand{\oline}{\overline}
\newcommand{\cl}{\mathcal}
\newcommand{\ident}{\mathds{1}}
\newcommand{\id}{\bm{I}}
% image in a line
\newcommand*{\img}[1]{%
    \raisebox{-.12\baselineskip}{%
        \includegraphics[
        height=\baselineskip,
        width=\baselineskip,
        keepaspectratio,
        ]{#1}%
    }%
}

\newlength\myheight
\newlength\mydepth
\settototalheight\myheight{Xygp}
\settodepth\mydepth{Xygp}
\setlength\fboxsep{0pt}
\newcommand*\inlinegraphics[1]{%
  \settototalheight\myheight{Xygp}%
  \settodepth\mydepth{Xygp}%
  \raisebox{-\mydepth}{% Figure removed}%
}




\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
%\DeclareMathOperator*{\min}{\text{min}}
\DeclareMathOperator*{\supp}{supp}
\DeclareMathOperator{\wt}{wt} 
\DeclareMathOperator{\pr}{Pr} 
\DeclareMathOperator{\tr}{Tr}
\DeclareMathOperator{\eqdef}{:=}
\DeclareMathOperator{\xor}{XOR}
\DeclareMathOperator{\cnot}{CNOT}
\DeclareMathOperator{\swap}{SWAP}


%----------------------------------------------
% NEWTHEOREM
%----------------------------------------------
\newtheorem{definition}{Definition}
\newtheorem{assumption}{Assumption}
\newtheorem{protocol}{Protocol}
\newtheorem{procedure}{Procedure}
\newtheorem*{procedure*}{Procedure}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{remark}{Remark}
\newtheorem{proposition}{Proposition}



%----------------------------------------------
% space between floats and text
%----------------------------------------------
\setlength{\floatsep}{20pt plus 2.0pt minus 2.0pt}
\setlength{\textfloatsep}{20pt plus 2.0pt minus 2.0pt}

\titlespacing*{\paragraph}{\parindent}{1.8ex plus .2ex minus .2ex}{2ex plus .5ex minus .2ex}


\begin{document}
%\author{Ashutosh Kumar Goswami}
%\cleanlookdateon
\title{\vspace{-20mm}{Factory-Based Fault-Tolerant Preparation of Quantum Polar Codes Encoding One Logical Qubit}}%A Factory Preparation of Quantum Polar Codes Encoding One Logical Qubit}}

\author{Ashutosh Goswami$^1$, \qquad Mehdi Mhalla$^2$, \qquad Valentin Savin$^3$\\[2mm]
    {\small $^1$\,QMATH, Dep. of Mathematical Sciences, Univ. of Copenhagen} \\
    {\small Universitetsparken 5, 2100 Copenhagen, Denmark}\\
    {\small $^2$\,Univ. Grenoble Alpes, CNRS, Grenoble INP, LIG, F-38000 Grenoble, France}\\
    {\small $^3$\,Univ. Grenoble Alpes, CEA-Leti, F-38054 Grenoble, France}\\
    {\small akg@math.ku.dk, mehdi.mhalla@univ-grenoble-alpes.fr, valentin.savin@cea.fr}
}
\date{}
\maketitle

%\tableofcontents

\begin{abstract}
%
% A fault-tolerant way to prepare logical code-states  of $\pone$ codes, $i.e.$, quantum polar codes encoding one qubit, has been recently proposed. The fault tolerance therein is guaranteed with the help of an error detection gadget, where if an error is detected during the preparation, one declares a preparation failure and discards entirely the preparation. Due to error detection, the preparation is probabilistic, and its success rate, referred to as the \emph{preparation rate}, decreases rapidly with the code-length, thus preventing the preparation of code-states of large code-lengths.   In this paper, to improve the preparation rate, we consider a factory preparation of $\pone$ code-states, where one attempts to prepare several copies of $\pone$ code-states in parallel. With the help of an extra scheduling step, we can avoid discarding the preparation entirely, every time an error is detected, hence, achieving an increased preparation rate in turn.   We further provide a theoretical method to estimate preparation and logical error rates of the $\pone$ codes, prepared using factory preparation, which is shown to tightly fit the Monte-Carlo simulation based numerical results. Therefore, our theoretical method is useful for providing estimates for large code-lengths, where Monte-Carlo simulations are practically not feasible. Our numerical results, for a circuit-level depolarizing noise model, indicate that the preparation rate increases significantly, especially for large code-length $N$. For example, for $N = 256$, it increases from $0.02\%$ to $27\%$ for a practically interesting physical error rate of $p = 10^{-3}$.  Remarkably, a $\pone$ code of code-length $N = 256$ achieves logical error rates around $10^{-11}$ and $10^{-15}$ for the physical error rates of $p = 10^{-3}$ and $p = 3 \times 10^{-4}$, respectively. This corresponds to an improvement of about three orders of magnitude compared to a surface code with similar code-length and minimum distance, thus showing the promise of the proposed scheme for large-scale fault-tolerant quantum computing.

%% Arxiv abstract:
A fault-tolerant way to prepare logical code-states of $\pone$ codes, i.e., quantum polar codes encoding one qubit, has been recently proposed. The fault tolerance therein is guaranteed by an error detection gadget, where if an error is detected during the preparation, one discards entirely the preparation. Due to error detection, the preparation is probabilistic, and its success rate, referred to as the \emph{preparation rate}, decreases rapidly with the code-length, preventing the preparation of code-states of large code-lengths. In this paper, to improve the preparation rate, we consider a factory preparation of $\pone$ code-states, where one attempts to prepare several copies of $\pone$ code-states in parallel. Using an extra scheduling step, we can avoid discarding the preparation entirely, every time an error is detected, hence, achieving an increased preparation rate in turn. We further provide a theoretical method to estimate preparation and logical error rates of $\pone$ codes, prepared using factory preparation, which is shown to tightly fit the Monte-Carlo simulation based numerical results. Therefore, our theoretical method is useful for providing estimates for large code-lengths, where Monte-Carlo simulations are practically not feasible. Our numerical results, for a circuit-level depolarizing noise model, indicate that the preparation rate increases significantly, especially for large code-length $N$. For example, for $N = 256$, it increases from $0.02\%$ to $27\%$ for a practically interesting physical error rate $p = 10^{-3}$. Remarkably, a $\pone$ code with $N = 256$ achieves logical error rates around $10^{-11}$ and $10^{-15}$ for $p = 10^{-3}$ and $p = 3  \times 10^{-4}$, respectively. This corresponds to an improvement of about three orders of magnitude compared to a surface code with similar code-length and minimum distance, thus showing the promise of the proposed scheme for large-scale fault-tolerant quantum computing.


 
% This preparation is measurement-based, where one prepares a $\pone$ code-state of length $N = 2^n, n>0$, by recursively applying transversal two-qubit Pauli measurements.

%To improve the rate of successful preparation,  we introuce an extra scheduling step at some recursion levels. We modify~\cite[Procedure 2]{goswami2022fault}, so that at some intermediate levels of recursion, we only discard $\pone$ code-states, where an error is detected and keep all the successfully prepared intermediate states and continue the preparation for the next levels of recursion. As this allows to avoid restarting the preparation from the beginning everytime an error is detected, we may achieve better preparation rate


%In this paper, we provide a factory preparation, where several $\pone$ code-states are prepared in parallel. By taking advantage of the recursive nature of preparation 

%is probabilistic and needs to be possrepeated

\end{abstract}

% XXXXXX

\section{Introduction}

 Polar codes are known for their execellent error correction performance in both classical and quantum communication settings~\cite{arikan2009channel, renes2011efficient,renes2014polar,wilde2013polar, dupuis2021polarization}.  In particular, they achieve the symmetric capacity of any binary-input discrete memoryless classical channel, and achieve the symmetric coherent information of any quantum channel. They also come equipped with a fast classical decoding algorithm (log-linear complexity), which can readily be adapted for Pauli channels, using a syndrome based decoding approach~\cite{renes2011efficient, dupuis2021polarization}.

%Quantum polar codes are a class of quantum codes that achieve the symmetric coherent information of any quantum channel and come equipped with an efficient classical decoding algorithms on Pauli channels~\cite{renes2011efficient,renes2014polar,wilde2013polar, dupuis2021polarization}.

Despite their excellent error correction performance, and nice algebraic and structural properties, polar codes remained largely unexplored for fault-tolerant quantum computation (FTQC). The main reason is due to the high weight of their stabilizer group generators, which prevents fault-tolerant state preparation and error correction from being implemented by repeated syndrome measurements. This contrasts with conventional approaches based on topological, or more generally quantum low-density parity-check (LDPC) codes, allowing the implementation of a fault-tolerant quantum memory through repeated syndrome measurements, with errors being detected by the difference between syndromes measured in consecutive rounds~\cite{kitaev2003fault, bombin2006topological, breuckmann2021quantum}.

Recently, a fault-tolerant procedure to prepare logical states of $\pone$ codes, that is, CSS quantum polar codes encoding one logical qubit, has been proposed in~\cite{goswami2022fault}. Combined with Steane error correction~\cite{steane1997active, steane2002fast}, this preparation procedure provides an alternative and promissing approach for building a fault-tolerant quantum memory. 

%However, despite their excellent error correction performance, polar codes remained largely unexplored for fault-tolerant quantum computation (FTQC) until recently in~\cite{goswami2022fault}, where a fault-tolerant way to prepare logical code-states of $\pone$ (i.e. CSS quantum polar codes encoding one logical qubit) has been proposed. This preparation combined with the Steane error correction results in a promising approach for fault-tolerant error correction.

\smallskip The preparation in~\cite{goswami2022fault} is measurement-based, where a set of $N$ qubits are first initialized in the Pauli $Z$ basis and then two qubit Pauli measurements are recursively applied on them. To achieve fault tolerance, the preparation is aided by an error detection gadget, which detects errors at each level of recursion. For error detection-aided preparation, it has been explicitly proven that the preparation is fault-tolerant, in the sense that the weight of the error in the prepared state does not exceed the number of components that fail during the procedure. The fault tolerance therein has been further confirmed by numerical simulations, revealing practically interesting pseudo-threshold values for small $\pone$ codes of length $N \leq 64$ qubits, and showing the promise of the proposed approach to fault-tolerant error correction.

\smallskip However, the preparation of $\pone$ code-states in~\cite{goswami2022fault} is probabilistic due to the error detection gadget. If the gadget detects an error at some recursion level, one declares a preparation failure and discards the prepared state. Hence, one may need to restart the preparation from the beginning several times before a $\pone$ code is successfully prepared. The preparation rate, $i.e.$, the rate of successful preparation, decreases rapidly with the code-length and approaches zero as the code-length increases, hence preventing the preparation of large $\pone$ code-states.

\smallskip In this paper, to improve the rate of successful preparation, we consider a factory preparation of $\pone$ code-states, where one attempts to prepare several copies of polar code-states in parallel, using the measurement-based preparation with error detection from~\cite{goswami2022fault}. Taking advantage of the recursive nature of the preparation, we introduce an extra scheduling step at some recursion levels, so that even if errors are detected we may proceed to the next level of recursion. In other words, we may not need to restart the whole procedure from the beginning every time an error is detected. Therefore, the factory preparation may provide better preparation rates compared to the preparation in~\cite{goswami2022fault}. 


\smallskip In addition, we conduct a thorough theoretical analysis of the proposed factory-based preparation approach, constituting one of the most significant contributions of the paper. To this end, we define the notions of rough and smooth errors depending on whether or not the error flips one of the measurement outcomes in the measurement-based preparation. Using rough and smooth errors, we provide theoretical estimates of the preparation rate, as well as the probability of $X$ and $Z$ errors on the prepared state. The latter are used to estimate the logical error rates of the $\pone$ codes under Steane error correction, by using density evolution, as in ~\cite[Section V.D]{goswami2022fault}. Our theoretical estimates are further substantiated by Monte-Carlo simulations. For the circuit level depolarizing noise model, we observe that our theoretical estimate of the preparation rate fits well the Monte-Carlo simulation for code-lengths $N = 64$ and $N = 256$. Further, for the code-length $N= 64$, our theoretical estimate of the logical error rate matches the logical error rate obtained based on Monte-Carlo simulation. Therefore, we use our theoretical estimates to obtain logical error rates corresponding to small physical error rates and large code lengths, where Monte-Carlo simulation is not practically feasible.

\smallskip
For the circuit level depolarizing noise model, our numerical results show that the factory preparation improves significantly the preparation rate of $\pone$ code-states compared to~\cite{goswami2022fault}. In particular, for the physical error rate $p = 10^{-3}$, the preparation rate increases from $47\%$ to $70\%$ for a $\pone$ code-state of length $N = 64$ and from $0.02\%$ to $27\%$ for a $\pone$ code of length $N = 256$. The improvement for $N = 256$ is quite significant as the preparation rate of $27\%$ is practically feasible and implies a qubit overhead only by a factor of four. We have further included numerical results on the logic error rates of $\pone$ codes, using Steane error correction that incorporates our factory preparation of $\pone$ code-states. The $\pone$-code of length $N = 256$ achieves a logical error rate of $10^{-11}$ and $10^{-15}$ for  physical error rate of $10^{-3}$ and $3 \times 10^{-4}$, respectively. A comparison with a surface code of similar length and minimum distance is also provided, further reinforcing the promise of polar codes for fault-tolerant quantum computation.
 
\smallskip  The paper is organized as follows. In Section~\ref{sec:prelim}, we review $\mathcal{Q}_1$ codes and the measurement-based preparation of $\pone$ code-states with error detection from~\cite{goswami2022fault}. In Section~\ref{sec:fact-prep}, we describe our factory preparation, in Section~\ref{sec:estimates_theory}, we provide theoretical estimates of the preparation rate and of the Pauli error probabilities on the prepared state, and in Section~\ref{sec:num-res}, we present our numerical results regarding the factory preparation and comparison with surface codes. Finally, in Section~\ref{sec:conc}, we conclude with some perspectives and future directions.
%
%Large scale quantum computers are expected to use quantum error correcting (QEC) codes to provide resilience against noise~\cite{preskill1998fault}. A  QEC code encodes one or more logical qubits into many noisy physical qubits, so that the logical qubits are more robust against noise than the physical qubits.  However, a  QEC code alone does not provide the ability to do fault-tolerant quantum computation (FTQC). To avoid the uncontrolled propagation of errors, it must be complemented with  several \emph{fault-tolerant} procedures~\cite{gottesman2010introduction}, aimed at $(i)$~preparing logical code-states, $(ii)$~operating on logical states, and $(iii)$~performing error correction. 
%
%In this paper, we explore a new approach to fault-tolerant quantum computation (FTQC), relying on quantum polar codes. Introduced first in 2009 for classical systems~\cite{arikan2009channel}, and then generalized to the quantum case~\cite{renes2011efficient, wilde2013polar, renes2014polar, dupuis2021polarization}, polar codes arguably represent one of the most important advances of the past decade in the coding theory. They achieve the coherent information (one-shot capacity) of any quantum channel, and come equipped with an efficient decoding algorithm, known as successive cancellation (SC), whose complexity scales log-linearly with the code-length. 
%
%It is worth noticing that a low-complexity decoding algorithm is key to performing fault-tolerant error correction. Indeed, the decoding must be faster than the syndrome extraction rate, since otherwise, the latency overhead becomes exponential in the number of non-Clifford gates, hindering any quantum advantage ~\cite{holmes2020nisq}. 
%
%
%Yet, despite their excellent error correction properties, polar codes have been hardly explored for quantum computing, except the work in \cite{krishna2018magic} on magic state distillation. Here, we focus on two closely related ingredients of FTQC, namely fault-tolerant code-state preparation and fault-tolerant error correction.
%
%
%The main contributions are as follows. 
%
%
%We consider quantum polar codes of Calderbank-Shor-Steane (CSS) type that encode one logical qubit, which we refer to as $\pone$ codes. We show that $\pone$ codes are a natural generalization of the well-known family of Shor codes, providing improved error correction performance.
% 
%
%We then consider the fault-tolerant preparation of $\pone$ code-states under the effect of noise. We propose a procedure to prepare $\pone$ code-states, by recursively performing  Pauli $Z\otimes Z$ or Pauli $X\otimes X$ measurements. This procedure is not by itself fault-tolerant, however, the measurement operations therein provide redundant classical bits, which can be advantageously used for error detection. Hence, to achieve fault-tolerance, the proposed procedure is complemented by an error detection method. 
%
%Finally, we consider the fault-tolerant error correction of $\pone$ codes, using Steane error correction \cite{steane1997active, steane2002fast}. We provide numerical estimates of the logical error rate (LER), assuming a circuit-level depolarizing noise  model, for $\pone$ and Shor-$\pone$ codes of length $N=16$ and $N=64$. Remarkably, the $\pone$ code of length $64$ qubits achieves an LER very close to $10^{-6}$ for the physical error rate $p = 10^{-3}$, therefore, demonstrating the potential of the proposed polar codes based approach to FTQC.


\section{Preliminaries} \label{sec:prelim}


\subsection{$\pone$ codes}

Here, we briefly review $\pone$ codes, which are CSS quantum polar codes that encode one logical qubit (for a review of CSS quantum polar codes see~\cite[Section~II]{goswami2022fault}).


\smallskip The quantum polar transform $Q_N$, where $N = 2^n$, with $n \geq 0$, is the unitary operation on $N$ qubits that operates in the computational basis as the classical polar transform $P_N$. Precisely, for any $\bm{u} = (u_1, \dots, u_N) \in \{0,1\}^N$, we define $Q_N\ket{\bm{u}} = \ket{P_N\bm{u}}$, where $P_N = \big( \begin{smallmatrix} 1 & 1 \\ 0 & 1 \end{smallmatrix}\big)^{\otimes n} $. Hence, $Q_N$  can be realized by recursively applying the quantum CNOT gate, transversely, on sub-blocks of $2^k$ qubits, for $k = 0,...,n-1$ (see Fig. \ref{fig:qpolar_N8}).
 

\smallskip Let $ \mathcal{S} = \{1,...,N\}$ denote an $N$-qubit quantum system. For a $\pone$ code, a position $i \in \mathcal{S}$ is chosen to encode the logical information. Given the index $i$, the set of indices preceding $i$,  $i.e$, $\mathcal{Z} \eqdef \{1, \dots, i-1\}$, are frozen in a $Z$ basis state $\ket{\bm{u}}_\mathcal{Z}, \bm{u} \in \{0, 1\}^{1-i}$. Further, the set of indices succeeding $i$,  $i.e$, $\mathcal{X} \eqdef \{i+1, \dots, N\}$, are frozen in a $X$ basis state, $\ket{\bm{\oline{v}}}_\mathcal{X}$, where $\bm{v} \in \{0, 1\}^{|\mathcal{X}|}$ and we have used the notation $\ket{\bar{0}} := \ket{+}$, and $\ket{\bar{1}} := \ket{-}$. 

%The sets $\mathcal{I} \eqdef \{i\}$,$\mathcal{Z}$ and $\mathcal{X}$ are referred to as information set, frozen $Z$ and $X$ sets respectively.

\smallskip Therefore, the logical code-state, denoted by $\ket{\widetilde{\phi}}_\mathcal{S}$, is given by $\ket{\widetilde{\phi}}_\mathcal{S} = Q_N (\ket{\bm{u}}_\mathcal{Z} \otimes \ket{\phi}_i  \otimes \ket{\bm{\oline{v}}}_\mathcal{X})$. In the following, we shall denote by by $\mathcal{Q}_1(N, i)$ the $\pone$ code of length $N$,  with  information position $ i \in \mathcal{S} = \{1, \dots, N \}$.

It is worth emphasizing that the error correction performance of a $\pone$ code greatly depends on the choice of the information position $i$. For depolarizing channels, the information position providing the best error correction performance, depending on the code-length $N$, was determined by using density evolution in~\cite{goswami2022fault}.

\paragraph*{Shor-$\pone$codes.} When the information position $ i \in \mathcal{S}$ is a power of two, $i.e.$, $i = 2^k, 0 \leq k \leq n$, the corresponding $\pone$ code is a Shor code~\cite[Theorem 1]{goswami2022fault}. The sub-family of Shor codes obtained from $\pone$ codes are referred to as Shor-$\pone$ codes. A Shor-$\pone$ code in general has inferior error correction performance compared to a $\pone$ code of the same code-length and minimum distance as the successive cancellation (SC) decoding of $\pone$ codes is able to decode beyond the minimum distance~\cite{goswami2022fault}.

%takes advantage of the full degree of freedom in $i$ and are not just restricted to positions that are power of two.~.  


%For a CSS quantum polar code \cite{renes2011efficient}, the system $\mathcal{S}$ is partitioned into $\mathcal{S} = \mathcal{Z} \cup \mathcal{I} \cup \mathcal{X}$, and the input quantum state of the polar transform is taken as follows. 

%For $\pone$ codes, the information set $\mathcal{I} = \{i\}$, for some $i \in \mathcal{S} = \{1, \dots, N\}$. Given the index $i$, the frozen sets $\mathcal{Z}$ consists of the set of indices preceding $i$,  $i.e$, $\mathcal{Z} \eqdef \{1, \dots, i-1\}$, and the frozen set $\mathcal{X}$ consists of the set of indices succeeding $i$,  $i.e$, $\mathcal{X} \eqdef \{i+1, \dots, N\}$.

%\smallskip For $\mathcal{Z} \subseteq \mathcal{S}$, the quantum state is frozen to a known Pauli $Z$ basis state $\ket{\bm{u}}_\mathcal{Z}$, where $\bm{u} := (u_1, \dots, u_n) \in \{0, 1\}^{|\mathcal{Z}|}$. For $\mathcal{X} \subseteq \mathcal{S}$, with $\mathcal{Z} \cap \mathcal{X} = \emptyset$, it is frozen to a known Pauli $X$ basis state $\ket{\bm{\oline{v}}}_\mathcal{X}$, where $\bm{v} \in \{0, 1\}^{|\mathcal{X}|}$ and we use the notation $\ket{\bar{0}} := \ket{+}$, and $\ket{\bar{1}} := \ket{-}$.  The remaining subset $\mathcal{I} := \mathcal{S}\setminus (\mathcal{X} \cup \mathcal{Z})$ is used to encode quantum information $\ket{\phi}_\cl{I}$. 



%\paragraph{$\pone$ codes (Quantum Polar Codes Encoding One Logical Qubit) \cite{goswami2022fault}: } \label{sec:q1code}



%As proved in \cite{}, when the information position is a power of two, that is, $i = 2^k, 0\leq k \leq n$, the corresponding $\pone$ code is a Shor code\cite{shor1995scheme,bacon2006operator}. We refer to these codes as \emph{Shor-$\pone$ codes}, or simply Shor codes, when no confusion is possible. 

%The \emph{construction} of a $\pone$ code refers to the choice of the information position $i$, which determines how  well the code protects the encoded quantum information. Hence, the position~$i \in \mathcal{S}$ should be chosen in a way to optimize the LER performance, depending on the specific noisy quantum channel.  For the subfamily of Shor-$\pone$ codes, the choice is restricted to positions $i = 2^k, 0\leq k \leq n$. 
%
%For depolarizing quantum channels, it is shown that $\pone$ codes generally outperform Shor-$\pone$ subfamily, hence providing an useful generalization of Shor codes \cite{}. 
% Figure environment removed

\subsection{Measurement-based preparation of $Q_1$ code-states}
%
%A recursive measurement-based preparation of $\pone$ code-states has been proposed in \cite{goswami2022fault}, employing only two qubit Pauli measurements. Further, this measurement-based procedure is shown to be fault-tolerant by incorporating an error detection gadget into it. In the following, we summarize the measurement-based preparation; first for the noiseless scenario and then for the noisy scenario, where we will discuss the error detection gadget.
%
%
In this section, we summarize the measurement-based preparation from~\cite{goswami2022fault} and discuss briefly its fault tolerance, under a circuit-level Pauli noise model.
%For $\pone$ code-states, 
%
%
%all the inputs of the polar transform $Q_N$ are frozen in either $Z$ or $X$ basis, precisely, the first consecutive inputs up to some $i(n) \in \mathcal{S}$ \footnote{Here, $n$ indicates the level of recursion.} are frozen in the $Z$ basis and the remaining inputs are frozen in the $X$ basis \cite{goswami2022fault}. 

Consider a $\pone (N, i)$ code, with $N = 2^n$ and $i \in \mathcal{S} = \{1, \dots, N\}$. We consider logical $Z$ and $X$ states of the code $\pone(N, i)$, hence the information position is also frozen in either $Z$ or $X$ basis, accordingly. Therefore, a $\pone(N, i)$ code-state has the following form,
\begin{equation}
\ket{q_N}_\mathcal{S} := Q_N \left( \ket{\bm{u}, \oline{\bm{v}}}_\mathcal{S}\right) = Q_N \left(\ket{\bm{u}}_{\cl{Z}(n)} \otimes \ket{ \oline{\bm{v}}}_{\cl{X}(n)}\right), \label{eq:q-prep-state}
\end{equation}
where $\cl{Z}(n) = \{1, \dots, i(n)\}$ and $\cl{X}(n) = \{i(n) + 1, \dots, N\}$, where \[i(n) = \begin{cases}   
 i, & \text{ for $Z$ logical state.} \\
 i-1, & \text{ for $X$ logical state.}
 \end{cases}\]

%$\bm{u} \in \{0,1\}^{i(n)}$ and $\bm{v} \in \{0,1\}^{N - i(n)}$, and where 

\smallskip Therefore, $i(n)$ simply represents the length of $Z$ type frozen set after the $n^{th}$ level of recursion. When no confusion is possible, we may simply write $\ket{q_N}$ instead of $\ket{q_N}_\mathcal{S}$. Finally, $\pone$ states defined by the same value of $i(n)$ are considered equivalent, regardless of the corresponding frozen values $\bm{u}, \bm{v}$. Note that equivalent $\pone$ states are defined by the same stabilizer generators, up to sign factors~\cite[Lemma 4]{goswami2022fault}.


\subsubsection{Recursive measurement-based preparation without noise}
%
Any $\pone$ code-state can be prepared using the following measurement-based procedure~\cite[Theorem~1]{goswami2022fault} (see also Fig.~\ref{fig:qpolarprep_N8_i3}). 


\begin{procedure}[measurement-based Preparation \cite{goswami2022fault}] \label{prot:prep}
Consider $\ket{q_N}_\mathcal{S}$ from (\ref{eq:q-prep-state}) and let $b_1\cdots b_n$ be the binary representation of $i(n)-1$, with $b_n$ being the most significant bit, $i.e$, $i(n)-1 = \sum_{k=1}^{n} b_k 2^{k-1}$. Then, the measurement-based procedure to prepare $\ket{q_N}_\mathcal{S}$ is carried out in $n+1$ steps, as follows.

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{1.7em}\setlength{\listparindent}{0em}}

\item[$(0)$] First, $\mathcal{S} = \{1, \dots, N\}$ is initialized in a Pauli $Z$ basis state $\ket{\bm{u}}_{\mathcal{S}}, \text{ for some } \bm{u} \in \{0, 1\}^N$.


\item[$(1 \to n)$] Then, two-qubit Pauli measurements are recursively applied for $n$ levels. The recursion is the same as the recursion of the quantum polar transform (see Fig. \ref{fig:qpolar_N8}), except that each $\cnot$ gate is replaced by either Pauli $X \otimes X$ or $Z \otimes Z$ measurement. Precisely, if $b_k = 0$ (or, $b_k = 1$), we apply Pauli $X \otimes X$ (or, $Z \otimes Z$) measurements at the $k^\text{th}$ recursion level, $k = 1, \dots, n$.
\end{list}
\end{procedure}
%
%At $k^{th}, 1 \leq k \leq n$ level of recursion, the above procedure applies either transversal Pauli $X \otimes X$ or $Z \otimes Z$ measurements on two equivalent polar codes states of length $2^{k-1}$, $i.e.$,  $\ket{q_{2^{k-1}}}$, preparing a $\pone$ code-state $\ket{q_{2^{k}}}$ . 

Note that a Pauli $Z$ basis state can be considered as a $\pone$ code-state of length $2^0$. Therefore, the first step of Procedure \ref{prot:prep}, \emph{i.e.}, initialization in a Pauli $Z$ basis, corresponds to the zeroth level of recursion, where one prepares $2^n$ copies of $\ket{q_{2^0}}$. After any $k^\text{th}$ level of recursion, $1 \leq k \leq n$, Procedure \ref{prot:prep} prepares $2^{n-k}$ equivalent code-states $\ket{q_{2^k}}$, with $i(k)-1 = \sum_{k=1}^{k} b_k 2^{k-1}$ (see Fig.~\ref{fig:qpolarprep_N8_i3}). In particular, each $\ket{q_{2^k}}$ is produced by applying  transversal Pauli $X \otimes X$ or $Z \otimes Z$ measurements on two equivalent $\ket{q_{2^{k-1}}}$ from the $(k-1)^{th}$ level of recursion \cite[Lemma 1]{goswami2022fault}. 

%We shall refer to the $\pone$ code-states prepared at any $k^{th}, k < n$ level of recursion as \emph{intermediate} $\pone$ code-states. 

% Figure environment removed


%\begin{lemma}{\cite[Lemma 1]{goswami2022fault}} \label{lem:Q1_code_prep}
%Consider two equivalent $\pone$ states on $K/2$-qubit systems $\mathcal{S}_1 : = \{1, \dots, K/2 \}$ and $\mathcal{S}_2 : = \{K/2+1, \dots, K\}$ as follows, $\ket{q_{\frac{K}{2}}^1}_{\mathcal{S}_1} \eqdef Q_{\frac{K}{2}} \ket{\bm{u_1}, \oline{\bm{v}}_{\bm{1}}}_{\mathcal{S}_1}$ and $\ket{q_{\frac{K}{2}}^2}_{\mathcal{S}_2} \eqdef Q_{\frac{K}{2}} \ket{\bm{u_2}, \oline{\bm{v}}_{\bm{2}}}_{\mathcal{S}_2}$, where $\bm{u_1}, \bm{u_2} \in \{0, 1\}^{i(k-1)}$ and $\bm{v_1}, \bm{v_2} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$, with $1 \leq i(k-1) \leq K/2$. Let $\mathcal{S} := \mathcal{S}_1 \cup \mathcal{S}_2$ be the joint system, then we have the following two cases.
%
%
%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{0.3em}\setlength{\listparindent}{0em}}
%\item Case $1$: If we apply transversal Pauli $Z \otimes Z$ measurements on the corresponding qubits of $\cl{S}_1$ and $\cl{S}_2$, we get the $K/2$ bit measurement outcome as follows,
%\begin{equation}
% \bm{m} = P_\frac{K}{2}(\bm{u'}, \bm{x}) \in \{0, 1\}^{\frac{K}{2}}, \label{eq:m-out}
%\end{equation}
%where $\bm{u'} = \bm{u_1} \oplus \bm{u_2} \in \{0, 1\}^{i(k-1)}$ and  $\bm{x} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$ is a random vector, and $P_{\frac{K}{2}}$ is the classical polar transform. After measurements, the state of $\mathcal{S}$ is a $\pone$ state, $\ket{q_K}_\mathcal{S} =  Q_K \ket{(\bm{u'}, \bm{x}, \bm{u_2}), \overline{\bm{v_1} \oplus \bm{v_2}}}_\mathcal{S}$, with $i(k) = i(k-1) + K/2 > K/2$, and where $\bm{x}$ is determined from the measurement outcome $\bm{m}$ in (\ref{eq:m-out}) by, $\bm{x} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{X}(k-1)}$, $i.e.$, the subvector of  $P_{\frac{K}{2}}(\bm{m}) \in \{0, 1\}^{K/2}$ corresponding to indices in the set $\mathcal{X}(k-1)$. 
%
%
%
%\item Case $2$: If we apply transversal Pauli $X \otimes X$ measurements on the corresponding qubits of $\cl{S}_1$ and $\cl{S}_2$, we get the $K/2$ bit measurement outcome as follows,
%\begin{equation}
% \bm{m} = P_\frac{K}{2}^\top(\bm{z}, \bm{v'}) \in \{0, 1\}^{\frac{K}{2}}, \label{eq:m-out-x}
%\end{equation}
%where $\bm{z} \in \{0, 1\}^{i(k-1)}$ is a random vector, and $\bm{v'} = \bm{v_1} \oplus \bm{v_2} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$. After measurements, the state on $\mathcal{S}$ is a $\pone$ state $\ket{q_K}_\mathcal{S} = Q_K \ket{\bm{u_1} \oplus \bm{u_2}, \overline{(\bm{v_1},  \bm{z},  \bm{v'})}}_\mathcal{S}$, with $i(k) = i(k-1) \leq K/2$ and from (\ref{eq:m-out-x}), $\bm{z} = P_{\frac{K}{2}}^\top (\bm{m})\lvert_{\mathcal{Z}(k-1)}$.
%
%\end{list}
%\end{lemma}


\subsubsection{Recursive measurement-based preparation with noise} \label{sec:prep-n}
We consider the standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$ measurements, using an ancilla qubit, as depicted in Figure~\ref{fig:mZZ_mXX_notation_and_circuit}. Then, the measurement-based procedure consists of the following basic components: qubits initialization in either Pauli $X$ or $Z$ basis, $\cnot$ gates, measurements in the Pauli $X$ or Pauli $Z$ basis. It is easy to see that the total number of components in the preparation of a $\pone$ code-state  of length $N$, denoted here by $C_N$, is given by \cite{goswami2022fault},
\begin{equation} \label{eq:num-comp}
C_N = N (1 + 2 \log N)
\end{equation}




\paragraph*{Noise Model.} We further assume that each component fails independently with some probability $p$, referred to as the physical error rate, according to a circuit level depolarizing noise model as follows~\cite{fowler2012surface}.

%Recall that our recursive procedure consists of two main operations; intialization in a Pauli $Z$ basis state and Pauli $Z\otimes Z$ or $X\otimes X$ measurements. 

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{0.3em}\setlength{\listparindent}{0em}}

\item[$1$] A noisy initialization in Pauli $Z$ (or $X$) basis corresponds to the perfect initialization, followed by an $X$ (or $Z$) error on the initialized qubit, with  probability $p$.

\item[$2$] A noisy CNOT gate corresponds to applying the perfect CNOT gate, followed by a two-qubit depolarizing channel, with probability $p$. Precisely, after the perfect CNOT, any one of the following $15$-two qubit Pauli errors $I \otimes X, I \otimes Y, I \otimes Z, X \otimes I, X \otimes X, X \otimes Y, X \otimes Z$,  $Z \otimes I$, $Z \otimes X$, $Z \otimes Y$, $Z \otimes Z$, $Y \otimes I$, $Y \otimes X$, $Y \otimes Y$, $Y \otimes Z$ may happen, with total probability $p$ (probability $p/15$ each).

\item[$3$] A noisy Pauli $Z$ (or $X$) basis measurement corresponds to first applying a Pauli $X$ (or $Z$) error on the qubit to be measured with probability $p$, then doing the perfect Pauli $Z$ (or $X$) measurement.

\end{list}


% Figure environment removed

%We now consider our measurement-based procedure under the effect of Pauli noise. We assume the standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$  measurements, where a bare ancilla qubit is initialized in either Pauli $Z$ or Pauli $X$ basis state, then two CNOT gates are applied between data and ancilla qubits, and finally the ancilla qubit is measured in Pauli $Z$ or $X$ basis. Therefore, any two-qubit Pauli measurement decomposes into four basic \emph{components}, namely one single-qubit initialization, two $\cnot$-gates, and one single-qubit measurement. 

%\smallskip As the preparation of $\ket{q_N}_\mathcal{S}$ consists of $N$ single-qubit initializations, followed by $N/2 \log N$ two-qubit Pauli measurements, the total number of components in the preparation is equal to $N (1 + 2 \log N)$.


\smallskip The measurement-based preparation given in Procedure~\ref{prot:prep} is not fault-tolerant by itself under the above noise model. The reason is that the outcomes of transversal Pauli $Z \otimes Z$ or Pauli $X \otimes X$ measurements, which are needed to determine the values corresponding to the frozen $\mathcal{Z}$ and $\mathcal{X}$ sets, get error corrupted, thus leading to a wrong determination of frozen values~\cite{goswami2022fault}. 

\smallskip To achieve fault tolerance, an error detection gadget is incorporated into the measurement-based procedure. Taking advantage of the redundancy in the transversal Pauli measurements, the error detection gadget detects errors at each level of recursion.

\paragraph{Error detection gadget.} Here, we briefly present the error detection gadget for the case of Pauli $Z \otimes Z$ measurements  (see~\cite[Procedure 2]{goswami2022fault} for more details). For $K = 2^k$, consider two equivalent $\pone$ code states $\ket{q^1_{K/2}}_{\mathcal{S}_1} = Q_{K/2}\ket{\bm{u}_1, \oline{\bm{v}_1}}$ and $\ket{q^1_{K/2}}_{\mathcal{S}_2} = Q_{K/2}\ket{\bm{u}_2, \oline{\bm{v}_2}}$, where $\bm{u}_1, \bm{u}_2 \in \{0, 1\}^{i(k-1)}$ and $\bm{v}_1, \bm{v}_2 \in \{0, 1\}^{K - i(k-1)}$. Consider first the noiseless scenario. The result of the transversal Pauli- $Z \otimes Z$ measurements on these polar code states is a codeword of a classical polar code as follows,
\begin{equation}
 \bm{m} = P_\frac{K}{2}(\bm{u'}, \bm{x}) \in \{0, 1\}^{\frac{K}{2}}, \label{eq:m-out}
\end{equation}
where $\bm{u'} = \bm{u_1} \oplus \bm{u_2} \in \{0, 1\}^{i(k-1)}$ and  $\bm{x} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$ is a random unknown vector, and $P_{\frac{K}{2}}$ is the classical polar transform. After measurements, the state of the joint system $\mathcal{S} = \mathcal{S}_1 \cup \mathcal{S}_2$ is a $\pone$ state, 
\begin{equation}
\ket{q_K}_\mathcal{S} =  Q_K \ket{(\bm{u'}, \bm{x}, \bm{u_2}), \overline{\bm{v_1} \oplus \bm{v_2}}}_\mathcal{S},
\end{equation}
 with $i(k) = i(k-1) + K/2 > K/2$, and where $\bm{x}$ is determined from the measurement outcome $\bm{m}$ in (\ref{eq:m-out}) by, $\bm{x} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{X}(k-1)}$, $i.e.$, the subvector of  $P_{\frac{K}{2}}(\bm{m}) \in \{0, 1\}^{K/2}$ corresponding to indices in the set $\mathcal{X}(k-1)$.

For the noisy scenario, the measurement outcome gives a noisy codeword of the classical polar code instead of (\ref{eq:m-out}), as follows
\begin{equation}
\bm{m} = P_\frac{K}{2}(\bm{u'}, \bm{x}) \oplus \bm{e}_X.
\end{equation}
The error detection gadget determines the syndrome of the error term $\bm{e}_X$ in the measurement outcome $\bm{m}$ as, $P_{\frac{K}{2}}(\bm{e}_X) \lvert_{\mathcal{Z}(k-1)} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{Z}(k-1)} \,\oplus\, \bm{u'}$. If the syndrome is zero, we proceed as in the noiseless case. If the syndrome is not zero, we report a component failure and discard the prepared state. For example, in Fig.~\ref{fig:qpolarprep_N8_i3}, if an error is detected in one of the $\ket{q_2^2}$ prepared at the second level of recursion, we discard the other prepared state even if no error is detected in it and restart the procedure from the beginning. 



 

%\smallskip More precisely, the measurement outcomes of  transversal Pauli $Z \otimes Z$ or Pauli $X \otimes X$ measurements on two equivalent copies of $\ket{q_{2^k}}$,  corresponds to a codeword of a classical polar code~\cite[Lemma 1]{goswami2022fault}. The component failures before the measurement may flip some of the measurement outcomes\footnote{Namely, $X$ errors may flip outcomes of Pauli $Z \otimes Z$ measurements, and $Z$ errors may flip outcomes of Pauli $X \otimes X$ measurements.}, therefore outputting a noisy version of the classical polar codeword. To detect the errors, we compute the syndrome of the classical code from the noisy measurement outcome and if the syndrome is not zero, we report a component failure and discard the prepared state. For example, in Fig.~\ref{fig:qpolarprep_N8_i3}, if an error is detected in one of the $\ket{q_2^2}$ prepared at the second level of recursion, we discard the other prepared state even if no error is detected in it and restart the procedure from the beginning.

\medskip Therefore, one needs to repeat the preparation until a preparation succeeds without an error detection. The preparation rate is defined as 
\begin{equation} \label{eq:prep_rate}
p_{\text{prep}}= \lim_{R \to \infty} \frac{t}{R},
\end{equation}
where $t$ is the number of successful preparations out of $R$ independent preparation attempts. 

\smallskip Finally, it is worth noting that some errors may not be detected by the gadget and hence, will remain on the successfully prepared states. It has been shown that the successfully prepared state is fault-tolerant in the sense that the errors in the prepared state do not exceed the number of component failures~\cite[Theorem 3]{goswami2022fault}. 


  

%Due to failures in the components, the measurement outcomes of transversal Pauli $Z \otimes Z$ or $X \otimes X$ measurements are error corrupted as follows, for some $\bm{e}_X, \bm{e}_Z \in \{0, 1\}^{K/2}$ 
%%
%\[ m =   
%\begin{cases}
%P_\frac{K}{2}(\bm{u'}, \bm{x}) \oplus \bm{e}_X & \text{ for Pauli $Z \otimes Z$ measurement}\\
%P_\frac{K}{2}^\top(\bm{z}, \bm{v'}) \oplus \bm{e}_Z & \text{ for Pauli $X \otimes X$ measurement}
%\end{cases}
%\] 
%%
%Note from Lemma, that the measurement outcome $\bm{m}$ is used to determine a part of the frozen $X$ or $Z$ values of the prepared state. Therefore, error corrupted measurement may lead to the incorrect determination of frozen values, making the preparation not fault-tolerant. To remedy this an error detection gadget is incorporated into the measurement-based preparation (see Procedure \ref{prot:err_det} below), and further the measurement-based preparation with the error detection is shown to be fault-tolerant \cite[Theorem 3]{goswami2022fault}.
%
%\begin{procedure}[measurement-based Preparation with Error Detection] \label{prot:err_det}
%Consider the preparation of a $\pone$ state of length $N$ from Procedure~\ref{prot:prep}.  We further incorporate an error detection gadget within each level of reccursion, $k=1,\dots, n$, consisting of the following two steps.
%
%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{1.7em}\setlength{\listparindent}{0em}}
%\item[$(1)$]  For all $2^{n-k}$ instances of prepared $\ket{q_K}$ states at the $k^{th}$ level of recursion, we first determine the syndrome of the error in the measurement outcome $\bm{m}$ as follows. When Pauli $Z \otimes Z$ measurements are performed ($i.e$, Case $1$ of Lemma \ref{lem:Q1_code_prep}), we determine the syndrome of the error term $\bm{e}_X$ in the measurement outcome $\bm{m}$ as, $P_{\frac{K}{2}}(\bm{e}_X) \lvert_{\mathcal{Z}(k-1)} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{Z}(k-1)} \,\oplus\, \bm{u'}$. Similarly, when Pauli $X \otimes X$ measurements are performed ($i.e$, Case $2$ of Lemma \ref{lem:Q1_code_prep}), we determine the syndrome of the error term $\bm{e}_Z$ as, $P_{\frac{K}{2}}^\top(\bm{e}_Z) \lvert_{\mathcal{X}(k-1)} = P_{\frac{K}{2}}^\top(\bm{m})\lvert_{\mathcal{X}(k-1)} \,\oplus\, \bm{v}'$. 
%
%
%\item[$(2)$] If the syndrome is the zero vector for all the $2^{n-k}$ instances of $\ket{q_K}$, we determine the value of $\bm{x}$ or $\bm{z}$ for all prepared states as in Lemma~\ref{lem:Q1_code_prep}, and proceed to the next level of recursion. Otherwise, we declare a preparation failure.
% 
%\end{list}
%\end{procedure}


\section{A factory preparation of polar code-states} \label{sec:fact-prep}


%Note that the preparation of $\ket{q_{2^n}}$, according to~\cite[Procedure 2]{goswami2022fault}, is probabilistic. If an error is detected in one of the $\ket{q_{2^k}}$, prepared at the $k^{th}, 1 \leq k \leq n$ level of recursion, we declare a preparation failure and discard all the other states even if some of them may be successfully prepared.

 


%The reason for this is that even if one intermediate state fails, we don't have enough intermediate states to continue to the next level of recursion.
 
%In the event of an error detection, we may restart the preparation from the begining, by initializing $N$ qubits in a Pauli $Z$ basis state. Therefore, we may need to restart the preparation several times before it finally succeeds. The preparation rate is defined as $p_{\text{prep}}= \lim_{R \to \infty} \frac{t}{R}$, where $t$ is the number of successful preparations out of $R$ preparation attempts. 

 
Note that the rate of the preparation $p_{\text{prep}}$ in~(\ref{eq:prep_rate}) decreases as the code-length $N$ increases. Intuitively, this is because the number of components increases with respect to $N$, as given in~(\ref{eq:num-comp}), thus resulting in an increased expected number of failures, and as a consequence a higher probability of error detection. Numerical results in~\cite{goswami2022fault} suggest that the $p_{\text{prep}}$ decreases rapidly as $N$ increases, hence, prohibiting the preparation of $\pone$ code-states of larger code-lengths in a practical scenario.

%In this section, we consider a factory preparation, where several $\pone$ code-states are prepared in parallel.

In this section, to improve the preparation rate, we consider a factory preparation, where several $\pone$ code-states of length $N$ are prepared in parallel.  We modify~\cite[Procedure 2]{goswami2022fault}, so that at some intermediate levels of recursion, we only discard $\pone$ code-states where an error is detected, and keep all the successfully prepared intermediate states and continue the preparation for the next levels of recursion. As this allows to avoid restarting the preparation from the beginning every time an error is detected, we may achieve better preparation rate than~\cite[Procedure 2]{goswami2022fault}.  


%have enough successfully prepared states of length $2^k$, to continue to the next level of recursion. 

%Our numerical results on $\pone$ code-states of lengths lengths $N = 16, 64, 256$ indicate that the preparation rate indeed improves significantly for the factory preparation.
%Our factory preparation is as follows.

\medskip We below describe our factory preparation in detail.

Let $\mathcal{S}_T \eqdef \{1, \dots, TN \}, T \geq 1$ be a set of $TN$ qubits, on which we want to prepare several copies of a $\pone$ code-state of length $N = 2^n$, $i.e.$, $\ket{q_N}$, with given $i(n)$ value, so that $b_1\cdots b_n \in \{0, 1\}^n$ is the binary expansion of $i(n)-1$. We will refer to $T$ as the \emph{size of the factory}, as $T$ is the maximum number of copies of $\ket{q_N}$ that can be produced. Further, consider the following ordered set
\begin{equation} \label{eq:sch-set}
    n_{sch} := \{ i_1, i_2, ..., i_{|n_{sch}|}\} \subseteq \{1, ..., n \},
\end{equation}
such that $0 < i_1 < i_2 < \cdots < i_{|n_{sch}|}$, and $i_{|n_{sch}|} = n$. We shall refer to $n_{\text{sch}}$ as the \emph{scheduling set} and the elements in $n_{\text{sch}}$ as the \emph{scheduling recursion levels}.  

%\smallskip Let $n_{\text{sch}} \subseteq \{0, \dots, n\}$ be a subset, so that it contains both zero\footnote{Recall that the zeroth step of recursion corresponds to initialization in a Pauli $Z$ basis state, $i.e.$, preparing $\ket{q_{2^0}}$.} and $n$, and further it is an ordered set, $i.e.$, $n_{\text{sch}}(j) > n_{\text{sch}}(i)$ if $j > i$, where $n_{\text{sch}}(i)$ denotes the $i^{th}, i \in \{0, \dots, |n_{\text{sch}}| - 1\}$ element of $n_{\text{sch}}$. Hence, zero is the zeroth element and $n$ is the last element of $n_{\text{sch}}$. We shall refer to $n_{\text{sch}}$ as the \emph{scheduling set} and the elements in $n_{\text{sch}}$ as the \emph{scheduling recursion levels}.  

\smallskip We denote by $B_{i \to j}$ the recursion levels from $i+1,...,j$ of Procedure 1, with respect to the binary string $b_{i+1},...,b_{j}$. For the particular case $B_{0 \to j}$, we  also include the initialization of the data qubits. We shall also assume that $B_{i \to j}$ incorporates the error detection gadget, as explained in Section~\ref{sec:prep-n}, and detailed in~\cite[Procedure 2]{goswami2022fault}. If an error is detected at one of the recursion levels of $B_{i \to j}$, we declare a preparation failure and discard the prepared state, hence no output is produced. If no error is detected during $B_{i \to j}$, we successfully prepare a $\pone$ code state of length $2^{j}$ (as shown in Fig.~\ref{fig:fact_prep}).

%\smallskip 
%
%We consider the implementation of~\cite[Procedure 2]{goswami2022fault}  in several steps, where each step implements a part of recursion levels.  We shall denote by $B_{i \to j}$, the recursion levels from $i + 1, \dots, j$ of~\cite[Procedure 2]{goswami2022fault},  with respect to the binary string $b_{i+1} \dots b_j$.  

\smallskip
Our factory preparation is as follows (see also Fig.~\ref{fig:fact_prep}). 

\begin{procedure}[Factory Preparation] \label{prot:fact_prep}

Consider the set of qubits $\mathcal{S}_T = \{1, \dots, TN\}, T \geq 1, N = 2^n, n > 0 $, and the scheduling set $n_{\text{sch}} \subseteq \{1, \dots, n\}$ according to~(\ref{eq:sch-set}). Then, the factory preparation consists of the following steps.

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}

\item[$(i)$] We first split $\mathcal{S}_T$ in groups, each containing $2^{i_1}$ qubits. We then apply $B_{0 \to i_1}$ on each group.


%The zeroth level of recursion corresponds to intializing the qubits in $\mathcal{S}_T$ in a Pauli $Z$ basis state. 


\item[$(ii)$] To prepare several copies of $\ket{q_{2^n}}$, we then recursively apply the preparation $B_{i_k \to i_{k+1}}, 1 \leq k < |n_{sch}|$,  as follows.

After any scheduling recursion level $i_k$, $1 \leq k < |n_{sch}|$, if more than $2^{n - i_k}$ copies of $\ket{q_{2^{i_k}}}$ are successfully prepared, we do the following. 

We split the set of successfully prepared code-states $\ket{q_{2^{i_k}}}$ into groups, each containing $2^{i_{k+1} - i_k}$ copies of $\ket{q_{2^{i_k}}}$. We then attempt to prepare $\ket{q_{2^{i_{k+1}}}}$ by applying $B_{i_k \to i_{k+1}}$ on each group. 

\vspace*{0.6em}
Otherwise, if less than $2^{n - i_k}$ copies of $\ket{q_{2^{i_k}}}$ are successfully prepared, we declare a preparation failure and discard entirely the factory preparation.

\end{list}
\end{procedure}

\smallskip Note that after a scheduling recursion level $i_k$, we need to have at least $2^{n - i_k}$ copies of $\ket{q_{2^{i_k}}}$ to be able to prepare at least one copy of $\ket{q_{2^{n}}}$. Therefore, if the number of successfully prepared state is less than $2^{n - i_k}$, we discard the factory preparation. In other words, the factory preparation is successful if we have at least $2^{n - i_k}$ successfully prepared copies of $\ket{q_{2^{i_k}}}$, after all the scheduling recursion levels $i_k, 1 \leq k \leq |n_{sch}|$.

\smallskip Finally, note that for $n_{sch} = \{0, n\}$, the factory preparation corresponds to applying $B_{0 \to n}$, hence it is the same as the preparation~\cite[Procedure 1]{goswami2022fault} with error detection.

% $n_{\text{sch}}(i), i = 0, \dots, |n_{\text{sch}}|-1$\footnote{For the zeroth level of recursion, this condition is trivially satisfied if $T \geq 1$, as there is no error detection.}. At the end of a successful preparation, we may have several copies of $\ket{q_N}$.

  


%We then split $\mathcal{S}_T$ into groups of length $2^{n_{\text{sch}}(1)}$. Precisely, there will be $\frac{TN}{2^{n_{\text{sch}}(1)}}$ such groups, and we shall denote them as $\mathcal{S}^{i_1}_T$, where $i_1 = 1, \dots, \frac{TN}{2^{n_{\text{sch}}(1)}}$.

%
%\item[$(2)$] We then attempt to prepare $\pone$ code-states of length $2^{n_{\text{sch}}(1)}$ on each subset $\mathcal{S}^{i_1}_T$, by applying $B_{0 \to n_{\text{sch}}(1)}$. We discard all the groups, where an error is detected, and on the remaining groups, we have prepared $\ket{q_{2^{n_{\text{sch}}(1)}}}$. 
%
%
%\item[$(3)$] We then further split the successfully prepared states after step $(2)$ into groups, each containing $2^{n_{\text{sch}}(2)-n_{\text{sch}}(1)}$ copies of $\ket{q_{2^{n_{\text{sch}}(1)}}}$. Let $p$ be the number of successfully prepared state after step $(2)$, then there are $[p/2^{n_{\text{sch}}(2)-n_{\text{sch}}(1)}]$ such groups, where $[\cdot]$ denotes the integer part of a number. We denote these groups as $\mathcal{S}^{i_2}_T, i_2 = 1, \dots, [p/2^{n_{\text{sch}}(2)-n_{\text{sch}}(1)}]$. Note that to prepare $\ket{q_{2^n}}$, one needs $p$ to be at least $2^{n - n_{\text{sch}}{2}}$. Hence, if $p < 2^{n - n_{\text{sch}}(2)}$, we discard the factory preparation and may start it from the begining, that is, step $(1)$.
%
%\item[$(4)$] We attempt to prepare $\ket{q_{2^{n_{\text{sch}}(2)}}}$ on each group $\mathcal{S}^{i_2}_T$, by applying $B_{n_{\text{sch}}(1) \to n_{\text{sch}}(2)}$ on the $2^{n_{\text{sch}}(2)-n_{\text{sch}}(1)}$ copies of $\ket{q_{2^{n_{\text{sch}}(1)}}}$. 
%
%% supposing that preparation starts at the recursion level $k = \log_2 n_{\text{sch}}(1)$. 
%
%\item[$(5)$] We proceed similar to steps $(3)$ and $(4)$, until we reach at the last recursion level. More precisely, after a scheduling recursion level $n_{\text{sch}}(i-1)$, $i \geq 1$, if less than $2^{n - n_{\text{sch}}(i)}$ copies of $\ket{q_{2^{n_{\text{sch}}(i-1)}}}$ are produced, we discard the preparation. Otherwise if more than $2^{n - n_{\text{sch}}(i)}$ copies of $\ket{q_{2^{n_{\text{sch}}(i-1)}}}$ are produced, we do the following.
%
%We split the successfully prepared code-states $\ket{q_{2^{n_{\text{sch}}(i-1)}}}$ into groups, each containing $2^{n_{\text{sch}}(i)-n_{\text{sch}}(i-1)}$ copies of $\ket{q_{2^{n_{\text{sch}}(i-1)}}}$. We then attempt to prepare $\ket{q_{2^{n_{\text{sch}}(i)}}}$ by applying $B_{n_{\text{sch}}(i-1) \to n_{\text{sch}}(i)}$  on each group. 
%
%\smallskip At the end of preparation, $i.e.$, when $n_{\text{sch}}(i) = n$, we may have several copies of $\ket{q_N}$.
 


%Finally, note that when $T = 1$, the factory preparation is same as the preparation in~\cite[Procedure 2]{goswami2022fault} with $n_{sch} = \{1, \dots, n\}$ as even if error is detected in one of the $\pone$ code-states after the $i_k^{th}$ level of recursion, the number of successful states would be less than $2^{n - i_k}$, hence, we discard the preparation. 



%we gather all the successfully prepared copies of $\ket{q_{2^{n_{\text{sch}}(2)}}}$ and split them into several groups and prepare $\ket{q_{2^{n_{\text{sch}}(3)}}}$ by applying recursive Pauli measurements according to the binary string $b_{n_{\text{sch}}(1) + 1} \cdots b_{n_{\text{sch}}(2)}$. 

%\end{procedure}
%


%Note that if $n_{\text{sch}} = \{2^0, 2^1, \dots, 2^n\}$, the Procedure  stops at each level of recursion. Here, we have taken $n_{\text{sch}} \subseteq \{2^0, 2^1, \dots, 2^n\}$ for the sake of generality and also to be able to compare preparation rates with respect to different subsets.

%Another important quantity is output error probability, 
%Let for the $i^{th}$ prepared state, the 

%% Figure environment removed

% Figure environment removed

\subsection{Preparation rate and error probabilities of factory preparation}
Consider the factory preparation of $\ket{q_N}$ from Procedure~\ref{prot:fact_prep}, with respect to some $T \geq 1$ and $n_{\text{sch}} \subseteq \{1, \dots, n \}$.  Suppose we run the factory preparation $R$ times, successfully preparing $t_R \geq 0$ copies of $\ket{q_N}$ in total. Then, we define the preparation rate of the factory preparation, denoted by $p^{T, n_{\text{sch}}}_{\text{fact}}$, as follows,
%
\begin{equation} \label{eq:fact_prep}
p^{T, n_{\text{sch}}}_{\text{fact}} := \lim_{R \to \infty} \frac{t_R}{RT}.
\end{equation}

%{\color{blue} Comment: when $T$ is finite, we need to repeat the factory preparation several time to estimate preparation rate.}  


Note that for $T = 1$, $p^{T, n_{\text{sch}}}_{\text{fact}}$ is equal to $p_{\text{prep}}$ from (\ref{eq:prep_rate}), $i.e.$, the preparation rate of~\cite[Procedure 2]{goswami2022fault}. Another interesting case is when $T \to \infty$, for which we define,
\begin{equation} \label{eq:fact_prep_T}
p^{n_{\text{sch}}}_{\text{fact}} \eqdef \lim_{T \to \infty} p^{T, n_{\text{sch}}}_{\text{fact}}.
\end{equation}


\smallskip Let $\bm{e}^j_X, \bm{e}^j_Z \in \{0, 1\}^N$ be the $X$ and $Z$ errors, respectively, on the $j^{th} \in \{1, \dots, t_R\}$ successfully prepared state $\ket{q_N}$. Then, the average $X$ and $Z$ error probabilities, denoted respectively by $p^{prep}_X$ and $p^{prep}_Z$, are as follows
%
%We model the output $X$ and $Z$ errors as independent and identically distributed (\emph{i.i.d.}) noise, with their respective error probabilities $p^{prep}_X$ and $p^{prep}_Z$, as follows, 
%
\begin{align}
p^{prep}_X &=  \lim_{R \to \infty} \frac{1}{t_RN} \sum_{j=1}^{t_R} \wt(\bm{e}^j_X), \label{eq:avg_X} \\ 
p^{prep}_Z &= \lim_{R \to \infty} \frac{1}{t_RN} \sum_{j = 1}^{t_R} \wt(\bm{e}^j_Z), \label{eq:avg_Z} 
\end{align}
where $\wt(\bm{e}^j_X)$ is the Hamming weight of $\bm{e}^j_X \in \{0, 1\}^N$. From now on, we refer to $p^{prep}_X$ and $p^{prep}_Z$ as the $X$ and $Z$ \emph{preparation error probabilities}, respectively. The preparation error probabilities may be used to estimate the logical error rate of $\pone$ code under  Steane's error correction, with the help of the density evolution technique as in~\cite{goswami2022fault}.

%{\color{blue} The preparation error probabilities are needed to estimate the logical error rates, using the density evolution technique~\cite{goswami2022fault}.}


%{\color{blue} Comment: When $T \to \infty$, intuitively it seems we don't need $R \to \infty$, $i.e.$, $p^{T, n_{\text{sch}}}_{\text{fact}} = \lim_{T \to \infty} \frac{t_{R= 1}}{T}$. But I don't see an easy way to prove this.} 

\section{Theoretical estimates of preparation rate and error probabilities} \label{sec:estimates_theory}


%As discussed in Section~\ref{sec:prep-n}, the error detection gadget may not detect all the errors that has happened during the preparation, hence, some errors remain on the successfully prepared $\pone$ code states. 



%In this section, we provide for each component, the probability that failure of the component produces an error that would be detected. Further, we also provide the errors that would remain on the successfully prepared $\pone$ code states due to the failure instances of the component, producing an error, which goes undetected. Finally, using the above, we provide theoretical estimates for the preparation and output error rates.

In this section, we define the notions of rough and smooth\footnote{ The terms ``smooth" and ``rough" are used to distinguish $X$ and $Z$ boundaries in the topological quantum code literature. We emphasize that our definition is unrelated to the one used for topological codes.} errors for the measurement based preparation, and then using them, we provide theoretical estimates of the preparation rate $p_{prep}$ from~(\ref{eq:fact_prep_T}) and preparation error probabilities $p^{prep}_X$ and $p^{prep}_Z$ from~(\ref{eq:avg_X}) and~(\ref{eq:avg_Z}), respectively.

\subsection{Rough and smooth errors with respect to $B_{i \to j}$}
%Here, we define the notion of effective errors with respect to $B_{i \to j}$, and then provide the effective and non-effective errors produced by each component $C$ of $B_{i \to j}$. The relationship between the notion of effective error and error detection gadget is specified in Section~\ref{sec:succ_prob_Bij}. 
%\smallskip Here, we define effective errors in $B_{i \to j}$, and further provide the effective and non-effective errors produced by each component, \emph{i.e.}, initialization, measurement and $\cnot$ gates.

\smallskip Recall that $B_{i \to j} $ corresponds to the recursion levels $i+1, \dots, j$ of the measurement based procedure with respect to the binary string $b_{i+1}, \dots, b_{j}$, where $b_k = 0$ signifies a recursion level with Pauli $X \otimes X$ measurements and $b_k = 1$  a recursion level with Pauli $Z \otimes Z$ measurements. For $i = 0$, $B_{i \to j}$ also includes initialization in Pauli $Z$ basis at the zeroth level of recursion. Further, $B_{i \to j}$ takes as input $2^{j-i}$ copies of $\ket{q_{2^i}}$, and produces as output a copy of $\ket{q_{2^j}}$ if no error is detected. 

\smallskip Consider the set of data qubits $\mathcal{S}_{i \to j} \eqdef \{1, \dots, 2^{j}\}$ that are input to $B_{i \to j}$, and let $\mathcal{A}_{ i \to j} := \{1, \dots, 2^{j-1} \}$ be the set of ancilla qubits used to implement the Pauli $Z \otimes Z$ and Pauli $X \otimes X$ measurements in $B_{i \to j}$. Further, let $\mathcal{C}_{i \to j}$ be the set of all components corresponding to $B_{i \to j}$. Note that $\mathcal{C}_{i \to j}$ consists of $T_{i \to j} = \big(j - i\big) 2^{j-1}$ two qubit Pauli measurements. Therefore, it consists of $T_{i \to j}$ initializations and measurements of the ancilla qubits and $2T_{i \to j}$ $\cnot$ gates between the  data and ancilla qubits. If $i = 0$, it also has $2^j$ initializations in the Pauli $Z$ basis.



\medskip Any recursion level of $B_{i \to j}$ consists of the following four~\emph{time steps} (see also Fig.~\ref{fig:error_det_big}),

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}

\item[$(t = 1)$] The ancilla qubits in $\mathcal{A}_{ i \to j}$ are initialized in the Pauli $Z$ or $X$ basis.

\item[$(t = 2)$] The first $\cnot$ gate (corresponding to all Pauli  $X \otimes X$ or $Z \otimes Z$ measurements) are applied in parallel.

\item[$(t = 3)$] The second $\cnot$ gate (corresponding to all Pauli $X \otimes X$ or $Z \otimes Z$ measurements) are applied in parallel.

\item[$(t = 4)$] The ancilla qubits in $\mathcal{A}_{ i \to j}$ is measured in the Pauli $Z$ or $X$ basis.
 
\end{list}



%\smallskip An error on $\mathcal{S}_{i \to j}$ before  $k^{th}, i+1 \leq k \leq j$ recursion level of $B_{i \to j}$ could be due to the following two reasons,
%%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%\item[$(i)$] The preexisting error on the input qubit of $B_{i \to j}$ that remain undetected after $(k-1)^{th}$ level of recursion. If $i = 0$, the preexisting errors correspond to the errors that happen during initialization in Pauli $Z$ basis.
%
%\item[$(ii)$] The errors that happen due to component failures between $(i+1)$ and $(k-1)^{th}$ level of recursion, that remain undetected after $(k-1)^{th}$ level of recursion.
%
%\end{list}
%The errors on the quantum state corresponding to $\mathcal{S}_{i \to j}$ could be due to the following reasons,
%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%%
%\item[$(i)$] \textbf{Initialization errors:} The preexisting errors on the input of $B_{i \to j}$, which correspond to undetected errors during previous $B_{0 \to i}$.
%
%\item[$(i)$] \textbf{Faulty component error:} The errors that happen due to component failures between $(i+1)$ and $(k-1)^{th}$ levels of recursion.
%\end{list}
%%


%
%In the following, we estimate, taking both cases into account, the probability that an error is detected during $B_{i \to j}$, and as well as the errors that goes undetected, hence, remaining on the output of $B_{i \to j}$.

\smallskip We now define rough and smooth errors with respect to $B_{i \to j}$, as follows.
%
\begin{definition}[Rough and smooth errors] \label{def:eff_err}
Let $\ket{\psi_{i \to j}^{k,t}}$ be the quantum state corresponding to the joint system $\mathcal{S}_{i \to j} \cup \mathcal{A}_{i \to j}$, after a time step $t = 1, 2, 3, 4$ of the $k^{th}$ recursion level of $B_{i \to j}$ ($ i < k \leq j  $). We say a Pauli error $P_e$ acting on $\ket{\psi_{i \to j}^{k,t}}$ is a rough error if it satisfies the following two conditions:
%
%
%following two conditions are satisfied,
%
% an error, with support on $s > 0$ qubits, happens after a recursion level $k, i \leq k \leq j$. We say that the error is an effective error with respect to $B_{i \to j}$ if it satisfies the following two criteria,
%
\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}

\item[$(C.1)$] It is a non-trivial error in the sense that it not a stabilizer of the quantum state $\ket{\psi_{i \to j}^{k,t}}$,

\item[$(C.2)$] It flips the outcome of at least one single qubit Pauli $Z$ or $X$ measurement at a recursion level $ k', k \leq k' \leq j $.

\end{list}
Further, we say that $P_e$ is a smooth error if it satisfies the above condition $(C.1)$, however it does not satisfy the condition $(C.2)$.
\end{definition}


\smallskip  The condition $(C.2)$ of Definition~\ref{def:eff_err} is illustrated in Fig.~\ref{fig:error_det_big} for $B_{0 \to 3}$, where the error $P_e = X \otimes Z$ happens at $k = 2, t= 2$. Recall that an $X$ error propagates through the control of a $\cnot$ to its target, while it simply passes through the target. An $Z$ error propagates through the target of a $\cnot$ gate to its control, while it simply passes through the control. Further, an error flips the outcome of a Pauli measurement if they anti-commute with each other. The error $P_e$ in Fig.~\ref{fig:error_det_big}, consisting of an $X$ error on the first data qubit and a $Z$ error on the first ancilla qubit, flips the outcome of an $X$ measurement at $k=3, t = 4$. Since $p_e$ is not a stabilizer of $\ket{\psi_{0 \to 3}^{2,2}}$, it corresponds to a rough error.

The rough and smooth errors are related with the error detection gadget as follows. An error is detected only if it flips the outcome of at least one measurement. Hence, roughness is a necessary condition for error detection. However, it is not a sufficient condition as an error of large weight may flip several measurement outcomes and the error detection is limited by the minimum distance of the classical code. Nevertheless, due to recursive nature of the preparation procedure, for an error to survive it should not be detected at any of the recursion levels that follow. Therefore, we expect that the rough errors will go undetected with small probabilities.  This justifies the following assumption that we make for the estimation of the preparation rate and preparation error probabilities. 
%

\begin{assumption} \label{ass:err_det}
Any rough error on the quantum state $\ket{\psi^{k,t}_{i \to j}}, i < k \leq j, t = 1, 2, 3,4$, is detected by the error detection gadget at one of the recursion levels $k, \dots, j$.
\end{assumption}
%Similarly, a smooth error would not be detected at any recursion level of $B_{i \to j}$.

 

%Therefore, we have used 


%Hence, we below provide approximations of preparation rate and preparation error probabilities, using the rough and smooth errors (see Assumption~\ref{ass:err_det}).


%({\color{blue} This has been further validated by numerical simulation)}

%In Figure~\ref{fig:error_det_big}, the error $X \otimes Z$ happens in the $\cnot$ gate applied at the recursion level $t = 1, k = 2$, during a Pauli $Z \otimes Z$ measurement. This error doesn't flip the measurement outcome of the corresponding $Z \otimes Z$ measurement, however, it flips the measurement outcome of a Pauli $X \otimes X$ measurement at the next recursion level. 
%
% Figure environment removed
%Hence, for the sake of simplicity, we may assume the following.
%
%\smallskip We now define \emph{effective error probability} and \emph{non-effective noise channel} for each component in $\mathcal{C}_{i \to j}$.
%
We will further use the rough error probability and smooth error channel, defined below.
%We, now provide the probability that a component in $B_{i \to j}$ produces a rough error, and also the quantum channel on the output of $B_{i \to j}$, due to the smooth errors produced by the component. We first formally define rough error probability.


\begin{definition}[Rough error probability] 
We define the rough error probability for a component $C \in \mathcal{C}_{i \to j}$, as the probability that $C$ produces a rough error in $B_{i \to j}$.
\end{definition} 
%denoted by $p^C_D$,
Considering Assumption~\ref{ass:err_det}, the error that remains on the output of $B_{i \to j}$, when no error is detected, is due to the smooth errors. We  define below the smooth error channel corresponding to a component. 
%
\begin{definition}[Smooth error channel] 
Let $L(H_{\mathcal{S}_{ i \to j}})$ be the set of linear operators acting on $H_{\mathcal{S}_{ i \to j}}$, the Hilbert space corresponding to $\mathcal{S}_{ i \to j}$. Then, we define the smooth error channel corresponding to a component $C \in \mathcal{C}_{i \to j}$, denoted by $\mathcal{W}_C: L(H_{\mathcal{S}_{ i \to j}}) \to L(H_{\mathcal{S}_{ i \to j}})$, as the channel that acts on the output quantum state of $B_{i \to j}$, due to the smooth errors produced by the faults in $C$. 
\end{definition} 
%
In the following, we denote by $p_C$ and $\mathcal{W}_C$, the rough error probability and the smooth error channel associated with a component $C$, respectively. We further define $k^{\min}_{i \to j}$, as follows,
%
%, the smallest recursion level in $i + 1 \leq k_{\text{min}} < j$, satisfying $b_{i'} = b_j, \forall k^{\min}_{i \to j} < i' \leq j$, where $b \in \{0, 1\}$ is a fixed value. 
%
\begin{equation}
k^{\min}_{i \to j} := \min \big\{ k \in \{i+1, \dots, j-1\} \mid b_{i'} = b_j, \forall k < i' \leq j \big\}. 
\end{equation}
%
In other words, $k^{\min}_{i \to j}$ is the minimum value in $\{i+1, \dots, j-1\}$, so that the recursion levels of $B_{i \to j}$ after $k^{\min}_{i \to j}$ consists of only one type of two qubit Pauli measurements, given by the value of $b_j$. 

%Note that if $k^{\min}_{i \to j} = i + 1$ and $b_{i+1} = b_j$, $B_{i \to j}$ entirely consists of only one type of two qubit Pauli measurements. Finally, we denote by $I_{\mathcal{S}} \in L(H_{\mathcal{S}})$, the identity operator on $H_{\mathcal{S}}$.
%

\smallskip We provide below $p_C$ and $\mathcal{W}_C$ for the initialization of data qubits (Lemma~\ref{lem:int-eff-err}), initialization and measurement of ancila qubits (Lemma~\ref{lem:p-w-int-m}), and CNOT gates (Lemma~\ref{lem:p-w-cnot}), considering the circuit level depolarizing noise model from Section~\ref{sec:prep-n}, with the physical error rate $p$. The proofs of lemmas are given in Appendix~\ref{app:proof-lemmas}. 
%
\begin{lemma} \label{lem:int-eff-err}
Consider the recursion levels corresponding to $B_{0 \to j}, j > 0$ and let $C$ be an initialization component on a data qubit $q \in \mathcal{S}_{0 \to j}$, at the zeroth level of recursion. Then, $p_C$ and $\mathcal{W}_C$ are as follows,
%
\begin{equation} \label{eq:eff_int_zero}
p_C = \begin{cases}
0, & \text{ if $\sum_{t=1}^j b_t = 0$. } \\
p, & \text{ otherwise. }
\end{cases}
\end{equation}
%
\begin{equation} \label{eq:non_eff_int_zero}
\mathcal{W}_C = \begin{cases}
I_{\mathcal{S}_{0 \to j} \setminus {q} } \otimes  \mathcal{B}_{q}^{p},  & \text{ if $\sum_{t=1}^j b_t = 0$.} \\
I_{\mathcal{S}_{0 \to j}}, & \text{ otherwise, }
\end{cases}
\end{equation}
where $\mathcal{B}_{q}^{(p)}$ is a bit-flip channel, acting on $q$ with the error probability $p$, i.e., $\mathcal{B}_{q}^{(p)}(\rho) := (1 - p) \rho + p X \rho X$.


\end{lemma}



\begin{lemma} \label{lem:p-w-int-m}
For an initialization and measurement component on an ancilla qubit in $\mathcal{A}_{i \to j}, 0 \leq i < j$, we have the following,
\begin{align}
p_C &= p. \label{eq:eff_measurement}\\
\mathcal{W}_C &= I_{\mathcal{S}_{i \to j}}.
\end{align} 
\end{lemma}
%
\begin{lemma} \label{lem:p-w-cnot}
Consider a $\cnot_{q \to a}$ on the $k^{th}$ recursion level of $B_{i \to j}, 0 \leq i  < k \leq j$, acting between a data qubit $q \in \mathcal{S}_{i \to j}$ and an ancilla qubit $a \in \mathcal{A}_{i \to j} $. Then,  depending on $k$, $p_C$  is as follows. 
%
\begin{equation} \label{eq:eff_err_cnot}
 p_C = \begin{cases}
 8p/15, & \text{ if $k =  j$. }  \\
 4p/5, & \text{ if $  k^{\min}_{i \to j} \leq k <  j$.} \\
 14p/15, & \text{ otherwise.} \\
\end{cases}
\end{equation}
%
Further, $\mathcal{W}_C = I_{\mathcal{S}_{i \to j} \setminus {q}} \otimes \mathcal{W}_q$, where $\mathcal{W}_q$ is a quantum channel acting on $q$ as follows, 
\begin{equation} \label{eq:eff_noise_cnot}
\mathcal{W}_q = \begin{cases}
\mathcal{D}_{q}^{(6p/15)}, & \text{ if $k =  j$ }  \\
 \mathcal{B}_{q}^{(2p/15)}, & \text{ if $k^{\min}_{i \to j} \leq k <  j$, and $b_j = 0$.} \\
  \mathcal{P}_{q}^{(2p/15)}, & \text{if $k^{\min}_{i \to j} \leq k < j$, and $b_j = 1$.} \\
 I_{\mathcal{S}_{i \to j}}, & \text{ otherwise,} \\
\end{cases}
\end{equation}
where $\mathcal{D}_{q}^{(p)}$ is a depolarizing channel, acting on $q$ with error probability $p$ as 
$\mathcal{D}_{q}^{(p)}(\rho) := (1 - p) \rho + \frac{p}{3} (X \rho X + Y \rho Y + Z \rho Z)$, $\mathcal{B}_{q}^{(p)}$ is a bit-flip channel, acting on $q$ with the error probability $p$ as $\mathcal{B}_{q}^{(p)}(\rho) := (1 - p) \rho + p X \rho X$, and $\mathcal{P}_{q}^{(p)}$ is a phase-flip channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p Z \rho Z$.
\end{lemma}


\subsection{The success probability of $B_{i \to j}$} \label{sec:succ_prob_Bij}


%In this section, using rough and smooth errors, we estimate the success probability of $B_{i \to j}$, \emph{i.e.}, the probability that no errors are detected during $B_{i \to j}$. 
Considering  Assumption~\ref{ass:err_det}, the success probability of $B_{i \to j}$ corresponds to the probability that a rough error is not produced at any of the recursion levels in $B_{i \to j}$. In this regard, we consider the following two cases: %Let $\mathcal{E}_{k,t}$ be the set of all possible Pauli errors on $\ket{\psi^{k,t}_{i \to j}}$. We may divide a possible error $P_e \in \mathcal{E}_{k,t}$ into the following two parts,
%
\begin{list}{}{\setlength{\labelwidth}{1em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
\item[$(1)$] The component failures at the previous recursion levels, $\emph{i.e.}$, $B_{0 \to i}$, producing smooth errors with respect to $B_{0 \to i}$.

%
\item[$(2)$] The component failures at one of the recursion levels corresponding to $B_{i \to j}$.

\end{list}
%
%Let $p^{(e)}$ be the probability that the error $P_e$ is not a rough error. We may the approximate $p^{(e)}$ as follows,
%\begin{equation}
%p^{(e)}  \approx p^{(e_1)} p^{(e_2)}.
%\end{equation}
%
Let $p^{(1)}$ and $p^{(2)}$ be the probability that a rough error with respect to $B_{i \to j}$ is not produced due to Point $(1)$ and Point $(2)$, respectively. In the following, we give approximations of $p^{(1)}$ and $p^{(2)}$, using which we may approximate the success probability of $B_{i \to j}$.


%the probability that  errors in Points $(1)$ and $(2)$ above are not rough errors, denoted by $P^{(1)}$ and $P^{(2)}$, respectively, using which we then approximate the success probability of $B_{i \to j}$.



%To compute the success probability of $B_{i \to j}$, we need to determine the probability that errors in $\mathcal{E} \eqdef \cup_{i+ 1 \leq k \leq j, t = 1, 2, 3, 4}  \mathcal{E}_{k,t}$ are smooth with respect to $B_{ i \to j}$. We may divide 

\medskip We first consider Point $(2)$. We may approximate $p^{(2)}$ directly from Lemmas~\ref{lem:int-eff-err},~\ref{lem:p-w-int-m} and~\ref{lem:p-w-cnot}, as follows,
%
%The probability that a rough error is not produced  due to Point $(2)$, denoted by $P^{(2)}$, can be approximated as follows, using Lemmas~\ref{lem:p-w-int-m} and~\ref{lem:p-w-cnot}\footnote{Recall $p_C$ is the rough error probability associated with $C$.},
\begin{equation} \label{eq:p_success_ii}
p^{(2)}  \approx \prod_{C \in \mathcal{C}_{i \to j}}(1-p_C).
\end{equation}
%
Recall that $p_C$ is the rough error probability associated with the component $C$. We have the following remark.

\begin{remark} \label{rem:rough-smooth-err}
We note that the total error produced by component failures in a set $\mathcal{C}' \subseteq \mathcal{C}_{i \to j}$ (containing two or more components, \emph{i.e.}, $|\mathcal{C}'| \geq 2$) can be a smooth error, even though individual component failures in $\mathcal{C}'$  produce rough errors (see Fig.~\ref{fig:rough-smooth}).  To get the actual value of $p^{(2)}$, we need to add in the right-hand side (RHS) of~(\ref{eq:p_success_ii}), the probabilities of the events for all the subsets $\mathcal{C}'  \subseteq \mathcal{C}_{i \to j}, |\mathcal{C}'| \geq 2$, where each component in $\mathcal{C}'$ produces a rough error individually but the total error is a smooth error. As the probability of such an event is upper bounded by $\prod_{C \in \mathcal{C}'} p_C$, we expect the RHS in~(\ref{eq:p_success_ii}) to be a good lower bound of $p^{(2)}$. 
\end{remark}


% Figure environment removed


\smallskip In the next paragraph, we give an approximation of $p^{(1)}$.
\paragraph{Rough error probability due to previous recursion levels.}

We first estimate the errors that remain on the input of $B_{i \to j}$ due to the smooth errors in previous recursion levels, \emph{i.e.}, $B_{0 \to i}$. We then estimate the probability that this remaining error is a rough error with respect to $B_{i \to j}$ (hence, giving an estimate of $p^{(1)}$).

%We first give an approximation of the noise channel acting on the output of $B_{0 \to i}$ due to smooth errors in $B_{0 \to i}$. We then determine the probability that this noise channel produces a rough error in $B_{i \to j}$.

\smallskip To estimate the remaining error on the input of $B_{i \to j}$,  we simply concatenate the smooth error channels corresponding to components in $\mathcal{C}_{0 \to i}$. The resulting channel after concatenation is a Pauli channel as given in Lemma~\ref{lem:smooth_total_channel}, which is proven in Appendix~\ref{app:proof-lemmas}.
%
%that act on a data qubit. Note from Lemma~\ref{lem:p-w-int-m}, the non-effective channel due to the initialization and measurement errors on an ancilla qubit in $\mathcal{A}_{0 \to i}$ is equal to indentity. Hence, we only need to consider non-effective channels due to initialization at the zeroth level of recursion, and the $\cnot$ gates in $\mathcal{C}_{0 \to j}$. 
%
%From assumption~\ref{ass:err_det}, the errors that are left on the output of $B_{0 \to i}$ are due to the non-effective errors. Hence, using the non-effective channels given in Lemmas~\ref{lem:int-eff-err},~\ref{lem:p-w-int-m}, and~\ref{lem:p-w-cnot}, we can determine the remaining errors on the output of $B_{0 \to i}$. 

\begin{lemma} \label{lem:smooth_total_channel}
Let $\mathcal{W}_{0 \to i}: L(H_{\mathcal{S}_{0 \to i}}) \to L(H_{\mathcal{S}_{0 \to i}})$ be the quantum channel that corresponds to the concatenation of smooth error channels for all $C \in \mathcal{C}_{0 \to i}$, i.e., $\mathcal{W}_{0 \to i} =  \mathcal{W}_{C_1} \circ \dots \circ \mathcal{W}_{C_{|\mathcal{C}_{0 \to i}|}}$. Then, $\mathcal{W}_{0 \to i} = \otimes_{q \in \mathcal{S}_{0 \to i}} \mathcal{W}_q$ (i.e., $\mathcal{W}_{0 \to i}$ acts independently and identically on qubits in $\mathcal{S}_{0 \to i}$), where $\mathcal{W}_q$ is a Pauli channel, whose $X$, $Y$ and $Z$ error probabilities are, respectively, upper bounded by $p^{0 \to i}_x, p^{0 \to i}_y$ and $p^{0 \to i}_z$, which are as follows,
%
\begin{align}
p^{0 \to i}_x &= \begin{cases}
1- (1-p)(1 - 2p/15)^{i} , & \text{if $\sum_{t=1}^i b_t = 0$.} \\
1-(1 - 2p/15)^{(i - k^{\min}_{0 \to i})+1}, & \text{if $\sum_{t=1}^i b_t \neq 0$, and $b_i = 0$.}  \\
2p/15, & \text{if $b_i = 1$.} 
\end{cases} \label{eq:prep_err_x}\\
p^{0 \to i}_y &= 2p/15. \label{eq:prep_err_y}  \\
p^{0 \to i}_z &= \begin{cases}
2p/15, & \text{if  $b_i = 0$.} \\
1-(1 - 2p/15)^{(i - k^{\min}_{0 \to i})+1}, & \text{if $b_i = 1$.} 
\end{cases} \label{eq:prep_err_z} 
\end{align}
\end{lemma}
%

\smallskip As explained in Remark~\ref{rem:rough-smooth-err} and Fig.~\ref{fig:rough-smooth}, a set of component failures may produce a smooth error even though individual component failures produce rough errors. Such smooth errors are not taken into account in Lemma~\ref{lem:smooth_total_channel}, therefore, the channel $\mathcal{W}_{0 \to i}$ therein underestimates the actual errors on the output of $B_{0 \to i}$. However, as the probability of such an event is exponentially small in the number of component failures, we expect $\mathcal{W}_{0 \to i}$ approximates well the actual channel acting on the output of $B_{0 \to i}$.


%(This has been further validated by numerical simulations in Section~\ref{sec:num-res}).


%Hence, the probabilities in~(\ref{eq:prep_err_x}),~(\ref{eq:prep_err_y}) and ~(\ref{eq:prep_err_z}) are lower bounds on actual $X$

We now estimate the probability that the channel $\mathcal{W}_{0 \to i}$ in Lemma~\ref{lem:smooth_total_channel} produces a rough error with respect to $B_{i \to j}$. Note that an $X$ (or $Z$) error on the qubit $q \in \mathcal{S}_{i \to j}$ at the input of $B_{i \to j}$, will flip the measurement outcome of the next Pauli $Z \otimes Z$ (or $X \otimes X$) measurement. Therefore, using~(\ref{eq:prep_err_x}),~(\ref{eq:prep_err_y}), and~(\ref{eq:prep_err_z}), the probability of preexisting error on a qubit $q$ to be rough in $B_{i \to j}$ is upper bounded as,
\begin{equation} \label{eq:p_D_pre}
p_{\text{pre}} = \begin{cases}
p^{0 \to i}_y + p^{0 \to i}_z, & \text{ if $\sum_{t={i+1}}^j b_t = 0$.} \\
p^{0 \to i}_x + p^{0 \to i}_y, & \text{ if $\sum_{t={i+1}}^j b_t = j-i$.} \\
p^{0 \to i}_x + p^{0 \to i}_y + p^{0 \to i}_z, & \text{otherwise}.
\end{cases}
\end{equation}
%
%Therefore, the probability that no effective error happens due to preexisting errors is given by $(1 - P^{pre}_D)^{2^j}$ (note that there are $2^j$ qubits in $\mathcal{S}_{i \to j}$), Therefore the probability that the effective error does not happen on $\ket{\psi_{i \to j}}$
%
Using~(\ref{eq:p_D_pre}) and the fact that there are $2^j$ qubits in $\mathcal{S}_{i \to j}$, the probability that the preexisting errors  do not produce a rough error with respect to $B_{i \to j}$ is given by,
%
\begin{equation} \label{eq:p_success_i}
p^{(1)} \approx (1-p_{\text{pre}})^{2^j}.
\end{equation}
%
Note that~(\ref{eq:p_success_i}) is an approximation due to the fact that several individual rough errors may be one smooth error when considered together, as previously explained.

\medskip Finally, from~(\ref{eq:p_success_i}) and~(\ref{eq:p_success_ii}), the probability that no-rough error happens in $B_{i \to j}$ (in other words, the success probability of $B_{i \to j}$ using Assumption~\ref{ass:err_det}) can be approximated as follows,
\begin{equation} \label{eq:p_success}
p^s_{i \to j} \approx (1-p_{\text{pre}})^{2^j} \prod_{C \in \mathcal{C}_{i \to j}}(1-p_C).
\end{equation}

%\paragraph{Effective error probability due to the component failures in $B_{i \to j}$.}
%
%
%
%
%
%
%
%
%
%
%
%Let $k^{\min}_{i \to j}$ be the smallest recursion level in $i-1 \leq k_{\text{min}} < j-1$ satisfying $b_{i'} = b, \forall k_{\text{min}} < i' < i$, for a fixed value $b \in \{0, 1\}$. In other words, recursion levels after $k$, consists of only one type of two qubit Pauli meauserments.
%
%%The initialization error at zeroth level on a qubit $q \in \mathcal{S}_{0 \to A}$ produces only $X$ error, which would flip at least one measurement outcome if there is a rescursion level with  
%
%From Lemma~\ref{lem:int-eff-err}, the non-effective channel corresponding to the initialization error at the zeroth level of recursion on each qubit $q \in \mathcal{S}_{0 \to i}$ is as follows.
%
%\begin{equation} \label{eq:non_eff_int_zero}
%W_D^C = \begin{cases}
%I_{\mathcal{S}_{0 \to j} \setminus {q} } \otimes  \mathcal{B}_{q}^{p} , & \text{ if $k^{\min}_{0 \to i} = 0$ and $b = 0$. } \\
%I_{\mathcal{S}_{0 \to j}}, & \text{ otherwise }
%\end{cases}
%\end{equation}
%
%%The preexisting errors on the inputs of $B_{i \to j}$ corresponds to the remaining errors on the output of the previous recursion levels $B_{0 \to i}$. In the following lemma, we provide the noise channel that acts on the output of $B_{0 \to i}$.
%
%
%\begin{lemma} \label{lem:prep_err}
%Consider the recursion levels corresponding to $B_{0 \to i}$. Let $k_{\text{min}}$ be the smallest recursion level such in $1 \leq k_{\text{min}} \leq i-1$ satisfying $b_{i'} = b, \forall k_{\text{min}} < i' < i$, for a fixed value $b \in \{0, 1\}$. Then considering Assumption~\ref{ass:error_det}, the noise channel on the output of $B_{0 \to i}$ is an $i.i.d.$ Pauli noise, with $X$, $Y$, and $Z$ error probabilities as follows,
%%
%\begin{equation}
%p^{0 \to i}_x = \begin{cases}
%1- (1 - 2p/15)^2 (1-p), & \text{ if $b = 0$, $k_{\text{min}} = i + 1$. } \\
%1- (1 - 2p/15)^2, & \text{ if $b = 0$, $k_{\text{min}} > i + 1$. } \\
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%%
%\begin{equation}
%p^{0 \to i}_y = 1- (1 - 2p/15)^2.
%\end{equation}
%%
%\begin{equation}
%p^{0 \to i}_z = \begin{cases}
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 0$. } \\
%1- (1 - 2p/15)^2, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%
%\end{lemma}
%%
%
%%
%
% 
%
%Note that if $k_{min}^{i \to j} > i + 1$, this means  $B_{i \to j}$  consists of both Pauli $Z \otimes Z$ and $X \otimes X$ measurements. Hence, both $X$ and $Z$ preexisting errors on the qubit $q \in \mathcal{S}_{i \to j}$, will flip the measurement outcome of at least one Pauli $Z \otimes Z$ and $X \otimes X$, respectively. Hence, in this case, preexisting error is an effective error. Hence, probability that no effective preexising error happens on the input of $B_{i \to j}$ is given by, $(1-p^{pre}_D)^{2^j}$.
%
%\smallskip Further, let $i$, $\cnot$ and $m$ denote a single qubit initialization in Pauli basis, $\cnot$ gate and single qubit measurement in Pauli basis, belonging to the set of components $\mathcal{C}_{i \to j}$. The probability that no effective fault happens is given by, $\prod_{i, \cnot, m \in \mathcal{C}_{i \to j}} (1-p_D^{i}) (1-p_D^{\cnot}) (1-p_D^{m})$, where $p_D^{i}, p_D^{m}$ are according to~(\ref{lem:p-w-int-m}) and $p_D^{\cnot}$ is according to~(\ref{eq:det_prob_cnot}).
%
%\smallskip  Hence, the probability that no effective error happens during $B_{i \to j}$, is given by,
%\begin{equation} \label{eq:p_success}
%P_{\text{noeff}} = (1-p^{pre}_D)^{2^j} \prod_{i, \cnot, m \in \mathcal{C}_{i \to j}} (1-p_D^{i}) (1-p_D^{\cnot}) (1-p_D^{m}).
%\end{equation}
%%
%As mentioned before, the error $P_{\text{noeff}}$ is our estimate of the success probability of $B_{i \to j}$.
%%From Lemma~3, we have a Pauli channel acting on each input qubit of $B_{i \to j}$. Therefore,  we may treat this Pauli channel as an error caused by the initialization component on the corresponding qubit.
%%
%%
%% and the probability of the initialization component to be effective with respect to $B_{i \to j}$ can be computed similar to Lemma~\ref{}, that is,
%%
%%Hence, the probability that at no effective fault happens at the input of $B_{i \to j}$ is given by,
%
%%Further, let $i$, $\cnot$ and $m$ denote a single qubit initialization in Pauli basis, $\cnot$ gate and single qubit measurement in Pauli basis, belonging to the set of components $\mathcal{C}_{i \to j}$. The probability that no effective fault happens is given by,
%%\begin{equation}
%%P_2 = \prod_{i, \cnot, m \in \mathcal{C}_{i \to j}} (1-p_D^{i}) (1-p_D^{\cnot}) (1-p_D^{m}),
%%\end{equation}


\subsection{Preparation rate of the factory preparation} \label{sec:fact-prep-rate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Using~(\ref{eq:p_success}), we now estimate the preparation rate for the asymptotically large factory size, that is, $T \to \infty$ as in~(\ref{eq:fact_prep_T}). Suppose after the $i_k^{th}, i_k \in n_{sch}$ scheduling recursion level, we have total $T_{i_k}$ successfully prepared $\pone$ code-states of length $2^{i_k}$. As in Procedure~\ref{prot:fact_prep}, we split successfully prepared code-states into $[T_{i_k}/(2^{i_{k+1} -i_k})]$ groups, each group containing $2^{i_{k+1} - i_k}$ code-states. We then apply $B_{i_k \to i_{k+1}}$ on each group to prepare $\pone$ code-states of length $2^{i_{k+1}}$. Using~(\ref{eq:p_success}) and the law of large numbers, we may estimate the number of prepared state after $B_{i_k \to i_{k+1}}$ as follows, 
\begin{equation} 
T_{i_{k + 1}} \approx [T_{i_k}/(2^{i_{k+1} - i_k})] p^s_{i_k \to i_{k+1}}. \label{eq:num_succ}
\end{equation}
Using~(\ref{eq:num_succ}), we have,
\begin{equation} \label{eq:num_succ1}
p^s_{i_k \to i_{k+1}} \approx \frac{T_{i_{k + 1}}  (2^{i_{k+1} - i_k})}{T_{i_k}}. 
\end{equation}
Further, applying~(\ref{eq:num_succ1}) recursively, we may get an estimate of the preparation rate in~(\ref{eq:fact_prep_T}), as follows (we take $i_0 = 0$ and recall $i_{|n_{sch}|} = n$),
\begin{align}
 p^{n_{sch}}_{\text{fact}} & = \frac{T_{i_{|n_{sch}|}}}{T} \\
& = \displaystyle\prod_{k = 0}^{i_{|n_{sch}| - 1}}  \frac{T_{i_{k+1}} (2^{i_{k+1} - i_k})}{T_{i_k}} \\
& \approx \displaystyle\prod_{k = 0}^{i_{|n_{sch}|} - 1} p^s_{i_k \to i_{k+1}}, \label{eq:ratio_int}
\end{align}
where we have used $T_{i_0} = T_0 = NT$ in the second equality, and approximation in the last line follows from~(\ref{eq:num_succ1}). Therefore, from~(\ref{eq:ratio_int}), the factory preparation rate for $T \to \infty$ is simply multiplication of the success probabilities of the blocks $B_{i_k \to i_{k+1}}$, $ k = 0, \dots, i_{|n_{sch}|}-1$. Further, from~(\ref{eq:p_success}) and~(\ref{eq:ratio_int}), we may roughly see as follows why factory preparation may improve the preparation rate compared to preparation in~\cite{goswami2022fault}. As noted before, preparation in~\cite{goswami2022fault} corresponds to $n_{sch} = \{0, n\}$, for which we get $  p^{n_{sch}}_{\text{fact}} \approx  p^s_{0 \to n}$ from~(\ref{eq:ratio_int}). Further from~(\ref{eq:p_success}), for $p^s_{0 \to n}$, we need to consider components in the set $\mathcal{C}_{0 \to n}$ for error detection, while for $\prod_{k = 0}^{i_{|n_{sch}|} - 1} p^s_{i_k \to i_{k+1}}$ corresponding to a $n_{sch} = \{ i_0, \dots, i_k, \dots, i_{|n_{sch}|} \} \supset \{0, n\}$, we need to consider components in the smaller set $\mathcal{C}_{0 \to i_1} \cup \cdots \cup \mathcal{C}_{i_{k-1} \to i_k} \cup \mathcal{C}_{i_k \to i_{k+1}} \dots \cup \mathcal{C}_{i_{|n_{sch}|-1} \to i_{|n_{sch}|}} \subset \mathcal{C}_{0 \to n}$. 
 


%Substituting $T_0 = NT$ in~(\ref{eq:ratio_int}), we have that
%Applying~(\ref{eq:num_succ}) recursively with $T_0 = NT$, we may get an estimate of the $T_n$ for the last scheduling recursion level. Then, the preparation rate is simply given by,
%\begin{equation}
%p^{n_{sch}}_{\text{fact}} = T_n/T. 
%\end{equation}



\subsection{Preparation error probabilities of the factory preparation}
The remaining error on the final prepared state is due to the smooth errors in $B_{0 \to n}$, hence given by the quantum channel $\mathcal{W}_{0 \to n}$ as in Lemma~\ref{lem:smooth_total_channel}. The action of $\mathcal{W}_{0 \to n}$ on each qubit $q \in \mathcal{S}_{0 \to j}$ corresponds to the Pauli channel, with the $X, Y$, and $Z$ error probabilities $p_x^{0 \to n}, p_y^{0 \to n}$, and  $p_x^{0 \to n}$ according to~(\ref{eq:prep_err_x}),~(\ref{eq:prep_err_y}),
and~(\ref{eq:prep_err_z}), respectively. Therefore, the preparation $X$ and $Z$ error probabilities in~(\ref{eq:avg_X}) and~(\ref{eq:avg_Z}), respectively, are given by,
\begin{align}
p_X^{prep} &= p_x^{0 \to n} + p_y^{0 \to n}. \label{eq:prep_x_erate}\\
p_Z^{prep} &= p_y^{0 \to n} + p_z^{0 \to n}. \label{eq:prep_z_erate}
\end{align}




%\subsection{Effective Faults}
%
%\smallskip We consider the noise model given in Section~\ref{sec:prep-n} and define effective faults in $B_{i \to j}$ as follows.
%
%\begin{definition}[Effective fault] \label{def:err-det}
%Suppose $C \in \mathcal{C}_{i \to j}$ is the only component that fails during $B_{i \to j}$. We say that the corresponding fault is an effective fault, if the error produced by the fault satisfies the following two criterions,
%%
%%
%%following two conditions are satisfied,
%%
%% an error, with support on $s > 0$ qubits, happens after a recursion level $k, i \leq k \leq j$. We say that the error is an effective error with respect to $B_{i \to j}$ if it satisfies the following two criteria,
%%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%
%\item[$(1)$] It does not correspond to a stabilizer of the quantum state it acts on.
%
%\item[$(2)$] It flips the outcome of at least one single qubit Pauli $Z$ or $X$ measurement in $B_{i \to j}$.
%
%\end{list}
%\end{definition}
%
%
%
%
%
%\smallskip  The second point of Definition~\ref{def:err-det} is illustrated in Fig.~\ref{fig:error_det_big} for $B_{0 \to 3}$ corresponding to the string $101$. Recall that an $X$ error propagates through the control of a $\cnot$ to its target, while it simply passes through a target. An $Z$ error propagates through the target of a $\cnot$ gate to its control, while it simply passes through the control. Further, an error flips the outcome of a Pauli measurement if they anti-commute with each other.
%
%
%\smallskip We now define \emph{detection error probability} and \emph{effective noise channel} for each component in $\mathcal{C}_{i \to j}$.
%
%
%
%
%\begin{definition}[Effective probability and non-effective noise channel] 
%Then, we define the detection probability for $C \in \mathcal{C}_{i \to j}$, denoted by $p^C_D$, as the probability that $C$ produces an effective fault.
%
%Further, we define the non-effective noise channel corresponding to $C$, denoted by $\mathcal{W}_C: L(\mathcal{S}_{ i \to j}) \to L(\mathcal{S}_{ i \to j})$, with $L(\mathcal{S}_{ i \to j})$ being the set of linear operators acting on the Hilbert space corresponding to $\mathcal{S}_{ i \to j}$, as the channel that acts on the output quantum state of $B_{i \to j}$, due to the non-effective faults in $C$. 
%
%
%%the error detection gadget detects an error at some recursion level in $B_{i \to j)}$, given that $C$ fails. 
%
%%Consider the cases, where an error is not detected by the gadget at any recursion level, given that only $C$ failed (This happens with probability $1 - p^C_D$). 
%\end{definition} 
%
%In Lemma~\ref{lem:p-w-int-m} and~\ref{lem:p-w-cnot}, which are proven in Appendix~\ref{app:proof-lemmas}, we provide $p^C_D$ and $W_C$ for $C \in \mathcal{C}_{i \to j}$.
%
%\begin{lemma} \label{lem:p-w-int-m}
%For an initialization and measurement component on a ancilla qubit $A$ during $B_{i \to j}$, we have the following,
%\begin{align}
%p_C &= 1. \\
%\mathcal{W}_C &= I_{S \to A}.
%\end{align} 
%\end{lemma}
%%
%\begin{lemma} \label{lem:p-w-cnot}
%Consider a $\cnot_{q \to A}$, during $B_{i \to j}$, acting between a data qubit $q \in \mathcal{S}_{i \to j}$ and the ancilla qubit $A$ on the $k^{th}$ recursion level. Then, $p_C$, depending on $k$,  is as follows. 
%%
%\begin{equation} \label{eq:det_prob_cnot}
% p^C_{D} = \begin{cases}
% 8p/15, & \text{ if $k =  j$. }  \\
% 4p/5, & \text{ if $k <  j$, and $b_i = 0, \forall k < i \leq  j $.} \\
% 4p/5, & \text{if $k < j$, and $b_i = 1, \forall k < i \leq  j $.} \\
% 14p/15, & \text{ otherwise.} \\
%\end{cases}
%\end{equation}
%%
%Further, $\mathcal{W}_C = I \otimes \mathcal{W}'_q$, where $\mathcal{W}'_q$ is a quantum channel acting on $q$ as follows, 
%\begin{equation} \label{eq:eff_noise_cnot}
%\mathcal{W}'_q = \begin{cases}
%\mathcal{D}_{q_1}^{(6p/15)}, & \text{ if $k =  j$ }  \\
% \mathcal{P}_{q_1}^{(2p/15)}, & \text{ if $k <  j$, and $b_i = 0, \forall k < i \leq  j $} \\
%  \mathcal{B}_{q_1}^{(2p/15)}, & \text{if $k < j$, and $b_i = 1, \forall k < i \leq  j $} \\
% I, & \text{ otherwise,} \\
%\end{cases}
%\end{equation}
%where $\mathcal{D}_{q_1}^{(p)}$ is a depolarizing channel, acting on $q$ with error probability $p$ as follows, 
%$\mathcal{D}_{q}^{(p)}(\rho) := (1 - p) \rho + \frac{p}{3} (X \rho X + Y \rho Y + Z \rho Z)$, $\mathcal{D}_{q_1}^{(p)}$ is a dephasing channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p Z \rho Z$, $\mathcal{D}_{q_1}^{(p)}$ is a phase-flip (or dephasing) channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p Z \rho Z$, and $\mathcal{B}_{q_1}^{(p)}$ is a bit-flip channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p X \rho X$.
%\end{lemma}
%
%%\smallskip We may extend Defition~\ref{def:err-det} for a collection of $\mathcal{C}_{i \to j}$ components. The first condition then would be modified as 
%
%%Note that the two conditions in Definition~\ref{def:err-det} may not be satisfied for the total error produced by two or more components failures in $B_{i \to j}$, even though the errors due to individual components may satisfy the conditions separately.
%%
%%
%%\smallskip We refer to an error that is not effective, as a \emph{non-effective} error. Note that non-effective errors will not be detected as they don't affect the measurement outcome. However, as the error detection code has limitations due to its minimum distance, some effective errors would also may not be detected. We define \emph{non-effective error probability} of $B_{i \to j}$, as the probability that effective errors do not happens during $B_{i \to j}$ or in other words, only non-effective errors happen during $B_{i \to j}$. The non-effective probability could be a good estimation of the success probability of $B_{i \to j}$, \emph{i.e.}, the probability that no error is detected during the implementation of $B_{i \to j}$, given that the error detection gadget detects errors with high probability.
%% 
%%
%%\smallskip In the following, we estimate the non-effective error probability of a $B_{i \to j}$ as well as the Pauli errors that remain on the output of $B_{i \to j}$ due to the non-effective errors. Using the above, we then provide estimates of the preparation rate as well as the preparation error probabilities of the factory preparation according to Procedure~\ref{prot:fact_prep}. Further, we compare the obtained theoretical estimates with our Monte-Carlo based numerical results. We observe that the theoretical estimates approximate well the numerical results for $N = 64, 256$. Therefore, our theoretical estimates are useful way to approximate these quantities for large code-lengths, where Monte-Carlo simulations are not-feasible due to their high computational resource requirements.
%
%
%%effective error probability, \emph{i.e.}, the probability that an effective error happens during a given block $B_{i \to j}$. Note that the effective error probability is an upper bound on the detection probability, \emph{i.e.}, the probability that an error is detected during the implementation of $B_{i \to j}$. Subsequently, we provide the noise channel that remains on the output of $B_{i \to j}$ due to the non-effective errors.
%
%%Using the above, we compute the effective preparation rate of the factory preparation according to Procedure~\ref{prot:fact_prep}, $i.e.$, 
%
%\subsection{Effective faults and detected errors}
%The relationship between the effective fault and detected faults is apparent.
%
%If $C \in \mathcal{C}_{i \to j}$ is the only component that fails, an error could only be detected if $C \in \mathcal{C}_{i \to j}$ is an effective fault. Similarly, considering a subset of components $\mathcal{C}_1 \in \mathcal{C}_{i \to j}$ fail, an error would be detected only if there exists a  $\mathcal{C}_2 \in \mathcal{C}$ such that the faults corresponding to components in $\mathcal{C}_2$ are effective. Therefore, the effective faults are necessary for error detection. However, it effective faults are not guaranteed to lead to an error detection. There are two reasons for that, as explained below.
%
%
%
%
%However, due to recursive error detection, we believe that effective faults are likely to be detected. 
%
%Note that for both cases, the probability that effective faults doesn't lead to an error detection is of order $p^n$, where $n \geq 2$. Hence, for the sake of simplicity, from now on, we assume the following.
%
%\begin{assumption} \label{ass:error_det}
%If at least one effective fault happens during $B_{i \to j}$, it will lead to an error detection. 
%\end{assumption}   
%
%
%We now note that an error can be detected due to the following two reasons, during $B_{i \to j}$,
%

%
%Let $B_{0 \to k_1}, \dots, B_{k_{i-1} \to k_i}, \dots, B_{k_i \to i}$ be the set of recursion levels applied before $B_{i \to j}$. To compute the preexisting errors on the inputs of $B_{i \to j}$, we may consider the previous recursion levels al
%
%The preexisting errors on the inputs of $B_{i \to j}$ corresponds to the remaining errors on the output of the previous recursion levels $B_{0 \to i}$. The errors on the output of $B_{0 \to i}$ can be caused by the faults in initialization according to Lemma~\ref{}, and also by the non-effective faults during $B_{0 \to i}$. In the following lemma, we provide the noise channel that acts on the output of $B_{0 \to i}$.
%
%
%\begin{lemma}
%Consider the recursion levels corresponding to $B_{0 \to i}$. Let $k_{\text{min}}$ be the smallest recursion level such in $1 \leq k_{\text{min}} \leq i-1$ satisfying $b_{i'} = b, \forall k_{\text{min}} < i' < i$, for a fixed value $b \in \{0, 1\}$. Then considering Assumption~\ref{ass:error_det}, the noise channel on the output of $B_{0 \to i}$ is an $i.i.d.$ Pauli noise, with $X$, $Y$, and $Z$ error probabilities as follows,
%%
%\begin{equation}
%p^{0 \to i}_x = \begin{cases}
%1- (1 - 2p/15)^2, & \text{ if $b = 0$. } \\
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%%
%\begin{equation}
%p^{0 \to i}_y = 1- (1 - 2p/15)^2.
%\end{equation}
%%
%\begin{equation}
%p^{0 \to i}_z = \begin{cases}
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 0$. } \\
%1- (1 - 2p/15)^2, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%
%\end{lemma}
%%
%From Lemma~3, we have a Pauli channel acting on each input qubit of $B_{i \to j}$. Therefore,  we may treat this Pauli channel as an error caused by the initialization component on the corresponding qubit.
%
%
% and the probability of the initialization component to be effective with respect to $B_{i \to j}$ can be computed similar to Lemma~\ref{}, that is,
%
%Hence, the probability that at no effective fault happens at the input of $B_{i \to j}$ is given by,
%\begin{equation}
%P_1 = \prod_{i \in I_{i \to j}} (1-p_D^{i}).
%\end{equation}
%Further, let $i_k$, $c_k$ and $m_k$ denote a single qubit initialization, $\cnot$ and gate and single qubit measurement applied at the $k^{th}$ recursion level during $B_{i \to j}$. The probability that no effective fault happens is given by,
%\begin{equation}
%P_2 = \prod_{i, c, m \in \mathcal{C}_{i \to j}} (1-p_D^{i}) (1-p_D^{c}) (1-p_D^{m}).
%\end{equation}
%
%
%
%
%
%\subsection{Noise on the output of  $B_{i \to j}$ due to non-effective errors}
%
%In this section, we provide the noise channel on the ouput of $B_{i \to j}$,  due to all the components in $\mathcal{C}$, when no error is detected at any recursion level. Note that the noise channel on the output of $B_{i \to j}$ may not only be due to the components in $B_{i \to j}$, but also due to preexisting errors on the input $B_{i \to j}$, that go undetected through $B_{i \to j}$. Here, we first consider the noise channel due to components in $B_{i \to j}$.
% 
%
%\subsection{Success probability of $B_{i \to j}$}
%
%An error can be detected during $B_{i \to j}$ due to the following two reasons,
%
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%\item[$(i)$] The preexisting error on the input of $B_{i \to j}$ gets detected during $B_{i \to j}$.
%
%\item[$(ii)$] The faults during $B_{i \to j}$, producing an error that is detected. 
%
%\end{list}
%
%We first estimate the probability that point $(ii)$ happens.
%
%
%
%
%%We note that the \emph{non-effective} error probability is an 
%
%
%
%%Using the above, we compute the non-effective probability of the 
%
%
%%
%\subsection{Non-effective and preparation error probabilities of $B_{i \to j}$}
%
%
%\smallskip Let $\mathcal{S}_{i \to j} :=  \eqdef \{1, \dots, 2^{j}\}$ be the set of qubits on which $B_{i \to j}$ acts and let and $\mathcal{C}_{i \to j}$ be the set of components corresponding to $B_{i \to j}$. Note that $\mathcal{C}_{i \to j}$ consists of $T_{j} = \big(j - i\big) 2^{j-1}$ two qubit Pauli measurements. Therefore, it consists of $T_{i \to j}$ initializations and measurements of the ancilla qubits and $2T_{i \to j}$ $\cnot$ gates between the ancilla and data qubits. 
%
%\smallskip We first define \emph{detection error probability} and \emph{effective noise channel} for  each component in $\mathcal{C}_{i \to j}$.
%
%
%
%
%\begin{definition}[Effective probability and non-effective noise channel] Consider an element $C \in \mathcal{C}_{i \to j}$ and suppose that $C$ is the only component $\mathcal{C}_{i \to j}$ that is faulty and the remaining components are perfect. 
%
%
%Then, we define the detection probability for $C$, denoted by $p^C_D$, as the probability that $C$ produces an effective error.
%
%Further, we define the non-effective noise channel corresponding to $C$, denoted by $\mathcal{W}_C: L(\mathcal{S}_{ i \to j}) \to L(\mathcal{S}_{ i \to j})$, with $L(\mathcal{S}_{ i \to j})$ being the set of linear operators acting on the Hilbert space corresponding to $\mathcal{S}_{ i \to j}$, as the channel that acts on the output quantum state of $B_{i \to j}$, when $C$ doesn't produce an effective error. 
%
%
%%the error detection gadget detects an error at some recursion level in $B_{i \to j)}$, given that $C$ fails. 
%
%%Consider the cases, where an error is not detected by the gadget at any recursion level, given that only $C$ failed (This happens with probability $1 - p^C_D$). 
%\end{definition} 
%%
%In Lemma~\ref{lem:p-w-int-m} and~\ref{lem:p-w-cnot}, which are proven in Appendix~\ref{app:proof-lemmas}, we provide $p^C_D$ and $W_C$ for each component $C$ in $\mathcal{C}_{i \to j}$.
%
%\begin{lemma} \label{lem:p-w-int-m}
%For an initialization and measurement component on a ancilla qubit $A$ during $B_{i \to j}$, we have the following,
%\begin{align}
%p_C &= 1. \\
%\mathcal{W}_C &= I_{S \to A}.
%\end{align} 
%\end{lemma}
%%
%\begin{lemma} \label{lem:p-w-cnot}
%Consider a $\cnot_{q \to A}$, during $B_{i \to j}$, acting between a data qubit $q \in \mathcal{S}_{i \to j}$ and the ancilla qubit $A$ on the $k^{th}$ recursion level. Then, $p_C$, depending on $k$,  is as follows. 
%%
%\begin{equation} \label{eq:det_prob_cnot}
% p^C_{D} = \begin{cases}
% 8p/15, & \text{ if $k =  j$. }  \\
% 4p/5, & \text{ if $k <  j$, and $b_i = 0, \forall k < i \leq  j $.} \\
% 4p/5, & \text{if $k < j$, and $b_i = 1, \forall k < i \leq  j $.} \\
% 14p/15, & \text{ otherwise.} \\
%\end{cases}
%\end{equation}
%%
%Further, $\mathcal{W}_C = I \otimes \mathcal{W}'_q$, where $\mathcal{W}'_q$ is a quantum channel acting on $q$ as follows, 
%\begin{equation} \label{eq:eff_noise_cnot}
%\mathcal{W}'_q = \begin{cases}
%\mathcal{D}_{q_1}^{(6p/15)}, & \text{ if $k =  j$ }  \\
% \mathcal{P}_{q_1}^{(2p/15)}, & \text{ if $k <  j$, and $b_i = 0, \forall k < i \leq  j $} \\
%  \mathcal{B}_{q_1}^{(2p/15)}, & \text{if $k < j$, and $b_i = 1, \forall k < i \leq  j $} \\
% I, & \text{ otherwise,} \\
%\end{cases}
%\end{equation}
%where $\mathcal{D}_{q_1}^{(p)}$ is a depolarizing channel, acting on $q$ with error probability $p$ as follows, 
%$\mathcal{D}_{q}^{(p)}(\rho) := (1 - p) \rho + \frac{p}{3} (X \rho X + Y \rho Y + Z \rho Z)$, $\mathcal{D}_{q_1}^{(p)}$ is a dephasing channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p Z \rho Z$, $\mathcal{D}_{q_1}^{(p)}$ is a phase-flip (or dephasing) channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p Z \rho Z$, and $\mathcal{B}_{q_1}^{(p)}$ is a bit-flip channel, acting on $q$ with the error probability $p$ as $\mathcal{P}_{q}^{(p)}(\rho) := (1 - p) \rho + p X \rho X$.
%\end{lemma}
%%\smallskip Indeed, this assumption is a necessary condition for an error to be detected. However, it is not a sufficient one, since if component failures produce an error, which has zero syndrome with respect to the classical code associated with the measurement outcome, at a given level of recursion, it would not be detected,  even though it may flip several measurement outcomes. However, if the number of component failures is not too many, the produced error is likely to be detected. Therefore, the above assumption is a reasonable one to make.  
%
%%However, it is unlikely that such an error would not be detected at one of the next level of recursions. Therefore, the above assumption is a reasonable one to make for our preparation. 
%
%%Recall that our preparation procedure consists of the following components, initialization in Pauli $Z$ and $X$ basis, $\cnot$ gates, and single qubit Pauli $Z$ and $X$ measurements. Consider a component $C$ in the preparation of $\pone$ code state according to Procedure~\ref{prot:fact_prep}. Let $p$ be the failure probability of the component $C$. A component failure produces an error on the output qubit as given by the noise model in {\color{blue}} \ref{}. In certain cases, the error produced by the failure may be detected by the error detection gadget at some recursion level, while in certain cases it may not be detected.
%
%%{ \color{blue} From~\cite[Theorem 3]{goswami2022fault}, a single component failure can produce an $X$ and $Z$ errors each of at most weight $1$. 
%%}
%%
%% The components failures that are  not detected cause errors on the prepared states. 
%
%
%
%%
%
%
%
%
%
%%Then, we define the effective failure probability of $C$ as 
%%\begin{equation}
%%p^C_{eff} = p p^C_D.
%%\end{equation}
%%
%%The components failures that are not detected cause errors on the prepared states.
%
%%\begin{definition}[Effective noise channel]
%%.
%%
%%\end{definition}
%
%%For the sake of simplicity, we shall assume the following regarding the error detection.
%%
%%\emph{We say that an error is detected by the gadget if it flips the outcome of at least one single qubit Pauli $Z$ measurement in the preparation procedure.}
%
%
%
%
%%In the following, we consider recursion levels $B_{n_{sch}(i) \to n_{sch}(j)}$, \emph{i.e.}, the recursion levels $n_{sch}(i) + 1, \dots, n_{sch}(i) + 1$, with the binary sequence, $b_{n_{sch}(i)} + 1, \dots, b_{n_{sch}(j)}$ determining two qubit Pauli measurements.
%
%
%
%
%
%%the preparation rate and output error probability for $B_{i \to j}$. Finally, we provide 
%
%
%%each component, considering preparation of a $\pone$ code-state of length $N = 2^n$, with $b_1\cdots b_n \in \{0, 1\}^n$ being the binary expansion of $i(n)-1$. 
%
%
%
%
%
%%To determine the effective probability of failure $p^C_{eff}$ for each component, we give the following lemma.
%%%
%%\begin{lemma} \label{lem:err_det}
%%Consider $C$ is the only component that failed during the preparation procedure. Then, error detection gadget detects an error if and only if the error caused by the failure flips the outcome of least one single qubit Pauli $Z$ or $X$ measurement in the preparation.
%%\end{lemma}
%%%
%%Recall that a Pauli error $P_e$ flips the outcome of a Pauli measurement $P_m$ if and only if $P_e$ and $P_m$ anti-commute. Therefore, a $Z$ measurement is flipped by $X$ or $Y$ error and a $X$ measurement is flipped by $Z$ or $Y$ error. 
%%
%%From Lemma~\ref{lem:err_det}, $p^C_D$, \emph{i.e.}, the probability of error detection when only the component $C$ fails, is equal to the probability that failure in $C$ causes at least one of the meausrement outcomes to be flipped. Using this equality, we below provide  $p^C_D$ for every component $C$ in the procedure. 
%
%
%%To determine $p^C_{eff}$ for each component, we will consider the following simplifying assumption on the error detection.
%
%
%%\begin{definition}[Detection of a component failure] \label{def:comp_det}
%%Failure in a component $C$ is detected if and only if the error caused by the failure flips the outcome of at least one Pauli $Z \otimes Z$ or $X \otimes X$ measurement. Therefore, a component failure will be detected if the corresponding error flips the measurement outcome of the single qubit Pauli measurement perfomed in  the implementation of Pauli $Z \otimes Z$ or $X \otimes X$ measurements. 
%%\end{definition}
%
%%Recall that a Pauli error $P_e$ flips the outcome of a Pauli measurement $P_m$ if and only if $P_e$ and $P_m$ anti-commute. Therefore, a $Z$ measurement is flipped by $X$ or $Y$ error and a $X$ measurement is flipped by $Z$ or $Y$ error.
%%
%%Note that according to Definition~\ref{def:comp_det}, a component failure at a given level of recursion may not be detected in the same level of recursion but in one of the next levels of recursions. This is illustrated in Fig.~\ref{fig:error_det_big}.
%%
%%Considering Definition~\ref{def:comp_det}, we below derive detection probability of for component.
%
%
%%\paragraph*{Initialization errors at the zeroth level of recursion:}
%%%
%%A failure of initialization (in the Pauli $Z$ basis) of the qubit $q$ produces an $X$ error on it. The $X$ error on the intialized qubit $q$ will flip only the outcome of a Pauli $Z \otimes Z$ measurement at one of the next recursion levels. Hence, we have that
%%%
%%\begin{equation} \label{eq:p-det-I}
%%p^{C}_D = \begin{cases}
%%1, & \text{ if there exists a  $i, 1 \leq i \leq k$ s.t. $b_i = 1$.} \\
%%0, & \text{ otherwise.}
%%\end{cases}
%%\end{equation}
%%%
%%%Further, it can be easily seen that the effective channel corresponding to the initialization on the $i^{th}$ qubit is identity, 
%%Clearly, when error is detected, the effective channel is an identity channel. When the error is not detected, \emph{i.e.}, in case when only Pauli $X \otimes X$ measurement is performed, the $X$ error on $q$ simply passes through Pauli $X \otimes X$ measurements. Hence, we have that 
%%%
%%\begin{equation} \label{eq:W-I}
%%W_C = \begin{cases}
%%I, & \text{ if there exists a  $i, 1 \leq i \leq k$ s.t. $b_i = 1$.} \\
%%W_q, & \text{ otherwise.}
%%\end{cases}
%%\end{equation}
%%where $W_q$ is a bit-flip channel, denoted by $\mathcal{B}_{q}^{(p)}$, acting on $q$ with error probability $p$, as follows, $\mathcal{B}_p^{(p)}(\rho) := (1 - p) \rho + p X \rho X$.
%\subsection{Error on the output of $B_{i \to j}$ due to non-effective errors}
%As mentioned before, non-effective errors won't be detected, hence will remain on the output of $B_{i \to j}$. In this section, we provide the remaining errors due to non-effective on the output of $B_{i \to j}$. 
%
%The remaining errors could be caused by the following two possibilities,
%\begin{itemize}
%\item[$(i)$] Error on the input of $B_{i \to j}$ that are non-effective with respect to $B_{i \to j}$.
%
%\item[$(ii)$] The errors produced during $B_{i \to j}$ that are non-effective with respect to $B_{i \to j}$.
%\end{itemize}
%%
%We first consider the point $(ii)$. We will use lemmas~\ref{} and~\ref{} to estimate the remaining error on the output of $B_{i \to j}$.
%
%\paragraph*{The failures during implementation of $B_{i \to j}$.}
%We note that two errors, that are effective individually, can be a non-effective error together (see figure~\ref{}). Hence, several component failures, so that they produce effective errors individually, may produce a non-effective error together. However, such events would happen with smaller probabilites as it would require failure of many components (In figure~\ref{}, we have two failures, the probability of which is $p^2$). Therefore, for the sake simplicity, we suppose that a collection of effective errors, remain effective. Thus, the final error on the output of $B_{i \to j}$ is simply composition of the non-effective noise channel $\mathcal{W}_C$ corresponding to each component $C \in \mathcal{C}_{i \to j}$. 
%
%From Lemma~\ref{lem:p-w-int-m}, it follows that the initialization and measurement errors on a ancilla qubit produce only effective errors. Further, from Lemma~\ref{lem:p-w-int-m}, the $\cnot$ before the smallest recursion level $k_{\min}$ such that $b_k$ takes a fixed value $b \in \{0, 1\}$ for all $k > k_{\text{min}}$, also produce only effective errors. In other words, the non-effective errors are produced only by $\cnot$ gates that act at recursion levels $k \geq k_{\text{min}}$. Note that at each recursion level
%
%
%\subsection{Non-effective error probability of $B_{i \to j}$}
%
%%\paragraph*{Suceess Probability and output error probability of $B_{i \to j}$:}
%
%In this section, we provide the noise channel on the ouput of $B_{i \to j}$,  due to all the components in $\mathcal{C}$, when no error is detected at any recursion level. Note that the noise channel on the output of $B_{i \to j}$ may not only be due to the components in $B_{i \to j}$, but also due to preexisting errors on the input $B_{i \to j}$, that go undetected through $B_{i \to j}$. Here, we first consider the noise channel due to components in $B_{i \to j}$.
%
%We consider 
%%Recall that the input of $B_{i \to j}, j > i \geq 1$ is $2^{j - i}$ copies of $\ket{q_{2^i}}$ and the output is $\ket{q_{2^j}}$. Let $\mathcal{S}_{i \to j}  \eqdef \{1, \dots, 2^{j}\}$ be the set of qubits on which $B_{i \to j}$ acts. 
%
%
%
%
%
%Firstly, from~(\ref{eq:W-M}), the effective noise 
%channel due to initialization and measurement components are identity, therefore they do not produce any error on the output of $B_{i \to j}$. 
%
%
%Let $\mathcal{C}_{i'}$ be the set of $\cnot$ gates, applied at the $i'^{th}, i \leq i' \leq j$ level of recursion. Let $k, i \leq k \leq j$ be the smallest recursion level such that $b_{i'} = b, \forall i' \geq 1$, for a fixed value $b \in \{0, 1\}$. In other words, $k$ is the smallest recursion level such that after the $k^{th}$ recursion level, only one type of two-qubit Pauli measurements are applied.
%
%From~(\ref{eq:eff_noise_cnot}), the effective noise channel associated with a $\cnot$ gate in $\mathcal{C}_{i'}, i' \leq k$ is equal to the identity, therefore they also do not produce any error on the output of $B_{i \to j}$.  
%
%
%Further, from~(\ref{eq:eff_noise_cnot}), for $\cnot_{q \to A} \in \mathcal{C}_{i'}, k \leq i' < n$, where $q \in \mathcal{S}_{i \to j}$ and $A$ is an ancilla qubit (involved in either $X \otimes X$ or $Z \otimes Z$ measurement), the effective channel is equal to $\mathcal{P}_{q}^{(2p/15)}$ if $b = 0$ and $\mathcal{B}_{q}^{(2p/15)}$ if $b = 1$. Finally for $\cnot$ gates on the last recursion level,  \emph{i.e.}, $\cnot_{q \to A} \in \mathcal{C}_{i'},i' = n$, the effective channel is a depolarizing channel $\mathcal{D}_{q}^{(6p/15)}$.
%
%Hence, the error on the output of $B_{i \to j}$ is only produced by the $\cnot$ gate acting on the recursion levels $i' \geq k$. Further, a $\cnot$ gate that acts on a data qubit $q \in \mathcal{S}_{i \to j}$, only produces error on qubit $q$. Hence, on each qubit $q$ of the output state, we simply need to concatenate effective error channels, corresponding to $\cnot$ gates that act on $q$, for recursion levels $i' \geq k$. Note that on each qubit $q \in \mathcal{S}_{i \to j}$, there act $2(n-k+1)$ $\cnot$ gates, for $i' \geq k$. Hence, on the output of $B_{i \to j}$, for any qubit $q \in \mathcal{S}_{i \to j}$, we have the following channel   
%
%\begin{equation}
%\mathcal{W}^{i \to j}_{q} = \begin{cases}
%\mathcal{P}_{q}^{(2p/15)} \circ  \stackrel{2(n-k)}{\cdots}  \circ \mathcal{P}_{q}^{(2p/15)} \circ \mathcal{D}_{q}^{(6p/15)} \circ \mathcal{D}_{q}^{(6p/15)}, & \text{ if $b = 0$ } \\
%\mathcal{B}_{q}^{(2p/15)} \circ \stackrel{2(n-k)}{\cdots} \circ \mathcal{B}_{q}^{(2p/15)} \circ \mathcal{D}_{q}^{(6p/15)} \circ \mathcal{D}_{q}^{(6p/15)}, & \text{ if $b = 1$ } \\
%\end{cases}
%\end{equation} 
%%
%The channel $\mathcal{W}_q$ can be easily simplified as a Pauli channel with probabilities associated $p_X, p_Y, p_Z$ with respect to $X, Y, Z$ errors as follows.  
%%
%\begin{equation}
%p^{i \to j}_x = \begin{cases}
%1- (1 - 2p/15)^2, & \text{ if $b = 0$. } \\
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%%
%\begin{equation}
%p^{i \to j}_y = 1- (1 - 2p/15)^2.
%\end{equation}
%%
%\begin{equation}
%p^{i \to j}_z = \begin{cases}
%1 - (1-2p/15)^{2(n-k+1)}, & \text{ if $b = 0$. } \\
%1- (1 - 2p/15)^2, & \text{ if $b = 1$. }
%\end{cases}
%\end{equation}
%
%\smallskip We now consider errors on the output of $B_{i \to j}$, due to preexisting errors on the input. 
%
%
%\smallskip Consider a set of recursion levels $B_{l \to i}, 1 \geq l \geq i$ preceding $B_{i \to j}$. Note that outputs of $2^{j-i}$ isntances of $B_{l \to i}$ are given as input of $B_{i \to j}$.
%
%
%\smallskip Similarly, the noise channel on each qubit of the output of $B_{l \to i}$  is a Pauli channel $\mathcal{W}^{l \to i}_q$, with probabilities $p^{l \to i}_X, p^{l \to i}_Y, p^{l \to i}_Z$. Note that if $B_{i \to j}$ consists of both Pauli $Z \otimes Z$ and $X \otimes X$ measurements, \emph{i.e.}, $k_{i \to j} > i $, the errors on the output of $B_{l \to i}$ will be detected during $B_{i \to j}$, hence producing no errors on the output of $B_{i \to j}$. Further, if $B_{i \to j}$ consists of only one type of two qubit measurement, \emph{i.e.}, $k_{i \to j} = i $, then only one type of error survive on the output of $B_{i \to j}$ depending on the value of $b$.
%%
%Hence, for a $q \in \mathcal{S}_{i \to j}$, the error on the output of $B_{i \to j}$ due to $B_{l \to i}$ is given by a channel $\mathcal{W}^{l \to i \to j}_q$, as follows 
%%
%\begin{equation}
%\mathcal{W}^{l \to i \to j}_q = \begin{cases}
%I, & \text{ if $k_{i \to j} > i $.} \\
%\mathcal{D}^{(p^{l \to i}_Z)}_q, & \text{ if $k_{i \to j} = i $ and $b = 0$.} \\ 
%\mathcal{B}^{(p^{l \to i}_X)}_q, & \text{ if $k_{i \to j} = i $ and $b = 1$.} \\ 
%\end{cases}
%\end{equation}
%%
%Similarly one can obtain noise channel on the output of $B_{i \to j}$, due to preceding levels to $B_{l \to i}$. For a preceding set of recursion levels $B_{l' \to l}, 1 \geq l' \geq l \geq i$, we denote by $\mathcal{W}^{l' \to l \to j}_q $, the error on $q \in \mathcal{S}_{i \to j}$ at the output of $B_{i \to j}$.
%
%
%%Then, we can group  the set $\mathcal{C}$, as $\mathcal{C} = \mathcal{C}_1 \cup \mathcal{C}_2 \cup \mathcal{C}_3 \cup \mathcal{C}_4$, where
%
%
%%
%%\begin{align*}
%%\mathcal{C}_1 &= \{c_k \in \mathcal{C} \mid k = n \} \\
%%\mathcal{C}^b_2 &= \{c_k \in \mathcal{C} \mid k < n, \text{ and } b_{i'} = b \in \{0, 1\}, \forall i' > k \} \\
%%\mathcal{C}_4&= \{c_k \in \mathcal{C} \mid k < n, \text{ and } \exists i', j' > k, \text{ s.t. } b_{i'} = 0 \text{ and } b_{j'} = 1\} \\
%%\end{align*}
%%%
%%From Theorem~\ref{}, we know that only $\cnot$ gates in $\mathcal{C}_1$ and $\mathcal{C}_2$ can produce errors on the output of $B_{i \to j)}, 1 \geq i > j \leq n$.
%%
%%
%%
%%
%%
%%according to 
%%
%%
%%
%%Recall that the input of $B_{n_{\text{sch}}(i) \to n_{\text{sch}}(i + 1)}$ are $2^{n - n_{\text{sch}}(i)}$ copies of $\ket{q_{2^{n_{\text{sch}}(i)}}}$. Let $p^e_{prev}$ be the error probability on each qubit of $\ket{q_{2^{n_{\text{sch}}(i)}}}$ due to the undetected error at the previous level of errors. We may treat the outut errors on $\ket{q_{2^{n_{\text{sch}}(i)}}}$ as the initialization error for $B_{n_{\text{sch}}(i) \to n_{\text{sch}}(i + 1)}$ and $p_C$ for these components is according to~(\ref{eq:p-det-I}). Note that the following holds,
%%\begin{align}
%%|I_0| &= 2^{n_{\text{sch}}(j)}  \\
%%|I_1| & = \big(n_{\text{sch}}(j) - n_{\text{sch}}(i)\big)2^{n_{\text{sch}}(j)-1}
%%|I_1|
%%\end{align}
%
%
%%There may be error on the each $2^{n - n_{\text{sch}}(i)}$
%
%
%
%%\smallskip Let $\mathcal{I}_0$ be the set of all initialization components on the input of   $B_{n_{\text{sch}}(i) \to n_{\text{sch}}(i + 1)}$, and let $\mathcal{I}_1$ be the set of all initialization components during Pauli $Z \otimes Z$ and Pauli $X \otimes X$ measurements, in $B_{i \to j}$.. Further , let $\mathcal{M}, \mathcal{C}$ be the set of all single qubit Pauli measurements and $\cnot$ components, respectively.
%%
%%Let $c_k$ denote the $\cnot$ gate, applied at the $k^{th}, i \leq k \leq j$ level of recursion. Then, we can group  the set $\mathcal{C}$, as $\mathcal{C} = \mathcal{C}_1 \cup \mathcal{C}_2 \cup \mathcal{C}_3 \cup \mathcal{C}_4$, where
%%%
%%\begin{align*}
%%\mathcal{C}_1 &= \{c_k \in \mathcal{C} \mid k = n \} \\
%%\mathcal{C}_2 &= \{c_k \in \mathcal{C} \mid k < n, \text{ and } b_i = 0, \forall i > k \} \\
%%\mathcal{C}_3 &= \{c_k \in \mathcal{C} \mid k < n, \text{ and } b_i = 1, \forall i > k \} \\
%%\mathcal{C}_4&= \{c_k \in \mathcal{C} \mid k < n, \text{ and } \exists i, j > k, \text{ s.t. } b_i = 0 \text{ and } b_j = 1\} \\
%%\end{align*}
%%%
%%Then, the probability of succesful preparation can be lower bounded as,
%%
%%\begin{equation}
%%(1- p_D^{B}) = (1 -p^e_{prev}p_D^{\mathcal{I}})^{2^{n_{\text{sch}}(i)}} (1 -p)^{|\mathcal{I}| + |\mathcal{M}|} \prod_{\mathcal{C}_i}(1 -pp_D^{\mathcal{C}_i})^{|\mathcal{C}_i|} 
%%\end{equation} 
%
%
%%
%
%
%
%
%\subsection{Output error probability}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%\smallskip The remaining errors may or may not be detected at the same level of recursion. Both Errors $X_{q_1} \otimes I_{A}$ and $Y_{q_1} \otimes Z_{A}$ propagate to $X_{q_1} \otimes I_{q_2}$ after the measurement, therefore they can only be detected at the next levels of recursion, where Pauli $Z \otimes Z$ measurements are performed. Errors $Z_{q_1} \otimes I_{A}$ and $I_{q_1} \otimes Z_{A}$ propagte to $Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$ respectively, therfore, they can be detected only at the next level of recursion with Pauli $X \otimes X$ measurements. Finally, errors $Y_{q_1} \otimes I_{A}$ and $X_{q_1} \otimes Z_{A}$ propagte to $Y_{q_1} \otimes I_{q_2}$ and $X_{q_1} \otimes Z_{q_2}$ resepectively, therefore they can be detected if there is a next level of recursion either with $X \otimes X$ or $Z \otimes Z$ measurements.
%%
%%
%%\smallskip Therefore, if there exist recursion levels with both $Z \otimes Z$ and $X \otimes X$ measurements after $k^{th}$ recursion level, a $\cnot_{q_1 \to A}$ failure will always be detected except for the trivial error $Z_{q_1} \otimes Z_{A}$.
%%Further, if there exist recursion levels with only $Z \otimes Z$ measurements after $k$, all the errors except $Z_{q_1} \otimes Z_{A}, Z_{q_1} \otimes I_{A}$ and $I_{q_1} \otimes Z_{A}$ would be detected. These undetected errors will cause errors $ Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$ on the data qubits after the measurement. Hence, after each measurement, when no error is detected, the errors $ Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$ occur with equal probability $p/15$. For simplification, we may assume that a Pauli error occurs on each qubit $q_1$ and $q_2$, with probability $p/15$. 
%%
%%Finally, if there exist recursion levels with only $X \otimes X$ measurements after $k$, all the errors except $Z_{q_1} \otimes Z_{A}, X_{q_1} \otimes I_{A}$ and $Y_{q_1} \otimes Z_{A}$ would be detected. Both undetected errors propagate to $X_{q_1} \otimes I_{q_2}$ after the measurement. Hence, after each measurement, when no error is detected, the error $ X_{q_1} \otimes I_{q_2}$ occurs with equal probability $2p/15$.
%%
%%
%%
%%
%%Hence, we have the following for $p^C_{eff}$,
%%%
%%\[ p^C_{eff} = \begin{cases}
%% 8p/15, & \text{ if $k = n$. }  \\
%% 4p/5, & \text{ if $k < n$, and $b_i = 0, \forall i > k$.} \\
%% 4p/5, & \text{if $k < n$, and $b_i = 1, \forall i > k$.} \\
%% 14p/15, & \text{ otherwise} \\
%%\end{cases}
%%  \]
%%The errors that are not detected, will remain on the prepared state after the preparation. Consider the case, when there exist only $Z \otimes Z$ measurements after $k$. In this case, for all $k < i < n$, one of the errors 
%%
%%
%%following quantum channel acts on qubits $q_1 q_2$, 
%%
%%$W_{q_1} \otimes W_{q_1} (\ket{\psi} \bra{\psi}) = $ 
%%
%%
%%
%%
%% undetected errors  $Z_{q_1} \otimes I_{A}$ and $I_{q_1} \otimes Z_{A}$ propagte to $Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$. Hence, 
%%
%%
%%
%%
%%\smallskip The remaining errors can be further divided as follows.
%%
%%\begin{itemize}
%%\item The error $Z_{q_1} \otimes Z_{A}$ propagates to $Z_{q_1} \otimes Z_{A}$, which is a stabilizer and hence can be ignored.
%%
%%\item Errors $X_{q_1} \otimes I_{A}$ and $Y_{q_1} \otimes Z_{A}$ propagate to $X_{q_1} \otimes I_{q_2}$, hence can only be detected at the next levels of recursion, where Pauli $Z \otimes Z$ measurements are performed.
%%
%%\item Errors $Z_{q_1} \otimes I_{A}$ and $I_{q_1} \otimes Z_{A}$ propagte to $Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$, hence can only be detected at the next levels of recursion, where Pauli $X \otimes X$ measurements are performed.
%%
%%\item Errors $Y_{q_1} \otimes I_{A}$ and $X_{q_1} \otimes Z_{A}$ propagte to $Y_{q_1} \otimes I_{q_2}$ and $X_{q_1} \otimes Z_{q_2}$, and can be detected if there is a next level of recursion either with $X \otimes X$ or $Z \otimes Z$ measurements.
%%
%%\end{itemize}
%%
%%
%%% one of the following errors $I_{q_1} \otimes X_{A}, X_{q_1} \otimes X_{A}, Z_{q_1} \otimes X_{A}, Y_{q_1} \otimes X_{A}, I_{q_1} \otimes Y_{A}, X_{q_1} \otimes Y_{A}, Z_{q_1} \otimes Y_{A}, Y_{q_1} \otimes Y_{A}$,
%%
%% %as they  flip the outcome of the Pauli $Z$ measurement therein.
%%
%%
%%
%%
%%
%%
%%
%%
%%
%% Then, there are following two cases in order, 
%%%
%%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%%
%%\item[$(1)$] The failure would be detected at the same level of recursion if it produces one of the following errors $I_{q_1} \otimes X_{A}, X_{q_1} \otimes X_{A}, Z_{q_1} \otimes X_{A}, Y_{q_1} \otimes X_{A}, I_{q_1} \otimes Y_{A}, X_{q_1} \otimes Y_{A}, Z_{q_1} \otimes Y_{A}, Y_{q_1} \otimes Y_{A}$, as they  flip the outcome of the Pauli $Z$ measurement therein. 
%%
%%\item[$(2)$] The remaining errors can be further divided as follows.
%%
%%\begin{itemize}
%%\item The error $Z_{q_1} \otimes Z_{A}$ propagates to $Z_{q_1} \otimes Z_{A}$, which is a stabilizer and hence can be ignored.
%%
%%\item Errors $X_{q_1} \otimes I_{A}$ and $Y_{q_1} \otimes Z_{A}$ propagate to $X_{q_1} \otimes I_{q_2}$, hence can only be detected at the next levels of recursion, where Pauli $Z \otimes Z$ measurements are performed.
%%
%%\item Errors $Z_{q_1} \otimes I_{A}$ and $I_{q_1} \otimes Z_{A}$ propagte to $Z_{q_1} \otimes I_{q_2}$ and $I_{q_1} \otimes Z_{q_2}$, hence can only be detected at the next levels of recursion, where Pauli $X \otimes X$ measurements are performed.
%%
%%\item Errors $Y_{q_1} \otimes I_{A}$ and $X_{q_1} \otimes Z_{A}$ propagte to $Y_{q_1} \otimes I_{q_2}$ and $X_{q_1} \otimes Z_{q_2}$, and can be detected if there is a next level of recursion either with $X \otimes X$ or $Z \otimes Z$ measurements.
%%
%%\end{itemize}
%%
%%
%%%failures that are not detected at the same level of recursion, $i.e.$ failure instances, where one of the errors $X \otimes I, Y \otimes I, Z \otimes I, I \otimes Z, X \otimes Z, Z \otimes Z, Y \otimes Z$ is produced. Note that these errors propagate as the following errors on the qubits $q_1 q_2$, after the measurement, up to the stabilizer $Z \otimes Z$.
%%
%%%$$ X \otimes I \to X \otimes I,  Y \otimes I \to Y \otimes I, Z \otimes I \to Z \otimes I $$
%%%
%%%$$ I \otimes Z \to I \otimes Z, X \otimes Z \to X \otimes Z, Z \otimes Z \to I \otimes I, Y \otimes Z \to X \otimes I$$ 
%%\end{list}
%%Let $p_D$ be the probability that an error is detected given that $\cnot_{q_1 \to A}$ fails. We define effective probability for each component as follows
%%
%%
%%
%%The errors that are not detected will accumulate and as proven in Theorem 
%%
%%
%%
%%
%%Hence, the effective probability of error detection for each co
%%
%%
%%Then, we have the following,
%%%%
%%%\[ p_D = \begin{cases}
%% 8/15, & \text{ if $k = n$. }  \\
%% 4/5, & \text{ if $k < n$, and $b_i = 0, \forall i > k$.} \\
%% 4/5, & \text{if $k < n$, and $b_i = 1, \forall i > k$.} \\
%% 14/15, & \text{ otherwise} \\
%%\end{cases}
%%  \]
%
%
%
%
%
%
%
%
%
%
%
%
%%Hence, the probability of 
%%
%%We may consider the remaining errors as initialization error for the next levels of recursion. Hence, we may further divide the errors that are not detected as follows.
%%
%%The errors that has no effect: $Z \otimes Z$. \\
%%The errors that will only be detected if Pauli $X \otimes X$ measurements are performed at least one of the next level of recursions: $Z \otimes I, I \otimes Z$. \\
%%The errors that will only be detected if transversal Pauli $Z \otimes Z$ measurements are performed at one of the next level of recursions: $X \otimes I, Y \otimes Z$. \\
%%The errors that will be detected if it's not the last level of of recursion, $i.e.$, there are at least one level of recursion after consisting either of $X \otimes X$ or $Z \otimes Z$ measurements: $X \otimes I, Y \otimes Z$.
%
%
%
%%a Pauli $Z$ error filps the measurement outcome of a Pauli $X$  measurement, while it does nothing when Pauli $Z$ measurement is perfomed. Similarly, a Pauli $X$ error filps the measurement outcome of a Pauli $Z$  measurement, while it does nothing when Pauli $X$ measurement is perfomed.
%
%
%
%%% Figure environment removed
%
%



\section{Numerical results} \label{sec:num-res}

In this section, we present our numerical results regarding the factory preparation rate and logical error rates, using our theoretical estimates in Section~\ref{sec:estimates_theory} as well as a Monte-Carlo simulation, considering the circuit level depolarizing noise model from Section~\ref{sec:prep-n}.
\subsection{Preparation rate}

For the Monte-Carlo simulation of the preparation rate, we proceed as follows. We simulate $R$ times the factory preparation according to Procedure~\ref{prot:fact_prep}, for a factory size $T$. Let $t_i$ be the number of successfully prepared states for the $i^{th}$ instance of the factory preparation, $1 \leq i \leq R$. Then, we determine $p^{T, n_{\text{sch}}}_{\text{fact}}$ as follows,
\begin{equation} \label{eq:fact_prep-1}
p^{T, n_{\text{sch}}}_{\text{fact}} = \frac{1}{RT} \sum_{i = 1}^R t_i.
\end{equation}
%
We obtain the value of $p^{T, n_{\text{sch}}}_{\text{fact}}$ for $T$ values $1, 2^1, \dots, 2^{10}$. For the fixed physical error rate $p = 10^{-3}$, the factory preparation rate $p^{T, n_{\text{sch}}}_{\text{fact}}$, with respect to $T$, is shown in Fig.~\ref{fig:fact_rate_num} for $\pone(N = 64, i = 23)$ and $\pone(N = 256, i = 91)$, with scheduling sets $n_{\text{sch}} = \{ 2, 4, 6\}$ and $n_{\text{sch}} = \{2, 4, 6, 8\}$, respectively. The information positions are chosen according to~\cite[Table I]{goswami2022fault} for ignoring correlations.



 % Figure environment removed
% $\pone$ code-states $\pone(N = 64, i = 23)$ and $\pone(N = 256, i = 91)$, with the scheduling sets $n_{\text{sch}} = \{0, 2, 4, 6\}$ and $n_{\text{sch}} = \{0, 2, 4, 6, 8\}$, respectively.



\smallskip We observe that $p^{T, n_{\text{sch}}}_{\text{fact}}$ increases with respect to $T$ in the beginning, and then it saturates. The saturated value corresponds to the preparation rate with respect to $T \to \infty$, \emph{i.e.}, $p^{n_{\text{sch}}}_{\text{fact}}$ from~(\ref{eq:fact_prep_T}). We take the saturated value to be the value of $p^{T, n_{\text{sch}}}_{\text{fact}}$ for $T = 2^{10}$. 

\smallskip The difference between the saturated value and the value of $p_{\text{prep}}$ from~(\ref{eq:prep_rate}) ($i.e.$, $p^{T, n_{\text{sch}}}_{\text{fact}}$ for $T = 1$) is quite significant, especially for $N = 256$. In particular, for $N = 64, 256$, the value of $p_{\text{prep}}$ is around $47\%, 2\%$, respectively, while the saturated value of  $p_{\text{prep}}$ is around $70\%, 27\%$. Therefore, the factory preparation provides significant improvement in the preparation rate compared to~\cite[Procedure 2]{goswami2022fault}. Further, the saturation happens rather quickly, for example the value of $p^{T, n_{\text{sch}}}_{\text{fact}}$ for $T = 8$ is already quite close to its value for $T = 1024$ for both $N = 64, 256$.  This means that we do not need a large factory size to get the increased preparation rate of the factory preparation\footnote{Note that the inverse of the preparation rate contributes to the qubit overhead of the preparation, hence, the factory preparation reduces significantly the qubit overhead of $\pone$ code-state preparation. In particular for $N = 256, p = 10^{-3}$, it reduces the qubit overhead by a factor of around $13$. }. 

\smallskip We further obtain the value of $p^{n_{\text{sch}}}_{\text{fact}}$ using our theoretical estimate in~(\ref{eq:p_success}) and~(\ref{eq:ratio_int}). In Fig.~\ref{fig:fact_rate_saturated_num}, we have presented both the Monte-Carlo and theoretical values of $p^{n_{\text{sch}}}_{\text{fact}}$ with respect to the physical error rate $p$. We observe that the curves corresponding to Monte-Carlo simulation and theoretical estimates are very close,  thus validating that our method of theoretical estimation is a good approximation of reality.









\subsection{Logical error rate}
%As we now have an increased preparation rate for $\pone$ code-states of length $N = 256$, it's imperative to study the error correction performance of $\pone$ code of length $N = 256$.
%
In this section, we estimate the logical error rates of $\pone$ codes, using the Steane error correction, which uses the ancilla code-states (logical $\ket{0}$ and $\ket{+}$ states), prepared by the factory preparation according to Procedure~\ref{prot:fact_prep}. 

% Figure environment removed



To do so, we use the density evolution technique as in~\cite[Section V.D]{goswami2022fault}. Precisely, using the $X$ and $Z$ error probabilities on the prepared states, given by~(\ref{eq:prep_x_erate}) and~(\ref{eq:prep_z_erate}), we first estimate the input error probability for the two decoders used within the Steane error correction procedure, as described in~\cite[Section V.C and Section V.D]{goswami2022fault} (see Eqs. (105) and (106) therein). Then, we use density evolution to estimate the output error probability of the two decoders, from which we determine the $X$ and $Z$ logical error rates, $P^L_X$ and $P^L_Z$~\cite[Eq. (107)]{goswami2022fault}, and then the (total) logical error rate $P^L_e = P^L_X + P^L_2 - P^L_X P^L_Z$.


\begin{table}[!t]
\begin{center}
\captionsetup{justification=centering}
\caption{Preparation and logical error rates for $N = 1024$.} 
\label{table:N=1024}
\begin{tabular}{|c|c|c|c|c|}
\hline
$p$ & $0.001$ & $0.0004$ & $0.0002$ & $0.0001$ \\
\hline
$p_{\text{fact}}^{n_{sch}}$ & $0.5\%$ & $12\%$ & $35\%$ & $59\%$ \\
\hline
$P_e^L$ & $4.08 \times 10^{-22}$ & $2.04 \times 10^{-28}$ & $3.23 \times 10^{-33}$ & $2.69 \times 10^{-38}$ \\
\hline
\end{tabular}
\end{center} 
\end{table}



%  For density evolution, we need the input error rate of the Steane decoding (see (105) and (106)~\cite[Section V.D]{goswami2022fault}). For the input error rates of the decoder, one needs the preparation  error probabilities of the prepared $\pone$ code-states. Here, we estimate the preparation error probabilities, using the our theoretical estimates in~(\ref{eq:prep_x_erate}) and~(\ref{eq:prep_z_erate}).


In Fig.~\ref{fig:log_rate_num}, we present the logical error rate vs. physical error rate curves for $N= 64, 256$. For $N = 64$, we have included the density evolution based curves as well as the Monte-Carlo simulation based curves from~\cite[Fig. 4]{goswami2022fault}. We observe that the density evolution curves virtually superimpose  the Monte-Carlo curves, therefore substantiating our theoretical method of estimating preparation error probabilities.

\smallskip For $N = 256$, we have only included the density evolution curves, as the logical error rates are very small to be simulated using the Monte-Carlo simulation, and also the preparation rates are comparatively smaller. As expected, the $\pone$ codes perform much better than the Shor-$\pone$ codes. Note that the performance of the $\pone$ code for $N = 64$ is better than the performance of the  Shor-$\pone$ code for $N = 256$, down to a physical error rate $p = 10^{-3}$. Remarkably, the $\pone$ code for $N = 256$ achieves logical error rates around $10^{-11}$ and $10^{-15}$ for physical error rates $10^{-3}$ and $3 \times 10^{-4}$, respectively, which is very promising for the practical large-scale fault-tolerant quantum computation~\cite{fowler2012surface}. 

\smallskip Finally, for $N = 1024$, our numerical results are given in Table~\ref{table:N=1024}. For a practically interesting range of physical error rates $p \in [10^{-4}, 10^{-3}]$, we observe that $\pone$ code of length $N = 256$ is the best choice due to good preparation rate and sufficiently low logical error rates. Increasing the code-length may be useful for physical error rates above $10^{-3}$, however in this case the $N=1024$ code is penalized by its poor preparation rate.   
%

\subsection{Comparison with the surface code}
 
In Fig.~\ref{fig:log_rate_comp-sur}, we compare the error correction performance of $\pone$ and Shor $\pone$ codes of length $N = 256$ and minimum distance $d = 16$, with that of a surface code with minimum distance $d=15$, assuming a circuit level depolarizing noise model.  For the surface code, the simulation results are taken from~\cite{fowler2012surface}. Note that taking $d=16$ for the surface code only increases the code-length $N$, but not the error correction performance. For $d=15$, the code-length reported in~\cite{fowler2012surface} is $N=421$, however, it can be reduced to  $N=225$, by considering a rotated variant of the surface code. The logical error rate of the surface code is simulated in~\cite{fowler2012surface} down to a physical error rate $p = 5 \times 10^{-3}$. We have extrapolated the logical error rate for lower physical error rates using $P_e^L = c (p / p_{th}) ^{\frac{d+1}{2}}$, as proposed in~\cite{fowler2012surface}, where   $p_{th} = 0.0057$ is the reported surface code threshold.


\smallskip We can see that the $\pone$ code outperforms the surface code by about three orders of magnitude. For example, for practically interesting physical error rates $p = 10^{-3}$ and $p = 5 \times 10^{-4}$, the corresponding logical error rates for the surface code are around $10^{-8}$ and $5 \times 10^{-11}$, while for $\pone$ codes are around $10^{-11}$ and $5 \times 10^{-14}$.  This is an encouraging result for $\pone$ codes and shows that they are of independent interest in the context of fault tolerant quantum computing.  
%
% Figure environment removed

However, we should consider the above comparison carefully, as error correction procedures are different for $\pone$ and surface codes. While Steane error correction is natural for $\pone$ codes, generator measurement-based error correction is natural for surface codes due to their small weight generators. On the one hand, Steane error correction is advantageous in the sense that one round of syndrome extraction is enough for error correction, while for generator measurement-based error correction, several rounds of syndrome extraction are needed. Therefore, error-correction for polar codes can be faster than for surface codes.  On the other hand, generator measurement-based error correction is advantageous in the sense that ancilla qubits can be intercalated between data qubits and are directly reusable after each round of syndrome extraction. However, Steane error correction needs a separate ancilla factory running, to produce ancilla states needed for error correction. Ancilla qubits used in a round of error correction will be  moved back to the factory so that they are reused. %\mehdi{interlocated not clear to me}

%It's worth emphasizing here that the mid-circuit read out is very challenging to implement on real systems, therefore it's likely that one would need to move ancilla qubits to a readout zone even for surface code, making ancilla qubits not really fixed.

\smallskip Finally, we note that the factory preparation (see also Fig.~\ref{fig:error_det_big}) requires distant $\cnot$ gates, \emph{i.e.} interaction between non-neighboring qubits, as opposed to the surface codes.  Although distant $\cnot$ gate is possible on some potential quantum systems such as ion-traps~\cite{ryan2021realization,postler2022demonstration}, there are  ways to circumvent this for quantum systems with local interaction constraint such as by applying swap gates~\cite{sigillito2019coherent, asai2023device} or physically moving qubits around~\cite{jadot2021distant, seidler2022conveyor, boter2022spiderweb, bluvstein2022quantum,bluvstein2023logical}. 

\smallskip Recently, quantum error correcting codes such as small surface and color codes, as well as three-dimensional codes,  have been implemented on a reconfigurable quantum architecture (based on Rydberg atoms), with storage, entangling and readout zones~\cite{bluvstein2022quantum,bluvstein2023logical}.  Qubits therein are moved around within a zone or between zones to achieve long-range connectivity. Moreover, it is worth noticing that the $3$-dimensional $[[8,3,2]]$ code implemented in~\cite{bluvstein2023logical} is actually very similar to a length-8 polar code, both codes using hypercube connectivity. As $\pone$ codes provide better error correction performance exploiting distant operations, they are naturally suited to this kind of architecture. Moreover, the reconfigurable quantum architecture allows to move blocks of qubits in parallel, realizing transversal $\cnot$ gate on two code blocks in parallel. As our preparation is based on recursively applying transversal measurements between two blocks of qubits, it may be implemented in a similar way. 

%is more suited for systems where long-range connectivity is allowed, as it takes advantage of the non-local operations to achieve better error correction performance.   

%space and time-overheads per error correction cycle are different for $\pone$ and surface codes, even if we consider similar codelengths.   


%
%our numerical results give the factory preparation rate of $34.8\%$ for the physical error rate $p = 2 \times 10^{-4}$ and the logical error rate of $3.23 \times 10^{-33}$.

%As expected $\pone$ code performs much better than Shor-$\pone$ codes. Note that the performance of the $\pone$ code for $N = 64$ is better than the performance of the  Shor-$\pone$ code for $N = 256$ up to the physical error rate $p = 10^{-3}$. Remarkably, the $\pone$ code for $N = 256$ achieves a logical error rate around $10^{-12}$, which is very promising for large-scale fault-tolerant quantum computation. 

% We note that the preparation error probabilities are determined based on a monte carlo method~\cite[Section V.D]{goswami2022fault}).


%We first note that the logical error rates of $\pone$ codes, under Steane error detection, has been estimated under Steane correction, using a Monte-Carlo simulation and also a density evolution method for code-lengths up to $64$. The density evolution therein needs the input error rate of the Steane decoding (see (105) and (106)~\cite[Section V.D]{goswami2022fault}). For the input error rates of the decoder, one needs the preparation  error probabilities of the prepared $\pone$ code-states, which is determined by running t





 %for which we use our theoretical estimates   in~(\ref{eq:prep_x_erate}) and~(\ref{eq:prep_x_erate}).





%The Monte-Carlo simulation for bigger code-lengths such as $N = 256$ is not feasible as the logical error rates as well as preparation rates are very small. Here, we estimate the logical error rates of $\pone$ codes, using the density evolution technique.
%
%% values and preparation rate us a. Further, 
%
%
%It is worth noting that the output error probability of 
%
%
%preparation error probabilities of the factory preparation does not depend on the scheduling set $n_{sch}$. The reason for this is that
%
%
%We first note that logical error rates 





% for which we use our theoretical estimates   in~(\ref{eq:prep_x_erate}) and~(\ref{eq:prep_x_erate}).


%{ \color{blue} It is worth noting that the factory preparation is essentially the same preparation as in~\cite[Procedure 2]{goswami2022fault}, except a scheduling, which makes effective use of $\pone$ codes states prepared at the intermediate levels of recursion. Therefore, the output error probabilities on the prepared states and hence, the logical error rates for a given physical error rate, should be independent of the factory size $T$  and the scheduling set $n_{\text{sch}}$. This is indeed what we observe in our numerical results.
%}

%It is worth noting that the preparation error probabilities of the factory preparation does not depend on the scheduling set $n_{sch}$. The reason for this is that

%Note that the error correction performance of $\pone$ codes depends on the output $X$ and $Z$ error probability of the prepared state.


%The density evolution technique requires an estimated of the output error 
%
% It is worth mentioning that logical error
% 
%Consider $R$ instances of factory prepration for some $T$ and $n_{\text{sch}}$ and let $t_R$ be the total number of successfully prepared $\pone$ code-states of length $N$. Further


%One should note that the output error rates, that are used 





%{\color{blue} suggest some citations if you are aware of something}.



\section{Discussion} \label{sec:conc}


We have proposed a factory preparation of $\pone$ code-states, which is shown to be an useful extension of the measurement based preparation in~\cite{goswami2022fault}, providing much better preparation rates comparatively. Its better preparation rate owes to a scheduling step, which makes clever use of the $\pone$ code-states prepared at the intermediate levels of recursion. Thanks to the factory preparation, we are able to prepare code-states of lengths $N = 256, 1024$, with reasonably high preparation rates for a practically interesting physical error rate range  $10^{-4}-10^{-3}$. Further, it is shown that for $N = 256, 1024$ and a physical error rate in the range $10^{-4}-10^{-3}$, the $\pone$ code achieves a logical error rate below $10^{-15}$, which is currently estimated to be the required logical error rate for large-scale fault-tolerant quantum computation~\cite{fowler2012surface}. Due to a higher preparation rate, smaller number of qubits and also achieving a sufficiently low logical error rate, the code-length $N=256$ is the best $\pone$ code in this physical error range. 

To estimate the preparation rate and logical error rates of $\pone$ codes, we have used a theoretical framework based on the new notions of smooth and rough errors. It is shown that estimates based on our theoretical framework fit well the estimates obtained using Monte-Carlo simulations, therefore substantiating the accuracy of the theoretical framework. We note that our notions of smooth and rough errors are not particular to $\pone$ codes and therefore, as a natural future direction, it would be interesting to analyze other fault-tolerant protocols using these notions, especially the ones based on error detection~\cite{knill2005scalable,chao2018quantum}. 
%
%Even though the preparation rate is significantly improved for the factory preparation compared to~\cite{goswami2022fault}, it still decreases with the code-length. Hence, further improvements are needed to prepare $\pone$-code states of lengths $N =1024, 2048, \dots$, with a reasonably high preparation rate for a practically interesting range of physical error rates.
%A potential approach could be incorporating an error correction instead of error detection or a combination of error detection and error correction in the preparation.
%
%Further, to take the full advantage of error correction capability of $\pone$ codes, it would be desirable to extend the preparation for polar codes that encode more than $1$ qubit.
\section{Acknowledgement}
This work was supported by the QuantERA grant EQUIP, by the French Agence Nationale de la Recherche, ANR-22-QUA2-0005-01.

%Consider $T> 1$ parallel preparations of $\pone$ code-states, each of length $N$. 
%\newpage
\appendix

\section{Proofs of Lemmas~\ref{lem:int-eff-err},~\ref{lem:p-w-int-m},~\ref{lem:p-w-cnot} and~\ref{lem:smooth_total_channel}} \label{app:proof-lemmas}
%




\paragraph{Proof of Lemma~\ref{lem:int-eff-err}:} Lemma~\ref{lem:int-eff-err} follows from the fact that the initialization at the zeroth level of recursion produces an $X$ error, which flips the outcome of a Pauli $Z \otimes Z$, while it does not have any effect on Pauli $X \otimes X$ measurement as shown in Fig.~\ref{fig:proof_lemma_initialization}.


\paragraph*{Proof of Lemma~\ref{lem:p-w-int-m}:}
Consider the circuit implementing Pauli $Z \otimes Z$ measurement from Fig.~\ref{fig:mZZ_mXX_notation_and_circuit}. Note that a failure in initialization on the ancilla qubit produces an $X$ error on it, which will flip the outcome of the next Pauli $Z$ measurement. A failure in Pauli $Z$ measurement produces an $X$ error just before the measurement, hence it will also flip the measurement outcome. Therefore, the measurement outcome will be flipped with probability $1$ if an initialization or an measurement error happens on the ancilla qubit. Therefore, it follows that,
\begin{align}
p_C &= p. \label{eq:p-det-M}  \\ 
\mathcal{W}_C &= I. \label{eq:W-M}
\end{align} 
%
Similarly, it can be proven for Pauli $X \otimes X$ measurement.

%It is easily seen that an initialization or an measurement error on the ancilla qubit during a $Z \otimes Z$ or  $X \otimes X$ measurement flips the outcome of the corresponding measurement with probability $1$. Hence, for initialization and measurement errors during a $Z \otimes Z$ or $X \otimes X$  measurement, we have that 



\paragraph*{Proof of Lemma~\ref{lem:p-w-cnot}:}
%
We  prove below Lemma~\ref{lem:p-w-cnot} for the $\cnot$ gate applied at the time step $t = 2$ of a recursion level in $B_{i \to j}$, with Pauli  $Z \otimes Z$ measurements. It can be similarly seen that Lemma~\ref{lem:p-w-cnot} also holds for $t = 3$, and as well as for the $\cnot$ gates applied in a Pauli $X \otimes X$ measurement.

% Figure environment removed


% Figure environment removed

Consider a Pauli $Z \otimes Z$ measurement applied at some $k^{th}$ recursion level corresponding to $B_{i \to j}$. We shall denote the data qubits on which Pauli $Z \otimes Z$ measurement acts on by $q_1, q_2$ and the ancilla qubit by $a$, as in Fig.~\ref{fig:proof_lemma_cnot}. Below, we  classify the errors produced by the first $\cnot$ gate $\cnot_{q_1 \to a}$ into rough and smooth errors, as per Definition~\ref{def:eff_err}, and then, using the set of rough and smooth errors, we compute $p_C$ and $\mathcal{W}_C$ for $C = \cnot_{q_1 \to a}$.

\smallskip Firstly, note that if a failure in $C$ produces the error $Z_{q_1} \otimes Z_{a}$, it propagates as $Z_{q_1} \otimes Z_{q_2}$ after the measurement, which is a stabilizer of the quantum state corresponding to the joint system $q_1q_2$, and hence this error can be ignored (see Fig.~\ref{fig:proof_lemma_cnot}). Further, if a failure in $C$ produces an $X$ or $Y$ error on the ancilla qubit $a$, it will flip the measurement outcome of the corresponding Pauli $Z \otimes Z$ measurement, hence such an error is a rough error. Precisely, the following errors produce an $X$ or $Y$ error on the ancilla,
%
\begin{equation}
I_{q_1} \otimes X_{a}, X_{q_1} \otimes X_{a}, Z_{q_1} \otimes X_{a}, Y_{q_1} \otimes X_{a}, I_{q_1} \otimes Y_{a}, X_{q_1} \otimes Y_{a}, Z_{q_1} \otimes Y_{a}, Y_{q_1} \otimes Y_{a}
\end{equation}


%
The remaining errors, \emph{i.e.}, $ X_{q_1} \otimes I_{a}, Y_{q_1} \otimes I_{a}, Z_{q_1} \otimes I_{a}, I_{q_1} \otimes Z_{a}, X_{q_1} \otimes Z_{a}, Y_{q_1} \otimes Z_{a}$ do not flip the outcome of the measurement and propagate to the following errors  after the measurement (up to the stabilizer $Z_{q_1} \otimes Z_{q_2}$, similar to Fig.~\ref{fig:proof_lemma_cnot}),  $X_{q_1} \otimes I_{q_2}, Y_{q_1} \otimes I_{q_2}, Z_{q_1} \otimes I_{q_2}, Z_{q_1} \otimes I_{q_2}, Y_{q_1} \otimes I_{q_2}, X_{q_1} \otimes I_{q_2}$, respectively. 
%
Hence, the remaining errors only act non-trivially on the qubit $q_1$, and they  correspond to a depolarizing channel, with error probability $6p/15$ as follows,   
$\mathcal{D}_{q_1}^{(6p/15)}(\rho) := (1 - \frac{6p}{15}) \rho + \frac{2p}{15} (X \rho X + Y \rho Y + Z \rho Z)$.
%
Some or all of the remaining errors may also be rough errors depending on whether they flip a measurement outcome at one of the next recursion levels. We have the following four cases in order.
%
\paragraph*{If $k$ is the last recursion level, \emph{i.e.}, $k = j$.}
%
In this case, $p_C$ is simply given by the errors that flip the measurement outcome of the corresponding Pauli $Z \otimes Z$ measurement at the $k^{th}$ recursion level. Therefore $p_C = 8p/15$. Further, $\mathcal{W}_C$ is the remaining noise channel after the $k^{th}$ recursion level. Therefore, $\mathcal{W}_C = I_{\mathcal{S}_{i \to j}\setminus {q_1}} \otimes \mathcal{D}_{q_1}^{(6p/15)}$.

\paragraph*{If $k^{\min}_{i \to j} \leq k <  j$ with $b_j = 0$ (hence, only Pauli $X \otimes X$ measurements after the $k^\textbf{th}$ recursion level.)}

In this case, the remaining $Z$ error after the $k^{th}$ level of recursion will flip a Pauli $X \otimes X$ measurement at the $(k+1)^{th}$ level of recursion, while the remaining $X$ errors will not flip any measurement outcome. This implies that the depolarizing channel $\mathcal{D}_{q_1}^{(6p/15)}$ transforms into a bit-flip channel, denoted by $\mathcal{B}_{q_1}^{(2p/15)}$, acting on $q_1$ with error probability $2p/15$. Therefore, $p_C = 12p/15$ and $\mathcal{W}_C = I_{\mathcal{S}_{i \to j}\setminus {q_1}} \otimes \mathcal{B}_{q_1}^{(2p/15)}$.

\paragraph*{If $k^{\min}_{i \to j} \leq k <  j$ with $b_j = 1$ (hence, only Pauli $Z \otimes Z$ measurements after the $k^\textbf{th}$ recursion level.)}

In this case, the remaining $X$  error after the $k^{th}$ level of recursion, will flip a Pauli $Z \otimes Z$ measurement at the $(k+1)^{th}$ level of recursion, while the remaining $Z$ errors will not flip any measurement outcome. This implies that the depolarizing channel $\mathcal{D}_{q_1}^{(6p/15)}$ transforms into a phase-flip channel, denoted by $\mathcal{P}_{q_1}^{(2p/15)}$, acting on $q_1$ with error probability $2p/15$. Therefore, $p_C = 12p/15$ and $\mathcal{W}_C = I_{\mathcal{S}_{i \to j}\setminus {q_1}} \otimes \mathcal{P}_{q_1}^{(2p/15)}$.


\paragraph*{If $k < k^{\min}_{i \to j}$.}
In this case, we have both Pauli $Z \otimes Z$ and $X \otimes X$ measurements afterwards, hence both the remaining $X$ and $Z$ errors after the $k^{th}$ recursion level will be detected in one of the next recursion levels. Therefore, the depolarizing channel $\mathcal{D}_{q_1}^{(6p/15)}$ transforms into the identity channel. Hence, $p_C = 14p/15$ and $\mathcal{W}_C = I_{\mathcal{S}_{i \to j}\setminus {q_1}} \otimes I_{\mathcal{S}_{i \to j}}$.



%
%Let $c_k$ denote the $\cnot$ gate, applied at the $k^{th}$ level of recursion and let $\mathcal{C}$ be the $\cnot$ gates involved in preparation of a $\pone$ code states. We can divide the set $C = \mathcal{C}_1 \cup \mathcal{C}_2 \cup \mathcal{C}_2 \cup \mathcal{C}_3$.  
%


In summary, we have the following for  $p^C_{D}$ and $\mathcal{W}_C$,
\begin{equation} \label{eq:eff_err_cnot_app}
 p^C_{D} = \begin{cases}
 8p/15, & \text{ if $k =  j$. }  \\
 4p/5, & \text{ if $  k^{\min}_{i \to j} \leq k <  j$.} \\
 14p/15, & \text{ otherwise.} \\
\end{cases}
\end{equation}
%
Further, $\mathcal{W}_C = I_{\mathcal{S}_{i \to j} \setminus {q}} \otimes \mathcal{W}_q$, where $\mathcal{W}_q$ is a quantum channel acting on $q$ as follows, 
\begin{equation} \label{eq:eff_noise_cnot_app}
\mathcal{W}_q = \begin{cases}
\mathcal{D}_{q}^{(6p/15)}, & \text{ if $k =  j$ }  \\
 \mathcal{B}_{q}^{(2p/15)}, & \text{ if $k^{\min}_{i \to j} \leq k <  j$, with $b_j = 0$.} \\
  \mathcal{P}_{q}^{(2p/15)}, & \text{if $k^{\min}_{i \to j} \leq k < j$, with $b_j = 1$.} \\
 I_{\mathcal{S}_{i \to j}}, & \text{ otherwise.} \\
\end{cases}
\end{equation}

%
%It can be similarly seen that $\cnot$ gates applied during a Pauli $Z \otimes Z$ or a Pauli $X \otimes X$ measurement, at time step $t = 1, 2$, and at any recursion level $k$ corresponding to $B_{i \to j}$ has the the same $p_C$ and $W_D^C$ as in (\ref{eq:eff_err_cnot_app}) and (\ref{eq:eff_noise_cnot_app}), respectively.


\paragraph{Proof of Lemma~\ref{lem:smooth_total_channel}:} \smallskip From Lemma~\ref{lem:int-eff-err}, the smooth error channel corresponding to initialization at the zeroth level of recursion (with respect to $k^{\min}_{0 \to i}$) is the identity, except when $ \sum_{t = 1}^i b_t = 0$ (it implies that $k^{\min}_{0 \to i} = 1$), when it is a bit flip channel on the corresponding qubit at the output of $B_{0 \to i}$, as in~(\ref{eq:non_eff_int_zero}). Further, from Lemma~\ref{lem:p-w-int-m}, the smooth error channel corresponding to initialization and measurement of the ancilla qubit is always the identity. Furthermore, from Lemma~\ref{lem:p-w-cnot}, the smooth error channel corresponding to $\cnot$ gates for recursion levels $k < k^{\min}_{0 \to i}$ is also the identity. For $k \geq k^{\min}_{0 \to i}$, it is either a depolarizing, bit or phase-flip channel as given in~(\ref{eq:eff_noise_cnot}), acting on the data qubit on which the $\cnot$ gate acts. 
%
Hence, from~(\ref{eq:non_eff_int_zero}) and ~(\ref{eq:eff_noise_cnot}), and noting that one $\cnot$ gate acts on a data qubit $q \in \mathcal{S}_{i \to j}$ at each recursion level (see Fig.~\ref{fig:error_det_big}), it follows that the total smooth channel on each qubit $q \in \mathcal{S}_{0 \to i}$ is an (\emph{i.i.d.}) Pauli channel as follows,
\begin{equation}\label{eq:total_non_eff_channel}
\mathcal{W}_q = \begin{cases}
\mathcal{B}^{(p)}_q \circ (\mathcal{B}^{(2p/15)}_q \circ \stackrel{i}{\cdots} \circ \mathcal{B}^{(2p/15)}_q) \circ \mathcal{D}^{(6p/15)}_q, & \text{if $\sum_{t=1}^i b_t = 0$.}  \\
(\mathcal{B}^{(2p/15)}_q \circ \stackrel{i - k^{\min}_{0 \to i}}{\cdots} \circ \mathcal{B}^{(2p/15)}_q) \circ \mathcal{D}^{(6p/15)}_q, & \text{if $\sum_{t=1}^i b_t \neq 0$ and $b_i = 0$.}  \\
(\mathcal{P}^{(2p/15)}_q  \circ\stackrel{i - k^{\min}_{0 \to i}}{\cdots} \circ \mathcal{P}^{(2p/15)}_q) \circ \mathcal{D}^{(6p/15)}_q, & \text{if $b_i = 1$.}  
\end{cases}
\end{equation}
%
By simplifying~(\ref{eq:total_non_eff_channel}), we can see that $\mathcal{W}_q$ is a Pauli channel, whose  $X$, $Y$, and $Z$ error probabilities are, respectively, upper bounded by $p^{0 \to i}_x, p^{0 \to i}_y$, and $p^{0 \to i}_z$, which are given by,
%
\begin{align}
p^{0 \to i}_x &= \begin{cases}
1- (1-p)(1 - 2p/15)^{i} , & \text{if $\sum_{t=1}^i b_t = 0$.} \\
1-(1 - 2p/15)^{(i - k^{\min}_{0 \to i})+1}, & \text{if $\sum_{t=1}^i b_t \neq 0$ and $b_i = 0$.}  \\
2p/15, & \text{if $b_i = 1$.} 
\end{cases}\\
p^{0 \to i}_y &= 2p/15.  \\
p^{0 \to i}_z &= \begin{cases}
2p/15, & \text{if $b_i = 0$.} \\
1-(1 - 2p/15)^{(i - k^{\min}_{0 \to i})+1}, & \text{if $b_i = 1$.} 
\end{cases} 
\end{align}
%
We note that $p^{0 \to i}_y$ is equal to the $Y$ error probability. Furthermore, $p^{0 \to i}_x$ is equal to the $X$ error probability for $b_i = 1$, and $p^{0 \to i}_z$ is equal to the $Z$ error probability, when $b_i = 0$.
%
%We may now estimate the probability that the preexisting error on a input qubit $q \in \mathcal{S}_{i \to j}$ is effective in $B_{i \to j}$. 
% and let $n_h$ be a subset of 
%
\printbibliography
\end{document}
%     and the sets of qubits $\mathcal{S}^{i_1}_T$ and $\mathcal{S}^{i_2}_T$ are illustrated by ellipses. The box $B_2$ denotes the preparation using Procedure \ref{prot:err_det} up to the second level of recursion and the box $B_{2 \to 4}$ denotes the preparation between the second and fourth level of recursion. Further, a red box denotes that an error is detected during the preparation.
%
%            (B9.north) ++ (-1.40, 0) node[] (at1) {}
%            (at1.north) ++ (0.35, 0) node[] (at2) {}
%            (at1.north) ++ (0.70, 0) node[] (at3) {}
%            (at1.north) ++ (1.05, 0) node[] (at4) {}
%        \draw
%            (B1.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B1.north)++(+0.30, 0) to ++(0, +0.3) 
%            (B2.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B2.north)++(+0.30, 0) to ++(0, +0.3)
%            (B3.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B3.north)++(+0.30, 0) to ++(0, +0.3)
%            (B4.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B4.north)++(+0.30, 0) to ++(0, +0.3) 
%            (B5.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B5.north)++(+0.30, 0) to ++(0, +0.3)
%            (B6.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B6.north)++(+0.30, 0) to ++(0, +0.3)
%            (B7.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B7.north)++(+0.30, 0) to ++(0, +0.3)
%            (B8.north)++(-0.30, 0) to ++(0, +0.3) 
%            (B8.north)++(+0.30, 0) to ++(0, +0.3)
%            ;
% (canal1 -| C.east) to node[above] {$X_1$} (canal1)
%            (canal2 -| C.east) to node[above] {$X_2$} (canal2)
%            (canal1 -| C.west) to ++(-1, 0) node[left] {$U_1$}
%            (canal2 -| C.west) to ++(-1, 0) node[left] {$U_2$}
%            (canal1.east) to ++(1, 0) node[right] {$Y_1$}
%            (canal2.east) to ++(1, 0) node[right] {$Y_2$}
            
\subsection{A Lower bound on the preparation rate and the output error probability}
Suppose at the end of step ($5$) of the factory preparation, we have successfully prepared $T'$ copies of $\ket{q_N}$. Then, the rate of the factory preparation, denoted by $p_{prepf}$, is as follows
\begin{equation}
p_{prepf} = \lim_{T \to \infty} \frac{T'}{T}. 
\end{equation}

%In this section, we provide a lower bound on the rate of factory preparation, supposing the following assumptions.


In this section, we provide a lower bound on the rate of factory preparation, supposing the standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$ measurements and suppose the independent and identically distributed ($i.i.d$) noise model, where each components fails with probability $p$, as given in Section \ref{sec:prep-n}.

\subsection{Success rate of $B_{i \to j}$}

We define the success rate of $B_{i \to j}$ to be the probability of implementing $B_{i \to j}$ successfully, without any error detection, given that all the recursion levels $k \leq i$ have been implemented perfectly, without any faults.  We shall dente the sucess rate of $B_{i \to j}$ as $p_{i \to j}$.

\smallskip

Let $\mathcal{C}_{i \to j}$ be the set of all components of $B_{i \to j}$. Note that $B_{i \to j}$ consists of $j - i$ levels of recursion, hence a total $\frac{j-i}{2}\log_2(j-i)$ two qubit Pauli measurements are performed during the implementation of $B_{i \to j}$. As we have four components per two qubit measurement, we have that 
%
\begin{equation}
|\mathcal{C}_{i \to j}| = 2(j-i)\log_2(j-i).
\end{equation}

We associate, with any component $C \in \mathcal{C}_{i \to j}$, a random variable $E_C \in \{0, 1\}$, which indicates whether or not a given component has failed. We suppose that $E_C$ takes value $1$ if a fault has occured in the implementation of $C$, otherwise it takes value $1$. Note that
\begin{equation} \label{eq:fault_C}
\pr(E_C = 1) = p.
\end{equation}
%
We further consider a random variable $D_{i \to j} \in \{0, 1\}$ to represent, whether an error is detected during an implementation of $B_{i \to j}$. Similarly, we suppose the random variable $D_{i \to j}$ takes value $0$ if no error is detected, otherwise it takes value $0$. 

\smallskip
Note that $B_{i \to j}$ is successfully implemented if and only if $D_{i \to j} = 0$, hence, $p_{ i \to j} = \pr(D_{i \to j} = 0)$. To estimate $\pr(D_{i \to j} = 0)$, we will make the following simplifying assumptions. 

\smallskip
\emph{A single component failure for some $C \in\mathcal{C}'_{i \to j}$ is detected if the corresponding error propagates to at least one measurement outcome.}

\smallskip Considering the above assumption, we associate for each $C \in\mathcal{C}'_{i \to j}$ an effective failure probability, denoted by, $p_C$, which corresponds to the probability that both $E_C$ and $D_C$ are $1$, that is,
%
\begin{equation}
 p_C = \pr(D_C = 1 \mid E_C = 1) \pr(E_C = 1). 
\end{equation}
%
Then, the success probability can be lower bounded as follows,
\begin{equation}
p_{i \to j} \geq \prod_{C \in \mathcal{C}_{i \to j}} (1 - p_C).
\end{equation}






Given that $\mathcal{C}'  \subset \mathcal{C}_{i \to j}$ corresponds to the set of components that are failed during the implementation of $B_{i \to j}$,  $\pr\big(D_{i \to j} = 1 \mid E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big)$ denotes the probability that $B_{i \to j}$ succeeds.

\smallskip 
Using Bayes' rule for conditional probabilities, we may write,
\begin{align}
\pr(D_{i \to j} = 0) &= \sum_{\mathcal{C}' \subseteq \mathcal{C}_{i \to j} }\pr\big(D_{i \to j} = 0 \mid E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) \nonumber \\
& \hspace*{50mm} \pr\big(E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) \nonumber \\
&=  \sum_{k = 0}^{|\mathcal{C}_{i \to j}|} \Big( \sum_{|\mathcal{C}'| = k} \pr\big(D_{i \to j} = 0 \mid E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) \Big) p^k (1-p)^{|\mathcal{C}_{i \to j}| - k} \nonumber \\
& = (1-p)^{|\mathcal{C}_{i \to j}| }  + \nonumber \\
& \hspace*{5mm}  \sum_{k = 1}^{|\mathcal{C}_{i \to j}|} \Big( \sum_{|\mathcal{C}'| = k} \pr\big(D_{i \to j} = 0 \mid E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) \Big) p^k (1-p)^{|\mathcal{C}_{i \to j}| - k},
\end{align}
where in the second inequality, we have used that $\pr\big(E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) = p^k (1-p)^{|\mathcal{C}_{i \to j}| - k}$ and in the third inequality, we have used $\pr\big(E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) = 1$ if $|\mathcal{C}'| = 0$.

\smallskip
To evaluate $\pr(D_{i \to j} = 0)$, we shall consider the following simplification. We suppose that if the error generated by a faulty component $C \in \mathcal{C}'$ propagates to at least one measurement outcome, it will be detected, $i.e.$, $\pr\big(D_{i \to j} = 1 \mid E_C = 1, \forall C \in \mathcal{C}', \sum_{C \not \in \mathcal{C}'} E_{C} = 0 \big) = 1$. We determine the probability that a component failure propagates 


error propagates to an 


set of components in $B_{i \to j}$ from which 

We suppose that 

%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{1.7em}\setlength{\listparindent}{0em}}
%
%\item[1] We may suppose that an error is detected 
%
%\end{list}

%Note that $D_{i \to j} = 1$ if and only if $E_C = 1$, for at least one of the components $C \in \mathcal{C}_{i \to j}$. Hence, we have that 
%\begin{equation}
%\pr(D_{i \to j} = 1 \mid \sum_{C  \in \mathcal{C}_{i \to j}  } E_{C} = 0) = 0.
%\end{equation}
%

\subsection{Preparation rate of factory preparation}




 Hence, we have that
\begin{equation}
\pr(D_{i \to j} = 1 \mid \sum_{C  \in \mathcal{C}_{i \to j}  } E_{C} = 0) = 0.
\end{equation}



% In the following, we will try to compute
%
%
%
%
%
%We say an error detection is caused by a subset of components $\mathcal{C}'_{i \to j} \subseteq \mathcal{C}_{i \to j}$ component if we have that
%\begin{equation}
%D_{i \to j} = 1 \mid E_C = 1, \forall C \in \mathcal{C}'_{i \to j}, \sum_{C \not \in \mathcal{C}'_{i \to j}  } E_{C} = 0.
%\end{equation}
%%
%
%Further, using bayes rule of the conditional probability, we have that,
%
%
%Further, we will say a component $C$ causes an error detection if $\mathcal{C}$ is the only component that failed and 
%
%
% following two conditions hold,
%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%
%\item[\cal{A}.$(i)$] 
%
%\item[\cal{A}.$(ii)$]
%\end{list}
%
%Further, we associate with $C$ another random variable $D_C \in \{0, 1\}$, which will indicate if component $C$ causes an error detection in the implementation of $B_{i \to j}$. Similarly, we suppose the random variable $D_C$ takes value $0$ if $\mathcal{C}$ causes an error detection, otherwise it takes value $0$. 
%
%
%
%If the component $C$ is implemented perfectly without any fault, it can never lead to an error detection, hence, we have that
%\begin{equation}
%\pr(D_C = 1 \mid E_C = 0) = 0.
%\end{equation}
%Hence, we may further write using~(\ref{eq:fault_C}),
%\begin{equation}
%\pr(D_C = 1) = \pr(D_C = 1 \mid E_C = 1, \sum_{C' \neq C} E_{C'} = 0) p
%\end{equation}
%
%Consider 
%
%
%To derive an upper bound on $p_{i \to j}$, we consider that detection of a component failure is independent of other component failures, $i.e$, the probability that a component failure is detected during the preparation doesn't depend on whether other components failed or not. 




%\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{2.5em}\setlength{\listparindent}{0em}}
%
%\item[\cal{A}.$(i)$] We suppose the standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$ measurements as in Section~\ref{sec:prep-n}. We also suppose the $i.i.d$ noise model, where each components fails with probability $p$, as in Section \ref{sec:prep-n}.
%
%
%\item[\cal{A}.$(ii)$] We consider that detection of a component failure is independent of other component failures, $i.e$, the probability that a component failure is detected during the preparation doesn't depend on whether other components failed or not. 
%
%%\item[\cal{A}.$(iii)$] A Pauli $Z$ (Pauli $X$) error, which happened during $i^{th}$ level of recursion, is detected if there is a recursion level $j > i$, such that $b_j = 1$ ($b_j = 0$).
%\end{list}


%Supposing the above assumption, we will first compute the probability of implementing $B_{i \to j}$ successfully. 
%
%probability that an error is detected during the implementation of $B_{i \to j}$. 
%
%Note that $B_{i \to j}$ consists of $j - i$ levels of recursion, hence a total $\frac{j-i}{2}\log_2(j-i)$ two qubit Pauli measurements are performed during the implementation of $B_{i \to j}$. As we have four components per two qubit measurement, $B_{i \to j}$ consists of $2(j-i)\log_2(j-i)$ components.
%
%
%Let $\mathcal{C}_{i \to j}$ be the set of all components of $B_{i \to j}$ and consider a component $C \in \mathcal{C}_{ij}$ applied at the $k^{th}$ level of recursion. Taking advantage of the assumption \cal{A}.$(i)$, we may associate, with any component $C \in \mathcal{C}_{i \to j}$, a random variable $E_C \in \{0, 1\}$, which indicates whether or not a given component has failed. We suppose that $E_C$ takes value $1$ if a fault has occured in the implementation of $C$, otherwise it takes value $1$. Note that $\pr(E_C = 1) = p$.




%We consider another random variable $D_C$ to indicate whether the failure of $C$ leads to an error detection, if $C$ is the only component were to fail in $\mathcal{C}_{i \to j}$. Similarly, we suppose the random variable $D_C$ takes value $0$ if $C$ leads to an error detection, otherwise it takes value $0$.

%We consider another random variable $D_C$ to indicate whether the component $C$ leads to an error detection. Similarly, we suppose the random variable $D_C$ takes value $0$ if $C$ leads to an error detection, otherwise it takes value $0$. 
% leads to an error detection, if this is the only component that failed.


%Similarly, taking advantage of the assumption \cal{A}.$(ii)$, we may associate  with $C \in \mathcal{C}_{i \to j}$ another random variable $D_C$, which indicates whether a component leads to an error detection.  Similarly, we suppose the random variable $D_C$ takes value $0$ if a component leads to an error detection, otherwise it takes value $0$. As if the component $C$ is implemented perfectly without any fault, it can never lead to an error detection, hence, we have that $\pr(D_C = 1 \mid E_C = 0) = 0$.
%
%\smallskip
%Now, it can be easily seen that the probability that $B_{i \to j}$ is implemented successfully is given as follows,
%%
%\begin{equation}
%p_{i \to j} = \prod_{C \in \mathcal{C}_{i \to j}} \big(1 - \pr(E_C = 1, D_C = 1)\big), 
%\end{equation}
%where we can further simplify $\pr(E_C = 1, D_C = 1) = \pr(D_C = 1 \mid E_C = 1) p $.

 

%\subsection{An lower bound on the output error probability }

\end{document}


\subsection{Recursive measurement-based preparation with noise}
%
In \cite{goswami2022fault}, we have standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$ measurements, where a bare ancilla qubit is initialized in either Pauli $Z$ or Pauli $X$ basis state, then two CNOT gates are applied between data and ancilla qubits, and finally the ancilla qubit is measured in Pauli $Z$ or $X$ basis. Therefore, any two-qubit Pauli measurement decomposes into four basic \emph{components}, namely one single-qubit initialization, two $\cnot$-gates, and one single-qubit measurement.




\paragraph{Measurement Based Preparation of $\pone$ code-states:}

The conventional encoding of quantum polar codes in Fig.~\ref{fig:qpolar_N8} is not fault-tolerant, as errors propagate  through the $\cnot$ gates. Further, measuring the stabilizer generators using the  standard ``phase kickback trick''~\cite{gottesman2010introduction}, similar to the case of quantum LDPC codes~\cite{gottesman2014fault}, is also not fault-tolerant, due to the high weights of generators.

\smallskip Hence, we propose a new procedure to prepare $\pone$ code-states, based on two-qubit Pauli measurements only. We describe our procedure in two steps. First, we assume that all the operations are error free, and show that the proposed procedure does indeed prepare a $\pone$ code-state. Then, we consider our procedure under the effect of errors (\emph{i.e.}, noisy gates and measurements), and show that it can be made fault-tolerant by incorporating an error detection gadget, exploiting the redundancy in the measurement outcomes. 


\smallskip We consider the preparation of logical $\ket{0}$ and $\ket{+}$ states, for which all the input qubits are frozen in  either $Z$ or $X$ basis. Consequently,  we consider the preparation of general $\pone$ code-states, with frozen sets $\mathcal{Z} = \{1,\dots,i\}$ and $\mathcal{X} = \{i + 1,\dots,N\}$, for some arbitrary $ 1 \leq i \leq N$, where $N=2^n$,  $n \geq 1$. Further, since our preparation procedure is recursive, to clearly indicate the length of the prepared $\pone$ state, we will use the notation $i(n) \eqdef i$, $\mathcal{Z}(n) \eqdef \mathcal{Z}$, and $\mathcal{X}(n) \eqdef \mathcal{X}$. Therefore, we want to prepare the following $N$-qubit $\pone$ state on the system $\mathcal{S} = \{1, \dots, N\}$,
\begin{equation}
\ket{q_N}_\mathcal{S} := Q_N \left( \ket{\bm{u}, \oline{\bm{v}}}_\mathcal{S}\right) = Q_N \left(\ket{\bm{u}}_{\cl{Z}(n)} \otimes \ket{ \oline{\bm{v}}}_{\cl{X}(n)}\right), \label{eq:q-prep-state}
\end{equation}
where $\bm{u} \in \{0,1\}^{i(n)}$ and $\bm{v} \in \{0,1\}^{N - i(n)}$. When no confusion is possible, we may simply write $\ket{q_N}$ instead of $\ket{q_N}_\mathcal{S}$. Here, we consider $\pone$ states defined by the same value of $i(n)$ as equivalent, regardless of the corresponding frozen values $\bm{u}, \bm{v}$. Indeed, equivalent $\pone$ states are defined by the same stabilizer generators, up to sign factors.



To prepare $\ket{q_N}_\mathcal{S}$ from (\ref{eq:q-prep-state}), we consider the following measurement based procedure.

\begin{procedure}[Measurement Based Preparation] \label{prot:prep}
Given a $n$-bit sequence $b_1\cdots b_n \in \{0, 1\}$, our measurement based procedure on $N = 2^n$ qubit system $\mathcal{S} = \{1, \dots, N\}$ is as follow.

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{1.7em}\setlength{\listparindent}{0em}}

\item[$(1)$] First, $\mathcal{S}$ is initialized in a Pauli $Z$ basis state $\ket{\bm{u}}_{\mathcal{S}}, \bm{u} \in \{0, 1\}^N$.


\item[$(2)$] Then, two-qubit Pauli measurements are recursively applied for $n$ levels. The recursion is the same as the recursion of the quantum polar transform (see Fig. \ref{fig:qpolar_N8}), except the $\cnot$ gate is replaced by either Pauli $X \otimes X$ or $Z \otimes Z$ measurement. Precisely, if $b_k = 0$ (or, $b_k = 1$), we apply Pauli $X \otimes X$ (or, $Z \otimes Z$) measurements at the $k^{th}, k = 1, \dots, n$ recursion level.
\end{list}
%
\end{procedure}


\begin{theorem} \label{thm:Q1_code_prep}
Consider the $\pone$ state $\ket{q_N}_\mathcal{S}$ from (\ref{eq:q-prep-state}), with $1 \leq i(n) \leq N$. Let $b_1\cdots b_n$ be the binary representation of $i(n)-1$, with $b_n$ being the most significant bit, $i.e$, $i(n)-1 = \sum_{k=1}^{n} b_k 2^{k-1}$. Then, $\ket{q_N}_\mathcal{S}$ can be prepared, using the measurement based procedure in Procedure \ref{prot:prep}, corresponding to the $n$ bit sequence $b_1\cdots b_n$.
\end{theorem}
%
The measurement based preparation for $N = 8, i(n) = 3$ is illustrated in Fig. \ref{fig:qpolarprep_N8_i3}.

\smallskip We first show in Lemma \ref{lem:Q1_code_prep} that given two equivalent $\pone$ states of length $K/2, K = 2^k$, we can prepare a $\pone$ state of length $K$ by performing $Z \otimes Z$ or $X \otimes X$ measurements transversely on them. Further, when we apply Pauli $Z \otimes Z$ measurements, we have $i(k) = i(k-1) +  K/2 > K/2$ and when we apply Pauli $X \otimes X$ measurements, we have $i(k) = i(k-1) \leq K/2$. The proof of Theorem \ref{thm:Q1_code_prep} then simply follows from Lemma \ref{lem:Q1_code_prep}, by noting that $b_k = 1 \Leftrightarrow i(k) > K/2$ (hence, $b_k = 0 \Leftrightarrow i(k) \leq K/2$).


\begin{lemma} \label{lem:Q1_code_prep}
Consider two equivalent $\pone$ states on $K/2$-qubit systems $\mathcal{S}_1 : = \{1, \dots, K/2 \}$ and $\mathcal{S}_2 : = \{K/2+1, \dots, K\}$ as follows, $\ket{q_{\frac{K}{2}}^1}_{\mathcal{S}_1} \eqdef Q_{\frac{K}{2}} \ket{\bm{u_1}, \oline{\bm{v}}_{\bm{1}}}_{\mathcal{S}_1}$ and $\ket{q_{\frac{K}{2}}^2}_{\mathcal{S}_2} \eqdef Q_{\frac{K}{2}} \ket{\bm{u_2}, \oline{\bm{v}}_{\bm{2}}}_{\mathcal{S}_2}$, where $\bm{u_1}, \bm{u_2} \in \{0, 1\}^{i(k-1)}$ and $\bm{v_1}, \bm{v_2} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$, with $1 \leq i(k-1) \leq K/2$. Let $\mathcal{S} := \mathcal{S}_1 \cup \mathcal{S}_2$ be the joint system, then we have the following two cases.



\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{0.3em}\setlength{\listparindent}{0em}}
\item Case $1$: If we apply transversal Pauli $Z \otimes Z$ measurements on the corresponding qubits of $\cl{S}_1$ and $\cl{S}_2$, we get the $K/2$ bit measurement outcome as follows,
\begin{equation}
 \bm{m} = P_\frac{K}{2}(\bm{u'}, \bm{x}) \in \{0, 1\}^{\frac{K}{2}}, \label{eq:m-out}
\end{equation}
where $\bm{u'} = \bm{u_1} \oplus \bm{u_2} \in \{0, 1\}^{i(k-1)}$ and  $\bm{x} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$ is a random vector, and $P_{\frac{K}{2}}$ is the classical polar transform. After measurements, the state of $\mathcal{S}$ is a $\pone$ state, $\ket{q_K}_\mathcal{S} =  Q_K \ket{(\bm{u'}, \bm{x}, \bm{u_2}), \overline{\bm{v_1} \oplus \bm{v_2}}}_\mathcal{S}$, with $i(k) = i(k-1) + K/2 > K/2$, and where $\bm{x}$ is determined from the measurement outcome $\bm{m}$ in (\ref{eq:m-out}) by, $\bm{x} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{X}(k-1)}$, $i.e.$, the subvector of  $P_{\frac{K}{2}}(\bm{m}) \in \{0, 1\}^{K/2}$ corresponding to indices in the set $\mathcal{X}(k-1)$. 



\item Case $2$: If we apply transversal Pauli $X \otimes X$ measurements on the corresponding qubits of $\cl{S}_1$ and $\cl{S}_2$, we get the $K/2$ bit measurement outcome as follows,
\begin{equation}
 \bm{m} = P_\frac{K}{2}^\top(\bm{z}, \bm{v'}) \in \{0, 1\}^{\frac{K}{2}}, \label{eq:m-out-x}
\end{equation}
where $\bm{z} \in \{0, 1\}^{i(k-1)}$ is a random vector, and $\bm{v'} = \bm{v_1} \oplus \bm{v_2} \in \{0, 1\}^{\frac{K}{2}-i(k-1)}$. After measurements, the state on $\mathcal{S}$ is a $\pone$ state $\ket{q_K}_\mathcal{S} = Q_K \ket{\bm{u_1} \oplus \bm{u_2}, \overline{(\bm{v_1},  \bm{z},  \bm{v'})}}_\mathcal{S}$, with $i(k) = i(k-1) \leq K/2$ and from (\ref{eq:m-out-x}), $\bm{z} = P_{\frac{K}{2}}^\top (\bm{m})\lvert_{\mathcal{Z}(k-1)}$.

\end{list}
\end{lemma}


% Figure environment removed


\paragraph{Fault-tolerant measurement based procedure:} 
Consider standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$ measurements, using an ancilla qubit, as depicted in Figure. Then, the measurement based procedure consists of the following basic components; initialization in a Pauli $X$ or $Z$ basis state, $\cnot$ gate on two qubits, measurement in Pauli $X$ or $Z$ basis. Further, the total number of components in the preparation of a $\pone$ qubit state, denoted here by C, is as follows \cite{goswami2022fault},
\begin{equation} \label{eq:num-comp}
C = N (1 + 2 \log N)
\end{equation}

\smallskip We further assume that each component fails independently with some probability $p$, according to a circuit level Pauli noise model as follows.

%Recall that our recursive procedure consists of two main operations; intialization in a Pauli $Z$ basis state and Pauli $Z\otimes Z$ or $X\otimes X$ measurements. 

\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{0.3em}\setlength{\listparindent}{0em}}

\item[$1$] A failure in initialization in Pauli $Z$ (or $X$) basis corresponds to the perfect initialization, followed by an $X$ (or $Z$) error on the initialized qubit.

\item[$2$] A failure in a CNOT gate corresponds to applying the perfect CNOT gate, followed by a two-qubit Pauli error on the output qubits of the CNOT gate. 

\item[$3$] A failure in Pauli $Z$ (or $X$)  measurement corresponds to first applying a Pauli $X$ (or $Z$) error on the qubit to be measured, and then doing the perfect Pauli $Z$ (or $X$) measurement.

\end{list}
%We now consider our measurement based procedure under the effect of Pauli noise. We assume the standard implementation of Pauli $Z \otimes Z$ and $X \otimes X$  measurements, where a bare ancilla qubit is initialized in either Pauli $Z$ or Pauli $X$ basis state, then two CNOT gates are applied between data and ancilla qubits, and finally the ancilla qubit is measured in Pauli $Z$ or $X$ basis. Therefore, any two-qubit Pauli measurement decomposes into four basic \emph{components}, namely one single-qubit initialization, two $\cnot$-gates, and one single-qubit measurement. 

%\smallskip As the preparation of $\ket{q_N}_\mathcal{S}$ consists of $N$ single-qubit initializations, followed by $N/2 \log N$ two-qubit Pauli measurements, the total number of components in the preparation is equal to $N (1 + 2 \log N)$.


\smallskip The measurement based procedure is not fault-tolerant by itself under the above noise model. Due to failures in the components, the measurement outcomes of transversal Pauli $Z \otimes Z$ or $X \otimes X$ measurements are error corrupted as follows, for some $\bm{e}_X, \bm{e}_Z \in \{0, 1\}^{K/2}$ 
%
\[ m =   
\begin{cases}
P_\frac{K}{2}(\bm{u'}, \bm{x}) \oplus \bm{e}_X & \text{ for Pauli $Z \otimes Z$ measurement}\\
P_\frac{K}{2}^\top(\bm{z}, \bm{v'}) \oplus \bm{e}_Z & \text{ for Pauli $X \otimes X$ measurement}
\end{cases}
\] 
%
Note from Lemma, that the measurement outcome $\bm{m}$ is used to determine a part of the frozen $X$ or $Z$ values of the prepared state. Hence, error corrupted measurement may lead to the incorrect determination of frozen values, hence making the preparation not fault-tolerant. To remedy this an error detection gadget is incorporated into the measurement based preparation (see Procedure \ref{prot:err_det} below), and further the measurement based preparation with the error detection is shown to be fault-tolerant \cite[Theorem 3]{goswami2022fault}.
%
\begin{procedure}[Measurement based Preparation with Error Detection] \label{prot:err_det}
Consider the preparation of a $\pone$ state of length $N$ from Procedure~\ref{prot:prep}.  We further incorporate an error detection gadget within each level of reccursion, $k=1,\dots, n$, consisting of the following two steps.


\begin{list}{}{\setlength{\labelwidth}{2em}\setlength{\leftmargin}{1.7em}\setlength{\listparindent}{0em}}
\item[$(1)$]  For all $2^{n-k}$ instances of prepared $\ket{q_K}$ states at the $k^{th}$ level of recursion, we first determine the syndrome of the error in the measurement outcome $\bm{m}$ as follows. When Pauli $Z \otimes Z$ measurements are performed ($i.e$, Case $1$ of Lemma \ref{lem:Q1_code_prep}), we determine the syndrome of the error term $\bm{e}_X$ in the measurement outcome $\bm{m}$ as, $P_{\frac{K}{2}}(\bm{e}_X) \lvert_{\mathcal{Z}(k-1)} = P_{\frac{K}{2}}(\bm{m})\lvert_{\mathcal{Z}(k-1)} \,\oplus\, \bm{u'}$. Similarly, when Pauli $X \otimes X$ measurements are performed ($i.e$, Case $2$ of Lemma \ref{lem:Q1_code_prep}), we determine the syndrome of the error term $\bm{e}_Z$ as, $P_{\frac{K}{2}}^\top(\bm{e}_Z) \lvert_{\mathcal{X}(k-1)} = P_{\frac{K}{2}}^\top(\bm{m})\lvert_{\mathcal{X}(k-1)} \,\oplus\, \bm{v}'$. 


\item[$(2)$] If the syndrome is the zero vector for all the $2^{n-k}$ instances of $\ket{q_K}$, we determine the value of $\bm{x}$ or $\bm{z}$ for all prepared states as in Lemma~\ref{lem:Q1_code_prep}, and proceed to the next level of recursion. Otherwise, we declare a preparation failure.
 
\end{list}
\end{procedure}

%noisy. Precisely, we have 

%$\bm{m} = P_\frac{K}{2}(\bm{u'}, \bm{x}) \oplus \bm{e}_X$ instead of (\ref{eq:m-out}), and $\bm{m} = P_\frac{K}{2}^\top(\bm{z}, \bm{v'}) \oplus \bm{e}_Z$ instead of (\ref{eq:m-out-x}), where $\bm{e}_X, \bm{e}_Z \in \{0, 1\}^{K/2}$ are unknown error terms. Recall from Lemma \ref{lem:Q1_code_prep} that vectors $\bm{x}$ and $\bm{z}$ are determined from $\bm{m}$, and they are necessary to know the prepared state $\ket{q_K}_\mathcal{S}$ after Pauli $Z \otimes Z$ and $X \otimes X$ measurements, respectively.  However, due to unknown error terms, the methods in Lemma \ref{lem:Q1_code_prep} may not correctly determine $\bm{x}$ and $\bm{z}$.  Accepting a wrong estimate $\hat{\bm{x}} \neq \bm{x}$ and  $\hat{\bm{z}} \neq \bm{z}$ amounts to extra $X$ and $Z$ errors on the respective prepared states, given by the vectors $P_K(0, \hat{\bm{x}} \oplus \bm{x}, 0, 0)$, and $P_K^\top(0, 0, \hat{\bm{z}} \oplus \bm{z}, 0)$, respectively. 

 
%\smallskip To make the measurement based preparation fault-tolerant, we consider the following error detection procedure. 


%



\smallskip The fault-tolerance of the successfully prepared state ($i.e.$, when errors are not detected at any recursion level $k = 1 \text{ to } n$), follows from Theorem \ref{thm:fault_tolerance}.



\begin{theorem} \label{thm:fault_tolerance}
Consider the measurement based preparation with error detection from Procedure \ref{prot:err_det}. Suppose a successful preparation of $\ket{q_N}$, where $T_n$ component failures occur during the preparation.  Let $\bm{e}_X^f, \bm{e}_Z^f \in \{0, 1\}^N$ be the final Pauli $X$ and $Z$ errors in the noisy prepared state $\ket{q^\prime_N}$, due to the component failures. Then, there exist equivalent errors  $\bm{e}_X^{\prime f} \equiv \bm{e}_X^f $ and $\bm{e}_Z^{ \prime f} \equiv \bm{e}_Z^f$, so that $\wt(\bm{e}_X^{\prime f}) \leq T_n$ and $\wt(\bm{e}_Z^{\prime f}) \leq T_n$, where $\wt(\bm{u})$ denotes the Hamming weight of $\bm{u}$.
\end{theorem}
%
Theorem \ref{thm:fault_tolerance} implies that the weight of $X$ and $Z$ errors on a successfully prepared state remains small given a sufficiently low component failure probability $p$. In particular, it upper bounds the average weight of the final error by $N(1+ 2 \log N)p$. Our numerical simulation suggests that the average error weight is much lower than $N(1+ 2 \log N)p$, which is expected as we discard the preparations where errors are detected. 



\paragraph{Fault-tolerant error correction:} For fault-tolerant error correction of $\pone$ codes, we consider Steane error correction. The $\pone$ states, needed in the Steane error correction, are prepared using Procedure \ref{prot:err_det}, assuming a circuit-level depolarizing noise model.  Further, as Procedure \ref{prot:err_det} consists of error detection, we consider polar code-states of small lengths $N = 16, 64$.  



\smallskip Let $p_{\text{prep}}= \lim_{R \to \infty} \frac{t}{R}$ be the preparation rate, where $t$ is the number of successful preparations out of $R$ preparation attempts. For a component failure probability $p = 10^{-3}$, % and $R = 10^{5}$, 
our numerical simulation gives $p_{\text{prep}} \approx 0.88$ and $p_{\text{prep}} \approx 0.47 $, respectively, for $\pone(N = 16, i = 7)$ and $\pone(N = 64, i = 23)$ codes. 


\smallskip The numerical estimate of the LER  for $\pone$ and Shor codes of length $N=16$ and $N=64$ qubits are given in Fig.~\ref{fig:p1_vs_shor}. The LER has been estimated by Monte-Carlo (MC) simulation of the Steane error correction procedure, until a number of $f$ logical errors are reported, where $f$ is taken to be between $50$ and $200$. We also provide a theoretical upper-bound of the LER based on density evolution (DE), providing a trustworthy extrapolation of the LER for smaller values of $p$. 
%
It can be also observed that the pseudothreshold (crossing point between the LER curve and the diagonal line \cite{svore2006flow, tomita2014low}) of the $\pone(N=16, i=7)$ code is $p_\text{th} \approx  0.001$, while for the  $\pone(N=64, i=23)$ code,  we get $p_\text{th} \approx  0.01$.


% Figure environment removed

\smallskip A natural extension of this work is to prepare longer $\pone$ states with high success probability. One possible approach is to replace the error detection mechanism incorporated in the preparation procedure, by an error correction one (ongoing work), allowing correcting errors on the fly, thus avoiding restarting the preparation procedure from the beginning. 


\paragraph*{Acknowledgment:}
This work was supported by the QuantERA grant EQUIP, by the French Agence Nationale de la Recherche, ANR-22-QUA2-0005-01.

\bibliographystyle{unsrt}
\bibliography{biblio_database}

\end{document}


