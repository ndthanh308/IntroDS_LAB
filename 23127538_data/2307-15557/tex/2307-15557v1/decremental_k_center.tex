\section{Decremental $k$-center on graphs}\label{sec:decremental}
In the decremental setting, the input graph of the $k$-center instance is subject to edge deletions.
Based on Lemma~\ref{lem:2b-approx_Gr}, in order to get a $(2 + \epsilon)$-approximation decremental
algorithm for the $k$-center problem, it is sufficient to develop a decremental algorithm for the 
\kbtors problem on $r$-threshold graphs. To maintain the necessary information for $r$-threshold
graphs, we use a decremental SSSP algorithm on $G$.

\subsection{Decremental \kbtors on $G_r$}
For the sake of efficiency, in order to maintain the necessary information
for $r$-threshold graphs, we make use of the approximate SSSP algorithm of 
Theorem~\ref{th:decr_appr_sssp}. Thus, we obtain instead the following theorem
which is a slight relaxation of the decremental \kbtors problem on $r$-threshold graphs.
This is still sufficient for the $k$-center problem, as Lemma~\ref{lem:2b_Gr_H}
suggests.

\begin{theorem} \label{th:res_dec_tors}
    Consider a graph $G = (V, E, w)$ subject to edge deletions, an integer $k \geq 1$, and positive parameters $r,\epsilon$. 
    Let $r' := (1+\epsilon)r$ and consider the threshold graphs $G_r$ and $G_{r'}$.
    Then, there is a deterministic algorithm which:
    \begin{itemize}[topsep=0pt,itemsep=-1ex,partopsep=1ex,parsep=1ex]
        \item either reports that there is an independent set in $G_r$ of size at least $k + 1$,
        \item or runs a \kbtors algorithm $\mathcal{B}$ on an edge-subgraph $H$ of $G_{r'}$ with
        the following condition: whenever $\mathcal{B}$ reports that
        there is an independent set in $H$ of size at least $k + 1$, then
        there is an independent set in $G_r$ of size at least $k + 1$.
    \end{itemize}
    The total update time of the algorithm is $\tilde{O}(m^{1+o(1)}k)$.
\end{theorem}


Recall that in the definition of an \abrs, the first property is that the distance between any two vertices
in the \abrs is at least $\alpha$. The crucial observation here is that under edge deletions, the distance between any 
two vertices is non-decreasing. Hence the first property is preserved in the decremental setting, and this is the major
ingredient for the algorithm.

\paragraph{Algorithm of Theorem~\ref{th:res_dec_tors}.}
In the beginning, the algorithm executes a static \tors algorithm $\mathcal{B}$ on $G_r$.
One simple algorithm for this problem is to run $k$ times the Dijkstra's algorithm on $G$.
In particular, at each iteration we choose a vertex $s$ which has not been covered yet, 
and we run Dijkstra's algorithm on $G$ with source $s$. Then, 
every vertex $v$ of distance at most $r$ from $s$ is set as covered, and the same process is repeated at most $k$
times. The running time of this algorithm is clearly $\tilde{O}(mk)$.

Let $M$ be the \tors in $G_r$ returned by $\mathcal{B}$. 
Then, we initialize a decremental approximate SSSP algorithm $\mathcal{A}$ with super-source $M$ on $G$, providing distance 
estimates $\delta(\cdot)$.\footnote{Namely, we introduce a fake root $x$ and 
add an edge $(x, v)$ of zero weight, for every $v \in M$. Then, we run a decremental approximate SSSP algorithm
with source $x$ on $G$.}
Specifically, we use the $(1 + \epsilon)$-approximate SSSP algorithm of Theorem~\ref{th:decr_appr_sssp}.
Also let $H$ be a graph whose edge set  contains all the edges $(u, v) \in V \times V$ such that
$\delta(v) \leq r'$, and $u \in M$ is the corresponding vertex for the distance estimate $\delta(v)$.
The graph $H$ can be explicitly constructed during the previous step.


Whenever there is an edge deletion in $G$, we pass this update to $\mathcal{A}$. In turn,
this update can possibly increase the distance estimate $\delta(\cdot)$ of some vertices. 
In particular, whenever the distance estimate $\delta(v)$ of a vertex $v \in V$ becomes greater
than $r'$, we add $v$ to $M$, and the algorithm $\mathcal{A}$ is restarted with super-source the
modified set $M$. Moreover, the graph $H$ is recomputed from scratch as before.

At any moment, if the size of $M$ has exceeded $k$, the algorithm reports that there is an independent set
in $G_r$ of size at least $k + 1$, and we do not restart the algorithm $\mathcal{A}$ anymore.

\paragraph{Proof of Theorem~\ref{th:res_dec_tors}.}

Initially the static algorithm produces a \tors $M$ in $G_r$.
At any moment, if the size of $M$ becomes at least $k + 1$, the algorithm reports
that there is an independent set in $G_r$ of size at least $k + 1$.
The next lemma shows the correctness of this step.

\begin{lemma} \label{lem:dist_alpha_IS}
    If the size of $M$ is at least $k + 1$, then there is
    an independent set in $G_r$ of size at least $k + 1$.
\end{lemma}
\begin{proof}
    Initially, $M$ is a \tors in $G_r$, and by definition $M$ is 
    also an independent set in $G_r$. Thus, if the size of $M$
    is at least $k + 1$ after the execution of the static algorithm, 
    the set $M$ remains an independent set in $G_r$ under edge deletions, and the claim holds.

    Hence, we can assume that the size of $M$ became at least $k + 1$ after some edge deletions.
    We prove the claim by contradiction. 
    Suppose to the contrary that $M$ is not an independent set in $G_r$ after an edge deletion. 
    In this case, the algorithm must have added 
    a vertex $v$ to $M$ which has a neighbor $u \in M$ in $G_r$ (i.e., $d_G(u, v) \leq r$). 
    Since $u \in M$, in the algorithm
    we maintain the decremental $(1+\epsilon)$-SSSP algorithm with super-source $M$, and by 
    Theorem~\ref{th:decr_appr_sssp} it holds that
    $\delta(v) \leq (1+\epsilon)d_G(u, v) \leq r'$.
    But then, the algorithm does not add $v$ to $M$ which yields a contradiction.
\end{proof}

The second part of the algorithm maintains a decremental \kbtors algorithm
on an edge-subgraph $H$ of $G_{r'}$. 
We prove this fact in the following lemma.

\begin{lemma}
    The graph $H$ is a subgraph of $G_{r'}$. 
    Moreover, the set $M$ is always a \tors in $H$.
\end{lemma}
\begin{proof}
    Let $(u, v) \in E(H)$ be an edge in $H$. 
    Then, WLOG it must be the case that $u \in M$ and $\delta(v) \leq r'$.
    Based on Theorem~\ref{th:decr_appr_sssp}, the distance estimate $\delta(\cdot)$ does not underestimate the distances,
    and so we have that $d_G(u, v) \leq \delta(v) \leq r'$. 
    Thus by definition, the edge
    $(u, v)$ is part of $G_{r'}$ as well.
    
    The algorithm adds a vertex $v$ to $M$ only if the distance estimate $\delta(v)$ becomes
    greater than $r'$, while an edge is part of $H$ only if the distance
    of the two endpoints is at most $r'$. This implies that the set $M$ is an independent set in $H$.
    Furthermore, whenever the distance estimate $\delta(v)$ of a vertex $v \in V \setminus M$ becomes
    greater than $r'$, the set $M$ and the graph $H$ are recomputed. 
    This implies that the distance estimate of any vertex $v \in V \setminus M$ is at most $r'$.
    By construction of $H$, there must exist an edge $(u, v)$, where $u$ is the corresponding vertex of $\delta(v)$.
    Hence, we can conclude that the set $M$ is a \tors in $H$.
\end{proof}

\subparagraph{Running time.} The running time of the simple static algorithm is $\tilde{O}(mk)$.
By Theorem~\ref{th:decr_appr_sssp}, the total time of the decremental approximate SSSP algorithm is $\tilde{O}(m^{1+o(1)})$.
As the decremental approximate SSSP algorithm is restarted at most $k$ times,
the total update time of the algorithm is $\tilde{O}(m^{1+o(1)}k)$. Finally, the time to detect whether
a distance estimate is greater than $(1+\epsilon) r$ is incorporated in the update time of the decremental approximate SSSP algorithm. 



\subsection{Decremental $k$-center on graphs: Putting it together}
We combine Theorem~\ref{th:res_dec_tors} with Lemma~\ref{lem:2b_Gr_H}
to obtain the next theorem for the decremental $k$-center problem on graphs.
A pseudocode of the algorithm of Theorem~\ref{th:dec_kcent_2appr} is provided in Algorithm~\ref{alg:dec_kcenter}. 

\begin{algorithm}[ht!]
\DontPrintSemicolon
\caption{\textsc{decremental $(2 + \epsilon)$-approximation algorithm for $k$-center}{}}
\label{alg:dec_kcenter}
\SetKwFunction{FMaximalDistrIS}{MaximalDistrIS}
\SetKwProg{Fn}{Function}{:}{\KwRet}

\setcounter{AlgoLine}{0}
\SetAlgoLined

\Fn{\FMaximalDistrIS{}} {
    $i = 0$
    
    \While {$G \setminus \bigcup_{j=1}^i C_j \neq \emptyset$ and $i \leq k$} {
        $u \gets $ arbitrary vertex from $G \setminus \bigcup_{j=1}^i C_j$
    
        $i \gets i+1$
    
        $c_i \gets u$

        $C_i \gets$ cluster with center $c_i$ and radius $r$
    }

    \KwRet i
}

\vspace{1em}

\SetKwProg{Fn}{Procedure}{:}{\KwRet}
\SetKwFunction{FFindRadius}{FindRadius}
\Fn{\FFindRadius{}} {
    \While {\FMaximalDistrIS{} > k} {
        $r = (1 + \epsilon) \cdot r$
    }
}

\vspace{1em}

\SetKwProg{Fn}{Procedure}{:}{\KwRet}
\SetKwFunction{FPreprocessing}{Preprocessing}
\Fn{\FPreprocessing{}} {
    $r = 1 + \epsilon$
    
    \FFindRadius{}

    $M \gets \{c_1, \dots, c_i\}$
    
    $\mathcal{A}.initialize(G, M)$
    \tcp*{$\mathcal{A}$ is decremental approx. SSSP algorithm with distance estimates $\delta(\cdot)$}
}

\vspace{1em}

\SetKwProg{Fn}{Procedure}{:}{\KwRet}
\SetKwFunction{FUpdate}{Update}
\Fn{\FUpdate{$u$, $v$}} {
    $G \gets (V, E \setminus (u,v))$

    $\mathcal{A}.delete(u,v)$

    \While{$\exists x \in V$ s.t. $\delta(x) > r$} {
        \If{$i < k$} {
            $i \gets i + 1$

            $c_i \gets x$

            $M \gets \{c_1, \dots, c_i\}$
            
            $C_i \gets$ cluster with center $c_i$ and radius $r$
        }
        \Else {
            $r = (1 + \epsilon) \cdot r$
            
            \FFindRadius{}
        }

        $\mathcal{A}.restart(G, M)$
    }
}
\end{algorithm}


\deckcenttappr*
\begin{proof}
    Observe that algorithm $\mathcal{A}$ inside Lemma~\ref{lem:2b_Gr_H} with $\beta = 1$, 
    has the same properties of the algorithm in Theorem~\ref{th:res_dec_tors}. Hence, 
    let $\mathcal{A}$ be the algorithm of Theorem~\ref{th:res_dec_tors}, and 
    $\epsilon_1 = \frac{\epsilon}{6}$. Based on Lemma~\ref{lem:2b_Gr_H},
    by running $\mathcal{A}$ with input $G, r, \epsilon_1$, for each
    $r \in \{(1 + \epsilon_1)^i \mid (1 + \epsilon_1)^i \leq nW, i \in \mathbb{N}\}$, we get a
    deterministic decremental $2(1+\epsilon_1)(1+\epsilon_1)$-approximation algorithm for the
    $k$-center problem. As $\epsilon < 1$ and $\epsilon_1 = \frac{\epsilon}{6}$, the approximation
    ratio is $(2 + \epsilon)$.

    Regarding the running time, by Theorem~\ref{th:res_dec_tors} the total update time of $\mathcal{A}$ is $\tilde{O}(m^{1+o(1)}k)$. Also, we run $\mathcal{A}$ for at most $O(\log_{1+\epsilon_1}(nW))$
    different values of $r$. Thus, the total update time
    of the algorithm remains $\tilde{O}(m^{1+o(1)}k)$. 
\end{proof}

