\section{Preliminaries}\label{sec:preliminaries}
    \paragraph{Graphs.}
    Consider a weighted undirected graph $G = (V, E, w)$. We denote by $n = |V|$ the number of vertices, by $m = |E|$ the number
    of edges, and by $W$ the maximum weight of an edge. 
    Without loss of generality (WLOG), we assume that the minimum edge weight is equal to 1.
    Moreover, we assume that $W$ is bounded by a polynomial in $n$ (i.e., $W=O(\text{poly}(n))$.)
    
    For any two vertices $u, v \in V$, the \emph{distance $d_G(u, v)$ between $u$ and $v$} is the 
    length of a shortest path from $u$ to $v$. For a fixed subset of vertices $S \subseteq V$ and a vertex $v \in V$, the \emph{distance $d_G(v, S)$ 
    between $v$ and $S$} is equal to $\min_{u \in S} d_G(v, u)$, namely the distance from $v$ to its closest vertex in $S$. 
    For a node $v \in V$, we denote by $N_G(v)$ the set of neighbors of $u$ in $G$.
    A \emph{subgraph} $H$ of a graph $G$ is a graph whose vertex set and edge set are subsets
    of the vertex set and edge set of $G$ respectively. 
    An \textit{edge-subgraph} of $G$ is a graph whose vertex set is the same as the vertex set of $G$ and whose edge set is a subset of the edge set of $G$.
    For a subset of vertices $S \subseteq V$,
    the \emph{induced subgraph $G[S]$} is the graph with vertex set $S$, whose edge set consists
    of all edges in $E$ that have both endpoints in $S$. We also say that $G[S]$ is the
    subgraph induced by $S$. For a graph $H$, we denote by $V(H)$ the vertex set of $H$, and by $E(H)$ the edge set of $H$.

    Consider now an unweighted undirected graph $G = (V, E)$. 
    A \emph{distance-$\alpha$ independent set} $M$ is a subset of vertices such that the distance between any two vertices in $M$
    is strictly more than $\alpha$. An \emph{independent set (IS)} is a distance-$1$ independent set.
    An \emph{\abrs} is a subset of vertices $M \subseteq V$ such that the distance between any two vertices in $M$ is at least $\alpha$,
    and the distance between any vertex in $V$ and its closest vertex in $M$ is at most $\beta$.
    A \emph{maximal independent set (MIS)} is a $(2, 1)$-ruling set.

    \paragraph{Dynamic setting.}
    In the dynamic setting, the graph $G$ is subject to edge updates, namely edge insertions and/or edge deletions.
     
    A \emph{fully dynamic algorithm} is able to process both types of edge updates (i.e., edge deletions and edge insertions), while
    a \emph{partially dynamic algorithm} is able to process only one type of edge updates
    (i.e., either edge insertions or edge deletions). 
    In particular, an \emph{incremental algorithm} can process only edge insertions and a \emph{decremental algorithm} can process only edge deletions.

    In our incremental algorithms, we assume that the updates are performed by an \emph{oblivious adversary} who fixes the sequence of updates before the algorithm starts. Namely,
    the adversary cannot adapt the updates based on the choices of the algorithm during the execution.
    This is as opposed to an \textit{adaptive adversary}, that instead we consider in the decremental and fully-dynamic settings.
    
    In the incremental setting, let $M$ be an independent set in $G$. 
    Then for an edge insertion $(u, v)$ in $G$, we say that the edge $(u, v)$ causes a \emph{conflict} in $G$ when both of its endpoints $u$ and $v$ belong to $M$ before the update.
    
    We say that a dynamic algorithm has \emph{amortized update time} $u(n, m)$ if its total time spent for processing any sequence of $\ell$ updates is bounded by $\ell \cdot u(n, m)$. 
     

\paragraph{$k$-center on graphs.} We formally define the $k$-center problem as follows:
\begin{definition}[$k$-center on graph]
    Given a weighted undirected graph $G = (V, E, w)$ and an integer $k \geq 1$, the goal is to output a subset of vertices $S \subseteq V$ of size at most $k$,
    such that the value $\max_{v \in V} d_G(v, S)$ is minimized.
\end{definition}

Consider a \emph{$k$-center instance $\left(G = (V, E, w), k\right)$}, which is the pair of the given input graph $G$ and the integer $k$.
For each choice of $S \subseteq V$, we define the radius $r := \max_{v \in V} d_G(v, S)$. 
The vertices of $S$ are also called \emph{centers}.
For a fixed $S$ with radius $r$, we define a \emph{cluster} for every $c \in S$ containing all vertices within distance $r$ from the center $c$.
We denote by $R^* := \min_{|S| \leq k} \max_{v \in V} d_G(v, S)$ the optimal radius of the given instance,
and by $S^*$ any subset with radius $R^*$ (i.e., $R^* = \max_{v \in V} d_G(v, S^*)$). For completeness we also discuss how we may be interested in answering other type of queries in Appendix \ref{apx:queries}. 

In the dynamic setting, the input graph of the $k$-center instance is subject to edge updates.

\paragraph{Partially dynamic shortest paths algorithms.}
Through the paper, we heavily make use of the existing partially dynamic $(1+\epsilon)$-approximate single-source shortest paths (SSSP) algorithms. In the decremental setting, we can use a deterministic algorithm.
\begin{theorem}[Decremental $(1+\epsilon)$-SSSP, \cite{bernstein2021deterministic}]\label{th:decr_appr_sssp}
    Given a graph $G = (V, E)$ subject to edge deletions, a source $s \in V$, and a constant $\epsilon\in(0,1)$ there is a deterministic algorithm that maintains $(1 + \epsilon)$-approximate shortest paths from $s$
    in total update time $\tilde{O}(m^{1+o(1)})$.
\end{theorem}

In the incremental setting, we can use the following randomized partially dynamic algorithm.
\begin{theorem}[Incremental $(1+\epsilon)$-SSSP, \cite{HKN2014hopsets, chechik2018, LackiN22}] \label{th:incr_appr_sssp}
    Given a graph $G = (V, E)$ subject to edge insertions, a source $s \in V$, and a constant $\epsilon\in(0,1)$ there is a randomized algorithm (against an oblivious adversary) that maintains $(1 + \epsilon)$-approximate shortest paths from $s$ in total update time $\tilde{O}(m^{1+o(1)})$.
\end{theorem}
The incremental algorithm is not explicitly stated but follows from similar algorithms as the decremental settings such as \cite{HKN2014hopsets, chechik2018, LackiN22}. In Appdenix \ref{app:incremental}, we give a brief sketch of how one can adapt these results to the incremental setting, but the details of this algorithm are beyond the scope of this paper.

