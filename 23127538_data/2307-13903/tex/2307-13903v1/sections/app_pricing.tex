\section{Proof Details for Pricing Loss}
\label{app:pricing}
\szcomment{Don't use adaptive zooming / adaptive discretization, use uniform discretization}


\begin{definition}
\label{def:validPair}
Call a hypercube $I_j$ a pricing-ready hypercube if $\len(Y_j) \le 10 L \cdot \eta$. Call the associated range $Y_j$ the pricing-ready range, and together $I_j, Y_j$ form a pricing-ready pair. A pricing-ready pair is valid if $f(I_j) \in Y_j$, otherwise, it is invalid. 
\end{definition}

\begin{definition}
\label{def:queryType}
Let $I_j, Y_j$ be a pricing-ready pair. A query of $\min(Y_j)$ is said to be a pricing query. A query of $\max(Y_j)$ is said to be a sanity check query. A query on a pair that is not pricing-ready (i.e. when $Y_j > 10L\cdot \eta$) is called a search query. 
\end{definition}


\begin{definition}
\label{def:run}
Let $I_j, Y_j$ be a pricing-ready pair. The set of queries that occurred on the pair before the learner becomes surprised or the algorithm terminates is called a run. 
\end{definition}


% The proof outline is as follows. 
% \begin{enumerate}
%     \item For intervals that are not pricing-ready, use safe/amending/corrupted to analyze. 
%     \item For intervals that are pricing-ready, use valid/invalid to analyze. 
% \end{enumerate}

% The following lemma follow directly from the analogue for symmetric loss, with minor changes. 
% \begin{lemma}
%     Consider all intervals with depth less than $\log 1/\eta$. Safe intervals contribute $O(1)$ loss each, total $O(T^{d/(d+1)})$ loss. Corrupted intervals contribute $O(\log T)$ loss each, total $O(C\log T)$ loss. Amending intervals contribute $O(\log T)$ loss each, total $O(2^d \cdot C\cdot \log T)$ loss. 
% \end{lemma}

On a pricing-ready hypercube $I_j$, the learner is said to become \emph{surprised} when the signal is inconsistent with $Y_j$. In other words, the learner becomes surprised when she queried $\min(Y_j)$ and receives an overprice signal ($\sigma_t = 1$), or queried $\max(Y_j)$ and receives an underprice signal ($\sigma_t = 0$). 

\szdelete{
The sanity check schedule ensures the following holds. 
\begin{claim}
Let a pricing interval be run for $t_0$ rounds before the learner becomes surprised or the algorithm terminates, then the number of sanity checks is $\Theta(g^{-1}(t_0))$. Conversely, if there are $s_0$ sanity checks in this run, then the interval has been run for $\Theta(g(s_0))$ rounds. 
\end{claim}
}

\begin{lemma}
\label{lemma:surprised}
    %There are at most $C$ invalid pricing intervals. 
    The learner becomes surprised at most $C$ times. 
\end{lemma}

\begin{proof}
    The learner can become surprised for the following two reasons: the signal itself is corrupted, or the signal is uncorrupted, but the associated range $Y_j$ is actually invalid (as in~\cref{def:validPair}). If the associated range $Y_j$ is invalid, then corruption must have occurred in the search queries before the hypercube became pricing ready. Since there are at most $C$ corruptions, the learner can become surprised at most $C$ times. 
\end{proof}


\begin{lemma}
\label{lemma:pricingLoss}
    Let $I_j, Y_j$ be a pricing-ready pair that has been queried for $\tau$ rounds before the learner becomes surprised or the algorithm terminates. Further, assume a total of $\xi$ signals were corrupted during this period. Then pricing queries in this pair pick up a loss of $L\cdot O(\tau \eta_0 + \xi \tau_0)$. 
\end{lemma}

\begin{proof}
If the pair were valid, i.e. $f(I_j) \in Y_j$, then each pricing round incurs loss $L\cdot O(\eta_0)$, hence a run with length $\tau$ incurs loss $L\cdot O(\tau \eta_0)$. 

For an invalid pricing interval-range pair, there are four cases. 
\begin{enumerate}
    \item $f(I_j) \ge \max(Y_j)$
    \item $f(I_j)$ has some overlap with $Y_j$ and $f(I_j) \ge \min(Y_j)$, $\max(Y_j) \in f(I_j)$
    \item $f(I_j) \le \min(Y_j)$
    \item $f(I_j)$ has some overlap with $Y_j$ and $f(I_j) \le \max(Y_j)$, $\min(Y_j) \in f(I_j)$
\end{enumerate} 
\szcomment{Insert a illustration here. }

Consider the total loss collected from pricing rounds before learner becomes surprised or algorithm terminates. 

% In all cases, the loss collected from sanity check queries is at most $O(f(t_0))$. 

For case 1, any uncorrupted signal in sanity check queries makes the learner surprised. Hence assuming the adversary spent corruption budge $\xi$, then the run must terminate in $O( \xi \tau_0 )$ rounds since the adversary must be corrupting every sanity check query. The learner then trivially incurs loss $L\cdot O(\xi \tau_0)$. 

For case 2, the loss collected is at most $L\cdot O(\eta_0)$ per pricing round, hence the total loss is $L\cdot O(\tau \eta_0)$. 
%At most $f(c_0)$ corruption. 

For case 3, any uncorrupted signal in pricing rounds makes the learner surprised. Hence assuming the adversary spent a corruption budget $\xi$, the run terminates in $\Theta(\xi)$ rounds (since the adversary must be corrupting all pricing rounds), and the learner incurs regret $L\cdot O(\xi)$. 

For case 4, the adversary does not corrupt sanity check rounds, or the learner will become immediately surprised. If the learner does not become surprised during pricing rounds, this could be due to either: 1. the learner did not overprice, or 2. the learner overpriced but the adversary corrupted the signal. Consequently in pricing rounds, uncorrupted queries accumulate $L\cdot O(\tau \eta_0)$ loss, and corrupted queries accumulate $L\cdot O(\xi)$ loss. 
%Can terminate very long or terminate in $O(c_0)$ rounds. 

Putting all cases together completes the proof. 
\end{proof}

In the following, let $\cT$ be a multi-set with elements denoting the length of runs of pricing-ready pairs. Let $\cC$ be a multi-set with elements denoting the number of corruptions that occurred in runs of pricing-ready pairs. 
%The learner starts with $2^{d \floor{ \log(1/\eta)} }  \le \eta^{-d}$ hypercubes, and becomes surprised at most $C$ times. 
\iffalse
\begin{lemma}
\label{lemma:sanityLoss}
The learner incurs loss $L\cdot O( T / \tau_0 )$ in sanity check queries. 
\end{lemma}
\begin{proof}
The learner performs sanity check every $\tau_0$ rounds, hence there can be $O(T /\tau_0)$ sanity check queries. Each query contribute loss at most $L$, hence the lemma follows. 
\end{proof}
\fi

\szdelete{
    The loss from sanity check queries can be bounded as
    \begin{align*}
        L\cdot \sum_{\tau \in \cT} g^{-1}(\tau) \le L\cdot N g^{-1}(T/N)
    \end{align*}
    by concavity of $g^{-1}$ and the fact that $\cT$ has at most $N$ elements. 
}


\begin{theorem}[\Cref{thm:pricing} restated]
\Cref{algo:pricing} incurs cumulative pricing loss $L\cdot \widetilde{O} \left( T/\tau_0 + C\tau_0 + T^{d/(d+1)}\right) $. 
\end{theorem}
\begin{proof}
    First, an upper bound is obtained on the total loss incurred from search queries (i.e. $\len(Y_j) > 10L\cdot \eta_0$). The learner searches from scratch when starting from initialization ($Y_j$ is set to $[0, L]$ at initialization) or when she becomes surprised ($Y_j$ is reset to $[0, L]$). This can happen at most $C + \eta_0^{-d}$ times, since the learner becomes surprised at most $C$ times (\cref{lemma:surprised}) and there are $\eta_0^{-d}$ hypercubes at initialization.  Whenever the learner searches from scratch, it takes $O(\log T)$ queries before the interval becomes pricing-ready. Thus the total loss incurred from search queries is 
    \begin{align}
    L \cdot \widetilde{O}(C + \eta_0^{-d}). 
    \end{align}

    Next, the loss incurred when range becomes pricing-ready can be separated into two parts, loss from sanity check queries and loss from pricing rounds. %that records the number of queries occurred in pricing-ready intervals before the learner becomes surprised or the algorithm terminates. 
    The total loss from sanity check queries can be bounded by
    \begin{align}
    L\cdot O ( T / \tau_0 ), 
    \end{align}
    since there can be $O(T/\tau_0)$ sanity check queries, and each query contribute loss at most $L$. 
    
    From~\cref{lemma:pricingLoss}, the total loss from pricing rounds can be bounded by
    \begin{align}
    L\cdot O\left( \sum_{\xi \in \cC} \xi \cdot \tau_0 + \sum_{\tau\in \cT} \tau \cdot \eta_0 \right) &\le L\cdot O( C \tau_0 +  T \eta_0 ). 
    \end{align}
    % Hence adding the loss from sanity check queries and pricing rounds, the total loss from pricing-ready intervals is bounded by
    % \begin{align*}
    % L\cdot \left( Ng^{-1}(T/N) + g(C) + T\eta \right)
    % \end{align*}

    Putting everything together, the total loss can be bounded by the sum of loss incurred during sanity check rounds, pricing rounds, and searching rounds:
    \[
    L\cdot \widetilde{O}\left( T / \tau_0 + C\tau_0 + T\eta_0 + \eta_0^{-d} \right). 
    \]
    Plugging the choice of parameter $\eta_0 = T^{-1/(d+1)}$ finishes the proof. 
\end{proof}


% \begin{theorem}
% Pricing loss $O(LT^{d/(d+1)} + C\log T)$. 
% \end{theorem}
% \begin{proof}
% Corrupted interval contribute $O(C\log T)$ loss. Amending interval contribute $O(C\log T)$ loss. 

% In safe intervals, the learner queries the lower end of $Y_j$ once the length of $Y_j$ drops below the threshold $\eta = ...$. Such queries contribute loss at most $O(T\eta) = ...$. 

% In safe intervals, the learner incurs regret $O(1)$ for all queries incurring in each interval (as opposed to $O(2^{-h})$ f or the symmetric loss) when the length has not reached the threshold $\eta$. Such intervals have depth $O(\log(1/\eta))$, and there are at most $O((8L)^d 2^{d\log(1/\eta)}) = O((LT)^{d/(d+1)})$. 
% \end{proof}

\iffalse
\subsection{Sanity Check with Pricing Loss}
Treat $L$ as constant. Recall in pricing loss, we no longer shrinks intervals when associated range falls below $\eta = T^{1/(d+1)}$. The total loss coming from these small boxes are $T\eta$. The total number of intervals required to reach this level of refinement is $2^{d\log(1/\eta)} = \eta^{-d}$. 

Consider a hypercube $I_j$ and associated range $Y_j$ with its length no larger than $\eta$. It could be valid or not. We say it is valid if $f(I_j) \in Y_j$. Otherwise it is invalid. 

Use the following sanity check schedule. When $I_j$ has been queried $t$ times, we sanity check $\max(Y_j)$ for $f(t)$ rounds. Suppose $c_j$ rounds are corrupted in this interval. Another way to think about this is to give a count to all small hypercubes below $\eta$. Let $z_1 = 1^{d+1/d}, z=2 = 2^{d+1/d}, ..., z_k = k^{d+1/d}, ...$ be the critical values. When $I_j$ has been queried for $z_i$-th time, query the upper bound on $Y_j$. 

Bound number of sanity checks on safe intervals $...$

If it is valid, then small loss when signal is uncorrupted. 

If it is invalid, there could be two cases. 

Case 1. $f(x) < Y_j$ for some $x \in I_j$. In this case, it is possible to overprice. 

Case 2. $f(x) > Y_j$ for some $x \in I_j$. In this case, it is possible to underprice by more than $\eta$, since the learner is willing to pay $f(x)$ and only $\min(Y_j)$ is charged. 

\subsection{Pricing Loss}
Use $d=1$ first, the case with $d>1$ will be similar. 

\begin{lemma}
The learner can become surprised $C\cdot 2^d$ times. 
\end{lemma}

Whenever the learner becomes surprised, she restarts the search from scratch by setting the associated range to $[0, L]$. Thus the learner starts from scratch at most $C \cdot 2^d$ times. 

Consider runs until the learner becomes surprised or until the whole algorithm terminates, denote the total number of rounds by $t_j$. Note that the learner can become surprised multiple times on the same interval $I_j$. Note $\sum t_j \le T$. 

\szcomment{From here, there are several ways to go about. First way is continue analyzing safe, corrupted, amending intervals. But this may not be fruitful. It would be better to focus on pricing intervals. }

Call a pricing interval valid if $f(I_j)\in Y_j$. It is invalid otherwise. There are essentially four cases when the interval is invalid. 

\szcomment{This has been moved earlier. }

Hence for any invalid interval, the learner collects loss $(f(t_0) + g(c_0))$ loss, here $g$ is the inverse function of $f$. 


Hence all loss for all invalid interval is $\sum_j f(t_j) + \sum_j g(c_j)$. 

Next, consider a valid interval, it is run for $t_j$ rounds before surprised. The total loss is $O(f(t_j))$ from sanity check rounds plus a pricing loss. 

\subsection{Adaptive Zooming}

% \begin{algorithm}[htbp]
% \caption{Learning with Corrupted Binary Feedback for $d > 1$ under Pricing Loss with Adaptive Zooming}
% \label{algo:1dabsolute}
% \begin{algorithmic}[1]
% \State Learner maintains a partition of hypercubes $I_j$ of the input space throughout learning process
% \State For each interval $I_j$ in the partition, learner maintains an associated range $Y_j$, and two endpoints $\lend(I), \rend(I)$
% \State The partition is initialized as $\ceil{8L}$ hypercubes $I_j$ with length less than $1/8L$ each, and each has feasible interval $Y_j$ set to $[0,1]$, with $\lend(I_j) = 0, \rend(I_j) = 1$
% \For {round $t = 1, 2, ..., T$}
%     \State Learner receives context $x_t$
%     \State Learner finds interval $I_j$ such that $x_t \in I_j$
%     \State Let $Y_j$ be the associated range of $I_j$
%     \If {$\len (Y_j) < \eta$}
%         \If {\textit{Reached sanity check schedule} }
%             \State Query $\max(Y_j)$
%         \EndIf
%         \State Query $\min(Y_j)$
%         \If {$\sigma_t = 1$}
%             \State Set $Y_j = [0,L]$ \Comment{Reset the range of $Y_j$}
%         \EndIf
%     \ElsIf {Exists an endpoint in $S_j$ not queried} %\label{algo:queryendpt_beg}
%         \State Query an unqueried endpoint of $S_j$
%         \If {Queried $\min(S_j)$ and $\sigma_t = 1$, or queried $\max(S_j)$ and $\sigma_t = 0$} 
%         \State Mark $I_j$ as unsafe \Comment{Contamination found in the current interval}
%         \EndIf
%         \If {Both endpoints of $S_j$ have been queried}
%             \If {$I_j$ marked unsafe}
%                 \State Set range $Y_j := [0,1]$ \label{algoline:marked_rangeset}
%             \Else
%                 \State Set range $Y_j = [\min(S_j) - L\cdot \len(I_j)), \max(S_j) + L\cdot \len(I_j))] \cap [0,1]$ \label{algoline:unmarked_rangeset}
%             \EndIf
%         \EndIf %\label{algo:queryendpt_end}
%     \Else %{$I_t$ not marked unsafe} \label{algo:notmarked_beg}
%         \State $Y_j := \algmq(I_j, Y_j)$
%         \If { $\len(Y_j) < 4 L\cdot \len(I_j)$}  \Comment{associated range $Y_j$ has shrunk enough}
%             \State Bisect each side of $I_j$ to form $2^d$ new hypercubes, each with length $...$
%         \EndIf %\label{algo:notmarked_end}
%     \EndIf
%     %\Else \Comment{$I_t$ is marked dishonest} \label{algo:dishonest_begin}
%         %\State Start from scratch until converge, takes $\log T$ steps \label{algo:test}
        
%         %\State Let $\set{[], [], []}$ be the sequence of feasible region (endpoints? ) on the path to $I_t$. 
%         %\State Perform binary search on this path and find the first interval [] that contains $f(I_t)$. \Comment{Takes $\log\log T$ steps}, set feasible region $I_t = []$
%         %\State From this point perform binary search and shrink feasible region \Comment{Takes $c$ steps, where $c$ is number of corruptions before reaching a correction interval? }
%     %\EndIf %\label{algo:dishonest_end}
% \EndFor
% \end{algorithmic}
% \end{algorithm}

\fi
