

\section{Proof Details for Symmetric Loss}
\label[appendix]{app:proof1d}

%In the analysis, the assumption is made that $L\ge 1$. If $L < 1$, a linear transformation can be applied on the function $f$ so that the range of $f$ becomes $[0,1]$ and the Lipschitz constant becomes $L = 1$ after the transformation. See the auxiliary results (lemma 14, lemma 15) in~\cite{mao2018contextual} for more details. 

%Recall the definition of corrupted, correcting and honest interval. 
The definition of corrupted interval, correcting interval, and safe interval will be restated for convenience. An interval is a corrupted interval if any signal of a query within the interval was corrupted. An interval is an correcting interval if its parent interval is corrupted and any signal of queries within the interval was uncorrupted. An interval is safe if its parent interval is safe or correcting. A root interval with no corrupted signals is also safe. 
\szcomment{rename to safe / unsafe / corrupted / amending / contaminated}

An interval has depth $r$ if it was bisected from an interval at depth $r-1$. Initial root intervals have depth 0. Hence, an interval $I_j$ at depth $r$ has length $\len(I_j) = 2^{-r}$. 


The below lemma shows that each call to $\algmq$ preserves the property $f(I_j)\in Y_j$. 
\begin{lemma}
\label{lemma:updateValid}
    Consider a call to the $\algmq(I_j, Y_j)$ procedure. Let $Y_j$ be the associated range before the query, and let $Y'_j = \algmq(I_j, Y_j)$ be the range after the query. If the signal was uncorrupted and $f(I_j) \in Y_j$, then $f(I_j) \in Y'_j$. 
    % Let $I_j$ be any interval and $Y_j$ the associated range that appears at any point in the learning process. Let $Y'_j = \algmq(I_j, Y_j)$. If $f(I_j) \in Y_j$, then $f(I_j) \in Y'_j$. 
\end{lemma}

\begin{proof}
Let $q_t$ be the query point (i.e. midpoint of $Y_j$). Assume the signal $\sigma_t = 0$, so that $f(x_t) \ge q_t$. The case where $\sigma_t = 1$ will be similar. 

Since $f$ is $L$-Lipschitz, it must be that 
\[
f(I_j) \ge f(x_t) - L\cdot \len(I_j) \ge q_t - L\cdot \len(I_j), 
\]
hence the update 
\[
Y'_j = Y_j\cap [q_t - L\cdot \len(I_j) , L]
\]
still guarantees that $f(I_j) \in Y'_j$. 
\end{proof}

The next lemma shows the length of $Y_j$ shrinks by a constant factor after each call to $\algmq$, regardless of whether the signal was corrupted or not. 
\begin{lemma}
\label{lemma:rangeShrinks}
Consider a call to the $\algmq(I_j, Y_j)$ procedure. Let $Y_j$ be the associated range before the query, and let $Y'_j = \algmq(I_j, Y_j)$ be the range after the query. Suppose $\len(Y_j) \ge 4L\cdot \len(I_j)$, then $\frac{1}{2} \len{(Y_j)} \le \len{(Y'_j)} \le \frac{3}{4} \len{(Y_j)}$ regardless of whether the signal is corrupted or not. 
\end{lemma}

\begin{proof}
    Let $q_t$ be the query point (i.e. midpoint of $Y_j$). Assume the signal $\sigma_t = 0$, the case with $\sigma_t = 1$ will be similar. 
    
    Before the call to $\algmq(I_j, Y_j)$, the learner has $\len(Y_j) \ge 4L\cdot \len(I_j)$. This implies 
    \[
    q_t - \min(Y_j) = \frac{\len(Y_j)}{2} \ge 2L\cdot \len(I_j)
    \]
    so that
    \[
    q_t - L\cdot \len(I_j) > \min(Y_j). 
    \] 


    The update can be written as
    \begin{align*}
        Y'_j &= [q_t - L\cdot \len(I_j), L] \cap Y_j\\
        &= [q_t - L\cdot \len(I_j), q_t] \cup [q_t, \max(Y_j)]
    \end{align*}
    The lemma then follows from $\len{( [q_t, \max(Y_j)] )} = \frac{1}{2} \len{ ( Y_j ) }$, $\len{ ( [q_t - L\cdot \len(I_j), q_t] ) } = L\cdot \len(I_j) \le \frac{1}{4} \len{ ( Y_j ) }$. 
\end{proof}


\begin{lemma}
\label{lemma:bisectFast}
    If an interval is marked unsafe, then the interval is bisected after $O(\log T)$ queries. If an interval is not marked unsafe, then the interval is bisected after $O(1)$ queries. 
\end{lemma}

\begin{proof}
    If the interval is marked unsafe, then the range of the interval is reset to $[0,L]$ in line~\ref{algoline:marked_rangeset} of algorithm~\ref{algo:1dabsolute}. By Lemma~\ref{lemma:rangeShrinks}, the range $Y_j$ shrinks by at least a factor of $\frac{3}{4}$ each query, hence after $O(\log T)$ queries, the learner has $\len(Y_j) < \max(4L\cdot \len(I_j), 4 L / T) $. 

    If the interval were not marked unsafe, then the range $Y_j$ in line~\ref{algoline:unmarked_rangeset} is updated as
    \[
    Y_j = [\min(S_j) - L\cdot \len(I_j), \max(S_j) + L\cdot \len(I_j)] \cap [0,L]. 
    \]

    If the interval has depth less than $\log T$, then $\len(S_j) \le 8 L \cdot \len(I_j) $, and after the update the learner has $\len(Y_j) \le 10 L \cdot \len(I_j)$. If the interval has a depth larger than $\log T$, then $\len(S_j) \le 8 L / T$,  and after the update $\len(Y_j) \le 10L / T$. In either case, Invoking Lemma~\ref{lemma:rangeShrinks} again, the range shrinks by constant factor each query and it takes $O(1)$ rounds for the range to shrink below $\max ( 4L \cdot \len(I_j), 4 L / T)$. 
\end{proof}

\begin{lemma}
\label{lemma:amendingFixes}
    Let $I_j$ be an correcting interval. When $I_j$ is bisected, it holds that $f(I_j) \in Y_j$. 
\end{lemma}

\begin{proof}
    It is first shown that $f(I_j) \in Y_j$ after the update following the agnostic check procedure. There are two cases to consider, whether $I_j$ has been marked unsafe or not after the agnostic check. 
    
    If $I_j$ has been marked unsafe, then the update in line~\ref{algoline:marked_rangeset} resets $Y_j$ to $[0,L]$, hence the learner has $f(I_j) \in Y_j$ trivally. 
    
    % If $I_j$ has been not marked unsafe after the two endpoints had been queried, then the associated range is reset to $[0,1]$, hence the learner effectively searches from scratch. 

    If $I_j$ has not been marked unsafe, the update in line~\ref{algoline:unmarked_rangeset} takes place. Since $I_j$ is an correcting interval, the signals are uncorrupted, and by Lipschitzness of $f$, the learner has
    \begin{align*}
        f(I_j) \ge \min(S_j) - L\cdot\len(I_j) \\
        f(I_j) \le \max(S_j) + L\cdot\len(I_j). 
    \end{align*}
    Hence the learner has $f(I_j) \in Y_j$ after the update. 
        
    Putting these two cases together, after the update on the associated range based on the results of the agnostic checking steps, the learner has $f(I_j) \in Y_j$. By inducting on Lemma~\ref{lemma:updateValid}, repeated calls to $\algmq$ guarantees $f(I_j) \in Y_j$ when $I_j$ is bisected. 
\end{proof}

\begin{lemma}
\label{lemma:safeNotMarked}
    Safe intervals are not marked unsafe. 
\end{lemma}

\begin{proof}
Induction is used to show the following for any safe interval $I_j$: 
\begin{enumerate}
    \item $f(I_j) \in S_j$
    \item $f(I_j) \in Y_j$ when $I_j$ is bisected
\end{enumerate}


Let $I_j$ be a safe interval. If $I_j$ is a root interval, then trivially $f(I_j)\in S_j$. Further by Lemma~\ref{lemma:updateValid}, $f(I_j) \in Y_j$ when $I_j$ is split. 

If $I_j$ has an correcting interval as its parent interval, then by Lemma~\ref{lemma:amendingFixes}, $f(I_j) \in S_j$, and consequently by Lemma~\ref{lemma:updateValid} $f(I_j) \in Y_j$ when $I_j$ is split. 

If $I_j$ has a safe interval as its parent interval, then a simple induction shows the desired result. 
% \begin{enumerate}
%     \item $f(I_j) \in S_j$
%     \item $f(I_j) \in Y_j$ when $I_j$ is bisected
% \end{enumerate}
% Hence safe intervals are never marked unsafe. 
    % If $f(I_j) \in [\lend(I_j), \rend(I_j)]$ and $I_j$ is a safe interval, then $f(I_j) \in Y_j$ when $I_j$ is bisected. The lemma then follows by inducting on the depth of intervals. 
\end{proof}

The following corollary follows directly from Lemma~\ref{lemma:bisectFast} and Lemma~\ref{lemma:safeNotMarked}. 
\begin{corollary}
\label{cor:safeBisectFast}
Safe intervals bisect in $O(1)$ rounds. 
\end{corollary}


% \begin{restatable}{lemma}{correctionCorrects}
%     Let $I_j$ be a correction interval and $Y_j$ be its feasible interval before $I_j$ is split. Then $f(I_j) \in Y_j$. 
% \end{restatable}
% \begin{proof}
% There are two cases to consider, whether $I_j$ had been marked dishonest after its two endpoints are queried. 

%     First consider the case that $I_j$ was not marked dishonest, then it must be the case that the feasible region is contained in $Y_j$ after the update in line~\ref{algo:queryendpt_end}. 

%     Otherwise $I_j$ is marked dishonest. Then the learner searches from scratch, thus he still finds the correct feasible region. 
% \end{proof}

\begin{lemma}
\label{lemma:corruptedLoss}
    Corrupted interval contribute $L\cdot O(C \log T)$ loss. 
\end{lemma}
\begin{proof}
    There are at most $C$ corrupted intervals, and each interval splits in $O(\log T)$ rounds by Lemma~\ref{lemma:bisectFast}, with each round incurring $O(L)$ regret (trivially). Hence corrupted interval contribute total $L \cdot O(C\log T)$ regret. 
\end{proof}

\begin{lemma}
\label{lemma:amendingLoss}
    Correcting intervals contribute $L\cdot O(C)$ loss. 
\end{lemma}
\begin{proof}
    There are at most $2C$ correcting intervals. For each correcting interval $I_j$, querying the two endpoints of $S_j$ incur $O(L)$ regret. Each call to $\algmq(I_j, Y_j)$ incur $O(\len(Y_j))$ regret. By Lemma~\ref{lemma:rangeShrinks}, $\len(Y_j)$ shrinks by a factor of $\frac{3}{4}$, hence the loss is geometrically decreasing with each query, and the total loss incurred within $I_j$ is $O(L)$. 
\end{proof}

\begin{lemma}
\label{lemma:safeLoss}
Consider a safe interval $I_j$ at depth $h < \log T$. Each query in $I_j$ incur $L\cdot O(2^{-h})$ regret. 
\end{lemma}

\begin{proof}
    Consider a safe interval $I_j$. Suppose the depth $h < \log T$. The two queries on the endpoints incur $O(2^{-h})$ loss, since 
    \[
    \len(S_j) < 8 L \cdot \len(I_j) = O(2^{-h}). 
    \]
    Each call to $\algmq(I_j, Y_j)$ also incurs $O(2^{-h})$ loss since $\len(Y_j) = O(L\cdot \len(I_j)) = O(2^{-h})$. By Corollary~\ref{cor:safeBisectFast}, safe intervals splits in $O(1)$ rounds, hence the loss incurred at interval $I_j$ is $O(2^{-h})$. \szcomment{TODO}
\end{proof}

\begin{theorem}[\Cref{thm:symm1D} restated]
\Cref{algo:1dabsolute} achieves cumulative symmetric loss $L\cdot O(C\log T)$. 
\end{theorem}
\begin{proof}
    By Lemma~\ref{lemma:corruptedLoss} and Lemma~\ref{lemma:amendingLoss}, corrupted interval and correcting interval contribute total $L\cdot O(C\log T)$ loss. Hence it is only needed to bound the loss of all safe intervals. 

    Note that there can be at most $O(2^h)$ intervals at depth $h$, thus considering all safe intervals at depth $h$, their total loss is at most $L\cdot 2^h \cdot O(2^{-h}) = L\cdot O(1)$ by Lemma~\ref{lemma:safeLoss}. For any safe interval that has a depth larger than $\log T$, each query incurs loss $L\cdot O(\nicefrac{1}{T})$, hence all queries with a depth larger than $\log T$ incur a total loss at most $L\cdot O(1)$. Consequently, all safe intervals incur loss $L\cdot O(\log T)$. 

    Putting these together, the algorithm incurs loss $L\cdot O(C\log T)$. 
\end{proof}