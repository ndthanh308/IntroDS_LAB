\begin{algorithm}[h]
\caption{Learning with corrupted binary signals under symmetric loss for $d=1$}
\label{algo:1dabsolute}
\begin{algorithmic}[1]
\State Learner maintains a partition of intervals $I_j$ of the input space throughout learning process
\State For each interval $I_j$ in the partition, learner stores a sanity check interval $S_j$, and maintains an associated range $Y_j$
\State The partition is initialized as $8$ intervals $I_j$ with length $1/8$ each, and each $I_j$ has associated range $Y_j$ and sanity check interval $S_j$ set to $[0,L]$
\For {round $t = 1, 2, ..., T$}
    \State Learner receives context $x_t$
    \State Learner finds interval $I_j$ such that $x_t \in I_j$
    \State Let $Y_j$ be the associated range of $I_j$
    \If {Exists an endpoint of $S_j$ not yet queried} %\label{algo:queryendpt_beg}
        \State Learner selects an unqueried endpoint of $S_j$ as guess
        \If {Learner guessed $\min(S_j)$ and $\sigma_t = 1$, or guessed $\max(S_j)$ and $\sigma_t = 0$} 
        \State Mark $I_j$ as unsafe \Comment{Contamination found in the current interval}
        \EndIf
        \If {Both endpoints of sanity check interval $S_j$ have been queried}
            \If {$I_j$ marked unsafe}
                \State Set range $Y_j := [0,L]$ \label{algoline:marked_rangeset}
            \Else
                \State Set range $Y_j = [\min(S_j) - L\cdot \len(I_j)), \max(S_j) + L\cdot \len(I_j))] \cap [0,L]$ \label{algoline:unmarked_rangeset}
            \EndIf
        \EndIf %\label{algo:queryendpt_end}
    \Else %{$I_t$ not marked unsafe} \label{algo:notmarked_beg}
        \State $Y_j := \algmq(I_j, Y_j)$
        \If { $\len(Y_j) < \max( 4 L\cdot \len(I_j), 4 L / T )$ }  \LineComment{Check if associated range $Y_j$ has shrunk enough}
            \State Bisect $I_j$ into $I_{j1}, I_{j2}$, set $S_{j1} = Y_j, S_{j2} = Y_j$ 
        \EndIf %\label{algo:notmarked_end}
    %\Else \Comment{$I_t$ is marked dishonest} \label{algo:dishonest_begin}
        %\State Start from scratch until converge, takes $\log T$ steps \label{algo:test}
        
        %\State Let $\set{[], [], []}$ be the sequence of feasible region (endpoints? ) on the path to $I_t$. 
        %\State Perform binary search on this path and find the first interval [] that contains $f(I_t)$. \Comment{Takes $\log\log T$ steps}, set feasible region $I_t = []$
        %\State From this point perform binary search and shrink feasible region \Comment{Takes $c$ steps, where $c$ is number of corruptions before reaching a correction interval? }
    \EndIf 
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm2e}
\caption{Midpoint query procedure: $\algmq(I_j, Y_j)$}
\label{algo:midpt_query}
    \State Input: $I_j, Y_j$
    \State Let $q$ be midpoint of $Y_j$
    \State Learner queries $q$
    \If {$\sigma_t$ = 1}
        % \State Set $Y'_j := [\min(Y_j), q_t + L\cdot\len(I_j)]$
        \State Set $Y'_j := [0, q_t + L\cdot\len(I_j)] \cap Y_j$
        \szcomment{This and above should be equivalent}
    \Else
        % \State Set $Y'_j := [q_t - L\cdot\len(I_j), \max(Y_j)]$
        \State Set $Y'_j := [q_t - L\cdot\len(I_j), 1] \cap Y_j$
        \szcomment{This and above should be equivalent}
    \EndIf
    \State Return $Y'_j$
\end{algorithm2e}


\begin{algorithm}[h]
\caption{Learning with corrupted binary signal under pricing loss with uniform discretization}
\label{algo:pricing}
\begin{algorithmic}[1]
\State Set parameter $\eta_0 = T^{-1/(d+1)}$, sanity check schedule $\tau_0$
\State Learner uniformly discretizes input space into hypercubes with lengths no larger than $\eta_0$ each
\State For each hypercube $I_j$, learner maintains an associated range $Y_j$ (initialized as $[0, L]$), query count $c_j$ (initialized as $0$)
% \State Set $\eta = 10 L \cdot T^{1/(d+1)}$
\For {$t = 1, 2, ..., T$}
    \State Learner receives context $x_t$
    \State Learner finds hypercube $I_j$ such that $x_t \in I_j$
    \State Let $Y_j$ be the associated range of $I_j$
    \If {$\len (Y_j) < 10 L \cdot \eta$} \Comment{The interval is pricing-ready}
        \State $c_j := c_j + 1$
        \If { $c_j > \tau_0$ } 
            \State Query $\max(Y_j)$
            \State Set $c_j := 0$
        \Else 
            \State Query $\min(Y_j)$
        \EndIf
        \If {Learner is surprised} \LineComment{Learner is surprised if queried $\max(Y_j)$ and $\sigma_t = 0$, or queried $\min(Y_j)$ and $\sigma_t = 1$}
            \State Set $Y_j := [0,L]$ \Comment{Reset the range of $Y_j$}
            \State Set $c_j := 0$
        \EndIf
    % \ElsIf {Exists an endpoint in $S_j$ not queried} %\label{algo:queryendpt_beg}
    %     \State Query an unqueried endpoint of $S_j$
    %     \If {Queried $\min(S_j)$ and $\sigma_t = 1$, or queried $\max(S_j)$ and $\sigma_t = 0$} 
    %     \State Mark $I_j$ as unsafe \Comment{Contamination found in the current interval}
    %     \EndIf
    %     \If {Both endpoints of $S_j$ have been queried}
    %         \If {$I_j$ marked unsafe}
    %             \State Set range $Y_j := [0,1]$ \label{algoline:marked_rangeset}
    %         \Else
    %             \State Set range $Y_j = [\min(S_j) - L\cdot \len(I_j)), \max(S_j) + L\cdot \len(I_j))] \cap [0,1]$ \label{algoline:unmarked_rangeset}
    %         \EndIf
    %     \EndIf %\label{algo:queryendpt_end}
    \Else %{$I_t$ not marked unsafe} \label{algo:notmarked_beg}
        \State $Y_j := \algmq(I_j, Y_j)$
        % \If { $\len(Y_j) < 4 L\cdot \len(I_j)$}  \Comment{associated range $Y_j$ has shrunk enough}
        %     \State Bisect each side of $I_j$ to form $2^d$ new hypercubes, each with length $...$
        % \EndIf %\label{algo:notmarked_end}
    \EndIf
    %\Else \Comment{$I_t$ is marked dishonest} \label{algo:dishonest_begin}
        %\State Start from scratch until converge, takes $\log T$ steps \label{algo:test}
        
        %\State Let $\set{[], [], []}$ be the sequence of feasible region (endpoints? ) on the path to $I_t$. 
        %\State Perform binary search on this path and find the first interval [] that contains $f(I_t)$. \Comment{Takes $\log\log T$ steps}, set feasible region $I_t = []$
        %\State From this point perform binary search and shrink feasible region \Comment{Takes $c$ steps, where $c$ is number of corruptions before reaching a correction interval? }
    %\EndIf %\label{algo:dishonest_end}
\EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[h]
\caption{Learning with corrupted binary signal under symmetric loss with $d > 1$}
\label{algo:highDsymm}
\begin{algorithmic}[1]
\State Learner maintains a partition of hypercubes $I_j$ of the input space $[0,1]^d$ throughout learning process
\State For each hypercube $I_j$, learner stores a sanity check interval $S_j$ and maintains an associated range $Y_j$
\State The partition is initialized as a single hypercube with sanity check interval $S_j$ set to $[0, 8L]$
\For {round $t = 1, 2, ..., T$}
    \State Learner receives context $x_t$
    \State Learner finds hypercube $I_j$ such that $x_t \in I_j$
    \State Let $Y_j$ be the feasible interval of $I_j$
    \If {Exists an endpoint of $S_j$ not queried} %\label{algo:queryendpt_beg}
        \State Query an unqueried endpoint of $S_j$
        \If {Queried $\min(S_j)$ and $\sigma_t = 1$, or queried $\max(S_j)$ and $\sigma_t = 0$} 
        \State Mark $I_j$ as unsafe \Comment{Contamination found in the current interval}
        \EndIf
        \If {Both endpoints of $S_j$ have been queried}
            \If {$I_j$ marked unsafe}
                \State Set range $Y_j := [0, 8L]$ \label{algoline:highd_marked_rangeset}
            \Else
                \State Set range $Y_j = [\min(S_j) - L\cdot \len(I_j)), \max(S_j) + L\cdot \len(I_j))] \cap [0,1]$ \label{algoline:highd_unmarked_rangeset}
            \EndIf
        \EndIf %\label{algo:queryendpt_end}
    \Else %{$I_t$ not marked unsafe} \label{algo:notmarked_beg}
        \State $Y_j := \algmq(I_j, Y_j)$
        \If { $\len(Y_j) < \max (4 L\cdot \len(I_j), 4L / T )$ }  \Comment{associated range $Y_j$ has shrunk enough}
            \State Bisect each side of $I_j$ to form $2^d$ new hypercubes each with length $\len(I_j) / 2$
            \State For each new hypercube $I_{ji}$ ($1\le i \le 2^d$) set $S_{ji} = Y_j$
        \EndIf %\label{algo:notmarked_end}
    %\Else \Comment{$I_t$ is marked dishonest} \label{algo:dishonest_begin}
        %\State Start from scratch until converge, takes $\log T$ steps \label{algo:test}
        
        %\State Let $\set{[], [], []}$ be the sequence of feasible region (endpoints? ) on the path to $I_t$. 
        %\State Perform binary search on this path and find the first interval [] that contains $f(I_t)$. \Comment{Takes $\log\log T$ steps}, set feasible region $I_t = []$
        %\State From this point perform binary search and shrink feasible region \Comment{Takes $c$ steps, where $c$ is number of corruptions before reaching a correction interval? }
    \EndIf %\label{algo:dishonest_end}
\EndFor
\end{algorithmic}
\end{algorithm}