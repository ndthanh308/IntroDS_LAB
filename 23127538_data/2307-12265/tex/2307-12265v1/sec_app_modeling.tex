
\section{Modelling Scenario
%with Non-Normal Modal Description Logics
}
\label{sec:model}

%To illustrate further the different principles validated by between relational and neighbourhood semantics,
%and to understand better the shortcomings of the former,
In the following,
%we illustrate with a running example
we present the modelling of an example scenario in the classic domain of multi-agent purchase choreography~\cite{MonEtAl10}.
The aim is twofold.
First, it displays some of the limitations of modalities defined on relational frames, motivating the adoption of neighbourhood semantics in modal extensions of description logics.
Second, it illustrates the expressivity of (non-normal) modal description logic languages, showing interactions between modalities and the constructs of the standard description logic $\ALC$.
%

Our multi-agent setting involves
a customer $\mathit{c}$,
a marketplace
$\mathit{m}$,
a seller $\mathit{s}$,
and
a warehouse $\mathit{w}$,
with
%formalised using a modal description logic language with the
agency operators $\mathbb{D}_i$ and $\mathbb{C}_i$, for $i \in \{ c, m, s, w \}$, read as `agent $i$ does/makes' and `agent $i$ can do/make', respectively~\cite{Elg,GovernatoriRotolo}. 
Concept names $\mathsf{Ord}$, $\mathsf{Prod}$, and $\mathsf{InCatal}$ are used to represent, respectively, orders, products, and the class of objects displayed as in-catalogue, while $\mathsf{req}$ is a role name for the request relation.
The formula
%\begin{equation}
$
\label{eq:1eq}
\mathsf{Ord} \equiv \mathbb{D}_{c}\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} )
$
%\end{equation}
defines an order $\mathsf{Ord}$ as a request made by customer $c$ of an in-catalogue
%($\mathsf{InCatal}$)
product.
%
Using the concept name $\mathsf{Confirm}$ to represent the class of objects that are confirmed, we also have that
%valid formula:
%\begin{equation}
$
\label{eq:2eq}
\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ) \sqsubseteq \mathsf{Confirm} \sqcup \lnot \mathsf{Confirm},
$
%\end{equation}
meaning that any request of an in-catalogue product is either confirmed or not confirmed.
However, relational semantics validates the so-called \emph{$\mathbf{M}$-principle} (often called \emph{monotonicity}) as well, according to which $C \sqsubseteq D$ always entails $\mathbb{D}_{c} C \sqsubseteq \mathbb{D}_{c} D$, for any concepts $C, D$.
Thus,
from the $\mathbf{M}$-principle %and the previous two formulas,
%from~(\ref{eq:1eq}),~(\ref{eq:2eq}) and the $\mathbf{M}$-principle above,
we would
%immediately
obtain
%\begin{equation}
$
\label{eq:monconc}
\mathsf{Ord} \sqsubseteq \mathbb{D}_{c} ( \mathsf{Confirm} \sqcup \lnot \mathsf{Confirm} ),
$
%\end{equation}
meaning that any order
%made by customer $c$
is made confirmed or not confirmed by $c$. This is an unwanted conclusion in our agency-based scenario, since customers' actions should be unrelated to any aspect of order confirmation.


Moreover, assume that the concept name $\mathsf{SubmitOrd}$ stands for the class of submitted orders, and that $\mathsf{PartConf}$ and $\mathsf{Reject}$ are used in our knowledge base to represent, respectively, the partially confirmed and the rejected
entities.
%\todo{N: I removed the pairwise disjointness.}
%They could be set as pairwise disjoint with $\mathsf{Confirm}$ by means of the formulas $\mathsf{Confirm} \sqsubseteq \lnot \mathsf{PartConf}$, $\mathsf{PartConf} \sqsubseteq \lnot  \mathsf{Reject}$, $\mathsf{Confirm} \sqsubseteq \lnot \mathsf{Reject}$.
%$C \sqsubseteq \lnot D$, with $C, D \in \{  \mathsf{Confirm}, \mathsf{PartConf}, \mathsf{Reject} \}$ and $C \neq D$.
Now consider the formula
%\begin{equation}
$
\label{eq:agglprem}
\mathsf{SubmitOrd} \sqsubseteq \mathbb{C}_{s}\mathsf{Confirm} \sqcap \mathbb{C}_{s}\mathsf{PartConf} \sqcap \mathbb{C}_{s}\mathsf{Reject},
$
%\end{equation}
stating that a submitted order can be confirmed, can be partially confirmed, and can be rejected by the seller $s$.
On relational frames, however, we have that
$ \mathbb{C}_{s} C \sqcap \mathbb{C}_{s} D \sqsubseteq \mathbb{C}_{s}( C \sqcap D ) $
 is a valid formula, for any concepts $C, D$, known as the \emph{$\mathbf{C}$-principle} (or \emph{agglomeration}).
 Therefore, by %~(\ref{eq:agglprem}) and
 the $\mathbf{C}$-principle, under relational semantics we would be forced to conclude that
%\begin{equation}
$
\label{eq:agglconc}
\mathsf{SubmitOrd} \sqsubseteq \mathbb{C}_{s}(\mathsf{Confirm} \sqcap \mathsf{PartConf} \sqcap \mathsf{Reject}),
$
%\end{equation}
meaning that any submitted order is such that the seller $s$ has the ability to make it confirmed, partially confirmed, and rejected, all \emph{at once}, which is unreasonable.

%M-PRINCIPLE
%Concepts $\mathsf{Ord}$, $\mathsf{Prod}$ and $\mathsf{Reject}$ are used to represent, respectively, orders, products, and the class of things that are rejected, while $\mathsf{req}$ is a role for the request relation.
%The axiom
%$\top \sqsubseteq \mathsf{Ord} \sqcup \mathsf{Prod}$
%%and $\mathsf{Ord} \sqcap \mathsf{Prod} \sqsubseteq \bot$
%%partition the domain into disjoint classes of products and orders.
%states that the domain is covered by orders or products.
%Moreover, the formula
%\begin{equation}
%\label{eq:1eq}
%\mathsf{Ord} \equiv \mathbb{D}_{c}\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} )
%\end{equation}
%defines an order $\mathsf{Ord}$ as a request made by customer $c$ of an in-catalogue ($\mathsf{InCatal}$) product.
%Under relational semantics, (\ref{eq:1eq}) entails, for instance, that
%$
%\mathsf{Ord} \sqsubseteq \mathbb{D}_{c} ( \mathsf{Ord} \sqcup \mathsf{Prod} )
%$,
%%$
%%\mathsf{Ord} \sqsubseteq \mathbb{D}_{c} \forall \mathsf{req}.\mathsf{Prod}
%%$,
%meaning:
%any order is made by customer $c$ to be either an order or a product.
%%any order is made by customer $c$ to be such that it request only products.
%This unwanted conclusion comes from
%$\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ) \sqsubseteq  \mathsf{Ord} \sqcup \mathsf{Prod}$
%%$\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ) \sqsubseteq \forall \mathsf{req}.\mathsf{Prod}$,
%(due to the covering axiom), and the fact that, over relational frames, $C \sqsubseteq D$ always entails $\mathbb{D}_{c} C \sqsubseteq \mathbb{D}_{c} D$,  for any concepts $C, D$.



Consider now the formula
%\begin{equation}
$
\label{eq:necprem}
\top \sqsubseteq \mathsf{Confirm} \sqcup \lnot \mathsf{Confirm},
$
i.e., the truism stating that anything is either confirmed or not confirmed.
%\end{equation}
By the so called \emph{$\mathbf{N}$-principle} (or \emph{necessitation}) of relational semantics, we have that if $\top \sqsubseteq C$ is valid on relational frames, then $\top \sqsubseteq \mathbb{D}_{c} C$ holds as well, for any concept $C$.
Thus, from
the $\mathbf{N}$-principle of relational semantics
%~(\ref{eq:necprem})
%and the truism above,
it would follow
that
%\begin{equation}
$
\label{eq:necprem}
\top \sqsubseteq \mathbb{D}_{c} (\mathsf{Confirm} \sqcup \lnot \mathsf{Confirm}),
$
%\end{equation}
thereby forcing us to the consequence that every object is made by customer $c$ to be either confirmed or not confirmed, and hence leading again to an unreasonable connection between customer's actions and confirmation of orders.
%
In fact, since customer $c$ plays no role in confirmation actions, it is sensible to assume that, for any object of the domain, it is not the case that $c$ makes it confirmed or not confirmed. This can be achieved by the formula
%\begin{equation}
$
\label{eq:qprinc}
\top \sqsubseteq \lnot \mathbb{D}_{c} (\mathsf{Confirm} \sqcup \lnot \mathsf{Confirm}),
$
%\end{equation}
an instance of a principle sometimes known as the \emph{$\mathbf{Q}$-principle}, which is \emph{unsatisfiable} in relational frames, while admissible over neighbourhood ones.

Finally, we consider additional principles that can be adopted both in relational and neighbourhood semantics.
The formula
%\begin{equation}
$
\label{eq:tprinc}
\mathbb{D}_{w} \mathsf{Avail}  \sqsubseteq \mathsf{Avail}
$
%	\mathbb{D}_{c} \exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ) \sqsubseteq \exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} )
%\end{equation}
states that
anything that is \emph{made} available by the warehouse $w$ is \emph{actually} available.
%anything that is \emph{made} by customer $c$ \emph{to be} a request of some in-catalogue products \emph{actually is} a request of some in-catalogue products.
This is an instance of the so-called \emph{$\mathbf{T}$-principle} (also \emph{factivity principle}), well-known in modal logic, particularly for its epistemic applications (if an agent \emph{knows} something, it has to be true).
Both in relational and neighbourhood semantics, the $\mathbf{T}$-principle entails the so-called \emph{$\mathbf{D}$-principle}.
This is instantiated by
%\begin{equation}
$
\label{eq:dprinc}
\mathbb{D}_{w} \mathsf{Avail}  \sqsubseteq \lnot \mathbb{D}_{w} \lnot \mathsf{Avail},
$
%\end{equation}
%\mathbb{D}_{w} \mathsf{Avail}  \sqsubseteq \hat{\mathbb{D}}_{cw} \mathsf{Avail}
%%	\mathbb{D}_{c} \exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ) \sqsubseteq \hat{\mathbb{D}}_{c}  \exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCatal} ),
%where $\hat{\mathbb{D}}_{c}$ abbreviates $\lnot \mathbb{D}_{c} \lnot$,
a formula asserting that
anything that is \emph{made available} by the warehouse $w$ is \emph{not made unavailable} by $w$.
%a request, made by customer $c$, of some in-catalogue products is not something that $c$ makes 
This principle, also well-known for its epistemic implications (anything that is \emph{known} by an agent is \emph{compatible} with their knowledge),
in relational semantics is \emph{equivalent} to a much lesser known principle, sometimes called \emph{$\mathbf{P}$-principle}.
An example of it is given by the formula
$
 \top \sqsubseteq \lnot \mathbb{D}_{w} (\mathsf{Avail} \sqcap \lnot \mathsf{Avail}),
$
which states that, for any object, it is not the case that the warehouse $w$ makes it both available \emph{and} unavailable.
Neighbourhood semantics, under which the $\mathbf{D}$- and the $\mathbf{P}$-principle are \emph{not equivalent}, allows for distinctions between modal constraints that are hence more fine-grained than in relational semantics.


%N-PRINCIPLE

%suppose that our knowledge base contains the formula
%\begin{equation}
%\label{eq:necprem}
%\mathsf{InvalidOrd} \sqsubseteq \mathbb{C}_{s} \mathsf{Cancel},
%\end{equation}
%asserting the seller $s$ has the power to cancel ($\mathsf{Cancel}$ any invalid order ($\mathsf{InvalidOrd}$).

%Under relational semantics, due to a principle known as \emph{necessitation} and here called \emph{$\mathbf{N}$-principle}, it follows that $\mathbb{D}_{w} \mathsf{Avail}$
%Clearly, the following formula is valid: $\top \sqsubseteq \mathsf{Avail} \sqcup \lnot \mathsf{Avail}$, that is, everything is either available or not available.

%The formula
%\begin{equation}
%%\label{eq:2eq}
%\top \sqsubseteq \forall \mathsf{req}.\mathsf{Prod}
%\end{equation}
%formalises that the range of the request relation $\mathsf{req}$ is a product $\mathsf{Prod}$.

%The formula $\top \sqsubseteq \forall \mathsf{req}.\mathsf{Prod}$ formalises that the range of the request relation $\mathsf{req}$ is a product $\mathsf{Prod}$
%
%\ldots
%
%The $\mathbb{C}_i$ operator expresses `agent $i$ can do/make'.
%

%The formula
%\begin{equation}
%\label{eq:2eq}
%\mathbb{C}_{w} \mathsf{Avail} \sqcap \mathbb{C}_{w} \lnot \mathsf{Avail} \sqsubseteq \forall .\mathsf{Prod}
%\end{equation}
%is valid on


%\todo[inline]{
%%$M, C, N$: counterexamples (valid in relational, not valid in neighbourhood)\\
%$Q$: always invalid in relational + example for validity on neighbourhood\\
%$P,D,T$: possibly hold in relational and in neighbourhood, examples for agency - $P, D$ equivalent in relational but not in neighbourhood semantics
%}

%To motivate further the modal description logic languages, we use description purchase choreography scenario, involving
%a customer $\mathit{c}$,
%a seller $\mathit{s}$,
%a warehouse $\mathit{w}$,
%and a marketplace
%$\mathit{m}$.
%The agency operator $\mathbb{D}_i$ is read as `agent $i$ does/makes', while $\mathbb{C}_i$ expresses `agent $i$ can do/make'.
%Valid principles: $\mathbb{D}_i C \sqsubseteq C$; $\mathbb{D}_i C \sqsubseteq \mathbb{C}_i C$
%

















%%%  FIGURE - SINGLE COLUMN VERSION
%% Figure environment removed


%%%  FIGURE - DOUBLE COLUMN VERSION
% Figure environment removed





























%The formulas discussed so far, to understand the shortcomings of relational frames and to motivate neighbourhood semantics, are part of
The full knowledge base describing the purchase choreography scenario
is reported in Figure~\ref{fig:purchasekb}.
%Remove $\mathbb{D}_{i}C \sqsubseteq \mathbb{C}_{i}C$ from caption? We are not able to treat it (no interacting modalities, cf. Discussion)
Notably, it displays a great range of interactions between modal and description logics constructs.
The modal operators $\mathbb{D}_{i}$ and $\mathbb{C}_{i}$ are axiomatized similarly to~\protect\cite{Elg}:
$\mathbb{D}_{i}$ obeys the $\mathbf{C}$- and $\mathbf{T}$-principles;
%$\mathbb{C}_{i}$
%obeys the $\mathbf{Q}$-principle,
%  {\color{red}{
%  and we have the axiom schema $\mathbb{D}_{i} C \sqsubseteq \mathbb{C}_{i} C$.
%  }}
  and both satisfy the $\mathbf{Q}$-principle, and the $\mathbf{E}$-principle:
  $C \equiv D$ entails $\mathbb{D}_{i} C \equiv \mathbb{D}_{i} D$ and $\mathbb{C}_{i} C \equiv \mathbb{C}_{i} D$.



On the left column, the first four axioms impose that the range of the request relation is a product, and that 
the classes of confirmed, partially confirmed, and rejected objects are all disjoint.
We have already discussed the fifth axiom, which is the definition of an order as a request, made by a customer, for some in-catalogue product.
The last four axioms on the left column define, respectively:
a submitted order as an order that is actually submitted by a customer;
an incomplete order as an order that is not submitted by the customer;
an invalid order as an order that cannot be submitted by the customer;
and a confirmed order as an order that is confirmed by the seller.

On the right column, the first formula states that an invalid order can be cancelled by the seller.
The second axiom asserts that, given a submitted order, the seller can check at the warehouse for availability of all of its requested products.
The third formula, as already discussed, requires that a submitted order can be confirmed, can be partially confirmed, and can be rejected by the seller.
The subsequent three axioms impose, respectively, the following constraints:
anything that is confirmed by the seller has to request only products made available by the warehouse;
anything that requests products that are made available, as well as products that are brought about to be unavailable by the warehouse, can be partially confirmed by the seller;
%\todo{I removed ``only'' (``can only be partially confirmed''): maybe we'd like $\lnot \mathbb{C}_s\mathsf{Conf} \sqsupseteq$ otherwise.}
finally, any request of products that are all unavailable at the warehouse can be rejected by the seller.
The third formula from the bottom of the right column states that the marketplace enforces that a confirmed order cannot be rejected by the seller.
%\todo{check for any possible inconsistency with Q-principle and $ConfirmOrd \sqsubseteq \lnot Reject$.}
The second last axiom defines a dispatched order as an order that the seller makes the warehouse dispatch.
Finally, the last formula imposes that the marketplace brings it about that any confirmed order is also dispatched.













%%%
%\todo[inline]{M: Introduction ARQNL22}
%
%
%Contexts involving
%%a certain degree of
%agency-based~\cite{Brown,Elg} and coalitional~\cite{Pau,Tro},
%epistemic and doxastic~\cite{Ago,Bal,Var1}, as well as deontic~\cite{AngEtAl,Gob,Wright}, reasoning capabilities populate the wide spectrum of settings where modal logics have found natural applications.
%In such scenarios, modal operators can be used to represent and reason about what agents, or groups of agents, respectively know, believe, have the capability, or have the permission, to bring about.
%
%The semantics of modal operators is usually given in terms of \emph{relational models}, based on frames consisting of a set of possible worlds equipped with suitable accessibility relations.
%However, all the modal systems interpreted by means of this kind of semantics, known as \emph{normal}, validate principles that have been considered problematic or debatable for the aforementioned applications, leading to counterintuitive or unacceptable conclusions.
%Among the unpleasant features discussed in the literature, one encounters for instance the problem of logical omniscience~\cite{Var1}, as well as a number of so-called paradoxes in the representation of agents' abilities~\cite{Elg} and obligations~\cite{Ross,Aqv,For}.
%
%To avoid the unwanted consequences of the relational semantics, several \emph{non-normal} modal logics have been proposed and studied, tracing back to the seminal works by C.I. Lewis~\cite{CIL}, Lemmon~\cite{Lem}, Kripke~\cite{Kripke}, Scott~\cite{Sco}, Montague~\cite{Mon}, Segerberg~\cite{Seg}, and Chellas~\cite{Che}.
%The semantics of such systems can be given in terms of \emph{neighbourhood models}, generalisations of the relational ones first introduced by Scott \cite{Sco} and Montague \cite{Mon}.
%In this setting, a frame consists of a set of worlds, each of which is associated with a set of subsets of worlds. Since a subset of worlds can be thought as a proposition (that is true in those worlds), this means that every world in a neighbourhood model is assigned to a set of propositions, those considered necessary with respect to that world.
%%
%This semantics both generalises the relational one, and avoids the drawbacks of the latter, since the modal principles validated on relational frames that are deemed as problematic for epistemic, coalitional or deontic applications do not hold in general on neighbourhood models.
%
%
%
%Non-normal modalities have been widely investigated as a way to extend propositional logic.
%A further line of research focuses on the behaviour of modal operators interpreted on neighbourhood frames in combination with first-order logic.
%%
%In this direction, a few works have provided completeness results for first-order non-normal modal logics~\cite{Cos,CosPac}.
%%
%In addition, non-normal modal extensions of \emph{description logics}, seen as fragments of first-order logic with a good trade-off between expressive power and computational complexity, have been considered for knowledge representation applications~\cite{SeyErd09, DL19}, also in multi-agent coalitional settings~\cite{SeyJam09,SeyJam10}.
%
%
%In this paper, we investigate
%satisfiability of non-normal modal extensions of description logics.
%In particular,
%%we study the logics associated with the class of
%%all neighbourhood frames,
%%supplemented neighbourhood frames, 
%%neighbourhood frames closed under intersection,
%%and neighbourhood frames containing the unit
%%(characterising, at the propositional level, the non-normal modal systems $\mathbf{E}$, $\mathbf{M}$, $\mathbf{C}$, and $\mathbf{N}$, respectively),
%we study the logics
%characterised by
%%associated with
%the class of all neighbourhood frames ($\mathbf{E}$),
%supplemented neighbourhood frames ($\mathbf{M}$), 
%neighbourhood frames closed under intersection ($\mathbf{C}$),
%and neighbourhood frames containing the unit ($\mathbf{N}$),
%and combine them with the prototypical $\ALC$ description logic. 
%We provide a framework of terminating, correct, and complete tableau algorithms to check 
%satisfiability in such logics interpreted
%in neighbourhood models
%with \emph{varying domains}
%(in this kind of semantics, the domains of the interpretations
%at each world
%%representing worlds
%can differ;
%cf.~Section~\ref{sec:prelim} for details).
%%regarding the semantics). 
%%Our proofs for the tableau algorithm include a characterization 
%%of neighbourhood models in terms of \emph{quasimodels}~\cite{?}, %cite yellow book
%%a classical technique used in modal logic to prove complexity results.  
%We then investigate the satisfiability problems in fragments of these languages obtained by restricting the application of modal operators to formulas only, and provide complexity upper bounds with \emph{constant domains}
%(in this case 
%%this is the more classical case in which
%the domains of the interpretations
%at every world
%%representing the worlds
%are the same).
%We leave satisfiability checking procedures for non-restricted languages interpreted on models with constant domain as open problems.
%%We leave the general case of satisfiability in these logics with constant domains as
%%open problems. 
%
%Full proof details are provided in an extended version of this paper~\cite{DalEtAl22arxiv}.
















































































%\section{Modelling}
%
%\subsection{Purchase Choreography Scenario}
%
%Abbreviations:
%$\mathit{c}$ := \emph{customer};
%$\mathit{s}$ := \emph{seller};
%$\mathit{w}$ := \emph{warehouse};
%$\mathit{m}$ := \emph{marketplace}
%\\
%Modalities: $\mathbb{D}_i C/\varphi$ - agent $i$ does/makes $C$/$\varphi$; $\mathbb{C}_i C/\varphi$ - agent $i$ can do/make $C$/$\varphi$ (alternative: $\mathbb{O}_i C/\varphi$ - agent $i$ oughts to do/make $C$/$\varphi$)
%\\
%Valid principles: $\mathbb{D}_i C \sqsubseteq C$; $\mathbb{D}_i C \sqsubseteq \mathbb{C}_i C$
%
%Cf. KB below:
%%
%\begin{align*}
%\top & \sqsubseteq \forall \mathsf{requests}.\mathsf{Product}
%\\
%\mathsf{Ord} & \equiv \mathbb{D}_{c}\exists \mathsf{req}.(\mathsf{Prod} \sqcap \mathsf{InCat} )
%\\
%\mathsf{IncomplOrd} & \equiv \mathsf{Ord} \sqcap \lnot \mathbb{D}_{c} \mathsf{Submit}
%\\
%%\mathsf{IncompleteOrder} & \sqsubseteq \lnot \mathsf{ExpiredOrder}
%%\\
%\mathsf{SubmitOrd} & \equiv
%\mathsf{Ord} \sqcap \mathbb{D}_{c} \mathsf{Submit}
%\\
%\mathsf{InvalidOrd} & \equiv  \mathsf{Order} \sqcap \lnot \mathbb{C}_{c} \mathsf{Submit}
%\\
%\mathsf{InvalidOrd} & \sqsubseteq \mathbb{C}_{s} \mathsf{Cancel}
%\\
%\mathsf{SubmitOrder} & \sqsubseteq \mathbb{C}_{s} \forall \mathsf{req}.
%(\mathbb{D}_{w} \mathsf{Avail} \sqcup \mathbb{D}_{w} \lnot \mathsf{Avail})
%\\
%\mathsf{SubmitOrd} & \sqsubseteq \mathbb{C}_{s}\mathsf{Confirm} \sqcap \mathbb{C}_{s}\mathsf{PartConf} \sqcap \mathbb{C}_{s}\mathsf{Reject}
%\\
%\mathbb{D}_{s} \mathsf{Confirm} & \sqsubseteq \forall \mathsf{req}.
%\mathbb{D}_{w}\mathsf{Avail}
%\\
%\mathbb{C}_{s} \mathsf{PartConf} & \sqsupseteq \exists \mathsf{req}.
%\mathbb{D}_{w}\mathsf{Avail} \ \sqcap
%\exists \mathsf{req}.
%\mathbb{D}_{w} \lnot \mathsf{Avail}
%\\
%\mathbb{C}_{s} \mathsf{Reject} & \sqsupseteq \forall \mathsf{req}.
%\mathbb{D}_{w}\lnot\mathsf{Avail}
%\\
%\mathsf{ConfirmOrd} & \equiv \mathsf{Ord} \sqcap \mathbb{D}_{s} \mathsf{Confirm}
%\\
%\mathbb{D}_{m}
%(
%\mathsf{ConfirmOrd} & \sqsubseteq
%\lnot \mathbb{C}_{s} \mathsf{Reject}
%)
%\\
%\mathsf{DispatchOrd} & \equiv \mathsf{Ord} \sqcap \mathbb{D}_{s} \mathbb{D}_{w} \mathsf{Dispatch}
%\\
%\mathbb{D}_{m}
%(
%\mathsf{ConfirmOrd} & \sqsubseteq
%\mathsf{DispatchOrd}
%)
%\end{align*}
%
%%% Figure environment removed
%%
%%\todo[inline,caption={}]{
%%M: todo complete/fix example
%%}
%
%
%%\begin{align*}
%%\mathsf{Order} & \sqsubseteq \mathbb{D}_{c}\exists \mathsf{requests}.\mathsf{Product} \sqcap \exists \mathsf{hasStatus}.\mathsf{OrderStatus}
%%\\
%%\mathsf{Product} & \sqsubseteq \exists \mathsf{hasStatus}.\mathsf{ProductStatus}
%%\\
%%\mathsf{OrderStatus} & \equiv \mathsf{Submitted}
%%%\sqcup \mathsf{Incomplete}
%%\sqcup \mathsf{Cancelled} \ \sqcup \\  
%%& \phantom{ \sqsubseteq \ \ } \mathsf{Confirmed} \sqcup \mathsf{PartiallyConfirmed} \sqcup \mathsf{Rejected}  \ \textit{(suitably disjoint)}
%%\\
%%\mathsf{ProductStatus} & \equiv \mathsf{Available} \sqcup \mathsf{Unavailable} \ (\textit{disjoint})
%%\\
%%\mathsf{SubmittedOrder} & \equiv \mathsf{Order} \sqcap \exists \mathsf{hasStatus}.\mathbb{D}_{c}\mathsf{Submitted}
%%\\
%%\mathsf{IncompleteOrder} & \equiv \mathsf{Order} \sqcap \forall \mathsf{hasStatus}.\lnot \mathbb{D}_{c}\mathsf{Submitted}
%%%\mathsf{IncompleteOrder} \equiv \mathsf{Order} \sqcap \exists \mathsf{hasStatus}.\mathsf{Incomplete}
%%\\
%%%\mathsf{CancelledOrder} & \equiv \mathsf{Order} \sqcap \exists \mathsf{hasStatus}.\mathsf{Cancelled},
%%%\
%%\mathbb{C}_{sl} ( \mathsf{IncompleteOrder} & \sqsubseteq  \mathsf{Order} \sqcap \exists \mathsf{hasStatus}. \mathbb{D}_{s} \mathsf{Cancelled})
%%%\mathbb{C}_{sl} ( \mathsf{Order} \sqcap \exists \mathsf{hasStatus}.\mathsf{Incomplete} & \sqsubseteq  \mathsf{Order} \sqcap \exists \mathsf{hasStatus}. \mathbb{D}_{sl} \mathsf{Cancelled})
%%\\
%%\mathsf{SubmittedOrder} & \sqsubseteq  \mathbb{C}_{s} \mathsf{ConfirmedOrder} \sqcup  \mathbb{C}_{s} \mathsf{PartiallyConfirmedOrder}  \sqcup \mathbb{C}_{s} \mathsf{RejectedOrder}  
%%\\
%%\mathsf{RejectedOrder} & \equiv \mathsf{SubmittedOrder} \sqcap \exists \mathsf{hasStatus}.\mathbb{D}_{s}\mathsf{Rejected}
%%\\
%%\mathsf{ConfirmedOrder} & \equiv \mathsf{SubmittedOrder} \sqcap \exists \mathsf{hasStatus}.\mathbb{D}_{s}\mathsf{Confirmed}
%%%\\
%%%\mathsf{ConfirmedOrder} & \sqsubseteq \lnot \mathsf{RejectedOrder}
%%\\
%%\mathbb{C}_{s} \mathsf{ConfirmedOrder} & \sqsubseteq \mathsf{Order} \sqcap \forall \mathsf{requests}.(\mathsf{Product} \sqcap  \exists \mathsf{hasStatus}.\mathbb{D}_{w}\mathsf{Available})
%%\\
%%\mathbb{C}_{s} \mathsf{PartiallyConfirmedOrder} & \sqsupseteq \mathsf{Order} \sqcap \exists \mathsf{requests}.(\mathsf{Product} \sqcap  \exists \mathsf{hasStatus}.\mathbb{D}_{w}\mathsf{Available}) \ \sqcap
%% \\
%%& \phantom{\sqsubseteq \ \ } 
%%\exists \mathsf{requests}.(\mathsf{Product}\sqcap  \exists \mathsf{hasStatus}.\mathbb{D}_{w}\mathsf{Unavailable})
%%\\
%%\mathbb{C}_{s} \mathsf{RejectedOrder} & \sqsupseteq \mathsf{Order} \sqcap \forall \mathsf{requests}.(\mathsf{Product} \sqcap  \exists \mathsf{hasStatus}.\mathbb{D}_{w}\mathsf{Unavailable})
%%\end{align*}
%
%
%%\subsection{Organisation Structure Scenario}
%%
%%\ldots
%
%
%
%
%
%
%
%
%%\subsection{Driving Licence Scenario}
%%
%%$\mathit{DMV}$ = Department of Motor Vehicles
%%
%%\noindent
%%$\cstyle{TruckDriver} \equiv \cstyle{Driver} \sqcap \exists \cstyle{hasLicence}.\mathbb{D}_{\mathit{DMV}} \cstyle{TruckDrivingLicence}$
%%
%%\noindent
%%$\cstyle{ExceptionalTruckDriver} \equiv \cstyle{TruckDriver} \sqcap \mathbb{D}_{\mathit{LocalAuthority}} \exists \cstyle{hasPermission.ExceptionalTransportationPermission}$
%%
%%\noindent
%%$\cstyle{Fine} \equiv \mathbb{D}_{\mathit{officer}} \cstyle{Issued} \sqcup \mathbb{D}_{\mathit{radar}} \cstyle{Issued}$
%%
%%\noindent
%%$\cstyle{QuestionableFine} \equiv \cstyle{Fine} \sqcap \mathbb{C}_{\mathit{judge}} \cstyle{Remitted}$
%%
%%\noindent
%%$\cstyle{SanctionedDriver} \equiv \cstyle{Driver} \sqcap \exists \cstyle{hasFine.Fine}$
%%
%%\noindent
%%$\cstyle{AcquittedDriver} \equiv \cstyle{SanctionedDriver} \sqcap \exists\cstyle{hasFine}.(\cstyle{Fine} \sqcap \mathbb{D}_{\mathit{judge}} \cstyle{Remitted})$
%%
%%\noindent
%%$\cstyle{ColludedDriver} \equiv \cstyle{SanctionedDriver} \sqcap \forall \cstyle{hasFine}.\mathbb{D}_{\mathit{judge}} \cstyle{Remitted}$
%%
%%\noindent
%%$\mathbb{C}_{\mathit{LocalAuthority}} (\cstyle{TaxiDriver} \sqsubseteq \exists \cstyle{hasPermission.CityCenterPermission})$
%%
%%\noindent
%%$\mathbb{C}_{\mathit{DMV}} \exists \cstyle{hasLicence.TruckDrivingLicence} \sqsubseteq \cstyle{ExpertDriver}$
%%
%%\noindent
%%$\mathbb{C}_{\mathit{DMV}} \exists \cstyle{hasLicence.CarLicence} \sqsubseteq \cstyle{Adult}$
%%
%%
%%\bigskip
%%
%%difference between
%%
%%$\mathbb{D}_{\mathit{DMV}} \exists \cstyle{hasLicence.TruckDrivingLicence}$
%%
%%and
%%
%%$\exists \cstyle{hasLicence}.\mathbb{D}_{\mathit{DMV}} \cstyle{TruckDrivingLicence}$?
%%
%%e.g. issue the licence vs. recognise the licence issued by another authority? 
%%
%%
%%\ldots
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%%%% OLD EXAMPLE
%
%\begin{comment}
%
%% Figure environment removed
%
%\end{comment}
