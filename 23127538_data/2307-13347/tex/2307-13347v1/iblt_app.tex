\section{Additional details on IBLT}
\label{sec:iblt_app}
\paragraph{Intuition on \texttt{ListEntries} for IBLT.} The intuition behind the IBLT construction is as follows:
Start with an array $\mathcal{B}$
of length $\ell$ containing 4-tuples
of the form $(0,0,0,0)$.
To insert pair $(x, v)$
hash the tuple ($x$, $\tilde{x}$, $v$, $1$) into $k$ locations $l_1, \ldots, l_k$ in $\mathcal{B}$ based on the key $x$, where $\tilde{x} := G(x)$ is a 
hash of $x$ into a sufficiently large domain so that collision probability is sufficiently unlikely. %
Then add, using component-wise sum, ($x$, $\tilde{x}$, $v$, $1$) to the contents of 
$\mathcal{B}$ in all locations $l_1, \ldots, l_k$.
The $\texttt{ListEntries}/\deciblt$ operation corresponds to the result of the following procedure: (1) find an
entry ($x_{sum}$, $\tilde{x}_{sum}$, $v_{sum}$, $j$) such that $G(x_{sum}/j) = \tilde{x}_{sum}/j$ holds, 
(2) add $(x_{sum}/j, v_{sum})$ to the output, and
(3) remove the pair $(x_{sum}/j, v_{sum})$
by subtracting ($x_{sum}$, $\tilde{x}_{sum}$, $v_{sum}$, $j$)
from the entries $l_1', \ldots, l_k'$ in the array $\mathcal{B}$ to which an insertion would add the tuple for key $x_{sum}/j$ and get back to step (1).
The process of listing entries a.k.a ``peeling off" $\mathcal{B}$.
might terminate before the IBLT is empty.
This is the failure procedure in 
Lemma~\ref{lem:iblt}, which corresponds to the natural procedure to find a 2-core in a random graph \cite{Goodrich2011iblt}.

\paragraph{Sketch size.} 
The above intuition corresponds to the IBLT construction variant from~\cite{Goodrich2011iblt}
that can handle duplicates.
It can be implemented with four length $\ell$ vectors with entries in 
$[d], \texttt{Im}(G), [mn], [mn]$,
respectively. 
In terms of concrete parameters (see ~\cite{Goodrich2011iblt} for details), $k = 3, \ell > 1.3 L_0$,
and $G = \mathbb{Z}_p$ with $p = 2^{31}-1$ give good performance, and require
$1.3L_0(32 + \log_2 d + 2\log_2(mn))$ bits. For the experiment setting considered in \cref{sec:exp}, this is will take at most $8L_0$ words.

\paragraph{Cardinality estimation from saturated IBLT.} 
\cref{lem:iblt} tells us that 
a tight bound $L_0$ on the number of distinct non-zero indices in the intended histogram, 
can save us space in an IBLT encoding. %
However, getting that bound wrong results in an undecodable IBLT. 
While in the single round case all is lost, in the multi-round setting
we leverage a property of undecodable IBLTs that helps update our $L_0$ bound for subsequent rounds
after a failed round. This is the main ingredient for our adaptive tuning heuristic presented in Section~\ref{sec:adaptive}.

Let $\mathcal{B}$ be an undecodable IBLT, and let $S$ be the size of the undecoded graph of $\mathcal{B}$. Also let $\ell$ be the size of $\mathcal{B}$, and let $N$ the (unknown) 
number of distinct elements inserted in $\mathcal{B}$ 
(note that $N$ corresponds to the correct bound $L_0$ that enables decoding).
By \cite{molloy2005cores}, we have the following relation: 
For large enough $N$, if $S < \ell$, we have 
\begin{equation}\label{eq:cardinality-from-core}
    \frac{S}{C} = 1 - e^{-x}(1+x) + o(1),
\end{equation}
where $x$ is the greatest solution to 
\begin{equation}\label{eq:cardinality-from-core-2}
    \frac{6N}{C} = \frac{2x}{(1 - e^{-x})^2}.
\end{equation}
Hence we can have an estimate for $N$ (and thus a correct choice for $L_0$ in a subsequent round) 
based on  $S$ and $C$. We first solve \eqref{eq:cardinality-from-core} ignoring the $o(1)$ term to get $x$ and then plug $x$ and $C$ into \eqref{eq:cardinality-from-core-2} to get an estimate for $N$.
As mentioned above we leverage this fact in Section~\ref{sec:adaptive}.

