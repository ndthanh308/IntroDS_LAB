\section{The Curious Case of Complete Binary Trees}\label{sec:completebintrees}

%\hadi{I think what we study here are technically called ``Perfect Binary Trees'' as we assumed all leaves are at the same level. The standard definition of Complete Binary Tree allows for the last level to be incomplete.}

In this section, we investigate {\GHA} on instances where the underlying graph is a complete binary tree $B_k$. Recall that such a tree has depth $k$, and $2^{k+1} - 1$ vertices in total, of which $2^k$ are leaves. All leaves, furthermore, are at the same depth.

In \citet[Theorem 4.11]{canon}, it was shown that for any binary tree (complete or otherwise), at least one optimal allocation satisfies the \emph{local median property}: the value at every internal node is the median among the values given to that node and its two children. The same authors surmised that, for any binary tree, at least one optimal allocation satisfies the stronger \emph{global median property}: for every internal node $v$, either its left subtree gets strictly lower-valued houses and its right subtree gets strictly higher-valued houses, or the other way round. Note that if true, this would lead to a straightforward recursive polynomial-time algorithm that would compute an optimal allocation on (nearly) balanced binary trees. %Note that a complete binary tree has only one global median allocation (up to reordering the subtrees at any of the internal nodes), and so the conjecture would imply a nearly linear-time value-agnostic algorithm for complete binary trees.
%\andrew{Would the running time really be $O(2^d)$? It seems that if the conjecture was true, you should just sort the elements in $H$ and place them on the leaves appropriately. But sorting is $O(n\log n)$} (see chat)

We now give a refutation of this conjecture. We illustrate an instance on a complete binary tree of depth $3$, in which no optimal allocation satisfies the global median property. This is a quite surprising result that shows that the general problem on complete binary trees may be much harder than expected.

\begin{example}\label{ex:globalrefutation}
    Consider the instance $(B_3, H)$, where
    \begin{equation*}
        H = \{0,0,0,0,0,0,0,1,1,1, 2,3,3,3,3\}.
    \end{equation*}
    \begin{comment}
    % Figure environment removed

% % Figure environment removed
\end{comment}
    See Figure \ref{fig:global-min-arg}. The top shows the only allocation satisfying the global median property (up to re-ordering). The total non-negligible envy incurred by this assignment comes out of the thick red edges of the $B_3$, which incur a total envy of $6$. However, the bottom shows an allocation with an envy of $5$ (incurred by the thick red edges), showing that the global median is strictly sub-optimal.
    % % Figure environment removed
\end{example}



    % Figure environment removed

% \begin{table*}[th]
%     \centering
%     \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c| } 
%  \hline
%  $m$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 \\
%  \hline
%  $\mathsf{elegance}(m)$ & 1 & 2 & 1 & 2 & 3 & 2 & 1 & 2 & 3 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 3 & 2 & 3 & 4 \\
%  \hline
% \end{tabular}
%     \caption{List of $\mathsf{elegance}(m)$ for $1 \leq m \leq 20$.}
%     \label{tab:repunit}
% \end{table*}


Fix an arbitrary instance of {\GHA} on the complete binary tree $B_k$ on $n = 2^{k+1} - 1$ vertices, and consider the valuation interval. There are $n$ values on the interval. Of particular interest to us is the size of the \emph{smallest} $(i, n - i)$-cut, i.e., $\delta_{B_k}(i)$. Since $\delta_{B_k}(i) = \delta_{B_k}(n - i)$, we can WLOG take $i \leq \lceil n/2\rceil$. We now need a definition.

\begin{definition}[Repunit Representation and Elegance]\label{def:repunitrepresentation}
    For any $m \geq 1$, let a \emph{repunit representation of $m$} be any finite sequence $(a_1, \ldots, a_r) \in \mathbb{Z}^r$ satisfying
    \begin{equation*}
        m = \sum_{i =1}^r {\mathsf{sgn}(a_i)} \cdot (2^{|a_i|} - 1)
    \end{equation*}
    where $\mathsf{sgn}(a_i)$ is $1$ (resp.~$-1$) if $a_i \geq 0$ (resp.~$a_i < 0$). Note that every $m \geq 1$ has a repunit representation (e.g.,~the length-$m$ sequence of all ones). We define $\mathsf{elegance}(m)$ as the smallest $r$ for which $m$ has a repunit representation $(a_1, \ldots, a_r)$ of length $r$.
\end{definition}

The intuition behind Definition \ref{def:repunitrepresentation} is to capture the most ``efficient'' way to write $m$ in binary as the sum or difference of binary repunits, i.e., numbers of the form $11\ldots 1$. For instance, $\mathsf{elegance}(10) = 2$, because $10 = (2^3 - 1) + (2^2 - 1)$, and there is no shorter repunit representation. Similarly, $\mathsf{elegance}(12) = 2$, as $12 = (2^4 - 1) - (2^2 - 1)$. Note that $12$ cannot be written as the \emph{sum} of two repunits. Table \ref{tab:repunit} summarizes the elegance of all numbers up to $20$.

\begin{table*}[h!]
    \centering
    \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c| } 
 \hline
 $m$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 \\
 \hline
 $\mathsf{elegance}(m)$ & 1 & 2 & 1 & 2 & 3 & 2 & 1 & 2 & 3 & 2 & 3 & 2 & 3 & 2 & 1 & 2 & 3 & 2 & 3 & 4 \\
 \hline
\end{tabular}
    \caption{List of $\mathsf{elegance}(m)$ for $1 \leq m \leq 20$.}
    \label{tab:repunit}
\end{table*}

% \begin{center}


The following proposition relates elegance to the size of the smallest $(i,n-i)$-cut in a complete binary tree, namely $\delta_{B_k}(i)$.


\begin{restatable}{proposition}{elegancecuts}\label{prop:elegance}
    Let $B_k$ be the complete binary tree on $n = 2^{k + 1} - 1$ vertices. Then for $i \leq 2^k - 1$, $\mathsf{elegance}(i) - 1 \leq \delta_{B_k}(i) \leq \mathsf{elegance}(i)$.
\end{restatable}
\begin{proof}
    Consider \emph{any} $(i, n - i)$-cut in $B_k$, say $(S, V \setminus S)$, with $|S| = i$, and suppose there are $m'$ edges going across the cut. We will construct a repunit representation of $i$ with at most $m' + 1$ terms. Suppose the tree $B_k$ is rooted at the node $r$, and direct each edge from parent node to child node. Initialize a sequence $\vec{v}$ to be empty, and take any edge $e$ going across the cut $(S, V \setminus S)$. Observe that $e$ is either directed from $S$ to $V \setminus S$ or the other way round. This edge must have a complete binary subtree $B_{k_1}$ on one side in $B_k$: specifically, the subtree rooted at the child of $e$. If the edge $e$ is directed from $V \setminus S$ to $S$, then append the term $k_1 + 1$ to $\vec{v}$ (this corresponds to adding a repunit), and if $e$ is directed from $S$ to $V \setminus S$, append the term $-(k_1 + 1)$ (corresponding to subtracting a repunit). Once this is done for all edges $e$ going across the cut, we end up with a finite sequence $\vec{v}$. It is now easy to check that either this sequence $\vec{v}$, or the sequence $\vec{v}$ appended with the term $k + 1$, is a valid repunit representation of $i$. It follows that if the cut had been the minimum one, we would have a repunit representation of $i$ with at most $\delta_{B_k}(i) + 1$ terms. Therefore, $\mathsf{elegance}(i) \leq \delta_{B_k}(i) + 1$.

    Conversely, consider any optimal valid repunit representation of $i$ (which, therefore, has $\mathsf{elegance}(i)$ terms). Note that we can assume WLOG that all the terms are distinct in absolute value. This is because adding and subtracting the same term gives us a suboptimal representation, whereas $(2^{k_1} - 1) + (2^{k_1} - 1) = 2^{k_1 + 1} - 1 - 1$, so we can replace two additive repunits of the same length by two other unequal-length repunits without changing the result. We claim that we can assume WLOG that the largest repunit in this representation is at most $2^k - 1$. Otherwise, if it is $2^{k + 1} - 1$ or larger, then note that the next most significant repunit needs to be $-2^k + 1$, as otherwise the distinctness assumption gives us $i \geq (2^{k+1} - 1) - \sum_{j = 1}^{k-1}(2^j - 1) \geq 2^k$, contradiction. We can replace these two terms using $(2^{k+1} - 1) - (2^k - 1) = (2^k - 1) + 1$, which would replace these two terms by two other repunits without changing the value. This would be a valid representation, with all distinct terms unless the original representation also had a $+1$ term in it. We could then replace the $+1 + 1$ by $+3 - 1$, which would again be valid, unless the original had a $+3$ term in it. We could then replace the $+1 + 1 + 3$ by $+7 - 3 + 1$, which would again be valid, unless the original had a $+7$ term in it. We can keep going this way. What is the largest additive term in the original that we can run into in this way? Note that if we get to an additive term of $2^{k-1} - 1$, then we would have $i \geq (2^{k+1} - 1) - (2^k - 1) + (2^{k-1} - 1) - \sum_{j = 1}^{k-2}(2^j - 1) \geq 2^k$, contradiction. So the largest (additive) term can only be $2^{k-2} - 1$, and we would then terminate.
    
    So now we have an optimal repunit representation of $i$ with all distinct terms in absolute value, with the largest term being at most $2^k - 1$. We now claim that this repunit representation gives rise to an $(i, n - i)$ cut in $B_k$. We can just take complete binary subtrees of the sizes determined by the terms of the repunit representation, and include or exclude them on one side of the cut (according to the sign of the relevant term). The edges going across the cut will exactly be the edges to the roots of these subtrees, and the number of these edges will be exactly the number of terms in the original representation. This is \emph{some} $(i, n - i)$-cut of $B_k$, and so the smallest one has at most as many edges going across it as this one. It follows that $\delta_{B_k}(i) \leq \mathsf{elegance}(i)$.
\end{proof}
% \begin{proof}[Proof Sketch]
%     For each edge going across a cut in $B_k$, one of its endpoints is the root of a binary subtree, and it contributes a term in a repunit representation (possibly along with an extra additive term). Conversely, any repunit representation gives rise to a cut. Therefore, cuts correspond to repunit representations up to a single additive term. Minimizing both sides yields the result.
% \end{proof}

We note that if $i \ll n$, then in fact $\delta_{B_k}(i) = \mathsf{elegance}(i)$. Therefore, $\mathsf{elegance}(i)$ actually characterizes the size of the minimum $(i, n - i)$ cut in any sufficiently large binary tree.

Consider a value-agnostic algorithm for complete binary trees. Such an algorithm would need to assign the house values in any instance in some fixed order $(v_1, \ldots, v_n)$ to the vertices of $B_k$. %Certainly, if we could find some ordering where for each $1 \leq i \leq n - 1$, we had $\delta_{B_k}(\{v_1, \ldots, v_i\}) = \mathsf{elegance}(i)$, then by Proposition \ref{prop:elegance} we would have an optimal allocation.
The following proposition shows that doing this cannot simultaneously achieve the optimal cut on all smallest subintervals, and this leads to a lower bound on the approximability.

\begin{restatable}{proposition}{binarylowerbound}\label{prop:traversalimpossible}
    There is no value-agnostic algorithm for complete binary trees that attains an approximation better than $(5/3) \approx 1.67$.
\end{restatable}
\begin{proof}
    Take a large enough binary tree $B_k$ with $n \gg 100$ vertices, and consider the numbers 89 and 94. Note that $\mathsf{elegance}(89) = 3$, as $89 = 127 - 31 - 7$, and $\mathsf{elegance}(94) = 2$, as $94 = 63 + 31$. Furthermore, these are unique minimum-length repunit representations. We claim that no layout $\sigma = (v_1, \ldots, v_n)$ would attain $\delta_{B_k}(\{v_1, \ldots, v_{89}\}) = 3$ and $\delta_{B_k}(\{v_1, \ldots, v_{94}\}) = 2$ simultaneously. Indeed, if a layout $\sigma$ satisfies the first condition, then the root of a subtree with $127$ must receive one of the lowest $89$ values. However, if $\sigma$ also satisfies the second condition, then the $94$ lowest values fill up exactly two complete binary subtrees of size $63$ and $31$, and so the root of any subtree of size $127$ could not have have any of these values. This is a contradiction, and therefore, any value-agnostic algorithm for this complete binary tree needs to choose at most one of these two options. However, now consider two instances, $(B_k, H_1)$ and $(B_k, H_2)$, where $H_1$ consists of $89$ values of $0$ and $n - 89$ values of $1$, whereas $H_2$ consists of $94$ values of $0$ and $n - 94$ values of $1$. The optimal envy on $(B_k, H_1)$ is $\mathsf{elegance}(89) = 3$, whereas the optimal envy on $(B_k, H_2)$ is $\mathsf{elegance}(94) = 2$. A value-agnostic algorithm will yield a sub-optimal result on at least one of these two instances. If it is wrong on $(B_k, H_1)$, it has to have at least $5$ edges spanning the only nontrivial smallest subinterval (since it needs an odd number crossing the cut $\delta_{B_k}(\{v_1, \ldots, v_{89}\})$, as any repunit representation of $89$ needs an odd number of terms, by parity) and it will be off by a factor of at least $5/3 \approx 1.67$ on this instance. If it is wrong on $(B_k, H_2)$, it has to have at least $4$ edges crossing the only nontrivial smallest subinterval (since it needs an even number crossing the cut $\delta_{B_k}(\{v_1, \ldots, v_{94}\})$, again by parity) and it will be off by a factor of at least $4/2 = 2$ on this instance. Therefore, the approximation ratio has to be at least $1.67$.
\end{proof}
% \begin{proof}[Proof Sketch]
%     In a sufficiently large complete binary tree, consider the smallest cut separating 89 vertices and the smallest cut separating 94 vertices. Using $\mathsf{elegance}(89) = 3$, as $89 = 127 - 31 - 7$, and $\mathsf{elegance}(94) = 2$, as $94 = 63 + 31$, we can argue that no layout $\sigma = (v_1, \ldots, v_n)$ attains $\delta_{B_k}(\{v_1, \ldots, v_{89}\}) = 3$ and $\delta_{B_k}(\{v_1, \ldots, v_{94}\}) = 2$ simultaneously, and so a value-agnostic algorithm will yield a sub-optimal result on at least one of these two instances.
% \end{proof}


%The proof of Proposition \ref{prop:traversalimpossible} also shows that we cannot attain an approximation ratio better than $3/2$ for any value-agnostic algorithm on complete binary trees. We can tweak our examples slightly to observe that the bounds for $\delta(177) = \delta(127 + 63 - 15 + 3 - 1) = 5$ and the conditions for $183 = 127 + 63 - 7$ cannot be satisfied simultaneously by any layout $\sigma$. this result also shows that there is no value-agnostic algorithm for $B_k$ that can achieve an approximation ratio better than $5/3$ \rik{Check this with Vignesh.} \vignesh{You can use the same example you have above.}.
%
%
%Proposition \ref{prop:traversalimpossible} and the nonexistence of the global median property (as discussed in Example \ref{ex:globalrefutation}) suggest that it may not be reasonable to be optimistic about an algorithm with \emph{any} constant approximation ratio, even for complete binary trees. 
The counterexample in Proposition \ref{prop:traversalimpossible} and the failure of the global median property (Example \ref{ex:globalrefutation}) may seem to suggest that, even for complete binary trees, \emph{any} constant approximation ratio is unattainable. 
%
Remarkably, the following result shows that this is not the case: there is a \emph{value-agnostic} algorithm attaining a constant approximation on any complete binary tree. Indeed, ordering the vertices of $B_k$ in the standard in-order traversal and allocating the (sorted) values in that order yields a $3.5$-approximation.

\begin{restatable}{theorem}{inorder}\label{thm:inorder}
    Let $B_k$ be the complete binary tree on $n = 2^{k+1} - 1$ vertices. Then, on any house allocation instance on $B_k$, assigning the houses in increasing order to the vertices of $B_k$ in the standard in-order traversal gives us a total envy at most $3.5$ times the optimal value.
\end{restatable}
\begin{proof}
    Suppose we allocate the houses in sorted order to the vertices of $B_k$ in the standard in-order traversal. For any $i \leq 2^k - 1$, consider the number of edges of $B_k$ spanning the subinterval $(h_i, h_{i+1})$ of the valuation interval. It can be shown that under the in-order traversal, the number of edges spanning this interval is exactly $\mathsf{runs}(i)$, the number of runs of contiguous $0$s or $1$s in the binary representation of $i$, by a simple argument\footnote{ For instance, the two quantities follow the same recurrence relation: $f(2^k + i) = f(2^k - i + 1) + 1$ for $k \geq 0$ and $0 < i \leq 2^k$, with the same base cases.}.
    
    Our main claim will be to show that for all $i$, $\mathsf{runs}(i) \leq 3\cdot\mathsf{elegance}(i) - 2$. Let $\mathsf{elegance}(i) = r$, and consider an optimal repunit representation $(a_1, \ldots, a_r)$ of $i$. WLOG suppose $|a_1| \geq \ldots \geq |a_r|$. Then $\mathsf{sgn}(a_1) = 1$. We will start with the binary representation $11\ldots 1$ of $2^{a_1} - 1$, which contains a single run of exactly $a_1$ $1$s. We will then add or subtract all the other terms $a_2, \ldots, a_r$, performing all our operations in binary. We will carefully keep track of how each of these operations can affect the number of runs.

    Consider an arbitrary binary integer, with $t$ runs, and consider adding a repunit to it. Adding such a repunit can be thought of as adding a single power of $2$ (which is a binary integer of the form $10\ldots 0$), and then subtracting a single $1$. When we add the power of $2$, starting from the right, the $0$s do not change the number of runs, until we get to the leading $1$. Observe that adding or subtracting a single $1$ can increase the number of runs by at most $1$. Therefore, at the leading $1$, we can add a new run by a mismatched bit between the $0$ and the $1$, and can also add a new run by adding the $1$ itself. Therefore, adding a power of $2$ can increase the number of runs by at most $2$. After that, subtracting the $1$ adds at most another run, as observed. Therefore, adding a repunit adds at most three runs to the original binary integer. By a symmetric argument, subtracting a repunit (which is equivalent to subtracting a power of $2$, and then adding a $1$) can also increase the number of runs by at most $3$.

    Since we started with $2^{a_1} - 1$, which contained a single run, and then added or subtracted $r - 1$ other repunits, the total number of runs in the final integer is at most $1 + 3(r - 1)$. This immediately implies that $\mathsf{runs}(i) \leq 3\cdot\mathsf{elegance}(i) - 2$.

    Coming back to $B_k$, we have just shown that for $i \leq 2^k - 1$, the number of edges in the in-order traversal spanning the subinterval $(h_i, h_{i+1})$ is at most $3\cdot\mathsf{elegance}(i) - 2$, which by Proposition \ref{prop:elegance} is at most $3\cdot\delta_{B_k}(i) + 1$. We now consider a couple of cases.

    We note that, for $i \leq 2^k - 1$, we have $\delta_{B_k}(i) = 1$ if and only if $i = 2^{k_1} - 1$ for some $k_1 \leq k$. This follows just by observing that every edge in a complete binary tree has a complete binary subtree on one side, and the other side cannot have size less than $2^k$. But in that case, $\mathsf{runs}(i) = \delta_{B_k}(i)$, and so on these subintervals, the in-order traversal only subtends a single edge (and is therefore optimal).

    On the other hand, for $i \leq 2^k - 1$, if $\delta_{B_k}(i) \geq 2$, then $1 \leq (\ffrac{1}{2})\cdot\delta_{B_k}(i)$.

    Therefore, the number of edges over any subinterval $(h_i, h_{i+1})$ in the range $i \leq 2^k - 1$ is at most $3\cdot\delta_{B_k}(i) + (\ffrac{1}{2})\cdot\delta_{B_k}(i) = 3.5\cdot\delta_{B_k}(i)$. By symmetry, this is true over all smallest subintervals of the valuation interval. Therefore, the number of edges passing over every smallest subinterval is at most $3.5$ times the minimum possible number of edges passing over that subinterval, and this yields the desired result.
\end{proof}
% \begin{proof}[Proof Sketch]
%     For any $i \leq 2^k - 1$, consider the number of edges of $B_k$ spanning the subinterval $(h_i, h_{i+1})$ of the valuation interval. It can be shown that under the in-order traversal, the number of edges spanning this interval is exactly $\mathsf{runs}(i)$, the number of runs of contiguous $0$s or $1$s in the binary representation of $i$. A careful argument shows that adding a single repunit to any binary number cannot increase the number of runs by more than $3$. It follows that for all $i$, $\mathsf{runs}(i) \leq 3\cdot\mathsf{elegance}(i) - 2 \leq 3\cdot\delta_{B_k}(i) + 1$, by Proposition \ref{prop:elegance}. Some straightforward casework now yields the result.
% \end{proof}

% In fact, the proof of Theorem \ref{thm:inorder} can be optimized a little bit to improve the approximation ratio slightly. We refer interested readers to Remark \ref{rem:optimizedinorderproof} in Appendix \ref{apdx:binary}.

\begin{remark}\label{rem:optimizedinorderproof}
    The proof of Theorem \ref{thm:inorder} can be optimized slightly for a more nuanced analysis. As observed in the proof, adding or subtracting repunits can be thought of as adding or subtracting powers of $2$, followed by subtracting or adding off $1$s. Consider performing all operations with the powers of $2$ first, and then finally adding or subtracting the number obtained by the $\pm 1$s. Each power-of-$2$ operation increases the number of runs by at most $2$, and the final additional number is at most $r - 1$, which has $1 + \lfloor\log(r - 1)\rfloor$ bits. Therefore, the total number of runs is actually $2 + 2(r - 1) + \lfloor\log(r - 1)\rfloor$. Note that this number is at most $(7/3)r$ for all $r \geq 18$, and in fact, the ratio of this number to $r$ gets arbitrarily close to $2$ as $r$ gets larger.
\end{remark}


It is instructive to check why this technique does not hold for arbitrary binary trees. Proposition \ref{prop:elegance} does not hold in general for non-complete binary trees. A complete binary tree ensures that there is always a binary subtree of the size given by a repunit representation to include on one side of the cut, but we lose this guarantee for non-complete trees.

We leave it as an open problem to construct either value-agnostic deterministic algorithms that achieve an approximation ratio better than $3.5$, or to obtain any polynomial-time algorithm (which cannot be value-agnostic) to obtain any approximation ratio better than $1.67$ for complete binary trees. We believe there should be an exact algorithm for this very special class of graphs, and hope that this will instigate future research into this problem.