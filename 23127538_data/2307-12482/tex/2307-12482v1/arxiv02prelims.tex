\section{Model and Preliminaries}\label{sec:prelims}

\subsection{Preliminaries from House Allocation}

We have a set of $n$ {\em agents} $V = [n]$ placed on the vertices of an undirected graph $G = (V, E)$. 
There are $n$ {\em houses}, each with a nonnegative \emph{value}, that need to be allocated to the agents. We represent the houses simply by the multiset of values $H = \{h_1, \ldots, h_n\}$, and assume without loss of generality that $h_1 \leq \ldots \leq h_n$. We will interchangeably talk about the house with value $h_i$ and the real number $h_i$. The pair $(G, H)$ defines an \emph{instance} of {\GHA}. %\hadi{we are sometimes referring to \textit{the} \GHA{} \textit{problem} and sometimes \GHA{} alone. we should be  consistent throughout the paper.}

An {\em allocation} $\pi: V \rightarrow H$ is a bijective mapping from agents (or nodes) to house values. Given an allocation $\pi$ and an edge $(i, j) \in E$, we define the {\em envy} along the edge $(i, j)$ as $|\pi(i) - \pi(j)|$. Our goal in {\GHA} is to compute an allocation $\pi^\ast$ that {\em minimizes} the total envy %\hadi{sometimes we say aggregate, let's be consistent} 
along all the edges of $G$:
\begin{align*}
    \Envy(\pi, G) := \sum_{(i, j) \in E} |\pi(i) - \pi(j)|.
\end{align*}

% The following definition, given by \cite{canon}, gives us a geometric way to visualize any allocation on an instance $(G, H)$ of {\GHA}.
We adopt the following definition from  \cite{canon} that provides a geometric representation to visualize any allocation on an instance $(G, H)$ of {\GHA}.

\begin{definition}[Valuation Interval]\label{def:valn_interval}
For an instance $(G, H)$ of {\GHA}, define the \emph{valuation interval} as the closed interval $\left[h_1, h_n\right] \subset \R_{\geq 0}$. For any allocation $\pi$, the envy along the edge $(i, j) \in E$ is exactly the length of the interval $[\pi(i), \pi(j)]$ (assuming $\pi(i) \leq \pi(j)$). We sometimes call the intervals $[h_i, h_{i+1}]$ for $1 \leq i \leq n - 1$ the \emph{smallest subintervals} of the valuation interval.
\end{definition}


 An optimal allocation $\pi^\ast$ would minimize the sum of the lengths of the intervals corresponding to each of its edges.
%
An allocation $\pi$ is \emph{$\alpha$-approximate} if $\Envy(\pi, G) \le \alpha\cdot\Envy(\pi^\ast, G)$. 




%In most cases of the {\GHA} problem, computing an optimal $\pi^\ast$ is intractable. Therefore, we focus on approximations. 
% An allocation $\pi$ is \emph{$\alpha$-approximate} if $\Envy(\pi, G) \le \alpha\cdot\Envy(\pi^\ast, G)$. 

Fix any arbitrary class $\cal G$ of graphs (we allow $\cal G$ to be a singleton class as well). We say an algorithm $\mathsf{ALG}_\mathcal{G}$ is \emph{defined} on $\cal G$ if $\mathsf{ALG}_\mathcal{G}$ is well-specified and outputs a valid allocation on every instance $(G, H)$ of {\GHA} with $G \in \mathcal{G}$. Such an algorithm $\mathsf{ALG}_\mathcal{G}$ is an \emph{$\alpha$-approximation} if for all instances $(G, H)$ of {\GHA} with $G \in \mathcal{G}$, $\mathsf{ALG}_{\mathcal{G}}$ always outputs an allocation that is $\alpha$-approximate. A $1$-approximation is an exact algorithm.

We are now ready to formulate the following definition.

\begin{definition}[Value-Agnostic Algorithms]
\label{defn:valueagnostic}
An algorithm $\mathsf{ALG}_\mathcal{G}$ defined on a graph class $\mathcal{G}$ is \emph{value-agnostic} if on every input $(G, H)$ with $G \in \mathcal{G}$, $\mathsf{ALG}_\mathcal{G}$ returns the same allocation on all instances where the \emph{ordering} of house values is the same (in other words, the algorithm only requires the ordinal ranking without requiring the numerical values).
If the graph class $\cal G$ admits a value-agnostic $\alpha$-approximation algorithm, we say $\cal G$ is \emph{$\alpha$-value-agnostic}. Otherwise, it is \emph{$\alpha$-value-sensitive}.
\end{definition}

How can we re-frame existing results on {\GHA} in the light of Definition \ref{defn:valueagnostic}? \cite{canon} show that, unless P = NP, there is no $1$-approximation algorithm $\mathsf{ALG}_\mathcal{G}$ when $\cal G$ is the set of vertex-disjoint unions of paths, cycles, or stars. In contrast, they show that value-agnostic \emph{exact} algorithms exist when $\cal G$ is the set of paths, cycles, or stars, and therefore these classes are all $1$-value-agnostic.
% ; see Figure \ref{fig:value_agnostic_ex}~(a).

Of course, value-agnostic $\alpha$-approximations are extremely powerful algorithms, as they can exploit the graph structure \emph{independent} of the values in the {\GHA} instance. As we would expect, value-agnostic $1$-approximations do not always exist, even on very simple singleton graph classes and even if we allow for exponential amount of time. For instance, consider the graph consisting of the disjoint union of $K_2$ and $K_3$. Figure \ref{fig:value_agnostic_ex} shows that this graph does not admit an $\alpha$-value-agnostic algorithm for any finite $\alpha$.
%\hadi{Conisder moving this example to right after Definition 2.1 when we introduce "valuation intervals". Then we can refer again to the same example when discussing value-agnostic approximations.}
%\rik{Will fix once figures are split and corrected.}

% Figure environment removed

Although all our examples so far use the disconnectedness of the graphs to illustrate value-sensitivity, we will see in Section \ref{sec:completebintrees} that there are value-sensitive connected graphs as well.




\subsection{Preliminaries from Structural Graph Theory}

We will use a few standard concepts from structural graph theory, most notably that of \emph{treewidth}. %Let us formally state the definition below.

\begin{definition}[Treewidth]\label{def:treewidth}
    For any graph $G = (V, E)$, a \emph{tree decomposition} $\mathfrak{T} = (T; \{X_i\}_{i = 1}^t)$ of $G$ is a tree $T$ whose nodes are subsets $X_1, \ldots, X_t \subseteq V$, satisfying the following three properties:
    \begin{enumerate}
        \item $\bigcup_{i = 1}^t X_i = V$;
        \item If $v \in V$ is in $X_i$ and $X_j$, then $v$ is in every $X_k$ in the unique path in $T$ between $X_i$ and $X_j$;
        \item For every edge $(u, v) \in E$, there is some $X_i$ containing both $u$ and $v$.
    \end{enumerate}
    The \emph{width} of the tree decomposition $\mathfrak{T}$ is
    % \begin{equation*}
    $
        \mathsf{width}(\mathfrak{T}) := \max_{i}\left ( |X_i| - 1\right ).
    $
    % \end{equation*}
    The \emph{treewidth} of a graph $G$ is defined as $\tw(G) := \min_{\mathfrak{T}}\mathsf{width}(\mathfrak{T})$.
    % \begin{equation*}
    %     \tw(G) := \min_{\mathfrak{T}}\mathsf{width}(\mathfrak{T}).
    % \end{equation*}
\end{definition}

Note that a connected graph $G$ with two or more vertices satisfies $\tw(G) = 1$ if and only if $G$ is a tree. Graphs with treewidth at most $2$ are exactly the series-parallel graphs, and graphs with treewidth $n - 1$ are exactly the complete graphs.

In Definition \ref{def:treewidth}, if we constrain the tree $T$ to be a path, then the resulting notion of width is called the \emph{pathwidth} of $G$, denoted $\pw(G)$. A tree with two or more vertices satisfies $\pw(G) = 1$ if and only if $G$ is a caterpillar graph.
Treewidth and pathwidth are deep and fundamental parameters for graphs, used widely in structural graph theory. Many problems on graphs become provably easier when a (near-optimal) tree decomposition or path decomposition is part of the input. Note that the two parameters are related, as
\begin{equation*}
    \tw(G) \leq \pw(G) \leq O(\tw(G)\cdot\log n),
\end{equation*}
for any $n$-vertex graph $G$.

In Section \ref{sec:cutwidth}, we will visit another parameter, called the $\cw$, that is related to both of these parameters, and can be directly applied to {\GHA} for finding good approximations.

%\hadi{Should we move cutwidth also to this section? Especially because we mention it immediately in the next section?}

For any graph $G = (V, E)$, and any subset $S \subseteq V$, we denote by $\delta_G(S)$ the set of edges going across the cut $(S, V - S)$ in $G$. A number of our bounds will rely on estimating $|\delta_G(S)|$ for various subsets $S$. For $1 \leq k \leq n-1$, we also define $\delta_G(k) := \min_{|S| = n}|\delta_G(S)|$ as the size of the smallest cut in $G$ with $k$ vertices on one side. Of course, $\delta(k) = \delta(n - k)$ for all $k$.