\clearpage
\setcounter{page}{1}
\setcounter{figure}{0} 
\renewcommand\thefigure{R.\arabic{figure}}
\setcounter{table}{0}
\renewcommand\thetable{R.\arabic{table}}
\setcounter{equation}{0}
\section*{author response} \label{sec:response}
%We thank the reviewers for the insightful and constructive comments. Following the suggestions, we revise our paper and the major changes are highlighted in {\hz blue}. Our responses to the major concerns of reviewers are as follows. 
We thank the reviewers for their insightful and constructive comments. Based on the reviewers' suggestions, the major changes we made in the revised paper are summarized into three aspects: 
\begin{itemize}
\vspace{-1mm}
\item {\bf Further Clarifications on the Problem's Applications and Our Motivations: } (for Meta-Reviewer, Reviewer \#4 and\#5)  

We illustrate the importance of estimating a single node's PageRank computation from both the theoretical and practical aspects. And we further clarify our motivations to study the problem of single-node PageRank computation on undirected graphs. Details can be found in our response to Meta-Reviewer, Reviewer \#4 and Reviewer \#5, or in Section~\ref{sec:intro} of the revised paper. 
    
\item {\bf Superiority Illustrations: } (for Reviewer \#5)  

We present a comprehensive analysis on the superiority of our \setpush over existing methods. We also explain the reasons why existing methods cannot achieve the complexity bound of \setpush. Details can be found in our response to Reviewer \#4, or in Section~\ref{sec:algorithm} of the revised paper. 

    
\item {\bf Supplementary Experiments: } (for Reviewers \#2, \#4 and \#5) 

We included more experiments as advised by Reviewers \#2, \#4 and \#5. These supplementary experiments further demonstrate the effectiveness and efficiency of our \setpush. 
    

\end{itemize}

In the revised paper, the major changes were highlighted in {\rev blue}. Our responses to the major concerns of reviewers were as follows. For readability, we also presented the supplementary tables and figures in the response letter, with captions beginning with R.1. 


\subsection*{Meta-Reviewer} \label{sec:meta}
\review{\bf D1}: {\em Your results are applicable to undirected graphs. Since most of the competitors in previous research addresses directed graphs, please clarify which of the complexities (query times) in Table 1 refer only to undirected graphs and what is the best result applicable to undirected graphs. Please also comment on whether the proposed approach extends to directed graphs.} 

\header{\bf Response: } Thanks for pointing out this issue. In Table~\ref{tbl:comparison} (or Table~\ref{tbl:comparison_rev} given below for readability), the complexities of LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected}, and our \setpush are only applicable to undirected graphs. In comparison, the complexities of the Power Method~\cite{page1999pagerank}, Monte-Carlo~\cite{fogaras2005MC}, RBS~\cite{wang2020RBS}, and  \sublinear~\cite{bressan2018sublinear} hold both on directed and undirected graphs. We revised Table~\ref{tbl:comparison} by marking the complexity with a $\star$ if it is only applicable on undirected graphs. 

To our knowledge, before our \setpush, 
the best complexity results for the single-node PageRank computation on undirected graphs are achieved by FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected} and \sublinear~\cite{bressan2018sublinear}.  %(which one is the best depends on the specific values of $d_t$, $\davg$ and $\dmax$). 
%the best complexity result for deriving a $(c,p_f)$-approximation of a single node's PageRank (e.g., $\vpi(t)$) is $\tilde{O}\left(\sqrt{n\cdot d_t}\right)$ (achieved by FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected}) or $\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{2/3}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$
As shown in Table~\ref{tbl:comparison}, our \setpush significantly outperforms the three methods in terms of query time complexity unless on a complete graph (i.e., the average degree $\davg=n$). Even on a complete graph, the time complexity of \setpush is still no worse than those of FastPPR, BiPPR and \sublinear. Notably, complete graphs are severely rare in real-world applications. Most real-world networks are actually scale-free networks, which include a large number of small-degree nodes and $\davg \ll n$. On a scale-free network, the complexity of our \setpush is asymptotically better than those of existing methods on undirected graphs. We present a comprehensive analysis on the theoretical improvements of our \setpush over existing methods. Please refer to our response to the W1 point of Reviewer \#4 for details. 
%present a detailed comparison between our \setpush and every existing method. Please
%Actually, it was empirically observed that most real-world networks are scale-free networks, in which most of graph nodes are small-degree nodes. 


\begin{table*} [t]
%\vspace{-4mm}
\centering
\renewcommand{\arraystretch}{1.4}
%\begin{small}
\tblcapup
\caption{Comparison of algorithms for deriving a $\boldsymbol{(c, p_f)}$-approximation of an {\em \underline{arbitrary}} target node $\boldsymbol{t}$'s PageRank on undirected graphs. The complexity results marked with $\star$ are only applicable on undirected graphs. 
%In the last column, we list the ratio of our \setpush's query time complexity to every baseline's time complexity. The smaller the ratio is, the larger improvement \setpush performs over the baseline method. 
}\label{tbl:comparison_rev}
\vspace{-3mm}
%\resizebox{0.9\linewidth}{!}{%
%\resizebox{1\linewidth}{!}{
%\tblcapdown
%p{2.3in}
\begin{tabular} 
%{|l|p{2.3in}|} \hline
{|P{3.5cm}|c@{\hspace{+1mm}}|@{\hspace{+1mm}}c@{\hspace{+1mm}}|@{\hspace{+1mm}}P{6.3cm}|} \hline
{\bf Query Time Complexity} & \multirow{3}*{\bf Baseline Methods} &  {\bf Query Time Complexities} & \multirow{2}*{\bf {Improvement of \setpush over Baselines}} \\ 
{\bf of Our \setpush} & & {\bf of Baseline Methods} & \multirow{2}*{(the larger, the better)} \\ 
{(arbitrary target node $t$)} & & {(arbitrary target node $t$)} &  \\ \hline
%~& & & (the time) \\ \hline
\multirow{7}*{$\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right) \star$} & The Power Method~\cite{page1999pagerank} & $\tilde{O}(m)$ & $\max \left\{ m / d_t, \sqrt{m} \right\}$  \\  \cline{2-4}
& Monte-Carlo~\cite{fogaras2005MC} & $\tilde{O}(n)$ & $\max \left\{n/d_t,  \sqrt{n/\davg} \right\}$ \\ \cline{2-4}
%LocalPush~\cite{andersen2007contribution} & $\tilde{O}\left(n\cdot d_t\right)$ \\ \hline
& LocalPush~\cite{lofgren2013personalized} & $\tilde{O}\left(\min\left\{n\cdot d_t, m\right\}\right) \star$ & $\sqrt{m}$ \\ \cline{2-4}
&  RBS~\cite{wang2020RBS} & $\tilde{O}\left(n\right)$ & $\max \left\{n / d_t, \sqrt{n/\davg} \right\}$ \\ \cline{2-4}
& FastPPR~\cite{lofgren2014FastPPR} &  $\tilde{O}\left(\sqrt{n\cdot d_t}\right) \star$ & $\max \left\{\sqrt{n / d_t}, \sqrt{d_t / d}\right\}$ \\ \cline{2-4}
& BiPPR~\cite{lofgren2016BiPPR,lofgren2015BiPPRundirected} & $\tilde{O}\left(\sqrt{n\cdot d_t}\right) \star$ & $\max \left\{\sqrt{n / d_t}, \sqrt{d_t / d}\right\}$ \\ \cline{2-4}
%\rule{0pt}{14pt} Bressan-PageRank~\cite{bressan2018sublinear} & {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\Delta^{1/3}}{d^{1/2}}, \frac{m^{4/5}}{d^{3/5}} \right\}\right)$}\\[1ex] \hline
& \sublinear~\cite{bressan2018sublinear} & {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{2/3}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$} 
& $\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot d^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\right\}\right\}$\\ \hline
%\rule{0pt}{14pt}$\mymathhl{\text{\setpush(Ours)}}$ & $\mymathhl{\tilde{O}(\min\left\{d_t, \sqrt{m}\right\})}$ \\[1ex] \hline
%& \setpush(Ours) & $\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right)$ & \\ \hline
\end{tabular}
%}
\vspace{-1mm}
%\end{small}
\end{table*}

\begin{table*} [t]
%\vspace{-4mm}
\centering
\renewcommand{\arraystretch}{1.4}
%\begin{small}
\tblcapup
\caption{Comparison of algorithms for deriving a $\boldsymbol{(c, p_f)}$-approximation of a {\em \underline{uniform}} target node $\boldsymbol{t}$'s PageRank on undirected graphs. The complexity results marked with $\star$ are only applicable on undirected graphs. 
%In the last column, we list the ratio of our \setpush's query time complexity to every baseline's time complexity. The smaller the ratio is, the larger improvement \setpush performs over the baseline method. 
}\label{tbl:comparison_uniform_rev}
\vspace{-3mm}
%\resizebox{0.9\linewidth}{!}{%
%\resizebox{1\linewidth}{!}{
%\tblcapdown
%p{2.3in}
\begin{tabular} 
%{|l|p{2.3in}|} \hline
{|P{3.5cm}|c@{\hspace{+1mm}}|@{\hspace{+1mm}}c@{\hspace{+1mm}}|P{2.5cm}|@{\hspace{+1mm}}P{3.5cm}|} \hline
{\bf Query Time Complexity} & \multirow{3}*{\bf Baseline Methods} &  {\bf Query Time Complexities} & \multicolumn{2}{c|}{\bf {Improvement of \setpush over baselines}}   \\ 
{\bf of Our \setpush} & & {\bf of Baseline Methods} & \multicolumn{2}{c|}{(the larger, the better)}   \\ \cline{4-5}
{(uniform target node $t$)} & & {(uniform target node $t$)} & on arbitrary graphs & on power-law graphs\\ \hline
%~& & & (the time) \\ \hline
\multirow{7}*{$\tilde{O}\left(\davg\right) \star$} & The Power Method~\cite{page1999pagerank} & $\tilde{O}(m)$ & $n$ & $n$ \\  \cline{2-5}
& Monte-Carlo~\cite{fogaras2005MC} & $\tilde{O}(n)$ & $n/\davg$ & $n/\log{n}$ \\ \cline{2-5}
%LocalPush~\cite{andersen2007contribution} & $\tilde{O}\left(n\cdot d_t\right)$ \\ \hline
& LocalPush~\cite{lofgren2013personalized} & $O\left(n \davg\right)$ & $n$ & $n$ \\ \cline{2-5}
&  RBS~\cite{wang2020RBS} & $\tilde{O}\left(n\right)$ & $n /\davg$ & $n /{\log{n}}$ \\ \cline{2-5}
& FastPPR~\cite{lofgren2014FastPPR} &  $\tilde{O}\left(\sqrt{n \davg}\right)$ & $\sqrt{n / \davg}$ & $\sqrt{n / \log{n}}$ \\ \cline{2-5}
& BiPPR~\cite{lofgren2016BiPPR,lofgren2015BiPPRundirected} & $\tilde{O}\left(\sqrt{n \davg}\right)$ & $\sqrt{n / \davg}$ & $\sqrt{n / \log{n}}$ \\ \cline{2-5}
%\rule{0pt}{14pt} Bressan-PageRank~\cite{bressan2018sublinear} & {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\Delta^{1/3}}{d^{1/2}}, \frac{m^{4/5}}{d^{3/5}} \right\}\right)$}\\[1ex] \hline
& \sublinear~\cite{bressan2018sublinear} & {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{2/3}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$} & $\min\left\{\frac{n^{2/3}\cdot d_{\max}^{1/3}}{d}, \frac{n^{4/5}}{d^{4/5}}\right\}$ & $\min\left\{\frac{n^{2/3}\cdot d_{\max}^{1/3}}{\log{n}}, \frac{n^{4/5}}{{\left(\log{n}\right)}^{4/5}}\right\}$ \\ \hline
%\rule{0pt}{14pt}$\mymathhl{\text{\setpush(Ours)}}$ & $\mymathhl{\tilde{O}(\min\left\{d_t, \sqrt{m}\right\})}$ \\[1ex] \hline
%& \setpush(Ours) & $\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right)$ & \\ \hline
\end{tabular}
%}
\vspace{-3mm}
%\end{small}
\end{table*}


%single-node PageRank on undirected graphs are achieved by FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected} and \sublinear~\cite{bressan2018sublinear} (which one is the best depends on the specific values of $d_t$, $\davg$ and $\dmax$). 

In the following, we would present a further clarification on our motivations to study the problem of single-node PageRank computation on undirected graphs. 

\begin{itemize}
\item First, estimating a single node's PageRank is a fundamental problem, which has been a primitive of both theoretical and practical interest over a decade. Please refer to our response to the W1 point raised by Reviewer \#5 for detailed illustrations. 

\item Second, studying the problem of single-node PageRank computation specifically on undirected graphs is well-motivated because of two-fold reasons. 
\begin{itemize}
    \item From the theoretical aspect, there are several crucial properties only held by the PageRank values on undirected graphs (e.g., Equation~\eqref{eqn:birectional_ppr} given in Section~\ref{sec:pre}). By carefully utilizing these properties, we propose the \setpush algorithm, which successfully achieves the $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$ time complexity for deriving a $(c, p_f)$-approximation of an arbitrary node $t$'s PageRank on {\em undirected graphs}. Such complexity result is encouraging, which implies the number of nodes we are required to visit for the approximation of $\vpi(t)$ is no more than the neighborhood size of $t$. 
    In comparison, the lower bound for the time complexity of deriving a $(c, p_f)$-approximation of $\vpi(t)$ on {\em directed graphs} is $\tilde{O}\left(\min\left\{ \sqrt{n \dmax}, n^{2/3} \davg^{1/3}\right\} \right)$~\cite{bressan2018sublinear}, where $\davg$ and $\dmax$ denote the average and maximum node degree, respectively. Note that 
    \begin{align*}
    \min \left\{d_t, \sqrt{m}\right\} \le \sqrt{m}=\sqrt{n\davg} \le \min\left\{ \sqrt{n \dmax}, n^{2/3} \davg^{1/3}\right\},
    \end{align*}
    which means the scalable complexity result $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$ of our \setpush can only be achieved by utilizing the unique theoretical properties of PageRank on undirected graphs. However, existing methods do not pay enough attention to these critical properties, leading to sub-optimal complexity results for single-node PageRank computation on undirected graphs. This offers us motivations to study the problem from the theoretical aspect.  
    
    \item From the practical aspect, designing scalable algorithms specifically for undirected graphs is of wide interest in database community. For example, Chen et al.~\cite{chen2022spanning} design a novel data structure on dynamic undirected graphs to scale existing spanning tree algorithms to the graphs with millions of vertices. Qiao et al.~\cite{qiao2013top} propose two efficient algorithms for top-$k$ nearest keywork search on undirected graphs. Moreover, Meahara et al.~\cite{maehara2014computing} make use of the properties of Personalized PageRank (PPR) on undirected to accelerate the convergence rate of the Power method. Analogously, Lofgren~\cite{lofgren2015BiPPRundirected} extends average-case approximation error guarantee of single-pair PPR approximation to worst-case guarantees by exploiting the properties of PPR on undirected graphs. 
    On the other hand, it is of particular interest to compute single-node PageRank on undirected graphs since multiple downstream tasks are only defined on undirected graphs. %All input directed graphs are required to be converted to undirected graphs. 
    For example, in the scenario of local clustering, the celebrated local clustering method~\cite{FOCS06_FS} employs the (Personalized) PageRank vector to find local clusters. Because the well-adopted {\em conductance} metric to measure the the quality of identified clusters is defined on undirected graphs, all we need in local clustering tasks is the PageRank vector computed on undirected graphs. %most of (if not all) local clustering algorithms are only for undirected graphs. Among them,  
    Additionally, Graph Neural Networks (GNNs) have drawn increasing attention in recent years. A plethora of GNN models leverage PageRank computation to propagate node features~\cite{klicpera2019APPNP, Bojchevski2020PPRGo,Chen2020GCNII}. Because the graph Laplacian matrix for feature propagation is only applicable to undirected graphs, this line of research invokes PageRank computation algorithms only on undirected graphs. 

    
\end{itemize}


\item Finally, we would also make some comments on the hardness of efficiently estimating single-node PageRank on directed graphs. Specially, we provide a toy example in Figure~\ref{fig:example_undirected} to see the hardness intuitively. 
Consider node $u_1$ in the left undirected graph, where the degree $d_{u_1}=\Theta(n)$. The transition probability from node $u_1$ to $t$ is $\Theta\left(\frac{1}{n}\right)$, and thus $\vpi_{u_1}(t)$ becomes $O\left(\frac{1}{n}\right)$. Therefore, if we conduct a backward push operation from node $t$, the probability mass reversely transferred from $t$ to $u$ is tiny. And the reverse propagation method can just stop after the first backward push operation as every $\vpi_u(t)$ for $\forall u\in N(t)$ turns out to be small. In comparison, consider the backward push operation from node $t$ in the right-side directed graph of Figure~\ref{fig:example_undirected}. The probability mass transferred from $t$ to every $u \in N_{in}(t)$ is significant since $d_{out}(u)=1$. Here $N_{in}(t)$ denotes the in-neighbor set of node $t$, and $d_{out}(u)$ denotes the out-degree of node $u$. As a result, the value of every $\vpi_u(t)$ is still large enough to conduct a new backward push operation from $u$. We note that $d_{in}(u)=\Theta(n)$ for every $u\in N_{in}(t)$, where $d_{in}(u)$ denotes the in-degree of node $u$. As a consequence, the time cost spent in the right directed graph is $\Theta(n^2)$, while we only require $\Theta(n)$ to estimate $\vpi(t)$ in the left undirected graph. %We leave open the question of whether the complexity of PageRank computation on directed graphs can be improved. 
Such toy example %given in Figure~\ref{fig:example_undirected} 
illustrates the hardness of estimating single-node PageRank on directed graphs. In the meanwhile, this toy example also reflects that %the importance of the properties 
there indeed exist several important properties of PageRank on undirected graphs. At a high level, recall that the following equation (i.e., Equation~\eqref{eqn:birectional_ppr}) holds for all nodes $u$ and $t$ in an undirected graph: 
\begin{align*}
\vspace{-2mm}
\vpi_u(t) \cdot d_u = \vpi_t(u) \cdot d_t. 
\end{align*}
%However, most of (if not all) existing methods fail to make fully use of this property, and incur large query time complexity both on directed and undirected graphs. 
%In this paper, we design the \setpush algorithm based on the above equation, and successfully achieve a better complexity result for single-node PageRank computation on undirected graphs. Specifically, we note that 
This equation actually implies the value of $\vpi_u(t)$ would not be extremely large if $d_u$ is large. We argue that this property is pretty crucial and should be highly valued when developing algorithms on undirected graphs. However, existing methods do not pay enough attention to this point, which leads to suboptimal complexity results and motivates us to contribute some improvements on this problem.  


\end{itemize}


\begin{comment}
%However, the three methods are originally proposed on directed graphs. This reflects existing methods do not make full use of the properties that PageRank scores hold on undirected graphs. This also offers us motivations to focus on the single-node PageRank computation problem on undirected graphs.  

Based on this advice, we further revised our paper in three points as shown below. %Furthermore, in the revised paper, we made the following changes . 

\begin{itemize}
    \item In the Abstract, we highlighted our motivations that we aim to efficiently compute single-node PageRank on undirected graphs. We also emphasized that our \setpush is proposed to efficiently estimate single-node PageRank specifically on undirected graphs. Please refer to the Abstract for details. 

    \item In the Introduction, we added a paragraph entitled ``Single-Node PageRank Computation on Undirected Graphs". In this paragraph, we illustrated the significance and necessity to estimate a single node's PageRank on undirected graphs from both theoretical and practical aspects. Please refer to Section~\ref{sec:intro} for details. 

    \item At the end of the Introduction, we summarized our major contributions into three points. In particular, in the first point, we provided Table~\ref{tbl:comparison} to show the theoretical improvements of our \setpush over existing methods for the single-node PageRank computation on undirected graphs. Moreover, in the third point of our contributions, we presented the high-level idea on how to utilize the theoretical properties of PageRank scores on undirected graphs in the development of our \setpush. 
\end{itemize}
\end{comment}

% Figure environment removed


%Based on the above observations, in this paper, we focus on the problem of single-node PageRank computation on undirected graphs, and achieve a better complexity result than the existing best result on undirected graphs. 

%Note that our \setpush is developed specifically on undirected graphs. And we leave open the problem of whether the complexity bounds for estimating single-node PageRank on directed graphs can be further improved. 

%We leave open the problem of whether our \setpush can be expected
%Although our \setpush is proposed specifically on undirected graphs, we provide some comments here on the problem of single-node PageRank computation on directed graphs. 
%On the other hand, improving the complexity of single-node PageRank computation on directed graphs is another non-trivial problem. 
%Such equality implicitly bounds the value of $\vpi_u(t)$ for those high-degree nodes $u$. In other words, given a target node $t$, the value of $\vpi_u(t)$ is relatively small if $d_u$ is large. 
%differences between single-node PageRank computations on undirected and directed graphs. 
%provides a toy example to illustrate the differences between single-node PageRank computations on undirected and directed graphs. 
%To see the hardness of the problem intuitively, 

%bounds the value of $\vpi_u(t)$ for those high-degree nodes $u$. In other words, given a target node $t$, the value of $\vpi_u(t)$ is relatively small if $d_u$ is large. 

%can be computed by $\vpi(t)=\frac{1}{n}\sum_{u\in V}\vpi_u(t)=\frac{1}{n}\sum_{u\in V}\frac{d_t}{d_u}\vpi_t(u)$. Thus, we no longer need to simulate $\alpha$-random walks from a uniformly selected source node $s$ for estimating the value of $\vpi_u(t)$ for every $u\in V$. Instead, we can propagate probability mass from node $t$ forward to its neighbors. As a result, we are able to break the lower bound $O\left(\frac{1}{\vpi(t)}\right)$ of the Monte-Carlo method, and achieve a better complexity compared to the Monte-Carlo method and all hybrid methods including a Monte-Carlo phase on undirected graphs. 



%In summary, existing methods for single-node PageRank computation mainly focus on directed graphs, while incur large time complexity due to the hardness of the problem. On the other hand, estimating single-node PageRank on undirected graphs is still of great importance from both practical and theoretical aspects. The PageRank scores on undirected graphs also have several unique properties, which are not fully utilized by existing methods. Motivated by the above issues, we 

\begin{comment}


revised the abstract and introduction of this paper to highlight this point. 
%in our contributions presented in the Introduction of the revised paper. 

Note that the three methods, LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR}, are originally proposed on directed graphs. However, they cannot offer the worst-case guarantee on directed graphs without considering a uniform random choice of the target node. For an arbitrary target node, meaningful complexity bounds of the three methods can only be derived on undirected graphs (as listed in Table~\ref{tbl:comparison}). On the other hand, 

to our knowledge, the best complexity results achieved by existing methods on undirected graphs turn out to be the complexities of FastPPR, BiPPR and \sublinear, which one is the best determined by the specific values of $d, d_{\max}$ and $d_t$. However, the three methods are originally proposed on directed graphs, which reflects that existing methods do not make fully use of the properties of PageRank on undirected graphs. 
The two points mentioned above motivate us to study the problem of single-node PageRank computation on undirected graphs. To be more specific, we think the necessity to study the single-node PageRank computation problem on undirected graphs mainly come from two aspects. %Specifically, our motivations mainly come from two aspects: %The necessity is two-fold: 


First, from the theoretical aspect, some important properties of PageRank (or Personalized PageRank (PPR)) only hold on undirected graphs. For example, as shown in Equation~\eqref{eqn:birectional_ppr}, the following equation holds for all nodes $u$ and $t$ in an undirected graph $G$: 
\begin{align*}
\vpi_u(t) \cdot d_u = \vpi_t(u) \cdot d_t. 
\end{align*}
However, most of (if not all) existing methods fail to make fully use of this property, and incur large query time complexity both on directed and undirected graphs. 
In this paper, we design the \setpush algorithm based on the above equation, and successfully achieve a better complexity result for single-node PageRank computation on undirected graphs. Specifically, we note that the above equation implicitly implies $\vpi(t)$ can be computed by $\vpi(t)=\frac{1}{n}\sum_{u\in V}\vpi_u(t)=\frac{1}{n}\sum_{u\in V}\frac{d_t}{d_u}\vpi_t(u)$. Thus, we no longer need to simulate $\alpha$-random walks from a uniformly selected source node $s$ for estimating the value of $\vpi_u(t)$ for every $u\in V$. Instead, we can propagate probability mass from node $t$ forward to its neighbors. As a result, we are able to break the lower bound $O\left(\frac{1}{\vpi(t)}\right)$ of the Monte-Carlo method, and achieve a better complexity compared to the Monte-Carlo method and all hybrid methods including a Monte-Carlo phase on undirected graphs. 





Second, from the practical aspect, the problem of single-node PageRank computation on undirected graphs is of great importance. Many downstream graph mining and learning tasks are only defined on undirected graphs. All input directed graphs are required to be converted to undirected graphs. For example, in the scenario of local clustering, the well-adopted {\em conductance} metric to measure the quality of identified clusters is defined on undirected graphs. Thus, %most of (if not all) local clustering algorithms are only for undirected graphs. Among them, 
a celebrated local clustering method~\cite{FOCS06_FS} employ the Personalized PageRank vector computed on undirected graphs to find local clusters. Moreover, Graph Neural Networks (GNNs) have drawn increasing attention in recent years. A plethora of GNN models leverage PageRank computation to propagate node features~\cite{klicpera2019APPNP, Bojchevski2020PPRGo,Chen2020GCNII}. Because the graph Laplacian matrix for feature propagation is only applicable to undirected graphs, this line of research invokes PageRank computation algorithms only on undirected graphs. 





% On the other hand, a number of existing algorithms do not offer any worst-case guarantee on directed graphs without considering a uniform random choice of the target node. For example, the canonical reverse exploration algorithm, LocalPush~\cite{lofgren2013personalized}, requires $O\left(n\cdot \left(\sum_{v\in V} \vpi_{v}(t)\cdot d_v\right)\right)$ time cost for estimating an arbitrary target node $t$'s PageRank on directed graphs. Such complexity can be rewritten as a meaning bound $O(n\cdot d_t)$ only on undirected graphs, by applying the property of PPR on undirected graphs: $\vpi_v(t) \cdot d_v = \vpi_t(v) \cdot d_t$. The same problem also holds in the hybrid methods, FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR}, which include a reverse propagation phase in the algorithm. 
%As a consequence, although these methods are originally proposed for single-node PageRank computation on directed graphs, their complexity bounds are only applicable to undirected graphs with an arbitrary target node. 
\end{comment}




\subsection*{Reviewer \#2} \label{sec:r2}
\review{\bf W1}: {\em Table 2 is not centered like Table 1, which I think is better centered. } 

\header{\bf Response: } Thanks for the suggestion. We centered the contents in Table 2 as advised. 


\review{\bf W2}: {\em Add description of hyperparametersâ€™ setting. } 

\header{\bf Response: } Thanks for the advice. We list the parameter settings of our \setpush and all competitors in the Experiments part. Please refer to Section~\ref{sec:exp} for details. 


\review{\bf W3}: {\em Add experiments for parameter sensitivity of the algorithm on datasets. } 

\header{\bf Response: } Thanks for the advice. Our \setpush has two parameters: the relative error $c$ and the failure probability $p_f$. 
%We assume $c$ and $p_f$ are both constants for the simplicity of presentation following~\cite{bressan2018sublinear, wang2020RBS}. 
From Figure~\ref{fig:query_uniform_0.1} to Figure~\ref{fig:query_degree_0.5}, we show the experimental results of our \setpush with different settings of $c$ (i.e., $c=0.1$, and $c=0.5$). In Figure~\ref{fig:pf}, we add the experiments to empirically evaluate the performances of \setpush under different values of $p_f$. Specifically, we vary $p_f$ in $\{1/3, 1/5, 1/20, 1/100\}$ and plot the query time of \setpush under every $p_f$ on the YT, IC, OL, and FR datasets. From Figure~\ref{fig:pf}, we observe that the query time of \setpush does not change significantly. This concurs with our analysis that the time complexity of \setpush only has a log dependence on $p_f$ by adopting the Median-of-Mean trick~\cite{charikar2002mediantrick}. We also add more experiments to evaluate the effectiveness of \setpush on different choice of the target node $t$. Please refer to our response to D4.1 of Reviewer \#4 for details. 

%We omit $ploy(c^{-1})$ and $polylog(p_f^{-1})$ factors for readablity. 

% Figure environment removed





\subsection*{Reviewer \#4} \label{sec:r4}

\review{\bf W1}: {\em The contribution of this work seems not obviously. There exist several algorithms to solve the single node PageRank problem. It is necessary to show the significant improvement and advantages of the proposed algorithms against existing methods in this paper. } 

\header{\bf Response: } Thanks for pointing out this issue. In Table~\ref{tbl:comparison} (or Table~\ref{tbl:comparison_rev} given in the response letter for readability), we list the theoretical improvements of our \setpush over existing methods on undirected graphs. We note that the expected time complexity of our \setpush is asymptotically better than those of existing methods except on complete graphs (i.e., the $\davg=n$). Even on complete graphs, the complexity result of \setpush is still no worse than those of existing methods. 
%We made the following modifications in the revised paper to highlight our contributions. 
%We revised the Introduction and summarized our contribution into three points
%re-summarized our contributions in the Introduction to highlight the major points. For reference, we present a brief summary (with some additional illustrations) on our core contributions in the following. %Please refer to Section~\ref{subsec:contribution} for details. 
%A more comprehensive version can be found in Section~\ref{subsec:contribution}. 
%First, we re-summarized our contributions in the Introduction into three points. 
%First of all, in the Introduction of the revised paper (see Section~\ref{subsec:contribution}), we explicitly listed the theoretical improvements of our \setpush over existing methods on undirected graphs. Specifically, as shown in Table~\ref{tbl:comparison}, the expected time complexity of our \setpush is no worse than that of any existing method on undirected graphs. 
In particular, 
%as given in the last column of Table~\ref{tbl:comparison}, 
our \setpush improves FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected} by a factor of $\varphi=\max \left\{\sqrt{n/{d_t}}, \sqrt{d_t / \davg }\right\}$, and improves the \sublinear method~\cite{bressan2018sublinear} by 
\begin{align*}
\varphi=\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot d^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\right\}\right\}, 
\end{align*}
where $\davg$ and $\dmax$ denote the average and maximum node degree of the graph, respectively. Note that FastPPR, BiPPR and \sublinear achieve the best complexity results among existing methods for deriving a $(c, p_f)$-approximation of $\vpi(t)$ on undirected graphs (which one is the best depends on the specific values of $d_t$, $\davg$ and $\dmax$). Unless on a complete graph where $\davg=n$, the improvement factor $\varphi$ of \setpush over FastPPR, BiPPR, and \sublinear are all strictly larger than $1$, which means the expected time complexity of \setpush is asymptotically better than that of any existing method. %Furthermore, as illustrated in our response to the D2 point given below, 
Even on a complete graph, in which case $\varphi=1$, the complexity of \setpush is no worse than those of FastPPR, BiPPR, and \sublinear, and still better than those of LocalPush, Monte-Carlo, and the Power method. 


%For the simplicity of comparison, we provide Table~\ref{tbl:comparison_uniform_rev} to show the superiority of \setpush for a uniform choice of the target node $t$. 
To see the superiority of \setpush clearly, we provide Table~\ref{tbl:comparison_uniform_rev} to show the theoretical improvements of \setpush over existing methods for a uniform choice of the target node $t$. We observe that \setpush improves over the Power method and the LocalPush method by a factor of $n$. Moreover, \setpush improves over the Monte-Carlo method and the RBS method by an $\frac{n}{\davg}$ factor, where $\davg$ denotes the average node degree of the graph $G$. Furthermore, for the three state-of-the-art methods FastPPR, BiPPR, \sublinear, \setpush outperforms FastPPR and BiPPR by a factor of $\frac{n}{\davg}$, and outperforms \sublinear by a factor of $\min\left\{\frac{n^{2/3}\cdot d_{\max}^{1/3}}{d}, \frac{n^{4/5}}{d^{4/5}}\right\}$. %We note that except on a compete graph, the average 
More specifically, we have the following observations: 
\begin{itemize}
\item The expected time complexity of \setpush is no worse than that of every existing method even on complete graphs. 

\item When the graph $G$ is a power-law graph with $\davg=O(\log{n})$, our \setpush outperforms the Power method and LocalPush by an $O(n)$ factor, and outperforms the Monte-Carlo method and the RBS method by an $O\left(n/\log{n}\right))$ factor. Moreover, our \setpush improves over FastPPR and BiPPR by a factor of $\sqrt{n/ \log{n}}$, and improves over \sublinear by a factor of $\min\left\{\frac{n^{2/3}\cdot d_{\max}^{1/3}}{\log{n}}, \frac{n^{4/5}}{{\left(\log{n}\right)}^{4/5}}\right\}$. 
%existing methods in terms of computational time complexity. In the meantime, when the target node $t$'s degree is small (e.g., $d_t=O(1)$), the improvement of our \setpush over existing methods is also significant. Specifically, we have the following observations. 
\end{itemize}

Note that complete graphs are severely rare in real-world applications. Actually, it was empirically observed that most real-world networks are scale-free networks, which follow the power-law degree distribution with the power-law exponent $2\le \gamma \le 3$~\cite{barabasi2013network, wang2017fora, wei2019prsim, lofgren2013personalized}. In such scale-free graph, the average node degree turns out to be $\davg=m/n=O(\log{n})$~\cite{wang2017fora}. As mention above, in such case our \setpush significantly outperforms existing methods in terms of computational time complexity. %In the meantime, when the target node $t$'s degree is small (e.g., $d_t=O(1)$), the improvement of our \setpush over existing methods is also significant. Specifically, we have the following observations. 


\begin{comment}
It's worth to mention that complete graphs are severely rare in real-world applications. Actually, it was empirically observed that most real-world networks are scale-free and follow power-law degree distribution with the power-law exponent $2\le \gamma \le 3$~\cite{barabasi2013network, wang2017fora, wei2019prsim, lofgren2013personalized}. In such scale-free graph, the average node degree is $\davg=m/n=O(\log{n})$~\cite{wang2017fora}, 
%In particular, when the input graphs are scale-free with
%consider a scale-free graph where $\davg=m/n=O(\log{n})$~\cite{wang2017fora} and $\dmax=O(n)$ due to the existence of hub nodes. 
in which case our \setpush significantly outperforms existing methods in terms of computational time complexity. In the meantime, when the target node $t$'s degree is small (e.g., $d_t=O(1)$), the improvement of our \setpush over existing methods is also significant. Specifically, we have the following observations. 
\begin{itemize}
\item For the power method~\cite{page1999pagerank}, our \setpush improves it by a factor of $\tilde{O}\left(\max\left\{\frac{m}{d_t}, \sqrt{m}\right\}\right)$. In particular, when $d_t=O(1)$, \setpush significantly outperforms the power method by an $\tilde{O}\left(m\right)$ factor. 

\item For the Monte-Carlo method~\cite{fogaras2005MC}, our \setpush improves it by a factor of $\tilde{O}\left(\frac{n}{d_t}, \sqrt{\frac{n}{\davg}}\right)$. When $d_t=O(1)$, the improvement of \setpush over the Monte-Carlo method turns out to be a $\tilde{O}(n)$ factor. On the other hand, considering a scale-free networks with $\davg=O(\log{n})$, our \setpush significantly at least improves the Monte-Carlo method by a factor of $\tilde{O}\left(\sqrt{\frac{n}{\log{n}}}\right)$. 

\item For the LocalPush method~\cite{lofgren2013personalized}, our \setpush significantly outperforms it by an $\tilde{O}\left(\sqrt{m}\right)$ factor. 
    
\item For FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR}, our \setpush improves both of the two methods by a factor of $\tilde{O}\left(\sqrt{\frac{n}{d_t}}, \sqrt{\frac{d_t}{\davg}}\right)$. In particular, on a scale-free graph with $\davg=O\left(\log{n}\right)$, \setpush outperforms the two methods by a factor of at least $\tilde{O}\left(\left(\frac{n}{\log{n}}\right)^{\frac{1}{4}}\right)$. On the other hand, when $d_t=O(1)$, \setpush significantly improves the two methods by a $\tilde{O}\left(\sqrt{n}\right)$ factor. 
%improves over FastPPR and BiPPR by at least $\max \left\{\sqrt{\frac{n}{\log{n}}}, \sqrt{\frac{}{}}\right\}$. 

\item For the \sublinear method~\cite{bressan2018sublinear}, our \setpush outperforms it by a factor of $\tilde{O}\left(\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot d^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\right\}\right\}\right)$. In particular, on scale-free networks with $d=O(\log{n})$, \setpush improves over the \sublinear method by at least a $\tilde{O}\left(\left(\frac{n}{\log{n}}\right)^{3 \over 10}\right)$ factor. Alternatively, when the given target node $t$ is a low-degree node (e.g., $d_t=O(1)$ is a constant), our \setpush significantly outperforms the \sublinear method by a factor of at least $\tilde{O}\left(\min \left\{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}, n^{\frac{4}{5}}\cdot d^{\frac{1}{5}}\right\}\right)$. 
\end{itemize}
\end{comment}



%Moreover, in Section~\ref{subsec:reasonswhy} of the revised paper, 
To intuitively understand the superiority of \setpush over existing methods, 
we also explain the reasons why existing methods cannot achieve the $\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right)$ complexity on undirected graphs as \setpush does. To be more specific, the reasons can be summarized into two aspects. 
%theoretical improvements achieved by our \setpush to two points of contribution given below (also presented in Section~\ref{subsec:contribution} and Section~\ref{subsec:highlevelidea} of the revised paper). 
\begin{itemize}
    \item The reverse exploration method (e.g., LocalPush~\cite{lofgren2013personalized}) and most of the hybrid methods (e.g., FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR}) adopt the vanilla backward push operations to reversely propagate the probability mass from the target node to its ancestors. However, the backward push operation (e.g., at node $u$) has to touch every neighbor of $u$ to push the probability mass, which leads to an $O(d_u)$ lower bound for the time cost of the backward push at $u$. In our \setpush, we propose a novel push operation, which simultaneously mixes the deterministic backward push and randomized Monte-Carlo sampling in one atomic step. Benefit from the novel push operation, we deterministically cost $O(d_u)$ time only at the node $u$ with small $d_u$, and randomly sample a fraction of $u$'s neighbors to push probability mass if $d_u$ is large. As a result, we successfully remove the $O(d_u)$ term introduced by the vanilla push operation at node $u$, and achieve a superior time complexity over the reverse exploration method (e.g., LocalPush) and most of the hybrid methods (e.g., FastPPR and BiPPR). 

    \item Considering the problem of single-node PageRank computation, existing methods mainly focus on directed graphs, and fail to make full use of the properties held by PageRank values on undirected graphs. In comparison, our \setpush algorithm is designed specifically on undirected graphs. We elaborately leverage the properties of PageRank on undirected graphs to achieve superior time complexity result. Specifically, we note that the canonical Monte-Carlo sampling admits an $\Omega\left(\frac{1}{\vpi(t)}\right)$ lower bound for deriving a $(c, p_f)$-approximation of $\vpi(t)$. Worse still, by the definition formula of PageRank, the initial probability distribution of simulating $\alpha$-random walks is $\frac{1}{n}\cdot \bm{1}=\left(\frac{1}{n}, \frac{1}{n}, \ldots, \frac{1}{n}\right)$. Therefore, in the worst-case scenario where $\vpi(t)=O\left(\frac{1}{n}\right)$, the Monte-Carlo method requires $\Omega(n)$ $\alpha$-random walks to hit node $t$ at least once. However, on undirected graphs, it is actually no longer necessary to simulate $\alpha$-random walks from a uniformly selected source node $s$. As shown in Equation~\eqref{eqn:actual_eqn}, on undirected graphs, we are able to estimate $\vpi(t)$ by computing $\frac{1}{n}\cdot \sum_{s\in V}\sum_{\ell=1}^L \frac{d_t}{d_s}\cdot \vpi^{(\ell)}_t(s)$. In other words, on undirected graphs, we can propagate the probability mass forward from the target node $t$, instead of simulating $\alpha$-random walks from a uniformly selected source node. Inspired by this observation, we successfully break the lower bound $O\left(\frac{1}{\vpi(t)}\right)$ of Monte-Carlo sampling with non-trivial analyses. As a consequence, our \setpush achieves a superior complexity result over all existing methods that include the Monte-Carlo sampling phase (e.g., the Monte-Carlo method~\cite{fogaras2005MC}, FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR}, and the \sublinear method~\cite{bressan2018sublinear}). 
\end{itemize}

% Figure environment removed




\review{\bf W2}: {\em The descriptions of experimental results and the figures are not one-to-one corresponded. It seems need to be double-checked. } 

\header{\bf Response: } Thanks for the suggestion. We have revised the experimental descriptions as advised. Please refer to Section~\ref{sec:exp} for details. 


\review{\bf W3}: {\em It will be better to provide more experiments to verify the performance of the proposed algorithm. Details are in the detailed comments. } 

\header{\bf Response: } Thanks for the suggestion. As pointed out in the D3 point, we included the experimental results of FastPPR in Figure~\ref{fig:query_uniform_0.1}, ~\ref{fig:query_uniform_0.5}, ~\ref{fig:query_degree_0.1}, and ~\ref{fig:query_degree_0.5}. Moreover, we added Figure~\ref{fig:dt_rev} to show the query time changes of each method with increasing $d_t$. Please refer to our response to D3 and D4.1 for details. 


\review{\bf D1}: {\em The paper proposes a new SetPush algorithm to solve the single node PageRank estimating problem which also provides detailed theoretical analysis. However, the superiority of the proposed algorithm against the existing methods is not shown significantly in practice. For example, the existing SubgraphPush algorithms seems can provide a similar or better query time on some datasets (Figure 6). } 

\header{\bf Response: } Thanks for pointing out this issue. We note that \sublinear may slightly outperform our \setpush only when the relative error parameter $c=0.5$ and the target node $t$ is chosen according to the degree distribution. In other words, the outperformance of \sublinear only exists for relatively large $c$ and the target node $t$ with high PageRank value. We attribute this phenomenon to the blacklist trick adopted in the \sublinear method. Specifically, the \sublinear~\cite{bressan2018sublinear} method includes a preprocessing phase, in which the \sublinear method samples $\ell=\min \left\{\frac{n^{2/3}\dmax^{1/3}}{c^{4/3}}, \frac{n^{4/5}d^{1/5}}{c^{6/5}}\right\}$ $\alpha$-random walks. For each $u\in V$, the \sublinear method computes $b(u)$, where $b(u)$ denotes the faction of times that the $\ell$ $\alpha$-random walks stops at node $u$. The \sublinear method defines a set $B$ called blacklist, which contains all the nodes $u\in V$ with $b(u)\ge \tilde{O}\left(\frac{1}{\ell}\right)$. During the query phase, if the given target node $t$ belongs to the blacklist $B$, the \sublinear method will stop early and return $\frac{1}{b(t)}$ as the approximation of $\vpi(t)$. Thus, for the target node $t$ with high PageRank value and large relative error $c$, the empirical running time cost may outperform our \setpush. However, such blacklist trick cannot improve the query time complexity of \sublinear in the worst case. %However, in practice, the \sublinear may performs well for some target node under large relative error. 
In Figure~\ref{fig:dt_rev}, we show the query time changes of each method with increasing $d_t$ and fixed $c=0.1$. We observe that our \setpush can consistently outperform the \sublinear method on all of the four datasets. This demonstrates the superiority and robustness of our \setpush. On the other hand, the blacklist trick can be also adopted in our \setpush, which, however, is beyond the scope of this paper. We leave the question of how to leverage this trick for achieving a better time complexity result as our future work. 


% Figure environment removed


% Figure environment removed


\review{\bf D2}: {\em Since I have checked that the query time of SubgraphPush presented in~\cite{bressan2018sublinear} is $O\left(\min\left\{\frac{m^{2/3} d^{1/3}_{max}}{d^{2/3}}, \frac{m^{4/5}}{d^{3/5}}\right\} \right)$, which is different with that reported in Table 1 of this paper, it will be better to explain it. } 

\header{\bf Response: } The expected time complexity of the SubgraphPush method~\cite{bressan2018sublinear} is $\tilde{O}\left(\min\left\{\frac{m^{2/3} d^{1/3}_{max}}{d^{2/3}}, \frac{m^{4/5}}{d^{3/5}}\right\} \right)$. The complexity of SubgraphPush listed in Table~\ref{tbl:comparison} in the original manuscript is incorrect. We sincerely thank the reviewer for pointing out this typo, and we are sorry for this discrepancy. We have corrected this typo in the revised paper. Please refer to Table~\ref{tbl:comparison} for details (also shown in Table~\ref{tbl:comparison_rev} given in this response letter for convenience). 

Nonetheless, our \setpush STILL achieves superior query efficiency over the \sublinear method~\cite{bressan2018sublinear} for deriving a $(c,p_f)$-approximation of $\vpi(t)$ on undirected graphs. Specifically, our \setpush improves over the \sublinear method by a factor of: 
\begin{align*}
\varphi=\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot \davg^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{\davg^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{\davg^{\frac{3}{10}}}\right\}\right\},     
\end{align*}
where $\dmax$ and $\davg$ denote the maximum and average node degree of the graph $G$, respectively. A detailed illustration to derive the value of $\varphi$ can be found in our response to D6 of Reviewer \#5. Note that the factor $\varphi$ is strictly larger than $1$ unless $\davg=n$. Thus, the expected query time complexity of \setpush is {\em asymptotically better} than that of \sublinear unless on a complete graph. Even on a complete graph, in which case $\varphi=1$, the complexity of \setpush is no worse than that of \sublinear. Furthermore, we present a comprehensive analysis on the theoretical improvements of our \setpush over each of existing method. Please refer to our response to the W1 point of Reviewer \#4 for details. 
%Please refer to our response to the W1 point in this section for detailed illustrations on our contributions and the superiority of \setpush over existing methods. 

%Note that a complete graph is severely rare in real-world applications. Actually, it was empirically observed that most real-world networks are scale-free and follow power-law degree distribution with the power-law exponent $2\le \gamma \le 3$~\cite{barabasi2013network, wang2017fora, wei2019prsim, lofgren2013personalized}. In such scale-free graph, the average node degree is $\davg=m/n=O(\log{n})$~\cite{wang2017fora}, %In particular, when the input graphs are scale-free with %consider a scale-free graph where $\davg=m/n=O(\log{n})$~\cite{wang2017fora} and $\dmax=O(n)$ due to the existence of hub nodes. 
%and thus, our \setpush improves over the \sublinear method by at least $\left(\frac{n}{\log{n}}\right)^{3 \over 10}$. %It was empirically observed that most real-world networks are scale-free and follow power-law degree distribution. 
%Furthermore, if the given target node $t$ is a low-degree node (e.g., $d_t=O(1)$ is a constant), our \setpush significantly outperforms the \sublinear method by at least $\min \left\{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}, n^{\frac{4}{5}}\cdot d^{\frac{1}{5}}\right\}$, whether or not on scale-free graphs. 





\review{\bf D3}: {\em As shown in Table~\ref{tbl:comparison}, the existing FastPPR, BiPPR and SubgraphPush algorithms have the better performance than others. However, the paper only compares the proposed algorithm to SubgraphPush algorithm. It is necessary to evaluate the query time by comparing with FastPPR or BiPPR. } 

\header{\bf Response: } In Figure~\ref{fig:query_uniform_0.1_rev}, ~\ref{fig:query_uniform_0.5_rev}, ~\ref{fig:query_degree_0.1_rev}, and ~\ref{fig:query_degree_0.5_rev}, we included the experimental results of FastPPR~\cite{lofgren2014FastPPR} as advised. We observe that our \setpush consistently outperforms FastPPR in terms of query time on all of the four datasets. In particular, when the target node is uniformly selected, our \setpush outperforms FastPPR by up to an order of magnitude in query time on the YT and IC datasets. For the BiPPR method~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected}, we omit its experimental results in Figures~\ref{fig:query_uniform_0.1_rev}, ~\ref{fig:query_uniform_0.5_rev}, ~\ref{fig:query_degree_0.1_rev}, and ~\ref{fig:query_degree_0.5_rev} since the publicly released code of BiPPR is only implemented in Scala. %, while other methods compared in this paper are implemented in C++.
%Thus,  %Thus, we attribute the experimental results of FastPPR to show the
Note that the complexity result of BiPPR is asymptotically the same as that of FastPPR. We believe the superiority of \setpush over FastPPR illustrated in Figures~\ref{fig:query_uniform_0.1_rev}, ~\ref{fig:query_uniform_0.5_rev}, ~\ref{fig:query_degree_0.1_rev}, and ~\ref{fig:query_degree_0.5_rev} can also demonstrate the superiority of \setpush over BiPPR. 


\review{\bf D4.1}: {\em It will be better to show how the query time changes with $d_t$ increasing to illustrate the superiority of the proposed algorithms.} 

\header{\bf Response: } In Figure~\ref{fig:dt_rev}, we added the experiments to show the query time changes of each method with increasing the value of $d_t$. Specifically, we partition the vertex set $V$ into five subsets $V_1, V_2, V_3, V_4, V_5$, such that the average node degrees $\davg_1, \davg_2, \davg_3, \davg_4, \davg_5$ of $V_1, V_2, V_3, V_4, V_5$ satisfy $\davg_1 \ge 100\davg$, $\davg_2 \in [10 \davg, 100 \davg)$, $\davg_3 \in [\davg, 10\davg)$, $\davg_4 \in [0.1 \davg, \davg)$, and $\davg_5 \in [0.01 \davg, 0.1\davg)$, respectively. In each subset (i.e., $V_1, \ldots, V_5$), we select five query nodes uniformly at random, and conduct each method to compute the five query nodes' PageRank. For each subset $V_1,\ldots, V_5$, we report the average running time of each method over the five query nodes with $c=0.1$ and $p_f=0.1$. From Figure~\ref{fig:dt_rev}, we note that our \setpush consistently outperforms all baseline methods on all datasets for all query sets. In particular, for law-degree query nodes, our \setpush achieves $10\times \sim 1000\times$ improvements on the query time over existing methods. For high-degree query nodes, the superiority of \setpush is gradually weakened, but still exists. Additionally, from Figure~\ref{fig:dt_rev}, we can derive several interesting observations: 
\begin{itemize}
    \item The query time of the Monte-Carlo method, RBS, and the \sublinear method nearly remain unchanged with the increment of $d_t$. This concurs with our analysis that the three methods do not include $d_t$ in their complexity results. 

    \item The query time of FastPPR and BiPPR increase slowly with the increment of $d_t$. This also concurs with the theoretical analysis since the time complexity of FastPPR and BiPPR is $\tilde{O}\left(n \cdot d_t\right)$, which has a logarithmic dependence on $d_t$. 

    \item Finally, we note that the query time of our \setpush and LocalPush grow linearly with $d_t$, which demonstrate the time complexities of the two methods are in linear of $d_t$. 
\end{itemize}


\review{\bf D4.2}: {\em In Figure 6, SubgraphPush provides better results than SetPush on YT and OL datasets. It will be better to explain the reason.} 

\header{\bf Response: } Thanks for pointing out this. Please refer to our response to the D1 point for details.  


\review{\bf D4.3}: {\em Page 12, Experimental Results, Figure 3 and Figure 6 -> Figure 3 and Figure 4. It is necessary to clearly state that the omitted result on Friendster in Figure 3 is the MC algorithm. The omitted results on Friendster in Figure 5 are LocalPush and MC.} 

\header{\bf Response: } Thanks for the advice. We have revised the descriptions as advised. Please refer to Section~\ref{sec:exp} for details. 




\subsection*{Reviewer \#5} \label{sec:r5}

\review{\bf W1}: {\em The application/motivation for estimating the PageRank value of a single node is unclear.} 

\review{\bf D1}: {\em It is unclear what are the applications of estimating the PageRank value of a single node.} 

\header{\bf Response to W1 and D1: } Thanks for pointing out this issue. %We elaborate the applications and motivations for estimating a single node's PageRank value. Please refer to the Introduction of the revised paper for details. 
The significance to study the single-node PageRank computation problem can be summarized into two aspects: 

First, from the theoretical aspect, the problem of efficiently estimating a single node's PageRank is of particular interest, which has been the subject of multiply research over a decade. The recent FOCS' 18 paper~\cite{bressan2018sublinear} proposes a novel method \sublinear, which achieves the $\tilde{O}\left(\min \left\{n^{2/3} \dmax^{1/3}, n^{4/5}\davg^{1/5}\right\}\right)$ time complexity for deriving a $(c,p_f)$-approximation of $\vpi(t)$. 
Furthermore, the single-node PageRank problem is an important primitive of theoretical interest. the query time complexity of single-node PageRank is related to several graph analysis problems. For example, as shown in Equation~\eqref{eqn:PageRank_PPR}, node $t$'s PageRank is equal to the average over all nodes $u$ of $\vpi_u(t)$, where $\vpi_u(t)$ denotes the Personalized PageRank (PPR) of node $t$ with respect to node $u$. Therefore, any theoretical insight for single-node PageRank computation may be extended to solve the problem of single-target PPR queries. Here we call the problem single-target PPR queries, in which we ask for $\vpi_u(t)$ of every node $u\in V$. Furthermore, as shown in~\cite{bressan2018sublinear}, the \sublinear algorithm for single-node PageRank computation can be extended to compute the Heat Kernel PageRank (HKPR) and applied in the local clustering scenario. 

Second, in many practical cases, all we need is an approximation of a few nodes' PageRank scores. For example, we may hope to observe the changes in the importance of a few popular websites (e.g., the top-10 most important websites ranked last year). Since websites' global importance can be reflected from their PageRank scores, in the case, we will frequently ask for the PageRank scores of the 10 websites. It would be prohibitively slow to score all nodes in the graph every time, especially on large-scale graphs with millions or even billions of nodes and edges. Therefore, an ideal solution is a {\em local} algorithm, which is able to efficiently return the target node's approximation scores by only exploring a small fraction of graph edges around the target node. However, as pointed out by~\cite{bressan2018sublinear}, most of existing approaches require an $\Omega(n)$ time complexity for single-node PageRank computation.  %We also illustrate the limitations of existing methods in Section~\ref{sec:algorithm}. 
Designing an efficient local algorithm for single-node PageRank computation still remains a challenging task. This offers us motivations to study the single-node PageRank computation problem from the practical aspect. 

\begin{comment}
Briefly speaking, we first listed multiple application scenarios of PageRank computation in the Introduction, including web search, social networks, recommender systems, databases, as well as biology, chemistry, neuroscience and etc. Then we provided a concrete example in which case all we need is an approximation of one or a few nodes' PageRank scores. Specifically, consider a data mining task that we are required to observe the changes in the importance of a few popular websites (e.g., the top-10 most important websites ranked last year). In this case, we will frequently ask for the PageRank scores of the 10 websites given the fact that websites' global importance can be reflected from their PageRank scores. Notably, it would be prohibitively slow to score all nodes in the graph every time, especially on large-scale graphs with millions or even billions of nodes and edges. Therefore, an ideal solution for such case is a {\em local} algorithm, which is able to efficiently return the target node's approximation scores by only exploring a small fraction of graph edges around the target node. However, as pointed out by~\cite{bressan2018sublinear}, most of existing approaches require an $\Omega(n)$ time complexity for single-node PageRank computation. %We also illustrate the limitations of existing methods in Section~\ref{sec:algorithm}. 
Thus, designing an efficient local algorithm for single-node PageRank computation remains a challenging task. This motivates us to study the problem of single-node PageRank computation from the practical aspect. 

Furthermore, from the theoretical aspect, we note that the query time complexity of single-node PageRank is related to several graph analysis problems. For example, as we illustrate in Section~\ref{sec:pre} (i.e., Equation~\eqref{eqn:PageRank_PPR}), node $t$'s PageRank is equal to the average over all nodes $u$ of $\vpi_u(t)$, where $\vpi_u(t)$ denotes the Personalized PageRank (PPR) of node $t$ with respect to node $u$. We call the problem single-target PPR queries, in which we ask for $\vpi_u(t)$ of every node $u\in V$. Therefore, 
any theoretical insight for single-node PageRank computation may be extended to solve the problem of single-target PPR queries. 
Additionally, as proved in~\cite{bressan2018sublinear}, the algorithm for single-node PageRank computation proposed in~\cite{bressan2018sublinear} also holds for Heat Kernel PageRank (HKPR). All of the above demonstrate that the problem of single-node PageRank computation is a primitive of theoretical interest. 
\end{comment}


\review{\bf W2, D2}: {\em It seems that the proposed algorithm does not work on directed graphs or absolute error estimation.} 

\header{\bf Response: } The complexity result of our \setpush is only applicable to undirected graphs. We describe our motivations to study the single-node PageRank computation problem specifically on undirected graphs from both theoretical and practical aspects. Please refer to our response to Meta Reviewer for details. 

The query time complexity of \setpush can be analyzed under absolute error. Recall that we bound the variance of $\epi(t)$ in Theorem~\ref{thm:variance}. Then we adopt the Chebyshev's Inequality to bound the value of $\theta$. Since the Chebyshev's Inequality also admits absolute error, our analysis can be also analyzed under absolute error. %which, however, is beyond the scope of our paper. %We leave this as our future work. 
However, most of recent methods are analyzed under relative error~\cite{lofgren2014FastPPR, lofgren2016BiPPR, lofgren2015BiPPRundirected, bressan2018sublinear, wang2020RBS}. %For the concern on the choice of approximation error metric, it is actually a well-adopted goal to estimate single-node PageRank (or single-target PPR, single-node HKPR, etc) under relative error in literature~\cite{bressan2018sublinear, lofgren2016BiPPR, lofgren2014FastPPR, wang2020RBS, yang2019TEA}.
On the other hand, as pointed out in~\cite{dagum2000optimal}, for those small PageRank scores $\vpi(t)$, a good absolute error estimate is typically a poor approximation of $\vpi(t)$ in terms of relative error. %And Bressan et al.~\cite{bressan2018sublinear} prove that 
Note that in an $n$-node graph, all except $o(n)$ nodes have small PageRank scores $O\left(\frac{1}{n}\right)$. Thus, in this paper, we only analyze the theoretical properties of \setpush under relative error. We leave the problem of estimating single-node PageRank with absolute error as the future work. 
%This means for almost every target node $t$ in the graph $G$, computing an estimate of $\vpi(t)$ under relative error is much harder than deriving a good absolute error estimate. %Furthermore, as shown in~\cite{wang2020RBS}, the approximation algorithm under relative error can also be used to derive an absolute error estimate just with a slight modification, which, however, is beyond the scope of our paper. We leave this as our future work. 


%Specifically, to achieve an $\e$ absolute error approximation of $\vpi(t)$, we aim to derive an estimator $\epi(t)$ of $\vpi(t)$, such that 
%\begin{align*}
%\left\|\vpi(t)-\epi(t)\right\| \le \e. 
%\end{align*}
%By the Chebyshev's Inequality, we can derive: 
%\begin{align*}
%\Pr \left\{\vpi(t)-\bpi(t)\right\}\ge \e 
%\end{align*}

%Our \setpush algorithm is proposed to efficiently estimate single-node PageRank within constant relative error on undirected graphs. The complexity of $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$ achieved by our \setpush is only applicable to undirected graphs with the relative error constraint. 

%It is worth to mention that the problem of estimating single-node PageRank on undirected graphs is of great importance from both practical and theoretical aspects (see the Introduction for details). Moreover, there exist some valuable properties of PageRank scores only held on undirected graphs (see our response to the Meta-Reviewer for details). However, existing methods do not pay enough attention to these properties, and fail to make full use of these properties to design efficient algorithms on undirected graphs. As a result, the best complexity bound for estimating single-node PageRank on undirected graphs is achieved by the algorithm originally proposed on directed graphs, with a large theoretical gap to be further improved. On the other hand, improving the complexity of single-node PageRank computation on directed graphs is a non-trivial problem. We provided a toy example to intuitively illustrate the hardness in our response to the Meta-Reviewer. %on the difference between single-node PageRank computations on undirected and directed graphs . 
%As a result, although most of existing methods mainly focus on directed graphs, some of them even can not offer worst-case guarantee on directed graphs without considering a uniform random choice of the target node. For these methods (e.g., LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR}), meaningful complexity bounds can only be derived on undirected graphs when we consider an arbitrary target node. 

%Based on the above observations, in this paper, we focus on the problem of single-node PageRank computation on undirected graphs. We propose a novel algorithm \setpush, in which we design a novel push operation and elaborately make use of the theoretical properties held by PageRank scores on undirected graphs. As a consequence, our \setpush outperforms existing methods on undirected graphs in terms of expected computational time complexity. %We presented a elaborated description to illustrate the above issues in the Introduction of the revised paper, and in our response to the Meta-Reviewer. Please refer these contents for more details. 
%In the Introduction, we added a detailed illustration on the importance and pressing demand to study the problem of single-node PageRank computation on undirected graphs. And in our response to the Meta-Reviewer, we elaborate on the hardness of improving the time complexity for the single-node PageRank computation on directed graphs. Please refer to Section~\ref{sec:intro} and our response to the Meta-Reviewer for details. 

%The major reasons are listed as below. 
%\begin{itemize}
%\item First, from the practical aspect, many downstream graph mining and learning tasks are only defined on undirected graphs. All input directed graphs are required to be converted to undirected graphs. For example, in the scenario of local clustering, the well-adopted {\em conductance} metric to measure the the quality of identified clusters is defined on undirected graphs. Thus, %most of (if not all) local clustering algorithms are only for undirected graphs. Among them, 
%a celebrated local clustering method~\cite{FOCS06_FS} employ the Personalized PageRank vector computed on undirected graphs to find local clusters. Moreover, Graph Neural Networks (GNNs) have drawn increasing attention in recent years. A plethora of GNN models leverage PageRank computation to propagate node features~\cite{klicpera2019APPNP, Bojchevski2020PPRGo,Chen2020GCNII}. Because the graph Laplacian matrix for feature propagation is only applicable to undirected graphs, this line of research invokes PageRank computation algorithms only on undirected graphs. 

%\item Second, from the theoretical aspect, existing methods for single-node PageRank computation mainly focus on directed graphs. %which, however, incur large query time complexity despite decades of efforts due to the hardness. In this paper, we settle for a slightly less ambitious target to efficiently estimate single-node PageRank {\em on undirected graphs}. However, a number of existing algorithms do not offer any worst-case guarantee on directed graphs without considering a uniform random choice of the target node. For these methods, meaningful complexity bounds  can only be derived on undirected graphs when we consider an arbitrary target node (e.g., the LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR} methods as listed in Table~\ref{tbl:comparison}). 
%Note that the three methods, LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR}, are originally proposed on directed graphs. However, they cannot offer the worst-case guarantee on directed graphs without considering a uniform random choice of the target node. 
%(as listed in Table~\ref{tbl:comparison}). 
%On the other hand, to our knowledge, the best complexity results for single-node PageRank computation on undirected graphs are achieved by FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR} and \sublinear~\cite{bressan2018sublinear}. %(which one is the best determined by the specific values of $d, d_{\max}$ and $d_t$).
%However, the three methods are originally proposed on directed graphs. This reflects that existing methods do not fully utilize the properties of PageRank on undirected graphs, and leaves significant theoretical gaps to be improved on undirected graphs. %The two points mentioned above motivate us to study the problem of single-node PageRank computation on undirected graphs. 

    
%\end{itemize}






%in this paper, we analyze the theoretical properties of our \setpush under relative error. 
%our \setpush may be extended to estimate single-node PageRank with absolute error. 

%Finally, we admit that it is an non-trivial problem to improve the complexity bound for the single-node PageRank computation on directed graphs. We leave open this problem as a future work presented in the Conclusion (see Section~\ref{sec:conclusion}). Please refer to our response to Meta-Reviewer for details. 



\review{\bf W3}: {\em Discussions on the applicability of the proposed new push operator to other PageRank estimation problems are not discussed.} 

\review{\bf D8}: {\em As the main idea is the new push operator (which actually is similar to the push operator used in RBS), it would be better to discuss the applicability of the new push operator to other PageRank estimation problems, such as PPR to a target node, single source PPR, and directed graphs. For example, can it replace the push operator used in LocalPush? } 

% Figure environment removed

\header{\bf Response to W3 and D8: } 
%As we mentioned in the response to W1, the problem of estimating a single node's PageRank is a primitive of theoretical interest. The query time complexity of single-node PageRank computation is
The push operation adopted in our \setpush can replace the push operator used in LocalPush~\cite{lofgren2013personalized} on undirected graphs. As shown in Algorithm~\ref{alg:VBES}, we repeatedly conduct the new push operations in the \setpush algorithm to estimate the target node $t$'s PageRank $\vpi(t)$ in $\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right)$ query time. In comparison, the LocalPush method estimates $\vpi(t)$ by performing the vanilla push operations step by step, which, however, admits a $\tilde{O}\left(\min\left\{n \cdot d_t, m\right\}\right)$ time complexity. We attribute the theoretical improvement of \setpush over LocalPush partially to the superiority of the new local push operation over the vanilla push. More discussions on the superiority of the new push operation adopted in \setpush can be found in our response to the W1 point raised by Reviewer \#4, or in Section~\ref{subsec:reasonswhy} and Section~\ref{subsec:highlevelidea} of the revised paper. 

On the other hand, we note that the LocalPush method has long been a crucial building block in many tasks. For example, FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected} combine the LocalPush method with the Monte-Carlo method to compute single-pair Personalized PageRank (PPR). Wei et al.~\cite{wei2019prsim} employ the LocalPush method to estimate single-source SimRank vector, where SimRank is a popular node similarity metric. Moreover, Wang et al. ~\cite{wang2018efficient} adopt the LocalPush method to find approximate heavy hitters in Personalized PageRank. Yin et al.~\cite{yin2019STRAP} compute the PPR matrix for node embedding by repeating the LocalPush method from every node on the graph. Therefore, the improvements over the LocalPush method also contributes to the query efficiency of the above mentioned tasks. Furthermore, as we illustrate in our response to W1\&D1, the problem of single-node PageRank computation is a primitive of theoretical interest, whose time complexity has a close connection to those of single-target PPR queries and single-node HKPR queries. Thus, the theoretical insights given in our \setpush can be also extended to solve the problems of single-target PPR queries and single-node HKPR queries. However, it is beyond the scope of this paper to discuss how to improve these tasks in detail, and we leave these promising problems as our future research directions. 

It's worth to mention that the new push operation adopted in our \setpush may be extended to directed graphs, while the complexity result of \setpush is only applicable to undirected graphs. Please refer to our response to Meta Reviewer for the applications and theoretical importance to study the single-node PageRank computation problem specifically on undirected graphs.  Additionally, the push operation adopted in \setpush is similar in spirit to the one used in RBS, but differs in one crucial aspect: we independently sample the neighbors $v$ from $N(u)$, while the sampling technique adopted in the RBS method is non-independent. As a consequence, the increment of $\r^{(\ell+1)}_t(v)$ for each $v\in V$ in \setpush is independent with each other. In contrast, the non-independent sampling technique adopted in the RBS method results in either large variance or expensive time cost. For example, consider the graph shown in Figure~\ref{fig:related} with node $t$ as the given target node. The sampling threshold of each $u\in N(t)$ is satisfied simultaneously. Thus, the RBS method costs either $O(n)$ time or unbounded approximation error to estimate $\vpi(t)$. Instead, in \setpush, we can independently sample $u\in N(t)$ to update $\r^{(\ell)}_t(u)$. 


%Thanks for the advice! Note that the superiority of \setpush mainly comes from two aspects. On one hand, we propose a novel push operation, which mixes the deterministic backward push and randomized Monte-Carlo sampling in one atomic step. In the new push operation (e.g., at node $u$), we do not need to touch every neighbor of $d_u$, and thus, improve the time complexity of the reverse exploration method. It's worth to mention that our push operation is in spirit to push operation adopted in RBS, but differs in one crucial aspect. That is, the sampling technique adopted in the push operation of RBS is non-independent, which results large variance for the single-node PageRank computation. In comparison, in the \setpush method, the increment of $\r_t^{(\ell)}$ for each $v\in V$ is independent with each other. As a consequence, the time complexity of our \setpush for estimating the single-node PageRank on undirected graphs is asymptotically better than that of the RBS method~\cite{wang2020RBS}. 

%On the other hand, we observe that there are several crucial properties held by the PageRank values on undirected graphs. However, existing methods do not pay enough attention to these properties, leading to suboptimal complexity results on undirected graphs. In our \setpush, we elaborately leverage these valuable properties, and successfully avoid the $O(n)$ time cost introduced by Monte-Carlo sampling in the worst-case scenario. 






\review{\bf D3}: {\em As the main contribution of the paper is the detailed theoretical analysis of the proposed push operator (and the resulting graph), a theoretical venue may be more suitable for this paper. } 

\header{\bf Response: } Thanks for the advice! However, we still believe the scope of the paper is highly relevant to the VLDB conference. The reasons can be summarized into three points given below. 
\begin{itemize}
\item In this paper, we focus on the problem of estimating single-node PageRank on undirected graphs. The PageRank computation problem (or its variants) is of great interest for the VLDB community~\cite{maehara2014computing, wei2018topppr, wu2021SpeedPPR, wang2018efficient, yang2019TEA, liao2022spanningforests, edgepush, wei2019prsim}. The problem of single-node PageRank computation is of great imporantnce from both theoretical and practical aspects (see our response to W1\&D1 for details). Moreover, in our response to Meta Reviewer, we clarify our motivations to study the problem specifically on undirected graphs. 
%As we illustrated in the Introduction, PageRank is a highly important graph centrality metric, which is widely adopted in numerous real-world applications. Moreover, computing a single node's PageRank is also of great significance from both theoretical and practical aspects. Please refer to our response to the W1 point of Reviewer \#5 for more supporting details. 
Therefore, we believe the research topic of single-node PageRank computation on undirected graphs is within the scope of VLDB papers. 

\item Futhermore, 
%Motivated by the pressing need of efficient single-node PageRank algorithms on undirected graphs, 
in this paper, we propose the \setpush algorithm, which achieves the best time complexity result among existing methods. With non-trivial analysis, we theoretically prove the superiority of \setpush over existing methods and explain the reasons why existing methods cannot achieve the complexity bound of \setpush. We believe our \setpush can bring some new ideas and theoretical insights to the VLDB community. 

\item Finally, we conduct comprehensive experiments on large-scale real-worlds datasets. Our experimental results demonstrate that our \setpush outperforms existing methods on undirected graphs in terms of query efficiency. 
\end{itemize}


\review{\bf D4}: {\em $c$ is ignored from the time complexity analysis. It will be better if the authors could also provide a version of the time complexity analysis with $c$ included; for example, what would the polynomial order of $c$ be? } 

\header{\bf Response: } Thanks for the advice. We included $\alpha, c$ and all logarithmic factors in the time complexity analysis. Please see Theorem~\ref{thm:finalcost_analysis} and its proof for details. 


\review{\bf D5}: {\em What are ignored by the $\tilde{O}$ notation is not mentioned in the paper? } 

\header{\bf Response: } $\tilde{O}$ is a commonly-used asymptotic notation and is widely adopted in literature (e.g., ~\cite{bressan2018sublinear, wang2020RBS, teng2016scalable}). Specifically, given a function $g(n)$, $\tilde{O}\left(g(n)\right)$ denotes the set of functions: 
\begin{align*}
\tilde{O}\left(g(n)\right)\hspace{-0.5mm}=\hspace{-0.5mm}\left\{f(n) \mid \exists\textit{~constant~} c \hspace{-0.5mm}>\hspace{-0.5mm} 0, \textit{such that~} f(n)\hspace{-0.5mm}=\hspace{-0.5mm}O\left(g(n)\hspace{-0.5mm} \cdot \hspace{-0.5mm} \log^c{n}\right)\right\}. 
\end{align*}
The above definition is presented in Section 1.2 of~\cite{teng2016scalable}. In other words, $\tilde{O}$ is a variant of the Big-Oh notation that ignores poly-logarithmic factors. For example, $n\log{n} = \tilde{O}(n)$. 
%, and $n^2 \log{n} \log{\log{n}}=\tilde{O}\left(n^2\right)$. 
%The $\tilde{O}$ notation is widely adopted in literature (e.g., ~\cite{bressan2018sublinear, wang2020RBS, teng2016scalable}) to make a . 
We explained the meaning of the $\tilde{O}$ notation in Table~\ref{tbl:def-notation}, and added more explanations on $\tilde{O}$ in the Introduction (see Section~\ref{subsec:contribution} for details). 




\review{\bf D6}: {\em In the Introduction, it is unclear why $\bar{d}^{1/5} \cdot n^{4/5}$ would be always no smaller than $d_t$. For example, what if $\bar{d}$ is small while $d_t$ is large? } 

\header{\bf Response: } Thanks for pointing out this. The expected time complexity of SubgraphPush~\cite{bressan2018sublinear} is $\tilde{O}\left(\min\left\{\frac{m^{2/3} d^{1/3}_{max}}{d^{2/3}}, \frac{m^{4/5}}{d^{3/5}}\right\} \right)$. The complexity of SubgraphPush listed in Table~\ref{tbl:comparison} in the original manuscript is incorrect. We sincerely thank the reviewer for pointing out this typo, and we are sorry for this discrepancy. We have corrected this typo in the revised paper. Please refer to Table~\ref{tbl:comparison} for details (also shown in Table~\ref{tbl:comparison_rev} given in the response letter for convenience). 

To see the superiority of our \setpush over the \sublinear method, recall that the expected time complexity of our \setpush is $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$. If $d_t \ge \sqrt{m}$, then our \setpush improves the \sublinear method by a factor of: 
\begin{align*}
\frac{\min\left\{\hspace{-0.5mm}\frac{m^{\frac{2}{3}} d^{1/3}_{max}}{d^{\frac{2}{3}}}, \frac{m^{\frac{4}{5}}}{d^{\frac{3}{5}}}\hspace{-0.5mm}\right\}}{\min \left\{d_t, \sqrt{m}\right\}}\hspace{-0.5mm}=\hspace{-0.5mm}\min\left\{\hspace{-0.5mm}\frac{m^{\frac{2}{3}} d^{1/3}_{max}}{d^{\frac{2}{3}} m^{\frac{1}{2}}}, \frac{m^{\frac{4}{5}}}{d^{\frac{3}{5}} m^{\frac{1}{2}}}\hspace{-0.5mm}\right\} \hspace{-0.5mm}= \hspace{-0.5mm}\min\left\{\hspace{-0.5mm}\frac{n^{\frac{1}{6}} d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\hspace{-0.5mm}\right\}. 
\end{align*}
Otherwise (i.e., $d_t < \sqrt{m}$), \setpush improves \sublinear by a factor of: 
\begin{align*}
\frac{\min\left\{\hspace{-0.5mm}\frac{m^{\frac{2}{3}} d^{1/3}_{max}}{d^{\frac{2}{3}}}, \frac{m^{\frac{4}{5}}}{d^{\frac{3}{5}}}\hspace{-0.5mm}\right\}}{\min \left\{d_t, \sqrt{m}\right\}}
\hspace{-0.5mm}=\hspace{-0.5mm}\min\left\{\hspace{-0.5mm}\frac{m^{\frac{2}{3}} d^{1/3}_{max}}{d^{\frac{2}{3}} d_t}, \frac{m^{\frac{4}{5}}}{d^{\frac{3}{5}} d_t}\hspace{-0.5mm}\right\} 
\hspace{-0.5mm}= \hspace{-0.5mm}\min\left\{\hspace{-0.5mm}\frac{n^{\frac{2}{3}} d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{3}{5}}d^{\frac{1}{5}}}{d_t}\hspace{-0.5mm}\right\}. 
\end{align*}
Consequently, we can derive that the improvement of \setpush over the \sublinear method is: 
\begin{align*}
\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot d^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\right\}\right\}\ge 1. 
\end{align*}
And the above inequality takes equation when $d=n$ (i.e., on a complete graph). We present a detailed illustration on the superiority of our \setpush over the \sublinear method, which can be found in our response to D2 of Reviewer \#4. 




\review{\bf D7}: {\em The computation of ground-truth PageRank values is discussed in the Experiments. But it is unclear how this is used in the experiments. Also, it would be better to also test the actual accuracy achieved by the tested algorithms. } 

\header{\bf Response: } Thanks for the advice. We evaluate the empirical relative errors of our \setpush, and report the experimental results in Figure~\ref{fig:epsr}. Specifically, we adopt the power method~\cite{page1999pagerank} with the iteration times $L=100$ to compute the ground truth of PageRank. %Recall that the power method is an iterative method based on the definition formula of PageRank given in Equation~\eqref{eqn:def_pagerank}. In our experiments, we set the maximum iterations of power method as $100$ and fix the dampling factor $\alpha$ as $0.2$. 
Furthermore, on each dataset, we select $10$ query nodes from the vertex set $V$ uniformly at random. We fix the relative error parameter $c=0.1$ and run our \setpush for each query node. Then we compute the empirical relative error $c_{emp}$ for each query node following: 
%\begin{align*}
$c_{emp}=\frac{|\epi(t)-\vpi(t)|}{\vpi(t)}$. 
%\end{align*}
In Figure~\ref{fig:epsr}, we report the average of the values $\left(\frac{c_{emp}}{c}\right)$ over all query nodes. Note that $\left(\frac{c_{emp}}{c}\right) \le 1$ implies that the empirical relative error of \setpush meets the requirement of the $(c,p_f)$-approximation of $\vpi(t)$ (see Definition~\ref{def:problem} for the formal definition). From Figure~\ref{fig:epsr}, we observe that the empirical relative errors of \setpush on all datasets are consistently smaller than $c$. In particular, on the IC and OL datasets, the empirical relative errors of \setpush are smaller than $c$ by up to one or two order of magnitude. This demonstrates the correctness and query efficiency of our \setpush. 
%We vary $\e_r$ from $0.1$ to $10$





\review{\bf D9}: {\em Proofreading is needed for the paper. } 

\header{\bf Response: } Thanks for pointing out this! We made a careful proofreading of the paper as advised. 