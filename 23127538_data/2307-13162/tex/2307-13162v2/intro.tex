%\vspace{-2mm}
\section{Introduction} \label{sec:intro}
PageRank is first proposed by Google~\cite{page1999pagerank} to rank the importance of web pages in the search engine. It is formulated based on two intuitive arguments: (i) highly linked pages are more important than the pages with fewer links; (ii) the page that linked by an important page is also important. 
%Alternatively, 
{\rev If we convert the web structure to a graph, the PageRank scores of all pages in the web correspond to the probability distribution of simulating random walks on the graph. 
Specifically, consider a graph $G=(V,E)$ with $|V|=n$ nodes and $|E|=m$ edges. 
We select a node $s$ from the graph's vertex set $V$ uniformly at random, and simulate an $\alpha$-random walk from node $s$. The PageRank score of node $t\in V$ is equal to the probability that an $\alpha$-random walk simulated from node $s$ terminates at node $t$. Here we call $s$ the source node. %$\alpha$ {\em the teleport probability} or {\em the dampling factor}. 
$\alpha$-random walk refers to the random walk process that at each step (e.g., at node $u$), the walk either terminates at $u$ with probability $\alpha$, or moves to a randomly selected neighbor of $u$ with probability $1-\alpha$. We call $\alpha$ {\em the teleport probability} or {\em the damping factor}, which is a constant satisfying $\alpha \in (0,1)$. 
%Following the convention of PageRank studies, in this paper, we assume $\alpha$ is a constant and $\alpha \in (0,1)$. 
%Therefore, 
%We note that the probability that an $\alpha$-random walk passes by 
%is more likely to terminate at the nodes with large neighborhood sizes or important neighbors, or more precisely, the nodes with high graph centrality scores. 
}


%Over the last decade, PageRank~\cite{page1999pagerank}, first proposed by Google to rank web pages, has emerged as one of the most well-adopted measure of graph centralities. 

Over the last decade, PageRank has emerged as one of the most well-adopted graph centrality measure%due to its simplicity, generality, uniqueness, fast convergence and, of course, the success Google has achieved
~\cite{gleich2015beyondtheweb}. 
%Due to the simplicity, generality and uniqueness of the PageRank
%The simplicity and generality of PageRank's formulation make it be widely apopted in numerous applications, 
%The applications of PageRank has been far beyond its origin in web search, covering a wide range of research domains, such as social networks~\cite{kwak2010twitter}, recommender systems~\cite{boldi2008query}, databases~\cite{balmin2004objectrank}, as well as biology~\cite{morrison2005generank}, chemistry~\cite{mooney2012molecularnetworks}, neuroscience~\cite{zuo2012neuro} and etc. 
The applications of PageRank has been far beyond its origin in web search, covering a wide range of research domains, such as social networks, recommender systems, databases, as well as biology, chemistry, neuroscience and etc. 
%Here we just name a few examples. 
For example, in social networks, PageRank serves as a classic role in evaluating the centrality of individuals. Kwak et al.~\cite{kwak2010twitter} use PageRank to characterize the properties of Twitter. In recommender systems, the PageRank scores of items are adopted to find potential predictions~\cite{boldi2008query}. Moreover, for the problem of database queries, the PageRank score indicates a query direction to the frequently retrieved results, and thus accelerates the query efficiency~\cite{balmin2004objectrank}. Additionally, PageRank are adopted to study molecules in chemistry~\cite{mooney2012molecularnetworks}, gene in biology~\cite{morrison2005generank} and brain regions in neuroscience~\cite{zuo2012neuro}. More applications of PageRank can be found in the comprehensive survey summarized by Gleich~\cite{gleich2015beyondtheweb}. 

{\rev 
At the same time, a plethora of variants stem from PageRank, including Personalized PageRank~\cite{page1999pagerank}, heat kernel PageRank~\cite{chung2007heatkernelPageRank}, reverse PageRank~\cite{bar2008reversePageRank}, weighted PageRank~\cite{xing2004weightedPageRank} and so on. 
%many of which have been the subjects of extensive research. 
}
For example, Personalized PageRank, one of the most famous variant of PageRank, has been an essential node proximity metric adopted in various web search and representation tasks~\cite{gupta2013wtf, klicpera2019APPNP, Bojchevski2020PPRGo}. Recall that PageRank serves as a global centrality measure in a graph. In comparison, the Personalized PageRank value of a node indicates a localized score, reflecting the relative importance of the node with respect to a given source node. Likewise, the heat kernel PageRank has a successful history in the local clustering scenario. A series of algorithms~\cite{chung2007heatkernelPageRank, yang2019TEA, kloster2014heat} leverage the scores of Heat Kernel PageRank to identify a well-connected cluster around the given seed node. These variants and their wide-spread applications also demonstrate the prominence of PageRank in graph analysis and mining tasks. 

{\rev 
Given the huge success achieved by PageRank, the problem of computing PageRank scores has been the subject of extensive research for more than a decade~\cite{bressan2018sublinear, bar2008reversePageRank, fogaras2005MC, andersen2007contribution, lofgren2013personalized, lofgren2016BiPPR, lofgren2014FastPPR}. One particular interest is the problem of {\em single-node PageRank computation}, which aims to compute a single node's PageRank on large-scale graphs. Such problem is an important primitive in graph analysis and learning tasks of both practical and theoretical interest. 
%resulting in various meaningful solutions in multiply applications. Briefly speaking, the significance of efficiently estimating a single node's PageRank is two-fold. 

%\begin{itemize}
%\item %Estimating a single node's PageRank intrinsically corresponds to the problem of approximating a node's centrality score in the graph. In many cases, all we need is an approximation of the centrality scores of a few nodes. For example, we may hope to observe the changes in the global importance of a few popular websites (e.g., the top-10 most important websites ranked last year). Since websites' global importance can be reflected from their PageRank scores, in the case, we will frequently ask for the PageRank scores of the 10 websites. It would be prohibitively slow to score all nodes in the graph every time, especially on large-scale graphs with millions or even billions of nodes and edges. Therefore, an ideal solution is a {\em local} algorithm, which is able to efficiently return the target node's approximation scores by only exploring a small fraction of graph edges around the target node. However, as pointed out by~\cite{bressan2018sublinear}, most of existing approaches 
%One one hand, 
From the theoretical aspect, 
the query time complexity of single-node PageRank has a close connection to various graph analysis problems. For example, as we shall show in Section~\ref{sec:pre}, node $t$'s PageRank is equal to the average over all nodes $u$'s $\vpi_u(t)$, where $\vpi_u(t)$ denotes the Personalized PageRank (PPR) score of node $t$ with respect to node $u$. We call such problem single-target PPR queries, in which we aim to estimate  $\vpi_u(t)$ of every node $u\in V$. %Therefore, %the algorithms for single-target PPR queries are also applicable for single-node PageRank computation. %On the other hand, 
%can be used to compute the target node's PageRank. In such case, the query time complexity of single-target PPR determines that of single-node PageRank. On the other hand, 
%Thus, 
%And 
The theoretical insight for single-node PageRank computation can therefore be used for single-target PPR queries by definition. 
%Any improvement of the query efficiency of single-node PageRank also contributes to the complexity bound of single-target PPR queries. 
Moreover, 
%as mentioned in~\cite{wang2020RBS}, the complexity of single-target PPR queries is the bottleneck for estimating single-source SimRank scores in the graph, where SimRank is a well-adopted measure for node similarity. Thus, any improvement in single-node PageRank studies may the complexity of single-node PageRank computation, we can also optimize the performance of single-source SimRank algorithms. Additionally, 
Bressan et al.~\cite{bressan2018sublinear} propose a novel method called {\em \sublinear} for single-node PageRank computation, and adapt the \sublinear method to computing single-node Heat Kernel PageRank (HKPR) by leveraging the analogue between PageRank and HKPR. %All of the above demonstrate that the problem of single-node PageRank computation is a primitive of theoretical interest. 


On the other hand, in many practical cases, all we need is an approximation of a few nodes' PageRank scores. % (also pointed out in~\cite{bressan2018sublinear}). 
For example, in the application scenario of web search, the changes in the importance of a few popular websites (e.g., the top-10 most popular websites ranked last year) is of particular interest. Since websites' global importance can be reflected from their PageRank scores, the PageRank scores of the ten websites are therefore frequently requested. Note that it would be prohibitively slow to score all nodes in the graph every time, especially on large-scale graphs with millions or even billions of nodes and edges. Therefore, an ideal solution is a {\em local} algorithm, which is able to efficiently return the target node's approximation scores by only exploring a small fraction of graph edges around the target node. However, as pointed out by~\cite{bressan2018sublinear}, most of existing approaches require an $\Omega(n)$ time complexity for the single-node PageRank computation. %We also illustrate the limitations of existing methods in Section~\ref{sec:algorithm}. 
Designing an efficient local algorithm with $o(n)$ query time complexity remains a challenge. 

%In the past decade, we have been experiencing a huge ``Big Data" movement with the exponential blowup in data volumes. It is prohibitively unrealistic to compute all nodes' PageRank scores one at a time on .     


%and single-pair Personalized PageRank (PPR) queries, single-source SimRank computations, and single-node heat kernel PageRank computation. 

%have close connection of various ppr computation problem

%The problem of single-node PageRank computation has wide-spread applications in the area of local clustering~\cite{Teng2004Nibble}, and graph representation learning~\cite{klicpera2019APPNP}. 

%\end{itemize}

%The reasons are multi-fold. 



}

%In particular, the need of efficiently computing a single node's PageRank are now in ever-increasing demand driven by the exponential blowup of data volumes in modern network analysis. However, despite decades of efforts devoted to the problem, most of existing methods require an $\Omega(n)$ time complexity to approximate a single node's PageRank in the graph. In other words, designing a {\em local} algorithm for computing a single node's PageRank remains a challenging task. 

{\rev 
\header{\bf Single-Node PageRank Computation on Undirected Graphs. } Existing methods for single-node PageRank computation mainly focus on directed graphs, which, however, incur large query time complexity despite decades of efforts due to the hardness. In this paper, we settle for a slightly less ambitious target to efficiently estimate single-node PageRank {\em on undirected graphs}. Note that the problem of single-node PageRank computation on undirected graphs is still of great importance from both practical and theoretical aspects. Specific reasons are illustrated in the following. 
\begin{itemize}
\vspace{-1mm}
\item From the theoretical aspect, a number of existing algorithms do not offer any worst-case guarantee on directed graphs without considering a uniform random choice of the target node. For these methods, meaningful complexity bounds  can only be derived on undirected graphs when we consider an arbitrary target node (e.g., the LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR} methods as listed in Table~\ref{tbl:comparison}). 
%Note that the three methods, LocalPush~\cite{lofgren2013personalized}, FastPPR~\cite{lofgren2014FastPPR}, and BiPPR~\cite{lofgren2016BiPPR}, are originally proposed on directed graphs. However, they cannot offer the worst-case guarantee on directed graphs without considering a uniform random choice of the target node. 
%(as listed in Table~\ref{tbl:comparison}). 
%On the other hand, to our knowledge, the best complexity results achieved by existing methods on undirected graphs turn out to be the complexities of FastPPR, BiPPR and \sublinear. %(which one is the best determined by the specific values of $d, d_{\max}$ and $d_t$).
%However, the three methods are originally proposed on directed graphs, which reflects that existing methods do not make full use of the properties held by PageRank on undirected graphs. 
On the other hand, there are several crucial properties of the PageRank scores that are only held on undirected graphs. This motivates us %The two points mentioned above motivate us 
to study the problem of single-node PageRank computation specifically on undirected graphs for achieving better complexity results by utilizing these crucial properties delicately. 


\item Second, %To be more specific, we think the necessity to study the single-node PageRank computation problem on undirected graphs mainly come from two aspects. 
%from high scalability to compute single-node PageRank on large-scale undirected graphs. 
%For example, the canonical reverse exploration algorithm, LocalPush~\cite{lofgren2013personalized}, requires $O\left(n\cdot \left(\sum_{v\in V} \vpi_{v}(t)\cdot d_v\right)\right)$ time cost for estimating an arbitrary target node $t$'s PageRank on directed graphs. Such complexity can be rewritten as a meaning bound $O(n\cdot d_t)$ only on undirected graphs, by applying the property of PPR on undirected graphs: $\vpi_v(t) \cdot d_v = \vpi_t(v) \cdot d_t$. The same problem also holds in the hybrid methods, FastPPR~\cite{lofgren2014FastPPR} and BiPPR~\cite{lofgren2016BiPPR}, which include a reverse propagation phase in the algorithm. As a consequence, although these methods are originally proposed for single-node PageRank computation on directed graphs, their complexity bounds are only applicable to undirected graphs with an arbitrary target node. 
from the practical aspect, many downstream graph mining and learning tasks are only defined on undirected graphs. %All input directed graphs are required to be converted to undirected graphs. 
%For example, in the scenario of local clustering, the well-adopted {\em conductance} metric to measure the the quality of identified clusters is defined on undirected graphs. Thus, %most of (if not all) local clustering algorithms are only for undirected graphs. Among them, 
%all we need in local clustering tasks is the PageRank vector computed on undirected graphs.the celebrated local clustering method~\cite{FOCS06_FS} employ the Personalized PageRank vector computed on undirected graphs to find local clusters. 
%Moreover, Graph Neural Networks (GNNs) have drawn increasing attention in recent years. A plethora of GNN models leverage PageRank computation to propagate node features~\cite{klicpera2019APPNP, Bojchevski2020PPRGo,Chen2020GCNII}. Because the graph Laplacian matrix for feature propagation is only applicable to undirected graphs, this line of research invokes PageRank computation algorithms only on undirected graphs. 
For example, in the scenario of local clustering, the celebrated local clustering method~\cite{FOCS06_FS} employs (Personalized) PageRank vector to identify local clusters, while the well-adopted {\em conductance} metric to measure the quality of identified clusters is defined on undirected graphs. Therefore, in local clustering, all we need is the PageRank scores on undirected graphs. %most of (if not all) local clustering algorithms are only for undirected graphs. Among them,  
Additionally, Graph Neural Networks (GNNs) have drawn increasing attention in recent years. A plethora of GNN models leverage PageRank computation to propagate node features~\cite{klicpera2019APPNP, Bojchevski2020PPRGo,Chen2020GCNII}. Since the graph Laplacian matrix for feature propagation is only applicable to undirected graphs, this line of research invokes PageRank computation algorithms only on undirected graphs. 
\end{itemize}
}


% Figure environment removed


\begin{table*} [t]
%\vspace{-4mm}
\centering
\renewcommand{\arraystretch}{1.4}
%\begin{small}
\tblcapup
\caption{\rev Comparison of algorithms for solving the problem of single-node PageRank computation on undirected graphs under constant relative error and failure probability. $d$ and $d_{\max}$ denotes the average and maximum degree of graph $G$, respectively. The complexity results marked by $\star$ are only applicable on undirected graphs. 
%In the last column, we list the ratio of our \setpush's query time complexity to every baseline's time complexity. The smaller the ratio is, the larger improvement \setpush performs over the baseline method. 
}\label{tbl:comparison}
\vspace{-2mm}
%\resizebox{0.9\linewidth}{!}{%
%\resizebox{1\linewidth}{!}{
%\tblcapdown
%p{2.3in}
\begin{tabular} 
%{|l|p{2.3in}|} \hline
{|P{3.5cm}|c@{\hspace{+1mm}}|@{\hspace{+1mm}}c@{\hspace{+0.5mm}}|P{6.3cm}|} \hline
{\bf Query Time Complexity} & \multirow{2}*{\bf Baseline Methods} &  {\bf Query Time Complexities} & {\bf {Improvement of \setpush over Baselines}} \\ 
{\bf of Our \setpush} & & {\bf of Baseline Methods} & (the larger, the better) \\ \hline
%~& & & (the time) \\ \hline
\multirow{7}*{$\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right) \star$} & The Power Method~\cite{page1999pagerank} & $\tilde{O}(m)$ & $\max \left\{ m / d_t, \sqrt{m} \right\}$  \\  \cline{2-4}
& Monte-Carlo~\cite{fogaras2005MC} & $\tilde{O}(n)$ & $\max \left\{n/d_t,  \sqrt{n/\davg} \right\}$ \\ \cline{2-4}
%LocalPush~\cite{andersen2007contribution} & $\tilde{O}\left(n\cdot d_t\right)$ \\ \hline
& LocalPush~\cite{lofgren2013personalized} & $\tilde{O}\left(\min\left\{n\cdot d_t, m\right\}\right) \star$ & $\sqrt{m}$ \\ \cline{2-4}
&  RBS~\cite{wang2020RBS} & $\tilde{O}\left(n\right)$ & $\max \left\{n / d_t, \sqrt{n/\davg} \right\}$ \\ \cline{2-4}
& FastPPR~\cite{lofgren2014FastPPR} &  $\tilde{O}\left(\sqrt{n\cdot d_t}\right) \star$ & $\max \left\{\sqrt{n / d_t}, \sqrt{d_t / d}\right\}$ \\ \cline{2-4}
& BiPPR~\cite{lofgren2016BiPPR, lofgren2015BiPPRundirected} & $\tilde{O}\left(\sqrt{n\cdot d_t}\right) \star$ & $\max \left\{\sqrt{n / d_t}, \sqrt{d_t / d}\right\}$ \\ \cline{2-4}
%\rule{0pt}{14pt} Bressan-PageRank~\cite{bressan2018sublinear} & {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\Delta^{1/3}}{d^{1/2}}, \frac{m^{4/5}}{d^{3/5}} \right\}\right)$}\\[1ex] \hline
& \sublinear~\cite{bressan2018sublinear} & {\rev $\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{2/3}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$} 
& $\max \left\{\min \left\{\frac{n^{\frac{2}{3}}\cdot d_{\max}^{1/3}}{d_t}, \frac{n^{\frac{4}{5}} \cdot d^{\frac{1}{5}}}{d_t}\right\}, \min\left\{\frac{n^{\frac{1}{6}}\cdot d_{\max}^{1/3}}{d^{\frac{1}{2}}}, \frac{n^{\frac{3}{10}}}{d^{\frac{3}{10}}}\right\}\right\}$\\ \hline
%\rule{0pt}{14pt}$\mymathhl{\text{\setpush(Ours)}}$ & $\mymathhl{\tilde{O}(\min\left\{d_t, \sqrt{m}\right\})}$ \\[1ex] \hline
%& \setpush(Ours) & $\tilde{O}\left(\min\left\{d_t, \sqrt{m}\right\}\right)$ & \\ \hline
\end{tabular}
%}
\vspace{-3mm}
%\end{small}
\end{table*}

\vspace{-0.5mm}
{\rev
\header{\bf Limitations of Existing Methods on Undirected Graphs. } 
Below we briefly illustrate the limitations of existing methods for the single-node PageRank computation on undirected graphs. A simplified problem formulation is given as follows. A formal definition can be found in Section~\ref{sec:pre}.  
%Consider the problem of single-node PageRank computation on undirected graphs. 
Specifically, the inputs to the single-node PageRank problem are an undirected graph $G=(V,E)$ and a target node $t \in V$. The goal is to estimate the target node $t$'s PageRank $\vpi(t)$ within a constant relative error. 
%Let us quickly recap the problem of estimating a single node's PageRank score.  The inputs to the problem are a graph $G=(V,E)$ and a target node $t \in V$. The goal is to estimate the PageRank value of node $t$ within a constant relative error. 
%using a sublinear number of visits to the graph. 
%In other words, we aim to design a local algorithm which only needs $o(n)$ time for estimating the PageRank of a single node in the graph. %An exception can be the complete graph where each node connects to all the other nodes in the graphs. 
We also allow a constant failure probability for scalability. 
%Note that most of existing methods mentioned below are originally proposed on directed graphs, some of which concern a uniform random choice of the target node to derive meaningful complexity results. 
%We note that existing methods for single-node PageRank computation incur several limitations, and cannot achieve scalable complexity results even on undirected graphs. %We present a brief discussion on these limitations in the following. A detailed version can be found in Section~\ref{subsec:reasonswhy}. 
%Specifically, 
%Studies on this problem 
For the single-node PageRank computation problem, existing methods can be broadly classified into three categories: %It's worth to mention that most of existing methods mention below are proposed on directed graphs, and can be extended to support undirected graphs. 
\begin{itemize}
    \item \underline{The Monte-Carlo method}~\cite{fogaras2005MC, fogaras2003start, lofgren2016BiPPR} estimate $\vpi(t)$ by repeatedly simulating $\alpha$-random walks in the graph. However, according to the Pigeonhole principle, the lower bound of the required number of random walks is $\Omega\left(1/n\right)$. Thus, in the worse-case scenario where $\vpi(t)=O\left(1/n\right)$, the Monte-Carlo method requires at least $O(n)$ computational time for estimating a single node's PageRank. In Figure~\ref{fig:high_level}, we provide a toy example to illustrate the hard instance by regarding node $v$ as the given target node which satisfies $\vpi(v)=\Theta\left(1/n\right)$. %To derive an accurate estimate of $\vpi(v)$, we need to generate at least $O(n)$ random walks in the graph just for ensuring one of the random walks stepping at node $v$ (e.g., from node $u$ to node $v$). 

    \item \underline{The reverse exploration method} attempts to derive an estimate of $\vpi(t)$ by reversely exploring the graph from the target node $t$ to its ancestors. A primitive operation commonly adopted in these methods is {\em backward push}, which deterministically pushes the probability mass initially at the target node $t$ reversely to its ancestors step by step. %Sadly, a major drawback of the backward push operation is that it has to touch all neighbors of the current node for pushing the probability. 
    Unfortunately, in each backward push operation (e.g., at node $u$), we at least require $O(d_u)$ time to reversely push the probability mass currently at $u$ to every neighbor of $u$, where $d_u$ denotes the degree of node $u$. Thus, %conducting a backward push operation at a high-degree node $u$ is time-consuming. 
    in the worst case where $d_u=\Omega(n)$, we cost $O(n)$ time only after one step of backward push. 
    %cost $O(n)$ time per push operation for propagating the probability mass to every neighbor of $u$ if $u$ is a high-degree node with $d_u=\Omega(n)$. 
    Figure~\ref{fig:high_level} provides a toy example for this bad case where $d_u=\Theta(n)$. 
    
    %where node $u$ serves as the given target node. 

    \item \underline{The hybrid method} combines the Monte-Carlo method and the reverse exploration method together. However, a simple combination cannot resolve the limitations of the Monte-Carlo and reverse exploration methods as mentioned above. %Up to now, the state-of-the-art algorithm has been the \sublinear method proposed by Bressan et al.~\cite{bressan2018sublinear}, which achieves {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{1/2}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$} time. 
    In fact, despite years of efforts, the problem of computing single-node PageRank on undirected graphs has not been well solved. 
    %designing local algorithm for single-node PageRank computation remains a challenging problem despite years of efforts. 
%We list the time complexities of these existing methods in Table~\ref{tbl:comparison}. 
%As a summary, designing local algorithm for single-node PageRank computation remains a challenging problem despite years of efforts. 

    %according to the settings of backward push operation, in the 
    %Therefore, for the nodes with large node degrees (e.g., node $u$ as shown in Figure~\ref{fig:high_level} that $d_u=O(n)$), the reverse exploration methods have to take up $O(n)$ time just for one backward push operation. 
\end{itemize}

%The expected time cost for deriving an estimator of $\vpi(t)$ within constant relative error turns out to be $O(n)$ in this case. 
}
%To compute the PageRank score of the given target node, %existing methods can be broadly classified into four categories: the Monte-Carlo methods, the reverse exploration methods and the 
%a set of methods~\cite{fogaras2005MC, fogaras2003start, lofgren2016BiPPR} propose to 

%Additionally, another line of research (e.g., the seminal method, LocalPush~\cite{lofgren2013personalized}) attempts to derive the estimator of a single node's PageRank by reversely exploring the graph from the target node to its ancestors. A primitive operation commonly adopted in these reverse exploration methods is {backward push}, which pushes the probability mass initially at the target node backward to its ancestors step by step. Sadly, a major drawback of the backward push operation is that it has to touch all neighbors of the current node for pushing the probability. Therefore, for the nodes with large node degrees (e.g., node $u$ as shown in Figure~\ref{fig:high_level} that $d_u=O(n)$), the reverse exploration methods have to take up $O(n)$ time just for one backward push operation. 

%A recent trend of algorithms (e.g., BiPPR~\cite{lofgren2016BiPPR}, RBS~\cite{wang2020RBS} and \sublinear~\cite{bressan2018sublinear}) for single-node PageRank computations is to combine the Monte-Carlo and reverse exploration methods together. However, these methods still suffer from the limitations introduced by the Monte-Carlo and reverse exploration methods mentioned above. %Up to now, the state-of-the-art algorithm has been the \sublinear method proposed by Bressan et al.~\cite{bressan2018sublinear}, which achieves {$\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{1/2}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$} time. 
%We list the time complexities of these existing methods in Table~\ref{tbl:comparison}. 
%As a summary, designing local algorithm for single-node PageRank computation remains a challenging problem despite years of efforts. 

%Thus, a bad case for this link of research is to compute the PageRank score approximating equals to $\frac{1}{n}$. 


%in this problem, we aim to efficiently estimate a single-node's PageRank with the desired approximation accuracy (e.g., a relative error). 

%a long-term research focus, attracting extensive 
%Extensive research has been devoted to this problem for more than a decade

%and the blowup in data volumes of modern web tasks, the computation efficiency of single-node PageRank has become a long-term research focus. 


%\subsection{Motivations}
%In this paper, we consider a fundamental problem in modern network analysis: estimating a single node's PageRank on undirected graphs with constant relative error. Driven by the success achieved by PageRank and the blowup in data volumes of modern web tasks, the computation efficiency of single-node PageRank has become a long-term research focus. %attracting long-term attention for more than a decade~\cite{bressan2018sublinear, bar2008reversePageRank, fogaras2005MC, andersen2007contribution, lofgren2013personalized, lofgren2016BiPPR, lofgren2014FastPPR}.


%The problem serves as a cornerstone task in various practical scenarios, and has a history dating back over a decade. Extensive research has been devoted to this problem with a goal 
%design such local algorithm for more than a decade

%PageRank computation: Additionally, we allow a constant failure probability for achieving the desired accuracy. Note that the problem of estimating single-node PageRank serves as a cornerstone role 

%To solve this problem, an ideal solution is a {\em local} algorithm, which only needs $o(n)$ time for estimating the PageRank of a single node in the graph. An exception can be the complete graph where each node connects to all the other nodes in the graphs. %Actually, Bressan et al.~\cite{bressan2018sublinear} prove the lower bound of this problem is 

%Aimed at the problem, extensive research has been devoted to design such local algorithm for more than a decade
%This history of estimating single-node PageRank efficiently dates back over a decade
%~\cite{bressan2018sublinear, bar2008reversePageRank, fogaras2005MC, andersen2007contribution, lofgren2013personalized, lofgren2016BiPPR, lofgren2014FastPPR}. However, finding truly sublinear algorithm remains a challenging problem 

%The problem of single-node PageRank computation has a history 

%Among existing methods, two basic operations, Monte-Carlo based random walk simulation and backward push, serve as cornerstone parts in these algorithms. 

%However, the two techniques are often impractical, especially in some special cases as shown in Figure~\ref{fig:high_level}. 






\vspace{-1mm}
%limitations of existing methods 
\subsection{Our Contributions}\label{subsec:contribution}
%\header{\bf {\rev Our Contributions.} }
{\rev 
In this paper, we consider the problem of single-node PageRank computation {\em on undirected graphs}. We propose a novel algorithm called \setpush, which achieves %the best complexity result among existing methods on undirected graphs. 
%a better time complexity compared to the best result of existing methods applicable on undirected graphs. 
%To be more specific, \setpush 
%for estimating single-node PageRank on undirected graphs. Our \setpush is the first algorithm which 
%achieves a 
the $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$ query time complexity for the single-node PageRank computation under constant relative error and failure probability. Here $m$ denotes the number of edges in the graph, $d_t$ denotes the degree of the given target node $t$. Additionally, $\tilde{O}$ is a variant of the Big-Oh notation that ignores poly-logarithmic factors~\cite{bressan2018sublinear, wang2020RBS, teng2016scalable}. %Additionally, we shall use $d$ and $d_{\max}$ (in Tabl) to denote the average and maximum degree of graph $G$, respectively. 
%Note that $\tilde{O}$ is a commonly adopted notation in theoretical analysis~\cite{bressan2018sublinear, wang2020RBS}, which was first proposed by Teng~\cite{teng2016scalable}.  
%In the following, we summarize three 
Detailed contributions achieved by this paper are summarized as below. 
\begin{itemize}
\vspace{-1mm}
\item \header{\bf Theoretical Improvements. } 
We theoretically demonstrate the superiority of our \setpush over existing methods on undirected graphs. 
%We now specify the superiority of our \setpush over existing methods on undirected graphs. %As shown in Table~\ref{tbl:comparison}, we list the theoretical improvement of \setpush over existing methods
Specifically, %in Table~\ref{tbl:comparison}, 
%our \setpush outperforms the basic Power Method by $\max\left\{\frac{m}{d_t}, \sqrt{m}\right\}$, and outperforms the Monte-Carlo method by $\max\left\{\frac{n}{d_t}, \sqrt{\frac{n}{d}}\right\}$. 
%we list the complexity results of our \setpush and existing methods to solve the problem of single-node PageRank computation on undirected graphs. It's worth to mention that the complexity results of FastPPR, BiPPR, LocalPush and our \setpush are only applicable to undirected graphs, while the complexity of the other methods hold both on directed and undirected graphs. The notation $d$ and $d_{\max}$ refer to the average and maximum degree of graph $G$, respectively. In particular, 
in the last column of Table~\ref{tbl:comparison}, we present the theoretical improvements of our \setpush over existing methods. In particular, the value of ``Improvement" equals the query time complexity of a baseline method over that of our \setpush. Thus, the value of ``Improvement" is the larger, the better. It's worth mentioning that the complexity results of FastPPR, BiPPR, LocalPush and our \setpush given in Table~\ref{tbl:comparison} are only applicable to undirected graphs, while the other complexities hold both on directed and undirected graphs. 
%From Table~\ref{tbl:comparison}, we have several observations: 
%In Table~\ref{tbl:comparison}, we list the time complexities of existing methods for single-node PageRank computation. 
%\begin{itemize}
%    \item 
We observe that the expected time complexity of our \setpush is no worse than that of each baseline method listed in Table~\ref{tbl:comparison}. %due to the fact $m=n\cdot d$, $d_{\max}\le n$ and $d_t \le n$. The notation $d$ and $d_{\max}$ refer to the average and maximum degree of graph $G$, respectively. 
Actually, except on a compete graph where the average node degree $d=n$, the time complexity of our \setpush is asymptotically better than that of every method listed in Table~\ref{tbl:comparison}. 
%In other our \setpush significantly outperforms existing methods.
    
    %\item The three hybrid methods given in Table~\ref{tbl:comparison} (i.e., FastPPR~\cite{lofgren2014FastPPR}, BiPPR~\cite{lofgren2016BiPPR} and \sublinear~\cite{bressan2018sublinear} ) outperform the Monte-Carlo method~\cite{fogaras2005MC} and the reverse exploration method (i.e., LocalPush~\cite{lofgren2013personalized} in Table~\ref{tbl:comparison}) in terms of query time complexity. This demonstrates the effectiveness of combining Monte-Carlo simulation and backward push together. Nonetheless, our \setpush still achieves a superior complexity over all of the three hybrid methods. 
    
    
    %The time complexity achieved by the \sublinear method~\cite{bressan2018sublinear} was the best result for single-node PageRank computation before our \setpush. We note that our \setpush improves over 
    
    %our \setpush, the best result is achieved by the \sublinear method~\cite{bressan2018sublinear} with the time complexity of {\rev $\tilde{O}\left(\min\left\{\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{2/3}}, \frac{m^{4/5}}{\davg^{3/5}} \right\}\right)$}, where $\davg$ and $\dmax$ correspond to the average and maximum node degree of the graph. Note that $m=n\cdot \davg$, $\dmax\ge \davg$, and thus our bound is asymptotically better than that of \sublinear since $\frac{m^{2/3}\cdot \dmax^{1/3}}{\davg^{1/2}}\ge \frac{m^{2/3}}{\davg^{1/6}}=m^{1/2}\cdot n^{1/6}$ and $\frac{m^{4/5}}{\davg^{3/5}} \ge \davg^{1/5} \cdot n^{4/5} \ge d_t$. 
    
    %\item We observe that our \setpush improves the Monte-Carlo method and the RBS method by a factor of at least $\sqrt{\davg/n}$, improves the LocalPush method by a factor of $1/\sqrt{m}$, and improves the two hybrid methods, BiPPR and FastPPR by a factor of $\sqrt{d_t/n}$. We also present a detailed descriptions on the limitations of existing methods and analyze why they cannot achieve the bound of $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$. 
%\end{itemize}



%\header{\bf Superiority of \setpush on Undirected Graphs. } 
\item \header{\bf A Novel Push Operation. } 
%We will elaborate on the reasons why existing methods are unable to achieve the complexity $\tilde{O}\left(\min \left\{d_t, \sqrt{m}\right\}\right)$ of \setpush on undirected graphs in Section~\ref{subsec:reasonswhy}. At a high level, 
%The superiority of \setpush over existing methods mainly comes from two aspects: 
%\begin{itemize}
%\item We propose a novel push operation,     
The core of our \setpush is a novel push operation, 
which simultaneously mixes the deterministic backward push and randomized Monte-Carlo sampling in an atomic step. Benefit from this push operation, we cost $\Theta(d_u)$ time only at the node $u$ with small $d_u$, and randomly sample a fraction of $u$'s neighbors to push probability mass if $d_u$ is large. As a result, we successfully remove the $O(d_u)$ term introduced by the vanilla push operation at node $u$, and achieve a superior time complexity over the baseline method. 
%in each push operation (e.g., at node $u$) adopted in \setpush, we do not always need to touch every neighbor of $u$, which successfully reduces the $O(d_u)$ term introduced by the vanilla push operation. 
%Benefit from the independence of the sampling operation adopted in our \setpush, the variance of \setpush can be bounded by a surprising simple form, which, though, needs to be derived through non-trivial theoretical analysis.  Finally, we conduct experiments on large-scale real-world graphs to demonstrate the effectiveness of the \setpush method. 

%\item 

\item \header{\bf Algorithm Development on Undirected Graphs. } Our \setpush algorithm is designed specifically on undirected graphs. We show that by making full use of the theoretical properties held by PageRank values on undirected graphs, we can achieve a better time complexity for single-node PageRank computation compared to existing methods on undirected graphs. %Briefly speaking, we note that on undirected graphs, it is no longer necessary to simulate $\alpha$-random walks from a uniformly selected source node $s$. Thus, we can break the lower bound $O\left(\frac{1}{\vpi(t)}\right)$ of the Monte-Carlo method, and achieve a superior complexity result compared to the Monte-Carlo method. 
\end{itemize}







%It's worth to mention that only considering the problem of single-node PageRank on undirected graphs


%the complexity results of FastPPR, BiPPR, LocalPush and our \setpush are only applicable to undirected graphs, while the complexity of the other methods hold both on directed and undirected graphs. 




%\end{itemize}

}







%\header{\bf Theoretical Improvements over Existing Methods. } 




%\header{\bf Technical Novelty of \setpush. } 




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
