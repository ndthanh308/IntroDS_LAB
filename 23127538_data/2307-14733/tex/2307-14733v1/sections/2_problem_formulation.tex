\section{Motivating Example \& Problem Formulation}\label{sec:problem-formulation}

In this section, we leverage the example in Listing~\ref{lst:stubbing-example} to illustrate how we formulate and address the problem of stub code generation and repair for unit tests.

\subsection{Formulation of Unit Test Cases}
Unit test cases are commonly executed in three phases, following the AAA pattern~\cite{DBLP:conf/icsm/YuTA19} \ie{Arrange, Act, Assert}.
First, the Arrange phase sets up the test environment, which includes the setup of dependencies with mock objects.
Next, the Act phase exercises the CUT by invoking its methods.
Finally, the Assert phase checks whether the CUT produces the expected test outputs.

We represent a test case as a tuple \( \tau = \langle V, S, E, A \rangle\).
Such representation is in line with the AAA pattern:
\begin{itemize}
	\item \textbf{Arrange Phase:}
	      \(V\) is the set of variables that are used in \(E\) and \(A\), and \(S\) is the stub code that specifies the behaviors of mock objects in \(V\).
	\item \textbf{Act Phase:}
	      \(E\) represents the bytecode instructions that exercise the CUT.
	\item \textbf{Assert Phase:}
	      \(A\) is the test oracle, including mocking calls.
\end{itemize}

Take the test case in Listing~\ref{lst:stubbing-example} as an example.
\(V\) contains two mock objects \code{dao} and \code{user} (Lines~\ref{code:stubbing-example:arrange-begin}--\ref{code:stubbing-example:extra-mock}).
\(S\) contains the stub code (the highlighted region) that sets up the behavior of the mock objects in \(M\).
For example, Lines~\ref{code:stubbing-example:stubbing-begin}--\ref{code:stubbing-example:stubbing-dao} set the behavior of \code{dao} and specify that its method \code{getPasswordHash} should return the SHA-1 digest of string \code{"bar"}.
\(E\) contains Lines~\ref{code:stubbing-example:act-begin}--\ref{code:stubbing-example:act-end} that exercise the login function of the CUT \code{LoginService}.
\(A\) contains Lines~\ref{code:stubbing-example:assert-begin}--\ref{code:stubbing-example:assert-end}, which check whether the login function performs as expected using a mocking call (Line~\ref{code:stubbing-example:assert-begin}) and a \junit{} assertion (Line~\ref{code:stubbing-example:assert-end}).

\subsection{Problem Statement}\label{ssec:problem-statement}
% Figure environment removed
Following our formulation of unit test cases, we define our stub code synthesis problem in two application scenarios.

\paragraph{Scenario \#1: Generation Mode.}
Given an incomplete test case \(\tau = \left\langle V,\varnothing, E, A\right\rangle \) without stub code, generate \(S\) such that \(\testTuple \) passes~\ie{all the oracle assertions in \(A\) pass without uncaught exceptions}.

In this scenario, our technique helps developers to develop test cases that are independent of their test dependencies.
For example, in Listing~\ref{lst:stubbing-example}, we can synthesize the stub code in the highlighted region given the remaining lines such that the oracle assertions at Line~\ref{code:stubbing-example:assert-begin} and Line~\ref{code:stubbing-example:assert-end} hold.
When developers are creating a new test case, they can simply instantiate the CUT with mock dependencies and finish the remaining parts without needing to consider the possible interactions between the CUT and the dependencies.
After that, they can launch \tool{} to synthesize the stub code to complete the test case.
We target at regression testing in this scenario, where we assume that the current system is correct and try to capture regressions in future versions.

\paragraph{Scenario \#2: Repair Mode.}
Given an obsolete test case \(\tau = \left\langle V, S_{bk}, E, A\right\rangle \) containing broken stub code \(S_{bk}\), synthesize \(S\) to replace \(S_{bk}\) such that \(\testTuple \) passes.

In this scenario, our technique helps developers to repair test cases whose stub code is broken due to program or library changes.
For example, when the stub code in the highlighted part is broken because of code updates in \code{User}, \code{UserDao}, or \code{LoginService}, developers can specify the code lines that contain the broken stub code and \tool{} can replace the broken stub code with a synthesized one that can be compiled and can make the test pass.
Compared with scenario \#1, which synthesizes stub code from scratch, we leverage the information in the broken stub code \(S_{bk}\) to guide the synthesis in scenario \#2.
In this scenario, we target at the repair the stub code that are broken dur to refactoring or library upgrades.
It need developers to decide whether the stub code needs to be repaired.

\medskip{}
In both modes, \tool{} can be implemented as an IDE plugin.
In generation mode, developers can place the cursor at where the stub code needs to be generated.
In repair mode, developers can select the obsolete stub code that needs to be repaired.
Developers can place the cursor at where the stub code need to be generated or selecte the obsolete stub code that need to be repaired.
After that, they can launch \tool{} via a menu item provided by the plugin.
The stub code is synthesized to facilitate regression testing based on the current program version.
The test case with synthesized stub code captures the implemented behavior of the CUT, and helps to detect regression bugs in future versions of the CUT.
It is important to clarify that \tool{} does not guarantee the semantic equivalence between the synthesized stub code and developer-written stub code.
In the context of mocking, the stub code helping the test case achieving the same adequacy may not need to be syntactically or semantically similar.
As an example, Listing~\ref{lst:benchmark-36rep} shows the stub code written by developer and synthesized by \tool{}.
First, the developer-written stub code and the synthesized stub code are syntactically different.
The developer-written stub code is using the API \code{when(...).thenReturn(...)} while the synthesized stub code is using the API \code{doReturn(...).when(...)}.
Also, the semantics of the two stub codes are not exactly the same.
The developer-written stub will return \code{"/actuator/health"} only when the method \code{getPath} is invoked with an argument \code{"health"} while the synthesized stub code will return \code{"/actuator/health"} when the invocation is done with any argument.
Although they are neither syntactically nor semantically the same, the test cases with both stub codes execute exactly the same set of instructions, traverse exactly the same execution paths, and kill exactly the same set of mutants as shown in our evaluation (Table~5).
This is because in that test case, the method \code{getPath} will only be invoked with argument \code{"health"}.
In other words, the two stub codes are semantically equivalent in the context of that specific test case.

Indeed, \tool{} has available only the CUT executions \(E\) and assertions \(A\) to guide the generation and repair of stub code.
Such available information is unlikely to be a complete specification of the behavior of the test.
However, assertions should predicate of the salient expected behaviours of the test that makes the test pass or fail.
In our evaluation (Section ~\ref{sec:rq4}), we conjecture that obtaining stub code that fulfills such behaviors \ie{it makes the assertions pass} would be enough to achieve the same (or similar) test adequacy with the ground-truth stub code.


\subsection{Technical Challenges}\label{ssec:technical-challenges}

It is challenging to synthesize a stub code, say \(\mathcal{S}\), to pass an input test \(\tau\) due to the huge search space of possible candidates that can be generated for \(\tau\).
This is because a stub code candidate is free to stub any method of any mock object in \(M\) for an arbitrary number of times, and to return any value or throw any exception for each stub call.
Even by bounding the number of lines of code of the generated stub code (50 in our experiments), the search space is too huge to exhaustively explore.
However, only specific stub code \(\mathcal{S}\) can make \(\tau\) pass.
\(\mathcal{S}\) should stub the correct set of methods with proper values so that \(E\) executes without exceptions and all the constraints in \(A\) are satisfied.
Take the test case shown in Listing~\ref{lst:stubbing-example} as an example.
Lines~\ref{code:stubbing-example:act-begin}--\ref{code:stubbing-example:act-end} create a \code{LoginService} object with mock object \code{dao} and invoke \code{login} method with username ``foo'' and password ``bar''.
The test case passes only when satisfying two oracle assertions: (1) the \code{findUser} method is called twice (the mocking call at Line~\ref{code:stubbing-example:assert-begin}), and (2) the \code{loginResult} returned by \code{login} is successful (the assert statement at Line~\ref{code:stubbing-example:assert-end}).
Lines~\ref{code:stubbing-example:cut-begin}--\ref{code:stubbing-example:cut-end} show the implementation of the \code{login} method.
In this method, \code{dao.findUser} will be called twice only if it throws a \code{TimeoutException} when it is first called (executing Line~\ref{code:stubbing-example:catch}), and returns a \code{User} object when it is called for the second time (breaking the loop at Line~\ref{code:stubbing-example:loop}).
The \code{LoginResult} will be successful only if the \code{getPasswordHash} of the \code{User} object returns the SHA-1 checksum of password ``bar'' (passing the condition at Line~\ref{code:stubbing-example:hash-check}).
Lines~\ref{code:stubbing-example:stubbing-begin}--\ref{code:stubbing-example:arrange-end} show the specific stub code that makes the pass.

It is infeasible to identify the test-passing stub code \(\mathcal{S}\) by randomly or systematically exploring all the possible stub code candidates.
To address this problem, we propose to use an evolutionary algorithm to guide the synthesis of the stub code and search for \(\mathcal{S}\).


\paragraph{Key Idea.}
The evolutionary algorithm searches for the test-passing stub code \(\mathcal{S}\) by generating new candidate stub code via crossover and mutations of existing ones in a guided manner.
It guides the search by a fitness function that evaluates the distance between an arbitrary \(S\) and a passing stub code.
As discussed in Section~\ref{ssec:problem-statement}, \(\mathcal{S}\) is the set of stub code that can pass \(\tau\).
In other words, the stub code should (1) make the code in \(E\) executable, and (2) satisfy all oracle assertions in \(A\).
Based on this observation, we propose a multi-objective fitness function: with an arbitrary \(S\), we integrate it with \(\tau\) and capture
(1) the percentage of bytecode instructions in \(E\) that can be successfully executed, and (2) the percentage of oracle assertions in \(A\) that can be satisfied, and (3) the distance between the value outputted by \(S\) and its expected value for an unsatisfied oracle assertion.
Intuitively, \(S\) is closer to pass \(\tau\) if it can make more bytecode instructions in \(E\) executable, satisfy more oracle assertions in \(A\), and for the unsatisfied oracle assertions, the outputted value is closer to the expected value.
