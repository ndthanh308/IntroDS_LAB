\section{Conclusions and Future Work}\label{sec:conclusion}
Mocking is an essential part of unit testing, as it allows testing a CUT in isolation from its dependencies~\cite{DBLP:conf/kbse/ZhuWWLCSZ20,DBLP:journals/ese/SpadiniABB19}.
Mocking frameworks allow developers to write stub code to specify the behaviors of test dependencies when a test case invokes the CUT.
However, developing and maintaining stub code is a labor-intensive and error-prone activity~\cite{DBLP:journals/ese/SpadiniABB19}.

In this paper, we present \tool{} to automatically generate and repair stub code for regression tests.
\tool{} is based on the intuition that the feedback given by the runtime behavior of a test case can drive the synthesis of stub code.
In particular, \tool{} implements an evolutionary algorithm guided by a fitness function that measures how close a candidate stub code is to pass the test.

Our evaluation on \numOfBenchmarkEntries{} test cases from \numOfBenchmarkProjects{} open-source projects shows that \tool{} effectively synthesizes stub code.
Moreover, \tool{} outperforms its unguided variant, demonstrating the usefulness of the fitness function to steer the search towards generating test-passing stub code.
Also, our results show that \tool{} synthesizes stub code with similar behaviors as those written by developers.

To the best of our knowledge, \tool{} is the first technique of its kind.
There are several possible future work in this area.
We point out the two most promising ones.

First, a possible future work to improve \tool's effectiveness is to mine existing stub code in GitHub to learn recurrent patterns of stub calls.
Indeed, different software projects often share the same libraries as test dependencies.
Although stub code is test case specific, such recurrent patterns might help explore the search space more efficiently.
For instance, the mutation operators of \tool{} could give a higher probability to those mutations that match one of the mined recurrent patterns.

Second, some automated test generation techniques rely on mock objects to increase test coverage~\cite{DBLP:conf/icst/ArcuriFJ17,DBLP:conf/dagstuhl/AlshahwanJLFST10}.
However, such techniques do not explore the possible behaviors of mock objects during test generation.
This is because they models each mock object and their stub calls as a single mutation unit.
In this case, they cannot mutate each of the stub calls separately.
In comparison, \tool{} models the behavior of the stub code at a finer-grained level: it models each of the stub call as a mutation unit, and thus can explore more possible behaviors of mock objects.

The integration of such techniques and \tool{} will enable finer control on the behavior of mock objects and thus achieve higher test coverage.
