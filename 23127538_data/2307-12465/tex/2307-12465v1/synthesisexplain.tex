%\naman{The discussion about anti-unification would go in related work I presume?}

Given this high-level \dsl, we will now describe our example-based synthesis algorithm. 
We take as input a set of unsafe programs and edits generated as output at the end of data collection step (Section~\ref{sec:data}). 
Let $\{(\prog_{1},\edit_1),(\prog_{2},\edit_2),\dots$ $,(\prog_{n},\edit_n)\}$. 
Here, $\prog_{i}$ is the $i^{th}$ unsafe program and $\edit_i$ is the corresponding edit. Edit ($\edit$) contains the \astree-node of the edit-location ($\edit$.loc), the \textit{concrete} \astree of the edit-program ($\edit$.editprog), and the type of edit i.e. \insertsc or \replace ($\edit$.type). We use these to learn high-level repair strategies in our \dsl. 
\lstMakeShortInline[columns=fixed]@
Our goal is to combine specific paths, learned over examples that share similar repairs in different semantic and syntactic contexts, to obtain general strategies. Our repair strategies abstractly learn the following:
% \begin{enumerate}
%     \item the traversal for localizing edit-locations (\editloc) and reference-locations (\refloc). 
%     \item template-repair-program-representations using the reference-traversals . 
% \end{enumerate}
\begin{enumerate}
    \item Traversals for localizing edit-locations (\editloc) and reference-locations (\refloc). For example, @Ls@ in Line~\ref{lst:line:semkleene} (Strategy \strategyone) depicts a \T{KleeneTraversal} abstraction we can learn from examples having a variable number of semantic-edges. Similarly, @I@ in Line~\ref{lst:line:offseteditindex} (of \strategyone) depicts a generalized index expression we can learn from examples.
    \item \eastree which use reference-traversals. For example, @O@ in Line~\ref{lst:line:goodstratO} demonstrates templated-program-structure that we can learn from examples (say by generalizing from the witnessed guards @handlers.has(data)@  and @events.storage.has(event.name)@).
\end{enumerate}
\lstDeleteShortInline@


% In particular, we wish to abstract over examples that share similar repairs in different semantic or syntactic contexts. Consider the example abstractions below: 
% \begin{enumerate}
%     \item  
%     \item Line~\ref{lst:line:eastree} in Figure~\ref{fig:strat1} depicts 
%     the guard condition in Figure~\ref{fig:safememberex} @handlers.hasOwnProperty(data.id)@ can be abstracted with another guard @eventHandlers._storage.hasOwnProperty(event.name)@ into an abstract template @REF1.hasOwnProperty(REF2)@ where @REF1@ and @REF2@ are \T{ReferenceAST} have use traversals
% \end{enumerate}
% For example, . 
%Consider the example in Figures~\ref{fig:static-witnessing-1},~\ref{fig:static-witnessing-2}, and ~\ref{fig:static-witnessing-3}. They describe three different kinds of syntactic repairs and are not candidates to merge. Instead, 

We depict our synthesis algorithm in Figure~\ref{fig:strategy-learning}. At a high-level, our synthesis algorithm, first pre-processes the inputs, storing the required \textit{concrete} traversals. Next, it performs ranked pair-wise merging over the processed edits to synthesize strategies.
%We merge non-terminals recursively by deductively choosing production rules to enumerate and merging the non-terminals appearing in the productions. %During this recursion, it learns the \textit{traversals} and program templates abstractly. 

\noindent \textbf{Pre-processing.} In this step, given the programs and edits, we store the concrete traversals required for learning \editloc and \refloc (Line~\ref{algo:line:preprocess}). Naively computing all such traversals is very expensive and also leads to \textit{bad strategies}. Here, based on the insights from Section~\ref{subsec:examples}, we only compute the traversals that lead to shorter  
traversals
%\textit{abstract traversals}
which generalize better. In addition, we also share traversals between between \editloc and \refloc. Pre-processing has following three key steps:
\begin{enumerate}
    \item \textbf{Edit Traversals.} We compute the traversals between \prog.source and \editloc (Line~\ref{algo:line:conceditloc} of Figure~\ref{fig:strategy-learning}) that have the form of a sequence of semantic-edges followed by a sequence of syntactic-edges. This allows abstracting variable-length sequences of semantic-edge traversals as a \kleeneedge (corresponding to an abstract \newtextsc{KleeneTraversal}). We implement this using \newtextsc{BiDirecBFS} method at Line ~\ref{algo:line:bidirecbfs}. For every edit-traversal ($\I{T}_e$), we define {\em semantic-location} (\semloc for brevity) as the last-node on the semantic (dataflow) traversal before traversing the syntactic-edges.
    \item \textbf{Compressing Edit Traversals.} We compress these edit-traversals using the \newtextsc{Compress} method in Line~\ref{algo:line:compress}. It takes in a sequence of (syntactic or semantic) edges as input, greedily combines the consecutive edges with the same edge-type (\edgetype) into a \kleeneedge. The \kleeneedge is constructed using the edge type \edgetype, and a set of clauses $\clause_i$ that satisfy the target node of \kleeneedge. These clauses are either $\lambda n. \mathcal{T}(n) = \tau$ that check the type  or $\lambda n. \mathcal{T}(F_i(n)) = \nu$ that check the type of a neighbor. \newtextsc{Compress} returns a sequence of edges or \kleeneedges as output. 
    \item \textbf{Reference Traversals.} For every node of the edit-program, we locate nodes in the \pdg with the same \textit{value} using a \newtextsc{LevelOrderBFS} until a max-depth (Line~\ref{algo:line:maxlevel}). We perform this traversal from \semloc (defined in (1) above). We thus share parts of traversals between locating \editloc and \refloc which helps in learning \textit{better strategies}. The motivation behind using \semloc is that the expressions necessary for repair will be close to \semloc as it lies on the information-flow path. 
\end{enumerate}
%Specifically, for \editloc, we find the traversals between \prog.source and \editloc (Line~\ref{algo:line:conceditloc}) that first navigate a set of semantic-edges followed by a set of syntactic-edges. We implement this using the \newtextsc{BiDirecBFS} function at Line ~\ref{algo:line:bidirecbfs}. %It traverses semantic-edges from the source, syntactic-edges from the edit-location, and returns the intersecting traversals. 
%For every edit-traversal ($\I{T}_e$), we define semantic-location (\semloc for brevity) as the last-node on the semantic (dataflow) traversal before navigating a syntactic-edge. 
%Next, we compress the traversals greedy by combining consecutive edges of the same edge-type (\edgetype) into a \kleeneedge using the \newtextsc{Compress} method in Line~\ref{algo:line:compress}. Every \kleeneedge stores the \edgetype, and a set of clauses $\clause_i : i \in {1,\dots,n}$ that satisfy the end-node of \kleeneedge. These clauses are either $\lambda n. \mathcal{T}(n) = \nu$, i.e. a clause on the type of \semloc or $\lambda n. \mathcal{T}(F_i(n)) = \nu$, i.e. a clause on the type of a syntactic-neighbour of \semloc. We then compute traversals for finding reference locations. Here, instead of computing traversals from the source-node, we instead compute traversals from the semantic-locations. The expressions referenced in repairs are usually close to the \semloc (as it lies on the information-flow path and thus is affiliated with variables likely necessary for building the repair). This traversal-sharing optimizes the search and generalization of our strategies.

\noindent \textbf{Strategy Synthesis.} Given the edits and the associated traversal meta-data, we synthesize the strategy by pair-wise merging  (Line~\ref{algo:line:callmerge}). \newtextsc{MergeEdits}, the top-level synthesis method, takes a pair of edits as inputs and returns a list of strategies satisfying the example edits. We synthesize the strategies recursively using a deductive search over the non-terminals of the DSL (Figure~\ref{fig:fixing-dsl}). Specifically, to synthesize an expression corresponding to a non-terminal, we deduce which production to use and recursively synthesize the non-terminals given by its production-rule. This has the following key components: 
\begin{enumerate}
    \item \newtextsc{MergeEdits}: It takes pairs of edits as inputs and returns the strategy. It recursively synthesizes the traversal (for \editloc), index, and \eastree. It combines and returns them using the edit-type. 
    \item \newtextsc{MergeTraversal}: It takes two concrete traversals (sequence of edges or \kleeneedges) as inputs and returns the abstracted traversal. by merging elements in the sequence.
    \item \newtextsc{MergeEdge}: It takes two edges or \kleeneedges as inputs and returns a \T{GetKleeneTraversal} or \T{GetEdgeTraversal}. We combine two \kleeneedges using their edge-types and intersecting the clauses stored during pre-processing. We combine two edges using their edge-types, and recursively combining their indices.
    \item \newtextsc{MergeIndex}: It takes two integer indices as inputs and returns an abstracted index. If the two input indices are equal, we return a \T{GetConstant} operator with the input index value. Otherwise, we compute offset as the difference between input-index and index of child of $n$ which has \semloc as descendent (computed by $DO(n, \semloc)$). We return this offset if they are equal and an empty-list otherwise. 
    \item \newtextsc{MergeProg}: It takes two programs as input and returns a list of \eastree, where each list element can materialize into the input programs. If the top-level node in the programs have equal values and types, we combine them as a \T{ConstantAST}. Otherwise, we recursively combine their children. Finally, we merge the reference-traversals corresponding to the input programs and combine them into \T{ReferenceAST}.
\end{enumerate}

Our synthesis procedure is inspired by anti-unification~\cite{anti-unification} and we abstract the paths and edit-programs across different examples. Specifically, our \T{KleeneTraversal} and \T{OffsetIndex} functions allow generalization across paths having different number of edges and different indices where naive abstractions fail. Similarly, \eastree also resemble anti-unification over tree-edits. However, again we use traversals over syntactic and longer-context semantic-edges, for better generalizations  and repairs. 

Finally, note that while we perform pair-wise merges over the edits, the strategy synthesis algorithm can be extended to merge bigger cluster of edits together as well. However, from our experience, we find that the pair-wise merging performs well and is sufficient for our experiments. 
%by recursively synthesizing values corresponding to the non-terminals in our \dsl. 
%Thus, to synthesize a strategy, we synthesize traversals for the \editloc. To synthesize a traversal, we check if the two traversals contain an equal number of edges. Next, we try to merge the corresponding pairs of edges on each traversal. To merge an edge, if it is simply a syntactic or semantic edge, we instantiate a \T{GetEdge} operator appropriately. However, if the two edges are \kleeneedge, then we instantiate a \T{GetKleeneEdge} operator where the clauses are constructed by intersecting the clauses computed in \newtextsc{Compress} step. It additionally ensures that the number of clauses after the intersection is more than $1$ to prevent over-generalizing strategies. In order to merge strategies, we next merge the edit-programs (\edit.editprog). We first combine the programs as a \T{ConstantAST} by checking whether the type and value match and then recursively merge the children and finally take the cartesian product of children. Next, based on the concrete reference traversals, we merge them and construct \T{ReferenceAST} \eastree. 



%Note that in order to learn repair strategies, we need to synthesize paths corresponding to all locations (\location) used in the strategy. We use \location in three production rules in our \dsl (\locationone, \locationtwo, \locationthree in Rules~\ref{dslrule:strategy},~\ref{dslrule:index},~\ref{dslrule:node}). Naively, trying to synthesize these paths is very expensive and will lead to non-generalizing strategies.
%Here, based on common fix-patterns for these vulnerabilities, we reduce the search space by enforcing structure over the paths we learn. Additionally, we also share paths between the three locations. 

%We find that performing these 

%At a high-level, our synthesis algorithm takes these unsafe-programs and edits as inputs, preprocesses them to store relevant meta-data, clusters them and then recursively enumerates over the non-terminals in the \dsl. How

