% \subsection{\sawitness and Witness-Removal }
\label{subsec:impl:witness-removal}
%\aksays{Are there going to be more subsections? If not, we should remove this subsection heading.}
\lstMakeShortInline[columns=fixed]@

We use \codeql~\cite{codeql} as our \sa tool. It is an open-source tool where custom static analysis is implemented as queries in a high-level object-oriented extension of datalog. The queries follow a relational \Verb|select from where| syntax to query the program database. Thus, we are able to implement the \T{\textbf{Witness}} relation defined in Section~\ref{sec:data} as queries in \codeql.

We implement the witness-removal and strategy learning steps in \cpp. Specifically, we perturb the detected \safeprogs using the \astree structure of the programs as described in Figure~\ref{fig:witness-removal}. While implementing witness-removal, we need to handle two particular challenges
\begin{enumerate}
    \item \textbf{Ensuring naturalness of perturbed programs.} Consider the following program @{if (witness) {sink}}@. Here, during witness-removal, apart from removing the guard condition, we need to remove the additional braces around the @sink@ as well. This is because the corresponding perturbed unsafe program generated (``@{{sink}}@'') would look unnatural and lead to non-generalizing repair strategies. We take care of such corner cases to the best of our abilities and leave investigating a more-thorough witness-removal pipeline for future work.
    \item \textbf{Capturing generalizing edits.} Consider the program @if (!witness) return custommessage@. Here, witness-removal step removes the entire \ifstmt (including the return statement). However, while capturing the edit, we ignore the return-value and store the edit-program as only @if (!witness) return@. This is because the return values, error handling, and error messages are very customized across different codebases and not learnable using a programmatic strategy. We make such design decisions to capture these kinds of \textit{generalizing edits} and discuss the implications in Section~\ref{sec:discuss}.
\end{enumerate}
\lstDeleteShortInline@

%Finally, while performing the repair, while inserting conditions, if we wrap an existing declaration statement inside a guard
%\codeql uses \T{Configuration} objects to store the \T{Source}, \T{Sink}, \T{Sanitizer}, and \T{Guard} relations. These configurations are manually written by \codeql developers and improved through rich community support\footnote{\url{https://github.com/github/codeql}}. 

% To implement our witnessing technique, we subclass these configurations by overriding the \T{Sanitizer} and \T{Guard} relations to be \texttt{none} and then defining our \T{SanInMiddle} predicate using the \T{Sanitizer} and \T{Guard} from the parent class. In addition, we need to make the following adjustments

% \begin{itemize}
%     \item \codeql does not allow dataflow through external library functions and thus many sanitizers implemented in external libraries are not detected using our default techniques. Therefore, we modify the \T{Sanitizer} relation to also detect external functions.     
%     \item In order to accurately detect the guards for a given source-sink pair, apart from using the build-in relations in configurations we also use the internals of \codeql  
% \end{itemize}

% \subsection{Strategy Learning}
% We implement the strategy learning step in \cpp. 