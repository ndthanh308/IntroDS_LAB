In this section, we describe how to learn repair strategies from the  unsafe programs and edits collected in Section~\ref{sec:data}. We define a \dsl (Section~\ref{subsec:dsl}) to express repair strategies that take an \pdg of an unsafe program  as input and generate a safe program as output. The DSL is expressive and can even express bad strategies that don't generalize well to programs in the wild. We provide examples of such bad strategies and good strategies that generalize well  (Section~\ref{subsec:examples}). We learn good repair strategies  in a data-driven manner using an example-based synthesis algorithm (Section~\ref{subsec:synthesis}). %Finally, given a new unsafe program and a set of learned repair strategies, we apply these strategies and generate  candidate repairs (Section~\ref{subsec:applying}).


%Our goal is to use the collected data to learn high-level general repair strategies. We learn these repair strategies over a joint representation of the \astree with the annotations inferred from the \sa tool (the representation referred to as \pdg ahead).  These inferred \sa tool annotations allow us to take the advantage of rich semantic information while performing \unsure{repairs}. Figure ~\ref{fig:example1-pdg} shows an example \pdg corresponding to the unsafe code shown in Figure ~\ref{fig:unsafememberex}. We develop a powerful \dsl that can utilize the annotations in the \pdg structure and learns repair strategies using a deductive synthesis algorithm. More specifically, strategies in this \dsl operate over the \pdg structure of unseen code-snippets and suggest appropriate edits correspondingly. \aksays{The following sentence can be removed if space becomes a constraint.} Section~\ref{subsec:dsl} describes the \dsl, Section~\ref{subsec:synthesis} talks about the synthesis algorithm, and Section~\ref{subsec:applying} demonstrates strategies in this \dsl can be applied. 


\subsection{\dsl for repair strategies}
\label{subsec:dsl}
We introduce a novel \dsl to express repair strategies in Figure~\ref{fig:fixing-dsl}.
%that use the knowledge of program semantics annotated on \pdg instead of just using the syntactic program structure and in-turn are more expressive and generalize better. These strategies take the an unsafe-program as input and return candidate repair programs by performing tree-edit-operations.
At a high level, the strategies define a three-step process where  they provide a computation to identify the edit-location node \editloc, a computation to identify the child index $\editindex$ of \editloc where repair happens, and a computation to generate the AST that must be placed at  index $\editindex$ of \editloc for the repair. The main part of these computations involve traversing paths of the input unsafe program \prog.
%The edit-operation can either be inserting a syntactic-child at \editloc (\insertsc) or replacing a syntactic-child with another tree at \editloc (\replace). The index at the \astree-node $\editloc$ where the insertion or replacement occurs is called the edit-index (\editindex). The tree that is inserted or replaces another existing tree at the \editloc is materialized hierarchically for the given example by defining abstract program structure using a combination of constant structure and references to \astree-nodes in the existing program \prog. These \astree-nodes are called reference-locations (\refloc). To find these locations (\editloc, \refloc) in a given program, the strategies abstractly store \textit{traversals} which materialize into a \textit{concrete} \astree-node in the given programs.  

%\naman{todo - talk about traversal in the introduction, background etc.}
\input{dsl}

%We present our \dsl in Figure ~\ref{fig:fixing-dsl}. 
%The DSL is a list of definitions for various non-terminals in the grammar. For each non-terminal, we define a corresponding type and a set of production rules. Each production rule is either a fixed expression, or an operator applied to other non-terminals or fixed-expressions in the grammar.  
The top-level production rule of the DSL defines strategies, \strategy, with type \newtextsc{Strategy}. 
%A \node is either the source node (\prog.source) or an application of \traversal on another \node. 
\gettraversal, \getclauses, and \getindex are all functions that take a \node $n$ as input and return a \node, \bool, and \integer as output respectively. The edit-AST, \eastree, is similar to a syntactic variant of \astree (i.e. no semantic edges) which we define in Section~\ref{sec:data} with one addition. It has reference nodes that, when applying the strategy to the input \pdg of \prog, are materialized from sub-trees of this \pdg, where the root nodes of these sub-trees are identified by traversing paths in the input. 
%Finally, edge-type (denoted by \edgetype) is an enumeration describing the type of edge, i.e. syntactic or semantic, and parent or child, as defined in Section~\ref{sec:data}. 

% Given these types, we now define the operators used in our \dsl. 
The strategy \strategy is of two types, \insertsc or \replace. \DMethod{Insert}{\I{L}}{\I{I}}{\I{O}}\ declaratively expresses the computation that computes the edit-location \editloc by traversing the path supplied in \I{L}, then computes \editindex, the index of edit-location,  by evaluating \I{I}(\editloc), and inserts the materialization of \I{O} as a syntactic-child \astree at index \editindex of the edit-location \editloc. \DMethod{Replace}{\I{L}}{\I{I}}{\I{O}}\ is similar and performs a replacement instead of an insertion.
%computes the \editloc and \editindex, and replaces syntactic-child of \editloc at \editindex with \I{O}.
%The insertion and replacement operations modify the nodes $\mathcal{N}$ and edges $\mathcal{E}$ of the \astree (Figure~\ref{fig:astsyntax}) appropriately. 

\node (\I{L}) is either the node corresponding to the source of vulnerability (\prog.source) or the target of the path corresponding to the traversal \DMethod{ApplyTraversal}{L}{\I{F}$_k\ o\ $\I{F}$_{k-1}\ o\ \cdots$\I{F}$_0$}. 
Here, each \I{F}$_i$ 
is a function that takes a node 
$n$ as input, performs a traversal from $n$, and returns the traversal's target node $n'$. 
Thus, \T{ApplyTraversal} can be recursively defined as \DMethod{ApplyTraversal}{\I{F}$_0$(L)}{\I{F}$_k\ o\ $\I{F}$_{k-1}\ o\ \cdots$\I{F}$_1$}\ if $k>0$ and \I{F}$_0$(L) otherwise. 

\newtextsc{GetTraversal} (\I{F}) defines a function that takes a node $n$ and returns a node $n'$ reachable from $n$ and can be of two types. Given $n$, the \DMethod{GetEdge}{\I{ET}}{\I{I}}\ operator first finds the possible single-edge traversals of type \I{ET} and indexes it using \I{I}. Specifically, if edge type \I{ET} is a parent then it returns the parent of $n$. Otherwise, 
it finds a set of $N$ of nodes that are connected with $n$ via the edge type \I{ET}, i.e., $N = \mathcal{E}(n, \I{ET})$, and returns the node $N[I(\I{n})]$ at the index given by $I$. In contrast, $\DMethod{GetKleeneStar}{\I{ET}}{\I{C}}(n)$  performs a \newtextsc{KleeneStarTraversal} that iteratively traverses edges of type \I{ET}, staring from input node $n$, until it reaches an edge whose target  node $n^{i}$ satisfies the condition defined by the clause \I{C}. Formally, \newtextsc{KleeneStarTraversal} can be defined recursively as $KE(n_1,ET,C) = \I{C}(n_1)? n_1 : \left(let\ t\in\mathcal{E}(n_1,ET)\ in\ KE(t,ET,C)\right)$. Here, the node $t$, which is target of an edge with source $n_1$ and type $ET$,  is chosen non-deterministically and our implementation resolves this non-determinism through a breadth-first search.
%A \traversal is a relation between nodes $n_1$ and $n_2$ such that there is an edge or a sequence of edges between them. 

\newtextsc{GetIndex} (\I{I}) defines a function that takes a node $n$ and returns a \integer. It is either a constant function that returns a fixed integer $z$ or a \DMethod{GetOffsetIndex}{\I{L}, \I{z}}. \DMethod{GetOffsetIndex}{\I{L}, \I{z}}\ takes a node $n$ as input and returns an integer $DO(n,L)+z$, where $DO(n_1,n_2)$ returns the index of syntactic child of $n_2$ who is a syntactic ancestor of $n_1$. 

\eastree (\I{O}) defines the edit \astree with reference nodes which, given an input program \prog, are materialized to a concrete \astree. The \eastree can either be a \T{ConstantAST} or a \T{ReferenceAST}. Specifically, \DMethod{ConstantAST}{$\tau$}{\I{value}}{\I{O}$_1$}{\I{O}$_2$}{$\cdots$}{{\I{O}$_k$}}\ returns an \eastree that has a type $\tau$, string representation \I{value}, and is recursively constructed with sub-trees \I{O}$_1 \cdots$ \I{O}$_k$ as syntactic children, each of which can either be a \T{ConstantAST} or a \T{ReferenceAST}. The \DMethod{ReferenceAST}{\I{L}}, when applying the strategy, finds a node $n$ in \prog by traversing the path described in \I{L} and returns a copy of the (syntactic) sub-tree of \prog rooted at $n$. %Next, we show examples of strategies written in this DSL and how to learn them automatically.

% Finally, note that the traversals can be composed by applying multiple \T{ApplyTraversal} operators sequentially. We use this key insight into developing our learning from examples setup. 
\input{strategies.tex}

\lstMakeShortInline[columns=fixed]@
\subsection{Example of strategies in our \dsl}
\label{subsec:examples}
Figure~\ref{fig:repair-strategy-ex1} describes   two possible repair strategies that are sufficient to repair the motivating example in Figure~\ref{fig:vulnerabilty-example1}. We first describe the good strategy in Figure~\ref{fig:strat1}, referred to as \strategyone,  and then compare it with the bad strategy \strategytwo in Figure~\ref{fig:strat2}. 

Given the program \prog in Figure~\ref{fig:vulnerabilty-example1}(a) as input, the strategy \strategyone
performs a replacement at index \I{I} of edit-location $L_e$ with the materialization of \I{O} (line 20 of \strategyone).
This process requires first finding the "semantic location" node \semloc. %The semantic location for \prog is shown in red in Figure~\ref{fig:example1-pdg}.
To this end, the strategy 
first  traverses a path from the node annotated as \T{source} by \sa  using \DMethod{GetKleeneStar}\ in Line~\ref{lst:line:semkleene} of \strategyone.  This \newtextsc{KleeneStarTraversal} starts from \T{source}, traverses semantic dataflow edges, and stops at a node 
corresponding to an identifier being used as the function name in a function call. 
 For the input program $P$, the traversal takes the semantic-child-edges 1-7 (Figure~\ref{fig:example1-pdg}) and stops at @foo@ in Line~\ref{lst:line:callerId-sink} of Figure~\ref{fig:vulnerabilty-example1}(a). Next, to reach the edit-location $L_e$, the strategy uses a \newtextsc{KleeneStarTraversal} that starts from \semloc, traverses syntactic parent edges,  and stops when it reaches a \blockstmt. For $P$, this traversal sets $L_e$  as the node corresponding to the \blockstmt between Lines~\ref{lst:line:handlers-run} and ~\ref{lst:line:handlers-run-end} of Figure~\ref{fig:vulnerabilty-example1}(a). Next, in Line~\ref{lst:line:offseteditindex} of \strategyone, the index \I{I} is set to the index corresponding to the  syntactic child of the edit-location $L_e$ who is an ancestor of the semantic location $L_s$ . For $P$, this index  materializes into $13$; the edge  outgoing from blue \blockstmt in Figure~\ref{fig:example1-pdg} to an ancestor of semantic location (shown in red) has label \T{ch:13}. Next, we materialize the \eastree defined in Line~\ref{lst:line:eastree} of \strategyone by  materializing the  reference-nodes. The \eastree \I{O} serializes into @if (REF1.hasOwnProperty(REF2)) { REF3 } @ where @REF1@, @REF2@, and @REF3@ correspond to \T{ReferenceAST} operators with locations as \reflocone, \refloctwo, and \reflocthree. \refloctwo traverses semantic-parent edges  from \semloc (Line~\ref{lst:line:goodref}) and materialize into @data.id@. Similarly, \reflocone and \reflocthree traverse syntactic children edges and materialize into @handlers@ and @foo(data);@ respectively. Thus, the \eastree \I{O} materializes  into @if (handlers.hasOwnProperty(data.id)) { foo(data); }@, which is the required repair. 

%When \strategyone is given the program \prog in Figure~\ref{fig:vulnerabilty-example1}(a) as input, then it first  traverses a path from the source node to the "semantic location"  \semloc using \DMethod{GetKleeneStar}{"SemChild"}{\DMethod{GetClause}{"Expr"}}\ in Line~\ref{lst:line:semkleene}. This leads to a \newtextsc{KleeneStarTraversal} with the stopping condition $\lambda n.\mathcal{T}[n] = \text{"CallExpr"}$. For the input program, the traversal skips through the semantic-child-edges 1-7 and reaches @foo@ in Line~\ref{lst:line:callerId-sink}. Next, it applies another \newtextsc{KleeneStarTraversal} starting from \semloc to reach \editloc in Line~\ref{lst:line:synkleene}. This traversal skips over syntactic-parent-edges and reaches the \blockstmt between Lines~\ref{lst:line:handlers-run} and ~\ref{lst:line:handlers-run-end}. Next, in Line~\ref{lst:line:offseteditindex}, the index \I{I} is computed as \DMethod{GetOffsetIndex}{Ls, 0}\ which means to pick the child-index of \editloc that has \semloc as its descendent. For our example, this index would materialize into the statement number in the block statement containing @foo@, which turns out to be $13$. Next, we instantiate the \eastree in Line~\ref{lst:line:eastree} which hierarchically defines the children-nodes or reference-nodes. The \eastree \I{O} deserializes into @if (REF1.hasOwnProperty(REF2)) { REF3 } @ where @REF1@, @REF2@, and @REF3@ correspond to \T{ReferenceAST} operators with locations as \reflocone, \refloctwo, and \reflocthree. \reflocone and \refloctwo use the semantic-parent edge traversals from \semloc (Line~\ref{lst:line:goodref}) and materialize into @handlers@ and @data.id@. \reflocthree performs a syntactic-child edge traversal from \editloc and materializes into @foo(data);@ thus materializing the entire \eastree \I{O} into @if (handlers.hasOwnProperty(data.id)) { foo(data); }@, i.e. the required repair. 

Now consider the repair strategy \strategytwo in Figure~\ref{fig:strat2}. This strategy shares a similar structure with the earlier strategy but differs in the way traversals and the index $\I{I}$ are computed. There are four key differences
\begin{enumerate}
    \item In order to reach \semloc from \prog.source, \strategytwo performs the \T{EdgeTraversal} using semantic-child edge seven times in Line~\ref{lst:line:nosemkleene}. The number of semantic edges varies widely across programs and prevents generalization to other scenarios. \T{KleeneStarTraversal} operator instead uses \newtextsc{Clauses} over nodes to find the edit-location.
    \item To reach $L_e$ from \semloc, \strategytwo performs the \T{EdgeTraversal} using syntactic-parent edge seven times in Line~\ref{lst:line:nosynkleene}. Consider a program that instead assigns output of the function-call @let out = foo(data)@. \strategytwo will find \assignexpr as the edit-location and fail to generalize whereas \strategyone will appropriately adjust and take four parent steps.
    \item In order to compute the index at which replacement needs to occur, \strategytwo uses a \DMethod{ConstantIndex}{13}\ in Line~\ref{lst:line:consteditindex} of Figure~\ref{fig:strat2}, which effectively assumes that replacement should always occur at 13$^{th}$ child of $L_e$ and again doesn't generalize. \strategyone on the other hand uses of \T{GetOffsetIndex} operator to instead compute index dynamically for a given input program
    \item In order to materialize reference nodes, \strategytwo uses syntactic edge traversals (Line~\ref{lst:line:badref} of Figure~\ref{fig:strat2}) which assume definite structure about the structure of the program (@GetConstant(7)@ used as syntactic child index to solve a long-ranged-dependency). \strategyone instead uses semantic-parent edges to capture the semantics here and produces a better generalizing repair.
\end{enumerate} 

\lstDeleteShortInline@

\noindent These programs highlight that our \dsl is expressive enough to perform complicated non-local repairs in a generic manner. At the same time, while many strategies can repair a given program, all applicable strategies are not equally good. A key realization is that we \emph{prefer shorter traversal functions} (\newtextsc{KleeneStarTraversal}\ over a long sequence of \newtextsc{EdgeTraversal}). Similarly, we \textit{prefer the traversals with none or small constants}. For example, we prefer \DMethod{GetOffsetIndex}{\semloc}{0}\  over \DMethod{GetConstant}{13}\ and semantic-parent traversal over syntactic-parent traversal with index \DMethod{GetConstant}{7}. %Finally, we also \emph{prefer strategies that share traversals across localizing \editloc and \refloc}.
We use these insights to guide the search in our synthesis algorithm.

% The strategy (\strategy) is defined by 
% performs this localization using an edit path (\editpath). We define a path (\genpath) in the strategy as a sequence of edges in the \prog. An edge is either a syntactic \astree edge or a semantic \taintpropedge in either direction (i.e. towards parent or child). 
% The localized node in the \prog is called edit location (\editloc). Next, the strategy either inserts or replaces a child of the edit location with a new \astree. This new \astree can either be a constant node or reference a node in the original \prog using a reference path (\rfpath). Figure ~\ref{fig:approach-notations} summarizes the notations 

% This \dsl was created so we can use the \sa annotations seamlessly and is guided by how humans fix such vulnerabilities. A line of previous works~\cite{} manually write repair patterns for fixing code. Our \dsl-based approach is strictly more general as it can perform various kinds of repairs and the exact repair strategies are learned from data. Moreover, we make effective use of high-level patterns and domain insights, and annotations. So while these other approaches tend to be simplistic and \textbf{either do not generalize well or over-generalize (generate a large number of false positives)}, concrete instantiations of strategies in our \dsl are better at capturing the high-level repair intent better. Following we describe the terminologies used in the repair \dsl.

% \lstMakeShortInline[columns=fixed]@
% The top level rule in our \dsl defines the Repair Strategy (denoted by \strategy). It is parameterized by the type of vulnerability the strategy fixes and the edit \edit. We consider two kinds of edits, either an insert operation or a replace operation. This means that the edit \edit either inserts an \astree child or replaces an \astree child with another \astree. Since we are fixing taint-flow vulnerabilities, we found these two operations to be sufficient. However, our \dsl can be expanded to also handle delete operations \aksays{Why can't we say that delete is replacement with an empty tree?}. In Figure ~\ref{fig:vulnerabilty-example1}, the fix applied in replaces the \astree corresponding to @handlers[callerId](data)@ (line ~\ref{lst:line:callerId-sink}, Figure ~\ref{fig:unsafememberex}) with the if statement in lines ~\ref{lst:line:fix-start}-\ref{lst:line:fix-end}, (Figure ~\ref{fig:safememberex}) and depicts a replace edit. 

% %\paragraph{Edit (\edit)} Since we are solving source-sink-sanitizer vulnerabilities, our \edit either inserts child \astree at edit-locations (denoted by \editloc) or replaces a child with another \astree (at \editloc). %This \editloc is a node in the \pdg which is reachable from the vulnerability source (as provided by the \astree) by traversing syntactic (\astree) or semantic edges in \pdg. %Once the \editloc is found, the new \astree (either replacing the existing child being inserted as a child) can be   

% Notice that in the \pdg, @handlers[callerId](data)@ is a child of the \blockstmt (parenthesis block between lines ~\ref{lst:line:handlers-run}-\ref{lst:line:handlers-run-end} and marked in blue in Figure ~\ref{fig:example1-pdg}). So while applying the fix, we replace the \textit{$k^{th}$} child of \blockstmt with the \ifstmt. We call the node in the \pdg where the edit operation applies as the edit location (\editloc). When a strategy applies, it has to determine this edit location based on the \pdg structure. Our \dsl defines an edit path (denoted by \editpath) to find edit location. In Figure ~\ref{fig:example1-pdg}, starting from the source-node @event@ (marked in orange), we take 7 semantic edges (reaching @callerId@) and then after hopping four synactic parent edges we reach the edit location \aksays{The notion of semantic edges should be defined and explained before this.}. This sequence of edge traversal defines our edit path. More generally, our \dsl considers the \editpath to be a set of semantic edges followed by a set of syntactic edges. This constraint on the paths allows expressivity to learn general strategies while also keeping the search space small. The semantic edges in \editpath allows navigating to ``somewhere close'' to sink location. Next once semantic edges are traversed, \editloc is reached by traversing a set of syntactic edges. Additionally, since the number of semantic edges might vary across examples, our \dsl allows a powerful  operator that navigates an indefinite number of semantic edges. This formulation helps our strategies to generalize well across widely different sets of programs. 

% %\paragraph{Edit Location (\editloc)} Edit location is the node in the \pdg where the edit operation (i.e. insertion or replacement of a child node) applies. \editloc is reachable from the vulnerability source found by traversing the edit-path (\editpath) in the \pdg.  So, in our running example, "$\dots$ function (data){$\dots$}" node (marked in blue) is the edit root and is reachable from the source via first traversing the semantic edges followed by traversing to "syntactic parent" four times. 
% Our kleene-star operator navigates indefinite semantic child edges until a ``stopping node'' (parameterized by a stopping condition) is reached. This stopping-condition is defined by a set of predicates applied on a \aksays{an} \astree node. We find that simplistic predicates about \newtextsc{ASTType} or \newtextsc{ASTValue} of \astree node and its neighbours suffice in locating this stopping node. For our running example, the stopping condition is the conjunction of the predicates @ASTType(node.parent) = IndexExpr@, @ASTType(node.parent.parent) = MethodCallExpr@. The stopping node lies on the taint-flow path from source to sink and therefore is quite relevant to the insert or replace operations (being a proxy for the semantic information of the vulnerability). Therefore, we call the stopping node as the semantic location (\semloc). In our running example, @calledId@, the sink-node is also the \semloc.

% As described above, our \dsl either inserts a new \astree, or it replaces an existing \astree with another \astree. An \astree is defined by three properties -- type, value and an array of children \astree. One can construct such an \astree by concretely initializing it using specific types and values for the tree and its descendants. However, a constant \astree cannot generalize because the fix depends on existing variables in the source code. Therefore, in addition to a constant \astree, our \dsl also allows referring to any existing node in the \astree. This referral is computed by traversing a path from the semantic location (\semloc defined above) to the node to reference \aksays{What is node to reference?}. The corresponding path is known as reference path. For e.g. the condition @handers.hasOwnProperty(callerId)@ which is used in the fix refers to @handlers@ and @callerId@ nodes in the tree and combines them in a constant \callexpr \astree. 

% We described edit paths and reference paths above. More generally a path is a sequence of edges in the \pdg where the edge can be one of syntactic or semantic or ancestral. When selecting a child edge, we also need to store \textit{which child} to select and it is determined by an index. Figure ~\ref{fig:repair-strategy-ex1} shows the entire strategy that fixes the example in Figure ~\ref{fig:vulnerabilty-example1}.
% \lstDeleteShortInline@

% \paragraph{Semantic Location (\semloc)} The node at which Kleene-Star traversal of semantic edges stops is called semantic location. This node is a key component in the repair since this node is a proxy for the semantically important values that would be necessary for making the edit. The sink node, callerId, is also the \semloc in our example. %Additionally, the \editloc is near this node and 

% \paragraph{Paths (\dslpath)} A path is described as a sequence of edges in the \pdg. The edges can be syntactic parent or child edges, semantic child edges, and ancestor edges in the \pdg.

% \paragraph{Index (\dslindex)}
% While selecting a child edge or while determining where the \concinsertcode needs to be inserted or replaced with, we need some index of which child to follow. Generally, this index is a constant value however it can be computed as an offset from the \semloc descendent direction as computed with the \newtextsc{OffsetFrom} operator. \naman{explain the requirement of offset with example}

%\paragraph{\astree} \astree is the tree-representation of the editcode that will replace some existing child of \editloc or will be inserted at some child indices of \editloc. One possible way to construct this \astree is to concretely initialize it using specific values and types. However, a constant \astree cannot generalize because the inserted code almost always depends on specific variables and the structures in the code. Therefore, in addition to a constant structure, the \astree can also refer to existing elements in the \pdg. This referral is again found using a path (\dslpath) traversal from the \semloc, the intuition being that it is a good \textit{proxy for the semantics of the vulnerability} and necessary variables to refer would be close to it.  


\subsection{Synthesizing \dsl strategies from examples}
\label{subsec:synthesis}
\input{synthesisexplain.tex}
% \aksays{This section is very dense. It would be good to take a small example and illustrate the key steps visually.}
\input{synthesisalgo2}

% Given this high-level \dsl, we will now describe our synthesis algorithm. We build a top-down synthesis algorithm that learns strategies in this \dsl through a \pbe approach. We receive a set of unsafe codes and concrete edits \unsure{the terminology of concrete edits can be confusing for the paper. Basically, anologous to all things in \dsl, we have concrete edits, paths, etc.}. Let $\{(\prog_{1},\concedit_1),(\prog_{2},\concedit_2),\dots$ $,(\prog_{n},\concedit_n)\}$ be the data we collect from our data collection step where $\prog_{i}$ is the ith unsafe code snippets and $\concedit_i$ is the corresponding concrete edit. $\concedit_i$ contains the concrete edit-location $\conceditloc_i$, the \astree of the editcode $\concinsertcode_i$, and the type of edit i.e. \insertsc or \replace.

% Given this data, we instantiate our algorithm to learn repair strategies. Our algorithm takes in these set of examples and learns a set of ($\{\strategy_1,\strategy_1,\dots,\strategy_k\}$) that are supposed to cover the training examples. Later, these repair strategies, when given an unsafe program \pdg will generate the edit that needs to be applied. The sketch of our synthesis and learning algorithm is presented in Figure~\ref{fig:strategy-learning}.

% %\input{synthesisalgo}

% \unsure{\textbf{Terminology for reference!!:} Letters with overlines are concrete elements ($\concedit$ is a concrete edit, $\conceditpath$ is a concrete edit path) while the letters without lines are abstract elements that can generalize over examples ($\edit$ is an abstract edit, $\editpath$ is an abstract edit path). Following, we again define the various abbreviations used in the algorithm
% \begin{itemize}
%     \item \prog is the \pdg containing \sa annotations
%     \item \concedit is the concrete edit which itself contains editcode, edit-location, edit-type, and indices
%     \item \concinsertcode is the concrete editcode that is either inserted or replaces some existing region in the unsafe code. \concinsertcode itself can be represented as an \astree
%     \item \conceditloc is the concrete edit location i.e. where the edit takes place in a \prog
%     \item \concpath is a concrete path as a sequence of edges
%     \item \conceditpath is a concrete edit path from source to \conceditloc
%     \item semLoc or semantic location is the stopping node of \conceditpath
%     \item \concrefpath is a concrete reference path from semantic location to a particular node matching value of a \astree node in \concinsertcode
%     \item edit-type refers to whether edit is \insertsc or \replace
% \end{itemize}}

% \spsays{Consider breaking these into subsections and have a running example. for instance, first section can be running bidirectional bfs, other could be pairwise merging, and so on..} 

% Our top-level \newtextsc{Learn} method receives the programs and concrete edits as inputs (Line~\ref{algo:line:learn}). This method first invokes the \newtextsc{PreProcessConcEdit} method which computes edit-paths and reference-paths in the $\concedit$. Next, \newtextsc{Learn} method ranks edits based on the similarity of their $\concinsertcode$ and in that order tries to combine edits together in a pairwise manner using the \newtextsc{MergeEdit} method.

% \newtextsc{PreProcessConcEdit} method (in Line~\ref{algo:line:preprocess}) stores the relevant paths in the $\concedit$ structure that will be useful during pairwise-merging. It first computes a set of edit paths from source to sink using a bi-directional breadth-first search (\newtextsc{BiDirectBFS}) (Line~\ref{algo:line:conceditloc}) and stores it in the edit. Note that during this \newtextsc{BiDirectBFS}, it traverses only semantic edges from the source and only syntactic edges from the edit location. This naturally leads to paths that follow the required pattern of a set of semantic edges followed by a set of syntactic edges. Note that edit-paths also contain the semantic-locations in the semLoc field. Then for every edit-node in the edit code and every semantic location in the edit path, it stores reference paths from semantic locations to nodes in the \astree having the same value as edit-node (Line~\ref{algo:line:concrefpath}. These paths are computed using a \newtextsc{MaxLevelBFS} until a certain depth and storing the satisfying nodes. Note that during implementation, we memoize the path-finding steps to avoid repeating computations.

% \newtextsc{PairSimilar} method computes a score for every pair of edits in the edit set. To compute the similarity for a given pair of edits it performs \newtextsc{ASTSimilarity} on their editcodes. 

% \newtextsc{MergeEdit} is the top-level method of our deductive top-down synthesis algorithm. The merging procedure is intuitive. For every element in the edit, it recursively calls \newtextsc{Merge} operation on the elements and then assembles an edit using their outputs. Specifically, this method first ensures that edits are of the same type (\insertsc or \replace. Then it obtains a set of candidate edit-paths by calling the \newtextsc{MergeEditPaths} method on the concrete edit paths stored in the input concrete edits. Next for every candidate edit-path, it finds a candidate editcode using the \newtextsc{MergeEditCode} method. Finally, for every editpath and editcode pair, it assembles the final edit (Line~\ref{algo:line:assembleedit})
    
% \newtextsc{MergeEditPath} method tries to merge two concrete editpaths. It first computes a set of intersecting predicates over the semantic-locations of the two paths. Using the predicates, it builds the \semkleene edge. Finally, over the remaining set of edges in the edit-path, it calls the \newtextsc{MergePath} method which inturn merges all the edges successively (Line~\ref{algo:line:mergepath})


% \subsection{Applying the learned strategies}
% \label{subsec:applying}
% Given an unsafe-program and a set of repair strategies, we apply each strategy to the program to generate candidate repairs. 
% To apply a single repair strategy, we use the definitions of operators described in Section~\ref{subsec:dsl} to generate candidate repair programs. We find that, in practice, we obtain a few distinct repairs and we return them as the output of our system. 

%Once these high level repair strategies are learnt, applying them is natural. For an unsafe program, strategy \strategy ingests the \pdg of the program. Then it tries to build an edit, by first locating the edit location (using the edit path \editpath) and building the \astree recursively depending on whether it is a constant or reference tree. If edit location and \astree are generated, the edit operation is applied appropriately based on whether it is an \insertsc or \replace edit. Otherwise, if either of location or \astree is not generated then no edit is applied. 
% \subsection{Scribblings}
% Each node $n$ of the AST has an identifier $\mathit{id}\in\mathbb{N}$. The AST is characterized by a set $\mathcal{N}$ of node $\mathit{id}$s, i.e., $\mathcal{N}=\{\mathit{id}_0,\ldots\mathit{id}_k\}$. We have a map $\mathcal{T}$ from nodes to their types, i.e., $\mathcal{T}(n)=\tau$, where the primitive types $\tau$ include {\sc MethodCallExpr}, {\sc IndexExpr}, etc. We also have a set $\mathcal{E}$ of edges, where each edge is $(n_1,n_2,ET,z)$. Here, $n_1$ is a source node, $n_2$ is a target node, $ET$ is the type of edge (syntactic parent, syntactic child, semantic parent, or semantic child), and $z$ is a child's index (set to $-1$ if the edge is a parent edge). 

% The strategy $S$ is of two types, insert an AST $O$ at index $I$ of location $L$, $\mathit{Insert}(L(\mathit{source}),I,O)$, and replace the AST at index $I$ of location $L$ with $O$, $\mathit{Replace}(L(\mathit{source}),I,O)$. Each $L(n)$ takes a node $n$ and traverses a path to reach a location, i.e.,  $L(n)=\mathit{ApplyPath}(n,F_k\circ\ldots\circ F_0)$, where the output node is $F_k(F_{k-1}(\ldots F_0(n)\ldots)$. Each $F$ instantiates the edge traversal function $TE[I,ET,C]$ with an index $I$, an edge type $ET$, and an optional clause $C$ (relevant for KleeneEdge). We define $TE[I,ET](n)$ as $let\ i=I(n)\ in\ let\ N=\mathcal{E}(n,ET)\ in\ N[i]$, which gets an integer index $i$ of children of $n$, gets a set $N$ of nodes by dereferencing edges of type $ET$ from $n$ and returns the $i^{th}$ child of $n$.
% $F$ can also be $TE[ET,C](n)\equiv KE(n,ET,C)$.
%  The KleeneEdge $KE$ keeps dereferencing edges of type $ET$ till it hits a node where a clause $C$ holds, i.e., $KE(n,ET,C)$ is defined as $C(n)? n : \left(let\ t=\mathcal{E}(n,ET)\ in\ KE(t,ET,C)\right)$. The node $t$ which is target of an edge with type $ET$ and $n$ as a source here is chosen non-deterministically and our implementation resolves this non-determinism through a breadth-first search. A clause is a conjunction of predicates of the form $\lambda n. \mathcal{T}(L(n))=\tau$. The index $I$ is either an integer $z$ or of the form $\lambda n.DO(n,L(\mathit{source}))+z$, where $DO(n_1,n_2)$ returns the index of syntactic child of $n_2$ who is a syntactic ancestor of $n_1$. 
 
%  A strategy can fail to apply if in $DO(n_1,n_2)$ there is no path from $n_2$ to $n_1$,