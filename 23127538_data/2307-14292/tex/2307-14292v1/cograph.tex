%!TEX root = main.tex

\section{Certifying Cographs}\label{se:cographs}

In this section we describe a PLS for the recognition of cographs, using $O(\log n)$-bit certificates in $n$-node graphs. That is, this section is entirely dedicated to  proving Theorem~\ref{theo:cographs}. Our scheme uses two known technical lemmas. The first lemma (Theorem~4 in~\cite{courcelle2007graph}) states that every graph of NLC-width \(k\) admits an NLC-decomposition of \emph{logarithmic} depth, and width still bounded by a function of~$k$. 

\begin{lemma}[Courcelle and Kant\'e \cite{courcelle2007graph}]\label{lem:logdepth}
Every \(n\)-node graph of NLC-width \(k\) admits an NLC-decomposition of width \(k\cdot 2^{k+1}\) such that the corresponding decomposition tree \(T\) has depth \(\mathcal{O}(\log n)\).
\end{lemma} 

The second technical lemma used to establish Theorem~\ref{theo:cographs} states that every cograph has a spanning tree with very small diameter. 
% \(\tau\) of depth \(2\). We are going to use this lemma to gather the certificates of all vertices into a single one, which corresponds to the root of \(\tau\).

\begin{lemma}[Montealegre, Ram\'{i}rez-Romero, and Rapaport \cite{montealegre2021compact}]\label{lem:depth2tree}
Every cograph has a rooted spanning tree of depth~2 in which every node at depth~1 in the tree has at most one child.
\end{lemma}

Our proof  of Theorem~\ref{theo:cographs} is structured as follows. First, we describe the certificates assigned by the prover at each node. Next, we describe the verification algorithm, and we prove that the scheme satisfies soundness and completeness. Finally, we establish the desired upper bound on the size of the certificates.

\subsection{Certificate Assignment }  

Let $G=(V,E)$ be the considered graph, and let \(u\in V\).  The certificate $c(u)$ is divided in two parts, respectively called \emph{main message} and \emph{auxiliary message}.

\subparagraph{Main messages.} 

Lemma~\ref{lem:logdepth} states that there exists an NLC-decomposition of cographs, with width~4, and such that the corresponding decomposition tree \(T_{dec}\) has depth \(\mathcal{O}(\log n)\). These main messages are used to encode such an NLC-decomposition tree \(T_{dec}\).  At every node~$u$, the main message contains the following data:
\begin{itemize}
\item The identifier $\id(u)$, and an integer \(\textsf{deg}(u)\) representing the degree of \(u\) in $G$.

\item A sequence \(\textsf{path}(u) = (x_1(u), \dots, x_{d}(u))\) of values, representing a path in \(T_{dec}\) from the root of $T_{dec}$ to the leaf of $T_{dec}$ where \(u\) is created thanks to $\mathsf{newVertex}$. Here \(d = d(u)\) represents the length of \(\textsf{path}(u)\). For each \(i \in \{1, \dots, d\}\), the value \(x_i(u)\) is a list of all the operations (type of join, potential recoloring, etc.) performed at the $i$th node of the path, starting from the root. For simplicity, we also refer to  \(x_i(u)\)  as this $i$th node. 

\item A sequence \(\textsf{links}(u) = (\ell_1(u), \dots, \ell_{d}(u)) \in \{0,1\}^{d}\), representing the sequence of edges that are followed to reach the $i$th node \(x_i(u)\) of the path $\textsf{path}(u)$ from the root $x_1(u)$. More precisely, \(\ell_1(u) = 0\) and for each \( i \in \{2, \dots, d\}\),  \(\ell_i(u)= 0\) if \(x_{i}(u)\) is the left child of \(x_{i-1}(u)\), and \(\ell_i(u) = 1\) otherwise. 
\end{itemize}

Note that since the prover provides \(u\) with the whole list of  \(\mathcal{O}(\log n)\) operations from the node of $T_{dec}$ where $u$ is created  to the root of~$T_{dec}$, there is not enough space for assigning a unique identifier to each nodes of the tree~$T_{dec}$, as this would results in consuming $O(\log^2n)$ bits in $\textsf{path}(u)$. Instead, a node of the decomposition will be uniquely identified by the sequence \(\textsf{links}(u)\) and by the content of the values stored in \(\textsf{path}(u)\). We shall show that this is sufficient. 


\subparagraph{Auxiliary messages.} 

Lemma~\ref{lem:depth2tree} states that there is a rooted spanning tree $T_{span}$ of $G$, with depth~2, and in which every node at depth~1 in the tree has at most one child. The auxiliary messages are used to gather all the main messages on a single node \(r \in V\). Each node receives the information required to certify a depth-2 spanning tree $T_{span}$ rooted at $r$. In addition, every node  at depth~1 in $T_{span}$ receives the main messages of its child in~$T_{span}$. Formally, the auxiliary message provided by the prover to a node \(u\) contains the following data:

\begin{itemize}
\item The identifier $\rho(u)=\id(r)$ of the root $r$ of $T_{span}$.
\item An integer \(\textsf{depth}(u) \in \{0,1,2\}\) representing the depth of \(u\) in $T_{span}$.
\item If \(\textsf{depth}(u) = 2\), a node identifier \(\textsf{parent}(u)\) representing the parent of \(u\) in $T_{span}$.
\item If \(\textsf{depth}(u) = 1\), a variable \(\textsf{child}(u)\), either representing the node identifier of the child of \(u\) in $T_{span}$, or \(\bot\) if \(u\) has no children in $T_{span}$.
 \item If \(\textsf{depth}(u) = 1\), and \(\textsf{child}(u) \neq \bot\), then \(u\) receives a variable \(\textsf{M}(u)\) representing  the main message of \(\textsf{child}(u)\).
\end{itemize}

\subsection{Verification Scheme} 

We now describe the verification algorithm performed by every vertex \(u\) of the actual graph. First,  \(u\) verifies that \(\textsf{deg}(u)\) corresponds to its degree, and that all the values stored in \(\textsf{path}(u)= (x_1(u), \dots, x_{d}(u))\) effectively correspond to a list of operations of an NLC-decomposition of width~4. In particular, $u$ checks that  \(x_{d}(u)\) contains the unique operation  \(\textsf{NewVertex}_i\) for some \(i\in \{1,\dots,4\}\). Concretely, after having shared its certificate with its neighbors,   \(u\) checks the following conditions, for each \(v \in N(u)\):

\begin{enumerate}
\item \label{item:pierre-1} \(\textsf{links}(u)\) and \(\textsf{links}(v) \) have a common prefix. More precisely, \(u\) checks that there exists an index \(i \in \{1, \dots, d(u)\}\)  such that \(\ell_j(u) = \ell_j(v)\) for every \(j \leq i\). Over all such indices  we denote by \(i^*\) the maximum one.

\item \label{item:pierre-2} \(\textsf{path}(u)\) and \(\textsf{path}(\revision{v})\) share the same the first \(i^*\) coordinates. More precisely, \(u\) verifies that \(x_j(u) = x_j(v)\) for every \(j \leq i^*\).

\item \label{item:pierre-3} Let \(\mathsf{currentcolor}(u,i^*)\) be the color of \(u\)  resulting from the \(\mathsf{NewVertex}\) operation specified in \(x_{d(u)}\), and all the \(\mathsf{recolor}\) operations in all the nodes in \(\textsf{path}(u)\) up to \(x_{i^*}(u)\), but not including the \(\mathsf{recolor}\) operations in \(x_{i^*}\)). The value \(\mathsf{currentcolor}(v,i^*)\) is defined the same for node~$v$. The following holds:
\begin{itemize}
\item  If \(\ell_{i^*}(u) = 0\) then \(u\) checks that  the join operation $\Join_S$ in  \(x_{i^*}\) satisfies  
\[(\mathsf{currentcolor}(u,i^*), \mathsf{currentcolor}(v,i^*)) \in S.\]
 \item If \(\ell_{i^*}(u) \neq 0\) then \(u\) checks that  the join operation $\Join_S$ in  \(x_{i^*}\) satisfies  
 \[(\mathsf{currentcolor}(v,i^*),\mathsf{currentcolor}(u,i^*)) \in S.\]
 \end{itemize}
\item \label{item:agree-root} Nodes $u$ and $v$ agree on the root of $T_{span}$, i.e., \(\rho(u) = \rho(v)\).  

% For simplicity, in the following we denote \(\rho = \rho(u)\). 

 \item \label{item:there-exists-parent} If \(\textsf{depth}(u)=2\) then \(u\) checks that there exists \(v \in N(u)\) such that \({\textsf{parent}(u) = v}\). 
 
\item \label{item:neighbor-root} If \(\textsf{depth}(u)=1\), then \(u\) checks that 
\begin{itemize}
\item \(\rho(u) \in \{\id(v):v\in N(u)\}\);
\item If  \(\textsf{child}(u)  \neq \bot\) then (1)~\(\textsf{child}(u) \in N(u)\),  (2)~\(\textsf{depth}(\textsf{child}(u)) = 2\), and (3)~every \(v \in N(u)\smallsetminus \{\textsf{child}(u) \} \) with  \(\textsf{depth}(v) = 2\) satisfies that \(\textsf{parent}(v) \neq u\);
\item If  \(\textsf{child}(u)  \neq \bot\) then \(\textsf{M}(u)\) equals the main message of \(\textsf{child}(u)\).
\end{itemize}

\item  \label{item:number-9-number-9} If \(\id(u) = \rho(u)\) then, \(u\) checks that the following holds\footnote{If all previous conditions are satisfied, then the root \(r=u\) obtains from its neighbors all the main messages of the nodes in~\(G\)}:
\begin{itemize}
\item The information in \(\{\textsf{path}(v): v\in V\}\) and \(\{\textsf{links}(v):v\in V\}\) is consistent, that is, for every \(v_1, v_2 \in V\), and for  every \(i \in \mathbb{N}\),
\[ \Big(\forall j \leq i, \; \ell_j(v_1) = \ell_j(v_2) \Big) \Longrightarrow \Big (\forall j \leq i,  \; x_j(v_1) = x_j(v_2)\Big).\]
Observe that if this condition is satisfied, then necessarily \(\{\textsf{path}(v): v\in V\}\) and \(\{\textsf{links}(v):v\in V\}\) describe a unique NLC-decomposition tree. Let us denote this tree by~\(T(u)\), and let \(G^*\) be the graph corresponding to the realization of the NLC-decomposition tree given by \(T(u)\). Note that \(u\) can obtain all the vertices and edges of \(G^*\) from \(T(u)\). 
\item Node \(u\) checks that \(G^*\) is a cograph.
\item Finally \(u\) checks that, for every node \(v \in V\),  the number of neighbors of \(v\) in \(G^*\)  equals \(\textsf{deg}(v)\). 
\end{itemize}
\end{enumerate}

\subsection{Completeness and Soundness} 

The completeness of our scheme directly follows from the fact that, thanks to Lemma~\ref{lem:logdepth}, every cograph admits a NLC-decomposition of width \(4\), and,  by Lemma \ref{lem:depth2tree}, one can define the main and auxiliary messages in a way that every node accepts.

For the soundness, let us assume that all nodes of a graph $G$ accept in the verification protocol. From condition~\ref{item:agree-root}, we have that all nodes agree on the same root $r$ of $T_{span}$. From the first item of condition~\ref{item:neighbor-root}, all nodes of depth~1 in $T_{span}$ are adjacent to~$r$. From condition~\ref{item:there-exists-parent}, and from the second item of condition~\ref{item:neighbor-root}, we have that every node at depth \(2\) is adjacent to a node of depth~1. Finally, the third item of condition~\ref{item:neighbor-root} guarantees that the root~$r$ receives all the main messages of the nodes \(G\). Then, by the first item of condition~\ref{item:number-9-number-9}, we have that $r$ can recover all the vertices and all the edges of \(G^*\), and by the second item of condition~\ref{item:number-9-number-9}, we have that \(G^*\) is a cograph.  From conditions \ref{item:pierre-1}-\ref{item:pierre-3}, we get that every edge \(\{u,v\} \in E(G)\) is necessarily included in \(G^*\), meaning that \(G\) is a spanning subgraph of \(G^*\). Finally, the third item of condition~\ref{item:number-9-number-9} guarantees that the number of edges in \(G^*\) equals the number of edges in \(G\), and thus \(G =G^*\). It follows that \(G\) is indeed a cograph.

\subsection{Certificate Size} 

By Lemma~\ref{lem:logdepth}, every cograph admits an NLC-decomposition tree of depth \(\mathcal{O}(\log n)\). Therefore, in the certificate assigned to node~$u$, we have \(d(u) = \mathcal{O}(\log n)\). Each value $x_i(u)$ can be encoded using $O(1)$ bits as  every operation involves a constant number of colors. It follows that  \(\textsf{path}(u)\) can be encoded on $O(\log n)$ bits. The variable \(\textsf{links}(u)\) can be encoded with \( \mathcal{O}(\log n)\) bits as well, by construction. Every node identifier,  and every node degree can be encoded with \( \mathcal{O}(\log n)\) bits. Therefore, all the main messages can be encoded with \( \mathcal{O}(\log n)\) bits. This also implies that the auxiliary messages can be encoded with \( \mathcal{O}(\log n)\) bits. We conclude that, in total, our PLS uses certificates on  \( \mathcal{O}(\log n)\) bits, which completes the proof of Theorem~\ref{theo:cographs}. 


