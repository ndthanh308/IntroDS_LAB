%!TEX root = main.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Models}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section, we recall the main concepts used in this paper, including proof-labeling scheme, and cographs. 

%----------------------------------------------------------------------
\subsection{Proof-Labeling Schemes for MSO Properties}
 %----------------------------------------------------------------------

For a fixed integral parameter $\lambda\geq 0$, we consider vertex-labeled graphs $(G,\ell)$, where $G=(V,E)$ is a connected simple $n$-node graph, and $\ell:V\to \{0,\dots,\lambda-1\}$. The label may indicate a solution to an optimization problem, e.g., a minimum dominating set ($\ell(v)=0$ or $1$ depending on whether $v$ is in the set or not), a $\lambda$-coloring, an independent set, etc. A labeling may also encode global overlay structures such as spanning trees or spanners, in bounded-degree graphs or in graphs provided by a distance-2 $k$-coloring, for $k=O(1)$. In the context of distributed computing in networks, nodes are assumed to be assigned distinct identifiers (ID) in $[1,n^c]$ for some $c\geq 1$, so that IDs can be stored on $O(\log n)$ bits. The identifier of a node~$v$ is denoted by~$\id(v)$. We denote by $N_G(v)$ the set of neighbors of node~$v$ in a graph~$G$, and we let $N_G[v]=N_G(v)\cup\{v\}$ be the closed neighborhood of~$v$. 

Given a boolean predicate~$\Pi$ on vertex-labeled graphs, a \emph{proof-labeling scheme} (PLS) for~$\Pi$ is a prover-verifier pair. The \emph{prover} is a non-trustable computationally unbounded oracle. Given a vertex-labeled graph $(G,\ell)$ with ID-assignment~$\id$, the prover assigns a \emph{certificate}~$c(v)$ to every node~$v$ of~$G$. The \emph{verifier} is a distributed algorithm running at every node~$v$ of~$G$. It performs a single round of communication consisting of sending $c(v)$ to all neighboring nodes $w\in N_G(v)$, and receiving the certificates of all neighbors. Given $\id(v)$, $\ell(v)$, and $\{c(w):w\in N_G[v]\}$, every node~$v$ outputs \emph{accept} or \emph{reject}. A PLS is correct if the following two conditions are satisfied: 
%
 \begin{itemize}
 \setlength\itemsep{0em}
 \item Completeness: If $(G,\ell)$ satisfies~$\Pi$ then the prover can assign certificates to the nodes such that the verifier accepts at all nodes;
\item Soundness:  If $(G,\ell)$ does not satisfy~$\Pi$ then, for every certificate assignment to the nodes by the prover, the verifier rejects in at least one node.
\end{itemize}
%
The main parameter measuring the quality of a PLS is the \emph{size} (i.e., number of bits) of the certificates assigned by the prover to each node of vertex-labeled graphs satisfying the predicate, and leading all nodes to accept. 

\subparagraph{MSO Predicates.} We focus on predicates expressible in $\MSO_1$. Recall that $\MSO_1$ is the fragment of monadic second-order (MSO) logic on (vertex-labeled) graphs that allows quantification on \revision{vertices} and \revision{on} sets of (labeled) vertices, and uses the adjacency predicate ($ \mathsf{adj}$). For instance non 3-colorability is in $\MSO_1$. Indeed, for every graph $G=(V,E)$, it can be expressed as: for all $A, B, C \subseteq V$, if $A\cup B\cup C=V$ and $A\cap B = A \cap C = B\cap C = \varnothing$ then 
\[
\exists (u,v) \in (A\times A) \cup (B\times B) \cup (C\times C) : (u\neq v) \land \mathsf{adj}(u,v). 
\]
We shall show that, although some $\MSO_1$ predicates, like non-3-colorability, require certificates on~$\tilde\Omega(n^2)$ bits in $n$-node graphs \revision{(see \cite{GoosS16})}, PLSs with certificates of polylogarithmic size can be designed for all $\MSO_1$ predicates in a rich class of graphs, namely all graphs with bounded clique-width. %, described next. 


%----------------------------------------------------------------------
\subsection{Cographs and Cotrees}
 %----------------------------------------------------------------------

We conclude this section by introducing a graph class that plays an important role in this paper. Recall that a graph is a cograph (see, e.g.,~\cite{BrandstadtLS99}) if it can be constructed by a sequence of parallel operations (disjoint union of two vertex-disjoint graphs) and join operations (connecting two vertex-disjoint graphs $G$ and $H$ by a complete bipartite graphs between $V(G)$ and $V(H)$). Therefore,  by definition, cographs have clique-width~2. In particular, cliques are cographs. 

It is known~\cite{BrandstadtLS99} that cographs capture precisely the class of induced $P_4$-free graphs. We shall show that, as opposed to $C_4$-free graphs, which require $\tilde\Omega(\sqrt{n})$-bit certificates to be certified by a PLS~\cite{DruckerKO13}\footnote{The lower bound in~\cite{DruckerKO13} is expressed for the \textsf{CONGEST} and \textsf{Broadcast Congested Clique} models, but it extends directly to PLSs since Set-Disjointness  has non-deterministic communication complexity~$\Omega(N)$ on $N$-bit inputs.}, $O(\log n)$-bit certificates are sufficient for certifying $P_4$-free graphs. This result is of  interest on its own, but proving this result will also play the role of a warmup before establishing our general result about graphs with bounded clique-width. Note that the class of $P_4$-free graphs (i.e., cographs) can be specified by an $\MSO_1$ formula. Roughly, the formula states that if there exists four vertices $v_1,v_2,v_3,v_4$ such that $\mathsf{adj}(v_i,v_{i+1})$ for $i=1,2,3$, then 
$
\mathsf{adj}(v_1,v_3) \lor \mathsf{adj}(v_1,v_4) \lor \mathsf{adj}(v_2,v_4).
$
$C_4$-freeness could be expressed in $\MSO_1$ as well. However, $P_4$-free graphs have clique-width~2 whereas $C_4$-free graphs have unbounded clique-width --- this is because there are \(2^{\Omega(n\sqrt{n})}\) different $C_4$-free graphs of size \(n\), but only \(2^{\mathcal{O}(n \log n)}\) \(n\)-vertex graphs of bounded clique-width.

Given a cograph~$G$, there is actually a canonic way of constructing~$G$ by a sequence of parallel and join operations~\cite{BrandstadtLS99}. As explained before, this construction can be described as a tree~$T$ whose leaves are the vertices of~$G$, and whose internal nodes are labeled $\parallel$ or $\Join$. This tree is called a \emph{cotree}, and will be used for our PLS. 
% Note that the operations corresponding to a cotree do not involve colors. However, using colors as in the NLC-decomposition enables to present different constructions of a same cograph, corresponding to different trees. The cotree of a cograph corresponds to the NLC-decomposition with the smallest number of colors, i.e., with just one color, which is equivalent to say without using the flexibility provided by the ability to color nodes. 












