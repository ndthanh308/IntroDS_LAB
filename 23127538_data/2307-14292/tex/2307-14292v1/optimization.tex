%!TEX root = main.tex

\section{Certifying Solutions of Optimization Problems}\label{se:optim}

In this section we extend our proof-labelling scheme to optimization problems expressible by  $\MSO_1$ predicates over graphs and vertex sets, on graphs of bounded clique-width. More precisely we consider $\MSO_1$ predicates $\Pi(G,X)$, over graphs $G=(V,E)$ and vertex subsets $X \subseteq V$. An optimization problem for $\Pi$ on graph $G$ consists in finding the maximum (or minimum) size vertex subset $X$ such that $\Pi(G,X)$ is true. For example, one can easily describe an  $\MSO_1$ predicate $\Pi(G,X)$ expressing that "$X$ is an independent set of $G$", or "$X$ is a dominating set of $G$". Hence problems like minimum dominating set or maximum independent set are particular cases of optimization problems expressible by  $\MSO_1$ predicates over graphs and vertex sets.

\begin{theorem}\label{theo:main-OPT}
Let $k$ be a non-negative integer. For every $\MSO_1$ predicate~$\Pi$ on vertex-labeled graphs and vertex-sets, and every $n$-node graph~$G=(V,E)$ with $\cw(G)\leq k$, and every $X\subseteq V$, there exists a PLS certifying that $X$ is the set of minimum (or maximum) size such that $(G,X)$ satisfies~$\Pi$ among all sets $Y$ such that $(G,Y)$ satisfies~$\Pi$, with $O(\log^2 n)$-bit certificates. 
\end{theorem}

Theorem~\ref{theo:main-OPT} actually also extends to $\MSO_1$ predicates $\Pi(G,X_1,X_2,\dots,X_q)$ over graphs and a bounded number of vertex subsets, and the optimization can be performed with respect to some linear evaluation function over the sizes of $X_1, \dots, X_q$. Such optimization problems are called $LinEMSOL$ in~\cite{CourcelleMR00}. However, since most natural optimization problems are expressed on a single vertex subset, and in order to keep the notations simpler, we focus here solely on predicates of type $\Pi(G,X)$. 


\subsection{Proof of Theorem~\ref{theo:main-OPT}}
\label{app:theo:main-OPT}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Operations $\Join_S$ and $\mathsf{recolor}_R$ directly extend to pairs of graphs and vertex subsets: $(G_1,X_1) \Join_S (G_2,X_2)$ corresponds to pair $(G_1 \Join_S G_2, X_1 \cup X_2)$, and recoloring $\mathsf{recolor}_R(G,X)$ is simply the pair $(\mathsf{recolor}_R(G),X)$. 

%We can define as before the equivalence relation $\equiv_{\Pi}$ over pairs $(G,X)$ where $G$ is a graph and $X$ is a vertex subset. Let $G_1, G_2 \in \NLC_k$, $X_1 \subseteq V(G_1)$ and $X_2 \subseteq V(G_2)$. We say that pairs $(G_1,X_1)$ and $(G_2,X_2)$ are equivalent w.r.t. $\Pi$, denoted $(G_1,X_1) \equiv_{\Pi} (G_2,X_2)$, if the following holds: for any NLC-decomposition decomposition tree $T$ with labels in $[k]$ and any leaf $x$ of $T$, if $T_1$ and $T_2$ denote the decomposition tree obtained by replacing the node $x$ of $T$ by the tree $T(G_1)$ and $T(G_2)$ respectively, then the two graphs $G'_1 = G(T_1)$ and $G'_2 = G(T_2)$ together with any vertex subsets $X'_1$ of $G'_1$ and $X'_2$ of $G'_2$ such that $X'_i \cap V(G_i) = X_i, i \in\{1,2\}$ satisfy $\Pi(G'_1,X'_1) = \Pi(G'_2,X'_2)$. \ioan{A compl√©ter par des explications plus intuitives.}

%Operations $\Join_S$ and $\mathsf{recolor}_R$ directly extend to pairs of graphs and vertex subsets: $(G_1,X_1) \Join_S (G_2,X_2)$ corresponds to pair $(G_1 \Join_S G_2, X_1 \cup X_2)$, and recoloring $\mathsf{recolor}_R(G,X)$ is simply the pair $(\mathsf{recolor}_R(G),X)$.

The notion of regularity (Definition~\ref{de:reg}) extends to predicates over graphs and vertex subsets, moreover such $\MSO_1$ predicates are regular on graphs of bounded NLC-width. (Again, this even holds for predicates with a bounded number of vertex subsets~\cite{CourcelleMR00}).

\begin{definition}\label{de:regOpt}
Let $\Pi(G,X)$ be a predicate over graphs and vertex sets. Predicate $\Pi$ is called  \emph{NLC-regular} if, for any value $k$, we can associate a finite set $\cC$ of \emph{homomorphism classes} and a \emph{homomorphism function} $h$, assigning to each graph $G \in \NLC_k$ and each vertex subset $X$ of $G$ a class $h(G,X) \in \cC$ such that:
\begin{enumerate}
\item If $h(G_1,X_1) = h(G_2,X_2)$ then $\Pi(G_1,X_1) = \Pi(G_2,X_2)$.
\item For each composition operation $ \Join_S $ of arity 2 there exists a function $\odot_{\Join_S}: \cC \times \cC \rightarrow \cC$ such that, for any two $\NLC_k$ graphs $G_1$ and $G_2$ with vertex subsets $X_1$, $X_2$,
 $$h((G_1,X_1) \Join_S (G_2,X_2)) = \odot_{\Join_S }(h(G_1,X_1),h(G_2,X_2)).$$
 \item For each composition operation $\mathsf{recolor}_R$ of arity 1 there is a function $\odot_{\mathsf{recolor}_R}: \cC \rightarrow \cC$ such that, for any $\NLC_k$ graph $G$ and vertex subset $X$,
$$h(\mathsf{recolor}_R(G,X)) = \odot_{\mathsf{recolor}_R}(h(G,X)).$$
\end{enumerate}
Moreover functions  $\odot_{\Join_S}$ and $\odot_{\mathsf{recolor}_R}$ can be computed in constant time for any recoloring function $R:[k] \to [k]$ and any set $S$ of pairs of $[k] \times [k]$. Also, for any graph with a unique vertex colored $i \in [k]$, its two classes (corresponding to the two possible vertex subsets, the singleton and the empty set) can be computed in constant time. Again, by constant time, we mean only depending on $k$ and on the $\MSO_1$ formula describing $\Pi$.
\end{definition}


For example, if $\Pi(G,X)$ expresses that $X$ is an independent set of $G$, then we can take $\cC$ as the set of subsets of $[k]$, plus a special symbol $\bot$, and define  $h(G,X)$ as follows: $h(G,X) = \bot$ if $X$ is not an independent set, otherwise $h(G,X)$ is the subset of $[k]$ such that $i \in h(G,X)$ if $X$ contains some vertex colored $i$. %If $\Pi(G,X)$ expresses that $X$ is a dominating set of $G$, then we can chose $h(G,X)$ as a pair of subsets of $[k]$: the first subset corresponds to all colors of $X$, the second corresponds to all colors that are not completely dominated by $X$. 
Again, it is a matter of exercise to construct the classes for graph with a single vertex, as well as functions $\odot_{\mathsf{recolor}_R}$ and $\odot_{\Join_S}$. Indeed, if $G$ has a unique vertex $x$ coloured $i \in [k]$ then $h(G,\emptyset) = \emptyset$ and $h(G,\{x\}) = \{i\}$. Function $\odot_{\mathsf{recolor}_R}$ simply takes into account the recoloring of vertices. Let $R : [k] \to [k]$ be a recoloring. Note that $\odot_{\mathsf{recolor}_R}(\bot) = \bot$ (this corresponds to pairs $(G,X)$ where $X$ is not an independent set of $G$). Let $c$ be a subset of $[k]$, note that  $\odot_{\mathsf{recolor}_R}(c) = c'$ with $c' = \{j \in [k] \mid \exists i \in c \text{~such that~} R(i) = j\}$. Indeed, if $c=h(G,X)$ for some pair $(G,X)$, then $c'$ corresponds to the colours of vertices of $X$ after recoloring. Eventually, we describe the binary function $\odot_{\Join_S} : \cC \times \cC \to  \cC$. Observe that $\odot_{\Join_S}(c_1,c_2) = \bot$ if $c_1= \bot$ or $c_2 = \bot$. Indeed this corresponds to the case when $c_1 = h(G_1, X_1)$ and $c_2 = h(G_2, X_2)$, and $X_1$ is not an independent set of $G_1$, or $X_2$ is not an independent set of $G_2$ ; therefore $X = X_1 \cup X_2$ cannot be an intependent set of $G_1 \Join_S G_2$. For similar reasons, if there is some pair $(i,j)\in S$ such that $i\in c_1$ and $j \in c_2$, then $\odot_{\Join_S}(c_1,c_2) = \bot$, because the $\Join_S$ operation adds an edge between $X_1$ and $X_2$, so $G$ is not an independent set of $G$. Otherwise, we have $\odot_{\Join_S}(c_1,c_2) = c_1 \cup c_2$, since the set of colours of $X$ is the union of the sets of colours of $X_1$ and $X_2$. This proves the NLC-regularity of predicate ''$X$ in an independent set of $G$''.


By~\cite{CourcelleMR00}, all $\MSO_1$ predicates are regular:

\begin{proposition}\label{pr:regOpt}
Any  property $\Pi$ over graphs and vertex subsets expressible by an $\MSO_1$ predicate is NLC-regular. Moreover, given the corresponding $\MSO_1$ formula and parameter $k$, one can explicitely compute the set of homomorphism classes $\cC$, as well as  functions $\odot_{\Join_S}$ and $\odot_{\recolor_R}$ for any $S \in [k] \times [k]$ and any $R : [k] \to [k]$, and the homomorphism class of the graph formed by a unique vertex coloured $i$, for any $i \in [k]$.
\end{proposition}

To unify maximization and minimization problems, assume that we deal with weighted graphs. In this setting, each vertex $u$ of $G$ is assigned an integer $weight(u)$ in the interval $[-MAXW,+MAXW]$ for some positive integer constant $MAXW$. The aim of the optimization is to find a maximum weight vertex subset $X$ satisfying $\Pi(G,X)$. Natural minimization problems are turned into maximization problems, using negative weights.

In the certification context, we will be given graph $G$ together with the set $X$ of \emph{selected vertices}. The selected vertices are encoded by a function $sel : V \to \{0,1\}$. The set $X_s$ of selected vertices corresponds to  $X_s = \{u \in V(G) \mid sel(u) = 1\}$ and we aim to certify that $\Pi(G,X_s)$ is true and $X_s$ is of maximum weight among all sets $X$ satisfying $\Pi(G,X)$. Each node $u$ of the graph knows its status $sel(u)$, so it knows whether it is selected or not. Let us note that we prefer to separate the vertex selection function $sel$ and the vertex labeling function $\ell$, for two reasons: they play different roles (the labelling is part of the input, while selected vertices must be proved to be an optimal output for the problem), moreover the two can be combined, in the sense that the optimization is performed on labeled graphs (e.g., in the red-blue dominating set problem, the input is a graph with vertices labelled 0 for red and 1 for blue, and the aim is to find a minimum size set X of red vertices dominating all blue vertices).

We need to enrich the certificates  for decision problems described in the Section~\ref{se:cwd}. For each class $c \in \cC$, let $MaxW(G,c)$ denote the maximum $weight(X)$ over all vertex subsets $X$ of graph $G$ such that $h(G,X) = c$. If no such $X$ exists, we set $MaxW(G,c) = -\infty$. 
Informally, in each certificate, homomorphism classes over subgraphs of $G$ are replaced by homomorphism classes over the same subgraphs, with the corresponding subset of selected vertices. Moreover, whenever we had to consider a partial solution over a subgraph $G'$ of $G$, we also store in the message, besides the homomorphism class $h(G,X')$, the weight of the selected vertices $X'$ of $G'$, as well as all values $MaxW(G',c)$, over all possible classes $c \in \cC$. The latter will allow to check that there is no better solution for the problem than our set of selected vertices.


The following proposition is a straightforward application of the definition of $MaxW(G,c)$. It was also observed, in slightly different terms, in~\cite{CourcelleMR00} and it provides the tool to update values $MaxW$, from bottom to top, if we are given a decomposition tree. %\ioan{Can add a proof if needed}
\begin{proposition}\label{pr:MaxW}
Let $\Pi(G,X)$ be an $\MSO_1$ predicate over graphs and vertex subsets,  $k$ be a fixed parameter, and $c \in \cC$ a homomorphism class.
\begin{enumerate}
\item If $G$ is formed by a single vertex $x$ of colour $i$. Then $$MaxW(G,c) = \max \{ weight(X)  \mid X \subseteq \{x\} \text{~such that~} h(G,X)=c\}.$$
\item If $G = G_1 \Join_S G_2$, then
$$MaxW(G,c) = \max_{c_1,c_2 \in \cC\times \cC}\{MaxW(G_1,c_1) + MaxW(G_2,c_2)\},$$
over all pairs of classes ${c_1,c_2 \in \cC\times \cC} \text{~s. t.~} \odot_{\Join_S}(c_1,c_2)=c$.
\item If $G = R(G')$, then
$$MaxW(G,c) = \max\{MaxW(G',c') \mid {c'\in \cC} \text{~such that~} \odot_R(c') = c.\}$$
\end{enumerate}
In all above equations we consider that the maximum of an empty set is $- \infty$.
\end{proposition}


We can now formally describe the certificates. We only precise what changes with respect to messages defined in Section~\ref{se:cwd}.

\subparagraph{Main messages.} 

In the decision setting, the main message of each node $u$ contains a sequence $\textsf{h}(u) = (h_1(u), \dots, h_d(u))$. Recall that $x_i(u)$ denotes the $i$th node on the path of the $NLC_+$ decomposition tree $T$ of $G$, from the root to the leaf creating $u$, and $h_i(u)$ denotes the homomorphism class of predicate $\Pi$ at node $x_i(u)$, i.e., corresponding to the induced subgraph $G[x_i(u)]$ of $G$. In the optimization setting we simply use as $h_i(u)$ the class $h(G[x_i(u)],X_s[x_i(u)])$, where $X_s[x_i(u)]$ is the set of selected vertices of $G[x_i(u)]$.


We add to the main message of $u$ the sequence $\textsf{weight}(u) = (\textsf{weight}_1(u), \dots, \textsf{weight}_d(u))$, such that, for each \(i \in \{1, \dots, d\}\), \(\textsf{weight}_i(u)\) denotes the total weight of selected vertices at $x_i(u)$, that is, the weight of $X_s[x_i(u)]$.

We also add the sequence $\textsf{MaxW}(u) = (\textsf{MaxW}_1(u), \dots, \textsf{MaxW}_d(u))$, where  $\textsf{MaxW}_i(u)$ denotes the list  $\{MaxW(G[x_i(u)],c) \mid c \in \cC\}$ of maximal weights of possible partial solutions at node $x_i$, over all possible classes $c \in \cC$. 

\subparagraph{Auxiliary messages.} 

Recall that at each node $x$ of type $\Join$ of the NLC+ decomposition tree, we use a spanning tree $A(x)$ of the graph $G[x]$ hanging at $x$ and and auxiliary messages to check that $G[x]$ is indeed connected, and that the messages in this subgraph are coherent. Formally each node $u$ of $G$ is provided an auxiliary message $\textsf{aux}(u) = (\textsf{aux}_1(u), \dots, \textsf{aux}_{d}(u))$, where $\textsf{aux}_i(u)$ is set to $\bot$ if $x_i(u)$ is of type $\parallel$, otherwise it contains the information required for the spanning tree $A(x_i(u))$ and the coherence of messages of $G[x_i(u)]$. The  difference for optimization problems consists in enriching the part \(\textsf{childrenMain}^j_i(u)=(z^j, h(z^j), \textsf{color}(z^j), \textsf{exit}(z^j))\) for \(j \in \{0,1\}\), where $z^0$ and $z^1$ denote the children of $x_i(u)$ in the NLC+ decomposition tree. As for main messages, in the optimization setting $h(z^j)$ will denote the homomorphism class for property $\Pi$ on $G[z^j]$ and its selected vertices. Moreover we add to $\textsf{childrenMain}^j_i(u)$ the information $\textsf{weight}(z^j)$ and $\textsf{MaxW}(z^j)$, for $j \in \{0,1\}$, where $\textsf{weight}(z^j)$ is the weight of selected vertices of $G[z^j]$ and $\textsf{MaxW}(z^j) = \{MaxW(G[z^j],c) \mid c \in \cC\}$ is the list of all optimal solutions, over all homomorphism classes, in graph $G[z^j]$. 
%\ioan{Laisse-t-on aussi l'indice $i$~?}

\subparagraph{Service messages.} 

Recall that these messages are created at each  node $x$ of type $\parallel$ in the decomposition tree, and they concern the vertices of some tree $S(x)$, connecting the graphs corresponding to subtrees of children $z_i$ of $x$, $1 \leq i \leq p$ through their exit vertices. Also recall that for each node $u$ of $S(x)$, we have defined the set of indices $\textsf{inCharge}_x(u) = \{i \in \{1, \dots, p\} \mid \textsf{exit}(z_i) \in S(x,u) \}$, meaning that the service message of $u$ for $x$ concerns the partial solution  \(G[ \textsf{inCharge}_x(u) ] \), the subgraph of \(G\) induced by the disjoint union of all graphs \(G[z_i]\) with \(i \in \textsf{inCharge}_x(u)\). By symmetry, let $X_s[ \textsf{inCharge}_x(u) ]$ be the union of labelled vertices $X_s[z_i]$,  \(i \in \textsf{inCharge}_x(u)\).

Recall that, for decision problems (see Section~\ref{se:cwd} for a full description of service messages), we used value $\textsf{class}^j_i(u)$ corresponding to homomorphism of $G[\textsf{inCharge}_{x}(u)]$ (here $j=0$ if $x$ is in the left child of $x_{i-1}(u)$, and  $j=1$ if $x$ is the right child of $x_{i-1}(u)$). In the optimization version, we use instead
 the homomorphism class \(h(G[ \textsf{inCharge}_x(u) ], X_s[ \textsf{inCharge}_x(u) ])\), and we add the weight $\textsf{weightService}^j_i(u)$ of $X_s[ \textsf{inCharge}_x(u) ]$, and  the list $\textsf{MaxWService}^j_i$ of all values $\{MaxW(G[ \textsf{inCharge}_x(u) ],c) \mid c \in \cC\}$. 


We emphasize again that, when we generalized the certification messages from decision problems to optimization problems, we applied the same process on every partial solution, on (induced) subgraphs $G'$ of $G$: the homomorphism class $h(G')$ was replaced with the corresponding homomorphism class $h(G',X'_s)$ over selected vertices of $G'$, and the messages were enriched with the weight $weight(X'_s)$ of $X'_s$ and with the set $\{MaxW(G',c) \mid c \in \cC\}$ of all maximal partial solutions of $G'$, over all possible homomorphism classes.

Therefore, in the verification scheme, we only need to update all verifications that were in charge of homomorphism classes $h(G')$ for some subgraph $G'$, and to enrich them to verify:
\begin{itemize}
\item $h(G',X'_s)$, using Definition~\ref{de:regOpt} instead of Definition~\ref{de:reg},  
\item  the weight $weight(X'_s)$ of $X'_s$, by simply summing over smaller partial solutions,
\item the wholes set $\{MaxW(G',c)\}$ over all classes $c$ of $\cC$. For the latter, we simply use Proposition~\ref{pr:MaxW}, in the same manner as we used Definition~\ref{de:reg}, to check that each value $MaxW(G',c)$ is correct.
\end{itemize}
This occurs in the following places -- we refer again to modifications w.r.t. Section~\ref{se:cwd}.

\subparagraph{Verification of main messages.} 

Item~\ref{verif:4}, on graph $G'$ with a single vertex $u$: we must check that $weight(X'_s) = 0$ if $u$ is not selected, otherwise $weight(X'_s) = weight(u)$. Values $MaxW(G',c)$ are computing using the first item of Proposition~\ref{pr:MaxW}.

Item~\ref{verif:5.1}, for the whole graph $G$. Besides checking that $h_1(u) = h(G,X_s)$ is an accepting class for property $\Pi$, we also check that the weight of $X_s$ (i.e., $\textsf{weight}_1(u)$) equals the maximum of $MaxW(G,c) \in \textsf{MaxW}_1(u)$ over all \emph{accepting} classes $c$. This ensures that the solution  $X_s$ is indeed optimal.

Item~\ref{verif:9}, corresponding to an edge between vertices $u$ and $v$ such that  $x_{i^*}(u)$, their lowest common ancestor in the NLC+ decomposition tree, is a binary $\Join$ node. In this case $G[x_{i^*}(u)]$ is obtained from $G[x_{i^*+1}(u)]$ and $G[x_{i^*+1}(v)]$ by a sequence of operations $\Join_S$ then $\recolor_R$. As for decision problems, we verify using Definition~\ref{de:regOpt} that class $h_{i^*}(u)$ is coherent with classes $h_{i^*+1}(u)$ and $h_{i^*+1}(v)$ after performing  $\Join_S$ then $\recolor_R$. Then we perform the similar verification for each value $MaxW(G[x_{i^*}(u)],c) \in \textsf{MaxW}_{i^*}(u)$ using Proposition~\ref{pr:MaxW} (items 2 and 3) to check that $\textsf{MaxW}_{i^*}(u)$ is indeed obtained from $\textsf{MaxW}_{i^*+1}(u)$ and $\textsf{MaxW}_{i^*+1}(v)$ by a sequence of operations $\Join_S$ then $\recolor_R$. Also, we check that $\textsf{weight}_{i^*}(u) = \textsf{weight}_{i^*+1}(u) + \textsf{weight}_{i^*+1}(v)$.

\subparagraph{Verification of auxiliary messages.} We do not need any changes, since this is only a coherence check based on the equality of parts $\textsf{childrenMain}$ of the messages.

\subparagraph{Verification of service messages.}  We need to verify messages $\textsf{class}^j_i(u)$ corresponding to homomorphism of $G[\textsf{inCharge}_{x}(u)]$, the weight $\textsf{weightService}^j_i(u)$ of $X_s[ \textsf{inCharge}_x(u) ]$, and  the list $\textsf{MaxWService}^j_i(u)$ of all values $\{MaxW(G[ \textsf{inCharge}_x(u) ],c) \mid c \in \cC\}$. 

Item~\ref{verif:21} is performed when $u$ is a leaf of the  tree \(S(x_i^j)\), in particular it is the exit vertex of $G[x_{i+1}(u)]$ and $ \textsf{inCharge}_x(u)  = G[x_{i+1}(u)]$. As in Section~\ref{se:cwd} we check that \(\textsf{class}_i^j(u) = h_{i+1}(u)\). We also check that $\textsf{weightService}^j_i(u) = \textsf{weight}_{i+1}(u)$ and $\textsf{MaxWService}^j_i = \textsf{MaxW}_{i+1}(u)$.

Recall that, for vertex $u$, \(\textsf{children}_i^j(u)\) denotes the set of nodes  \(w\in V\) such that \({\textsf{parent}_i^j(w)=u}\), and this set is known to $u$. In particular $ \textsf{inCharge}_x(u)  = \parallel_{w \in \textsf{children}_i^j(u)} \textsf{inCharge}_x(w)$. In particular $ \textsf{inCharge}_x(u)  = \cup_{w \in \textsf{children}_i^j(u)} \textsf{inCharge}_x(w)$.


Item~\ref{verif:24} This verification occurs when  \(\textsf{children}_i^j(u)\) has a unique node $w$. Besides the verification that \(\textsf{class}_i^j(u) = \textsf{class}_i^j(w)\) we also check that $\textsf{weightService}^j_i(u) = \textsf{weightService}^j_i(w)$ and $\textsf{MaxWService}^j_i(u) = \textsf{MaxWService}^j_i(w)$.


Item~\ref{verif:25} This happens when  \(\textsf{children}_i^j(u)\) has two or more nodes $w$. Recall that, in this case, $G[\textsf{inCharge}_{x}(u)] = \parallel_{w \in \textsf{children}_i^j(u)} G[\textsf{inCharge}_x(w)]$. As for decision problems, we order arbitrarily the vertices $w_1 \dots, w_p$ of \(\textsf{children}_i^j(u)\) and for each graph $H_q = G[\textsf{inCharge}_x(w_1)] \parallel \dots \parallel G[\textsf{inCharge}_x(w_q)]$, $1 \leq q \leq p$, we compute  $h(H_q,X_q)$, $weight(X_q)$ and sets $\{MaxW(H_p,c) \mid c \in \cC\}$ incrementally, by increasing values of $q$. Here $X_q$ denotes the set of selected vertices of $H_q$. Observe that $H_1 = G[ \textsf{inCharge}_{x}(w_1)]$ so node $u$ has all the required information in the message of $w_1$. For each $q, 2 \leq q \leq p$, these parameters are computed thanks to relation $H_q = H_{q-1} \parallel G[\textsf{inCharge}_x(w_q)]$, based on Definition~\ref{de:regOpt} and Proposition~\ref{pr:MaxW} adapted to operation $\parallel$, from the similar parameters on $H_{q-1}$ (previously computed at node $u$) and $G[\textsf{inCharge}_x(w_q)]$ (retrieved from the message of $w_q$. Eventually, $u$ checks that these parameters on $H_p$ correspond to $\textsf{class}^j_i(u)$, $\textsf{weightService}^j_i(u)$ and $\textsf{MaxWService}^j_i(u)$.


Item~\ref{verif:27} applies when  \(u = \textsf{exit}_{i}(u)\). In this case, $u$ checks for each \(j \in \{0,1\}\) that  \(\textsf{class}_i^j(u) = h_{i}(u)\), $\textsf{weightService}^j_i(u) = \textsf{weight}_{i}(u)$ and $\textsf{MaxWService}^j_i = \textsf{MaxW}_{i}(u)$.

The soundness and correctness proofs are, modulo the use of Definition~\ref{de:regOpt} and Proposition~\ref{pr:MaxW}, very similar the case of decision problems. Note that the new messages are still of size $O(\log^2 n)$.  \hfill\qed

 






