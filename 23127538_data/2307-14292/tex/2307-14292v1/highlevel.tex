%!TEX root = main.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview of our Techniques}
\label{se:hl}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The objective of this section is to provide the reader with a general idea of our proof-labeling scheme. Our construction bears some similarities with the approach used in~\cite{FraigniaudMRT22} for the certification of \(\MSO_2\) properties on graphs of bounded tree-width, with certificates of size \(O(\log^2 n)\) bits. However, extending this approach to a proof-labeling scheme for graphs with bounded clique-width requires to overcome several significant obstacles. We therefore start by summarizing the main tools used for 
the certification of \(\MSO_2\) properties on graphs of bounded tree-width (see Section~\ref{subsec:recalltw}), and then proceed with the description of the new tools required for extending the result to graphs of bounded clique-width, to the cost of reducing the class of certified properties from  \(\MSO_2\) to \(\MSO_1\) (see Sections~\ref{subsec:cw-et-nlcw}-\ref{subsec:summarylabelsize}). 

%-----------------------------------------------------------------------------------------------------------
\subsection{Certifying $\MSO_2$ Properties in Graphs of Bounded Tree-Width}
\label{subsec:recalltw}
%-----------------------------------------------------------------------------------------------------------

Recall that a tree-decomposition of a graph \(G\) is a tree \(T\) where each node \(x\) of \(T\), also called \emph{bag}, is a subset of \(V(G)\), satisfying the following three conditions: 
(1) for every vertex \(v\in V(G)\) there is a bag \(x \in V(T)\) that contains~\(v\), 
(2) for every edge \(\{u,v\} \in E(G)\), there is a bag \(x\) containing both its endpoints, and 
(3) for each vertex \(v \in V(G)\), the set of bags that contains \(v\) forms a (connected) subtree of \(T\). 
Let  \(\Pi\) be an \(\MSO_2\) property, and let $T$ be a tree-decomposition of the  graph~$G$. The proof-labeling scheme aims at providing each vertex with sufficient information for certifying the correctness of~\(T\), as well as the fact that \(G\) satisfies~\(\Pi\). To do so, the certificate of each vertex is divided into two parts, one called \emph{main messages}, and the other called \emph{auxiliary messages}.

\subparagraph{Main messages.} 

 The main message of a node \(v\) is a sequence \(\textrm{seq}_v\) representing a path of bags in \(T\) that connects a leaf with the root, such that \(v\) is contained in at least one bag of \(\textrm{seq}_v\).  For each bag \(x \in \textrm{seq}_v\), the main message includes, roughly: the set of vertices contained in \(x\), the identifier of a vertex \(\ell_x\) in \(x\), called the \emph{leader} of \(x\), and a data structure \(c_x\) used to verify the \(\MSO_2\) property $\Pi$ on~\(G\). The leader \(\ell_x\) of \(x\) is chosen arbitrarily among the vertices of \(x\) that are adjacent to a vertex \(u\) belonging to the parent bag \(p(x)\) of \(x\) in \(T\). The vertex \(u\) is said to be \emph{responsible} for \(x\) in \(p(x)\). Let us assume the following consistency condition: for every bag \(x\) of \(T\),  every vertex in \(x\) received the same information about all the bags from \(x\) to the root of~\(T\). Under the promise that the consistency condition holds, it is possible to show that the vertices can collectively verify that \(T\) is indeed a tree-decomposition of~$G$, and that \(G\) satisfies~\(\Pi\).  

\subparagraph{Auxiliary messages.} 

The role of the auxiliary messages is precisely to check the above consistency condition.  For each bag \(x\), let  \(\tau_x\) be a Steiner tree \revision{(i.e. a minimal tree connecting a set of vertices denoted \emph{terminals})}  in $G$ rooted at the leader~\(\ell_x\), with all the nodes of \(x\) as terminals. Every vertex in \(\tau_x\) receives an auxiliary message containing the certification of~$\tau_x$ \revision{(each vertex of \(\tau_x\) receives the identifier of a root, of its parent and the distance to the root)}, and a copy of the information about \(x\) given to the nodes in the bag~$x$, through their main messages. By using the auxiliary messages, the leader $\ell_x$ can verify whether the subgraph $G[x]$ of \(G\) induced by the union of the bags in \(T[x]\) satisfies~$\Pi$, where \revision{\(T[x]\) the subtree of \(T\) containing \(x\) and all its descendants}. Specifically, this verification is performed by simulating the dynamic programming algorithm in Courcelle's Theorem~\cite{Courcelle90} as in the version of Boire, Parker and Tovey \cite{BoPaTo92}. This uses a \revision{constant-size} data structure \(c_x\) stored in the auxiliary messages that ``encodes'' the predicate \(\Pi(G[x])\). Its correctness can be verified by a composition of the values~\(c_y\) for each child \(y\) of \(x\) in~$T$. The tree \(\tau_x\) is actually used to transfer the information about \(c_y\) from the node $\ell_y$ in \(x\) responsible for~\(y\), to the leader \(\ell_x\).  

\subparagraph{Certificate size.} 

If \(T\) is of depth \(d\), then the main messages are of size \(O(d \log n)\) bits.  Crucially, for every graph \(G\), there is a tree-decomposition \(T\) satisfying that, for every bag \(x\), there is a Steiner tree \(\tau_x\) completely contained in \(G[x]\). Such a decomposition is called \emph{coherent} in~\cite{FraigniaudMRT22} (Lemma 3). It follows that every node participates in a Steiner tree with at most \(d\) bags, which implies that the auxiliary messages can be encoded in \(O(d \log n)\) bits. Thanks to a construction by Bodlaender~\cite{bodlaender1989nc}, it is possible to choose a coherent tree-decomposition with depth \(d = O(\log n)\), up to increasing the sizes of the bags by a constant factor only. It follows that the certificates are of size $O(\log^2n)$ bits. 
 
\bigbreak 

Our construction also follows the general structure described above. However, each element of this construction has to be adapted in a highly non-trivial way. Indeed, the grammar of clique-with, and the related structure of NLC decomposition, differ in several significant ways from the grammar of tree-width. The rest of the section is dedicated to providing the reader with a rough idea of how this can be done. 

%----------------------------------------------------------------------
\subsection{Clique-Width and NLC-Width}
\label{subsec:cw-et-nlcw}
 %----------------------------------------------------------------------
 
 First, instead of working with clique-width, it is actually more convenient  to work with the NLC-width, where NLC stands for \emph{node-label controlled}. Every graph of clique-width at most~$k$ has NLC-width at most~$k$, and every graph of NLC-width at most~$k$ has clique-width at most~$2k$~\cite{Johansson98}. As clique-width, NLC-width can be viewed as the following grammar for constructing graphs, bearing similarities with the grammar for clique-width:
 %
 \begin{itemize}
 \setlength\itemsep{0em}
 \item Creation of a new vertex $v$ with color $i\in\mathbb{N}$, denoted by $\mathsf{newVertex}_i$;
\item Given a set $S$ of ordered pairs of colors, and an ordered pair $(G,H)$ of vertex-disjoint colored graphs, create a new graph as the union of $G$ and $H$, then join by an edge every vertex colored~$i$ of~$G$ to every vertex colored~$j$ of~$H$, for all $(i,j)\in S$; this operation is denoted by $G \Join_S H$;
\item Recolor the graph, denoted by $\mathsf{recolor}_R$ where $R:\mathbb{N}\to\mathbb{N}$ is any function.

\end{itemize}
%
If $k\geq 1$ colors are used, a recoloring function~$R$ is a function $R:[k]\to [k]$. When $R$ is used,  for every $i\in [k]$, vertices with color~$i$ are recolored~$R(i)\in [k]$ (all colors are treated simultaneously, in parallel). Note that the recoloring operation in the definition of clique-width is limited to functions~$R$ that preserve all colors but one. Note also that, for $S=\varnothing$, the operation  $G \Join_S H$ is merely the same as  $G \parallel H$ for clique-width. We therefore use $G \Join_\varnothing H$ or $G \parallel H$ indistinctly. The NLC-width of a graph~$G$ is the smallest number of colors such that $G$ can be constructed using the  operations above. It is denoted by $\nlcw(G)$. For instance, the $n$-node clique can be constructed by creating a first node $v_1$ with color~1, and then repeating, for all $i=1,\dots,n-1$, (1)~the creation of a new node~$v_{i+1}$, with color~1 as well, and (2)~applying $v_{i+1} \Join_{\{(1,1)\}}K_i$ to get the clique~$K_{i+1}$ on $i+1$ vertices. Therefore, cliques can be constructed by using one color only, i.e., $\nlcw(K_n)=1$ for every $n\geq 1$. 

\subparagraph{NLC-decomposition.} For every $k\geq 1$,  the construction of a graph~$G$ with $\nlcw(G)\leq k$ can be described by a binary tree~$T$, whose leaves are the (colored) vertices of~$G$. In~$T$, every internal node~$x$ has an identified  left child~$x'$ and an identified right child~$x''$, and is labeled by~$\parallel$ or~$\Join_S$ for some non-empty set $S\subseteq [k]\times [k]$. This label indicates the operation performed on the (left) graph $G'$ with vertex-set equal to the leaves of the subtree~$T_{x'}$ of~$T$ rooted at~$x'$, and the (right) graph $G''$ with vertex-set equal to the leaves of the subtree~$T_{x''}$ of~$T$ rooted at~$x''$. That is, node $x$ corresponds to the operation $G_{x'}\parallel G_{x''}$ or $G_{x'}\Join_S G_{x''}$, depending on the label of~$x$.  In addition to its label ($\parallel$~or~$\Join_S$ for some~$S\neq\varnothing$), a node may possibly also include a recoloring function~$R:[k]\to [k]$, which indicates a recoloring to be performed \emph{after} the join operation, see Figure~\ref{fig:NLCdec} for an example.

% Figure environment removed

%-----------------------------------------------------------------------------------------------------------
\subsection{From Tree-Width to NLC-Width: The Main Messages}
%-----------------------------------------------------------------------------------------------------------

Let \(\Pi\) be an \(\MSO_1\) property, and let $T$ be an NLC-decomposition tree of a graph \(G\) with \(\cw(G)\leq k\). That is, we can choose the tree \(T\) as one using at most \(k\) colors. In the following, to avoid confusion, we call \emph{vertices} the elements of the vertex set of~\(G\), and \emph{nodes} the elements of the vertex-set of the decomposition tree~\(T\). The structure of our certificates differ from the one in~\cite{FraigniaudMRT22}, and now we decompose the certificate assigned to each node~$v$ into three parts: \emph{main messages}, \emph{auxiliary messages}, and \emph{service messages}. This subsection focuses on the main messages. 

Our main messages have, to some extent, a structure similar to the main messages used in~\cite{FraigniaudMRT22}  for the tree-width.  In particular, vertex \(v\) receives a sequence \(\textsf{path}(v)\), listing all the nodes, i.e., the whole set of operations, in the path from the root of  \(T\)  to the leaf of $T$ where \(v\) was created. For each node \(x\) in $\textsf{path}(v)$, the main message also includes the vertex identifier of a leader for~$x$, called \emph{exit vertex of \(x\)}, and denoted by \(\textsf{exit}(x)\). The main message also includes a data structure \(h(x)\) that encodes the truth value of the \(\MSO_1\) property on \(G[x]\). However, unlike the case of tree-width, where the nodes of the tree-decomposition are sets of vertices (i.e., bags) of bounded size, the contents of a non-leaf node in an NLC-decomposition tree \(T\) does not necessarily include information about the vertices created in \(T[x]\). For that reason, our proof-labeling scheme includes additional information in the main message of \(v\) in order to verify the correctness of the given decomposition. It may actually be worth providing a concrete example to explain the need for additional information. 

\subparagraph{Example.} 

Let us pick an arbitrary edge \(\{u,v\} \in E(G)\), and denote by \((x_1(u), \dots, x_{t_1}(u))\) and \((x_1(v), \dots, x_{t_2}(v))\)  the sequences \(\textsf{path}(u)\) and \(\textsf{path}(v)\), respectively, where \(x_1(u) = x_1(v)\) is the root of \(T\), and \(x_{t_1}(u)\) and \(x_{t_2}(v)\) are the nodes where \(u\) and \(v\) are respectively created.  Let \(x_1, \dots, x_{t_3}\) be the longest common prefix of these two sequences, i.e., the information contained in their main messages coincide on the first  \(t_3\) elements,  but \(x_{t_3+1}(u) \neq x_{t_3+1}(v)\). In the tree~$T$, \(x_{t_3+1}(u)\) and \(x_{t_3+1}(v)\) are two children of \(x_{t_3}\). The sequence of operations described in \(x_{t_1}(u), \dots, x_{t_3+1}(u)\) defines the color \(c(u)\) that \(u\) has in \(x_{t_3+1}(u)\). Similarly, the color \(c(v)\) of \(v\) in \(x_{t_3+1}(v)\) is defined by \(x_{t_2}(v), \dots, x_{t_3+1}(v)\). In order to create the edge \(\{u,v\}\), the operations described in \(x_{t_3}\) must specify a \(\Join\) operation between vertices with color~\(c(u)\) and vertices with color~\(c(v)\). However, the join operations described in an NLC-decomposition tree make a clear distinction between the left and right children of a  node. Therefore, in our example, for checking that the edge \(\{u,v\}\) is indeed correctly created in the given decomposition tree, the vertices \(u\) and \(v\) must be able to distinguish which of the two children \(x_{t_3+1}(u)\) and \(x_{t_3+1}(v)\) of \(x_{t_3}\) is the left child, and which one is the right child. 

\bigbreak

For a node \(x\) different from the root, let us denote by \(p(x)\) the parent of \(x\) in \(T\). The main message of~\(v\) includes 
a sequence \(\textsf{links}(v)\) that specifies, for each node \(x\) in \(\textsf{path}(v)\) different from the root, whether $x$ is the left or right child of \(p(x)\). For instance, in the example of Figure~\ref{fig:NLCdec}, we have  \(\textsf{links}(c) = (1,0)\), indicating that, to reach the leaf creating vertex $c$ from the root, one must follow the right child~(1), and then the left child~(0). S imilarly, \(\textsf{links}(d)=(1,1,0)\).  The sequences \(\textsf{links}\) are
also used to determine the longest common prefixes of the main messages, when the  same operations are repeated between two children of a same node (consider for instance the case where the same operation is performed at all the nodes of the decomposition tree). Back to our example above, let us suppose that the sequences \(\textsf{links}(u)\) and \(\textsf{links}(v)\) specify that \(x_{t_3+1}(u)\) is the left neighbor of \(x_{t_3}\), and \(x_{t_3+1}(v)\) is the right neighbor of \(x_{t_3}\). Using this information, \(u\) and \(v\) can  infer that it is an operation \(\Join_S\), with \((c(u), c(v)) \in S\) that is specified in the description of \(x_{t_3}\). 
With the given information, each vertex can thus check that all its incident edges are indeed created at some node of the decomposition tree~$T$. 

It remains to check that the decomposition does not define non-existent edges. To do so, the main message of every vertex \(v\) also includes, for each node \(x\) in \(\textsf{path}(v)\), and for each \(i \in [k]\),  the integers \(\textsf{color}_i(x)\) representing the number of vertices of \(G[x]\) that are colored \(i\) in the root of \(T[x]\). (Recall that the subgraph $G[x]$ is the subgraph of $G$ induced by the vertices created in the subtree \(T[x]\) of~$T$). Returning to our example, vertex \(v\) checks that it has exactly \(\textsf{color}_{c(u)}(x_{t_3+1}(u))\) neighbors with the same longest common prefix as \(u\) colored \(c(u)\) in the left children of \(x_{t_3}\). Also, vertex \(v\) checks, for each \(i\in [k]\), that the number of vertices colored~\(i\) in node \(x_{t_3}\) corresponds to the sum of the number of vertices colored \(j\) in \(x_{t_3+1}(u)\) and \(x_{t_3+1}(v)\), for each color \(j\) that is recolored \(i\) by the recoloring operation defined in \(x_{t_3}\). So, let us assume that the following consistency condition (analogous to the one for the certification of tree-decompositions) holds: 

\begin{description}
\item[C1:] For every pair of vertices \(u,v \in V(G)\), and for every  node \(x\) in both \(\textsf{path}(u)\) and \(\textsf{path}(v)\),  \(u\)~and \(v\) receive the same information about all nodes in the path from \(x\) to the root of \(T\) in their main messages, and 
\item[C2:]  If \(x\) is the root of \(T\), then the data structure \(h(x)\) describes an accepting instance (i.e., \(G\) satisfies \(\Pi\)). 
\end{description}

Assuming that the consistency condition is satisfied, it is not difficult to show that the vertices can collectively check that the given certificates indeed represent an NLC-decomposition tree, and that \(G\) satisfies \(\Pi\).  The difficulty is however in checking that the consistency condition holds. This is the role of the auxiliary and service messages, described next. 

%-----------------------------------------------------------------------------------------------------------
\subsection{Checking Consistency: Auxiliary, and Service Messages }
%-----------------------------------------------------------------------------------------------------------

We use auxiliary and service messages for allowing our proof-labeling scheme to check the first condition~\textbf{C1} of the consistency condition defined at the end of the previous subsection. 

Auxiliary messages can easily be defined for every node \(x\) of \(T\) satisfying that  \(G[x]\) is connected. In that case, the auxiliary messages of all the vertices \(v\) in \(T[x]\) contain the certificates for certifying a spanning tree \(\tau_x\) of \(G[x]\) rooted at the exit vertex of \(x\). Each vertex \(v\) can verify that the longest common prefix common to $v$ and its parent in \(\tau_x\) contains all the nodes from the root up to \(x\), and that the information given in the main messages coincide for all such nodes. Observe that every vertex \(v\) may potentially contain one auxiliary message for each node in  \(\textsf{path}(v)\). 

 The case where \(G[x]\) is not connected is fairly more complicated, and we need to introduce another type of decomposition. 

\subparagraph{NLC+ decompositions trees.}

 Observe that \(G\) itself is connected. Therefore, there must exist an ancestor \(z\) of \(x\) for which  \(G[z]\) is connected. We could provide the vertices in $G[z]$ with a spanning tree of \(G[z]\) for checking the consistency in \(T[x]\). However, the vertices in \(G[z]\) do not necessarily contain \(x\) in the prefixes of their node sequences, so we would have to put a copy of the main message associated to \(x\) on every node participating in the spanning tree. Since an NLC-decomposition tree does not allow to provide a bound on the distance between \(z\) and \(x\) in the tree, we have no control on how many copies of main messages a vertex should handle.
 
  Therefore, to cope with the case where \(G[x]\) is disconnected, we define a specific type of NLC decompositions trees, called NLC+ decompositions trees. The NLC+ decomposition trees are similar to NLC-decomposition trees, up to two important differences. 
\begin{itemize}
\item First, we allow the nodes corresponding to a \(\parallel\) operation to have arbitrary large arity, and thus NLC+ decomposition trees are not binary trees, as opposed to NLC-decomposition trees. 
\item Second, if a node \(x\) induces a disconnected subgraph \(G[x]\), then its parent node \(p(x)\) must satisfy that \(G[p(x)]\) is connected. Observe that  \(p(x)\) must then correspond to a \(\Join\) operation, and thus $p(x)$ has only two children: $x$ and another child, denoted by $y$. 
\end{itemize}

\subparagraph{Service trees.}

 A \emph{service tree} \(S_x\) for a node \(x\) such that $G[x]$ is disconnected is a Steiner tree in \(G[p(x)]\) rooted at the exit vertex of \(x\), and with all the vertices of \(G[x]\) as terminals. Each vertex of  \(S_x\) (i.e., all vertices in \(G[x]\), plus some vertices in \(G[y]\) is given a \emph{service message}, which contains the certificate for the tree \(S_x\), as well as a copy of the information about \(x\) given in the main messages of the vertices in \(G[x]\). Each vertex in \(S_x\) can then check that it shares the same information about \(x\) than its parent. The properties of the NLC+ decomposition guarantee that a vertex \(v\) participates to at most two service trees, for each node \(x\) in the sequence \(\textsf{path}(v)\). Indeed, vertex \(v\) necessarily participates in \(S_x\) when \(x\) is of type \(\parallel\),  and may also participate in \(S_y\) whenever  the sibling $y$ of \(x\) is of type \(\parallel\). There are significantly more subtle details concerning service trees, but they will be described in Section~\ref{se:cwd}.

It remains to check the second condition~\textbf{C2} of the consistency condition defined at the end of the previous subsection, which consists in verifying the correctness of \(h(x)\), for every node \(x\) of~\(T\). This is explained next. 

%-----------------------------------------------------------------------------------------------------------
\subsection{Dealing with $\MSO_1$ Predicates}
%-----------------------------------------------------------------------------------------------------------

In their seminal work, Courcelle, Makowsky and Rotics~\cite{CourcelleMR00} proved that every $\MSO_1$ predicate $\Pi$ on vertex-labeled graphs can be decided in linear time on graphs of bounded clique-width, and hence on graphs of bounded NLC-width, whenever a decomposition tree is part of the input. The running time of the algorithm is~$O(n)$, i.e., linear in the number~$n$ of vertices of the input graph, with constants hidden in the big-O notation that depend on the clique-width bound, on the number of labels, and on the $\MSO_1$ formula encoding the predicate~$\Pi$.  Note that this result does not hold for $\MSO_2$ predicates, which is why our proof-labeling scheme applies to $\MSO_1$ predicates only. We discuss the possible extension to $\MSO_2$ properties in the conclusion (see Section~\ref{sec:conclusion}).

For our purpose it is convenient to see the linear-time decision algorithm  as a dynamic programming algorithm over the NLC-decomposition tree of the input graph. We formalize this dynamic programming approach following the vocabulary and notations used by Borie, Parker and Tovey~\cite{BoPaTo92}. Note that the latter  provided an alternative proof of Courcelle's theorem, but for graphs of bounded tree-width, i.e., specific to a graph grammar defining tree-width.  To design our proof-labeling scheme, we adapt their approach to a graph grammar defining  NLC-width.

\subparagraph{Homomorphism Classes.}

For a fixed property $\Pi$ and a fixed parameter $k$, there is a finite set $\mathcal{C}$ of \emph{homomorphism classes} (whose size depends only on $\Pi$ and $k$) such that we can associate to each graph  $G$ of clique-width at most \(k\) its class $h(G) \in \mathcal{C}$ \revision{(for more details see Proposition \ref{pr:reg})}. Whenever $G$ is obtained from two graphs $G_1$ and $G_2$ by a $\Join_S$ operation potentially followed by a recoloring operation~$R$, the class $h(G)$ only depends on $h(G_1)$, $h(G_2)$, $S \subseteq [k] \times [k]$, and $R:[k] \to [k]$. This property also holds whenever $\Join_S$ is replaced by $\parallel$. Moreover, we also extend the notion to arbitrary arity so that it holds for the NLC+ decomposition trees. Importantly, Courcelle's theorem~\cite{CourcelleMR00} provides a "compiler" allowing to compute $h(G)$ whenever $G$ is formed by a single vertex of color $j \in [k]$, and to compute $h(G)$ from $h(G_1)$, $h(G_2)$, $S$ and $R$ whenever $G = R(G_1 \Join_S G_2)$. 

\subparagraph{Checking Condition \textbf{C2}.}

In our proof-labeling scheme, for each node $x$ of the NLC+ decomposition tree, we specify \(h(x)\) as the class $h(G[x])$. Following the same principles as before, the consistency of these classes can be checked by simulating a bottom-up parsing of the decomposition tree, in a way very similar to what we described before for checking the consistency of $\textsf{color}(x)$, but replacing the mere additions by updates of the homomorphism classes as described above. 

This completes the rough description of our proof-labeling scheme. 

%-----------------------------------------------------------------------------------------------------------
\subsection{Certificate Size}
\label{subsec:summarylabelsize}
%-----------------------------------------------------------------------------------------------------------

For each vertex \(v\), the main, auxiliary, and service messages of \(v\) can be encoded using \(O(\log n)\) bits for each node \(x\) in \(\textsf{path}(v)\), for the following reasons. 
\begin{itemize}
\item The main message associated to a node \(x\) contains the following information. First, the list of operations described in the node, which can be encoded in \(O(k^2)\) bits.  Second, the corresponding index of \(\textsf{links}\), which is just one bit representing whether \(x\) is the left or right children of its parent. Third, the homomorphism class \(h(x)\) that can be encoded in \(f(k)\) bits for some function~$f$ depending on the $\MSO_1$ property under consideration --- see the remark further in the text for a discussion about~$f$. Finally, it includes the node identifier of the exit vertex of \(x\), and the integers \(\textsf{color}_i\) for each \(i\in [k]\).  All these latter items can be encoded on  \(O(\log n)\) bits. 

\item The auxiliary message associated to node \(x\) (whenever \(G[x]\) is connected) corresponds to the certification of a spanning tree of \(G[x]\), which can be encoded in \(O(\log n)\) bits (see~\cite{KormanKP10}). 

\item For the service messages, note that vertex \(v\) participates in at most two service trees associated to \(x\): the one of \(x\) (whenever \(G[x]\) is disconnected), plus the one of the sibling \(y\) of \(x\) (when \(G[y]\) is disconnected). Again, each of these trees can be certified using \(O(\log n)\) bits.
\end{itemize}

Therefore, the total size of the certificates is \(O(d\cdot \log n)\) bits, where \(d\) is the depth of the NLC+ decomposition tree~\(T\). Our final certificate size depends then on how much we can bound the depth~$d$ of \(T\). Courcelle and Kant\'e \cite{courcelle2007graph} show that there always exists an NLC decomposition tree of logarithmic depth, but it comes with a price: the width of the small depth decomposition can be exponentially larger than the width of the original decomposition. Specifically, Courcelle and Kant\'e have shown that every \(n\)-node graph of NLC-width \(k\) admits an NLC-decomposition of width \(k\cdot 2^{k+1}\) such that the corresponding decomposition tree \(T\) has depth \(\mathcal{O}(\log n)\). Fortunately, our construction of NLC+ decomposition trees does not increase the depth of a given NLC-decomposition tree. In other words, we can use the result of Courcelle and Kant\'e to also show that  NLC+ decomposition trees have logarithmic depth. Overall, we conclude that the certificate size is \(O(\log^2 n)\) bits. 

\subparagraph{Remark.}

Our asymptotic bound on the size of the certificates hides a large dependency on  the clique-width \(k\) of the input graph. For certifying the NLC+ decomposition only, the constant hidden in the big-O notation is single-exponential in $k$, given that the width of the NLC+ decomposition tree with logarithmic depth grows to \(k\cdot 2^{k+1}\). However, for certifying an \(\MSO_1\) property, the dependency on \(k\) can be much larger, as it depends on the number of homomorphism classes.  It is known that, for  $\MSO_1$ properties, the number of homomorphism classes is at most a tower of exponentials in $k$, where the height of the tower depends on the number of quantifiers in the $\MSO_1$ formula. Moreover, this non-elementary dependency on $k$ can not be improved significantly~\cite{FrickGrohe04}. This exponential or even super-exponential dependency on the clique-width~$k$ is however inherent to the theory of algorithms for graphs of bounded clique-width. The same type of phenomenon
 occurs when dealing with graphs of 
 %bounded tree-depth~\cite{FeuilloleyBP22} or 
 bounded tree-width (see~\cite{FrickGrohe04}), and the proof-labeling scheme in~\cite{FraigniaudMRT22} is actually subject to the same type of dependencies in the bound~$k$. On the other hand, the certificate size of our proof-labeling scheme grows only polylogarithmically with the size of the graphs. 

