%:
%!TEX root = main.tex

\section{$\MSO_1$ Properties on Labeled Graphs of Bounded Clique-Width}\label{se:cwd}

This section is dedicated to the proof of Theorem~\ref{theo:main}. To avoid overloading the notation, a labeled graph is simply denoted by~$G=(V,E,\ell)$ where $\ell$ is the vertex-labeling function. We will often simply speak of "graphs" instead of "vertex-labeled graphs". 
Before describing the certificates and the verification protocol, let us first establish some preliminary technical results. 

\subsection{Regularity of $\MSO_1$ predicates}\label{sse:reg}

In their seminal work~\cite{CourcelleMR00}, Courcelle, Makowsky and Rotics proved that any $\MSO_1$ predicate $\Pi$ can be decided in linear time on graphs of bounded clique-width, and hence on graphs of bounded NLC-width, whenever a decomposition tree is part of the input. The running time of the algorithm is linear in the number~$n$ of vertices of the input graph, but the constant hidden in the big-O notation depends on~$k$, on the number of labels and on the $\MSO_1$ formula encoding the predicate $\Pi$. The algorithm in~\cite{CourcelleMR00} is described using tools from automata theory. For our purpose it is more convenient to see it as a dynamic programming algorithm over the decomposition tree of the input graph. Let us formalize this dynamic programming approach following the vocabulary and notations that Borie, Parker and Tovey~\cite{BoPaTo92}. Note that~\cite{BoPaTo92} is alternative proof of Courcelle's theorem on bounded treewidth graphs, specific to a graph grammar defining treewidth; here we simply adapt the definitions to NLC-width and the NLC grammar.

Let $\NLC_k$ denote the class of labeled graphs of graphs of $\NLC$-width at most $k$ and let $\Pi$ be a graph property, assigning to each graph $G$ a boolean value $\Pi(G)$. Intuitively, two graphs $G_1,G_2  \in \NLC_k$ can be considered as equivalent w.r.t. $\Pi$ if, whenever a graph $G'_1 \in \NLC_k$ is obtained by a sequence of NLC operations performed on $G_1$, then the graph $G'_2$ obtained from the same sequence of operations but performed on $G_2$ has the same behaviour w.r.t. property $\Pi$ as $G'_1$. Informally again, a property $\Pi$ is said to be \emph{NLC-regular} if the number of such equivalence classes, that will be called \emph{homomorphism classes} as in~\cite{BoPaTo92}, is upper bounded by a constant: the number of such classes does not depend on the size of the graphs, but only on parameter $k$ and the property $\Pi$ itself. As we shall see, if $\Pi$ is an $\MSO_1$-definable boolean predicate, then it is also NLC-regular, and this is the crux for deciding $\MSO_1$ properties for graphs of bounded NLC-width.

\begin{definition}[NLC-regular property]\label{de:reg}
A graph property $\Pi$ is called \emph{NLC-regular} if, for any value $k$, we can associate a finite set $\cC$ of \emph{homomorphism classes} and a \emph{homomorphism function} $h$, assigning to each graph $G \in \NLC_k$ a class $h(G) \in \cC$ such that:
\begin{enumerate}
\item If $h(G_1) = h(G_2)$ then $\Pi(G_1) = \Pi(G_2)$.
\item For each operation $\Join_S$ there exists a function $\odot_{\Join_S}: \cC \times \cC \rightarrow \cC$ such that, for any two graphs $G_1$ and $G_2$ in $\NLC_k$,
 $$h(\Join_S(G_1,G_2)) = \odot_{\Join_S}(h(G_1),h(G_2)),$$
and for each  operation $\recolor_R$ of there is a function $\odot_{\recolor_R}: \cC \rightarrow \cC$ such that, for any graph $G \in \NLC_k$,
$$h(\recolor_R(G)) = \odot_{\recolor_R}(h(G)).$$
\end{enumerate}
\end{definition}

Observe that NLC-regularity of property $\Pi$ not only implies that the set of homomorphism classes does not depend on the size of the graph, but also that, given an NLC-decomposition of some graph $G \in NLC_k$, the class $h(G)$ can be computed by dynamic programming from the leaves to the root. At each node $x$ of the decomposition tree $T$, the class of $G[x]$, the subgraph of $G$ corresponding to the subtree $T[x]$ rooted at $x$ only depends on the classes at the children nodes, and the operations at node $x$. The first condition of Definition~\ref{de:reg} partitions $\cC$ into a set of accepting classes, i.e., classes $c \in \cC$ such that $h(G) = c \rightarrow \Pi(G)$, and rejecting classes, corresponding to graphs that do not satisfy the property. %An example illustrating Definition~\ref{de:reg}  is provided in Appendix~\ref{example:de:reg}. 


We illustrate Definition~\ref{de:reg} on the predicate $\Pi$ corresponding to non-3-colorability, in order to prove that this predicate is NLC-regular, and how this regularity allows to decide the non-3-colorability on graphs in $\NLC_k$. 
It is  convenient to view a proper 3-coloring of a graph $G$ as a partition of its vertex $V$ set into three independent sets $(X_1, X_2, X_3)$. For such a partition $(X_1, X_2, X_3)$ of a graph $G \in \NLC_k$, $i \in [k]$, we encode this partition as a triple $(b_1,b_2,b_3)$ of boolean vectors of length $k$. Vector $b_j$ encodes the intersection of set $X_j$ with the $k$ possible colours of the NLC decomposition of $G$. That is, $b_j[i] = 1$ if set $X_j$ contains some vertex coloured $i \in [k]$, otherwise $b_j[i] = 0$. Eventually, the homomorphism class $h(G)$ of graph $G$ is the set of all triples $(b_1,b_2,b_3) \in \{0,1\}^k \times  \{0,1\}^k \times \{0,1\}^k$, such that there is some partition of the vertices $G$ into three independent sets $(X_1, X_2, X_3)$ and $(b_1,b_2,b_3)$ is the encoding of this partition as described above. In particular, observe that $G$ is non-3-colourable iff $h(G) = \emptyset$, so $\emptyset$ is the only accepting class.

It is a matter of exercise to see that the number of homomorphism classes is upper bounded by a function on $k$, and even to understand how to construct the class of graphs with a single vertex, and how functions $\odot_{\Join_S}$ and $\odot_{\recolor_R}$ of Definition~\ref{de:reg} can be obtained for all $\Join_S$ and $\recolor_R$ operations. For the sake of completeness, we give the construction in full details.

If $G$ consists of a single vertex $x$ coloured $i$, then the possible partitions of $G$ into three independent sets are $(\{x\},\emptyset,\emptyset)$,  $(\emptyset,\{x\},\emptyset)$ and $(\emptyset,\emptyset,\{x\})$. Thus $h(G)$ is formed by three triples: $(u_{i,k},0^k,0^k)$, $(0^k,u_{i,k},0^k)$, and $(0^k,0^k,u_{i,k})$, where $0^k$ denotes the boolean vector of $k$ zeros, and $u_{i,k}$ is formed of $k-1$ zeros, and a one at position $i$.

Consider now two graphs $G_1,G_2 \in \NLC_k$ and let $G = G_1 \Join_S G_2$ for some $S \in [k] \times [k]$. We describe function $\odot_{\Join_S}$, constructing $h(G)$ from $h(G_1)$ and $h(G_2)$. Note that for each 3-partition $(X_1,X_2,X_3)$ of $G$ into three independent sets, the intersection of $X_1,X_2,X_3$ with the vertex set of $G_1$ (resp. $G_2$) induces a 3-partition $(Y_1,Y_2,Y_3)$ (resp. $(Z_1,Z_2,Z_3)$) into independent sets. Conversely, given partitions  $(Y_1,Y_2,Y_3)$ of $G_1$ and $(Z_1,Z_2,Z_3)$ of $G_2$ into independent sets, $(X_1 = Y_1 \cup Z_1, X_2 = Y_2 \cup Z_2, X_3 = Y_3 \cup Z_3)$ forms a partition into independent sets of $G$ unless operation $\Join_S$ creates an edge between $Y_1$ and $Z_1$, or $Y_2$ and $Z_2$, or $Y_3$ and $Z_3$. Therefore, the homomorphism class of $h(G)$ can be constructed as follows. For each triple of boolean vectors $(y_1,y_2,y_3) \in h(G_1)$ and $(z_1,z_2,z_3) \in h(G_2)$ (corresponding to partitions $(Y_1,Y_2,Y_3)$ of $G_1$ and $(Z_1,Z_2,Z_3)$ of $G_2$ respectively), we add to $h(G)$ the triple $(y_1 \lor z_1, y_2 \lor z_2, y_3 \lor z_3)$ (where $x \lor y$ denotes the bit-wise OR operation), unless there is some pair $(p,q) \in  S$ such that $y_1[p] \land z_1[q]$ or  $y_2[p] \land z_2[q]$ or  $y_3[p] \land z_2[q]$ is true. The latter condition verifies that operation $\Join_S$ does not create an edge in $X_1$ or in $X_2$ or in $X_3$ in graph $G$. 

Eventually, let $G' = \recolor_R(G)$ for some $G \in \NLC_k$, and $R:[k] \to [k]$. We describe function $\odot_{recolor_R}$. Note that $(X_1,X_2,X_3)$ is a partition of $G'$ into independent sets iff it is also a partition of $G$ into independent sets. Therefore we only need to describe how the recoloring $R$ changes the encoding of $(X_1,X_2,X_3)$ from $G$ to $G'$. For each $(b_1,b_2,b_3) \in h(G)$, we add $(\recolor_R(b_1),\recolor_R(b_2), \recolor_R(b_3))$ to $h(G')$, where $b' = \recolor_R(b)$ is defined as follows on boolean vector $b \in \{0,1\}^k$: for each $q \in [k]$ we set $b'[q] = 1$ if and only if there is some $p \in [k]$ such that $R(p) = q$ and $b[p]=1$. In full words, $b'[q]$ is set to true iff the set $X$ encoded by $b$ contains some vertex colored $p$ in $G$, recolored $q$ in $G'$.

This does not only prove that property $\Pi(G)$: ``$G$ is non-3-colourable'' is NLC-regular, but provides all ingredients to decide the property for graphs $G \in \NLC_k$, when a decomposition tree is part of the input. Indeed we need to compute, at each node $x$ of the decomposition tree, the homomorphism class of $G[x]$, the induced subgraph corresponding to thee $T[x]$. At the leaves, graph $G[x]$ is formed by a unique vertex, and as described above the homomorphism class is defined by the colour of that vertex. Then, for each node of the tree, the homomorphism class can be updated from the classes of its children using functions $\odot_{\Join_S}$ and $\odot_{\recolor_R}$. Finally, at the root, we accept if and only if the homomorphism class of the whole graph is the empty set. The running time is linear in the number of nodes of the tree, so it is $O(n)$~--- of course it also depends (exponentially) in parameter $k$.\\

% \subsubsection{Regularity of  $\MSO_1$ predicates}

The result of Courcelle, Makowsky and Rotics~\cite{CourcelleMR00}, although expressed in terms of automata theory (see also Theorem 4.2 in~\cite{GanianH10} for an alternative proof), can be restated as follows:

\begin{proposition}\label{pr:reg}
Any graph property $\Pi$ expressible by an $\MSO_1$ predicate is NLC-regular. Moreover, given the corresponding $\MSO_1$ formula and parameter $k$, one can explicitely compute the set of homomorphism classes $\cC$, as well as   functions $\odot_{\Join_S}$ and $\odot_{\recolor_R}$ for any $S \in [k] \times [k]$ and any $R : [k] \to [k]$, and the homomorphism class of the graph formed by a unique vertex coloured $i$, for any $i \in [k]$.
\end{proposition}

Therefore all $\MSO_1$ properties can be decided in $O(n)$ time on graphs of bounded NLC-width, if a decomposition tree is part of the input; again, the big-Oh notation hides a dependency in $k$ and the $\MSO_1$ formula. We also use these ingredients for our proof labeling scheme.

\subsection{General description $\NLC_+$-Width}

Before getting into the full details of our PLS, let us give a general description of the certification algorithm for an $\MSO_1$ property $\Pi$ on graphs of $\NLC$-width at most~$k$. As in the case of cographs (cf. Section~\ref{se:cographs}), given a graph $G \in \NLC_k$, we use an NLC-decomposition tree~$T_{dec}$ of depth $\mathcal{O}(\log n)$ and of width $k' \leq k\cdot 2^{k+1}$, provided by Lemma~\ref{lem:logdepth}. For any vertex $u$ of $G$, recall that $\textsf{path}(u) = (x_1(u), \dots, x_d(u))$ denotes the path in $T_{dec}$ from the root $x_1(u)$ to the leaf $x_d(u)$ corresponding to the node where vertex $u$ is created (again, we abuse notation by identifying the nodes of the tree with the values describing the operations performed in those nodes). 

As in Section~\ref{se:cographs}, the so-called main message of $u$ contains its identifier~$\id(u)$, the sequence $\textsf{path}(u)$, as well as the sequence $\textsf{links}(u)  = (\ell_1(u), \dots, \ell_{d}(u))$, where, for \(i \geq 2\), $\ell_i(u)\in\{0,1\}$ indicates whether $x_{i}(u)$ is the left or right child of $x_{i-1}(u)$ in~$T_{dec}$, when \(x_{i-1}(u)\) is of type \(\Join\) . For certifying a predicate $\Pi$, let $h_i(u)$ denote the homomorphism class at node $x_i(u)$ w.r.t. ${\Pi}$ restricted to graphs of $\NLC$-width at most \(k'\). That is, for $i=1,\dots,d$, 
\[
h_i(u)=h(G[x_i(u)]).
\]
The sequence 
\begin{equation}\label{eq:sequence-h}
\textsf{h}(u) = (h_1(u), \dots, h_d(u))
\end{equation}
is added to the main message of $u$. Note that, since $d \in \mathcal{O}(\log n)$, each sequence is of logarithmic length. Moreover, for every $i\in\{1,\dots,d\}$,  $(x_i(u), \ell_i(u), h_i(u))$ can be encoded on $O(1)$ bits. Therefore the total size of the main message is $\mathcal{O}(\log n)$. 

Unlike the case of cographs, the diameter of a graph of bounded NLC-width is not necessarily bounded by a constant (i.e., Lemma~\ref{lem:depth2tree} does not hold in general for such graphs). It follows that the main messages cannot be gathered in a single vertex as in cographs. To overcome this difficulty, the prover places additional information in  the main message of $u$. First, %instead of providing only the degree of $u$ in $G$, the prover provides the sequence of degrees 
%\[
%\textsf{deg}(u) = (\deg_1(u), \dots, \deg_d(u))
%\]
%where, for $i=1,\dots,d$, $\deg_i(u)$ denotes the degree of $u$ in $G[x_i(u)]$. 
for each color $j \in [k']$ and \(i \in [d(u)]\) let $\textsf{color}_i^j(u)$ denote the number of vertices colored \(j\) in $G[x_i(u)]$ after the recoloring operations performed at node~$x_i(u)$. The sequence 
\[
\textsf{color}^j(u) = (\textsf{color}^j_1(u), \dots, \textsf{color}^j_d(u))
\]
is also added to the main message of $u$, for all $j\in [k']$. 

Finally, we need to guarantee that, for each node \(x\), every vertex that belongs to \(G[x]\) receives the same information about the operations performed in \(x\), as well as the number of vertices colored with each one of the colors.  This verification is especially hairy for nodes \(x\) where \(G[x]\) is disconnected, where this consistency verification is done with the help of vertices outside \(G[x]\).  In order to cope with this issue, let us slightly modify the notion of NLC-decomposition tree by allowing nodes~$\parallel$ (i.e., nodes of $T_{dec}$ at which a disjoint union operation is performed) to be of arbitrarily large arity (in the original decomposition $T_{dec}$, the arity of an internal node is~2). Moreover all disconnected graphs $G[x]$ will correspond to parallel nodes $x$, and for the parent $y$ of such a node, $G[y]$ has to be connected. Such a decomposition tree will be called an $\NLC_+$-decomposition tree. 

%More precisely, additional information must be added to the certificates for ensuring consistency of the corresponding main messages. 


%The information given in the main messages would be sufficient for verifying~$\Pi$ if, for each node $x$ of the decomposition tree $T_{dec}$, the graph corresponding to $T[x]$ were connected. However, such a connectivity property does not necessarily hold, and it is required to handle the situation where there are nodes $x$ for which $T[x]$ is disconnected. The difficulty comes from the fact that the vertices of $G$ belonging to different connected components do not communicate in the verification part of the protocol\pierre{what do you mean?}. 
\begin{definition}\label{def:nlc+}
Let $k\geq 1$. A rooted tree $T$ is an $\NLC_+$-decomposition tree of width \(k\) if the following conditions holds:  
 \begin{enumerate}
 \setlength\itemsep{0em}
 \item Every leaf of $T$ is labeled $\mathsf{newVertex}_i$, for some \(i \in [k]\);
 \item Every internal node of \(T\) is labelled \(\Join\) or \(\parallel\);
\item Every node labeled  \(\Join\) has exactly \(2\) children, and such a node is associated to a set $S\in [k]\times[k]$ and to a function $\mathsf{recolor}_R$ where $R:[k] \to[k]$;
\item Every node labeled \(\parallel\) has at least 2 children, and, for every node labeled \(\parallel\) distinct from the root, its parent is labeled \(\Join\);
\item \label{item:connectivityNLC+} Every graph defined by the subtree rooted in a \(\Join\) node is connected.
\end{enumerate}
\end{definition}

In Definition~\ref{def:nlc+}, the nodes labeled  \(\Join\)  represent the join and recoloring operations performed as in \(\NLC\)-decomposition trees, i.e., first join, and then recolor.  Similarly, the nodes \(\parallel\)  represent the disjoint union of the graphs defined by their children. However, a crucial difference compare to $\NLC$-decomposition is that instead of systematically involving two vertex-disjoint graphs, the $\NLC_+$-decomposition allows an arbitrary number of vertex-disjoint graphs. Another crucial difference with $\NLC$-decomposition is Condition~\ref{item:connectivityNLC+}, which imposes connectivity of the subgraph hanging at every  \(\Join\) node. 

To cope with the notion of $\NLC_+$-decomposition, we merely extend the functions $\odot$ given in Definition~\ref{de:reg} by introducing the operator \(\odot_{\parallel}\) with arbitrary arity. Specifically, let \(G\) be a graph obtained from the disjoint union of a set of \(\NLC_+\) graphs $\{G_1, \dots, G_p\}$, in any order, with \(p\geq 2\). We define 
\begin{align*}
h(G)  =  \odot_{\parallel }(h(G_1), \dots, h(G_p)) = \odot_{\parallel }\Bigg(h(G_1), \odot_{\parallel }\bigg(h(G_2), \odot_{\parallel }\Big(\dots, \odot_{\parallel }\big(h(G_{p-1}), h(G_p)\big)\Big)\bigg)\Bigg). 
\end{align*}
We say that a graph has \(\NLC_+\) width \(k\) if it can be constructed according to an \(\NLC_+\) decomposition tree of width \(k\). For any node \(x\) of an \(\NLC_+\) decomposition tree \(T\), we also define \(T[x]\) and \(G[x]\) in the same way as for NLC-decompositions trees. We now show that allowing large arity and imposing connectivity does not ruin the good properties of $\NLC$-decomposition.

\begin{lemma}\label{lem:ldc} 
For every $k\geq 1$, all \(n\)-node connected graphs of $\NLC$-width \(k\) have \(\NLC_+\)-decomposition trees of width at most \(k\cdot 2^{k+1}\), and depth \(\mathcal{O}(\log n)\).
\end{lemma} 


The proof of the  lemma is based on the following statement.

\begin{claim}\label{claim:pourlem:ldc} 
Let $G=(V,E)$ be a connected graph of $\NLC$-width $w\geq 1$. Let $T$ be an $\NLC$-decomposition tree of $G$ of width~$w$ and depth~$d$. Then $G$ admits an \(\NLC_+\)-decomposition tree $T_+$  of width~$w$ and depth at most~$2d$. Moreover, the color of each vertex of $G$ at the root of $T_+$ is the same as the color of this vertex at the root of~$T$.
\end{claim}

\begin{proof}
The proof is by induction on $d$. 
The claim is straightforward for $d=1$ as  $T$ is also an \(\NLC_+\)-decomposition tree in this case. Let $d>1$, and let us assume by induction hypothesis that the claim holds for all connected graphs having an NLC-decomposition tree of depth smaller than $d$. Let $x$ be a node of tree $T$ such that $G[x]$ (corresponding to the decomposition subtree $T[x]$) is connected, but, for at least one of the children $z_1,z_2$ of $x$, $G[z_i]$ is disconnected. Note that if no such $x$ exists, then $T$ is an \(\NLC_+\)-decomposition tree, the connectivity condition being satisfied at each node. We choose $x$ closest to the root, in the sense that no other node from $x$ to the root has this property. (Of course, there might be several such nodes $x$, none of them being ancestor of the other in the tree.)
For each $i \in \{1,2\}$, let $D_i^1, D_i^2,\dots, D_i^{p_i}$ be the connected components of $G[z_i]$. Observe that each $D_i^j$, $1\leq j \leq p_i$ has an $\NLC$-decomposition tree $T_i^j$ of depth at most the depth of $T[z_i]$, obtained by trimming from $T[z_i]$ all leaves that do not correspond to vertices of $D_i^j$. By induction hypothesis, graph $D_i^j$ has an \(\NLC_+\)-decomposition tree $T_+(i,j)$ of width $w$ and of depth at most twice the depth of $T[z_i]$.

We obtain the tree $T_+$ as follows. For node $x$, if $G[z_i]$ has a unique component $D_i^1$, we replace the subtree $T[z_1]$ by $T_+(i,1)$. If $G[z_i]$ has several components $D_i^1, D_i^2,\dots, D_i^{p_i}$, then we replace $T[z_i]$ by a subtree of root $\parallel$, with $p_i$ children, the $j$th child being the root of $T_+(i,j)$. Observe that in this way, the label of $x$ remains unchanged, and $T_+[x]$ is an  \(\NLC_+\)-decomposition tree of $G[x]$. By performing in parallel these operations on all such nodes $x$, we obtain an  \(\NLC_+\)-decomposition tree of $G$. The width of the decomposition has not changed. Moreover the depth has been increased by a factor~2 at most. Indeed, for each node $x$, we replaced $T[z_i]$ by subtrees of depth at most twice the original depth, and the node $x$ itself might have caused the addition of a new layer of children labelled $\parallel$. Therefore, the depth of $T_+[x]$ is at most $2 \cdot \max\{\mbox{depth}(T[z_1]),\mbox{depth}(T[z_2])\}$+2, hence at most twice the depth of $T[x]$. Altogether, the depth of $T_+$ is at most twice the depth of $T$. This concludes the induction step, and the proof of  Claim~\ref{claim:pourlem:ldc}. 
\end{proof}

\begin{proof}[Proof of Lemma~\ref{lem:ldc}.]
Thanks to Lemma~\ref{lem:logdepth}, every $n$-node connected graph $G$ of NLC-width $k$ admits an NLC-decomposition tree of width $k \cdot 2^{k+1}$ and depth $O(\log n)$. By Claim~\ref{claim:pourlem:ldc}, we obtain an \(\NLC_+\)-decomposition tree of the same width $k \cdot 2^{k+1}$, and still of logarithmic depth. 
\end{proof}


Let \(T\) be an $\NLC_+$ -decomposition. Recall that, for every node \(x\) of \(T\), we denote by \(h(x)\) the homomorphism class of \(G[x]\) w.r.t. property \({\Pi}\). Moreover, we set 
\begin{equation}\label{eq:sequence-color}
\textsf{color}(x)=(\textsf{color}^1(x), \dots, \textsf{color}^{k'}(x))
\end{equation}
where, for every $j\in \{1, \dots, k'\}$, $\textsf{color}^j(x)$ is the number of vertices colored \(j\) at node~$x$ after the recoloring operations. Finally, we denote by \(\textsf{exit}(x)\) the identifier of some vertex that belongs to \(G[x]\), called the \textit{exit vertex} of \(G[x]\). When \(x\) is of type \(\parallel\) then \(\textsf{exit}(x)\) is an arbitrary vertex in \(G[x]\).  When \(x\) is of type \(\Join\), we have by Definition~\ref{def:nlc+} that \(G[x]\) is connected. Let \(z^0\) and \(z^1\) be the left and right children of \(x\), respectively. Then, we choose \(\textsf{exit}(x)\) as an arbitrary node belonging to \(G[z^0]\) that is adjacent to some node in \(G[z^1]\).

%We have now all the ingredients necessary to describe our proof-labeling scheme. 

\subsection{Certificate Assignment }  

As for cographs, the certificates are divided in several parts, called \emph{main messages} and \emph{auxiliary messages}. We add a third part, called \emph{service messages}. Let us fix some \(\NLC_+\)-decomposition of width \(k\) and depth \(\mathcal{O}(\log n)\) of the input graph \(G\). 

\subparagraph{Main messages.}  
%
These messages are used to check the local correctness of the decomposition tree. The main message of node \(u \in V\) contains the following information. 

\begin{itemize}

\item The sequence \(\textsf{path}(u) = (x_1(u), \dots, x_{d}(u))\) as defined in Section~\ref{se:cographs} for certifying cographs.

\item The sequence \(\textsf{links}(u) = (\ell_1(u), \dots, \ell_{d}(u)) \in \{0,1,\bot\}^d\), representing the sequence of edges that are to be followed to reach \(x_d(u)\) from \(x_1(u)\), similarly to Section~\ref{se:cographs}, but taking into account the presence of nodes  \(\parallel\) with large arity. More precisely, \(\ell_1(u) = \bot\), and for every $i\geq 2$,
\begin{itemize}
\item if \(x_{i-1}(u)\) is of type \(\parallel\) then \(\ell_i(u) = \bot\);
\item if \(x_{i-1}(u)\) is of type \(\Join\) then \(\ell_i(u)= 0 \) whenever \(x_{i}(u)\) is the left children of \(x_{i}(u)\), and  \(\ell_i(u)= 1\) otherwise.  
\end{itemize}

\item The sequence $\textsf{h}(u) = (h_1(u), \dots, h_d(u))$ defined in Eq.~\eqref{eq:sequence-h}.

\item The sequence $\textsf{color}(u) = (\textsf{color}_1(u), \dots, \textsf{color}_d(u))$, such that, for each \(i \in \{1, \dots, d\}\), \(\textsf{color}_i(u)\) is the sequence $\textsf{color}(x_i(u))=(\textsf{color}^1_i(u), \dots,\textsf{color}^{k'}_i(u))$ defined in Eq.~\eqref{eq:sequence-color}. 


\item The sequence \(\textsf{exit}(u) = (\textsf{exit}_1(u), \dots, \textsf{exit}_d(u))\), where, for each \(i \in \{1, \dots, d\}\), \(\textsf{exit}_i(u)\) is the identifier of node \(\textsf{exit}(x_i(u))\). 
\end{itemize}

\noindent In the following, for every \(i \in [d]\), we denote
 $
 \textsf{main}(u)= (\textsf{main}_1(u), \dots, \textsf{main}_d(u))
 $
 where, for each \(i \in [d]\),
\[ 
\textsf{main}_i(u)  = \Big( x_i(u),\; \ell_i(u),\; h_i(u),\; \textsf{color}_i(u),\; \textsf{exit}_i(u) \Big).
\]

\subparagraph{Auxiliary messages.} 
%
These messages are used to certify the connectivity of the subtrees rooted at nodes \(x\) of type \(\Join\). Let \(z^0\) and \(z^1\) be the children of \(x\) in \(T\). An \emph{auxiliary tree associated to \(x\)}, denoted by~\(A(x)\),  is a spanning tree of \(G[x]\). In the auxiliary messages, we certify the existence of \(A(x)\) using the standard certification for trees~\cite{KormanKP10}. That is, we give each node of the tree the identifier of the root, the identifier of its parent, and its distance to the root.  We also use the auxiliary messages to certify that each vertex created in \(G[z^0]\) (respectively \(G[z^1]\)) received the same information about \(z^0\). Formally, every vertex~\(u\) receives the sequence 
\[
\textsf{aux}(u) = (\textsf{aux}_1(u), \dots, \textsf{aux}_{d}(u))
\]
where, for each \(i \in \{1, \dots, d\}\), \(\textsf{aux}_i(u)=\bot\) whenever \(x_i(u)\) is of type $\parallel$, and, otherwise, 
\[
\textsf{aux}_i(u)= (\textsf{root}_i(u), \textsf{parent}_i(u), \textsf{distance}_i(u), \textsf{childrenMain}_i(u))
\] 
where 
\begin{itemize}
 \setlength\itemsep{0em}
\item \( \textsf{root}_i(u)\) is the identifier of the node \(\textsf{exit}(x_i(u))\);
\item  \( \textsf{parent}_i(u)\) is the identifier of the parent of \(u\)  in \(A(x_i(u))\), where  \(\textsf{parent}_i = \bot\) if $u = \textsf{root}_i(u)$;
\item \( \textsf{distance}_i(u)\) is the distance  between \(u\) and \(\textsf{exit}(x_i(u))\)  in \(A(x_i(u))\);
%\item \(\textsf{terminals}_i(u)\) is a pair of vertex identifiers representing \(\textsf{exit}(z_0), \textsf{exit}(z_1)\). 
%\item \(\textsf{terminalClasses}_i(u)\) is a pair of  classes for \(\equiv_{\Pi}\) representing the pair \((h(z_0), h(z_1))\).
%\item  $\textsf{terminalColors}_i(u)$ represents the pair \((\textsf{color}(z_0), \textsf{color}(z_1))\)
\item \(\textsf{childrenMain}^j_i(u)=(z^j, h(z^j), \textsf{color}(z^j), \textsf{exit}(z^j))\) for \(j \in \{0,1\}\). %\ioan{Est-ce qu'on ne devrait pas garder aussi l'indice $i$ dans $z^j$?}
%\item \(\textsf{boolPair}_i(u)\) is a pair of Booleans \((\textsf{bool}_i^0(u), \textsf{bool}_i^1(u))\)  where \(\textsf{bool}_i^0(u)\) (respectively \(\textsf{bool}_i^1(u)\)) is true and only if \(\textsf{ex}_i^0(u)\) (respectively \(\textsf{ex}_i^1(u)\)) appears in the subtree of \(A(x_i(u))\) rooted at \(u\).
\end{itemize}

\subparagraph{Service messages.}  These messages are used to check consistency in the subgraphs induced by the subtrees rooted at nodes of type \(\parallel\). In other words, they are used to handle the case of nodes in the tree~$T$ constructing non-connected subgraphs. Before explaining these messages, let us define some additional data structures. 

Let \(x\) be a node of type \(\parallel\), and let $y$ denote the parent of $x$ in $T$. Again by Lemma~\ref{lem:ldc}, for each child $z_i$, $1 \leq i \leq p$, of $x$,  the graph $G[z_i]$ corresponds to a connected component of the graph $G[x]$ (which is disconnected by construction). A \emph{service tree associated to} \(x\), denoted by \(S(x)\), 
is a Steiner tree in \(G[y]\) with terminals \(\{\textsf{exit}(z_1), \dots, \textsf{exit}(z_p)\}\), and root \(\textsf{exit}(x)\). The service messages are used to certify the existence of \(S(x)\) in a  way similar to the auxiliary tree.  We also use the service messages  to certify the consistency between \(h(z_1), \dots, h(z_p)\) and \(h(x)\).  This latter certification is slightly more complicated than for auxiliary trees because a parallel node may have an arbitrarily large number of children, and one cannot store  the identifiers, the classes and the colors of all the terminals if one want to keep the certificate size small.


Let \(u\) be a vertex in \(S(x)\). The service message of \(u\) contains the root of \(S(x)\), the parent of \(u\), and the depth of \(u\) in \(S(x)\). Let us denote by \(S(x,u)\) the subtree of \(S(x)\) rooted at~\(u\).  Furthermore, let us call \(\textsf{inCharge}_x(u)\) the set of the indices of the terminals of \(S(x)\) contained in \(S(x,u)\). Formally,
\[
\textsf{inCharge}_x(u) = \{i \in \{1, \dots, p\} \mid \textsf{exit}(z_i) \in S(x,u) \} 
\]
Now let us denote by \( G[ \textsf{inCharge}_x(u) ] \) the subgraph of \(G\) induced by the disjoint union of all graphs \(G[z_i]\), \(i \in \textsf{inCharge}_x(u)\). The service message of \(u\) includes the homomorphism class \(h(G[ \textsf{inCharge}_x(u) ])\). The correctness of this homomorphism class will be verified using only  the homomorphism classes of the children of \(u\) in \(S(x)\).  Observe that \(S(x, \textsf{exit}(x)) = S(x)\), and \[h(G[ \textsf{inCharge}_x(\textsf{exit}(x))] = h(x).\]

Observe that node  \(u\) is necessarily contained in \(G[y]\), but not necessarily in \(G[x]\). Therefore, it is possible that \(x\) does not appear in the main message of \(u\). Therefore, for each \(j \in \{0,1\}\), vertex \(u\) also receives the sequence
\[
\textsf{service}^j(u) = (\textsf{service}^j_1(u), \dots, \textsf{service}^j_{d}(u)), 
\]
where, for each \(i \in [d]\), the value of \(\textsf{service}^j_i(u)\) represents the part of the certification of the service tree \(S(x)\), where \(x\) is the left child (respectively the right child) of \(x_{i-1}(u)\). 
Specifically, if \(x\) is not of type \(\parallel\), or if \(u\) does not participate in \(S(x)\), then \(\textsf{service}^j_i(u)=\bot\). Otherwise, 
\[
\textsf{service}^j_i(u) = (\textsf{root}^j_i(u), \textsf{parent}^j_i(u), \textsf{distance}^j_i(u), \textsf{class}^j_i(u), \textsf{colorCharge}^j(u))
\]
where
\begin{itemize}
 \setlength\itemsep{0em}
\item \( \textsf{root}^j_i(u)\) is the identifier of the root of \(S(x)\); 
\item  \( \textsf{parent}^j_i(u)\) is the identifier of the parent of \(u\)  in \(S(x)\), with \(\textsf{parent}^j_i (u)= \bot\) if \(u = \textsf{root}^j_i(u)\),;
\item \( \textsf{distance}^j_i(u)\) is the distance between \(u\) and the root \(\textsf{exit}(x)\)  in \(S(x)\);
\item \(\textsf{class}^j_i(u)\) is the homomorphism class of \(G[\textsf{inCharge}_{x}(u)]\);
\item  $\textsf{colorCharge}_i^j(u)=(\textsf{colorCharge}_i^{j,1}(u), \dots, \textsf{colorCharge}_i^{j,k'}(u))$ where $\textsf{colorCharge}_i^{j,s}(u)$ is the number of vertices colored $s$ in $G[\textsf{inCharge}_{x}(u)]$, for every $s \in [k']$.
\end{itemize}


\subsection{Verification Scheme} 
%
The main role of the verification procedure is to check that  the \(\NLC_+\)-decomposition tree is correct, that is (1)~it corresponds to the graph $G$, and (2)~at each node $x$ of the decomposition tree, the homomorphism class for property $\Pi$ provided by the prover corresponds to $h(G[x])$.

Each vertex \(u \in V\) checks that all its messages in its certificate are correctly formatted.  Then, the verification is split in three parts: (1)~verification of the main messages, (2)~verification of the auxiliary messages, and (3)~verification of the service messages. 
 
\subparagraph{Verification of main messages. }

Each vertex \(u \in V\) verifies the following conditions:

\begin{enumerate}

\item \label{verif:1} \(x_{d}(u)\) is of type $\mathsf{newVertex}_s$ for some \(s \in [k']\);
\item  \label{verif:2} $\textsf{exit}_d(u)=\id(u)$;
\item  \label{verif:3} \(\textsf{color}^j_d(u) = 0\) for every \(j\in [k']\setminus\{s\}\), and \(\textsf{color}^s_d(u) = 1\);
 \item  \label{verif:4} \(h_d(u)\) is the homomorphism class for \({\Pi}\) of a graph equal to a single node labelled $\ell(u)$, colored $s$;
 \item  \label{verif:5} \(x_1(u)\) is of type~\(\Join\), and for each \(i\in \{2, \dots, d(u)\}\), if \(x_i\) is of type \(\parallel\) then \(x_{i-1}(u)\) is of type \(\Join\);
 \item \label{verif:5.1} \(h_1(u)\) is an \emph{accepting} homomorphism class for \({\Pi}\), i.e., graphs of \(\NLC_{+}\)-width \(k'\) having this class satisfy~\(\Pi\).
\end{enumerate}
Let us define \(\mathsf{currentcolor}(u,i)\) in the same way that we did in the verification of cographs. Moreover, for a vertex \(v\in V\), let us denote \(i^*=\textsf{index}(u,v)\) as the maximum index \(i\in [d(u)]\) such that \(\ell_j(u) = \ell_j(v)\) for every \(j \leq i\). Then, \(u\) computes \(\textsf{index}(u,v)\) for each of its neighbors \(v\in N(v)\), and checks:


\begin{enumerate}
\setcounter{enumi}{6}
\item \label{verif:6} \(\textsf{main}_i(u) = \textsf{main}_i(v)\) for every \(i \leq i^*\).
%All the sequences given in the main messages to \(u\) have a common prefix with the ones given to \(v\). Formally, \(u\) verifies that for every \(i \leq \textsf{index}(u,v)\), \(x_i(u) = x_i(v)\),  \(\textsf{children}_i(u) = \textsf{children}_i(v)\), \(h_i(u) = h_i(v)\), \(\textsf{deg}_i(u) = \textsf{deg}_i(v)\), \(\textsf{exit}_i(u) = \textsf{exit}_i(v)\) and also for every \(j\in [k']\),  \(\textsf{color}^j_i(u) = \textsf{color}^j_i(v)\). 

  
\item \label{verif:7} \(x_{i^*}(u)\) is of type \(\Join\), and 
\begin{itemize}
\item   if \(\ell_{i^*+1}(u) = 0\) then \(u\) checks that \(x_{i^*}\) contains the join operation $\Join_S$ with \[(\mathsf{currentcolor}(u,i^*), \mathsf{currentcolor}(v,i^*)) \in S\]
\item   if \(\ell_{i^*+1}(u) = 1\) then \(u\) checks that  \(x_{i^*}\) contains the join operation $\Join_S$ with \[(\mathsf{currentcolor}(v,i^*),\mathsf{currentcolor}(u,i^*)) \in S.\]
\end{itemize}

\item \label{verif:11} For each \(j \in [k']\), vertex \(u\) checks that it has exactly \(\textsf{color}^j_{i^*+1}(v)\) neighbors \(w\) such that \(\textsf{index}(u,w) = i^*\), \(\ell_{i^*+1}(w) \neq \ell_{i^*+1}(u)\), and \(\mathsf{currentcolor}(w,i^*+1) = j\);

%\item \label{verif:8} Vertex $u$ checks that its degree $\textsf{deg}_{i^*}(u)$ at node $x_{i^*}$ corresponds to its degree $deg_{i^*+1}(u)$, plus the cardinality of the set \(\{v \in N(u) \mid \textsf{index}(u,v) = i^*\}\).  Vertex \(u\) also verifies that \(\textsf{deg}_1(u)\) corresponds to its degree in \(G\).

\item \label{verif:9} Vertex $u$ then considers the homomorphism classes $h_{i^*}(u)$, $h_{i^*+1}(u)$ and $h_{i^*+1}(v)$. (Recall that these encode the homomorphism classes of relation ${\Pi}$ for graphs $G[x_{i^*}(u)]$, $G[x_{i^*+1}(u)]$ and $G[x_{i^*+1}(v)]$, respectively.) 
\begin{itemize}
\item If \(\ell_{i*+1} = 0\) then $x_{i^*+1}(u)$ must be the left child of $x_{i^*}(u)$, and vertex  $u$ checks that \[h_{i^*}(u) = \odot_{\mathsf{recolor}_R} (\odot_{\Join_S}(h_{i^*+1}(u), h_{i^*+1}(v))).\] 
\item If  \(\ell_{i*+1} = 1\) then $x_{i^*+1}(u)$ must be the right child of $x_{i^*}(u)$, and vertex  $u$ checks  that \[h_{i^*}(u) = \odot_{\mathsf{recolor}_R} (\odot_{\Join_S}(h_{i^*+1}(v)),h_{i^*+1}(u)).\] 
\end{itemize}


\item \label{verif:10}  For each \(j\in [k']\), \[\textsf{color}^j_{i^*}(u) = \sum_{s \in R^{-1}(j)}  \left(\textsf{color}^{s}_{i^*+1}(u) + \textsf{color}^{s}_{i^*+1}(v)\right).\]


\item  \label{verif:12} Finally, for each \(i \in [d(u)]\) such that \(x_{i}(u)\) is of type \(\Join\), if \(\textsf{exit}_i(u)=\id(u)\), then \(u\) checks that \(\ell_{i+1}(u) = 0\), and that there exists \(v\in N(u)\) such that \(\textsf{index}(u,v) = i\) and \(\ell_{i+1}(v) = 1\).
\end{enumerate}

\subparagraph{Verification of auxiliary messages.}  

For every \(i \in [d(u)]\) vertex \(u\) checks that \(\textsf{aux}_i \neq \bot \) if and only if \(x_i(u)\) is of type \(\Join\). Let us suppose now that \(\textsf{aux}_i \neq \bot\). Then \(u\) checks the following conditions

\begin{enumerate}
\setcounter{enumi}{12}
\item \label{verif:13} \(\textsf{root}_i(u) = \textsf{exit}_i(u)\);
\item  \label{verif:14} if \( \textsf{parent}_i(u) = \perp\) then \(\textsf{root}_i(u)=\id(u)\);
 \item  \label{verif:15} if \(v = \textsf{parent}_i(u) \neq \bot\) then \(v \in N(u)\), \(\textsf{index}(u,v) \geq i\), \(\textsf{aux}_i(v) \neq \perp\), \(\textsf{root}_i(v) = \textsf{root}_i(u)\), \(\textsf{childrenMain}^0_i(u) = \textsf{childrenMain}^0_i(v) \),  \(\textsf{childrenMain}^1_i(u) = \textsf{childrenMain}^1_i(v) \), and \[\textsf{distance}_i(v) = \textsf{distance}_i(u) -1;\]
\item  \label{verif:16} if \(j = \ell_{i+1}(u) \) then \(\textsf{childrenMain}^j_i(u) = \textsf{main}_{i+1}(u)\).  


%For each \(j \in \{0,1\}\), if \(u\) is the identifier of \(\textsf{ex}_i^j(u)\), then \(\textsf{bool}_i^j(u) = \texttt{true}\). If \(u \neq \textsf{ex}_i^j(u)\), we define \(\textsf{children}_i(u) = \{w \in V: \textsf{parent}_i(w) = u\}\).  If \(\textsf{children}_i(u) = \emptyset\) then \( \textsf{bool}_i^j = \texttt{false}\). If \(\textsf{children}_i(u) \neq \emptyset\) then,
 %\[\textsf{bool}(u)_i^j=\bigvee_{w \in \textsf{children}_i(u)} \textsf{bool}_i^j(w) \].
\end{enumerate}


\subparagraph{Verification of service messages.}   

For every \(i \in [d(u)]\) and \(j \in \{0,1\}\) for which \(\textsf{service}^j_i(u)\neq \perp\), \(u\) checks the following conditions:


\begin{enumerate}
\setcounter{enumi}{16}
\item \label{verif:17}  If \(\ell_i(u) = j\) then \(x_i(u)\) is of type \(\parallel\).

\item  \label{verif:18} If \(v = \textsf{parent}^j_i(u) \neq \perp\) then \(v \in N(u)\), \(\textsf{index}(u,v) \geq i-1\), \(\textsf{service}^j_i(v) \neq \perp\), \(\textsf{root}^j_i(v) = \textsf{root}^j_i(u)\) and \(\textsf{distance}^j_i(v) = \textsf{distance}_i^j(u) -1\).
\item  \label{verif:19} If \( \textsf{parent}^j_i(u) = \perp\) then \(\textsf{root}^j_i(u)=\id(u)\).
%\item \label{verif:14} If \(j = \ell_i(u)\), then 
%\(\displaystyle{\textsf{index}(u,v) \leq \left\{ \begin{array}{cl} i  & \text{if } x_{i+1}(u) \text{ is of type} \parallel, \text{ and}\\  i+1 & \textsf{if } x_{i+1}(u) \text{ is of type} \Join. \end{array}\right.}\)\\
%If \(j \neq \ell_i(u)\), then 
%\(\displaystyle{\textsf{index}(u,v) \leq \left\{ \begin{array}{cl} i  & \text{if } x_{i+1}(v) \text{ is of type} \parallel, \text{ and}\\  i+1 & \textsf{if } x_{i+1}(v) \text{ is of type} \Join. \end{array}\right.}\)

\end{enumerate}
If \(u\) has no neighbors \(w \in V\) such that \(\textsf{parent}^j_i(w) = u\), then \(u\) deduces that it is a leaf of the tree \(S(x_i^j)\). In that case, \(u\) checks the following conditions:
\begin{enumerate}
\setcounter{enumi}{19}

\item \label{verif:20}  \(u\) is a terminal, so \(\textsf{exit}_{i+1}(u)=\id(u)\);%\pierre{It's a claim, or something to be checked?}
\item \label{verif:21} \(\textsf{class}_i^j(u) = h_{i+1}(u)\) and \(\textsf{colorCharge}_i^j(u) = \textsf{color}_{i+1}(u)\).%, and \(\textsf{numCharge}_i^j(u) = 1\).

\end{enumerate}
If $u$ is not a leaf of \(S(x_i^j)\), then \(u\) computes the set \(\textsf{children}_i^j(u)\) of nodes  \(w\in V\) such that \({\textsf{parent}_i^j(w)=u}\). Then \(u\) checks the following conditions:

\begin{enumerate}
\setcounter{enumi}{21}
%\item \label{verif:22} Let \(\delta = 1\) if \(u = \textsf{exit}_{i+1}(u)\) and \(\ell_i(u) = j\). Otherwise, \(\delta = 0\). Then \(u\) checks that: \[\displaystyle{\textsf{numCharge}_i^j(u)  = \sum_{w \in \textsf{children}_i^j(u)} \textsf{numCharge}_i^j(w) + \delta.}\]
\item \label{verif:23} For each \(s\in [k']\), let \(\gamma = \textsf{color}_{i+1}^s(u)\) if \(u = \textsf{exit}_{i+1}(u)\) and \(\ell_i(u) = j\), and let  \(\gamma = 0\) otherwise.  Then \(u\) checks that: 

\[\textsf{colorCharge}^{j,s}(u)  = \sum_{w \in \textsf{children}_i^j(u)} \textsf{colorCharge}^{j,s}(w) + \gamma\]



\item \label{verif:24} If \(\textsf{children}_i^j(u)\) contains a single vertex \(w\), then \(u\) checks that \(\textsf{class}_i^j(u) = \textsf{class}_i^j(w)\).  
\item \label{verif:25} If \(\textsf{children}_i^j(u)\) contains two or more vertices, then \(u\) defines an arbitrary order of the vertices in \(\textsf{children}_i^j(u)\), namely \(w_1, \dots, w_p\). Then, \(u\) defines a sequence of homomorphism classes \(c_1, \dots, c_{p}\) where, \(c_1 = \textsf{class}_i^j(w_1)\), and for each \(i \in \{2, \dots, p\}\):
\[c_i = \odot_{\parallel} (c_{i-1},  \textsf{class}_i^j(w_{i})).\]
where \(\odot_{\parallel}\) corresponds to the function \(\odot_{\Join_{\emptyset}}\). Finally checks that \(c_p = \textsf{class}_i^j(u) \).
\end{enumerate}
 If \(u = \textsf{exit}_{i}(u)\), then \(u\) checks the following additional conditions for each \(j \in \{0,1\}\):
\begin{enumerate}
\setcounter{enumi}{24}
\item \label{verif:26} \(\textsf{parent}_i^j(u) = \bot\), and  \(\textsf{distance}_i^j(u) = 0\);
\item \label{verif:27} \(\textsf{class}_i^j(u) = h_{i}(u)\), and \(\textsf{colorCharge}_i^j(u) = \textsf{color}_{i}(u)\).%, and \(\textsf{numCharge}_i^j(u) = \textsf{children}_{i+1}(u)\).
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%
\subsection{Completeness and Soundness} 
%
The completeness follows directly from the existence of an $\NLC_+$-decomposition $T$ of $G$ as described in Lemma~\ref{lem:ldc} and from the construction of the main, auxiliary and service messages, based on this decomposition. 

For soundness, assume that the verification protocol accepts at every vertex.  Let us define the set of all main messages as \(\textsf{mainset} = \{\textsf{main}(u) : u \in V\}\), and let \(d^* = \max_{u\in V} d(u)\). For every \(M \in \textsf{mainset}\) we denote \(d(M) = d(u)\) where \(u\) is such that \(\textsf{main}(u) = M\). Now, we define  \(\textsf{Prefix}(M,i)\) as the set of vertices \(v\in V\) that have the same first \(i\) values in their main messages. Formally,  
\[
\textsf{Prefix}(M,i) = \{v \in V: M_j = \textsf{main}_j(v),  \textrm{ for every } 1\leq  j \leq  i\}.
\] 
By condition~\ref{verif:2} in the verification protool, \(\textsf{exit}_{d}(u)=\id(u)\). Thus \(\textsf{main}(u) \neq \textsf{main}(v)\) for every pair of vertices \(u \neq v\). Therefore, \(\textsf{Prefix}(\textsf{main}(u),d(u)) = \{u\}\). Also, by condition~\ref{verif:6} we have that \(\textsf{Prefix}(M,1) = V\). Given \(M \in \textsf{mainset}\),  and \(i \in [d(M)]\), let 
\[
M_i = (x_i(M), \ell_i(M), h_i(M), \textsf{color}_i(M), \textsf{exit}_i(M))
\] 
be the list \(\textsf{main}_i(v)\) for a vertex \(v\) such that \(\textsf{main}(v) = M\).


\begin{lemma}\label{lem:completeness} 
For every \(M \in \textsf{mainset}\), and every \(i \in [d(M)]\), there exists a \(\NLC_+\)-decomposition tree \(T[M,i]\) of \(G[M,i] = G[\textsf{Prefix}(M,i)]\)  such that, for all \(u \in \textsf{Prefix}(M,i)\), the following holds. 
\begin{itemize}
\item For every $j$ with \(i \leq j \leq d(u)\), \(x_j(u)\) contains the operations in the \(j\)-th node in path from the root of \(T[M,i]\) to the node where \(u\) is created;
\item \(h_i(u) = h(G[M,i])\);
\item  For every \(s\in [k']\), \(\textsf{color}^s_i(u) \) is the number of vertices colored \(s\) in the root of \(T[M,i])\).
\end{itemize}
\end{lemma}

\begin{proof}
The proof is by induction on \(i\), in decreasing order for each \(M\). Let us fix \(M \in \textsf{mainset}\). The base case is \(i = d(M)\), and \(\textsf{Prefix}(M,d(M))\) is a single vertex \(u\) satisfying \(\textsf{main}(u) = M\).  In this case the lemma is true by conditions~\ref{verif:1}-\ref{verif:4}. For the inductive case, let us suppose that there exists \(t >1 \)  such that the lemma is true for every \(M \in \textsf{mainset}\), and \(i \in \{t, \dots, d(M)\}\), and let us show that the lemma holds an arbitrary  pair \(M \in \textsf{mainset}\) and \(i = t-1\). 

\medskip

\noindent -- Let us suppose first that \(x_{i}(M)\) is of type \(\Join\). Consider the set
\[
\beta_i(M) =  \{(\textsf{root}_i(u), \textsf{parent}_i(u),  \textsf{distance}_i(u)) \mid u \in \textsf{Prefix}(M,i)\}.
\] 
From conditions~\ref{verif:13}-\ref{verif:15}, we have that \(\beta_i(M)\) certifies a spanning tree of \(\textsf{Prefix}(M,i)\) rooted at \(\textsf{exit}_i(M)\). In particular, we have that \(\textsf{Prefix}(M,i)\) induces a connected subgraph of \(G\). Let us call \(u^0\) the vertex with identifier \(\textsf{exit}_i(M)\). By condition~\ref{verif:12}, we have \(\ell_{i+1}(u^0) = 0\), and there exists a vertex \(u^1 \in N(u)\) such that \(\textsf{index}(u,v) = i\) and \(\ell_{i+1}(u^1) = 1\). Let us call \(M^0= \textsf{main}(u^0)\) and \(M^1 = \textsf{main}(v^1)\). Our candidate for \(T[M,i]\) is the tree defined by a root \(x_i(M)\) with two children. The left children induces the subtree \(T[M^0, i+1]\) while the right children induces the subtree \(T[M^1,{i+1}]\).

Observe first that \(\textsf{Prefix}(M, i)\) can be partitioned in \(\textsf{Prefix}(M^0, i+1)\) and  \(\textsf{Prefix}(M^1, i+1)\). Indeed, let \(w\) be a vertex in \(\textsf{Prefix}(M, i)\), and let \(j =\ell_{i+1}(w) \). By condition~\ref{verif:16},   we have that \(\textsf{childrenMain}^j_i(w)=\textsf{main}_{i+1}(w)\). By condition~\ref{verif:15}, and the fact that \(\textsf{Prefix}(M, i)\) is connected, we have that \(\textsf{main}_{i+1}(w) = \textsf{main}_{i+1}(w')\) for every \(w' \in \textsf{Prefix}(M, i)\) for which \(\ell_{i+1}(w') = j\). In particular \(\textsf{main}_{i+1}(w) = \textsf{main}_{i+1}(u^j)\), and therefore \(w\)  belongs to \(\textsf{Prefix}(M^j, i+1)\).


By the induction hypothesis, for each \(j\in \{0,1\}\), \(T[M^j, i+1]\) is an \(\NLC_+\) decomposition tree of \(G[M^j, i+1]\). Moreover, \(h_{i+1}(M^j) = h(G[M^j, i+1])\), and, for each \(s\in [k']\), we have that \(\textsf{color}^s_{i+1}(M^j)\) is the number of vertices colored \(s\) in the root of \(T[M^j, i+1]\).
Let \(S\) be the set of join operations defined in \(x_i(M)\), and let \(u \in \textsf{Prefix}(M^0,i+1)\) and \(v \in \textsf{Prefix}(M^1,i+1)\) be such that \(\{u,v\} \in E(G[\textsf{Prefix}(M,i)])\). By condition~\ref{verif:7}, we have that 
\[
(\textsf{currentcolor}(u,i), \textsf{currentcolor}(v,i)) \in S.
\] 
Moreover, by condition~\ref{verif:11}, vertex \(u\) has exactly \(\textsf{color}_{i+1}^s(M^1)\) neighbors  \(v \in \textsf{Prefix}(M^1,i+1)\) such that \(\textsf{currentcolor}(v,i) = s\). This implies that  the join operations defined in \(x_i(M)\) create exactly the set of edges \(\{u,v\} \in E(G[M,i])\) such that \(\textsf{index}(u,v) = i\), and no other edges. It follows that \(T[M,i]\) is an \(\NLC_+\)-decomposition tree of \(G[M,i]\). Finally, by condition~\ref{verif:9} applied at \(u^0\), we have that \(h_i(M) = h(G[M,i])\), and, by condition~\ref{verif:10} applied at \(u^0\), we have that, for every \(s\in [k']\), \(\textsf{color}_i^s(M)\) is the number of vertices colored \(s\) in the root of \(T[M,i]\).

\medskip 

\noindent -- Let us suppose now  that \(x_{i}(M)\) is of type \(\parallel\), and let us define the following subset of \textsf{mainset}:
\[\textsf{mainPrefix}(M,i) = \{ M' \in \textsf{mainset} \mid \textsf{Prefix}(M,i) = \textsf{Prefix}(M',i) \}\]
Observe that from the induction hypothesis, we have that, for each \(M' \in \textsf{mainPrefix}(M,i)\), there is an \(\NLC_{+}\)-decomposition tree  \(T[M',i+1]\) of \(G[M',i+1]\), satisfying the conditions of the lemma.
Our candidate for \(T[M,i]\) is a tree rooted in  \(x_{i}(M)\), where the children of \(x_{i}(M)\) induce the set of trees 
\[
\{ T[M', i+1]: M' \in \textsf{mainPrefix}(M,i) \}.
\]
Indeed,  every vertex \(u\) in \(\textsf{Prefix}(M,i)\) satisfies that \(x_i(u) = x_i(M)\). Then, by condition~\ref{verif:7},  \(u\) cannot have a neighbor \(v\) such that \(\textsf{index}(u,v) = i\). Therefore \(T[M,i]\) does define an \(\NLC_{+}\) decomposition of  \(G[M,i]\). Let \(j = \ell_{i}(M)\), and let us consider the set
\[
\alpha_i^j(M) =  \{(\textsf{root}^j_i(u), \textsf{parent}^j_i(u),  \textsf{distance}^j_i(u)) \mid u \in \textsf{Prefix}(M,i-1) \; \text{and} \; \textsf{service}_i^j(u) \neq \bot\}.
\] 
Let \(u\) be a vertex such that \(\textsf{main}(u) \in \textsf{mainPrefix}(M,i)\). From condition~\ref{verif:5},  \(x_{i+1}(u)\) is of type \(\Join\). Hence, \(\textsf{Prefix}(\textsf{main}(u), i+1)\) induces a connected set of vertices in \(G\). Therefore, by conditions~\ref{verif:17}-\ref{verif:20} and~\ref{verif:26},  \(\alpha_i^j(M)\) certifies a Steiner tree in \(G\) rooted at \(\textsf{exit}_{i}(M)\), with set of terminals
\[
\textsf{terminals}_i(M) =  \{u \in V \mid  \exists  M' \in \textsf{mainPrefix}(M,i), \id(u)= \textsf{exit}_{i+1}(M')\}. 
\]  
From conditions~\ref{verif:21} and \ref{verif:24}-\ref{verif:27},   \(h_i(M)\)  is the homomorphism class of \({\Pi}\) obtained from the disjoint union function  \({\odot}_{\parallel}\) over the set  
\[
\{h_{i+1}(M'): M' \in \textsf{mainPrefix}(M,i) \}.
\] 
By the induction hypothesis, it follows that \(h_i(M)\) is the homomorphism class of \(G[M',i+1]\).  From conditions~\ref{verif:21}, \ref{verif:23},  and~\ref{verif:27}, we have that, for each \(s \in [k']\),
\[
\textsf{color}^s_{i}(M) = \sum_{u~ \in ~\textsf{terminals}_i(M)} \textsf{color}^{s}_{i+1}(u).
\]
Again, by the induction hypothesis, \(\textsf{color}_i^s(M)\)  is the number of vertices colored \(s\) in the root of~\(T[M,i]\).
\end{proof}

Finally, observe that by condition \(\ref{verif:6}\), for every $M$ and $M' \in \textsf{mainset}$, we have \(M_1 = M'_1\). Then, \(\textsf{Prefix}(M,1) = V\). Applying Lemma~\ref{lem:completeness} to an arbitrary \(M \in \textsf{mainset}\) and for \(i = 1\), we deduce that  \(T[M,1]\) is an \(\NLC_+\)-decomposition tree of \(G\). It follows that \(G\) is a graph of \(\NLC_+\)-width~\(k'\). Moreover, also by Lemma~\ref{lem:completeness}, we have \(h_1(M) = h(G)\).   Finally, by condition~\ref{verif:5.1} we conclude that \(G\) satisfies property \(\Pi\). \hfill\qed


%
\subsection{Certificate Size} 
%
For the  certificate size, let \(u\) an arbitrary vertex, let \(i \in d(u)\), and let \(j \in \{0,1\}\). Observe that each item of \(\textsf{main}_i(u)\), \(\textsf{aux}_i(u)\), and \(\textsf{service}^j_i(u)\) can be encoded with \(\mathcal{O}(\log n)\) bits.  By Lemma~\ref{lem:ldc}, we have that \(d(u)= \mathcal{O}(\log n)\). Therefore, the certificate of \(u\) is of size \(\mathcal{O}(\log^2 n)\). 



