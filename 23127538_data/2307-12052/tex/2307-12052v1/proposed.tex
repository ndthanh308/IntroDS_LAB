%$uTAB$ is of the form ($tag$, $cPay$, $numReq$, $request$($userID$, $reqNum$, $time$, $state$, $pay$, $\$paid$, $\$deposit$)). $uTAB$ is accessed by $tag$ and $request$ within a $uTAB$ is accessed by $reqNum$.
%\thispagestyle{plain}
\section{Proposed incentive mechanism and deduplication scheme}
\subsection{Incentive mechanism}
To make a CSP incentive-compatible we introduced a new parameter $EF_{u}^{c}$ in \eqref{eq:Uu1}. In this section, we find the minimum and maximum values of $EF_{u}^{c}(t)$ so that a user/CSP obtains non-negative utility when opted for dedup with $\mathcal{B}_{DEDU}$.
\\ According to the IC-Constraint in definition \ref{def:IC-constraint}, a CSP $c$ is said to be incentive compatible if 
\begin{equation}\label{eq:cloudUtil}
U_{c}^{1}(t) - U_{c}^{0}(t) \ge 0 
\end{equation}
Substituting the utilities from Table \ref{tab:Utilitiessummary} in  \eqref{eq:cloudUtil}
\begin{multline*}
\sum_{d\in \mathcal{D}}(N_{d}^{c}(t)-n_{d}^{c}(t)+1) * (SF_{u}^{c}(t)-SC_{c}^{u}(t)) + \sum_{d\in \mathcal{D}} n_{d}^{c}(t) * EF_{u}^{c}(t) \\ - \sum_{d\in \mathcal{D}} N_{d}^{c}(t) * I_{c}(t) - I_{deploy}(t) - \sum_{d\in \mathcal{D}} N_{d}^{c}(t) * (SF_{u}^{c}(t)-SC_{c}^{u}(t) \ge 0
\end{multline*}
Assuming the cost of interacting with $\mathcal{B}_{DEDU}$ is negligible when compared to $SF_{u}^{c}(t)$ and $SC_{c}^{u}(t)$, we have
\begin{multline*}
\sum_{d\in \mathcal{D}}(N_{d}^{c}(t)-n_{d}^{c}(t)+1) * (SF_{u}^{c}(t)-SC_{c}^{u}(t)) + \sum_{d\in \mathcal{D}} n_{d}^{c}(t) * EF_{u}^{c}(t)\\ - \sum_{d\in \mathcal{D}} (N_{d}^{c}(t)) * (SF_{u}^{c}(t)-SC_{c}^{u}(t)) \ge 0
\end{multline*}
For a single data file we have
\begin{equation*}
(1-n_{d}^{c}(t)) * (SF_{u}^{c}(t)-SC_{c}^{u}(t)) + n_{d}^{c}(t) * EF_{u}^{c}(t) \ge 0
\end{equation*}
\begin{equation*}
n_{d}^{c}(t) * EF_{u}^{c}(t) \ge (n_{d}^{c}(t)-1) * (SF_{u}^{c}(t)-SC_{c}^{u}(t))
\end{equation*}
\begin{equation} \label{eq:minCF}
EF_{u}^{c}(t) \ge \frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * (SF_{u}^{c}(t)-SC_{c}^{u}(t))
\end{equation}
Now, we find the maximum value of $EF_{u}^{c}(t)$ so that a user is incentive-compatible when opted for dedup with $\mathcal{B}_{DEDU}$. According to the IC-Constraint in definition \ref{def:IC-constraint}, a user $u$ is said to be incentive-compatible if 
\begin{equation}\label{eq:userUtil}
U_{u}^{1}(t) - U_{u}^{0}(t) \ge 0
\end{equation}
Substituting the utilities from Table \ref{tab:Utilitiessummary} in  \eqref{eq:userUtil}
\begin{equation*}
P_{u}(t) - \frac{SF_{u}^{c}(t)}{n_{d}^{c}(t)} - EF_{u}^{c}(t) - I_{u}(t) - P_{u}(t) + SF_{u}^{c}(t) \ge 0
\end{equation*}
Assuming the cost of interacting with $\mathcal{B}_{DEDU}$ is negligible when compared to $SF_{u}^{c}(t)$, we have
\begin{equation*}
SF_{u}^{c}(t) - \frac{SF_{u}^{c}(t)}{n_{d}^{c}(t)} - EF_{u}^{c}(t) \ge 0
\end{equation*}
\begin{equation}\label{eq:maxEF}
EF_{u}^{c}(t) \le  \frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * SF_{u}^{c}(t)
\end{equation}
From \eqref{eq:minCF} and \eqref{eq:maxEF} the minimum and maximum values of $EF_{u}^{c}(t)$ are set as 
\begin{equation}
 EF_{u}^{c}(t) =\Bigg[ \frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * (SF_{u}^{c}(t)-SC_{c}^{u}(t)), \frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * SF_{u}^{c}(t) \Bigg] 
\end{equation}
when the cost of interacting with $\mathcal{B}_{DEDU}$ is considered then
\begin{multline*}
EF_{u}^{c}(t) =\Bigg[ \frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * (SF_{u}^{c}(t)-SC_{c}^{u}(t)) + (n_{d}^{c}(t) * I_{c}(t)) + I_{deploy}, \\(\frac{n_{d}^{c}(t)-1}{n_{d}^{c}(t)} * SF_{u}^{c}(t)) + I_{u}(t) \Bigg] 
\end{multline*}
\subsection{Blockchain-based deduplication scheme}
In this section, we discuss a Blockchain-based cloud storage system which consists of a smart contract $\mathcal{B}_{DEDU}$, a protocol to interact with $\mathcal{B}_{DEDU}$ and a public Blockchain network to deploy $\mathcal{B}_{DEDU}$. At the end of the section, we provide an analysis of our proposed smart contract.
%\subsection{Setting the discount parameter $\alpha_{c}^{d}(t)$}
%We set $\alpha_{c}^{d}(t) = r_{c}^{d} *SFPay + commPay$.
%\\ then the amount of pay paid by the users is  \\
%$E = \begin{cases}
%SFPay * |F|, & \text{if} \: n_{c}^{d}(t)=0 \\
%\frac{SFPay*|F|}{n_{c}^{d}(t) + 1} + commPay, & \text{if} \: n_{c}^{d}(t)>0
%\end{cases} $. 
%The intuition behind this choice is 
\subsubsection{Assumptions}
\begin{enumerate}
	\item We assume that there are no unintentional system failures which may affect the utilities of the CSP and the user. 
	\item We assume that the CSP, the cloud, the smart contract and the Blockchain network are available all the time.
\end{enumerate}
\subsubsection{$\mathcal{B}_{DEDU}$ contract}\label{contract:1}
$\mathcal{B}_{DEDU}$ is a contract between a CSP $c$ and a cloud user $u$. The high-level idea is that if both $c$ and $u$ are honest, then $c$ will receive the fee\footnote{From here on we call the amount paid by $u$ as fee which includes both $SF_{u}^{c}(t)$ and $EF_{u}^{c}(t)$ values} paid by $u$ and $u$ will receive the file link to access the $u$'s file in the cloud managed by $c$. The fee is computed according to rules encoded in $\mathcal{B}_{DEDU}$ contract. The clauses in the $\mathcal{B}_{DEDU}$ contract are as follows:
\begin{enumerate}[label={(\arabic*)}]
	\item\label{clause1} All parties agree on timing parameters $\tau_{p}<\tau_{c1}<\tau_{c2}$ and two payment parameters: $SF_{u}^{c}(t)$ and $EF_{u}^{c}(t)$. 
	%$SF_{u}^{c}(t)$ is computed based on deduplication rate and $EF_{u}^{c}(t)$ is fixed.
	\item\label{clause2} $c$ creates a smart contract ($\mathcal{B}_{DEDU}$) for facilitating payments for cloud storage deduplication. $c$ deploys the $\mathcal{B}_{DEDU}$ on a public Blockchain network and announces the smart contract address and smart contract ABI on a public platform (like a website/bulletin board). 
	%$c$ also initializes the contract with storage fee per bit ($SFPay$)  and a small fee ($commPay$). $c$ obtains $SFPay$ in case of no deduplication, and $commPay$ in case of deduplication. 
	\item\label{clause3} After verifying the contract details at the contract address, a user $u$ if willing to store data at cloud managed by $c$, has to send a request to $\mathcal{B}_{DEDU}$ along with some safety deposit $\$d$. This safe deposit is required to penalize $u$ for sending false requests. $u$'s request includes a $tag$ computed from the encrypted file, and length of the file in bits.
	\item\label{clause4} After receiving the request, $\mathcal{B}_{DEDU}$ checks whether the $tag$ sent by $u$ is received previously. If the check is valid, it will compute the fee as $(\frac{SF^{c}_{u}(t)*|d|}{n_{d}^{c}(t)} + EF_{u}^{c}(t))$ and sends this information to $u$. Otherwise it will compute the fee as $SF^{c}_{u}(t)*|d| + EF_{u}^{c}(t)$ and sends it to $u$. $|d|$ is the length of the data to be stored in bits.
	\item\label{clause5} $u$ must send the fee to $\mathcal{B}_{DEDU}$ before $\tau > \tau_{p}$. If $u$ fails then his deposit $\$d$ is sent to $c$ and the request is marked as terminated. Otherwise $u$'s deposit $\$d$ is refunded. 
	%$u$ must send the file to $c$ which will be stored at the  cloud managed by $c$.
	\item\label{clause6} %If $c$ receives the file or PoP from $u$, then 
	$c$ has to send the confirmation message to $\mathcal{B}_{DEDU}$ before $\tau > \tau_{c1}$ acknowledging the receipt of file or correct PoP . Otherwise, the fee paid by $u$ is refunded, and the request is marked as terminated. $c$ should send the file link with correct access rights to $u$.
	\item\label{clause7} 
	%if $u$ receives the file link 
	$u$ has to send the confirmation message to $\mathcal{B}_{DEDU}$ before $\tau > \tau_{c2}$ acknowledging the receipt of file link.  Otherwise the fee paid by $u$ is refunded. If $u$ has sent the confirmation message before $\tau > \tau_{c2}$ then, (1) if $u$ is the first uploader of $d$ then the fee is sent to $c$ (2) if $u$ is not the first uploader of $d$, then the $EF_{u}^{c}(t)$ part of fee is sent to $c$ and the $SF_{u}^{c}(t)$ part of fee is distributed equally among all the users who hold the file link of $d$ before $u$. In either case, the request is marked as terminated and the value of $n_{d}^{c}(t)$ is incremented.
	%if $u$ receives the file link from $c$, then he need to send a confirmation message to $\mathcal{B}_{DEDU}$ before $\tau_{c2}$. If $u$ sends confirmation message before $\tau_{c2}$, then $\mathcal{B}_{DEDU}$ sends the pay to $c$, otherwise the pay is refunded to $u$ and $c$ will not store $u$'s data.
\end{enumerate}

\begin{comment}
% Figure environment removed
\end{comment}
\begin{center}
	\footnotesize
	\begin{longtable}{|p{1.2cm}p{0.9\textwidth}|}
	\hline
	  \multicolumn{2}{|c|}{$contract$-$\mathcal{B}_{DEDU}$} \\
 \textbf{init:}  & $SF:=0$, $EF:=0$, $uTAB:=\{\}$, $k:=0$ \\	
 \textbf{Create:} & Upon receiving ("create", $SPay$, $EPay$, $interval$) from a cloud storage provider $c$ \\
 & set $SF:=SPay$, $EF:=EPay$ and $k:=interval$\\
 \textbf{Request:} & Upon receiving ("request", $tag$, $|d|$, $\$d$) from a user $u$ \\
  &assert $ledger[u] \ge \$d$ \\
  &set $ledger[u]:=ledger[u] - \$d$ \\
  & if $(tag,*,*,*) \in uTAB$ \\
  & $\:$ if  $\exists \: request(*,*,*,*,*,active,*,*) \in uTAB[tag]$ \\
  & $\:$ $\:$ set $pay:=uTAB[tag].cPay$ \\
  & $\:$ else set $pay:=SF*|d|+EF$ \\
  & else \\
  & $\:$ set $pay:=SF*|d|+EF$ \\
  & $\:$ set $numReq:=0$\\
  & $\:$ set $uTAB:=uTAB \cup (tag,numReq,*,*)$ \\
  & set $ID:=u$, $rState:=waitForPay$, $\$paid:=0$, $reqNum:=uTAB[tag].numReq$ \\
  & set  $\tau_{sub}:=\tau$, $\tau_{p}:=\tau_{sub}+k$, $\tau_{c1}:=\tau_{p}+k$, $\tau_{c2}:=\tau_{c1}+k$ \\
  & set $uTAB[tag].requests$ := $uTAB[tag].requests$ $\cup$\\ 
  &  $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ $ ($ID$, $\tau_{sub}$, $\tau_{p}$, $\tau_{c1}$, $\tau_{c2}$, $rState$, $pay$, $\$paid$) \\
  & set $uTAB[tag].cPay:=pay$\\
  & set $uTAB[tag].numReq:=uTAB[tag].numReq+1$ \\
  & send ("pay", $tag$, $SF$, $pay$, $reqNum$, $\tau_{p}$, $\tau_{c1}$, $\tau_{c2}$) to user $u$\\
  \textbf{Pay:} & Upon receiving ("pay",$tag$, $reqNum$, $\$pay$) from a user $u$\\
  & assert $\tau \le \tau_{p}$ \\
  & assert $uTAB[tag].requests[reqNum].ID = u$ \\
  & assert $uTAB[tag].requests[reqNum].pay \ge \$pay$ \\
  & assert $uTAB[tag].requests[reqNum].rState:=waitForPay$ \\
  & assert $ledger[u] \ge \$pay$ \\
  & set $ledger[u] = ledger[u] - \$pay$ \\
  & set $uTAB[tag].requests[reqNum].\$paid:=\$pay$ \\
  & set $ledger[u] = ledger[u] + uTAB[tag].requests[reqNum].\$d$ \\
  & set $uTAB[tag].requests[reqNum].rState:=waitForCSPConf$ \\
  \textbf{CSPConf:} & Upon receiving ("cspConf", $tag$, $reqNum$) from a cloud storage provider $c$ \\
  & assert $\tau \le \tau_{c1}$ \\
  & assert $uTAB[tag].requests[reqNum].rState=waitForCSPConf$ \\
  & set $uTAB[tag].requests[reqNum].rState:=waitForCliConf$ \\
  \textbf{usrConf:} & Upon receiving ("usrconf", $tag$, $reqNum$) from a user $u$\\
  & assert $\tau \le \tau_{c2}$ \\
  & assert $uTAB[tag].requests[reqNum].ID = u$ \\
  & assert $uTAB[tag].requests[reqNum].rState=waitForCliConf$ \\
  & $\forall$ $i \in [0,uTAB[tag].numReq-2]$\\
  & $\:$ if $uTAB[tag].requests[i].rState=active$ \\
  & $\:$ $\:$ set $activeRequests:=activeRequests+1$ \\
  & if $activeRequests=0$\\
  & $\:$ set $ledger[c]:=ledger[c]+ uTAB[tag].requests[rNum].\$paid$ \\
  & else \\
  & $\:$ set $\$rem := uTAB[tag].requests[reqNum].\$paid - EF$ \\
  & $\:$ set $\$DF:= uTAB[tag].requests[reqNum].\$paid - \$rem$ \\
  & $\:$ set $ledger[c]:=ledger[c] + \$DF$\\
  & $\:$ $\forall$ $i \in [0,activeRequests]$\\
  & $\:$ $\:$ if $uTAB[tag].requests[i].rState=active$\\
  & $\:$ $\:$ $\:$ set $ledger[uTAB[tag].requests[i].ID]:=$ $ledger[uTAB[tag].requests[i].ID]$\\ 
  & $  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \   \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \   \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ + \frac{\$rem}{activeRequests}$\\
  & set $uTAB[tag].cPay:= \frac{SF}{activeRequests+2}+EF$\\
  & set $uTAB[tag].requests[reqNum].rState:=active$ \\
  \textbf{Refund:} & Upon receiving ("refund", $tag$, $reqNum$) from a user $u$\\
  & assert $uTAB[tag].requests[reqNum].ID = u$ \\
  & assert $(\tau > \tau_{c1}$ $\&\&$ $uTAB[tag].requests[reqNum].rState=waitForCSPConf)$
 $||$ \\ & $\ \ \ \ \ \ \ (\tau > \tau_{c2}$ $\&\&$ $uTAB[tag].requests[reqNum].rState=waitForCliConf))$  \\
  & set $ledger[uTAB[tag].requests[reqNum].ID]$ := \\ 
  &$ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ledger[uTAB[tag].requests[reqNum].ID]$ + \\
  & $\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uTAB[tag].requests[reqNum].\$paid$\\
  \textbf{Claim:} & Upon receiving ("claim", $tag$, $reqNum$) from a cloud storage provider $c$ \\
  & assert $\tau>\tau_{p} \: \&\& \: uTAB[tag].requests[reqNum].rState:=waitForPay$ \\
  & set $ledger[c]:=ledger[c]+uTAB[tag].requests[reqNum].\$d$ \\
  \textbf{DeLink:} & Upon receiving ("deLink", $tag$, $reqNum$) from a user $u$\\
  & assert $uTAB[tag].requests[reqNum].ID = u$ \\
  & assert $uTAB[tag].requests[reqNum].rState=active$ \\
  & set $uTAB[tag].requests[reqNum].rState:=inActive$ \\
 \hline
	\end{longtable}
\captionof{figure}{$contract$-$\mathcal{B}_{DEDU}$}
\label{fig:naiveContract}
\end{center}
% Figure environment removed
\begin{comment}
\begin{tcolorbox}[enhanced jigsaw,breakable, parbox=false]
\begin{center}
\textbf{$\mathcal{B}_{DEDU}$ protocol}
\end{center}Let $(KeyGen_{CE}, Encrypt_{CE}, Decrypt_{CE}, TG_{CE})$ be a secure convergent encryption scheme.\\ 
	\underline{For cloud storage provider $c$} 
    \begin{enumerate}[nosep]
    \item To set up storage fee send $\textbf{trans}^{c}_{create}$ = ($SPay$, $EPay$, $interval$) to $BC$.
    \item After receiving a storage request 
    \begin{enumerate}[nosep]
    \item Assert that $u$ has sent $\$pay$ to $BC$ with the same tag 
	\item Send $\textbf{trans}^{u}_{cspconf}$ =($tag$, $reqNum$) to $BC$.
    \item Store $d$ and send the file link ($tag$, $reqNum$, $L$) to user $u$.
    \end{enumerate}
    \item After receiving ("proof", $PoP$, $tag$, $reqNum$) from user $u$.
    \begin{enumerate}[nosep]
    \item Assert that $PoP$ is the correct proof for $tag$ 
    \item Assert that $u$ has sent $\$pay$ to $BC$ with the same tag.
    \item Send $\textbf{trans}^{u}_{cspConf}$ = ($tag$, $reqNum$) to $BC$.
    \item Store $d$ or add $u$ to the user list of $d$ and send file link ($tag$, $reqNum$, $L$) to user $u$        
    \end{enumerate}
    \item To claim the storage fee send $\textbf{trans}^{c}_{claim}$ = ($tag$, $reqNum$) to $BC$.
    \item After receiving a delink request ($tag$, $reqNum$, $L$) from user $u$ 
    \begin{enumerate}[nosep]
    \item  Assert that $u$ has sent "deLink" message to $BC$ with same $tag$ and $reqNum$.
    \item Disable the link $L$ for $u$ or remove $d$ if no other users have active links to $d$
    \end{enumerate}
     \end{enumerate}
    \underline{For user $u$}
    \begin{enumerate}[nosep,resume]
    \item To send a storage request
    \begin{enumerate}[nosep]
    \item Compute $K \leftarrow KeyGen_{CE}(d)$.
    \item Set $C\leftarrow Encrypt_{CE}(K,d)$. 
    \item Set $tag\leftarrow TG_{CE}(C)$.
    \item Send  $\textbf{trans}^{u}_{request}$ = ($tag$, $|d|$, $\$d$) to $BC$.
    \end{enumerate}
    \item To send storage fee
    \begin{enumerate}[nosep]
    \item Assert that a request message has sent earlier with the same $tag$. 
    \item Send $\textbf{trans}^{u}_{pay}$ = $(tag, reqNum, \$pay)$ to $BC$ 
    \item If $SF*|d| = pay$, then send file ($d$, $tag$, $reqNum$) to $c$. Otherwise send the proof of possession ($PoP$, $tag$, $reqNum$) to $c$.
    \end{enumerate}
    \item To confirm receiving file link
    \begin{enumerate}[nosep]
    \item Assert that $L$ is a correct link to File $d$.
    \item Assert that $c$ has sent "cspConf" message to $BC$ with the same $tag$.
    \item Send $\textbf{trans}^{u}_{usrConf}$ = ($tag$, $reqNum$) to $BC$.
    \end{enumerate}
    \item To request a refund send $\textbf{trans}_{u}^{refund}$ = ($tag$, $reqNum$) to $BC$.
    \item To delink a file 
    \begin{enumerate}[nosep]
    \item Send $\textbf{trans}_{deLink}^{u}$ = ($tag$, $reqNum$) to  $BC$.
    \item Send ($tag$, $reqNum$, $L$) to $c$.
    \end{enumerate}
    \end{enumerate}
    \underline{Blockchain $\mathcal{BC}$}: $SF:=0$, $EF:=0$, $uTAB:=\{\}$, $k:=0$
    \begin{enumerate}[nosep,resume]
    \item On receiving $\textbf{trans}^{c}_{create}$
    \begin{enumerate}[nosep,label={}]
    \item Set $SF \gets SPay$, $EF \gets EPay$ and $k \gets interval$
    \end{enumerate}
    \item On receiving $\textbf{trans}^{u}_{request}$
    \begin{enumerate}[nosep,label={}]
    \item Assert $ledger[u] \ge \$d$
    \item Set $ledger[u] \gets ledger[u] - \$d$
    \item If $(tag,*,*,*) \in uTAB$
    \begin{enumerate}[nosep,label={}]
    \item If  $\exists \: request(*,*,*,*,*,active,*,*) \in uTAB[tag]$
    \begin{enumerate}[nosep,label={}]
    \item Set $pay \gets uTAB[tag].cPay$
    \end{enumerate}
    \item Else set $pay \gets SF*|d|+EF$
    \end{enumerate}
    \item Else 
    \begin{enumerate}[nosep,label={}]
    \item Set $pay \gets SF*|d|+EF$ 
    \item Set $numReq \gets 0$
    \item Set $uTAB \gets uTAB \cup (tag,numReq,*,*)$
    \end{enumerate}
    \item Set $ID \gets u$, $rState \gets waitForPay$
    \item Set $\$paid \gets 0$, $reqNum \gets uTAB[tag].numReq$ 
    \item  Set  $\tau_{sub} \gets \tau$, $\tau_{p} \gets \tau_{sub}+k$, $\tau_{c1} \gets \tau_{p}+k$, $\tau_{c2}\gets \tau_{c1}+k$ 
    \item  Set $uTAB[tag].requests$ $\gets$ $uTAB[tag].requests$ $\cup$ ($ID$, $\tau_{sub}$, $\tau_{p}$, $\tau_{c1}$, $\tau_{c2}$, $rState$, $pay$, $\$paid$) 
    \item Set $uTAB[tag].cPay \gets pay$
    \item Set $uTAB[tag].numReq \gets uTAB[tag].numReq+1$ 
    \item Send ($tag$, $SF$, $pay$, $reqNum$, $\tau_{p}$, $\tau_{c1}$, $\tau_{c2}$) to user $u$
    \end{enumerate}
    \item On receiving $\textbf{trans}^{u}_{pay}$ 
    \begin{enumerate}[nosep,label={}]
    \item Assert $\tau \le \tau_{p}$ 
    \item Assert $uTAB[tag].requests[reqNum].ID = u$ 
    \item Assert $uTAB[tag].requests[reqNum].pay \ge \$pay$ 
    \item Assert $uTAB[tag].requests[reqNum].rState:=waitForPay$
    \item Assert $ledger[u] \ge \$pay$ 
    \item Set $ledger[u] \gets ledger[u] - \$pay$ 
    \item Set $uTAB[tag].requests[reqNum].\$paid \gets \$pay$ 
    \item Set $ledger[u] \gets ledger[u] + uTAB[tag].requests[reqNum].\$d$
    \item Set $uTAB[tag].requests[reqNum].rState \gets waitForCSPConf$
    \end{enumerate}
    \item On receiving $\textbf{trans}^{u}_{cspconf}$
    \begin{enumerate}[nosep,label={}]
    \item Assert $\tau \le \tau_{c1}$ 
    \item Assert $uTAB[tag].requests[reqNum].rState=waitForCSPConf$ 
    \item Set $uTAB[tag].requests[reqNum].rState \gets waitForCliConf$
    \end{enumerate}
    \item On receiving $\textbf{trans}^{u}_{usrConf}$ 
    \begin{enumerate}[nosep,label={}]
    \item Assert $\tau \le \tau_{c2}$
    \item Assert $uTAB[tag].requests[reqNum].ID = u$ 
    \item Assert $uTAB[tag].requests[reqNum].rState=waitForCliConf$ 
    \item $\forall$ $i \in [0,uTAB[tag].numReq-2]$
    \begin{enumerate}[nosep,label={}]
    \item If $uTAB[tag].requests[i].rState=active$, then set $activeRequests \gets activeRequests+1$
    \end{enumerate}
     \item  If $activeRequests=0$, then set $ledger[c] \gets ledger[c]+ uTAB[tag].requests[rNum].\$paid$ 
     \item Else 
     \begin{enumerate}[nosep,label={}]
     \item Set $\$rem \gets uTAB[tag].requests[reqNum].\$paid - EF$ 
     \item Set $\$DF \gets uTAB[tag].requests[reqNum].\$paid - \$rem$
     \item Set $ledger[c] \gets ledger[c] + \$DF$
     \item $\forall$ $i \in [0,activeRequests]$
     \begin{enumerate}[nosep,label={}]
     \item If $uTAB[tag].requests[i].rState=active$, then
     \item Set $ledger[uTAB[tag].requests[i].ID] \gets ledger[uTAB[tag].requests[i].ID] + \frac{\$rem}{activeRequests}$
     \end{enumerate}
     \item Set $uTAB[tag].cPay \gets \frac{SF}{activeRequests+2}+EF$
     \item Set $uTAB[tag].requests[reqNum].rState \gets active$
     \end{enumerate}
    \end{enumerate}
    \item On receiving $\textbf{trans}_{u}^{refund}$ 
    \begin{enumerate}[nosep,label={}]
    \item Assert $uTAB[tag].requests[reqNum].ID = u$ 
    \item Assert $(\tau > \tau_{c1}$ $\&\&$ $uTAB[tag].requests[reqNum].rState=waitForCSPConf)$
     $||$ $(\tau > \tau_{c2}$ $\&\&$ $uTAB[tag].requests[reqNum].rState=waitForCliConf))$  
    \item Set $ledger[uTAB[tag].requests[reqNum].ID] \gets ledger[uTAB[tag].requests[reqNum].ID] + uTAB[tag].requests[reqNum].\$paid$
    \end{enumerate}
    \item On receiving $\textbf{trans}_{claim}^{c}$
    \begin{enumerate}[nosep,label={}]
    \item Assert $\tau>\tau_{p} \&\& uTAB[tag].requests[reqNum].rState:=waitForPay$ 
    \item Set $ledger[c] \gets ledger[c]+uTAB[tag].requests[reqNum].\$d$ 
    \end{enumerate}
    \item On receiving $\textbf{trans}^{u}_{deLink}$  
    \begin{enumerate}[nosep,label={}]
    \item Assert $uTAB[tag].requests[reqNum].ID = u$ 
    \item Assert $uTAB[tag].requests[reqNum].rState=active$ 
    \item Set $uTAB[tag].requests[reqNum].rState \gets inActive$ 
    \end{enumerate}                
    \end{enumerate}
%\end{tabular}
\end{tcolorbox}
\end{comment}
\subsubsection{Analysis of $\mathcal{B}_{DEDU}$}
In $\mathcal{B}_{DEDU}$, the parties agree on different timing parameters $\tau_{p}<\tau_{c1}<\tau_{c2}$. These timing parameters are required to enforce timely computation and also to avoid locking of the funds if one of the party refuses to move forward in the protocol. The contract $\mathcal{B}_{DEDU}$ can always query the underlying Blockchain for current time\footnote{most smart contracts use block number or block timestamp as a timer.} which is different from the real-world timer. 
Clause \ref{clause4} ensures the user that the fee is calculated according to the deduplication rate. Clause \ref{clause5} ensures the user that if he sends the fee before $\tau_{p}$, then his deposit is refunded; otherwise, his deposit is forfeited. According to clause \ref{clause6}, in order to get the fee, the CSP has to send an acknowledgement before $\tau_{c1}$. Otherwise, it is deemed as either the CSP do not want to store the user's data, or the user has not sent the data or correct proof-of-ownership. According to clause \ref{clause7} in order to store his data at cloud and get access rights, the user has to send the acknowledgement of the receipt of file link before $\tau_{c2}$. Otherwise, it is deemed as either the user has not received the file link or the user is acting maliciously after receiving the file link. In this case, the CSP does not store the file or do not provide the access rights to the user. Clause \ref{clause7} also guarantees that if $u$ is not the first uploader of a data $d$, then the $SF_{u}^{c}(t)$ part of the fee paid by $u$ is equally distributed among all the users who hold the file link of $d$. This distribution of storage fee among users is unique to our scheme, and it guarantees that all users pay the same storage fee irrespective of when they submit their request. A formal smart contract encoding the clauses discussed above is presented in Figure \ref{fig:naiveContract} and a protocol to interact with the smart contract is presented in Figure \ref{fig:naiveProto}.

A cloud service provider $c$ initializes the parameters $SF$ and $EF$ by invoking Create functionality. $c$ sets these parameters according to current storage costs and utility. If the storage costs vary in future, he can change $SF$ and $EF$ values according to new storage costs. The parameter $interval$ is required  to compute timing parameters $\tau_{p}$, $\tau_{c1}$ and $\tau_{c2}$. These timing parameters are required for timely computation of protocol and avoiding indefinite locking of funds in the contract. A user $u$ sends his storage request to $\mathcal{BC}$ invoking Request functionality. His request consists of parameters like $tag$, $|d|$ and $\$d$. $tag$ is computed using a convergent encryption algorithm, and $|d|$ is the length of the file requested for storage and $\$d$ is a safety deposit. The Request functionality computes the pay in two ways. If the $tag$ sent by $u$ is already exists and is in active state at cloud maintained by $c$, then $pay$ is computed according to the current discounted storage fee of file $F$ with tag $tag$. Otherwise, the pay is computed as $pay = SF * |d| + EF$. Depending on the behavior of the user, there are two cases as follows:
\begin{myEnumerate}[label={}, leftmargin = 0pt]
	\item \textbf{Case 1}: $u$ has sent the storage fee to $\mathcal{BC}$ invoking Pay functionality. Depending on the behavior of the user, there are five cases as follows:
	\begin{myEnumerate}[label={}]
		\item \textbf{Case 1.1}: $u$ has sent the correct file $d$ \footnote{The correctness of the file is verified using the $tag$, based on which the payment is computed during execution of Request functionality.} to $c$. Depending on the behavior of $c$, there are two cases as follows:
		\begin{myEnumerate}[label={}]
			\item \textbf{Case 1.1.1}: $c$ has sent the confirmation message to $\mathcal{BC}$ invoking CSPConf functionality. Depending on the behavior of $c$, there are two cases as follows:
			\begin{myEnumerate}[label={}]
				\item \textbf{Case 1.1.1.1}: $c$ has sent the file link to $u$. Depending on the behavior of the $u$, there are two cases as follows:
				\begin{myEnumerate}[label={}]
					\item \textbf{Case 1.1.1.1.1}: $u$ has sent the confirmation message to $\mathcal{BC}$ invoking usrConf functionality. In this case, if file $d$ is not previously stored at $c$, then all the $pay$ is sent to $c$. Otherwise, the number of owners currently having a link to file $d$ is calculated, and $pay$ is divided into $rem$ and $DF$ components. $rem$ is distributed among the file owners equally, and $DF$ is sent to $c$. The new $pay$ to be paid by the next deduplication requester is computed and stored at contract storage.
					\item \textbf{Case 1.1.1.1.2}: $u$ has failed to send the confirmation message. This case occurs when $u$ has not received the file link from $c$ or $u$ intentionally / unintentionally fail to send a confirmation message. In this case, the $c$ can invalidate the link sent to $u$ and $u$ can send a transaction to $\mathcal{BC}$ invoking Refund functionality, which refunds $pay$ to $u$.
				\end{myEnumerate}
				\item \textbf{Case 1.1.1.2}:  $c$ has failed to send the file link to $u$. This case is similar to case 1.1.1.1.2 where $u$ can obtain a refund by invoking Refund functionality.
			\end{myEnumerate}
			\item \textbf{Case 1.1.2}: $c$ has failed to send the confirmation message to $\mathcal{BC}$. This case is similar to case 1.1.1.1.2 where $u$ can obtain a refund by invoking Refund functionality.
		\end{myEnumerate}
		\item \textbf{Case 1.2}: $u$ has sent the incorrect file to $c$. In this case, the $c$ discards the $u$'s request and will not send any further transactions. $u$ can obtain its $pay$ invoking Refund functionality.
		\item \textbf{Case 1.3}: $u$ has sent the correct proof-of-possession to $c$. In this case, $c$ adds $u$ to the list of owners of file $d$ and sends the file link to $u$. From now on this case proceeds similarly to case 1.1.1.1.
		\item \textbf{Case 1.4}: $u$ has sent the incorrect proof-of-possession to $c$. This case is similar to case 1.2.
		\item \textbf{Case 1.5}: $u$ neither sends file nor proof-of-possession to $c$.  This case is similar to case 1.2.
	\end{myEnumerate}
	\item \textbf{Case 2}: $u$ has failed to send the storage fee. In this case, $c$ sends a transaction to $\mathcal{BC}$ invoking Claim functionality to claim $u$'s deposit.
\end{myEnumerate}
\subsubsection{Proofs of $\mathcal{B}_{DEDU}$}
\begin{theorem}
Proposed scheme satisfies correctness
\end{theorem}
\begin{proof}
	Let $contract$-$\mathcal{B}_{DEDU}$ is deployed on a Nakamoto-style Blockchain network using Proof-of-Work as a consensus algorithm. Let $b$ be the current block of the blockchain which is extended by blocks $b_{1}$ and $b_{2}$. Let $tx_{request}$ and $tx_{pay}$ be the request and pay transactions initiated by a user $u$ which are eventually embedded in $b_{1}$ and $b_{2}$ respectively. We will prove the correctness by considering the following cases. \par
	Case 1: A user $u$ influences the execution of the request functionality to decrease the fee $f$ to be paid by him. This can happen if $u$ assumes the role of a miner and pre-mines two blocks $b_{1}^{'}$ and $b_{2}^{'}$ that contains the $tx_{request}^{'}$ and $tx_{pay}^{'}$ transactions respectively with a modified fee $f^{'}$. Remember in this case $u$ does not broadcast $tx_{request}^{'}$ to the network. Now $u$ broadcast $b_{1}^{'}$ extending $b$ and $b_{2}^{'}$ extending $b_{1}^{'}$ to the Blockchain network. All the other miners in the Blockchain network verifies every transaction in $b_{1}^{'}$ and extends $b_{1}^{'}$ if and only if all the outputs of every transaction in $b_{1}^{'}$ are correct. As the output of $tx_{request}$ is $f$ but not $f^{'}$ the miners discard the block $b_{1}^{'}$. As $b_{2}^{'}$ is extending the wrong block $b_{1}^{'}$, it is also discarded. Miners with at least 51\% of hash-rate cumulatively required to guarantee the correctness of the transactions in the block. \par
	Case 2: $u$ broadcasts $tx_{request}$ but pre-mines $b_{2}^{'}$ that contains $tx_{pay}^{'}$ transaction with modified fee $f^{'}$. In this case, as the actual fee $f$ to be paid by $u$ is already stored in the contract storage, while verifying the $tx_{pay}^{'}$ in $b_{2}^{'}$, the $f^{'}$ received through $tx_{pay}^{'}$ is compared against the stored value. The comparison will fail and the block $b_{2}^{'}$ is discarded. \par
	Case 3: A cloud storage provider $c$ influences the execution of request functionality to increase the fee to be paid by $u$. This case is similar to Case 1 except that now $c$ assumes the role of a miner and broadcasts $b_{1}^{'}$ consisting the modified fee. \par
	Similarly, all the transactions with $\mathcal{B}_{DEDU}$ are executed correctly; otherwise, those transactions are rejected. Nevertheless,  $c$ or $u$ can influence some of the miners to include the wrong blocks to their local ledger and generate new blocks extending these wrong blocks. However, $c$ or $u$ should accumulate more than 50\% of hash rate to make the entire network to accept wrong blocks which is a difficult task unless they have large mining pools under their control \cite{kroll2013economics}. 
	
	In summary, as the miners in public Blockchain networks are reasonably assumed to act honestly for the common good and follow the rules encoded in consensus algorithm, it is difficult for $c$ or $u$ to make the network to accept wrong blocks. Considering the above cases, our scheme satisfies correctness as defined in Section \ref{def:pb}.
\end{proof}
\begin{theorem}\label{th:fairpayments}
Proposed scheme satisfies fair payments
\end{theorem}
\begin{proof}
	We prove fairness by considering the following cases. \par
	Case 1: $u$ is malicious and aborts after learning the fee he needs to pay. In this case, according to $\mathcal{B}_{DEDU}$ contract clause \ref{clause5}, $u$ forfeits his deposit, and his data is not stored in the cloud. Here, the data of the $u$ cannot be stored in the cloud unless he pays the fee. Thus the fairness holds\par    
	Case 2: $u$ fails to send the data $d$ or sends incorrect $PoP$ to $c$. In this case, according to $\mathcal{B}_{DEDU}$ contract clause \ref{clause6}, $c$ refuses to acknowledge the receipt of $d$/$PoP$ and the fee paid by $u$ is refunded. Here, the $u$ cannot obtain the storage link if he fails to send the $d$ or the correct $PoP$. Thus the fairness holds.\par
	Case 3: $c$ is malicious and do not acknowledge the receipt of $d$ or correct $PoP$. This case similar to Case 2. The fee paid by $u$ is refunded. Here $c$ cannot obtain the fee without acknowledging the receipt of $d$ or correct $PoP$. Thus the fairness holds.\par
	Case 4: $c$ is malicious and do not send the file link to $u$. In this case, according to $\mathcal{B}_{DEDU}$ contract clause \ref{clause7} $u$ will not acknowledge the receipt of file link. Then the fee paid by $u$ is refunded. Here, $c$ cannot obtain the fee without sending the file link to $u$. Thus the fairness holds. \par
	Case 5: $u$ is malicious and do not acknowledge the receipt of the file link. This case is similar to case 4. The fee paid by $u$ is refunded. If $c$ do not receive the fee, it disables the file link sent to $u$. Here, $u$ cannot store his data without acknowledging the receipt of file link. Thus the fairness holds.\par
	In summary, considering the above cases, our scheme holds fairness.
\end{proof}
\begin{theorem}
	Proposed scheme satisfies uniform payments
\end{theorem}
\begin{proof}
According to clause \ref{clause4}, the first uploader pays a fee of $SF_{u}^{c}(t)+EF_{u}^{c}(t)$. The second uploader pays a fee of $\frac{SF_{u}^{c}(t)}{2}+EF_{u}^{c}(t)$. Due to the second uploader, the first uploader gets a refund of $\frac{SF_{u}^{c}(t)}{2}$. So at the end each uploader pays a fee of $\frac{SF_{u}^{c}(t)}{2}+EF_{u}^{c}(t)$. 

The $n^{th}$ uploader pays a fee of $\frac{SF_{u}^{c}(t)}{n}+EF_{u}^{c}(t)$ and due to the $n^{th}$ uploader each of the previous $n-1$ uploaders receive a refund of $\frac{SF_{u}^{c}(t)}{n*(n-1)}$. At the end of $n^{th}$ user's payment, the first user pays $SF_{u}^{c}(t)+EF_{u}^{c}(t)-\frac{SF_{u}^{c}(t)}{2}-\frac{SF_{u}^{c}(t)}{6},...,-\frac{SF_{u}^{c}(t)}{n*(n-1)}=\frac{SF_{u}^{c}(t)}{n}+EF_{u}^{c}(t)$. The second user pays $\frac{SF_{u}^{c}(t)}{2}+EF_{u}^{c}(t)-\frac{SF_{u}^{c}(t)}{6},...,-\frac{SF_{u}^{c}(t)}{n*(n-1)}=\frac{SF_{u}^{c}(t)}{n}+EF_{u}^{c}(t)$. Similarly the $(n-1)^{th}$ user pays $\frac{SF_{u}^{c}(t)}{n-1}+EF_{u}^{c}(t)-\frac{SF_{u}^{c}(t)}{n*(n-1)}=\frac{SF_{u}^{c}(t)}{n}+EF_{u}^{c}(t)$.
So, every user having a data $d$ opting for dedup with $\mathcal{B}_{DEDU}$ at $c$ pays the same fee. 

In summary, the proposed scheme satisfies uniform payments irrespective of when a user submits his/her request. 
\end{proof}
%\begin{theorem}
%	Proposed scheme converges.
%\end{theorem}
%\begin{proof}
%We show that the scheme will be converged to one of the end points: Terminated or aborted. We define several strategies for cloud provider and cloud user and show that our proposed scheme converges to one of end points irrespective of the strategies of the cloud user and provider. We prove the convergence using a tree diagram.
%\begin{table}
%	\begin{tabular}{|c}
%		
%	\end{tabular}
%\end{table}
%\end{proof}

