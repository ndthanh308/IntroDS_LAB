\section{Introduction}

Tree Transducers are fundamental devices within automata theory and formal language theory.
They generalize the finite state transductions from strings to (finite, ranked) trees and
were invented in the 1970s in the context of compiler theory and mathematical linguistics.
Probably the most basic such transducers are the top-down tree
transducer~\cite{DBLP:journals/jcss/Thatcher70,DBLP:journals/mst/Rounds70}
and the bottom-up tree transducer~\cite{th70}, see also~\cite{DBLP:journals/mst/Engelfriet75}.
These transducers traverse their input tree once, but may process subrees in several copies.
It is well known that these transducers have \emph{linear height increase} (``LHI''),
see e.g.~\cite{DBLP:series/eatcs/FulopV98}.

In this paper we deal with a more powerful type of tree transducer:
the macro tree transducer~\cite{DBLP:journals/jcss/EngelfrietV85} (``mtt'').
Mtts can be seen as particular functional
programs that carry out primitive recursion via tree pattern matching.
Alternativly, mtts can be seen as context-free tree grammars
(introduced in~\cite{DBLP:journals/mst/Rounds70} as ``context-free dendrogrammars'';
see also~\cite{fis68, DBLP:journals/jcss/EngelfrietS77,DBLP:journals/jcss/EngelfrietS78}
and Section~15 of~\cite{DBLP:reference/hfl/GecsegS97}),
the nonterminals of
which are controlled by a top-down tree storage in the spirit of~\cite{DBLP:journals/corr/Engelfriet14}.

It is well known, that if we restrict the translations of mtts to
\emph{linear size increaase}, then we obtain exactly the MSO definable tree
translations~\cite{DBLP:journals/siamcomp/EngelfrietM03}. 
In that paper it is also proven that it is decidable
for a given mtt, whether or not its translation is of linear size increase
(in fact, this can even be decided for compositions of mtts, and if so,
then the translation is effectively MSO definable~\cite{DBLP:journals/acta/EngelfrietIM21}).
It is an open problem, if it is decidable for a given mtt whether or not
its translation can be realized by a top-down tree transducer
(in the presence of ``origin'', this problem was shown to be decidable~\cite{DBLP:journals/iandc/FiliotMRT18}).
As mentioned above, it is a necessary condition for the mtt to be of
linear height increase (``LHI''). 
This raises the question, can we decide for a given
mtt, whether or not its translation is of LHI?
Here we answer this question in the affirmative. 

It is also an open problem, if it is decidable for a given mtt whether or not
its translation can be realized by an attributed tree 
transducer~\cite{DBLP:journals/mst/Knuth68,DBLP:journals/actaC/Fulop81} (``att'').
It is well-known that atts have \emph{linear size-to-height increase} (``LSHI''), 
see, e.g., Lemma~5.40 of~\cite{DBLP:series/eatcs/FulopV98}. 
This raises the question, can we decide for a given
mtt, whether or not its translation is of LSHI?
Here we answer this question in the affirmative. 
Note that it was conjectured already in~\cite{DBLP:journals/siamcomp/EngelfrietM03}
that the methods of that paper
can be applied in order to decide whether or not the translation of an mtt
is of LSHI.

Last but not least, let us consider \emph{linear size-to-distinct-number-of-output-trees increase}
(``LSOI''). It is well-known that atts have LSOI, see, e.g.,
Lemma~5.43 of~\cite{DBLP:series/eatcs/FulopV98}.
In fact, it was conjectured in the year~2000 by Joost~Engelfriet that the translation of an mtt
can be realized by an att (with look-around, see~\cite{DBLP:journals/jcss/BloemE00}) if and only if the 
translation if of LSOI. This raises the question, can we decide for a given mtt,
whether or not its translation is of LSOI? 
Here we show that deciding LSOI for mtts is at least as difficult as
deciding equivalence of atts. The latter is a long-standing and difficult open problem.  

Let us now discuss our results in more detail.
How is the \emph{linear size increase} (``LSI'') 
property decided for a given mtt~\cite{DBLP:journals/siamcomp/EngelfrietM03}?
The given mtt is first transformed into a certain normal form (called ``proper'');
intuitively, the normal form guarantees that 
(1.)~each state (except possibly the initial state) produces
infinitely many output trees (this is called ``input-proper''),
and that 
(2.)~each parameter of a state is instantiated with infinitely many
distinct argument trees (this is called ``parameter-proper'').
Note that input-properness is a 
generalization of the proper form of~\cite{DBLP:journals/iandc/AhoU71}.
Once in proper normal form, it suffices to check if the transducer
is ``finite copying''. This means that 
(1.)~each node of each input tree is processed only a bounded number of times
and that
(2.)~each parameter of every state is copied only a bounded number of times. 
Both of these properties can easily be reduced to the finiteness problem
of ranges of compositions of (nondeterministic) mtts~\cite{DBLP:journals/iandc/DrewesE98}.
It is also proved that if a proper mtt is \emph{not} finite copying, then its
translation is \emph{not} of LSI.

To decide both the LHI and LSHI properties, we introduce a new normal form
called ``depth-proper''. An mtt is depth-proper if each parameter of every state
appears at infinitely many different depths (for different input trees).
The proof of this normal form is similar to the one of input-properness, but
is more complicated. Technically speaking all our mtts are always equipped
with look-ahead. The original proof of the proper form of~\cite{DBLP:journals/iandc/AhoU71}
was wrong, because they had not realized that due to the change of look-ahead,
states that were input-proper in the original transducer, may become non-input-proper
in the new constructed transducer. To solve this issue, it was shown in~\cite{DBLP:journals/siamcomp/EngelfrietM03}
that the construction has to be iterated, and that this iteration terminates after at
most $|Q|$-many iterations and yields an input-proper mtt (where $Q$ is the set of
states of the given original mtt).
In the case of input-properness, only the look-ahead changes in each iteration of the construction.
Our construction of a depth-proper mtt also needs to be iterated due to the change of
look-ahead, however, we also add new states in each iteration. This complicates the 
termination proof and we are not able to present a simple bound such as $|Q|$ for our iteration. 

Given a depth-proper mtt, we can decide the LSHI and LHI properties as follows.
First, we consider input trees which contain exactly one special marked input leaf
(it will be marked by a state $p$ of the look-ahead automaton, to act as a place-holder for
any input tree for which the look-ahead automaton arrives in state $p$).
For such input trees, the mtt produces output trees which still contain (nested) state calls
to the special input leaf. We say that the mtt has the ``finite nesting'' property, if
there is a bound on the number of nested state calls that appear on any path of such output trees.
We can decide whether or not an mtt is finite nesting, similar as before: we change the mtt
to nondeterministically output any path of nested states of any such output tree. The 
original mtt is finite nesting if and only if the range
of this transducer is finite (the latter is decidable, as mentioned above).
We can also show that if the mtt is \emph{not} finite nesting, then the given translation
if \emph{not} LSHI.
In a similar way we can deal with LHI: here we consider that \emph{each} leaf of
an input tree is marked by a look-ahead state and then proceed exactly as for LSHI.

For the last result, consider two (total) attributed tree transducers.
We know that their translations are of
linear size-to-number-of-distinct-output-subtrees increase (``LSOI'').
We now convert these transducers into equivalent mtts (following, e.g.,
the construction in the proof of Lemma~5.11 of~\cite{DBLP:journals/iandc/EngelfrietM99}).
We obtain two total mtts that are of LSOI.
Consider first that these transducers $M_1,M_2$ are not equivalent, i.e., there exists
some input tree $s$ such that the output $M_1(s)$ of $M_1$ is not equal to the output $M_2(s)$ of $M_2$. 
We construct a new transducer $M$ which takes as input trees of the form $a^n(s')$.
It outputs a full binary tree of height $n$, at the leaves of which are all possible
cons-like list of the trees $M_1(s')$ and $M_2(s')$. This causes that the translation of $M$
is not of LSOI (in particular, taking $s'=s$). On the other hand, if $M_1$ and $M_2$ are equivalent,
then all those cons-like trees are equal and hence $M$ is of LSOI.  
