
%required definitions:
%	- tree contexts
%	- Paths
%	- size and height of trees
% - Provisional output, and their size S() and height H(): The height of a provisional output is defined inductively, similarly to the height of trees, with $H(q(X, t_1, \dots, t_n)) = 1+ \mathrm{max}(0,H(t_1), \dots, H(t_n))$. 
% - \mathrm{Depth}(y_i,q(t))
%	- \mathrm{dom}
%	- \mathrm{Prefix}
%	- width of unranked trees
%	- t_{\uparrow u}[X], t_{\uparrow u_1, u_2}[X_1,X_2], t_{\downarrow u} (=t|_{u})

%Todo:
%	- more detail on the decidability theorem
%	- check again that all required definitions are present
%	- more detail on theorem \ref{the:loop_finding}
%	- check %cursor things (use Ctrl + f "%cursor" to see small things that can still be improved)


\section{Deciding LSHI}\label{sec:decision_LSHI}

The Linear input Size to output Height Increase (LSHI) property is defined similarly to the Linear Size Increase (LSI) property from \cite{DBLP:journals/siamcomp/EngelfrietM03}:

\begin{definition}
	A MTT $M$ is of \emph{Linear input Size to output Height Increase} (LSHI) if there exists a bound $b \in \N$ such that, for all input tree $t$ of size $n$, the height of $M(t)$ is less than $b*n$. 
\end{definition}

In this section we first characterize the LSHI property of MTTs under Depth-proper normal form as those that are finite-nesting, then we use this characterization to decide whether a MTT is LSHI. The finite-nesting property is defined as follows:

\begin{definition}
	A MTT $M$ is \emph{finite-nesting} if there is a bound $b \in \N$ such that, for all input tree-context $t[X]$ with variable $X$, in the provisional output of $M(t[X])$, states of $M$ applied to $X$ appear nested (i.e.\ along a same output path) at most $b$ times. 
	
	A MTT is \emph{infinite-nesting} if it is not \emph{finite-nesting}. 
\end{definition}

\subsection{LSHI characterization}\label{ssec:LSHI_char}

This subsection is dedicated to proving the following theorem:

\begin{theorem}\label{the:LSHI_char}
	Any MTT in Depth-proper normal form is LSHI (Linear input Size to output Height Increase) if and only if it is finite-nesting. 
\end{theorem}

We first prove that any finite-nesting MTT $M$ in Depth-proper normal form is LSHI. The idea here is that, for each path in an output tree, each input node can only contribute a bounded number of nodes to that output path. Given an input node $u$ and an output path $v$, the finite-nesting property tells us that the number of occurrences of states applied to $u$ along path $v$ in the output is bounded by some integer $n$. So the number of nodes along path $v$ whose origin is $u$ is bounded by $n$ times the maximum size of the right-hand side of rules of $M$. Formally: 

\begin{claim}\label{cla:finite-nesting_is_LSHI}
	Given a MTT $M$ in Depth-proper normal form, if $M$ is finite-nesting then $M$ is LSHI. 
\end{claim}

\begin{proof}
	We note $n \in \N$ the nesting bound of $M$, i.e.\ $n$ is such that for all input tree-context $C[X]$ where variable $X$ occurs once in $C$, along each path in the provisional output $M(C(X))$ there are at most $n$ occurrences of a state of $M$ applied to $X$. 
	
	Now we look at the provisional outputs $M(C[X_1, \dots, X_k])$ where each variable $X_i$ occurs once in $C$, and how the height of such a provisional output increases when we substitute $X_1$ with a tree-context $\sigma(Y_1, \dots, Y_m)$ where $\sigma$ is an output tree symbol of arity $m$. 
%	The height of a provisional output is defined inductively, similarly to the height of trees, with $H(q(X, t_1, \dots, t_n)) = 1+ \mathrm{max}(0,H(t_1), \dots, H(t_n))$. 
	
	By definition of $n$, the height of $M(C[X_1, \dots, X_k])$ increases, through the substitution $[X_1 \leftarrow \sigma(Y_1, \dots, Y_m)]$, by at most $n.c$, where $c$ is the maximum height of a right-hand-side of rule of $M$. 
	
	For all input tree $t$, the output $M(t)$ can be computed from the provisional output $M(X)$ by successive substitutions of the form $[X \leftarrow \sigma(Y_1, \dots, Y_m)]$ where $\sigma$ is an output tree symbol of arity $m$. The number of substitutions needed is the size $|t|$ of $t$. The height of $M(X)$ is constant. The height of the provisional output increases by at most $b.c$ after each substitution, so the height of $M(t)$ is at most linear in the size of input tree $t$. Therefore $M$ is LSHI. 
\end{proof}

Proving the converse implication requires more work. The general idea is that any infinite-nesting MTT must have a kind of loop we call \emph{nesting generator loop}. Such a loop can be pumped to contradict the LSHI property. 


\subsubsection*{Nesting generator loops}

Nesting generator loops are defined so as to be the most general type of loop which can induce infinite-nesting: a generator state $q_0$ calls itself and a generated state $q$ by nesting them, and the generated state $q$ calls itself on the same loop. 

\begin{definition}\label{def:nesting_loop}
	A \emph{nesting generator loop} in MTT $M$ is given by a tuple $(C[X],p,q_0,q)$ where: 
	\begin{itemize}
		\item $C[X]$ is an input tree-context with variable $X$
		\item $p$ is a look-ahead state such that, noting $L_p$ the set of input trees with look-ahead $p$, there exists $t \in L_p$ with $C(t) \in L_p$
		\item $q_0$ and $q$ are states of $M$ such that there exists an input tree-context $C_0[X]$ so that $q_0(X)$ appears in the provisional output of $M(C_0[X])$ when $X$ has look-ahead $p$
		\item We have the following nesting properties in the provisional outputs of $q$ and $q_0$ on input $C(X_p)$ where $X_p$ is an input tree variable with look-ahead $p$:
		\begin{itemize}
			\item in the provisional output $M_q(C(X_p))$, there exists a parameter $y_i$ of $q$ such that $y_i$ appears in the $i$-th argument of $q(X_p)$
			\item in the provisional output $M_{q_0}(C(X_p))$, either $q_0(X_p)$ appears in the $i$-th argument of $q(X_p)$, or there exists a parameter $y_j$ of $q_0$ such that a single occurrence of $y_j$ appears in the $j$-th argument of $q_0(X_p)$ and in the $i$-th argument of $q(X_p)$. 
		\end{itemize}
	\end{itemize}
\end{definition}

The look-ahead state $p$ is important because without it we cannot pump the loop. Note that states $q_0$ and $q$ and parameters $y_i$ and $y_j$ are not necessarily distinct. When $q_0 = q$ and $y_i = y_j$, the loop allows to produce a nesting of states exponential in the number of times we pump the loop. In the general case however, pumping this loop $n$ times produces a number of nested state calls $q(X)$ linear in $n$. 


We start by proving that a \emph{nesting generator loop} in a MTT $M$ in Depth-proper normal form necessarily breaks the LSHI property (i.e.\ $M$ cannot be LSHI). 

\begin{claim}\label{cla:loop_breaks_LSHI}
	Given a MTT $M$ in Depth-proper normal form, if $M$ has a \emph{nesting generator loop} then $M$ is not LSHI. 
\end{claim}

\begin{proof}
	By definition of the nesting generator loop, we have tree-contexts $C_0$ and $C$ such that, in the provisional output of $M(C_0(C(X_p)))$, $q_0(X_p)$ and $q(X_p)$ appear nested.
	
	Moreover, by pumping the loop, we increase the nesting of $q(X_p)$, i.e.\ $q(X_p)$ appears $n$-times along a single path in the provisional output of $M(C_0(C^n(X_p)))$ for all $n \in \N$. This notably implies that $M$ is not finite-nesting. 
	
	So, for all $t \in L_p$, the height of $M(C_0(C^n(t)))$ is at least $n$ times the maximum depth of parameter $y_i$ in $q(t)$. The size of the input $C_0(C^n(t))$ is:
	\[S(C_0(C^n(t))) = S(C_0) + n.S(C) + S(t)\]
	The height of the output is:
	\[H(M(C_0(C^n(t)))) \geq n.\mathrm{Depth}(y_i,q(t)) \]
	If $M$ was LSHI there would be a bound $b \in \N$ such that, for all $n \in \N$:
	\[b.(S(C_0) + n*S(C) + S(t)) \geq H(M(C_0(C^n(t)))) \geq n.\mathrm{Depth}(y_i,q(t))\]
	This means that $b \geq \mathrm{Depth}(y_i,q(t)) / S(C)$ for all $t \in L_p$. Since $M$ is in Depth-proper normal form, there is no bound on the depth of $y_i$ in $q(t)$ for $t \in L_p$. Then such a $b$ cannot exist, therefore $M$ is not LSHI. 
\end{proof}

The last step in proving theorem \ref{the:LSHI_char} is to show that if a MTT $M$ in Depth-proper normal form is \emph{infinite-nesting} then it has a \emph{nesting generator loop}. For this we look at how states of $M$ call each other, more specifically we define a notion of state call trees, and we express the \emph{infinite-nesting hypothesis} as a condition on those state call trees. We will then prove that this condition implies the existence of a \emph{nesting generator loop}. 

\subsubsection*{State call trees}

For each input tree $t$, we can look at the state calls on the nodes of $t$ as a larger unranked tree whose root is the call of the initial state on the root of $t$, and each node corresponds to the call of a state on a node of $t$. 

To facilitate the definition of state call trees, we define from $M$ a new $\MTTR$ noted $M^{\#}$ where each state $q$ adds a node labeled $\#_q$ at the root of its output, i.e.\ we replace each right-hand side $t$ by $\#_q(t)$ where $\#_q$ is a new output symbol of arity $1$ and $q$ is the state on the left side of the rule. 
Here we consider each occurrence of $\#_q$ as one "state call", we discuss this choice after the definition: 

\begin{definition}
	For all input tree $t$, we note $\mathrm{Origin}(t,M^\#(t))$ the \emph{origin semantics} of the computation of $M^\#$ on tree $t$. We define it as the set of pairs of paths $(u,v) \in P(t) \times P(M^\#(t))$ such that the node at path $v$ in $M^\#(t)$ was produced by the node at path $u$ in $t$. 
	
	We call \emph{state call tree} of $M$ on $t$ the unranked tree $\SC(t)$ defined by:
	\begin{itemize}
		\item the set of nodes is $N = \{(u,v) \in \mathrm{Origin}(t,M^\#(t)) \mid \exists q \in Q, M^\#(t)|_v = \#_q\}$
		\item the root is $(\epsilon, \epsilon)$
		\item for all node $(u,v) \in N \setminus \{(\epsilon, \epsilon)\}$, the parent node of $(u,v)$ is $(u',v')$ where: 
		\begin{itemize}
			\item $u'$ is the longest strict prefix of $u$ (i.e.\ $\exists i \in \N, u'.i = u$)
			\item $v'$ is the longest strict prefix of $v$ such that $(u',v') \in N$
		\end{itemize}
	\end{itemize}
\end{definition}

Intuitively, each node corresponds to a state call, and the parent of a state call $q(t_i)$ is the state call $q'(a(t_1, \dots, t_n))$ which induces it (so $q(X_i)$ is in the right-hand side of a rule of $M^\#$ whose left side is $q'(a(X_1, \dots, X_n), \dots)$). 

Considering each occurrence of $\#_q$ in the output as a state call can be counter-intuitive. This is because when a state call $q(t)$ appears in an argument of another state call $q'(t)$ and the state $q'$ makes several copies of this argument, the corresponding $\#_q$ will occur several times in the output. With our definition we consider each occurrence of $\#_q$ as a different \emph{state call}. 

Since we are only looking at nesting properties in this paper, we will only look at state calls occurring along a same path in the output tree. Because state calls along a same output path have different arguments, they cannot be copies of each other, and so this choice does not change anything for the proofs in this paper. 

\subsubsection*{The infinite-nesting hypothesis for state call trees}

The infinite-nesting property of $M$ can be expressed as a property of its state call trees. Given an input tree $t$, a path $u$ in $t$ and a path $v$ in $M^\#(t)$, the nesting along path $v$ of states on the input node at path $u$ is the number of nodes in the state call tree $\SC(t)$ of the form $(u,v')$ where $v'$ is a prefix of $v$. This allows us to characterize the infinite-nesting property in terms of state call trees. This will later allow us to find a \emph{nesting generator loop}. 

The nesting number on an input tree $t$ on input path $u$ along output path $v$ can be expressed as the width of a trimmed version of the state call tree on $t$ (by \emph{width} here we mean the number of nodes of a same depth):

\begin{definition}
	We call state call tree trimmed on input path $u$ along output path $v$, and we note $\SC(t,u,v)$, the tree obtained from $\SC(t)$ by keeping nodes in $\mathrm{Prefix}(u) \times \mathrm{Prefix}(v)$ and removing the others. 
\end{definition}

We get the lemma:

\begin{lemma}\label{lem:LSHI_unbounded_width}
	The transducer $M$ is infinite-nesting if and only if, for all integer $n \in \N$, there exists a trimmed state call tree $\SC(t,u,v)$ of width $\geq n$. 
\end{lemma}

\begin{proof}%cursor: more detail here
	By definition of infinite-nesting and trimmed state calls $\SC(t,u,v)$. 
\end{proof}

\subsubsection*{Finding loops in state call trees}

We now give a theorem implying that if trimmed state call trees are of unbounded width, then there exists a nesting generator loop. However, we keep this theorem more general because it will also be used in the characterization of the LHI property. 

\begin{theorem}\label{the:loop_finding}
	Given an infinite set $S$ of rooted unranked trees whose nodes have labels in a finite set $Q$, under the following two hypotheses:
	\begin{itemize}
		\item Bounded arity: there is a bound $m$ on the arity of nodes in trees of $S$, 
		\item Unbounded width: for all $n \in \N$ there exist a tree $t_n \in S$ and a depth $d \in \N$ such that there are at least $n$ nodes of depth $d$ in $t_n$, 
	\end{itemize}
	There must exist a tree $t \in S$ with the following pattern: 
	\begin{center}
		% Figure removed
	\end{center}
	
	More formally, there must exist 5 nodes $N_{q_0}, N_{q}, N_{q_0,0}, N_{q, 0}, N_{q, 1}$ of $t$ such that:
	\begin{itemize}
		\item we have the following depth equations, noting $d(N) \in \N$ the depth of node $N$:
		\[d(N_{q_0}) = d(N_{q})\]
		\[d(N_{q_0, 0}) = d(N_{q, 0}) = d(N_{q, 1})\]
		\item we have the following label equations, noting $L(N) \in Q$ the label of node $N$:
		\[L(N_{q_0}) = L(N_{q_0, 0}) = q_0 \in Q\]
		\[L(N_{q}) = L(N_{q, 0}) = L(N_{q, 1}) = q \in Q\]
		\item there are the following paths in $t$, noting $N_1 \to N_2$ if there is a path from $N_1$ to $N_2$:
		\[N_{q_0} \to N_{q_0, 0}\]
		\[N_{q_0} \to N_{q, 0}\]
		\[N_{q} \to N_{q, 1}\]
	\end{itemize}
\end{theorem}

The notation choice of $q_0$ and $q$ obviously hints that the labeling is linked to the states corresponding to the state calls. But we will need to add more information in this labeling, both for the characterization of LSHI and LHI. As a first corollary of this theorem, we get that infinite-nesting implies the existence of a nesting generator loop:

\begin{claim}\label{cla:LSHI_loop}
	Any infinite-nesting MTT $M$ has a \emph{nesting generator loop}. 
\end{claim}

\begin{proof}
	For each trimmed state call tree $\SC(t,u,v)$, to each node $(u',v')$ we give the label $L((u',v')) = (q,p,i)$ where:
	\begin{itemize}
		\item $q \in Q$ is the state of $M$ such that $M^\#(t)|_{v'} = \#_q$
		\item $p \in P$ is the look-ahead state of $t|_{u'}$
		\item $i$ is the index of the argument of $q$ whose root node occurs along path $v$ in the output $M^\#(t)$ if it exists, otherwise $i=0$. In other words, if there is a state call $(u',v'')$ with $v' < v'' \leq v$ then this state call appears in $M^\#(t_{\uparrow u'})$ below the state call $(u',v')$ in its $i$-th argument; and $i=0$ otherwise. 
	\end{itemize}
	The added look-ahead and argument information is necessary to imply the existence of a nesting generator loop. 
	
	We can now apply theorem \ref{the:loop_finding} to the set of labeled $\SC(t,u,v)$ because:
	\begin{itemize}
		\item the trees have \emph{unbounded width} according to Lemma \ref{lem:LSHI_unbounded_width}, 
		\item the trees have \emph{bounded arity} because the arity is bounded by the maximum state nesting in the rules of $M$, 
		\item the nodes of trees are labeled in the \emph{finite set} $Q \times P \times [0, n]$ where $n$ is the maximum number of parameters of states of $M$.
	\end{itemize}
	
	The theorem gives us a tree $\SC(t,u,v)$ and in it five nodes $(u_1,v_1), (u_1,v_2), (u_2,v_3), (u_2,v_4), (u_2,v_5)$ labeled respectively $(q_0,p,j),(q,p,i),(q_0,p,j),(q,p,i),(q,p,i)$ (the equalities between the $u_1$, $u_2$ and $p$ come from the depth equalities). 
	
	By definition of the labels, if there exists two nodes $(u',v')$ and $(u',v'')$ with $v' < v''$ then the label of $(u',v')$ is $(q',p',i')$ with $i' \neq 0$. This applies to $(u_2,v_4)$ and $(u_2,v_5)$: since $v_4$ and $v_5$ are both prefixes of $v$, either $v_4 < v_5$ or $v_5 < v_4$, in either case $i \neq 0$. 
	
	Then we have the \emph{nesting generator loop} $(C[X],p,q_0,q)$ with $C[X] = (t_{\uparrow u_2}[X])|_{u_1}$ and:
	\begin{itemize}
		\item there exists $t|_{u_2} \in L_p$ such that $C(t|_{u_2}) = t|_{u_1} \in L_p$ 
		\item there exists $t_{\uparrow u_1}[X]$ such that for all variable $X_p$ of look-ahead $p$: $q_0(X_p)$ appears in $M^\#(t_{\uparrow u_1}(X_p))$, 
		\item because $(u_1,v_2)$ is an ancestor node of $(u_2,v_5)$ in $\SC(t,u,v)$ and $(u_1,v_2)$ and $(u_2,v_5)$ both have label $(q,p,i)$ with $i \neq 0$, parameter $y_i$ must appear in $M^{\#}_q(C(X_p))$ in the $i$-th argument of $q(X_p)$, 
		\item because $(u_1,v_1)$ is an ancestor node of $(u_2,v_3)$ and $(u_2,v_4)$ in $\SC(t,u,v)$, and because $(u_1,v_1)$, $(u_2,v_3)$ and $(u_2,v_4)$ have labels $(q_0,p,j), (q,p,i)$ and $(q_0,p,j)$ respectively, we have two cases depending on whether $j = 0$ or not:
		\begin{itemize}
			\item if $j\neq 0$ then, in $M^{\#}_{q_0}(C(X_p))$, a single occurrence of parameter $y_j$ appears in the $j$-th argument of $q_0(X_p)$ and in the $i$-th argument of $q(X_p)$, 
			\item if $j=0$ then, in $M^{\#}_{q_0}(C(X_p))$, $q_0(X_p)$ appears in the $i$-th argument of $q(X_p)$. 
		\end{itemize}
	\end{itemize}
\end{proof}

Theorem \ref{the:LSHI_char} is therefore a consequence of claims \ref{cla:LSHI_loop}, \ref{cla:loop_breaks_LSHI} and \ref{cla:finite-nesting_is_LSHI}: any MTT in Depth-proper normal form is LSHI (Linear input Size to output Height Increase) if and only if it is finite-nesting. 


\subsection{Deciding LSHI}

We can now use Theorem \ref{the:LSHI_char} to give an algorithm to decide the LSHI property of MTT$^R$. Given a MTT$^R$ $M$ we compute its Depth-proper normal form, then decide if it is finite-nesting:

\begin{corollary}
	The LSHI property is decidable for MTT$^R$. 
\end{corollary}

\begin{proof}
	Given $M$ a MTT$^R$, we can decide if $M$ is LSHI by checking if the Depth-proper normal form $M'$ of $M$ is finite-nesting. 
	
	The finite-nesting problem can be reduced to the finiteness of ranges of Macro tree transducers, which is known to be decidable. 
	
%	we can reduce it to the decision of finiteness of ranges of transducers (that is also how the "finite copying" property is proved in the 2003 paper; that paper does talk about generator loops, but that is inside of a pumping argument, and not for deciding something).
%	E.g., for LHI, we construct a *nondeterministic* MTT which outputs monadic trees which are all possible nestings of states in any tree t = M(s[u \leftarrow h(s/u)] where u is a node of the input tree s and h(s/u) is the look-ahead state attained at the subtree s/u. E.g., if in the tree "t" there is a state q_3 that appears in a parameter position of state q_2 which in turn appears in a parameter position of state q_1, then the new transducer (which has as nullary input symbols also the set P of look-ahead states) outputs the monadic tree q_1(q_2(q_3(e))), i.e., it has as output symbols all states (of rank 1) plus the nullary sumbol "e".
%	This is how the decision of linear size increase in the 2003 paper works and in a very similar way we can also decide LSHI.
	
\end{proof}


















\section{Deciding LHI}\label{sec:decision_LHI}

The structure of this section is the same as section \ref{sec:decision_LSHI}. Replacing the LSHI with the LHI property entails slight changes in the type of nesting we use to characterize LHI, the type of loops we look for, and more minute details in the proofs. But the main ideas are very similar. 

The Linear Height Increase (LHI) property is defined similarly to the Linear Size Increase (LSI) property from \cite{DBLP:journals/siamcomp/EngelfrietM03} and Linear input Size to output Height Increase (LSHI) property:

\begin{definition}
	A MTT $M$ is \emph{Linear Height Increase} (LHI) if there exists a bound $b \in \N$ such that, for all input tree $t$ of height $h$, the height of $M(t)$ is less than $b*h$. 
\end{definition}

In this section we first characterize the LHI property of MTTs under Depth-proper normal form as those that are both finite-nesting and \emph{finite-multi-leaf-nesting} (or finite-ML-nesting), then we will use this characterization to decide whether a MTT is LHI. The finite-ML-nesting property is defined as follows:

\begin{definition}
	A MTT $M$ is \emph{finite ML-nesting} if there is a bound $b \in \N$ such that, for all input tree-context $t[X_1, \dots, X_n]$ with variables $X_1, \dots, X_n$, in the provisional output of $M(t[X_1, \dots, X_n])$, states of $M$ applied to variables $X_1, \dots , X_n$ appear nested (i.e.\ along a same output path) at most $b$ times. 
	
	A MTT is \emph{infinite ML-nesting} if it is not \emph{finite ML-nesting}. 
\end{definition}

\subsection{LHI characterization}\label{ssec:LHI_char}

This subsection is dedicated to proving the following theorem:

\begin{theorem}\label{the:LHI_char}
	Any MTT in Depth-proper normal form is LHI (Linear Height Increase) if and only if it is finite-ML-nesting. 
\end{theorem}

We first prove that any finite-ML-nesting MTT $M$ in Depth-proper normal form is LHI. The idea is that an anti-chain of nodes in the input tree (i.e.\ set of nodes that are not ancestors of each other) can only contribute a bounded number of nodes to each output path. Given an anti-chain $A$ of input nodes and an output path $v$, the finite-ML-nesting property tells us that the number of occurrences of states applied to nodes in $A$ along path $v$ in the output is bounded by some integer $n$. So the number of nodes along path $v$ with origin in $A$ is bounded by $n$ times the maximum size of the right-hand side of rules of $M$. Formally: 

\begin{claim}\label{cla:finite-ML-nesting_is_LHI}
	Given a MTT $M$ in Depth-proper normal form, if $M$ is finite-ML-nesting then $M$ is LHI. 
\end{claim}

\begin{proof}
	We note $b \in \N$ the ML-nesting bound of $M$. %i.e.\ $b$ is such that for all input tree-context $C[X]$ where variable $X$ occurs once in $C$, along each path in the provisional output $M(C(X))$ there are at most $b$ occurrences of a state of $M$ applied to $X$. 
	
	We look at the provisional outputs $M(C[X_1, \dots, X_k])$ where each variable $X_i$ occurs once in $C$, and how the height of such a provisional output increases when we apply a substitution $\mathfrak{S}$ of height $1$, i.e.\ a substitution where each $X_i$ is substituted with a tree of the form $\sigma(Y_1, \dots, Y_m)$ where $\sigma$ is an output tree symbol of arity $m$. The height of a provisional output is defined inductively, similarly to the height of trees, with $H(q(X, t_1, \dots, t_n)) = 1+ \mathrm{max}(0,H(t_1), \dots, H(t_n))$. 
	
	By definition of $b$, the height of $M(C[X_1, \dots, X_k])$ increases, through the substitution $\mathfrak{S}$ by at most $b.c$, where $c$ is the maximum height of a right-hand-side of rule of $M$. 
	
	For all input tree $t$, the output $M(t)$ can be computed from the provisional output $M(X)$ by successive substitutions of height $1$. The number of substitutions needed is the height $H(t)$ of $t$. The height of $M(X)$ is constant. The height of the provisional output increases by at most $b.c$ after each substitution, so the height of $M(t)$ is at most linear in the height of input tree $t$. Therefore $M$ is LHI. 
\end{proof}

Proving the converse implication requires more work. The general idea is that any infinite-ML-nesting MTT must have either a nesting generator loop \ref{def:nesting_loop} or a new kind of loop we call \emph{nesting generator loop}. Either type of loop can be pumped to contradict the LHI property. 

\subsubsection*{ML-nesting generator loops}

ML-nesting generator loops are defined so as to be the most general type of loop which can induce infinite-ML-nesting: a generator state $q_0$ calls itself and a generated state $q$ by nesting them. The difference with nesting generator loops is that the calls to $q_0$ and $q$ should not be on the same subtree. 

\begin{definition}\label{def:ML-nesting_loop}
	A \emph{ML-nesting generator loop} in MTT $M$ is given by a tuple $(C[X_1,X_2],p_0,p,q_0,q)$ where: 
	\begin{itemize}
		\item $C[X_1,X_2]$ is an input tree-context with variables $X_1$ and $X_2$, 
		%		\item $C[X]$ is an input tree-context with variable $X$
		\item $p_0$ and $p$ are look-ahead states such that, noting $L_{p_0}$ and $L_p$ the sets of input trees with look-ahead $p_0$ and $p$ respectively, there exists $t_0 \in L_{p_0}$ 
		%		and $t_1,t_2 \in L_p$ 
		such that: $C(t_0,t_1) \in L_{p_0}$ %and $C(t_2) \in L_p$, 
		\item $q_0$ and $q$ are states of $M$ such that there exists an input tree-context $C_0[X]$ so that $q_0(X)$ appears in the provisional output of $M(C_0[X])$ when $X$ has look-ahead $p_0$
		\item In the provisional output $M_{q_0}(C(X_{p_0},X_p))$ where $X_{p_0}$ and $X_p$ are input tree variables with look-ahead $p_0$ and $p$ respectively, we have either:
		\begin{itemize}
			\item $q_0(X_{p_0})$ appears in an argument of $q(X_p)$
			%		in the provisional output $M_q(C(X_p))$, there exists a parameter $y_i$ of $q$ such that $y_i$ appears in the $i$-th argument of $q(X_p)$
			\item a single occurrence of a parameter $y_i$ of $q_0$ appears in the $i$-th argument of $q_0(X_{p_0})$ and in an argument of $q(X_p)$. 
		\end{itemize}
	\end{itemize}
\end{definition}

Note that a nesting generator loop is not an ML-nesting generator loop. For this reason we will prove that the existence of either of these two kinds of loops in a Depth-proper transducer contradicts the LHI property. 

\begin{claim}\label{cla:loop_breaks_LHI}
	Given a MTT $M$ in Depth-proper normal form, if $M$ has either a \emph{nesting generator loop} or a \emph{ML-nesting generator loop} then $M$ is not LHI. 
\end{claim}

\begin{proof}
	If there exists a \emph{nesting generator loop} then, according to claim \ref{cla:loop_breaks_LSHI}, $M$ is not LSHI and therefore not LHI. \\
	We now assume that there exists a \emph{ML-nesting generator loop}. By definition of such loops, we have tree-contexts $C_0$ and $C$ such that, in the provisional output of $M(C_0(C(X_{p_0},X_p)))$, $q_0(X_{p_0})$ and $q(X_p)$ appear nested.
	We note $C^n(X_{p_0},X_p)$ the input tree \\
	$C( \dots C(C(X_{p_0},X_p),X_p) \dots ,X_p)$ where $C$ is pumped $n$ times, and we note $y_j$ the argument of $q$ on which $q(X_p)$ is nesting in the loop. 
	
	Moreover, by pumping the loop, we increase the nesting of $q(X_p)$, i.e.\ $q(X_p)$ appears $n$-times along a single path in the provisional output of 
	$M(C_0(C^n(X_{p_0},X_p)))$ where $C$ is pumped $n$ times. This notably implies that $M$ is not finite-ML-nesting. 
	
	So, for all $t_0 \in L_{p_0}, t \in L_p$, the height of $M(C_0(C^n(t_0,t)))$ is at least $n$ times the maximum depth of the parameter $y_i$ in $q(t)$. The height of the input $C_0(C^n(t_0,t))$ is:
	\[H(C_0(C^n(t_0,t))) \leq d_{C_0} + n.d_C + \mathrm{max}(H(t_0),H(t))\]
	where $d_{C_0}$ is the depth of $X$ in $C_0[X]$ and $d_C$ is the maximum depth of $X_{p_0}$ or $X_p$ in $C(X_{p_0},X_p)$. 
	The height of the output is:
	\[H(M(C_0(C^n(t)))) \geq n.\mathrm{Depth}(y_i,q(t)) \]
	If $M$ was LHI there would be a bound $b \in \N$ such that, for all $n \in \N$:
	\[b.(d_{C_0} + n.d_C + \mathrm{max}(H(t_0),H(t))) \geq H(M(C_0(C^n(t)))) \geq n.\mathrm{Depth}(y_i,q(t))\]
	This means that $b \geq \mathrm{Depth}(y_i,q(t)) / d_C$ for all $t \in L_p$. Since $M$ is in Depth-proper normal form, there is no bound on the depth of $y_i$ in $q(t)$ for $t \in L_p$. Then such a $b$ cannot exist, therefore $M$ is not LHI. 
\end{proof}

The last step in proving theorem \ref{the:LHI_char} is to show that if a MTT $M$ in Depth-proper normal form is \emph{infinite-ML-nesting} then it has either a \emph{nesting generator loop} or a \emph{ML-nesting generator loop}. Similarly to the LSHI case, we look at the structure of state calls. 

\subsubsection*{The infinite-ML-nesting property for state call trees}

Similarly to the infinite-nesting property, the infinite-ML-nesting property can be expressed as a property of state call trees. 
%cursor: transpose from here
Given an input tree $t$, a path $u$ in $t$ and a path $v$ in $M^\#(t)$, the nesting along path $v$ of states on the input node at path $u$ is the number of nodes in the state call tree $\SC(t)$ of the form $(u,v')$ where $v'$ is a prefix of $v$. This allows us to characterize the infinite-nesting property in terms of state call trees. This will later allow us to find a \emph{nesting generator loop}. 

The nesting number on an input tree $t$ on input path $u$ along output path $v$ can be expressed as the width of a trimmed version of the state call tree on $t$ (by \emph{width} here we mean the number of nodes of a same depth):

\begin{definition}
	We call state call tree trimmed on input path $u$ along output path $v$, and we note $\SC(t,u,v)$, the tree obtained from $\SC(t)$ by keeping nodes in $\mathrm{Prefix}(u) \times \mathrm{Prefix}(v)$ and removing the others. 
\end{definition}

We get the lemma:

\begin{lemma}\label{lem:LHI_unbounded_width}
	The transducer $M$ is infinite-nesting if and only if, for all integer $n \in \N$, there exists a trimmed state call tree $\SC(t,u,v)$ of width $\geq n$. 
\end{lemma}

\begin{proof}%cursor: more detail here
	By definition of infinite-nesting and trimmed state calls $\SC(t,v)$. 
\end{proof}
%cursor: to here
By using lemma \ref{lem:LHI_unbounded_width} and theorem \ref{the:loop_finding}, we can now prove the following claim:

\begin{claim}\label{cla:LHI_loop}
	Any infinite-ML-nesting MTT $M$ has a \emph{ML-nesting generator loop}. 
\end{claim}

\begin{proof}
	If $M$ is infinite-nesting then, by Claim \ref{cla:LSHI_loop}, it has a \emph{nesting generator loop}. From now on we assume that $M$ is not infinite nesting, i.e.\ there is a bound on the nesting of state calls from a same input node. 
	
	To detect ML-nesting of state calls, we trim state call trees along a path of the output tree (to look at ML-nesting state calls), but forcing state calls to fork with respect to the input tree (so that two different state calls $(u,v)$ and $(u',v')$ have $u \neq u'$). 
	Formally, for all input tree $t$, output path $v \in M^\#(t)$ and partial function $f: P(t) \rightarrow \mathrm{Prefix}(v)$ such that:
	\[\forall u \in \mathrm{dom}(f), ~~ (u,f(u)) \in \SC(t) ~~ \text{ and }\]
	\[\forall u' \in \mathrm{Prefix}(u), ~~ (u',f(u')) \text{ is an ancestor of } (u,f(u)) \text{ in } \SC(t)\]
	we note $\SC(t,v,f)$ the tree obtained from $\SC(t)$ by keeping nodes in $(u,f(u))$ and removing the others (by definition of $\SC(t)$, this is still a tree rooted in $(\epsilon,\epsilon)$). 
	
	For each such $\SC(t,v,f)$, to each node $(u',v')$ we give the label $L((u,v')) = (q,p,i)$ where:
	\begin{itemize}
		\item $q \in Q$ is the state of $M$ such that $M^\#(t)|_{v'} = \#_q$
		\item $p \in P$ is the look-ahead state of $t|_{u'}$
		\item $i$ is the index of the argument of $q$ whose root node occurs along path $v$ in the output $M^\#(t)$ if it exists, otherwise $i=0$. In other words, if there is a state call $(u',v'')$ with $v' < v'' \leq v$ then this state call appears in $M^\#(t_{\uparrow u'})$ below the state call $(u',v')$ in its $i$-th argument; and $i=0$ otherwise. 
	\end{itemize}
	In the label, we add the argument index in order to get the proper form of the ML-nesting generator loop. 
	
	We can now apply theorem \ref{the:loop_finding} to the set of labeled $\SC(t,v,f)$ because:
	\begin{itemize}
		\item the trees have \emph{unbounded width} because $M$ is infinite ML-nesting and the width of $\SC(t,v,f)$ is the maximum ML-nesting of state calls along output path $v$ and there is a bound on the nesting of state calls for the same input node, %cursor: need to explain more here
		\item the trees have \emph{bounded arity} because the arity is bounded by the maximum state nesting in the rules of $M$, 
		\item the nodes of trees are labeled in the \emph{finite set} $Q \times P \times [0, n]$ where $n$ is the maximum number of parameters of states of $M$.
	\end{itemize}
	
	The theorem gives us a tree $\SC(t,v)$ and in it five nodes $(u_0,v_0), (u_1,v_1), (u_2,v_2), (u_3,v_3)$ and $(u_4,v_4)$ labeled respectively $(q_0,p_0,j),(q,p,i),(q_0,p_0,j),(q,p,i),(q,p,i)$. 
	
	By definition of the labels, if there exists two nodes $(u',v')$ and $(u'',v'')$ at the same depth in $\SC(t,v,f)$ with $v' < v''$ then the label of $(u',v')$ is $(q',p',i')$ with $i' \neq 0$. This applies to $(u_3,v_3)$ and $(u_4,v_4)$: since $v_3$ and $v_4$ are both prefixes of $v$, either $v_3 < v_4$ or $v_4 < v_3$, in either case we have $i \neq 0$. 
	
	Then we have the \emph{ML-nesting generator loop} $(C_0[X_1,X_2],C[X],p_0,p,q_0,q)$ with \\
	$C_0[X_1,X_2] = (t_{\uparrow u_2,u_3}[X_1,X_2])|_{u_0}$ and $C[X] = (t_{\uparrow u_4}[X])|_{u_1}$ and:
	\begin{itemize}
		\item there exists $t|_{u_2} \in L_{p_0}$ and $t|_{u_3}, t|_{u_4} \in L_p$ such that $C_0(t|_{u_2},t|_{u_3}) = t|_{u_0} \in L_{p_0}$ and $C(t|_{u_4}) = t|_{u_1} \in L_p$ 
		\item there exists $t_{\uparrow u_0}[X]$ such that for all variable $X$ of look-ahead $p_0$: $q_0(X)$ appears in $M(t_{\uparrow u_0}(X))$, 
		\item because $(u_1,v_1)$ is an ancestor node of $(u_4,v_4)$ in $\SC(t,u,v)$, both with label $(q,p,i)$ with $i \neq 0$, parameter $y_i$ must appear in $M_q(C(X_p))$ in the $i$-th argument of $q(X_p)$ when $X_p$ is a variable of look-ahead $p$, 
		\item because $(u_0,v_0)$ is an ancestor node of $(u_2,v_2)$ and $(u_3,v_3)$ in $\SC(t,u,v)$ with labels $(q_0,p_0,j), (q,p,i)$ and $(q_0,p_0,j)$ respectively, we have two cases depending on whether $j = 0$ or not:
		\begin{itemize}
			\item if $j\neq 0$ then, in $M_{q_0}(C_0(X_{p_0},X_p))$, a single occurrence of parameter $y_j$ appears in the $j$-th argument of $q_0(X_{p_0})$ and in the $i$-th argument of $q(X_p)$, 
			\item if $j=0$ then, in $M_{q_0}(C_0(X_{p_0},X_p))$, $q_0(X_{p_0})$ appears in the $i$-th argument of $q(X_p)$. 
		\end{itemize}
	\end{itemize}
\end{proof}

Theorem \ref{the:LHI_char} is therefore a consequence of claims \ref{cla:LHI_loop}, \ref{cla:loop_breaks_LHI} and \ref{cla:finite-ML-nesting_is_LHI}: any MTT in Depth-proper normal form is LHI (Linear Height Increase) if and only if it is finite-ML-nesting. 


\subsection{Deciding LHI}

We can now use Theorem \ref{the:LHI_char} to give an algorithm to decide the LHI property of MTT$^R$. Given a MTT$^R$ $M$ we compute its Depth-proper normal form, then decide if it is finite-nesting:

\begin{corollary}
	The LHI property is decidable for MTT$^R$. 
\end{corollary}

\begin{proof}
	Given $M$ a MTT$^R$, we can decide if $M$ is LHI by checking if the Depth-proper normal form $M'$ of $M$ is finite-ML-nesting. 
	
	Similarly to finite-nesting property, the finite-ML-nesting property can be reduced to the finiteness of ranges of Macro tree transducers, which is known to be decidable. 
	
%	we can reduce it to the decision of finiteness of ranges of transducers (that is also how the "finite copying" property is proved in the 2003 paper; that paper does talk about generator loops, but that is inside of a pumping argument, and not for deciding something).
%	E.g., for LHI, we construct a *nondeterministic* MTT which outputs monadic trees which are all possible nestings of states in any tree t = M(s[u \leftarrow h(s/u)] where u is a node of the input tree s and h(s/u) is the look-ahead state attained at the subtree s/u. E.g., if in the tree "t" there is a state q_3 that appears in a parameter position of state q_2 which in turn appears in a parameter position of state q_1, then the new transducer (which has as nullary input symbols also the set P of look-ahead states) outputs the monadic tree q_1(q_2(q_3(e))), i.e., it has as output symbols all states (of rank 1) plus the nullary sumbol "e".
%	This is how the decision of linear size increase in the 2003 paper works and in a very similar way we can also decide LSHI.
	
\end{proof}





























% the syntax for setting root file depends on your editor (first one is for Texstudio)
% !TeX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End: