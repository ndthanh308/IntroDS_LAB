%!TEX root = ICALP_main.tex
\section{Preliminaries}
\label{sect:prelim}

The set $\{0,1,\dots \}$ of natural numbers is denoted by $\mathbb{N}$.
For $k\in\mathbb{N}$ we denote by $[k]$ the set
$\{1,\dots,k\}$; thus $[0]=\emptyset$.
A ranked alphabet (set) consists of an alphabet (set) $\Sigma$ together
with a mapping $\text{rank}_{\Sigma}: \Sigma\to\mathbb{N}$
that assigns each symbol $\sigma\in\Sigma$ a natural number called its ``rank''.
We write $\sigma^{(k)}\in\Sigma$ to denote that $\sigma\in\Sigma$ and
$\text{rank}_{\Sigma}(\sigma)=k$.
By $\Sigma^{(k)}$ we denote the symbols of $\Sigma$ that have rank $k$.
%
The set $T_\Sigma$ of (finite, ranked, ordered) trees over $\Sigma$ is the smallest
set $S$ such that if $\sigma\in\Sigma^{(k)}$, $k\geq 0$, and
$s_1,\dots,s_k\in S$, then also $\sigma(s_1,\dots,s_k)\in S$.
We write $\sigma$ instead of $\sigma()$.
For a tree $s=\sigma(s_1,\dots,s_k)$ with $\sigma\in\Sigma^{(k)}$, $k\geq 0$,
and $s_1,\dots,s_k\in T_\Sigma$, we define 
the set $V(s)\subseteq\mathbb{N}^*$ of nodes of $s$ as
$\{\varepsilon\}\cup \{ iu\mid i\in[k], u\in V(s_i)\}$;
thus, nodes are strings over positive integers.
Thus, $\varepsilon$ denotes the root node of $s$, and
for a node $u$, $ui$ denotes the $i$-th child of $u$.
For $u\in V(s)$ we denote by $s[u]$ the label of $u$ in $s$ and
by $s/u$ the subtree rooted at $u$.
Formally, let $s=\sigma(s_1,\dots,s_k)$ and define 
$s[\epsilon]=\sigma$,
$s[iu]=s_i[u]$, 
$s/\varepsilon=s$, and
$s/iu=s_i/u$ for $\sigma\in\Sigma^{(k)}$, $k\geq 0$,
$s_1,\dots,s_k\in T_\Sigma$, $i\geq 1$ and $u\in V(s_i)$ such that $iu\in V(s)$.

We fix two special sets of symbols: the set $X=\{x_1,x_2,\dots \}$ of
variables and the set $Y=\{y_1,y_2,\dots\}$ of parameters.
For $k\geq 1$ let $X_k=\{x_1,\dots,x_k\}$ and $Y_k=\{y_1,\dots,y_k\}$.
Let $A$ be a set that is disjoint from $\Sigma$. Then the set $T_\Sigma(A)$ of
trees over $\Sigma$ indexed by $A$ is defined as $T_{\Sigma'}$ where
$\Sigma'=\Sigma\cup A$ and $\text{rank}_{\Sigma'}(a)=0$ for $a\in A$ and 
$\text{rank}_{\Sigma'}(\sigma)=\text{rank}_{\Sigma}$ for $\sigma\in\Sigma$.

For a ranked alphabet $\Sigma$ and a set $A$ the ranked set
$\<\Sigma,A>$  consists of all symbols $\<\sigma,a>$ with $\sigma\in\Sigma$ and
$a\in A$; the rank of $\<\sigma,a>$ is defined as $\text{rank}_\Sigma(\sigma)$.

\medskip

%\subsection{Tree Substitutio}n
\textbf{Tree Substitution.}\quad
Let $\Sigma$ be a ranked alphabet and let $s,t\in T_\Sigma$.
For $u\in V(s)$ we define the tree $s[u\leftarrow t]$ that is obtained
from $s$ by replacing the subtree rooted at node $u$ by the tree $t$.
Let $\sigma_1,\dots,\sigma_n\in\Sigma^{(0)}$, $n\geq 1$ be pairwise distinct symbols
and let $t_1,\dots,t_n\in T_\Sigma$. Then $t[\sigma_i\leftarrow t_i\mid i\in[n]]$
is the tree obtained from $t$ by replacing each occurrence of $\sigma_i$ by
the tree $t_i$. We have defined trees as particular strings, and this is just
ordinary string substitution (because we only replace symbols of rank zero).
We refer to this as ``first-order tree substitution''.

In ``second-order tree substitution'' it is possible to replace internal nodes $u$ (of a tree $s$)
by new trees. These new trees use parameters to indicate where
the ``dangling'' subtrees $s/ui$ of the node $u$ are to be placed.
Let $\sigma_1\in\Sigma^{(k_1)},\dots, \sigma_n\in\Sigma^{(k_n)}$ be pairwise distinct symbols 
with $n\geq 1$ and
$k_1,\dots,k_n\in\mathbb{N}$ and let $t_i\in T_\Sigma(Y_{k_i})$ for $i\in[n]$.
Let $s\in T_\Sigma$.
Then $s[\![\sigma_i\leftarrow t_i\mid i\in[n]]\!]$ denotes the tree
that is inductively defined as (abbreviating $[\![\sigma_i\leftarrow t_i\mid i\in[n]]\!]$ by
$[\![\dots ]\!]$) follows:
for $s=\sigma(s_1,\dots,s_k)$,
if $\sigma\not\in\{\sigma_1,\dots,\sigma_n\}$ then $s[\![\dots]\!]=\sigma(s_1[\![\dots]\!],
\dots,s_k[\![\dots]\!])$ and if $\sigma=\sigma_j$ for some $j\in[n]$ then
$s[\![\dots]\!]=t_j[y_i\leftarrow s_i[\![\dots]\!]\mid i\in[k]]$.

\medskip 

%\subsection{Macro Tree Transducers}
%\label{sect:mtt}
\textbf{Macro Tree Transducers.}\quad
A (deterministic bottom-up) \emph{tree automaton} $A$ is given by a tuple
$(P,\Sigma,h)$ where $P$ is a finite set of states, $\Sigma$ is a ranked alphabet,
and $h$ is a collection of mappings $h_\sigma:P^k\to P$ with $\sigma\in\Sigma^{(k)}$
and $k\geq 0$ such that the collection is surjective (i.e., for every $p\in P$ there
exists a $\sigma$ such that $p$ is in the range of $h_\sigma$).
The extension of $h$ to a mapping $\hat{h}:T_\Sigma\to P$
is defined recursively as $\hat{h}(\sigma(s_1,\dots,s_k))=
h_\sigma(\hat{h}(s_1),\dots,\hat{h}(s_k))$ for every $\sigma\in\Sigma^{(k)}$,
$k\geq 0$, and $s_1,\dots,s_k$. For every $p\in P$ we define the subset $L_p$ of trees
in $T_\Sigma$ as $\{ s\in T_\Sigma\mid \hat{h}(s)=p\}$.
Note that $L_p\not=\emptyset$ due to the surjectivity requirement above.

A (total, deterministic) \emph{macro tree transducer with (regular) look-ahead} (``mttr'') 
$M$ is given by a tuple
$(Q,P,\Sigma,\Delta,q_0,R,h)$, where
\begin{itemize}
\item $Q$ is a ranked alphabet of \emph{states},
\item $\Sigma$ and $\Delta$ are ranked alphabet of \emph{input} and \emph{output symbols},
\item $(P,\Sigma,h)$ is a tree automaton (called the \emph{look-ahead automaton} of $M$),
\item $q_0\in Q^{(0)}$ is the \emph{initial state},
\item and $R$ is the \emph{set of rules}, where for each $q\in Q^{(m)}$, $m\geq 0$,
$\sigma\in\Sigma^{(k)}, k\geq 0$, and $p_1,\dots, p_k\in P$ there is exactly one rule of the form 
\[
\<q,\sigma(x_1:p_1,\dots,x_k:p_k)>(y_1,\dots,y_m) \to t
\]
with $t\in T_{\Delta\cup \< Q,X_k>}(Y_m)$.
The right-hand side $t$ of such a rule is denoted by
$\text{rhs}_M(q,\sigma,\<p_1, \dots,p_k>)$
\end{itemize}

We use a notation that is slightly different from the one used in the Introduction:
instead of, e.g., $q_2(x_2, q_{\text{id}}(x_1))$ we write
$\< q_2,x_2>(\< q_{\text{id}},x_1>)$.
Thus, we use angular brackets $\< \dots >$ to indicate a state call on an input subtree,
and use round brackets (after the angular brackets), to indicate the parameter arguments
of the particular state call.

The semantics of an mttr $M$ (as above) is defined as follows.
We define the derivation relation $\Rightarrow_M$ as follows.
For two trees $\xi_1,\xi_2\in T_{\Delta\cup\< Q,T_\Sigma>}(Y)$,
$\xi_1\Rightarrow_M\xi_2$ if there exists a node $u$ in $\xi_1$
with $\xi_1/u=\<q,s>(t_1,\dots,t_m)$, $q\in Q^{(m)}$, $m\geq 0$,
$s=\sigma(s_1,\dots,s_k)$, $\sigma\in\Sigma^{(k)}$, $k\geq 0$,
$s_1,\dots,s_k\in T_\Sigma$,
$t_1,\dots,t_m\in T_{\Delta\cup\<Q,T_\Sigma>}(Y)$, and 
$\xi_2=\xi_1[u\leftarrow\xi]$ where $\xi$ equals
\[
\zeta
[\![\<q',x_i>\leftarrow \<q',s_i>\mid q'\in Q,i\in[k]]\!]
[y_j\leftarrow t_j\mid j\in[m]]
\]
and $\zeta=\text{rhs}_M(q,\sigma,\<\hat{h}(s_1),\dots,\hat{h}(s_k)>)$.
Since $M$ is total (i.e.,
for every state $q$, input symbol $\sigma\in\Sigma^{(k)}$, $k\geq 0$, and 
look-ahead states $p_1,\dots,p_k$, $M$ contains a corresponding rule)
%and $\Rightarrow_M$ is confluent and terminating,
there is for every $\xi_1$ a unique
tree $\xi'\in T_\Delta(Y)$ such that $\xi_1\Rightarrow_M^* \xi'$.
For every $q\in Q^{(m)}$, $m\geq 0$ and $s\in T_\Sigma$ we define the
\emph{$q$-translation of $s$}, denoted by $M_q(s)$, as the unique tree $t$ in $T_\Delta(Y_m)$ such that
$\<q,s>(y_1,\dots, y_m)\Rightarrow_M^* t$.
We denote the \emph{translation realized by $M$} also by $M$, i.e., 
$M=M_{q_0}$ and for every $s\in T_\Sigma$,
$M(s)=M_{q_0}(s)$ is the unique tree $t\in T_\Delta$
such that $\< q_0,s>\Rightarrow_M^* t$.

Let $M$ be an mttr as before.
We define \emph{the extension $\widehat{M}$ of $M$} which can also process
look-ahead states at leaves of input trees.
Let $\widehat{M}=(Q,P,\hat{\Sigma},\hat{\Delta},q_0,R\cup \hat{R},h\cup h')$ where
$\hat{\Sigma}=\Sigma\cup \{p^{(0)}\mid p\in P\}$ and
$\hat{\Delta}=\Delta\cup \{\< q,p>^{(m)} \mid q \in Q^{(m)}, p \in P, m\geq 0\}$.
For every $q\in Q^{(m)}$, $m\geq 0$, and $p\in P$ we let $h(p)=p$ and we
let the rule
$\<q,p>(y_1, \dots, y_m)\to \<q,p>(y_1, \dots, y_m)$ be in $\hat{R}$;
note that the $\<q,p>$ on the right-hand side of this rule is an output symbol.
%
For the original transducer $M$ we say that the pair $(q,p)$ is
\emph{reachable (in $M$)} if there is an input tree $s\in T_{\hat{\Sigma}}$ such
that $\<q,p>$ occurs in $\widehat{M}(s)$.
Clearly it is decidable for a given pair $(q,p)$, whether or not
it is reachable; this is because (1)~inverse translations of mttrs
effectively preserve regularity~\cite{DBLP:journals/jcss/EngelfrietV85,DBLP:journals/ipl/PerstS04},
(2)~the set of all trees in $T_{\hat{\Delta}}$
that contain at least one occurrence of $\< q,p>$ is regular, and
(3)~emptiness of regular tree languages is decidable~\cite{TATA07}. 

We say that $M$ is \emph{nondeleting}, if for every state $q\in Q^{(m)}$,
$m\geq 1$, $\sigma\in\Sigma^{(k)}, k\geq 0$, $p_1,\dots, p_k\in P$,
and $j\in[m]$, there is at least one occurrence of $y_j$ in
$\text{rhs}_M(q,\sigma,\< p_1,\dots,p_k>)$.
The next proposition is proved in~\cite[Lemma~6.7]{DBLP:journals/iandc/EngelfrietM99}
(for mttrs that do not copy parameters, but the proof works analogously for
arbitrary mtts).

\begin{proposition}
\label{prop:nondeleting}
For every mttr, an equivalent nondeleting mttr $M$ can be constructed such that,
for every state $q$ of $M$ of rank $m\geq 1$ and
for every $j\in[m]$ it holds that $M_q(s)$ contains at least one
occurrence of $y_j$, for every $s\in T_\Sigma$.
\end{proposition}

It is well known that the finiteness of ranges of compositions of 
mttrs is decidable~\cite{DBLP:journals/iandc/DrewesE98}.
A (partial nondeterministic) top-down tree transducer with look-ahead
(``topr'' for short)
is an mttr
as before, where $Q=Q^{(0)}$ and $R$ may contain none or several
rules for each given $q$ and $\sigma$.


\begin{proposition}(\cite[Theorem~4.5]{DBLP:journals/iandc/DrewesE98})
\label{prop:finite}
For a given composition of mttrs and (partial nondeterministic) toprs it is 
decidable whether or not the range of the composition is finite. 
In the case of finiteness, the range can be constructed.
\end{proposition}

%Note that a ``partial'' mttr is one where for some $q,\sigma,p_1,\dots,p_k$
%it may be that $\text{rhs}_M(q,\sigma,\< p_1,\dots,p_k>)$ is \emph{not}
%defined.
