%We present two examples to show how a depth proper mttr is obtained.

\newcommand\qid{q_{\mathrm{id}}}

We now show how the depth proper normal form is achieved using
an example. An additional example (which makes more interesting use of
helper states) can be found in the Appendix. 
%
%Next we shall show a more complex example where
%a set of \(Z\)-skeleta is not singleton and 
%a $Y$-node of a \(Z\)-skeleton is not empty
%(and where the construction needs to be iterated).
%
Let \(M=(Q,\{p\},\Sigma,\Delta,q_0,R,h_0)\) 
with
\(Q=\{q_0^{(0)},q_1^{(1)},q_2^{(2)}\}\),
\(\Sigma=\{a^{(1)},b^{(1)},e^{(0)}\}\),
and \(\Delta=\{f^{(2)},g^{(1)},e^{(0)}\}\)
be an mttr 
where \((\Sigma,\{p\},h_0)\) with $L_p=T_\Sigma$
and \(R\) consists of these rules:
\begin{align*}
\<q_1, a(x)>(y_1) &\to \<q_2, x>(y_1, \<q_1,x>(y_1)) &
\<q_2, a(x)>(y_1,y_2) &\to f(y_1,\<q_1,x>(g(y_2)))
\\
\<q_1, b(x)>(y_1) &\to y_1 &
\<q_2, b(x)>(y_1,y_2) &\to f(y_2,y_1)
\\
\<q_1, e>(y_1) &\to g(y_1) &
\<q_2, e>(y_1,y_2) &\to f(y_2,y_1)
\end{align*}
We suppose that the \(q_0\)-rules are defined so that all states are reachable.
Now we have \(F_p=\{q_2\}\), \(Y(q_2,p)=\{y_1\}\), and 
\(\lcop{M_{q_2}(L_p)}_{\{y_1\}} = \{ t_1, t_2 \}\)
with \(t_1 = f(y_1,\{y_2\})\) and \(t_2=f(\{y_2\},y_1)\).
As before, we can rewrite \(q_2\)-calls with the skeleta,
but since there are two possibilities \(t_1\) and \(t_2\), 
we need to separate the rules according to the input using the look-ahead.
In general, \(F_p\) contains several states each of which may have multiple skeleta, 
so each look-ahead contains a finite map from \(F_p\) to skeleta.
Let \(\varphi_1=\{q_2\mapsto t_1\}\) and \(\varphi_2=\{q_2\mapsto t_2\}\) 
such that \(L_{p,\varphi_1}=\{a(s)\mid s\in\tree\Sigma\}\) and
\(L_{p,\varphi_2}=\{b(s)\mid s\in\tree\Sigma\}\cup\{e\}\).
The \((q_1,a)\)-rule containing a \(q_2\)-call is separated as
\begin{align*}
\<q_1,a(x:(p,\varphi_1))>(y_1) &\to f(y_1, \<[q_2,p,t_1,2],x>(\<q_1,x>(y_1))) \\
\<q_1,a(x:(p,\varphi_2))>(y_1) &\to f(\<[q_2,p,t_2,1],x>(\<q_1,x>(y_1)),y_1) 
\end{align*}
where \(\<[q_2,p,t_1,2],x>\) and \(\<[q_2,p,t_2,1],x>\) are helper states.
Each helper state has rank 1 
because the corresponding node in the skeleton is a $Y$-node of length 1.
The arguments of the call are inherited from
the arguments of the original \(q_2\)-call that occur in the sequence.
For example, \(\<[q_2,p,t_1,2],x>\) is called with \(\<q_1,x>(y_1)\)
since \(t_1\) has a $Y$-node \(\{y_2\}\) and 
the original \(q_2\)-call has \(\<q_1,x>(y_1)\) as the second argument.
The rules of these helper states are constructed from the original \(q_2\)-rule
with substitution (which causes nothing since no states in \(F_p\) are called)
and extracting a subtree at the $Y$-node, that is,
\[
\begin{array}{lcl}
\<[q_2,p,t_1,2], a(x:(p,\varphi))>(y_1) &\to& \<q_1,x>(g(y_1)) \\
\<[q_2,p,t_2,1], b(x:(p,\varphi))>(y_1) &\to& y_1 \\
\<[q_2,p,t_2,1], e>(y_1) &\to& y_1 
\end{array}
\]
where \(\varphi\in\{\varphi_1,\varphi_2\}\) and
we had to rename the parameter \(y_2\) into \(y_1\)
(because the helper states only refer to \(y_2\)).
Note that rules for \(([q_2,p,t_1,2],b)\), \(([q_2,p,t_1,2],e)\) and \(([q_2,p,t_2,1], a)\) 
do not have to be considered.
These rules are not referred because
the states are never called with the input symbols
due to their look-ahead.
For example, the \([q_2,p,t_1,2]\)-call occurs only 
in the \((q_1,a)\)-rule with \(x\in L_{p,\varphi_1}\)
in which the root symbol cannot be \(b\).
%They are not reachable because they are called with the specific look-ahead.

Thereby we have been able to remove every call of states in \(F_p\).
However, new improper states may be generated by the separation of rules 
because of the look-ahead introduction.
In fact, we have \(F_{p,\varphi_2}=\{q_1,q_2,[q_2,p,t_2,1]\}\) in the example above.
Since every \(q_2\)-call has already been removed in the previous step,
we have to apply the same technique again for the calls of 
\(q_1\) and \([q_2,p,t_2,1]\).
We have $Y(q_1,(p,\varphi_2))=\{y_1\}$ and 
$Y([q_2,p,t_2,1],(p,\varphi_2))=\{y_1\}$.
Moreover 
$\lcop{M'_{q_1}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1, g(y_1)\}$
and
$\lcop{M'_{[q_2,p,t_2,1]}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1\}$.

\iffalse
We have: \vspace{-2mm}
\begin{align*}
&Y(q_1,(p,\varphi_2))=\{y_1\}
&&\text{and}
&Y([q_2,p,t_2,1],(p,\varphi_2))=\{y_1\}, \\
&\lcop{M'_{q_1}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1, g(y_1)\}
&&\text{and}
&\lcop{M'_{[q_2,p,t_2,1]}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1\}\text.
\end{align*} \vspace{-5mm}
\fi


Look-ahead has to be introduced to determine which skeleton to output.
Two maps over \(F_{p,\varphi_2}\),
except for \(q_2\) whose call has already been removed,
are defined: 
\(\varphi_3=\{q_1\mapsto y_1, [q_2,p,t_2,1]\mapsto y_1\}\) and
\(\varphi_4=\{q_1\mapsto g(y_1), [q_2,p,t_2,1]\mapsto y_1\}\)
such that \(L_{p,\varphi_2,\varphi_3}=\{b(s)\in L_{p,\varphi_2}\mid s\in\tree\Sigma\}\) and
\(L_{p,\varphi_2,\varphi_3}=\{e\}\).
The \((q_1,a)\)- and \(([q_2,p,t_1,2],a)\)-rules with look-ahead \(\varphi_2\)
which contains a \(q_2\)-call 
are separated as follows:
\[
\begin{array}{lcl}
\<q_1, a(x:(p,\varphi_2,\varphi_3))>(y_1) &\!\to& f(y_1,y_1) \\
  \<[q_2,p,t_1,2], a(x:(p,\varphi_2,\varphi_3))>(y_1) &\!\to& g(y_1) \\
\<q_1, a(x:(p,\varphi_2,\varphi_4))>(y_1) &\!\to& f(g(y_1),y_1) \\
  \<[q_2,p,t_1,2], a(x:(p,\varphi_2,\varphi_4))>(y_1) &\!\to& g(g(y_1)) 
\end{array}
\]
The resulting  mttr is depth proper.

\iffalse
Let \(M=(\{q_0,q_1,q_2\},\{p\},\Sigma,\Delta,q_0,R,h_0)\) be an mttr 
where \((\Sigma,\{p\},h_0)\) is the trivial tree automaton on \(\tree\Sigma\)
and \(R\) consists of the rules:
\begin{align*}
&\<q_0, a(x)> \to g(\<q_1, x>(\<q_0, x>)) &
&\<q_0, b(x)> \to g(\<q_2, x>(e)) &
&\<q_0, e> \to e
\\
&\<q_1, a(x)>(y) \to f(y, y) &
&\<q_1, b(x)>(y) \to g(y) &
&\<q_1, e>(y) \to g(y) 
\\
&\<q_2, a(x)>(y) \to\<q_2,x>(g(y)) &
&\<q_2, b(x)>(y) \to f(y, \<q_0,x>) &
&\<q_2, e>(y) \to y
\end{align*}
where the look-ahead \(p\) is omitted.
Then we can find that \(M_{q_1}(L_p)=M_{q_1}(\tree\Sigma)\)
is finite, that is, \(M_{q_1}(L_p)=\{f(y,y),g(y)\}\),
and hence \(Y(q_1,p)=\{y\}\).
Let us call such states \emph{improper}.
Every call of the improper state \(q_1\) will be substituted (in a second-order fashion)
by either one of these trees, and which one is determined by look-ahead.
The look-ahead is given as a tree automaton \((P,\Sigma,h)\) with \(P=\{p_1,p_2\}\)
that satisfies
\(M_{q_1}(L_{p_1})=\{f(y,y)\}\), \(M_{q_1}(L_{p_2})=\{g(y)\}\),
and \(L_{p_1}\cup L_{p_2}=\tree\Sigma\).
Thereby the \(q_0\)-rule for \(a\) is split into two rules
\begin{align*}
\<q_0, a(x:p_1)> &\to g(f(\<q_0, x>, \<q_0, x>)) 
\\
\<q_0, a(x:p_2)> &\to g(g(\<q_0, x>)) 
\end{align*}
for \(\{y\}\)-skeleta \(f(y,y)\) and \(g(y)\), respectively,
and the other rules are split into two which have the same right-hand side as before.
Observe that there are no state call of \(q_1\).

Let \(M'\) be the obtained mttr.
Since \(L_{p_2}\) consists of two types of trees, 
either \(b(t)\) with \(t\in\tree\Sigma\) or \(e\),
we find that 
\(M_{q_2}(L_{p_2})=\{y\}\cup\{f(y,t)\mid t\in\tree\Delta\}\),
thus \(\lcop{M_{q_2}(L_{p_2})}_{\{y\}}=\{y, f(y,\emp)\}\) is finite.
In a way similar to the above,
we remove all \(q_2\)-calls for look-ahead \(p_2\)
by replacing them either by \(y\) or by \(f(y, t')\)
where look-ahead determines which one to be used.
The tree \(t'\) is constructed according to the original rules.
The refined look-ahead automaton is given by \((P\times P',\Sigma,h'')\)
with \(P'=\{p'_1,p'_2\}\)
that satisfies 
\(\lcop{M_{q_2}(L_{(p_2,p'_1)})}_{\{y\}} =\{y\}\),
\(\lcop{M_{q_2}(L_{(p_2,p'_2)})}_{\{y\}} = \{ f(y,\emp) \}\), 
\(L_{(p_2,p'_1)}\cup L_{(p_2,p'_2)}=L_{p_2}\).
Every rule of \(M'\) is split into two again
where the set of look-ahead states becomes \(P\times P'\).
The original \((q_0,b)\)-rule and \((q_2,a)\)-rule with look-ahead \(p_2\)
containing \(q_2\)-calls
will be split into different new rules:
\begin{align*}
\<q_0, b(x:(p_2,p'_1))> &\to g(e)
\\
\<q_0, b(x:(p_2,p'_2))> &\to g(f(e,\<[q_2,p_2,f(y,\emptyset),2],x>))
\\
\<q_2, a(x:(p_2,p'_1))>(y) &\to g(y)
\\
\<q_2, a(x:(p_2,p'_2))>(y) &\to f(g(y),\<[q_2,p_2,f(y,\emptyset),2],x>)
\end{align*}
where the first and the third rules are obtained as done in the previous step
using the \(\{y\}\)-skeleton \(y\)
while the other two rules are constructed not only by replacing the \(q_2\)-call
with the \(\{y\}\)-skeleton \( f(y,\emptyset) \) but also
by using the \emph{helper state} \([q_2,p_2,f(y,\emptyset),2]\)
to compute a concrete output tree at the node of \(\emptyset\).
The helper state plays a role of waiting for the time 
when it is able to give the output tree.
In general,
a helper state call \(\<[q,p,t,u]^{(|t/u|)},x>\) for \(x\in L_p\) is expected to
compute a subtree at \(u\) of \(M_q(x)\) of the form \(t\in\lcop{M_q(L_p)}_Z\)
where \(t/u\subseteq Y_{\rk(q)}\setminus Z\),
and hence the rules of the helper state are defined by the original \(q\)-rules
with traversing its right-hand side according to the path \(u\).
For the current example, from the original \((q_2,b)\)-rules, we obtain
\begin{align*}
\<[q_2,p_2,f(y,\emptyset),2],b(x:(p_i,p'_j))> &\to \<q_0,x> 
\end{align*}
for all \(i,j\in\{1,2\}\) such that \(h''_{b}((p_i,p'_j)) = (p_2,p'_2)\).
The other rules of \([q_2,p_2,\ab f(y,\emptyset),2]\) can be arbitrarily defined
because their inputs are not in \(L_{(p_2,p'_2)}\), so that they are not reachable.
Then we find the state \(q_2\) becomes improper
for \(L_{(p_1,p'_1)}\) and \(L_{(p_1,p'_2)}\)
where 
\(\lcop{M_{q_2}(L_{(p_1,p'_i)})}_{\{y\}}=\{g(y), f(g(y),\emptyset)\}\) with \(i=1,2\).
This procedure terminates as we will show later.

We shall show another example to illustrate how the helper states work.
Let \(M=(\{q_0,q_1,q_2\},\{p\},\Sigma,\Delta,R,h_0)\) be an mttr
with the trivial look-ahead \((\Sigma,\{p\},h_0)\) and \(R\) consists of the rules:
\begin{align*}
&\<q_0, a(x)> \to \<q_1, x>(e) &
&\<q_0, e> \to e \\
&\<q_1, a(x)>(y) \to f(\<q_2, x>(e,g(y,\<q_0,x>)),\<q_0,x>) &
&\<q_1, e>(y) \to f(g(e,g(y,e)),e) \\
&\<q_2, a(x)>(y_1,y_2) \to g(\<q_2,x>(g(y_1,e),e),y_2) &
&\<q_2, e>(y_1,y_2) \to g(y_1,y_2)
\end{align*}
Then we find that two states \(q_1\) and \(q_2\) are improper
since both
\(\lcop{M_{q_1}(L_p)}_{\{y\}}=\{f(g(\emp,g(y,\emp)),\emp)\}\)
and
\(\lcop{M_{q_2}(L_p)}_{\{y_2\}}=\{g(\{y_1\},y_2)\}\)
are finite.
We will remove every call of both improper states simultaneously.
%This example is more complex than the previous one
%because the finiteness of \(\lcop{M_{q_1}(L_p)}_{\{y\}}\) is found
%not only the \(q_1\)-rules but also the \(q_2\)-rules.
Let \(t_1=f(g(\emp,g(y,\emp)),\emp)\) and \(t_2=g(\{y_1\},y_2)\)
be the \(\{y\}\)-skeleton for the state \(q_1\)
and the \(\{y_1\}\)-skeleton for the state \(q_2\), respectively.
As done for the previous example,
we replace the \(q_1\)- and the \(q_2\)-calls 
by \(t_1\) and \(t_2\), respectively,
with calls of helper states at the leaf nodes labeled by subsets of parameters, and 
the \(q_2\)-calls in the \((q_1,a)\)- and \((q_2,a)\)-rules
by the \(\{y\}\)-skeleton \(t\) with calls of helper states

 to obtain
\begin{align*}
\<q_0, a(x)> &\to
f(g(\<[q_1,p,t_1,1.1],x>,g(e,\<[q_1,p,t_1,1.2.2],x>)),\<[q_1,p,t_1,2],x>)
\\
\<q_1, a(x)>(y) &\to 
f(g(\<[q_2,p,t_2,1],x>(e),g(y,\<q_0,x>)),\<q_0,x>) 
\\
\<q_2,a(x)>(y_1,y_2) &\to g(g(\<[q_2,p,t_2,1],x>(g(y_1,e)),e),y_2)
\end{align*}
where no refinement with look-ahead is required because of the uniqueness.
The rules of the helper states will be
\begin{align*}
\<[q_1,p,t,1.1],a(x)> &\to \<[q_2,p,t',1],x>(e)
&
\<[q_1,p,t,1.1],e> &\to e
\\
\<[q_1,p,t,1.2.2],a(x)> &\to \<q_0,x>
&
\<[q_1,p,t,1.2.2],e> &\to e
\\
\<[q_1,p,t,2],a(x)> &\to \<q_0,x>
&
\<[q_1,p,t,2],e> &\to e
\end{align*}

\fi





