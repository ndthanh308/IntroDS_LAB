%!TEX root = main.tex

% macros (will be moved later)
%\def\<#1>{\langle #1 \rangle}

%\newcommand\nopr{\mathrm{\$}}
%\newcommand\pout{\mathsf{pOut}}

%\section{Depth-Proper Normal Form}
%%%%%%%% From our arXiv paper
\iffalse
Because the LSHI and LHI properties of MTTs pertain to the growth of the height of the output,
those properties are linked to the nesting of state calls in the output.
For example an MTT that is finite-nesting is trivially LSHI,
the converse is however not true
because some state calls do not always increase the height of the output tree.
The goal of this normal form is
to remove those states that have a bound on the amount of height they contribute to the output,
i.e. the depth at which they use their parameters.
This normal form will allow us to characterize LSHI and LHI by finite-nesting constraints.
\fi
%%%%%%%% 

\medskip

We present two examples to show how a depth proper mttr is obtained.
%The formal construction is given in Section~\ref{sect:dp}.
%
\newcommand\qid{q_{\mathrm{id}}}
Let \(M=(\{q_0,q_1,q_2,q_3,q_4,\qid\},\{p\},\Sigma,$ $\Delta,q_0,R,h_0)\)
with \(\Sigma=\{a^{(1)},e^{(0)}\}\) and 
%\(\Delta=\{a_1^{(1)},a_2^{(2)},a_3^{(2)},a_4^{(1)},f^{(2)},g^{(3)},e^{(0)}\}\)
\(\Delta=\{a_1^{(1)},a_2^{(1)},f_1^{(2)},f_2^{(2)},f_3^{(2)},g^{(3)},e^{(0)}\}\)
be an mttr 
where \((\Sigma,\{p\},h_0)\) is the trivial look-ahead with
$L_p=T_\Sigma$,
Suppose that \(R\) contains the following rules for \(a\): 
\begin{align*}
\<q_0, a(x)> &\to \<q_1,x>(e)
\\
\<q_1, a(x)>(y) &\to f_1(y, \<q_2,x>(a_1(y)))
\\
\<q_2, a(x)>(y) &\to g(y, \<q_3,x>(f_2(y, \<\qid, x>)), \<\qid, x>)
\\
\<q_3, a(x)>(y) &\to f_1(y, \<q_4,x>(f_3(y, \<\qid, x>)))
\\
\<q_4, a(x)>(y) &\to a_2(y)
\end{align*}
Then
because of \(L_p=\tree\Sigma\)
we have \(q_i\in F_p\) and \(Y(q_i,p)=\{y\}\) for any \(i=1,2,3,4\), and
the corresponding sets of \(\{y\}\)-skeleta are
\begin{align*}
\lcop{M_{q_1}(L_p)}_{\{y\}} &= 
\{f_1(y, g(a_1(y), f_1(f_2(a_1(y), \emp), a_2(f_3(f_2(a_1(y), \emp), \emp))), \emp))\}
\\
\lcop{M_{q_2}(L_p)}_{\{y\}} &= 
\{g(y, f_1(f_2(y, \emp), a_2(f_3(f_2(y, \emp), \emp))), \emp)\}
\\
\lcop{M_{q_3}(L_p)}_{\{y\}} &= \{f_1(y, a_2(f_3(y, \emp)))\}
\\
\lcop{M_{q_4}(L_p)}_{\{y\}} &= \{a_2(y)\}
\end{align*}
when the rules for \(e\) are appropriately given
so as for each of the sets above to be a singleton for simplicity.
Let \(t_i\) be the skeleta such that \(\lcop{M_{q_i}(L_p)}_{\{y\}} = \{t_i\}\).
When the skeleton contains no sequence node such as \(t_4\),
the \(q_4\)-calls in the right-hand side of every rule are easily removed
by substituting (in a second-order fashion) \(t_4\) for \(\<q_4,x>\).
For example,  the \(q_3\)-rule above will be 
\[ 
\<q_3, a(x)>(y) \to f_1(y, a_2(f_3(y, \<\qid, x>)))\text. 
\]
When the skeleton contains sequence nodes such as $\emptyset$,
our construction replaces them by \emph{helper states}; such states
traverse the input until further output needs to be generated.
A helper state has the form \([q,p,t,u]\) where
\(\<[q,p,t,u],s>\) for \(s\in L_p\) computes 
the subtree at node \(u\) of $M_q(s)$.
For example, the \(q_2\)-rule above which contains a \(q_3\)-call will be
\begin{align*}
&\<q_2, a(x)>(y) \to\\&\qquad
     g(y, 
       f_1(f_2(y, \<\qid, x>), a_2(f_3(f_2(y,\<\qid, x>), 
                                       \<[q_3,p,t_3,212],x>))),
       \<\qid, x>)
\end{align*}
by replacing the call by \(t_3\) whose sequence node is replaced by a helper state.
Since the sequence node \(t_3/212\) is $\emptyset$, the helper state has no parameter.
We will see later the case of skeleta containing non-empty sequence nodes.
Similarly the \(q_0\)-rule will be 
\begin{align*}
&\<q_0, a(x)>\to\\&\qquad %\<q_1,x>(e)
f_1(e, g(\begin{array}[t]{l}
         a_1(e), \\
         f_1(\begin{array}[t]{l}
             f_2(a_1(e), \<[q_1,p,t_1,2212],x>), \\
             a_2(f_3(f_2(a_1(e), \<[q_1,p,t_1,222112],x>), 
                     \<[q_1,p,t_1,22212,x>))), 
             \end{array} \\
         \<[q_1,p,t_1,23],x>))
         \end{array}
\end{align*}
%
A rule of a helper state \([q,p,t,u]\) is constructed from the \(q\)-rule
by first replacing each call of an \emph{improper} state
(at least one of whose parameter is improper) in the right-hand side
by the corresponding skeleton
and then taking the subtree at \(u\).
Thereby, from the obtained \(q_1\)-, \(q_2\)-, and \(q_3\)-rules above,
our construction gives
\begin{align*}
\<[q_1,p,t_1,2212],a(x)>   &\to \<[q_2,p,t_2,212],x>   \\
\<[q_1,p,t_1,222112],a(x)> &\to \<[q_2,p,t_2,22112],x> \\
\<[q_1,p,t_1,22212],a(x)>  &\to \<[q_2,p,t_2,2212],x>  \\
\<[q_1,p,t_1,23],a(x)>     &\to \<[q_2,p,t_2,3],x>     \\
\<[q_2,p,t_2,212],a(x)>    &\to \<\qid,x>              \\
\<[q_2,p,t_2,22112],a(x)>  &\to \<\qid,x>              \\
\<[q_2,p,t_2,2212],a(x)>   &\to \<[q_3,p,t_3,212],x>   \\
\<[q_2,p,t_2,3],a(x)>      &\to \<\qid,x>              \\
\<[q_3,p,t_3,212],a(x)>    &\to \<\qid,x> \text.
\end{align*}
For example, 
the right-hand side of the first rule of \(\<[q_1,p,t_1,2212],a(x)>\)
is constructed from the right-hand side of the rule of \(\<q_1,a(x)>\)
after substituted as shown above
by extracting its subtree at \(2212\), that is, \(\<[q_2,p,t_2,212],x>\).

Consider an input tree $s=a^5(s')$ with $s'\in T_\Sigma$
consisting of at least five top-most $a$-symbols
and apply the new $q_0$-rule shown above.
All the helper states in the right-hand side of that rule are now traversing
the node $1$ of $s$.
Now consider the derivation of the helper state $[q_1,p,t_1,22212]$:
it becomes $[q_2,p,t_2,2212]$ on node $11$ of $s$.
Then it become $[q_3,p,t_3,212]$ on node $111$ of $s$.
And finally it becomes $q_{\text{id}}$ on node $1111$ of $s$.
This is exactly right and corresponds to the computation of the original transducer.
All other helper states correctly become $q_{\text{id}}$ on node $111$ of $s$.

\bigskip

Next we shall show a more complex example where
a set of \(Z\)-skeleta is not singleton and 
a sequence node of a \(Z\)-skeleton is not empty
(and where the construction needs to be iterated).
%
Let \(M=(Q,\{p\},\Sigma,\Delta,q_0,R,h_0)\) 
with
\(Q=\{q_0^{(0)},q_1^{(1)},q_2^{(2)}\}\),
\(\Sigma=\{a^{(1)},b^{(1)},e^{(0)}\}\),
and \(\Delta=\{f^{(2)},g^{(1)},e^{(0)}\}\)
be an mttr 
where \((\Sigma,\{p\},h_0)\) is the trivial look-ahead with $L_p=T_\Sigma$
and \(R\) consists of these rules:
\begin{align*}
\<q_1, a(x)>(y_1) &\to \<q_2, x>(y_1, \<q_1,x>(y_1)) &
\<q_2, a(x)>(y_1,y_2) &\to f(y_1,\<q_1,x>(g(y_2)))
\\
\<q_1, b(x)>(y_1) &\to y_1 &
\<q_2, b(x)>(y_1,y_2) &\to f(y_2,y_1)
\\
\<q_1, e>(y_1) &\to g(y_1) &
\<q_2, e>(y_1,y_2) &\to f(y_2,y_1)
\end{align*}
We suppose that the \(q_0\)-rules are defined so that all states are reachable.
Now we have \(F_p=\{q_2\}\), \(Y(q_2,p)=\{y_1\}\), and 
\(\lcop{M_{q_2}(L_p)}_{\{y_1\}} = \{ t_1, t_2 \}\)
with \(t_1 = f(y_1,\{y_2\})\) and \(t_2=f(\{y_2\},y_1)\).
As before, we can rewrite \(q_2\)-calls with the skeleta,
but since there are two possibilities \(t_1\) and \(t_2\), 
we need to separate the rules according to the input using the look-ahead.
In general, \(F_p\) contains several states each of which may have multiple skeleta, 
so each look-ahead contains a finite map from \(F_p\) to skeleta.
Let \(\varphi_1=\{q_2\mapsto t_1\}\) and \(\varphi_2=\{q_2\mapsto t_2\}\) 
such that \(L_{p,\varphi_1}=\{a(s)\mid s\in\tree\Sigma\}\) and
\(L_{p,\varphi_2}=\{b(s)\mid s\in\tree\Sigma\}\cup\{e\}\).
The \((q_1,a)\)-rule containing a \(q_2\)-call is separated as
\begin{align*}
\<q_1,a(x:(p,\varphi_1))>(y_1) &\to f(y_1, \<[q_2,p,t_1,2],x>(\<q_1,x>(y_1))) \\
\<q_1,a(x:(p,\varphi_2))>(y_1) &\to f(\<[q_2,p,t_2,1],x>(\<q_1,x>(y_1)),y_1) 
\end{align*}
where \(\<[q_2,p,t_1,2],x>\) and \(\<[q_2,p,t_2,1],x>\) are helper states.
Each helper state has rank 1 
because the corresponding node in the skeleton is a sequence node of length 1.
The arguments of the call are inherited from
the arguments of the original \(q_2\)-call that occur in the sequence.
For example, \(\<[q_2,p,t_1,2],x>\) is called with \(\<q_1,x>(y_1)\)
since \(t_1\) has a sequence node \(\{y_2\}\) and 
the original \(q_2\)-call has \(\<q_1,x>(y_1)\) as the second argument.
The rules of these helper states are constructed from the original \(q_2\)-rule
with substitution (which causes nothing since no states in \(F_p\) are called)
and extracting a subtree at the sequence node, that is,
\begin{align*}
\<[q_2,p,t_1,2], a(x:(p,\varphi))>(y_1) &\to \<q_1,x>(g(y_1)) \\
\<[q_2,p,t_2,1], b(x:(p,\varphi))>(y_1) &\to y_1 \\
\<[q_2,p,t_2,1], e>(y_1) &\to y_1 \\
\end{align*}
where \(\varphi\in\{\varphi_1,\varphi_2\}\) and
we had to rename the parameter \(y_2\) into \(y_1\)
(because the helper states only refer to \(y_2\)).
Note that rules for \(([q_2,p,t_1,2],b)\), \(([q_2,p,t_1,2],e)\) and \(([q_2,p,t_2,1], a)\) 
do not have to be considered.
These rules are not referred because
the states are never called with the input symbols
due to their look-ahead.
For example, the \([q_2,p,t_1,2]\)-call occurs only 
in the \((q_1,a)\)-rule with \(x\in L_{p,\varphi_1}\)
in which the root symbol cannot be \(b\).
%They are not reachable because they are called with the specific look-ahead.

Thereby we have been able to remove every call of states in \(F_p\).
However, new improper states may be generated by the separation of rules 
because of the look-ahead introduction.
In fact, we have \(F_{p,\varphi_2}=\{q_1,q_2,[q_2,p,t_2,1]\}\) in the example above.
Since every \(q_2\)-call has already been removed in the previous step,
we have to apply the same technique again for the calls of 
\(q_1\) and \([q_2,p,t_2,1]\).
We have: \vspace{-2mm}
\begin{align*}
&Y(q_1,(p,\varphi_2))=\{y_1\}
&&\text{and}
&Y([q_2,p,t_2,1],(p,\varphi_2))=\{y_1\}, \\
&\lcop{M'_{q_1}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1, g(y_1)\}
&&\text{and}
&\lcop{M'_{[q_2,p,t_2,1]}(L_{p,\varphi_2})}_{\{y_1\}}=\{y_1\}\text.
\end{align*} \vspace{-5mm}

Look-ahead has to be introduced to determine which skeleton to output.
Two maps over \(F_{p,\varphi_2}\),
except for \(q_2\) whose call has already been removed,
are defined: 
\(\varphi_3=\{q_1\mapsto y_1, [q_2,p,t_2,1]\mapsto y_1\}\) and
\(\varphi_4=\{q_1\mapsto g(y_1), [q_2,p,t_2,1]\mapsto y_1\}\)
such that \(L_{p,\varphi_2,\varphi_3}=\{b(s)\in L_{p,\varphi_2}\mid s\in\tree\Sigma\}\) and
\(L_{p,\varphi_2,\varphi_3}=\{e\}\).
The \((q_1,a)\)- and \(([q_2,p,t_1,2],a)\)-rules with look-ahead \(\varphi_2\)
which contains a \(q_2\)-call 
are separated as follows:
\begin{align*}
\<q_1, a(x:(p,\varphi_2,\varphi_3))>(y_1) &\to f(y_1,y_1) \\
\<q_1, a(x:(p,\varphi_2,\varphi_4))>(y_1) &\to f(g(y_1),y_1) \\
\<[q_2,p,t_1,2], a(x:(p,\varphi_2,\varphi_3))>(y_1) &\to g(y_1) \\
\<[q_2,p,t_1,2], a(x:(p,\varphi_2,\varphi_4))>(y_1) &\to g(g(y_1)) 
\end{align*}
The resulting  mttr is depth proper.

\iffalse
Let \(M=(\{q_0,q_1,q_2\},\{p\},\Sigma,\Delta,q_0,R,h_0)\) be an mttr 
where \((\Sigma,\{p\},h_0)\) is the trivial tree automaton on \(\tree\Sigma\)
and \(R\) consists of the rules:
\begin{align*}
&\<q_0, a(x)> \to g(\<q_1, x>(\<q_0, x>)) &
&\<q_0, b(x)> \to g(\<q_2, x>(e)) &
&\<q_0, e> \to e
\\
&\<q_1, a(x)>(y) \to f(y, y) &
&\<q_1, b(x)>(y) \to g(y) &
&\<q_1, e>(y) \to g(y) 
\\
&\<q_2, a(x)>(y) \to\<q_2,x>(g(y)) &
&\<q_2, b(x)>(y) \to f(y, \<q_0,x>) &
&\<q_2, e>(y) \to y
\end{align*}
where the look-ahead \(p\) is omitted.
Then we can find that \(M_{q_1}(L_p)=M_{q_1}(\tree\Sigma)\)
is finite, that is, \(M_{q_1}(L_p)=\{f(y,y),g(y)\}\),
and hence \(Y(q_1,p)=\{y\}\).
Let us call such states \emph{improper}.
Every call of the improper state \(q_1\) will be substituted (in a second-order fashion)
by either one of these trees, and which one is determined by look-ahead.
The look-ahead is given as a tree automaton \((P,\Sigma,h)\) with \(P=\{p_1,p_2\}\)
that satisfies
\(M_{q_1}(L_{p_1})=\{f(y,y)\}\), \(M_{q_1}(L_{p_2})=\{g(y)\}\),
and \(L_{p_1}\cup L_{p_2}=\tree\Sigma\).
Thereby the \(q_0\)-rule for \(a\) is split into two rules
\begin{align*}
\<q_0, a(x:p_1)> &\to g(f(\<q_0, x>, \<q_0, x>)) 
\\
\<q_0, a(x:p_2)> &\to g(g(\<q_0, x>)) 
\end{align*}
for \(\{y\}\)-skeleta \(f(y,y)\) and \(g(y)\), respectively,
and the other rules are split into two which have the same right-hand side as before.
Observe that there are no state call of \(q_1\).

Let \(M'\) be the obtained mttr.
Since \(L_{p_2}\) consists of two types of trees, 
either \(b(t)\) with \(t\in\tree\Sigma\) or \(e\),
we find that 
\(M_{q_2}(L_{p_2})=\{y\}\cup\{f(y,t)\mid t\in\tree\Delta\}\),
thus \(\lcop{M_{q_2}(L_{p_2})}_{\{y\}}=\{y, f(y,\emp)\}\) is finite.
In a way similar to the above,
we remove all \(q_2\)-calls for look-ahead \(p_2\)
by replacing them either by \(y\) or by \(f(y, t')\)
where look-ahead determines which one to be used.
The tree \(t'\) is constructed according to the original rules.
The refined look-ahead automaton is given by \((P\times P',\Sigma,h'')\)
with \(P'=\{p'_1,p'_2\}\)
that satisfies 
\(\lcop{M_{q_2}(L_{(p_2,p'_1)})}_{\{y\}} =\{y\}\),
\(\lcop{M_{q_2}(L_{(p_2,p'_2)})}_{\{y\}} = \{ f(y,\emp) \}\), 
\(L_{(p_2,p'_1)}\cup L_{(p_2,p'_2)}=L_{p_2}\).
Every rule of \(M'\) is split into two again
where the set of look-ahead states becomes \(P\times P'\).
The original \((q_0,b)\)-rule and \((q_2,a)\)-rule with look-ahead \(p_2\)
containing \(q_2\)-calls
will be split into different new rules:
\begin{align*}
\<q_0, b(x:(p_2,p'_1))> &\to g(e)
\\
\<q_0, b(x:(p_2,p'_2))> &\to g(f(e,\<[q_2,p_2,f(y,\emptyset),2],x>))
\\
\<q_2, a(x:(p_2,p'_1))>(y) &\to g(y)
\\
\<q_2, a(x:(p_2,p'_2))>(y) &\to f(g(y),\<[q_2,p_2,f(y,\emptyset),2],x>)
\end{align*}
where the first and the third rules are obtained as done in the previous step
using the \(\{y\}\)-skeleton \(y\)
while the other two rules are constructed not only by replacing the \(q_2\)-call
with the \(\{y\}\)-skeleton \( f(y,\emptyset) \) but also
by using the \emph{helper state} \([q_2,p_2,f(y,\emptyset),2]\)
to compute a concrete output tree at the node of \(\emptyset\).
The helper state plays a role of waiting for the time 
when it is able to give the output tree.
In general,
a helper state call \(\<[q,p,t,u]^{(|t/u|)},x>\) for \(x\in L_p\) is expected to
compute a subtree at \(u\) of \(M_q(x)\) of the form \(t\in\lcop{M_q(L_p)}_Z\)
where \(t/u\subseteq Y_{\rk(q)}\setminus Z\),
and hence the rules of the helper state are defined by the original \(q\)-rules
with traversing its right-hand side according to the path \(u\).
For the current example, from the original \((q_2,b)\)-rules, we obtain
\begin{align*}
\<[q_2,p_2,f(y,\emptyset),2],b(x:(p_i,p'_j))> &\to \<q_0,x> 
\end{align*}
for all \(i,j\in\{1,2\}\) such that \(h''_{b}((p_i,p'_j)) = (p_2,p'_2)\).
The other rules of \([q_2,p_2,\ab f(y,\emptyset),2]\) can be arbitrarily defined
because their inputs are not in \(L_{(p_2,p'_2)}\), so that they are not reachable.
Then we find the state \(q_2\) becomes improper
for \(L_{(p_1,p'_1)}\) and \(L_{(p_1,p'_2)}\)
where 
\(\lcop{M_{q_2}(L_{(p_1,p'_i)})}_{\{y\}}=\{g(y), f(g(y),\emptyset)\}\) with \(i=1,2\).
This procedure terminates as we will show later.

We shall show another example to illustrate how the helper states work.
Let \(M=(\{q_0,q_1,q_2\},\{p\},\Sigma,\Delta,R,h_0)\) be an mttr
with the trivial look-ahead \((\Sigma,\{p\},h_0)\) and \(R\) consists of the rules:
\begin{align*}
&\<q_0, a(x)> \to \<q_1, x>(e) &
&\<q_0, e> \to e \\
&\<q_1, a(x)>(y) \to f(\<q_2, x>(e,g(y,\<q_0,x>)),\<q_0,x>) &
&\<q_1, e>(y) \to f(g(e,g(y,e)),e) \\
&\<q_2, a(x)>(y_1,y_2) \to g(\<q_2,x>(g(y_1,e),e),y_2) &
&\<q_2, e>(y_1,y_2) \to g(y_1,y_2)
\end{align*}
Then we find that two states \(q_1\) and \(q_2\) are improper
since both
\(\lcop{M_{q_1}(L_p)}_{\{y\}}=\{f(g(\emp,g(y,\emp)),\emp)\}\)
and
\(\lcop{M_{q_2}(L_p)}_{\{y_2\}}=\{g(\{y_1\},y_2)\}\)
are finite.
We will remove every call of both improper states simultaneously.
%This example is more complex than the previous one
%because the finiteness of \(\lcop{M_{q_1}(L_p)}_{\{y\}}\) is found
%not only the \(q_1\)-rules but also the \(q_2\)-rules.
Let \(t_1=f(g(\emp,g(y,\emp)),\emp)\) and \(t_2=g(\{y_1\},y_2)\)
be the \(\{y\}\)-skeleton for the state \(q_1\)
and the \(\{y_1\}\)-skeleton for the state \(q_2\), respectively.
As done for the previous example,
we replace the \(q_1\)- and the \(q_2\)-calls 
by \(t_1\) and \(t_2\), respectively,
with calls of helper states at the leaf nodes labeled by subsets of parameters, and 
the \(q_2\)-calls in the \((q_1,a)\)- and \((q_2,a)\)-rules
by the \(\{y\}\)-skeleton \(t\) with calls of helper states

 to obtain
\begin{align*}
\<q_0, a(x)> &\to
f(g(\<[q_1,p,t_1,1.1],x>,g(e,\<[q_1,p,t_1,1.2.2],x>)),\<[q_1,p,t_1,2],x>)
\\
\<q_1, a(x)>(y) &\to 
f(g(\<[q_2,p,t_2,1],x>(e),g(y,\<q_0,x>)),\<q_0,x>) 
\\
\<q_2,a(x)>(y_1,y_2) &\to g(g(\<[q_2,p,t_2,1],x>(g(y_1,e)),e),y_2)
\end{align*}
where no refinement with look-ahead is required because of the uniqueness.
The rules of the helper states will be
\begin{align*}
\<[q_1,p,t,1.1],a(x)> &\to \<[q_2,p,t',1],x>(e)
&
\<[q_1,p,t,1.1],e> &\to e
\\
\<[q_1,p,t,1.2.2],a(x)> &\to \<q_0,x>
&
\<[q_1,p,t,1.2.2],e> &\to e
\\
\<[q_1,p,t,2],a(x)> &\to \<q_0,x>
&
\<[q_1,p,t,2],e> &\to e
\end{align*}

\fi





