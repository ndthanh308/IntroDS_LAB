\section{Design of \toolname}
\label{sec:design}
This section describes the design of \toolname, which aims to prevent \ac{pdos} and \ac{pados} attacks by attacks by achieving thread isolation for provenance data processing. Similar to Sysdig, \toolname captures system call, thread switching, and system signal events, and allows users to provide custom logic for processing these events.

\subsection{Design Goals} 
\toolname is designed to address the super producer threat by satisfying the following properties:

\noindent \textbf{G1 - Zero Data Lost.} \toolname must record all provenance data generated by the system to prevent \ac{pdos} attacks.

\noindent \textbf{G2 - Performance Isolation.} \toolname must ensure that a super producer cannot affect overall system performance, preventing attacks such as \ac{pados}.

\noindent \textbf{G3 - Low Overhead.} \toolname should not introduce significantly higher costs than existing auditing frameworks.

\subsection{Design Principles} \toolname is guided by two design principles: self-consuming execution and synchronized logging buffer.

\noindent \textbf{Self-consuming execution.} With \toolname, each thread processes its own generated provenance data. This differs from the centralized processing architecture of current auditing frameworks and addresses the super producer threat by achieving resource and data isolation. Each thread uses its own resource quota to process its provenance data in a dedicated buffer, preventing a super producer from evicting other threads’ system events or slowing them down by occupying their resource quota.

\noindent \textbf{Synchronized logging buffer.} \toolname allocates a dedicated logging buffer for each thread and dynamically instruments provenance data processing logic into each thread when the buffer is full. This synchronized strategy ensures no provenance data is overwritten or lost, regardless of the super producer’s data volume.

These principles are realized through a threadlet-based approach. A threadlet is a self-contained piece of code that exists in the memory space of a host thread. \toolname instantiates provenance data processing logic as a threadlet, inserts it into the memory of the currently running thread, and consumes the provenance data stored in the dedicated buffer. This type of threadlet is referred to as a consumer throughout the paper.

The threadlet-based design of \toolname offers three advantages: \begin{inparaenum}[(1)] \item It allows \toolname to use each running thread’s resource quota to process the provenance data generated by that thread, without breaking the OS’s resource isolation mechanism or slowing down the entire system. \item Synchronized insertion of a threadlet into a running thread’s memory space provides data isolation, preventing a super producer from manipulating or overwriting provenance data in other threads. \item The threadlet-based architecture is more resource-efficient and lightweight than a conventional thread, eliminating most thread switch overhead such as scheduling delay, cache movement, and priority inversion. \end{inparaenum}

In summary, the threadlet-based architecture satisfies three requirements: \circled{1} all provenance data is collected; \circled{2} a super producer cannot slow down the entire system; and \circled{3} overhead is optimized.

% Figure environment removed

\subsection{High-Level Workflow}
\toolname consists of two main components: a kernel module and a user-space consumer. Like other auditing frameworks, the kernel module intercepts system calls to collect provenance data and stores it in a dedicated logging buffer. The consumer, implemented as a threadlet, processes the provenance data.
In \toolname, provenance data includes three types of system events: system call, thread switching, and system signals. This definition is the same as that used by Sysdig~\cite{sysdig}.

The workflow of how \toolname handles system calls is shown in Figure~\ref{fig:workflow}. When a thread invokes a system call, the kernel captures it (\circled{1}) and executes it (\circled{2}). The kernel module of \toolname then catches and records the system call in a dedicated in-kernel logging buffer (\circled{3}). If the buffer is not full, \toolname returns control to the host thread (\circled{4}). If the buffer is full or the thread exits, control is passed to the consumer (\circled{5}). Before transferring control, \toolname checks if there is a consumer in the running thread’s memory. If not, it first instruments the consumer into the running thread($\circled{5}^*$). Once the consumer has control, it uses the running thread’s resource quota to process the transferred provenance data, providing performance and data isolation between threads (\circled{6}). When processing is complete, control is returned to the original thread (\circled{7}). The workflow for handling thread switching and system signals differs from that for system calls only in how the kernel is entered (\circled{1} in Figure~\ref{fig:workflow}); all other steps are the same.

\subsection{Design Details}
This section describes the detailed design and implementation of key components in \toolname. Since \toolname’s kernel module is similar to that of Sysdig~\cite{sysdig}, its details are not discussed. Instead, the focus is on the unique design of the in-kernel logging buffer (\S\ref{sssec:buffer}), the user-space consumer (\S\ref{sec:consumer}), and consumer instrumentation (\S\ref{sssec:consumer-init}).

\subsubsection{In-Kernel Logging Buffer}
\label{sssec:buffer}

The in-kernel logging buffer is used to store provenance data in the kernel, improving the efficiency of auditing frameworks. When the buffer is full, the consumer consumes provenance data from the front end. Meanwhile, the kernel module pushes incoming provenance data to the end of the buffer  until the buffer is full.

\toolname uses a per-thread buffering scheme, allocating one logging buffer for each thread. This is chosen to meet design goal G2, which requires isolation of provenance data from each thread. This buffering scheme naturally distinguishes provenance data from every thread.

In \toolname, each system event contains the metadata and the argument data. The metadata includes the basic attributes of a system event, such as its type, timestamp, and size of the system event. The argument data is distinct for different types of system events. For system call events,  each element in the argument data is the value of a system call parameter. If the size of the parameter values is large (\eg the content of \code{read}), \toolname follows the practice of Sysdig by truncating the parameter values that are larger than 80 bytes. For thread switching, the argument data contains the IDs of the previous thread and the next thread, respectively. For signals, the argument data contains the signal ID and the process ID, which captures the signal. 

\subsubsection{The Consumer}
\label{sec:consumer}
The consumer is designed as a user-defined threadlet function for processing provenance data. It has one parameter that points to a copy of the in-kernel logging buffer in user-space and returns nothing. The key task for \toolname is to ensure the efficiency and security of the consumer. To achieve this, the conventional threadlet is improved.

\noindent \textbf{Kernel interaction.}
To efficiently and correctly pass the in-kernel logging buffer to the consumer, \toolname uses \code{mmap} to directly map the buffer from the kernel to user space. This avoids the overhead of copying data and restricts the consumer from accessing other in-kernel memory.

\noindent \textbf{Memory protection.}
The key challenge for the consumer is to ensure that it cannot be compromised by the host process. Since the host thread or other parallel threads are in the same process as the consumer, they could potentially modify the consumer’s data. To prevent this, \toolname uses a comprehensive approach that combines address space randomization, an isolated heap, and MPK to protect the consumer. Figure~\ref{fig:layout} summarizes the memory protection mechanisms used by \toolname. The consumer is located in a randomized memory region with a dedicated protection key. This region includes a separate stack, heap, and mapped logging buffer.

First, \toolname randomizes the consumer’s address to prevent attackers from obtaining it, making it more difficult to compromise the consumer. When the consumer is first instrumented, \toolname randomly chooses the threadlet’s loading address, preventing attackers from obtaining the consumer’s address before the threadlet is run.

Second, \toolname allocates a dedicated heap and stack for the consumer to prevent memory-overflow-based attacks (e.g., ROP) from the host thread. Isolating the heap is challenging because an attacker could potentially compromise the heap allocator that allocates memory from the consumer’s dedicated heap region. To prevent this, \toolname pre-loads a customized heap allocator for the consumer that always allocates memory from the dedicated heap.

Finally, \toolname enforces memory isolation using MPK, a hardware primitive that achieves in-process memory isolation by controlling protection keys and their permissions with a thread-local register called \code{PKRU}~\cite{vahldiek2019erim,234966}. To protect the consumer, \toolname binds a dedicated \code{key} to all consumer memory. By updating the \code{PKRU} value, access permission for that key is enabled at the consumer entry point and disabled after it exits. Similar to previous approaches using MPK~\cite{vahldiek2019erim,234966}, \toolname ensures that the host thread cannot modify the \code{PKRU} register by scanning executable code to validate that it contains no \code{PKRU}-related instructions. In \toolname, all consumers in the same process share the same key. Since the total number of MPK keys is limited, enough keys are left for later use. Using one MPK key does not compromise \toolname’s security because MPK protection is thread-local~\cite{234966,mpk-intro}.


% Figure environment removed

\noindent \textbf{Privilege escalation.}
 Sandbox or container threads may have limited execution privileges. 
However, suppose the consumer uses the sandbox or container threads as host threads and inherits the limited privilege. In that case, it cannot perform necessary processing on the provenance data, such as writing the data to files or network~\cite{gui2019progressive,king_backtracking_2003-1,hossain_sleuth_2017,camflow,LPM,hifi,dap}. 
To this end, \toolname elevates the consumer's privileges by raising the \code{RLIMIT} and \code{CAPACITY} to unlimited and disabling the \code{SECCOMP}.
\toolname recovers these privileges when switching back to the sandbox or container thread.

\noindent \textbf{Atomic execution.}
Because of the privilege escalation, the sandbox or container thread may abuse the higher privilege of the consumer, thus breaking the system security policy.
To avoid such abuse and other data-racing between the consumer and the application thread, \toolname ensures the atomicity of the consumer execution by disabling all signals while the consumer is running. \toolname delays the upcoming signals until the consumer exits. 
\toolname enables all signals when switching back to the sandbox or container thread. At this moment, \toolname delivers the delayed signals to their handlers of the host thread.
Therefore, there is never interleaved execution between the consumer and the sandbox or container thread.

\subsubsection{Consumer Instrumentation} 
\label{sssec:consumer-init}

\toolname blocks the running thread and invokes the consumer (\protect\circled{5} in Figure~\ref{fig:workflow}) when either the in-kernel logging buffer is full or the running thread exits. The instrumentation process of the consumer is described in detail here.

\noindent \textbf{Threadlet initialization.}
\toolname prepares and initializes the consumer execution environment when the running thread traps into the kernel for the first time (\protect\circled{1} in Figure~\ref{fig:workflow}).
Specifically, \toolname allocates the space of the in-kernel buffer and a per-consumer control block. 
The control block stores the meta information describing a consumer, including its running state, the address of the user-defined entry function, memory layout, and protection key.

\noindent \textbf{Consumer loading.}
When the consumer is first instrumented, \toolname loads its binary($\protect\circled{5}^*$ in Figure~\ref{fig:workflow}). The loading process is similar to that of the \code{execve} system call. The kernel module reads and parses the consumer’s ELF file, allocates memory space, and loads all segments into memory, as shown in Figure~\ref{fig:layout}(b). Additionally, \toolname reserves an MPK key and initializes the consumer control block. This loading phase only occurs once for each thread, so its overhead does not significantly degrade system performance. Furthermore, existing in-memory template caching techniques can be leveraged to further optimize this cost~\cite{edgeos_atc_20}.

\noindent \textbf{Consumer invocation.}When invoking the consumer (\protect\circled{5} in Figure~\ref{fig:workflow}), \toolname's kernel module maps the logging buffer, saves the register context of the running thread, updates \code{PKRU} value, elevates the privilege and finally upcalls to the consumer's entry point.

\noindent \textbf{Consumer exit.}
We add a new system call that the consumer uses to exit (\protect\circled{7} in Figure~\ref{fig:workflow}).
This system call does the reverse of consumer invocation.
Concretely, it releases the logging buffer, recovers the privilege configuration, restores the \code{PKRU} and other registers, and lastly, switches back to the instrumented thread.
