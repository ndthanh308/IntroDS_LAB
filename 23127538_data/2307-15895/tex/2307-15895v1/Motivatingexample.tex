\section{Background}
\label{sec:background}

\begin{table*}[!t]
    \caption{A comparison of auditing frameworks. \emph{* means the collector is implemented by us. Per-core thread means each CPU core has a dedicated processing thread for provenance data. Per-core buffer means each CPU core has a dedicated event buffer.}}
    \label{tab:collectors}
    \centering
    \begin{tabular}{@{}ccccc@{}}
    \toprule
     Name       & Computation isolation & Data isolation       & Synchronization & Strategy   \\ \midrule
    Sysdig~\cite{fangback,sabharwal2020monitoring,salamero2019kubernetes,gantikow2019rule,tien2019kubanomaly,grimmer2019modern}       & Single thread    & Per-core buffer         &   Asynchronous     & pro-performance        \\
    Linux Audit~\cite{wang2019attentional,wang2020you,han2020sigl,hassan2019nodoze,inamforensic} & Single thread   & Single buffer           &     Asynchronous     & pro-performance         \\
    LTTng~\cite{kohyarnejadfard2019system,sultana2012improved,kohyarnejadfard2021anomaly,khreich2017anomaly}   & Single thread     & Per-core buffer                  &    Asynchronous      & pro-performance     \\
    Camflow~\cite{camflow,han2020ndss,pasquier2018ccs}     & Per-core thread    & Per-core buffer    &      Asynchronous     & pro-integrity       \\
    KennyLoggings~\cite{paccagnella2020logging}   & Single thread     & Single buffer                  &  Asynchronous      & pro-performance    \\
    Hardlog~\cite{ahmad2022hardlog}   & Single thread     & Single buffer                   &  Synchronous      & pro-performance    \\
    QuickLog~\cite{281386}       & Single thread     &  Single buffer                &  Asynchronous     & pro-performance    \\
    % ETW~\cite{wang2019attentional,wang2020you,han2020sigl,hassan2019nodoze}         & N/A  & N/A                  &   N/A       & N/A         \\
    Sysdig-Camflow*      & Per-core thread     & Per-core buffer                      &    Asynchronous    & pro-integrity         \\
    Sysdig-Integrity*      & Single thread    & Per-core buffer                      &    Synchronous   & pro-integrity         \\
    \bottomrule
    \toolname*      & Per-thread threadlet    & Per-threadlet buffer         &   Synchronous    & performance and integrity        \\
    \bottomrule
    \end{tabular}
    \vspace{-2ex}
\end{table*}

Auditing frameworks are the fundamental part of provenance analysis~\cite{king2003backtracking}, which is a technique that monitors system activities to detect and investigate attacks~\cite{fangback,sabharwal2020monitoring,salamero2019kubernetes,gantikow2019rule}. Popular auditing frameworks include Sysdig~\cite{sysdig}, LTTng~\cite{lttng}, and Linux Audit~\cite{audit}. These three auditing frameworks are the most widely cited in provenance-based detection solutions~\cite{fangback,sabharwal2020monitoring,salamero2019kubernetes,gantikow2019rule,tien2019kubanomaly,grimmer2019modern,wang2019attentional,wang2020you,han2020sigl,hassan2019nodoze,inamforensic,kohyarnejadfard2019system,sultana2012improved,kohyarnejadfard2021anomaly,khreich2017anomaly}. Besides, there are more recent auditing frameworks from academia, including Camflow~\cite{camflow,Camquery}, Hardlog~\cite{ahmad2022hardlog}, KennyLoggings~\cite{paccagnella2020logging}, and QuickLog~\cite{281386}. We thoroughly investigate the auditing frameworks published in industry and academia in recent years. We summarized the auditing frameworks in Table~\ref{tab:collectors}.


The existing auditing framework has a ``centralized'' architecture~\cite{sysdig,audit,lttng,Camquery}, as Figure~\ref{fig:sysdig} shows. This framework intercepts provenance events through a kernel module and digests them based on user-specified rules (\eg sending the provenance data to a remote log server or storing it to local files) in a centralized user-space module, called \texttt{collector}. Current auditing frameworks mainly differ in how they handle massive amounts of provenance data. They adopt two strategies: pro-performance and pro-integrity.


Several solutions, such as Sysdig~\cite{sysdig}, Linux Audit~\cite{audit}, and LTTng~\cite{lttng}, follow the ``pro-performance'' strategy. The rationale behind this strategy is that the auditing framework should minimize the system run-time overhead and maintain the performance of critical services on the monitored host. Current solutions limit the CPU usage of the auditing framework by allowing only \textit{one collector thread}. If this thread cannot process all the provenance events in time, it will either stop receiving events or drop them.


Solutions that adopt the ``pro-integrity'' strategy~\cite{camflow,Camquery} try to allocate enough resources to the auditing framework to handle all the provenance events. For instance, Camflow~\cite{camflow} uses a multi-threaded model that dynamically allocates computational resources based on the provenance data generation speed.
 
\section{The Super Producer Threat}
\label{sec:dilemma}

% Figure environment removed

The existing auditing frameworks use a centralized architecture that exposes them to the super producer threat. This threat occurs when an attacker exploits a super producer to consume the computational resources of other processes, breaking the logic and resource isolation between them. As a result, current auditing frameworks face a dilemma between data integrity and efficiency.

Figure~\ref{fig:sysdig} illustrates the super producer threat and the ``data-integrity vs. efficiency'' dilemma. The figure shows three user-space applications (the super producer, the malware, and the Nginx server) and an auditing framework that processes all the provenance data of these applications. The arrows indicate the direction of provenance data flow, and the width of the arrows reflects the amount of provenance data.

The super producer produces considerable system provenance data that exhausts the collector's computation capacity.
As a result, the collector either drops the provenance data of other applications or competes for more computational resources, implicitly breaking the resource quota of each application.
Thus, it becomes feasible to exploit \ac{pdos} and \ac{pados} attacks.

The pro-performance strategy restricts the resource quota of the collector to prevent performance degradation of the whole system~\cite{sysdig,lttng,audit}, but this exposes the system to the \ac{pdos} attack.  
Figure~\ref{fig:sysdig} shows that the collector's limited resources cannot cope with the high rate of provenance data generation by the super producer, and the collector will drop events when overloaded.
Moreover, the collector does not separate the provenance data from different applications, so other critical provenance events of the malware may be evicted, enabling the attackers to conceal the malware from detection.

The pro-integrity strategy gives the collector more resources to prevent the loss of provenance data~\cite{han2020ndss,pasquier2018ccs}, but this exposes the system to the \ac{pados} attack. 
Figure~\ref{fig:sysdig} shows how the collector consumes more resources to handle all provenance events, while the resources of other applications are reduced accordingly, resulting in significant performance interference for the whole system.
Moreover, since the super producer indirectly affects the system performance by using the collector, it only requires moderate resources to generate a large amount of provenance data.
Hence, existing isolation mechanisms (\eg \code{cgroups}), which limit the resource usage of the super producer, cannot effectively stop the \ac{pados} attack.

\subsection{Research Challenges}
Addressing the super producer threat is conceptually challenging. One possible solution is to suppress the super producer's generation speed of provenance data with some specified threshold. However, this strategy is not systematic. First, it is hard to set an effective threshold considering the dynamics of the systems. Second, attackers may use a set of super-producer processes to avoid reaching the threshold.

Another straightforward solution is to provide isolation inside the user-space collector. However, this strategy requires complex user-space logic in the collector, increasing the run-time overhead and difficulty in adapting to different systems. Note that simply providing a separate event buffer for different processes is not sufficient because other computational resources, such as the CPU, also need to be isolated.
More importantly, resource isolation or scheduling policy inside the collector may be inconsistent or conflict with the original policy made by the OS. Thus, different policies interfere with each other, causing all of them ineffective.

In summary, we need to redesign the auditing framework architecture, which can adaptively suppress the super producer, isolate provenance data, avoid performance interference, and respect the OS resource management policies.

\subsection{Attack Scenario and Threat Model}
\label{sec:case}
We consider a common scenario of a multi-tenant web server~\cite{multitenancy} as the potential context for \ac{pdos} and \ac{pados} attacks. We suppose that two Internet-facing applications, the \textit{target app} and the \textit{victim app}, from different users, are running on the server at the same time. These two applications have their own resource quota (\ie in separate \code{cgroups}). An auditing framework is running to monitor both the \textit{target app} and the \textit{victim app}. For the \ac{pdos} attack, the attacker's objective is to disable the auditing framework by attacking the \textit{victim app}. Then, the attacker can try to compromise the \textit{target app} without leaving traces in the provenance data. For the \ac{pados} attack, the attacker's aim is to paralyze the \textit{target app} by compromising the \textit{victim app}.

We define our threat model as follows: the attacker can transform the \textit{victim app} into a super producer. This does not imply that the attacker has to compromise the \textit{victim app}. It is enough to generate a large number of requests for a complex dynamic web application. Moreover, we assume that the attacker is aware of the auditing framework that is deployed on the server.

We also make the following assumptions about the security of the auditing frameworks. First, the kernel modules that collect provenance data are not vulnerable to attacks. Second, the provenance data is stored and transmitted securely and reliably. Third, the user space module that analyzes the provenance data is protected by existing intrusion detection systems that can alert us if the attacker tries to disable or compromise the auditing frameworks~\cite{sysdig,lttng}. The protection of the kernel module, the transmission, and the storage of provenance data is beyond the scope of this paper.
