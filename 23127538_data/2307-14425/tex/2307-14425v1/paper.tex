\documentclass[preprint,preprintnumbers,amsmath,amssymb,floatfix,nofootinbib]{revtex4}                                                

\usepackage{url}
\usepackage{epsf, array, color}
\usepackage{graphicx}
\usepackage[linktocpage,colorlinks,urlcolor=blue]{hyperref}

\setcounter{MaxMatrixCols}{30}


\begin{document}

\newcommand{\ket}[1]{\left|#1\right>}
\newcommand\scalemath[2]{\scalebox{#1}{\mbox{\ensuremath{\displaystyle #2}}}}

\title{Code conversion with the quantum Golay code for a universal transversal gate set}
%
\author{Matthew Sullivan}
%
\email{msullivan1@bnl.gov}
%
\affiliation{Department of Physics, Brookhaven National Laboratory, Upton, New York 11973 U.S.A.}
%
\date{\today}

\begin{abstract}
The $[[7,1,3]]$ Steane code and $[[23,1,7]]$ quantum Golay code have been identified as good candidates for fault-tolerant quantum computing via code concatenation. These two codes have transversal implementations of all Clifford gates, but require some other scheme for fault-tolerant $T$ gates. Using magic states, Clifford operations, and measurements is one common scheme, but magic state distillation can have a large overhead. Code conversion is one avenue for implementing a universal gate set fault-tolerantly without the use of magic states. Analogously to how the $[[7,1,3]]$ Steane code can be fault-tolerantly converted to and from the $[[15,1,3]]$ Reed-Muller code which has a transversal $T$ gate, the $[[23,1,7]]$ Golay code can be converted to a $[[95,1,7]]$ triorthogonal code with a transversal $T$ gate. A crucial ingredient to this procedure is the $[[49,1,5]]$ triorthogonal code, which can itself be seen as related to the self-dual $[[17,1,5]]$ 2D color code.
\end{abstract}

\maketitle

\section{Introduction}
\label{sec:intro}
Quantum error-correcting codes enable errors on a number of individual physical qubits to be corrected while preserving the logical qubits. Code concatenation enables one to suppress logical error rates to any desired level, as long as the physical error rates are below some threshold\cite{shor1996fault}. Among quantum error correcting codes, the quantum Golay code has been recognized as a good candidate with a low threshold\cite{cross2009faulttolerance}. The quantum Golay code is a 23-qubit code, based off the classical Golay code, which encodes one logical qubit and can correct errors on up to three physical qubits. 

The ability to perform arbitrary logical operations on encoded qubits is crucial for achieving fault-tolerant universal quantum computation. The Eastin-Knill theorem demonstrates that there are no quantum error-correcting codes which can implement a universal gate set transversally \cite{eastin2009restrictions}. There are codes which can implement all of the logical Clifford gates transversally, such as the 7-qubit Steane code\cite{steane1996error} and the quantum Golay code, but Clifford gates do not give universality. Using a source of noisy `magic states', and a magic state distillation procedure to increase the fidelity of said magic states, is one of the standard ways to implement the required non-Clifford gates fault-tolerantly and achieve universal quantum computation\cite{PhysRevA.71.022316}. There do exist, however, quantum codes which can implement the logical $\pi/8$ gate, also called the $T$ gate, transversally, such as those constructed from triorthogonal binary matrices\cite{bravyi2012magic}.
 The Clifford gates along with the $T$ gate would suffice for a universal gate set. This leads to one of the possible methods for implementing a universal gate set fault-tolerantly: the fault-tolerant conversion between a code with transversal $T$ and a code with transversal Clifford gates.

Anderson, Duclos-Cianci, and Poulin showed how this code conversion can be done rather simply for the 7-qubit Steane code and the 15-qubit Reed-Muller code, and more generally for the family of Reed-Muller codes\cite{steane1996error}.  Related to this, Paetznick and Reichardt\cite{paetznick2013universal} had earlier shown how to implement logical Hadamard fault-tolerantly using only transversal gates and error correction for the 15-qubit Reed-Muller code (framed as a particular gauge choice of 6 of the logical qubits for the $[[15,7,3]]$ quantum Hamming code). In this paper, this general scheme will be discussed and then applied to the quantum Golay code. The ingredients of this scheme are
\begin{enumerate}
\item a self-dual CSS code encoding 1 logical qubit which has fully transversal logical Pauli operators,
\item a triorthogonal code encoding 1 logical qubit.
\end{enumerate}
Related methods have been applied to $2D$ color codes by such names as stacked codes\cite{PhysRevA.93.022323}, gauge color codes\cite{PhysRevA.93.052332}, and doubled color codes\cite{bravyi2015doubled}. The resulting codes are not $2D$ topological codes, although Brayvi and Cross showed how they can be cleverly implemented using local operations\cite{bravyi2015doubled}. The general procedure for this construction will be referred to as `code-doubling'. This constructon will be used to give a $[[95,1,7]]$ triorthogonal code with transversal $T$ gate which can be converted to and from the quantum Golay code.


\section{General code-doubling procedure}
\label{sec:doubling}
The general procedure to construct a triorthogonal code from an $n$ qubit self-dual CSS code is similar to the construction of the Reed-Muller code from two copies of the Steane code, except that instead of a single ancillary qubit, a sequence of $m$ qubits encoding a smaller triorthogonal code is used. As shall be demonstrated, this is necessary to preserve the code distance. This procedure is the general version of the implementations discussed in Refs~\cite{PhysRevA.93.022323,PhysRevA.93.052332,bravyi2015doubled}. To more closely match the standard notation for triorthogonal codes, the odd-weight logical and the even-weight generators of the self-dual CSS code will be written as a matrix $B_{sd}$ in block form as
\begin{equation}
\label{eq:selfdual}
B_{sd} = \begin{bmatrix}B_{sd,(1)} \\ \hline B_{sd,(0)}\end{bmatrix}.
\end{equation}
It will be useful to write an additional matrix $E_{sd}$ with even-weight rows such that the rows of $E_{sd}$ and $B_{sd}$ form a complete basis. For the smaller triorthogonal code, the corresponding triorthogonal matrix is similarly written in $B_{tri}$ in block form as
\begin{equation}
\label{eq:smalltriorthogonal}
B_{tri} = \begin{bmatrix}B_{tri,(1)} \\ \hline B_{tri,(0)}\end{bmatrix}.
\end{equation}
The orthogonal complement of $B_{tri}$ is spanned by the rows of the matrix 
\begin{equation}
\label{eq:tricomplement}
B_{tri}^\bot =
\begin{bmatrix} B_{tri,(0)} \\ C_{tri}
\end{bmatrix},
\end{equation} for some matrix $C_{tri}$ corresponding to the additional set of $Z$ stabilizers used for the triorthogonal code.

The derived triorthogonal matrix from code-doubling will now be presented. In block form, it is given by
\begin{equation}
\label{eq:doubledcode}
B_{doubled} =
\begin{bmatrix}
B_{doubled,(1)}\\ \hline
B_{doubled,(0)}
\end{bmatrix} =
\begin{bmatrix}
B_{sd,(1)} & B_{sd,(1)} & B_{tri,(1)}  \\ \hline
B_{sd,(0)} & B_{sd,(0)} & 0_m  \\
0_n & 1_n & B_{tri,(1)}\\
0_n & 0_n & B_{tri,(0)}
\end{bmatrix} ,
\end{equation}
with $0_k$, $1_k$ representing again a $k$ by 1 submatrix containing all 0 or all 1 entries, respectively, and with $B_{sd,(0)}$, $B_{sd,(1)}$, $B_{tri,(0)}$, $B_{tri,(1)}$ as in Eqs.~\ref{eq:selfdual}~and~\ref{eq:smalltriorthogonal}. For brevity, the matrix representations $B_{sd}$, $B_{tri}$, and $B_{doubled}$ will be used to refer to these three codes.

Before continuing, note the use of both $B_{sd,(1)}$ and $1_n$ in Eq~\ref{eq:doubledcode}. In Section~\ref{sec:intro}, it was mentioned that the construction would require that the self-dual CSS code only encoded a single logical qubit, and that it had fully transversal logical Pauli operators, so $B_{sd,(1)}$ and $1_n$ might ostensibly seem to be the same. Of course, there are smaller representations of the logical Pauli operators obtained from multiplication with stabilizers, so $B_{sd,(1)}$ is not unique. $B_{sd,(1)}$ is used where any smaller representation works in the construction and $1_k$ where only the fully transversal representation works. Since $1_k$ is necessary for one stabilizer, this means that this construction will have a large weight stabilizer when using a large self-dual code.

The reason that $B_{doubled}$ is a triorthogonal matrix is fairly simple: non-trivial products of three rows of $B_{doubled}$ involve one of the following: 
\begin{enumerate}
\item products of three rows of $B_{tri}$, which is itself a triorthogonal matrix;
\item twice the product of rows of $B_{sd}$, which gives 0 in arithmetic modulo 2;
\item the product of $1_n$ and two rows of $B_{sd}$, which reduces to the product of two rows of $B_{sd}$, which is 0 by the orthogonality of self-dual CSS codes.
\end{enumerate}
A basis of the orthogonal complement of $B_{doubled}$ is given by the rows of the matrix
\begin{equation}
\label{eq:doubledcomplement}
B_{doubled}^\bot = 
\begin{bmatrix}
B_{sd,(0)} & B_{sd,(0)} & 0_m \\
0_{n} & 1_{n} & B_{tri,(1)} \\
0_n & 0_n & B_{tri,(0)} \\
B_{sd,(0)} & 0_n & 0_m\\
E_{sd} & E_{sd} & 0_m\\
0_n & 0_n & C_{tri}
\end{bmatrix} ,
\end{equation}
with $B_{sd,(0)}$ as in Eq.~\ref{eq:selfdual}, $E_{sd}$ as in the discussion immediately following, $B_{tri,(0)}$ and $B_{sd,(0)}$ as in Eq.~\ref{eq:smalltriorthogonal}, and $C_{tri}$ as in the discussion immediately following.

The distance of this new code will now be addressed. From the starting representation of the logical Pauli operators, $(B_{sd,(1)} , B_{tri,(1)} , B_{sd,(1)})$, from Eq.~\ref{eq:doubledcode}, the logical Pauli $Z$ can be shortened using any of the stabilizers constructed from Eq.~\ref{eq:doubledcomplement}.
A self-dual code encoding one logical qubit with $k$ $X$ stabilizers and $k$ $Z$ stabilizers has $n=2k+1$ qubits. Since the rows of $B_{sd,(0)}$, $B_{sd,(1)}$, and $E_{sd}$ span the $2k+1$-D vector space and $B_{sd,(0)}$ and $E_{sd}$ have even weight rows, the rows of $B_{sd,(0)}$ and $E_{sd}$ span the even-weight subspace of the $2k+1$-D vector space. Thus, the stabilizers of the form $(B_{sd,(0)} , 0_m , B_{sd,(0)})$ and $(E_{sd} , 0_m , E_{sd})$ can be used to reduce the first and third block of the logical $Z$ to only operating on one qubit each.
Stabilizers from the set $(0_n , B_{tri,(0)} , 0_n)$ and $(0_n , C_{tri} , 0_n)$ can be used to make the second block of the logical $Z$ act on only $d_{tri}$ qubits, where $d_{tri}$ is the distance of the triorthogonal code constructed from $B_{tri}$. So the distance of this doubled code is at most $d_{tri} + 2$.

On the other hand, starting again from the original representation of the logical Pauli operators, $(B_{sd,(1)} , B_{sd,(1)}) , B_{tri,(1)} $, using the stabilizers from the set of $(0_{n}, 1_{n} , B_{tri,(1)})$ and $(B_{sd,(0)} , B_{sd,(0)} , 0_m)$, one can also reduce the logical $Z$ to the form $(1_n, 0_n, 0_m)$. From here, the stabilizers from the set $(B_{sd,(0)} , 0_n , 0_m)$ can be used to reduce the logical $Z$ down to acting on only $d_{sd}$ qubits, with $d_{sd}$ being the distance of the original self-dual code associated with the matrix $B_{sd}$. The distance $d_{doubled}$ of the doubled code associated with the triorthogonal matrix $B_{doubled}$ is thus
\begin{equation}
\label{eq:distance}
d_{doubled} = \min{(d_{sd}, d_{tri}+2)}.
\end{equation}
From this, it is clear why the general procedure needs a smaller triorthogonal code instead of a single ancilla bit like the Reed-Muller code construction. With only the single ancilla bit (which can be seen as a trivial case of a distance 1 triorthogonal code), the resulting code can only ever be up to distance 3. Since the Steane code is also distance 3, that is perfectly fine for that code conversion.

The faul-tolerant code conversion between the self-dual $B_{sd}$ and the triorthogonal $B_{doubled}$ works as in the Steane and Reed-Muller conversion procedure~\cite{steane1996error}.  For going from $B_{sd}$ to $B_{doubled}$:
\begin{enumerate}
\item Extend the self-dual code with entangled ancillas in the state $(\ket{0} \ket{0} + \ket{1} \ket{1})/\sqrt{2}$, with one of the logical qubits using the code $B_{sd}$ and one using the code $B_{tri}$
\item Measure the stabilizers of $B_{doubled}$
\item Perform error correction using only the syndromes of the stabilizers that were shared between the two forms
\item Fix the sign of the extra stabilizers  (the stabilizers of the form $(E_{sd} , E_{sd} , 0_m)$) using their measured syndromes
\end{enumerate}
For going from $B_{doubled}$ to $B_{sd}$:
\begin{enumerate}
\item Measure the stabilizers of the extended form of $B_{sd}$ with the entangled ancilla of $B_{tri}$ and the additional $B_{sd}$ copy
\item Perform error correction using only the syndromes of the stabilizers that were shared between the two forms
\item Fix the sign of the extra stabilizers (the $X$ stabilizers of the form $(B_{sd,(0)}, 0, 0)$ using their measured syndromes
\item Discard the additional ancilla
\end{enumerate}
The stabilizers from $B_{doubled,(0)}$ are shared among both $B_{doubled}$ and $B_{sd}$ extended by the entangled ancilla. These shared stabilizers suffice to correct up to $k$ errors for $2k+1 = d_{doubled}$, which makes the procedure fault-tolerant\footnote{There are also $Z$ stabilizers of the form $(B_{sd,(0)}, 0, 0)$ which are shared among both forms, but they are not needed to correct errors of weight $k$ or less; their syndromes can simply be fixed with Pauli corrections that commute with the other stabilizers and the logicals.}.
With the appropriate choice of a smaller triorthogonal code, this construction thus gives a procedure to fault-tolerantly convert between a self-dual CSS code (which has transversal implementations for $H$, $S$ and $CNOT$) and a constructed triorthogonal code which supports a transversal implementation of the logical $T$ gate, thus giving access to a fault-tolerant universal gate set.

\section{Minimum distance decoding}
\label{sec:syndrome}
To make full use of this code-doubling construction, it will be necessary to know how to correct errors. There is much that can be said about syndrome measurement itself; see e.g. Reference~\cite{PhysRevA.97.032331} and Reference~\cite{paetznick2012golay} which analyzed the preparation of ancillas for Steane's scheme for extracting syndromes for large codes, specifically the Golay code. Assuming the successful extraction of the error syndromes, the next question, which shall be addressed in this section, is then how to perform the error correction for a given syndrome in the code-doubling construction. Specifically, shortest error decoding using the shared $X$ and $Z$ stabilizers from only $B_{doubled,(0)}$ will be addressed. Appendix B of reference~\cite{PhysRevA.93.052332} includes a similar discussion.

There are three kinds of stabilizers in $B_{doubled,(0)}$:
\begin{enumerate}
\item Stabilizers acting only on the two blocks of the self-dual code,
\item Stabilizers acting only on the block of the smaller triorthogonal code,
\item Stabilizer correlating one of the self-dual blocks with the triorthogonal block.
\end{enumerate}
For the first two kinds of stabilizers, the correction procedure reduces to the shortest error correction procedure for the two kinds of codes used in the construction. The syndromes for the first kind of stabilizer can be corrected by applying the error correction procedure for the self-dual code to the first block only, and the syndromes for the second kind of stabilizer can be corrected using the error correction procedure for the triorthogonal code. The third kind of stabilizer, the one of the form $(0_{n} , 1_{n} , B_{tri,(1)})$, however, provides a slight complication. It is possible that the procedure for correcting the first two kinds of stabilizers will already leave the syndrome of the third kind of stabilizer with the correct $+1$ value, based on how many of the qubit corrections for the triorthogonal block overlap with $B_{tri,(1)}$. However, if the existing corrections will not fix the last stabilizer, then an additional correction is needed. As long as at least one qubit of the first self-dual block is going to be corrected, then the solution is simple: move one of the qubit corrections from the first self-dual block to the second self-dual block. 

The more complicated scenario is when there are no corrections required for the self-dual code blocks and yet the $(0_{n} , 1_{n} , B_{tri,(1)})$ stabilizer needs additional correction. There are two distinct ways to change this stabilizer while leaving the others unchanged: either apply a logical Pauli correction to one qubit in the first self-dual code block and to the same qubit in the second self-dual code block, or apply a logical Pauli operation to the component triorthogonal code block. The two options have opposite effect on the logical operator of the doubled code, so care needs to be taken to choose whichever is shorter\footnote{Reference~\cite{PhysRevA.93.052332} suggests always applying single qubit corrections to both self-dual blocks. The quantum Reed-Muller code, which can only correct 1 $Z$ error, can be seen as a special case of this construction with a trivial triorthogonal block of one single qubit, so the suggested procedure would not decode the shortest error in that case. This shows the need to distinguish which correction to apply.}. To accurately determine this, one not only needs to know the smallest weight representation of the error $E$ for any given syndrome, but also the smallest weight representation of $E+L$ for logical Pauli $L$ for the triorthogonal code. Then the question of which correction to make reduces to whether the smallest weight of $E+L$ is smaller or larger than two plus the smallest weight of $E$\footnote{For some situations, the answer will be obvious based only on the smallest weight of $E$ and the distance of the doubled code. However, when some subset of errors larger than $\frac{d-1}{2}$ are also correctable, then explicit information about the smallest weight of $E+L$ may be necessary sometimes.}.


\section{Application to the quantum Golay code}
\label{sec:golay}
\subsection{Constructing the $[[95,1,7]]$ triorthogonal code}
\label{sec:golay95}
Using the same notation as before for representing self-dual CSS codes with a matrix, the $[[23, 1, 7]]$ quantum Golay code is represented as 
\begin{equation}
\label{eq:golay}
B_{Golay}=\begin{bmatrix}B_{Golay,(1)} \\ \hline B_{Golay,(0)} \end{bmatrix} = 
\begin{bmatrix}
 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 \\
 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\
 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 \\
 1 & 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 \\
 1 & 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
 0 & 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 \\
 1 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 \\
 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 \\
 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 \\
 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 0 & 1 & 0 & 1 & 1
\end{bmatrix}.
\end{equation}
One possible choice for an appropriate even-weight matrix with which to form a complete basis together with $B_{Golay}$ is
\begin{equation}
\label{eq:golayE}
E_{Golay} = \begin{bmatrix}
 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 1 & 1 & 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
 1 & 1 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 1 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 1 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
 1 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 \\
 1 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 \\
 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 \\
 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1
\end{bmatrix},
\end{equation}
which is obtained from the product of 11 selected pairs of rows of $B_{Golay}$.

To construct a distance 7 triorthogonal code with this code-doubling scheme using the quantum Golay code, a distance 5 triorthogonal code is the remaining necessary ingredient. There is a $[[49,1,5]]$ code known in the literature which is suitable\cite{bravyi2012magic}.  One could imagine, however, using this same construction with a distance 5 self-dual CSS code and a distance 3 triorthogonal code in order to construct a distance 5 code. In fact, the $[[49,1,5]]$ code in the literature is already equivalent to such a code constructed from a $[[17,1,5]]$ self-dual CSS code (which is, in fact, a color code), and the $[[15,1,3]]$ quantum Reed-Muller code. The matrix representation of the $[[49,1,5]]$ triorthogonal code can be written in block form as
\begin{equation}
\label{eq:tri49}
B_{49} =
\begin{bmatrix}
B_{17,(1)} & B_{17,(1)} & B_{RM,(1)} \\
\hline
B_{17,(0)} & B_{17,(0)} & 0_{15} \\
0_{17} & 1_{17} & B_{RM,(1)}\\
0_{17} & 0_{17} & B_{RM,(0)}
\end{bmatrix},
\end{equation}
with the submatrices coming from the $[[17,1,5]]$ self-dual color code,
\begin{equation}
\label{eq:sd17}
B_{17} =
\begin{bmatrix}
B_{17,(1)} \\ \hline
B_{17,(0)}
\end{bmatrix} = 
\begin{bmatrix}
 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
 1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 1 & 1 & 0 & 0 \\
 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0
\end{bmatrix},
\end{equation}
and the $[[15,1,3]]$ triorthogonal Reed-Muller code,
\begin{equation}
\label{eq:RM}
B_{RM} =
\begin{bmatrix}
B_{RM,(1)} \\ \hline
B_{RM,(0)}
\end{bmatrix} = 
\begin{bmatrix}
 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\ \hline
 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\
 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 
\end{bmatrix}.
\end{equation}
For the convenient construction of a basis for the orthogonal complement of the $[[49,1,5]]$ triorthogonal matrix as in Eq.~\ref{eq:doubledcomplement}, two more matrices are required: an even-weight matrix $E_{17}$ whose rows, together with the rows of $B_{17}$, form a complete basis of $Z_{2}^{17}$, and a matrix $C_{RM}$ whose rows, together with the rows of $B_{RM,(0)}$ span the orthogonal complement of $B_{RM}$. One such choice for these matrices is
\begin{equation}
\label{eq:sd17extra}
E_{17} = 
\begin{bmatrix}
 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 1 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\
 0 & 0 & 1 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix}
\end{equation}
and
\begin{equation}
\label{eq:RMextra}
C_{RM} = 
\begin{bmatrix}
 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\
 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 \\
 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 \\
 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1
\end{bmatrix},
\end{equation}
both of which are constructed similarly to $E_{Golay}$ from Eq.~\ref{eq:golayE}. Using these matrices, the construction from Eq.~\ref{eq:doubledcomplement} gives
\begin{equation}
\label{eq:49complement}
B_{49}^\bot = 
\begin{bmatrix}
B_{17,(0)} & B_{17,(0)} & 0_m  \\
0_{17} & 1_{17} & B_{RM,(1)} \\
0_{17} & 0_{17} & B_{RM,(0)} \\
B_{17,(0)} & 0_{17} & 0_{15}\\
E_{17} & E_{17} & 0_{15}\\
0_{17} & 0_{17} & C_{RM}
\end{bmatrix} = 
\begin{bmatrix}
B_{49,(0)}\\
C_{49}
\end{bmatrix}
\end{equation}
as a basis for the orthogonal complement, and thus the $Z$ stabilizers for the 49 qubit triorthogonal code, with $C_{49}$ being the additional set of $Z$ stabilizers without corresponding $X$ stabilizers.

Using the code-doubling procedure with the $[[23,1,7]]$ quantum Golay code and the $[[49,1,5]]$ triorthogonal code, the construction yields a $[[95,1,7]]$ triorthogonal code which can be converted back and forth to the quantum Golay code fault-tolerantly. The matrix representation $B_{95}$ of the triorthogonal code in block form is
\begin{equation}
\label{eq:tri95}
B_{95} =
\begin{bmatrix}
B_{Golay,(1)} & B_{Golay,(1)} & B_{17,(1)} & B_{17,(1)} & B_{RM,(1)} \\
\hline
B_{Golay,(0)} & B_{Golay,(0)} & 0_{17} & 0_{17} & 0_{15} \\
0_{23} & 1_{23} & B_{17,(1)} & B_{17,(1)} & B_{RM,(1)} \\
0_{23} & 0_{23} & B_{17,(0)} & B_{17,(0)} & 0_{15} \\
0_{23} & 0_{23} & 0_{17} & 1_{17} & B_{RM,(1)}\\
0_{23} & 0_{23} & 0_{17} & 0_{17} & B_{RM,(0)}
\end{bmatrix},
\end{equation}
and a basis for the orthogonal complement can be given by the rows of the matrix
\begin{equation}
\label{eq:95complement}
B_{95}^\bot = 
\begin{bmatrix}
B_{Golay,(0)} & B_{Golay,(0)} & 0_{17} & 0_{17} & 0_{15} \\
0_{23} & 1_{23} & B_{17,(1)} & B_{17,(1)} & B_{RM,(1)} \\
0_{23} & 0_{23} & B_{17,(0)} & B_{17,(0)} & 0_{15} \\
0_{23} & 0_{23} & 0_{17} & 1_{17} & B_{RM,(1)}\\
0_{23} & 0_{23} & 0_{17} & 0_{17} & B_{RM,(0)}\\
0_{23} & B_{Golay,(0)} & 0_{17} & 0_{17} & 0_{15} \\
E_{Golay} & E_{Golay} & 0_{17} & 0_{17} & 0_{15} \\
0_{23} & 0_{23} & B_{17,(0)} & 0_{17} & 0_{15}\\
0_{23} & 0_{23} & E_{17} & E_{17} & 0_{15}\\
0_{23} & 0_{23} & 0_{17} & 0_{17} & C_{RM}
\end{bmatrix} = 
\begin{bmatrix}
B_{95,(0)}\\
C_{95},
\end{bmatrix}
\end{equation}
with $C_{95}$ giving the additional set of $Z$ stabilizers for the doubled code.
\subsection{Correcting errors}
\label{sec:golay95errors}
The three component codes whose error correction must be known to correct errors for the $[[95,1,7]]$ triorthogonal code are the $[[23,1,7]]$ quantum Golay code, the $[[17,1,5]]$ color code, and the $[[15,1,3]]$ quantum Reed-Muller code. Each of these reduces to error correction on a corresponding classical code. These will only be briefly summarized here. For the $[[23,1,7]]$ quantum Golay code, all errors on up to 3 qubits are correctable, and also {\em only} errors with a minimum weight of 3 or lower are correctable. For the $[[17,1,5]]$ color code, all errors on up to 2 qubits are correctable, but there is also a subset of errors of minimum weight 3 that are correctable. And for the $[[15,1,3]]$ quantum Reed-Muller code, only errors on a single qubit can be corrected using only the shared $X$ and $Z$ stabilizers. 

As mentioned in Section~\ref{sec:syndrome}, the error decoding procedure for the $[[95,1,7]]$ doubled code reduces to the slightly modified decoding procedure for the $[[23,1,7]]$ quantum Golay code and the $[[49,1,5]]$ triorthogonal code, and the decoding procedure for the $[[49,1,5]]$ code itself reduces to the slightly modified procedure for the $[[17,1,5]]$ color code and the $[[15,1,3]]$ quantum Reed-Muller code. The only special cases to consider are when the self-dual block has no errors and when the stabilizer correlating the self-dual block and component triorthogonal block needs additional correction. The relevant information for the error correction of the $[[49,1,5]]$ code is summarized in Table~\ref{table:errorprocedure}. Note that even some subset of errors of up to weight 4 are correctable for this code.

\begin{table}
\centering
\begin{tabular}{c|c|c||c|c|c}
color & Reed-Muller & parity & corrections & $w(E)$ & $w(E+L)$\\
\hline
 0 & 0 & no  &      & 0 & 5 \\
 0 & 0 & yes & $+2$ & 2 & 3 \\
 0 & 1 & no  &      & 1 & 4 \\
 0 & 1 & yes & $+L$ & 2 & 3 \\
 1 & 0 & no  &      & 1 & 4 \\
 1 & 0 & yes & move & 1 & 4 \\
 1 & 1 & no  &      & 2 & 3 \\
 1 & 1 & yes & move & 2 & 3 \\
 2 & 0 & no  &      & 2 & 3 \\
 2 & 0 & yes & move & 2 & 3 \\
 2 & 1 & no  &      & 3 & 4 \\
 2 & 1 & yes & move & 3 & 4 \\
 3 & 0 & no  &      & 3 & 4 \\
 3 & 0 & yes & move & 3 & 4 \\
 3 & 1 & no  &      & 4 & 5 \\
 3 & 1 & yes & move & 4 & 5 
\end{tabular}

\caption{Additional error correction information for the $[[49,1,5]]$ triorthogonal code. The first two columns indicate the number of errors indicated by the naive interpretation of the syndromes for the color code blocks (`color') and quantum Reed-Muller code block (`Reed-Muller'). The column `parity' indicates whether the stabilizer correlating the two component code blocks requires additional corrections. The `corrections' column indicates the extra correction to apply in  that case: $+L$ means applying an additional logical Pauli to the inner Reed-Muller block, and $+2$ means applying a single qubit Pauli correction to the same location in both color code blocks, and `move' means moving one qubit correction from the first color code block onto the second color code block. The last two columns are the minimum weights of the error $E$ and the error plus logical Pauli $E+L$.}
\label{table:errorprocedure}
\end{table}

Using the information on the weights from Table~\ref{table:errorprocedure} for the $[[49,1,5]]$ code, the additional error correction step for the $[[95,1,7]]$ doubled code can be determined. If the stabilizer correlating the $[[49,1,5]]$ triorthogonal block with one of the $[[23,1,7]]$ Golay blocks requires additional correction and there are no detected errors on the Golay blocks, then the additional correction will either be
\begin{enumerate}
\item applying an additional logical Pauli to the $[[49,1,5]]$ block, or
\item applying a single qubit Pauli correction to the same location in both Golay code blocks.
\end{enumerate}
If the weight of the error detected on the $[[49,1,5]]$ block is either 0 or 1, then option 2 is the correct option for the shortest error decoding. If the weight of the error is 2 or larger, then option 1 is the correct option\footnote{Performing the correction associated with option 1 using the actual shortest representation of the error and logical is not required but can be useful to minimize the number of gates applied.}. Note that while all errors of up to weight 3 are correctable for the $[[95,1,7]]$ code, since some errors of up to weight 4 are correctable on the $[[49,1,5]]$ block and errors of up to weight 3 are correctable on the $[[23,1,7]]$ blocks, even some subset of errors up to weight 7 are correctable by this code. 

\section{Discussion}
\label{sec:disc}
The construction of this doubled code allows for a few different ways to implement fault-tolerant quantum computation. The obvious one is the code conversion procedure already described. Clifford gates can be applied to the $[[23,1,7]]$ quantum Golay code, and then the code can be converted to the $[[95,1,7]]$ code when $T$ gates are necessary, and the conversion can be done back and forth depending on what gates are necessary. It is also interesting to note that a transversal $CNOT$ with the first 23 qubits of the $[[95,1,7]]$ as a control and the 23 qubits of a separate $[[23,1,7]]$ code as a target implements a logical $CNOT$ with a qubit encoded in the $[[95,1,7]]$ code as the control and a qubit encoded in the $[[23,1,7]]$ code as a target. The reverse, however, with the $[[95,1,7]]$ code as the target, does not preserve the codespace. Another possibility for fault-tolerance is to strictly use the $[[95,1,7]]$ triorthogonal code. Logical Pauli, $CNOT$, $S$, and $T$ gates can be implemented transversally with this code, and using the procedure of Ref.~\cite{paetznick2013universal}, the logical Hadamard can be implemented by transversal application of Hadamard followed by error correction.

The code doubling procedure can also generally be applied to a large class of self-dual CSS codes. One disadvantage is that for larger codes, the procedure yields large weight stabilizers. Although code doubling was presented in the light of code conversion between a self-dual CSS code and a triorthogonal code, the procedure also can be used merely for the construction of triorthogonal codes with larger distances. Triorthogonal codes are useful tools for magic state distillation, although the distillation procedures tend to benefit from codes with a high yield rather than a high distance\cite{bravyi2012magic}.

There is another relevant avenue to mention: the concatenation of two distinct codes with different transversal gate sets\cite{PhysRevLett.112.010505}. This has been considered using the $[[7,1,3]]$ Steane code and the $[[15,1,3]]$ quantum Reed-Muller code. The concatenated code is a $[[105,1,9]]$ code, but it does not have transversal implementations of some necessary gates. However, $H$ can be implemented non-transversally at the level of the $[[15,1,3]]$ code and transversally at the level of the $[[7,1,3]]$ code, while the reverse is possible for the $T$ gate. This preserves the ability to correct single-qubit errors after applying the $H$ and $T$ gates. The gates that are transversal for both codes ($CNOT$, $S$, and Pauli gates) have the full distance 9 protection, enabling correction of arbitrary errors on up to 4 qubits. The full protection for $CNOT$ gates in particular is one of the more appealing points, as the asymptotic threshold of the code in fact ends up limited by the pseudo-threshold for the $CNOT$ gates rather than $H$ or $T$\cite{PhysRevLett.117.010501}. One could perform the same sort of concatenation procedure with the $[[23,1,7]]$ and $[[95,1,7]]$ codes to create a $[[2185,1,49]]$, which can correct errors on up to 24 qubits for $CNOT$, $S$, and Pauli gates and up to 3 errors for $T$ and $H$ gates.

Due to the size of the doubled code, implementation of the above quantum error correcting schemes on hardware in the near-term would be difficult. The Steane and quantum Reed-Muller codes are both rather small at 7 and 15 qubits, respectively. The quantum Golay code, at 23 qubits, is bigger than both of those codes combined. On top of that, the doubled code presented requires more than 4 times the qubits of the quantum Golay code. In spite of this, the payoff over the Steane code and quantum Reed-Muller code is the larger code distance protecting against larger errors. When larger devices become available, these larger codes may prove advantageous.  A detailed analysis of the application of the various methods for this doubled code scheme could be a subject for future work.

\section{Conclusions}
\label{sec:conc}
Achieving fault-tolerant quantum computation is a requirement for scalable quantum computers. Although different avenues are possible for fault tolerance, code concatenation schemes remain a promising approach. The quantum Golay code has been recognized as a promising candidate for this purpose, but the existing methods to achieve a universal gate set for this code in the literature are based on magic states. In this paper, a triorthogonal code was constructed that can be related to the quantum Golay code. This construction enables a simple code conversion procedure for the quantum Golay code which enables the fault-tolerant implementation of a universal gate set without the use of magic state distillation. The constructed triorthogonal code can also be used as a triorthogonal quantum error-correcting code in its own right. 

\section*{Acknowledgements}
MS is supported by the United States Department of Energy under Grant Contract DE-SC0012704.

%\bibliographystyle{utphys}
\bibliography{references.bib}


\end{document}
