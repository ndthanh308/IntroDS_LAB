\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumerate}
\usepackage{amsthm}
\usepackage{comment}
\usepackage{appendix}
\usepackage{subcaption}
\usepackage{tikz-cd}
\usepackage{algorithm}
\usepackage{url}
\usepackage{algpseudocode}
\makeatother
\usepackage{graphicx}
\newcommand\norm[1]{\left\lVert#1\right\rVert}
\newcommand\shrunk[1]{\text{shrunk}(#1)}
\newcommand\troot[1]{\text{root}(#1)}
\newcommand\vr{\mathrm{VR}}
\newcommand\myceil[1]{\left \lceil #1 \right \rceil }
\newcommand\length[1]{\text{length}(#1)}
\newcommand\compo[1]{\text{compo}(#1)}
\newcommand{\union}[2]{\text{union}(#1,#2).}
\newcommand\dist[1]{\text{dist}(#1)}
\newcommand\neighbor[1]{\text{neighbor}(#1)}
\newcommand\ph[1]{\text{PH}_{#1}}
\newcommand\lune{\mathrm{lune}}
\newcommand\rng{\mathrm{RNG}}
\newcommand\id{\mathrm{id}}
\newcommand\mst{\mathrm{MST}}
\newcommand\sktwo{\mathrm{SK}_{2}}
\newcommand
\skone{\mathrm{SK}_{1}}
\newcommand
\sk{\mathrm{SK}}
\newtheorem{theorem}
{Theorem}[section]
\newcommand\inc{\mathrm{inc}_{r_1^{r_2}}}
\newcommand\incr{_{R}\mathrm{inc}_{r_1}^{r_2}}
\newtheorem{example}{Example}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definition}{Definition}[section]

\title{Reduced Vietoris-Rips Complexes: 

New methods to compute Vietoris-Rips Persistent Homology}
\author{Musashi Koyama, Vanessa Robins, Katharine Turner, Facundo M\'emoli}
\date{April 2023}

\begin{document}

\maketitle

\section{Introduction}

Persistent homology is the study of how topological features evolve in a filtration of topological spaces. The beginnings of persistent homology can be traced back to \cite{frosini_1990} where size theory, equivalent to modern day zero-dimensional persistent homology was introduced. Modern persistent homology was developed fairly simultaneously by Robins \cite{vanessa_robins_article}, Edelsbrunner, Letscher and Zomorodian \cite{edelsbrunner_original}. Since then, persistent homology has been employed in several disciplines such as health \cite{BIO21010LungCancerSurvivalisAssociatedWithPersistentHomologyofTumorImaging} and material science \cite{nearly_hexagonal_lattice}. 

One of the most fundamental structures in persistent homology is the notion of a persistence barcode. In the same way a barcode of a product at the store can give us information about the product a persistence barcode can give us information about the space. Typically, we will be interested in the shape of a set of points, which we will call a point cloud. To apply persistent homology to the point cloud, we construct a filtration of topological spaces using the point cloud. Popular choices include the Alpha-Shape filtration \cite{alpha_shape_reference} and the Vietoris-Rips filtration \cite{VietorisberDH}. For point clouds in $\mathbb{R}^2$ and $\mathbb{R}^3$, there already exist efficient algorithms which compute persistent homology of the Alpha-shape filtration for point clouds in lower dimensions but at the time of writing there is currently no software that is capable of computing Vietoris-Rips persistent homology  (VRPH) for large point clouds. In the digital age, data sets consisting of billions of data points are not uncommon, meaning if persistent homology is to be adopted by the greater science community then there is a necessity for software that can compute persistent homology for such large point clouds.

Currently the most popular software for computing VRPH is Ripser \cite{Ripser} and its GPU accelerated version Ripser++ \cite{zhang2020gpu}. At the time of writing, neither of these pieces of software have the capability to compute one-dimensional VRPH (1D VRPH) of point clouds with even $10^6$ points on any commercially available computers. 

The reason one-dimensional Vietoris-Rips persistent homology is difficult to compute is because the Vietoris-Rips filtration of a point cloud requires a large number of simplices. To compute 1D VRPH of a point cloud with $n$ points. One will require a filtration with $O(n^3)$ simplices. Even if you have a method which computes 1D VRPH in linear time on the number of simplices this computational complexity is simply too high for widespread adoption of VRPH. 


In this paper we present a new algorithm for computing VRPH of Euclidean point clouds in $\mathbb{R}^2$ and $\mathbb{R}^3$. One may question the usefulness of such an algorithm, since we could simply compute Alpha-shape persistent for such point clouds. Whilst the implementation has only been done in two and three dimension the methods here can be extended to higher dimensions though there are difficulties that will arise, as discussed in the conclusion. Furthermore, due to techniques such as Multidimensional Scaling \cite{MDSPAPER} it may be possible to use the techniques here to obtain approximate 1D VRPH for non-Euclidean point clouds. 


\section{Notation and Terminology}

In this section we detail the notation and terminology which will be used in this paper. A simplex consisting of the vertices $a,b,c$ will be denoted as $<abc>$. For a given simplicial complex $Y$ the $q$th skeleton of $Y$ will be denoted as $\sk_{q}(Y)$. The set of $q$-cells in $Y$ will be denoted by $Y_q$. When referring to a homology class $[\gamma]$ it shall be understood that $\gamma$ is a single representative of the homology class $[\gamma]$. Sometimes, when it is more convenient, we shall use coset notation to represent homology classes as well. All homology will be done using coefficients in $\mathbb{Z}_{2}$. $X$ will always be used to denote a point cloud, that is a finite set in some Euclidean space $\mathbb{R}^{d}$. $d$ will also be used to denote the Euclidean metric, though this should not cause any confusion. In this paper, $n$ will exclusively be used to denote the size of a point cloud, that is $n = |X|$. Throughout this paper we will also be making the assumption that all pairwise distances between points of $X$ are unique. 

\section{Preliminaries}
In this section we will briefly review some preliminary concepts necessary for content later in the paper.

\subsection{Persistent Homology}
Here we review the notion of persistent homology and persistent barcodes. We will \emph{not} discuss either of these concepts in their full generality, only covering what is needed for our purposes. The reader who wants more details is directed towards \cite{book}.

First we will define the notion of a filtration of topological spaces. 

\begin{definition}[Filtration of Topological Spaces]
\label{def-filtration-of-topological-spaces}
Consider a totally ordered set $\mathcal{I}$ and suppose we have a set of topological spaces $(K_{i})_{i\in \mathcal{I}}$ such that for $i\leq j$ in $\mathcal{I}$ we have that $K_{i} \subset K_{j}$. We will call such a collection of spaces $(K_{i})_{i\in \mathcal{I}}$ a filtration of topological spaces.
\end{definition}

For $i<j$ and $q \geq 0 $ an integer we can apply the $q$-dimensional homology functor $H_{q}(-)$ to the inclusion map $K_{i}\hookrightarrow K_{j}$ to obtain the map $f_{i}^{j}:= H_{q}(K_{i})\rightarrow H_{q}(K_{j})$. We are interested in tracking the evolution of homology classes as $i$ takes increasing values from $\mathcal{I}$. To this end we are ready to introduce the notion of birth and death times. 

\begin{definition}[Birth Times]
\label{def-birth-time}
Consider a non trivial homology class $[\gamma] \in H_{q}(K_{i})$. Then $[\gamma]$ is said to be born at $i$ if $i$ is the smallest such value that $[\gamma]$ can not be expressed in the form $f_{i'}^{i}([\beta]) = [\gamma]$ for some $[\beta] \in  H_{l}(K_{i'})$ and $i'<i$. In this case, we will say that $[\gamma]\in H_{q}(K_{i})$ was ``born at time $i$".  
\end{definition}

\begin{definition}[Death Times]
\label{def-death-time}
Consider a non trivial homology class $[\gamma]$ in $H_{q}(K_{i})$ which is born at time $i$. Then $[\gamma]$ is said to die at time $j>i$ if $f_{i}^{j}([\gamma]) = 0$ and for $j' <j$ we have $f_{i}^{j'}([\gamma]) \neq 0$. In this case we will say that the homology class $[\gamma]$ which was born at time $i$ dies at time $j$.  
\end{definition}

For the rest of this paper we will consider the case where $\mathcal{I} = [0,\infty)$. Since $\mathcal{I}$ consists of real numbers we can define the notion of the persistence of a homology class.

\begin{definition}[Persistence of a Homology Class]
\label{def-persistence-of-homology-class}
Consider a homology class $[\gamma]$ which is born at time $i$ and dies at time $j$. Then $j-i$ is referred to as the persistence of the homology class $[\gamma]$. 
\end{definition}

We can obtain a holistic visual representation of all homology classes in the form of a persistence diagram. 

\begin{definition}[Persistence Diagrams]
Consider a filtration of topological spaces $(K_{i})_{i\in [0,\infty)}$. Then the multiset consisting of all $(i,j) \in \mathbb{R}^2$ such that $[\gamma]\in H_{q}(K_{i})$ is born at time $i$ and dies at time $j$ will be referred to as the $q$-dimensional persistence diagram of the filtration $(K_{i})_{i\in [0,\infty)}$. 
\end{definition}

An equivalent representation of the Persistence Diagram is the Persistence Barcode. This involves for each $(b,d)$ in the persistence diagram, drawing a bar above the number line representing $[0,\infty)$ from $b$ to $d$. Throughout this paper, the barcode representation will be favoured since the persistence of each homology class is more readily visualised. 

\subsection{Vietoris-Rips Complexes and Filtrations}

Here we review the notion of the Vietoris-Rips complex \cite{reitberger2002leopold}. From the Vietoris-Rips complex we can build the Vietoris-Rips filtration. In what follows, $X$ will always be a finite metric space, and for the purposes of this paper, one can simply consider $X$ to be a point cloud as discussed in the ``Notation and Terminology" section. We let $d(-,-)$ denote the metric. 


\begin{definition}
\label{def-vietoris-rips-complex}
The Vietoris-Rips complex of $X$ with scale $r$ refers to the following simplicial complex which we shall denote by $\text{VR}^{r}(X)$. A set $\{x_{0},...,x_{p}\}\subset X$ is a p-dimensional simplex in $\text{VR}^{r}(X)$ if for all $i,j\in \{0,...,p\}$ we have $d(x_{i},x_{j}) \leq r$. 
\end{definition}

Note we have not proven that $\text{VR}^{r}(X)$ is actually a simplicial complex, though this follows easily from the definitions. It is easy to see that $(\text{VR}^{r}(X))_{r\in [0,\infty)}$ is a filtration and we call this filtration the Vietoris-Rips filtration of $X$. Applying the $H_{1}(-)$ functor to the Vietoris-Rips filtration of $X$ one can then compute the one-dimensional persistence barcode of the Vietoris-Rips filtration of $X$. We will sometimes refer to this barcode as the $1$-dimensional Vietoris-Rips persistent homology of $X$ and denote it by $\mathrm{PH}_{1}(X)$. Computing this efficiently will be the focus of the rest of this paper. Since for a point cloud $X$ we will only be looking at computing $\mathrm{PH}_{1}(X)$, thus for the sake of brevity, given a point cloud $X$ we will sometimes refer to the $1$-dimensional Vietoris-Rips persistent homology of $X$ as simply the persistent homology of $X$. 

\subsection{Minimum Spanning Acycles}
The notion of a minimum-spanning acycle will be useful in later discussions when we discuss relative neighborhood graphs. We briefly introduce them here. The following can be found in \cite{minimum_spanning_acycles}. In the following, $H_{q}(-)$ will always refer to the reduced homology. 
\begin{definition}
Consider a  simplicial complex $K$. Let $K^{(q-1)}$ be the $(q-1)$-skeleton of $K$. Then a subset of $q$-simplices $S$ is said to be an acycle if $H_{q}(S\cup K^{(q-1)}) = 0$. 
\end{definition}

\begin{definition}
Consider a simplicial complex $K$. Let $K^{(q-1)}$ be the $(q-1)$-skeleton of $K$. Then a subset $S$ of $l$-simplices $S$ is said to be spanning if $H_{q-1}(S\cup K^{(q-1)})=0$.
\end{definition}

Suppose there is a weight function $w:K\rightarrow \mathbb{R}$ which assigns each simplex a weight. Then we define a minimum spanning acycle as follows. 

\begin{definition}
Consider a weighted simplicial complex $K$ with a weight function $w:K\rightarrow \mathbb{R}$. Then a subset $S$ of $q$-dimensional simplices is called a $q$-minimum spanning acycle if $S$ satisfies the following.  

\begin{itemize}

\item $S$ is acyclic. That is we have $H_{q}(S\cup K^{(q-1)})=0$

\item $S$ is spanning. That is we have $H_{q-1}(S\cup K^{(q-1)})=0$

\item $w(S)=\sum_{s\in S}w(s)$ is minimal out of all spanning acycles $S$.

\end{itemize}

\end{definition}

For $q=1$ this is the definition of the minimum spanning tree. We assume the weight of a simplex $\sigma$ will be the scale $r$ for which $\sigma$ is added to the filtration, that is $w(\sigma)=\max_{x,y\in \sigma}d(x,y)$. We introduced the notion of a minimum spanning acycle because they have some nice properties in relation to birth and death values. The following theorem is from \cite{minimum_spanning_acycles}.

\begin{theorem}
\label{births-and-deaths}
Consider a  weighted simplicial complex $K$ with weight $w:K\rightarrow \mathbb{R}$. Let $S$ be an $q$-spanning acycle.

\begin{itemize}

\item $\{w(\sigma)\}_{\sigma \in S}$ is the set of death times of $(q-1)$-dimensional homology classes of the filtration induced by $w$.

\item $\{w(\sigma)\}_{\sigma \in K_{q}\setminus S }$ is the set of birth times of $q$ dimensional homology classes of the filtration induced by $w$.

\end{itemize}

\end{theorem}

Consider a point cloud $X$ with $|X|=n$ and let $K$ be the $n-1$ simplex consisting of all points in $X$ as its vertices. Letting $q=1$ Theorem \ref{births-and-deaths} says that all the weights of the edges of the one-spanning acycle (minimum spanning tree) correspond to the death of zero dimensional homology classes and any one-simplices not contained in the minimum spanning tree correspond to the birth of one dimensional homology classes. It should be noted that in the Vietoris-Rips filtration of a point cloud there are several homology classes that die as soon as they are born and that the set of one-simplices not in the minimum spanning tree will contain these edges. One should also note that Theorem \ref{births-and-deaths} makes no reference as to how to pair these birth times with their corresponding death times.  

\subsection{Relative Neighborhood Graphs}
In this section we discuss a structure which is heavily related to the computation of one-dimensional Vietoris-Rips persistent homology. First we define the notion of a lune. As usual, $X$ will be a point cloud, though some of the following can be generalized to more general metric spaces. 

\begin{definition}[Lune]
\label{def-lune}
Consider two points $a$ and $b$ in a point cloud $(X,d)$. Then the lune of the one simplex $\langle ab \rangle $, denoted as $\lune ( \langle ab \rangle )$ is defined as the following. 

\begin{equation}
\lune (\langle ab \rangle) = \{ x \in X \hspace{6pt} | \hspace{6pt} d(a,x) < d(a,b) \hspace{6pt} \text{and} \hspace{6pt} d(b,x) < d(a,b) \} 
\end{equation}
\end{definition}

It should be emphasised that the inequalities in the definition of the lune are strict. It is necessary to use strict inequalities in order to exclude $a$ and $b$ from the lune itself. 

Now we are ready to define the Relative Neighborhood Graph \cite{ToussaintRNG} of a point cloud $X$. 
\begin{definition}[Relative Neighborhood Graph of a point cloud]
\label{def-rng}
Consider a point cloud $X$. Then the Relative Neighborhood Graph of $X$, which we shall denote as $\rng (X)$ is the graph with 

\begin{itemize}
    \item Set of vertices $X$

    \item Set of edges $E$. Where $E$ is the set $\{\langle xy \rangle \hspace{6pt} | \hspace{6pt} \lune (\langle xy \rangle ) = \emptyset\}$
\end{itemize}
\end{definition}

Note that the RNG can still be defined for any finite metric space $X$. That is, for a point cloud $X$, $\rng (X)$ is the set of one-simplieces with empty lune. $\rng (X)$ has some interesting proprties. The following lemma is a result from \cite{ToussaintRNG}.

\begin{lemma}
\label{lemma-mst-in-rng}
Consider a point cloud $X$. Then we have 

\begin{equation}
\mst (X) \subset \rng (X) \subset \mathrm{DT}(X)
\end{equation}
\end{lemma}

That is, for a point cloud $X$, its minimum spanning tree is a subset of its relative neighborhood graph. The next lemma, which is a new result, discusses the computational importance of edges which are in $\rng (X)$ but are not in $\mst (X)$.

\begin{lemma}
\label{RNG-lemma-3}
For a point cloud $X$. $\rng (X) $  contains all edges that give birth to a one-dimensional homology class with non-trivial persistence. Furthermore, the edges of $\rng (X) \setminus \mst (X)$ correspond to the births of $1$-dimensional homology classes with non-trivial persistence. 
\end{lemma}

\begin{proof}
Since the MST is a $1$-spanning acycle it follows from \cite{minimum_spanning_acycles} that all the non-MST edges correspond to births in the Vietoris-Rips filtration. Consider any edge $e=\langle xy \rangle$ that gives birth to a one-dimensional homology class. We must have that $\text{lune}(e)$ is either empty or non-empty. If $\text{lune}(e) \neq \emptyset$ then there exists a point $z$ such that $d(z,x)<d(x,y)$ and $d(z,y)<d(x,y)$. This means that the addition of $e$ to the filtration gives birth to the cycle $\langle xy \rangle + \langle yz \rangle + \langle xz \rangle $ which immediately dies since $\langle xyz \rangle$ is added at the same time. Now consider an edge $e$ in $\rng (X)- \mst (X)$ and suppose now that $\text{lune}(e)= \emptyset$. This means at scale $r=d(x,y)$ no two-simplex was added since we are assuming uniqueness of pairwise distances. Thus no one-cycle could have died at scale $r$ and thus $e$ corresponds to the birth of a non-trivial homology class. 
\end{proof}

It should be noted that the above lemma also holds as long as $X$ is a finite metric space with unique pairwise distances. This means that provided we have $\rng (X)$ and $\mst (X)$ we know the following information about the one dimensional Vietoris-Rips persistent homology before actually computing it: The birth times of all homology classes with non-trivial persistence and the number of bars in the persistence barcode. The latter is particularly important because we will use it in the stopping condition utilised in the algorithm later in this paper. 

\section{Reduced Vietoris-Rips Complex}

In this section we cover a new result on one-dimensional Vietoris-Rips persistent homology of a point cloud $X$. The result proved here will be used extensively in later sections. The main benefit of this result is that instead of having to examine $O(n^3)$ two-simplices and $O(n^2)$ one-simplices to calculate persistent homology one can reduce the number of two-simplices needed to be examined to $O(n^2)$. Though this may seem like a minor improvement it will prove to have profound effects on the computation of Vietoris-Rips persistent homology. 




\subsection{Construction of the Reduced Vietoris-Rips Complex}

We now describe how to construct the Reduced Vietoris-Rips complex which from here on in we will sometimes refer to simply as the ``reduced complex". 
Frequently, we will be interested in the distribution of points in the lune of a given edge $\langle xy \rangle$. 

\begin{definition}[Connected Components of a Lune]
\label{def-connected-components-of-lune}
Consider points $x$ and $y$ in a point cloud $(X,d)$. Let $d(x,y) = r$. Consider a graph with vertices consisting of the points in $\lune (\langle xy \rangle)$. We join two points $p,q \in \lune (\langle xy \rangle )$ by an edge if $d(p,q) < r$. Suppose this graph has $c$ connected components, then we say that $\lune (\langle xy \rangle)$ has $c$ connected components. 
\end{definition}

Whilst everything that has been stated thus far has applied to finite metric spaces in general, it is at this point we specialise to the case where $X$ is a finite subset of Euclidean space $\mathbb{R}^d$. We view $X$ as a finite metric space with the metric it inherits from Euclidean space. The reason for this is that in Euclidean space we can assert that the number of possible connected components of a lune is bounded above by a constant, though that constant does depend on $q$, the dimension of the Euclidean space. This can be easily shown via a packing argument. 

We are now in a position to describe how one builds the Reduced Vietoris-Rips Complex. 

\begin{definition}[Reduced Vietoris-Rips Complex]
\label{def-reduced-vietoris-rips-complex}
Consider a point cloud $X$. Then the Reduced Vietoris-Rips Complex of $X$ with scale $r$, denoted as $\vr _{R}^{r}(X)$ is the simplicial complex which consists of the following. 

\begin{itemize}
    \item $\vr_{R}^{r}(X)_{0} = X$ is the set of zero simplices

    \item $\vr_{R}^{r}(X)_{1}$ consists of the one-simplices $\langle xy \rangle $ where $x, y$ in $X$ such that $d(x,y) < r$. 

    \item For each one simplex $\langle ab \rangle  \in \vr_{R}^{r}(X)_{1}$ let $c_{xy}$ be the number of connect components of $\langle ab \rangle $. Choose points $z_{1},...,z_{c_{xy}}$ where $z_{i}$ is chosen from the $i$th connected component of $\langle xy \rangle $. $\vr_{R}^{r}(X)_{2}$ consists of the two-simplices $\{\langle xyz_{i} \rangle \}_{1 \leq i \leq c_{xy}}$ for all $\langle xy \rangle \in \vr_{R}^{r}(X)_{1}$. 
\end{itemize}

\end{definition}

It should be noted that when constructing $\vr_{R}^{r}(X)_{2}$, from each connected component \emph{any} point may be selected from the component. We also note that we have not actually shown that this is a simplicial complex. This once again easily follows from the definitions. Letting $r$ be the diameter of $X$, $\text{VR}_{R}^{r}(X)$ will have $O(n)$ zero-simplices and $O(n^2)$ one simplices. Given that $X$ will be a subset of some Euclidean space $\mathbb{R}^d$, it follows that for each edge in $\vr _{R} ^{r}(X)_{1}$, $O(1)$ two simplices will be added and thus there will be $O(n^2)$ two simplices in $\text{VR}_{R}^{r}(X)$. Since the geometric realisation of $\text{VR}_{R}^{r}(X)$ is a topological space and $\text{VR}_{R}^{r'}(X) \subset \text{VR}_{R}^{r}(X)$ for $r' <r$ it follows that $(\text{VR}_{R}^{r}(X))_{r\in [0,\infty)}$ is a filtration. We give this filtration a name in the definition that follows. 

\begin{definition}[Reduced Vietoris-Rips Filtration]
\label{def-reduced-vietoris-rips-filtration}
We will call the filtration $(\vr _{R}^{r}(X))_{r\in [0,\infty)}$ the Reduced Vietoris-Rips Filtration of $X$.
\end{definition}

\subsection{The Relationship between Vietoris-Rips complexes and their reduced counterparts}

So far we have detailed what the Reduced Vietoris-Rips complex is but we have not shown why it is useful. Here we state and prove a new result on Reduced Vietoris-Rips complexes which relates the one dimensional persistent homology of the Vietoris-Rips filtration of $X$ with the one dimensional persistent homology of the Reduced Vietoris-Rips filtration of $X$.


\begin{theorem}
\label{theorem-VR-RVR-isomorphism}
Consider a point cloud $X$ and let $r_{1},r_{2}>0$. Then we have the following diagram commutes. Here $\phi$ is an isomorphism which we shall describe in the proof. Note that we have used a slight abuse of notation in letting $f_{r_1}^{r_2}$ be the map that arises from applying $H_{1}(-)$ to the inclusion $\vr ^{r_1}(X) \subset \vr ^{r_2}(X)$ and $\vr_{R}^{r_1}(X)\subset \vr_{R}^{r_2}(X)$. 

\begin{equation}
\begin{tikzcd}
H_{1}(\vr _{R}^{r_1}(X)) \arrow[r, "f_{r_1}^{r_2}"] \arrow[d, "\phi"] & H_{1}(\vr _{R}^{r_2}(X)) \arrow[d, "\phi"] \\
H_{1}(\vr ^{r_1}(X)) \arrow[r, "f_{r_1}^{r_2}"] & H_{1}(\vr ^{r_2}(X))
\end{tikzcd}
\end{equation}

\end{theorem}

\begin{proof}
We first define $\phi$ and then show it is an isomorphism. Let $\sigma = \langle ab \rangle$ be a one-simplex in $\text{VR}_{R}^{r_1}(X)$. Let $\sigma + B_{1}(\text{VR}_{R}^{1}(X))$ be an element of $H_{1}(\text{VR}_{R}^{r_1}(X))$. Then we define $\phi(\sigma + B_{1}(\text{VR}_{R}^{r_1}(X))) = \sigma + B_{1}(\text{VR}^{r_1}(X))$. $\phi$ is well defined since if $\tau = \sigma + \partial c$, where $c\in C_{2}(\text{VR}_{R}^{r_1}(X))$ then $\phi(\tau + B_{1}(\text{VR}_{R}^{r_1}(X))) = \tau + B_{1}(\text{VR}^{r_1}(X)) = \sigma + \partial c + B_{1}(\text{VR}^{r_1}(X))$. Note since $\text{VR}_{R}^{r_1}(X) \subset \text{VR}_{R}^{r_2}(X)$ it follows that $C_{2}(\text{VR}_{R}^{r_1}(X)) \subset C_{2}(\text{VR}^{r_1}(X))$ and thus $B_{1}(\text{VR}_{R}^{r_1}(X)) \subset B_{1}(\text{VR}^{r_1}(X))$. Hence $\partial c \in B_{1}(\text{VR}^{r_1}(X)))$. Thus $\sigma + \partial c + B_{1}(\text{VR}^{r_1}(X)) = \sigma + B_{1}(\text{VR}^{r_1}(X))$. Hence we have $\phi(\sigma + B_{1}(\text{VR}_{R}^{r_1}(X))) = \phi(\tau + B_{1}(\text{VR}_{R}^{r_1}(X)))$. 

We next show that $\phi$ is surjective. Let $c + B_{1}(\text{VR}^{r_1}(X))$ be an element of $H_{1}(\text{VR}^{r_1}(X))$. Since all edges of $\text{VR}^{r_1}(X)$ are less than $r_1$ it follows that $c + B_{1}(\text{VR}_{R}^{r_1}(X))$ will be mapped to $c + B_{1}(\text{VR}^{r_1}(X))$ via $\phi$. 

We now show that $\phi$ is injective. We proceed with induction in order to prove this. Note the theorem is trivially true for $r_1 \in [0,\epsilon)$ for some $\epsilon$ smaller than the distance between the closest pair of points in $X$. Suppose the theorem is true for all $r<r_{1}$. We will show that with this inductive assumption we can prove that the theorem holds for $r_{1}$. Suppose that $\phi(c + B_{1}(\text{VR}_{R}^{r_{1}}(X))) = 0 + B_{1}(\text{VR}^{r_{1}}(X))$. We wish to show that $c \in B_{1}(\text{VR}_{R}^{r_1}(X))$. We have that $c \in B_{1}(\text{VR}^{r_{1}}(X))$. Thus we can write $c = \partial \gamma$ for some $\gamma \in C_{2}(\text{VR}^{r_1}(X))$. Let us write $\gamma = \sum_{i} \sigma_{i}$ where each $\sigma_{i}$ is a two-simplex. We can write 

\begin{equation}
\gamma = \sum_{\{i |\text{diam}(\sigma_{i}) < r_1\}} \sigma_{i} + \sum_{\{i |\text{diam}(\sigma_{i}) = r_1\}} \sigma_{i}
\end{equation}


Then we may write 
\begin{equation}
c = c_{<r_1} + c_{r_1} = \partial (\sum_{\{i |\text{diam}(\sigma_{i}) < r_1\}} \sigma_{i}) + \partial (\sum_{\{i |\text{diam}(\sigma_{i}) = r_1\}} \sigma_{i})
\end{equation}

Using the induction hypothesis we know that since 
\begin{equation}
\phi(c_{<r_1} + B_{1}(\text{VR}_{R}^{r_1}(X))) =\partial (\sum_{\{i |\text{diam}(\sigma_{i}) < r_1\}} \sigma_{i}) + B_{1}(\text{VR}_{R}^{r_1}(X)) = 0 + B_{1}(\text{VR}_{R}^{r_1}(X))
\end{equation}

it follows that $c_{<r_1} \in B_{1}(\text{VR}_{R}^{r_1}(X))$. Thus we can assume that $c = \partial(\sum_{i} \sigma_{i})$ where $\text{diam}(\sigma_{i}) =r_1$ for all $i$. We can write $c = \sum_{i} \partial \sigma_{i}$ meaning that if we can show $c_{i} = \partial \sigma_{i} \in B_{1}(\text{VR}_{R}^{r_1}(X))$ for each $i$ then we are done. Thus we may as well assume that $c = \partial \sigma$, where $\sigma$ is a two-simplex in $C_{2}(\text{VR}^{r_1}(X))$. Let $\sigma = \langle abx \rangle $ where $\langle ab \rangle$ is the longest edge of $\langle abx \rangle $. Our goal is to show that $\partial (\langle abx \rangle) \in B_{1}(\text{VR}_{R}^{r_1}(X))$. Then $x$ is in the lune of $\langle ab \rangle $. Consider the connected component of $\langle ab \rangle $ that $x$ lies in, let $y$ be the point in this connected component such that $aby \in \text{VR}_{R}^{r_1}(X)$. If $y = x$ then we are done, if not then since $x$ and $y$ are in the same component we know there exists $z_{1},...,z_{q}$ such that $x,z_1,...,z_q,y$ is a path where all consecutive points are within $r$ of each other. We know that $\partial(\langle abx \rangle  + \langle abz_1 \rangle + \langle xz_1a \rangle + \langle xz_1 b \rangle ) = 0$
and thus $\partial (\langle abx \rangle) = \partial(\langle abz_1 \rangle ) + \partial(\langle xz_1a\rangle ) + \partial ( \langle xz_1 b \rangle )$. $\partial(\langle xz_1a \rangle ), \partial ( \langle xz_1b \rangle )$ will be in $B_{1}(\text{VR}_{R}^{r_1}(X))$ due to the inductive hypothesis and the fact they both have diameter less than $r_1$. We can write $\partial(\langle abz_1 \rangle ) = \partial( \langle ab z_2 \rangle) +\partial ( \langle a z_1 z_2 \rangle) + \partial (\langle b z_1 z_2 \rangle)$. $\partial (\langle a z_1 z_2 \rangle )$ and $ \partial (\langle b z_1 z_2 \rangle)$ will be in $B_{1}(\text{VR}_{R}^{r_1}(X))$ due to the inductive hypothesis and the fact that both $\langle a z_1 z_2 \rangle$ and $ \langle b z_1 z_2 \rangle$ have diameter less than $r_1$. We can then continue the process until one eventually utilises $\partial (\langle abz_q \rangle ) = \partial (\langle aby \rangle) + \partial (\langle z_q y a \rangle) + \partial (\langle z_q y b \rangle)$. 


Commutativity of the diagram follows easily from the definition of $\phi$ and $f_{r_1}^{r_2}$. Hence the theorem is proved. 
\end{proof}



\section{The Algorithm for Computing one-dimensional Vietoris-Rips persistent homology}

In this section we discuss the main algorithm which will be used to compute 1D VRPH for a point cloud in Euclidean space. First we will begin a brief overview of the main differences and advantages between our algorithm and the algorithms utilised by others. We will then give a high level description of our algorithm, highlighting the main components. Lastly, we will give detailed explanations for each part of the Algorithm described in the high level description. When describing our algorithm we will view the point cloud $X$ as an $n \times d$ matrix where $X[a]$ is the $a$th row corresponding to the point with point ID given by $a$. In what follows, the letters $a$ and $b$ will exclusively be used for point IDs and $x,y,z$ will represent actual points in $X$. 

\subsection{Main differences and Advantages of our Algorithm}

At the heart of the algorithm, we still make use of a matrix reduction method like the one described in \cite{edelsbrunner_original}. There are two main things that makes our algorithm different. The first is that we don't construct the whole boundary matrix at the beginning, instead generating each column as each two-simplex is introduced to the filtration. The second is that we make use of the RNG in order to know when we have found all one-dimensional homology classes with non trivial persistence. This means we can stop generating columns once we have found all the bars in the barcode, and thus avoid reducing the whole boundary matrix. How much of the boundary matrix one will have to generate will depend on the point cloud itself, but in many cases one will only have to generate a small fraction of the columns of the whole boundary matrix. 

Unlike in Ripser \cite{Ripser}, we do not make use of cohomology. Using cohomology means one is working with a matrix with $O(n^2)$ columns with $O(n)$ elements in each column as opposed to using the standard boundary matrix with $O(n^3)$ columns and three elements in each column. Though it should be said that Ripser does not explicitly store the matrix and uses apparent pairs to drastically reduce the number of columns needed to be reduced. Using Theorem \ref{theorem-VR-RVR-isomorphism} we can, in a sense, get the best of both worlds. The boundary matrix we use still will have $O(n^2)$ columns but will only have 3 elements in each column. Furthermore, we won't even be generating all the columns, so the amount of columns we have to analyze will in some cases be significantly less than $O(n^2)$. 

In order to make use of what has been discussed, there are two main obstacles. The first is obtaining each one-simplex, one by one, in increasing diameter without computing all pairwise distances. The second is computing the lune of a one-simplex in an efficient fashion. Both of these can be somewhat resolved by utilising kd-trees \cite{bentley1975multidimensional}. kd-trees are a structure that excels in finding the $k$ nearest neighbors of a given point and finding all points within a given radius of a point for a set of points in Euclidean space. The use of kd-trees is one of the main ways we take advantage of the fact that out point cloud is in Euclidean space. In our algorithm, we utilised nanoflann to find the kd-trees. 

\subsection{High level description of the Algorithm}

In this part we give a high level description of the Algorithm. The algorithm can be broken down into the following steps. 

\subsubsection*{Step 1: Compute the RNG}

We first compute the RNG of the point cloud $X$. We then find $\mathrm{total\_ death} := |\mathrm{RNG}(X)-\mathrm{MST}(X)|$. The variable $\mathrm{total\_ death}$ tells us the number of bars we have in $\mathrm{PH}_{1}(X)$.

\subsubsection*{Step 2: Find the next smallest one-simplex}
In this part we find the smallest one-simplex $xy$ whose lune has not been computed yet. Keep in mind we have made the assumption that all pairwise distances are unique. So there will only be one such one-simplex. 

\subsubsection*{Step 3: Find the lune}

In this step we find the lune of $\langle xy \rangle$ found in in Step 2. 

\subsubsection*{Step 4: Find the connected components of the lune}

Let the points in $\mathrm{lune}(\langle xy \rangle)$ be denoted by $V$. Let $E$ be the set of one simplices made using points of $V$ that have diameter less than the length of $\langle xy \rangle$. Consider the graph $G = (V, E)$. In this step, we find $c$, the number of connected components of $G$. For $i=1,...,c$, choose a point $z_{i}$ from each connected component. 

\subsubsection*{Step 5: Add a column for each connected column of $G$}

If $\mathrm{lune}(\langle xy \rangle)$ is empty then this means there are no two-simplices with diameter equal to $d(x,y)$. In this case we do not need to add any columns. 

If $\mathrm{lune}(\langle xy \rangle)$ consists of one connected component then we only need to add one column to the boundary matrix corresponding the the boundary of $\langle xyz_{1} \rangle$. This column will not need to be reduced as its lowest one will correspond to $\langle xy \rangle$ which has only just been added to the filtration. 

If $\mathrm{lune}(\langle xy \rangle)$ consists of more than one connected component then we need to add one column for each two-simplex $\langle abx_i  \rangle$. With the exception of the first column added, all other columns will need to be reduced. 

\subsubsection*{Step 6: Find any bars}
If you actually performed reduction in Step 5, then you obtain the bars in the barcodes by finding the persistent pairs and then converting this into a real number by finding the diameter of each simplex in the pair.

\subsection{Detailed description of the algorithm}

In this section we give a detailed description of the algorithm, expanding upon the steps detailed in the high level explanation. 

\subsubsection*{Step 1: Compute the RNG}

There are several algorithms for computing $\mathrm{RNG}(X)$. In 2D Euclidean space one can find $\mathrm{RNG}(X)$ in $O(n\log (n))$ time by first computing the Delaunay triangulation of $X$, from which one can compute $\mathrm{RNG}(X)$ \cite{supowit_RNG}. Another algorithm also given by Supowitz works for all dimensions and has complexity $O(n^2)$. The complexity is however, also implicitly dependent on $d$, the dimension of the Euclidean space. For dimensions $d \geq 3$, we still have that $\mathrm{RNG}(X) \subset \mathrm{DT}(X)$ and can still first find the Delaunay triangulation and then compute the RNG from that. The unappealing aspect of this is that for $d\geq 3$ there could potentially be $O(n^2)$ edges in the Delaunay triangulation and thus checking the lune condition for each edge will bring the total complexity to $O(n^3)$. In \cite{Agarwal1992RelativeNG}, the author demonstrates some randomized algorithms which can compute the $\rng (X)$ in expected time $O(n^{2(1-\frac{1}{d+1})+\epsilon})$ where $\epsilon > 0$ is arbitrarily small. The Delaunay triangulation is another place where the assumption that $X$ is a Euclidean point cloud is used. For point clouds in $\mathbb{R}^2$, we utilised Delaunator whose code can be found at \url{https://github.com/abellgithub/delaunator-cpp}. For three dimensions we utilised CGAL \cite{cgal:pt-t3-23b}. 

In our implementation for dimensions 2 and 3, we have chosen to use a simpler method which takes advantage of the kd-tree structure computed from $X$. We first compute the Delaunay triangulation and then check the lune condition of each edge by utilising the radius search capabilities of the kd-tree. Whilst in theory this still has a complexity of $O(n^3)$, it performs very well and outperforms Supowitz's algorithm by quite a large margin for point clouds in $\mathbb{R}^2$ and $\mathbb{R}^3$. The function $\mathrm{nRNG(X)}$ returns $|\mathrm{RNG}(X)- \mathrm{MST}(X)|$ using this method of computing $\mathrm{RNG}(X)$. 

\subsubsection*{Step 2: Find the next smallest one simplex}
At the beginning of the algorithm, after $\mathrm{RNG}(X)$ is computed we decide on a value of $k$ to be used for computing the $k$ nearest neighbors of each point in $X$. This can be done efficiently using the kd-tree constructed on $X$. We store this information in a cell array $N$. A cell array can simply be thought of as a list of lists, where each list can be of different length. $N[i] = \mathrm{KNN}(i,k)$ will consist of the point IDs of the $k$ nearest neighbors of $x_{i}$ with point ID greater than $i$. Using $N$, a minimum heap $H$ is created with elements of the form $(a,N[a][t],r,t)$. Here $a$ and $N[a][t]$ are the point IDs of the endpoints of a one-simplex and $r = d(X[a],X[N[a][t]])$. The variable $t$ is used to navigate the list $N[a]$, so that we can find the next closest point to the point with point ID $a$. The elements of the minimum heap $H$ will be sorted according to their $r$ values and $H$ will initially consist of $n-1$ elements of the form $(i, N[i][1], d(X[1], X[N[i][1]]), 1)$. Through each iteration of the main while loop we will pop the top element of the heap, say $(a,N[a][t],r,t)$ and insert $(a,N[a][t+1],r,t+1)$ into the heap. Since we only computed the $k$ nearest neighbors of each point in $X$, there is a chance that we will ``run out of neighbors" and exhaust a list $N[a]$ for some $a$. In this case we have implemented a ``backup" plan $\mathrm{FindAllNeighbors}(a)$ which computes all neighbors of $X[a]$ from nearest to farthest and then replaces $N[a]$ with that list. Obviously, we don't want to do this for all points $x\in X$ otherwise $N$ will require $O(n^2)$ memory to store and will ultimately require $O(n^2\log (n))$ time to compute. Thus the choice of $k$ should not be too small so as to avoid this. Then again the choice of $k$ should not be too large either so that we don't unnecessarily compute neighbors we don't need to. Another scenario that can occur is that a list $N[a]$ is exhausted and we have already utilised our ``backup plan". In this case, we don't add another edge to the minimum heap since all edges of the form $\langle X[a], X[b] \rangle$ have been added to the filtration where $a \neq b$. It is difficult to know what value of $k$ to choose via computing the persistence diagram, but from our experiments we have found that $k$ can be far less than $1\%$ of all edges and the algorithm won't have to resort to the ``backup" plan to the point that performance is compromised.

\subsubsection*{The bijection $\psi$}

The bijection $\psi$ is a book keeping tool which assigns each one-simplex an integer. Everytime we analyze the lune of a one-simplex we assign it the value of $\mathrm{one\_simplex\_counter}$ and then increase $\mathrm{one\_simplex\_counter}$ by one. We use the bijection when expressing the boundary of a two simplex, simply keeping a set of the three numbers corresponding the one-simplices which form the boundary. For example, the boundary of a two simplex $\langle xyz \rangle$ can be represented by the set of three integers $\{ \psi(\langle zy \rangle), \psi(\langle yz \rangle), \psi(\langle xz \rangle) \}$. 

\subsubsection*{Step 3: Find the Lune}
In order to find the lune of a given one-simplex $\langle xy \rangle$ we use the kd-tree on $X$ to find all points within $r : = d(x,y)$ of $x$ and all points within $r$ of $y$ and then find the intersection of these sets. 

\subsubsection*{Step 4: Find the connected components of the lune}
Let $G = (V,E)$ be the graph described in Step 4 of the high level description of the algorithm. In order to compute the number of connected components of $G$ we use a standard DFS (Depth First Search) algorithm. In our algorithm $\mathrm{FindCC(\langle xy \rangle)}$ will return a (possibly empty) vector $c$ whose $i$th entry consists of the point ID of a point chosen from the $i$th connected component. The particular implementation we used in our algorithm is an extremely minor modification of the implementation which can be found at \url{https://www.geeksforgeeks.org/connected-components-in-an-undirected-graph/}.

\subsubsection*{Step 5: Add a ``column'' for each connected column of $G$}

Instead of storing a boundary matrix we make use of two balanced binary search trees $T_{1}$ and $T_{>1}$. Our implementation in particular uses AVL trees \cite{AdelsonVelskii1963ANAF} but any other self balancing binary search tree could be used. The nodes in our trees consist of the following fields: left, right, height, key and column. The fields left, right, height and key are standard fields necessary for the AVL tree to function. The reason we use AVL trees is to speed up the matrix reduction process. 

If we \emph{were} building a boundary matrix, when a two simplex $\langle xyz \rangle$ is added to the filtration we would want to create a column vector with non-zero entries at rows $\psi(\langle xy \rangle), \psi (\langle yz \rangle)$ and $\psi (\langle xz \rangle)$. Instead, we will add a node to one of the trees $T_{1}$ and $T_{>1}$. 

If $\langle xyz \rangle $ was added from a one-simplex with only one connected component in its lune then we add a node to $T_{1}$ with the field column being the set $\{ \psi(\langle xy \rangle), \psi (\langle yz \rangle), \psi (\langle xz \rangle) \}$ and the field key being the maximum value of this set. Thus each node contains information of the non-zero elements of column and its lowest one. 

If $\langle xyz \rangle $ was added from a one-simplex with more than one connected component in its lune we create a node $g$ with the field column being the set $\{ \psi(\langle xy \rangle), \psi (\langle yz \rangle), \psi (\langle xz \rangle) \}$ and the field key being the maximum value of this set. However, we don't add this node to any tree yet. We then search $T_{1}$ and $T_{>1}$ to see if there are any columns with the same lowest one. This is where the benefit of using AVL trees is realised. If we are adding the $j$th two-simplex to the filtration then we will only have to search $O(\log (j))$ nodes to find out if another column has the same lowest one as opposed to standard matrix reduction where one could potentially have to check $O(j)$ columns. If we find a node with the same key (lowest one) then we ``add" the column field of this node to the column field of $g$. Since we are working with coefficients in $\mathbb{Z}_{2}$, ``adding" in this context will simply be taking the symmetric difference of the two sets. We then set the key field of $g$ to be the maximum element of this set. We repeat this process until either the key of $g$ cannot be found in either $T_{1}$ or $T_{2}$ or the column field of $g$ is empty. If the column field of $g$ is not empty, we add the node $g$ to $T_{>1}$. 


\subsubsection*{Step 6: Find any bars}
This part does not differ that much from its high level description. But now we have $\psi$ we can describe it more explicitly. Suppose we have for a two-simplex $\langle xyz \rangle$ generated from the lune of a one-simplex with more than one connected component that the node added for $\langle xyz \rangle$ does not have empty column field. Let $a$ be the value of the key field. Then $(\mathrm{diam}(\psi^{-1}(a)), \mathrm{diam} (\langle xyz \rangle))$ is a bar in the persistence barcode. We maintain a set called $\mathrm{barcode}$ and add $(\mathrm{diam}(\psi^{-1}(a)), \mathrm{diam} (\langle xyz \rangle))$ to it.

\newpage 
\section {Pseudocode of the Algorithm}

In this section we present pseudocode of the algorithm.


\begin{algorithm}[h!]
\caption{\label{main-algorithm-part-1}  Part 1}
\begin{algorithmic}[1]
\Procedure {FindPersistentHomology}{$X$}

    \Comment{Initialisation}
    \State $\mathrm{death\_count} = 0$
    \State $T_{1} = \emptyset$
    \State $T_{>1} = \emptyset$
    \State $N = \emptyset $
    \State $n = \mathrm{numrows}(X)$
    \State $H = \emptyset$
    \State $\mathrm{one\_simplex\_counter} = 0$
    \Comment{Populate list of lists N}
    \For { $i = 1:n$}
        \State $N[i] = \mathrm{KNN}(i,k)$
    \EndFor
    
    \Comment{Populate minimum heap H}
    \For { $i = 1:n$}
        \If {$N[i]$ is not empty}
            \State $H.\mathrm{insert}(i,N[i],d(i,N[i]),1)$
        \EndIf
    \EndFor

    \Comment{Find the number of bars in the bar-code}
    \State $\mathrm{total\_death} = \mathrm{nRNG}(X)$
    
    \Comment{Begin main program}
    \While { $\mathrm{death\_count} < \mathrm{total\_death}$}
        \State $(a,N[a][t],r,t) = H.\mathrm{top}()$
        \State $H.\mathrm{pop}()$
        \If {$t+1 > N[a].\textrm{length}()$}
            \If {$t+1 \leq n-a$}
                \State $N[a] = \textrm{FindAllNeighbors}(a)$
                \State $t' = t + 1$
                \State $b' = N[a][t']$
                \State $r' = d(X[a], X[b'])$
                \State $H.\mathrm{insert}(a,b',r',t')$
            \EndIf
        \Else 
            \State $t' = t + 1$
            \State $r' = d(X[a], X[N[a][t']])$
            \State $H.\mathrm{insert}(a,N[a][t'],r',t')$
        \EndIf
        \Comment{Algorithm continues into Algorithm 2}
    \algstore{bkbreak}
\end{algorithmic}
\end{algorithm}

\newpage 

\begin{algorithm}
\label{main-algorithm-part-2}
\caption{Part 2}
\begin{algorithmic}[1]
\algrestore{bkbreak}
        \State $\mathrm{one\_simplex\_counter} = \mathrm{one\_simplex\_counter} + 1$
        \State $\psi(i) = \mathrm{one\_simplex\_counter}$
        \State $c = \mathrm{FindCC}(\langle X[a]X[b] \rangle)$
        \If {$c.\mathrm{length}() = 1$}
            \State $c_{1} = c[1]$
            \State $v = \{ \psi(\langle X[a] X[b] \rangle), \psi(\langle X[a] X[c_{1}] \rangle), \psi(\langle X[b]X[c_{1}] \rangle) \}$
            \State $l = \max (v)$
            \State Insert a node into $T_{1}$ with key field $l$ and column field $v$. 
        \EndIf
        \If {$c.\mathrm{length}() > 1$}
            \For {$i = 1 : c.\mathrm{length}()$}
                \State $c_{i} = c[i]$
                \State $v = \{ \psi^{-1}(\langle X[a]X[b] \rangle), \psi^{-1}(\langle X[a]X[c_{i}] \rangle), \psi(\langle X[b]X[c_{i}] \rangle) \}$
                \State $l = \max (v)$
                \State $\mathrm{flag1} = 0$
                \State Make node $g$ with $g.\mathrm{key} = l$ and $g.\mathrm{column} = v$
                
                \Comment{Algorithm continues into Algorithm 3}
                \algstore{bkbreak}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\label{main-algorithm-part-3}
\caption{Part 3}
\begin{algorithmic}[1]
\algrestore{bkbreak}
                    \While {$\mathrm{flag1} = 0 \hspace{6pt} \mathrm{and} \hspace{6pt} g.\mathrm{column} \hspace{3pt} \mathrm{not \hspace{3pt} empty}$}
                        \State $f = T_{1}.\textrm{find}(l)$
                        \Comment{ $f$ will be empty if $\textrm{find}()$ does not find a node with key value $l$}
                        \If {$f$ not empty}
                            \State $g.\mathrm{column} = \mathrm{column} + f.\mathrm{column} $
                            \State $g.\mathrm{key} = \max (g.\mathrm{column})$ 
                        \Else 
                            \State $f = T_{>1}.\mathrm{find}(z,l)$
                            \If {$f$ not empty}
                                \State $g.\mathrm{column} = \mathrm{column} + f.\mathrm{column} $
                            \State $g.\mathrm{key} = \max (g.\mathrm{column})$ 
                            \Else 
                                \State $\mathrm{flag1} = 1$ 
                                \Comment This flag tells us that $g.\mathrm{column}$ has been reduced.
                            \EndIf
                        \EndIf
                    \EndWhile
                    \Comment{At this stage, if $g.\mathrm{column}$ is not empty. We add the necessary barcodes}
                    \If {$g.\mathrm{column} \hspace{3pt}\mathrm{not \hspace{3pt} empty}$}
                        \State $T_{>1}.\mathrm{insert}(g)$ 
                        \State $w_1 = \mathrm{diam}(\psi^{-1}(g.\mathrm{key}))$
                        \State $w_2 = \mathrm{diam}(X[a]X[b]X[c_i])$
                        \If {$w_1 - w_2 \neq 0$}
                            \State $\mathrm{barcode}.\mathrm{insert}(w_1,w_2)$
                            \State $\mathrm{death\_count} = \mathrm{death\_count} + 1$
                        \EndIf
                    \EndIf
                \EndFor
                
                    
        \EndIf
    \EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}

\newpage

\section{Experiments}
In this section we document the details of the experimental results obtained by using this algorithm. All results in this section were utilised by using a computer with the following specifications. 

\begin{itemize}
            \item AMD Ryzen 5 3400G with integrated Vega 11 graphics

            \item 2 $\times$ 8GB DDR4 RAM

            \item OS: 64bit Ubuntu 22.04.2 LTS 
        \end{itemize}

\subsection{ Results for point clouds in $\mathbb{R}^2$}

For this set of experiments we compared Ripser with our code on point clouds of size $1 \times 10^4, 2 \times 10^4, 5 \times 10^4, 7.5 \times 10^4, 1\times 10^5$ and $2\times 10^5$. Each of these point clouds were generated by from the uniform distribution of am unit square. The value of $k$ was set to 200 in all cases. Our results can be seen below in the following graph. Ripser was unable to compute $\mathrm{PH}_{1}$ for point clouds of size $5\times 10^4$ and larger. 

% Figure environment removed

    \subsection{ Results for point clouds in $\mathbb{R}^3$}

For this set of experiments we compared Ripser with our code on point clouds of size $1 \times 10^4, 2 \times 10^4, 5 \times 10^4, 7.5 \times 10^4, 1\times 10^5$ and $1.1\times 10^5$. Each of these point clouds were generated by from the uniform distribution of am unit square. The value of $k$ was set to 200 in all cases. Our results can be seen below in the following graph. Ripser was unable to compute $\mathrm{PH}_{1}$ for point clouds of size $5\times 10^4$ and larger. 

% Figure environment removed


\section{Conclusion}

The results show that our new code certainly shows promise. In particular, our algorithm seems to scale very well, suggesting a stronger computer could very well analyze larger point clouds. Future investigation should involve comparing performance on point clouds generated from different distributions and producing code for computing $\mathrm{PH}_{1}$ for dimensions four and higher. For higher dimensions, computing the Delaunay triangulation becomes prohibitively expensive and thus comoputing the RNG using alternative algorithms such as the one given by \cite{supowit_RNG} may see some use in this case. 
\newpage

\bibliography{references}
\bibliographystyle{ieeetr}


\end{document}
