\section{Introduction}
Microarchitectural covert and side channel attacks are proving to be an increasingly serious threat in traditional CPU-based systems. Such attacks happen when a compromised or untrusted process is co-located with a trusted process on the same hardware. As a result, it exploits the shared hardware resource to leak sensitive information. Many variants of covert and side channel attacks have been explored and studied on a wide range of microarchitectural resources, including but not limited to caches, branch predictors, interconnects and ports, re-order buffer, TLBs and main memory resources ~\cite{percival-05, mehmet-2016, liu-15, gruss-DIMVA-2016, Yarom-2014, branchscope, evtyushkin-16-branch, leaky_buddies,lotr,port_ieeesp,smotherspectre_ccs19, ben_tlb_usenix18, mismanaged_asiaccs21, drama_usenix, lee_dram}. 

Heterogeneous computing systems are proliferating. Such systems combine a number of CPU cores to run the operating system and traditional workloads along with specialized or general-purpose accelerators to perform application-specific computations. While accelerators in heterogeneous systems offer superior performance and power efficiency, they also expose new vulnerabilities and security issues due to their complex architecture and their integration with the rest of the system.  


In a heterogeneous System-on-Chip (SoC), accelerators are tightly integrated on the same die as CPU cores and share the on-chip interconnect, last-level cache (LLC) (in some architectures), as well as the main memory and its MC. This tight integration provides high-speed and power-efficient data transfer between the CPU and integrated accelerators. However, it also creates the potential for new attacks that exploit common resources to create interference between these components, leading to cross-component microarchitectural attacks. A recent work~\cite{leaky_buddies} has shown that this resource sharing can lead to microarchitectural covert channels between CPU and iGPU in an Intel-based SoC. Specifically, they build cross-component covert channels through the shared LLC and ring interconnect. 


Our work targets the shared MC resources (i.e. read and write buffers) in a heterogeneous SoC (specifically an Intel SoC with iGPU) to build cross-component covert channel attacks. Prior work~\cite{cornell_defense_hpca} proposed a defense scheme against contention-based channels that target shared MC and memory subsystem in a multi-core CPU. To motivate their protection scheme, they showed covert and side channel attacks examples. However, they neither characterize the source of contention nor develop an end-to-end attack. %Also, for the side channel attack, they cause a miss to detect the execution of an operation to infer the secret bit. 
Also, there is no indication of the required number of requests to cause the timing difference in both attacks.


In this paper, we study the effect of MC resource characteristics in a modern heterogeneous SoC and investigate the impact of memory write requests from an accelerator on the shared read and write buffers within the MC. We demonstrate that throughput-oriented accelerators with Single-Instruction Multiple-Data (SIMD) architecture which generate massively parallel memory accesses increase the latency of co-running CPU process significantly. We show that such high latency which is experienced by CPU processes can be exploited to construct reliable and high-quality covert channel attacks across the components in a chip. 


In comparison with homogeneous multi-core CPUs, heterogeneous systems provide attackers with unique opportunities. For example, massive parallelism in accelerators reduces the time required for filling shared buffers. Such buffers are originally designed with consideration to common characteristics of CPU process memory traffic. Moreover, this new class of microarchitectural attacks (cross-component attacks) relieves the attacker from co-location on the same processor and can bypass existing defense mechanisms that mainly focus on one component of the system. However, new challenges are introduced due to the heterogeneity of components. This includes frequency disparity of CPU and accelerators which makes the covert channel synchronization more challenging, and programming APIs with no (or limited) system support (e.g. lack of timing interface and {\fontfamily{pcr}\selectfont clflush} in OpenCL API). Additionally, exploiting write memory requests due to updated cache lines at the MC level requires special techniques. This is because the CPU process does not know the exact time when these dirty cache lines will reach the shared MC. 

To our knowledge, this is the first attack to target read and write buffers in the MC in heterogeneous SoCs. Furthermore, this is the first work to characterize the high latency of co-running CPU processes due to iGPU memory write requests. This provides important insights into how this threat model manifests in such systems and extends our understanding of the threat to guide future research into defense mechanisms. 

In summary, our paper makes the following main contributions:
%\hoda{I tried to elaborate on this a little bit more to have at least 4 items. Some items look similar though. But I feel three bulletins are not enough!}
\begin{itemize}

%\item We reverse engineer the process of serving memory read and write requests at the MC level. 

\item We identify that parallel memory writes from an integrated accelerator can be a strong leakage vector to build cross-component covert channels through the shared MC. 

\item We characterize the slowdown of memory read requests from co-running CPU process during iGPU kernel memory write requests.

\item We identify the main root of the slowdown is due to the management policy of the write buffer (\textit{drain\_when\_full}) in the shared MC.

\item We develop two covert channel attack variants between CPU and iGPU in Intel-based SoCs by exploiting parallel memory writes and the slowdown caused by the management policy of the write buffer.
\end{itemize}

Our work mainly focuses on developing covert channel attacks. The presence of a covert channel can also forecast the possibility of a side-channel attack to reveal secret information (if the secret is dependent on accelerators' memory write requests).%, although we do not pursue such attacks in this paper



%Side channel attack exploiting the write buffer management policy is possible and can reveal secret information if this secret is dependent on accelerators' memory write requests.



%\hoda{Ghadeer, do you want to completely remove the side channel section? If you think the previous side channel is still relevant to the write buffer management policy (not any other effects) I think we should have a proof of concept side channel and that simple version should be enough. Unfortunately, asking about a side channel is an easy question for reviewers.}
%\ghadeer{the previous side channel do not reveal any secret information it just can identify two different running kernels, these two kernels are not secret dependent. Also, the victim in the side channel suffer almost same latency level in case of iGPU kernel reads and writes. As a result, i can't relate it to MC write buffer. I will focus on covert channel attack variants now since there are papers accepted with just covert channel attacks.}

%\item We present a proof-of-concept side channel attack in which a CPU-based spy process monitors the iGPU memory traffic on the shared memory controller to extract information about a targeted application on iGPU: Kmeans from the Rodinia benchmark.





%We propose a covert channel attack which utilizes integrated GPU memory requests to cause contention on shared memory controller and leak secret information. With just 256 threads, we achieved a bit rate of ...\% and error rate of ...\%. This is not achievable even with large buffer size in case of CPU-CPU contention. To the best of our knowledge this is the first covert channel attack to target contention on memory controller using iGPU memory traffic.

%\item Our covert channel exploits memory writes and not memory reads. Memory write request are harder to exploit at the memory controller level because they don't necessarily indicate current execution state of processing unit. We show that with iGPU parallelism this is possible.



%\item We propose flushless covert and side channel attack that does not depend on cl\_flush instruction neither at spy side nor trojan side.

%\item We propose adaptive synchronization algorithm which is applicable to different global work group size and lead to faster bit and less error rates.


The paper is organized as follows: Sections~\ref{sec:background}, \ref{sec:threat_model} and \ref{sec:motivation} present background, threat model, and our attack motivation. In Section~\ref{sec:cont_src} we explain the reverse engineering process of the source of the slowdown. Section~\ref{sec:attack_design} explains our attack design, and in Section~\ref{sec:eval} we evaluate our covert channel attack variants. Sections~\ref{sec:discuss} and \ref{sec:mitigations} are discussion and possible mitigations, and Section~\ref{sec:related_work} presents related work. Finally, Section~\ref{sec:conc} concludes our paper.







