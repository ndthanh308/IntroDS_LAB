\section{Side Channel Attack}
\label{sec:side-channel}


In this section, we present a proof-of-concept side channel attack by exploiting the contention on the memory controller to leak secret information. In our side channel scenario, a victim application is running on iGPU and a CPU-based spy extracts some sensitive information from the victim by monitoring the contention on the shared memory controller.

For our victim application, we target Kmeans application from Rodinia Benchmark\cite{rodinia_paper, rodinia} on iGPU. Kmeans application in Rodinia benchmark includes two GPU kernels: {\fontfamily{pcr}\selectfont kmeans\_swap} and {\fontfamily{pcr}\selectfont kmeans\_kernel\_c}. {\fontfamily{pcr}\selectfont kmeans\_kernel\_c} is responsible for clustering and only includes buffer reads. While {\fontfamily{pcr}\selectfont kmeans\_swap} does data swapping and as a result includes both memory reads and writes.

The number of threads in each work-group is set to 256 in Kmeans benchmark and the number of work-groups is dependent on the size of input data (data points). For example, if the number of data points is 2560, then a total of 2560 threads will be used (i.e. 10 work-groups of each 256 threads). We experiment with the maximum number of features of 255 and different data point sizes. Figure \ref{fig:side_channel_mem_accesses} demonstrates the CPU-based spy average latency, when it accesses a buffer in memory. Similar to single kernel spy setting, for side channel attack, the attacker accesses a buffer of 1MB at a stride of eight cache lines. The attacker keeps flushing and accessing its buffer to monitor the contention level caused by iGPU kernel.
%\hoda{add details of spy buffer size and pattern, and flushing} \ghadeer{I will add data about attacker's buffer and its algorithm}. 

The execution behavior of two Kmeans kernel functions is clearly observed by the spy process. {\fontfamily{pcr}\selectfont kmeans\_swap} kernel is first to execute and only once. After some time based on the size of input data,  
%\hoda{What does number of iteration mean? Does it relate to the input size?}
%\ghadeer{it is the number of iteration required until error threshold is reached. yes, it is different with different input data sizes and it is correlated with number of clusters being created. it is indicated by the number of green circles. I'm showing only portion of the collected data. but attacker monitored kernel execution till the end, the number of green circles is the number of iterations.}
{\fontfamily{pcr}\selectfont kmeans\_kernel\_c} executes for a number of iterations. 



%\hoda{not clear what you mean, is the period of red circle or the time between red and green circles?} 
%\ghadeer{each iteration indicate execution of the kernel function shown in the green circle. the kernel function in red circle is executed only one time.}
The execution time of each kernel, the elapsed time between two kernels (red circle and green circle), and also the elapsed time between every two iterations of {\fontfamily{pcr}\selectfont kmeans\_kernel\_c} kernel
are dependent on data points size. Also, the attacker is able to figure out the number of iterations the algorithm would take till convergence (as shown in Figure~\ref{fig:side_channel_mem_accesses}). This can leak information about Kmean algorithm parameters such as the number of clusters, the input data size, and the error threshold. %\hoda{how the error threshold is related} \ghadeer{Kmean algorithm executes the kernel function in green circle till convergence. this convergence is dependent on the error threshold. iterations till convergence is determined by the number of green circle. it will not give attacker direct value to error threshold, but an approximate range}.

%why contention level is small
From Figure \ref{fig:side_channel_mem_accesses}, it can be noticed that the level of contention is not as high as the contention level we observed in the covert channel attack. This is mainly due to memory coalescing on the iGPU. With memory coalescing, memory accesses to same cache line are merged as a single memory request \cite{gen9}. In our covert channel, we designed our access patterns to avoid memory coalescing, however, the attacker in a side channel does not have any control over the victim process. Memory coalescing will decrease the memory traffic and as a result, the contention level compared to having memory accesses to different cache lines. However, the iGPU kernel execution behavior is still clearly visible and attacker can infer information about Kmean algorithm by monitoring the contention on the memory controller.


%role of llc contention
%To investigate the role of (potential) LLC or ring-interconnect contention, we forced the CPU-based spy buffer accesses to be LLC hits. Figure \ref{fig:side_channel_llc_accesses} illustrates the attacker's execution behavior during Kmean kernels' execution. The attacker can observe some variations in its execution behavior due to iGPU kernel memory accesses, but it does not observe as high contention level as in Figure \ref{fig:side_channel_mem_accesses}. This indicates that the main contribution behind the contention is the shared queues in the memory controller. \hoda{in this version, although the contention level is lower, the elapsed time, two kernels, ... are also visible. We can remove this figure and its text! No need to include it}
%\ghadeer{i see your point. i will try to add back propagation algorithm after finishing the draft and fixing the figures}

% Figure environment removed

\begin{comment}
% Figure environment removed
\end{comment}


\begin{comment}
% Figure environment removed

\end{comment}