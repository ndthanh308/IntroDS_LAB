\section{Covert Channel Attacks Evaluation}
\label{sec:eval}
In this section, we explain the attack evaluation setup and evaluate both attack variants in terms of bit and error rates. %We also discuss the results of both attack variants 1 and 2.

\subsection{Experimental Setup}
We target an Intel-based SoC with an integrated GPU. Most desktop and mobile Intel processors include integrated GPU for the acceleration of graphics and compute workloads\cite{gen9,gen11, tap_georgiatech_hpca}. All our experiments are on a Cometlake i7-10700K processor, which features an integrated Intel UHD Graphics 630 (based on gen9.5 architecture with 1 slice of 3 subslices, and 8 EUs per subslice). We use OpenCL version 2.1, running Ubuntu version 20.04.1 (which uses Linux Kernel version 5.13). The size of LLC and main memory are 16MB and 32GB, respectively. The SoC has a single memory controller with dual channels. Table~\ref{tab:exp_setup} summarizes the attacks' experimental setup.

\begin{table}[t]
\centering
\begin{tabular}{||m{0.4\columnwidth} || m{0.5\columnwidth}||}
    \hline
     CPU &  8 cores, Cometlake i7-10700K @ 3.80GHz\\
     \hline
     L1 \& L2 Caches & L1-I\$,L2-D\$:32KiB (8-way)\newline L2\$:256KiB (4-way) \\
     \hline
     LLC & 16MiB (16-way)\\
     \hline
     iGPU &  Intel UHD Graphics 630 (gen9.5) @ 1200MHz\\
     \hline    
     Mem. Controller (MC) & one MC, dual channel\\
     \hline
     DRAM & 32GB\\
     \hline
    % Kernel & Linux v5.13 w/ ubuntu 20.04.1\\
    % \hline
    % OpenCL \& ICD Loader & 2.1, 2.2.11\\
    % \hline
\end{tabular}
\caption{Attacks environment setup.}
     \label{tab:exp_setup}
     \end{table}

\subsection{Evaluation of Attack Variant 1 }
%\hoda{I think most papers report BW in bits per second rather than B/s. Let's double check with some other papers and report the same.}
This attack depends on allocating a large buffer that is accessed by the iGPU kernel to evict dirty cache lines. Figure~\ref{fig:attack_var1} depicts both bit and error rates. The parameters are based on our analysis in section~\ref{subsec:var1_design}. The attack can achieve an average bit rate of 1.65 kbps with an average error rate of 0.49\%. This is achieved when the iGPU kernel buffer is accessed at a stride of eight cache lines. If a stride of 16 cache lines is selected, an average bit rate of 2.43 kbps is possible but with an average error rate of 29.87\%. 



% % Figure environment removed


% Figure environment removed


\subsection {Evaluation of Attack Variant 2}
This attack requires spy and trojan to pre-agree on a specific MC channel to access. This requires channel bit addressing knowledge to know which bit in physical address determine which channel to access. We evaluated this attack variant based on the parameters we have inferred in section~\ref{subsec:attack_var2}. Figure~\ref{fig:attack_var2} depicts bit and error rates for different secret sizes. This attack variant achieved an average bit rate of 4.41 kbps and average error rate of 4.32\%. Attack variant 2 achieved bit rate $\times2.67$ larger than attack variant 1, but average error rate is $\times8.8$ larger than attack variant 1.


% \subsection{Discussion}
% \ghadeer{discuss the results}






%old version
\begin{comment}
\begin{scriptsize}
\begin{table}[h!]
  \centering
  \caption{System Configurations
  \ghadeer{elaborate on L3 cache and shared memory}} \label{tab:sys_config}
  \begin{tabular}{|l|l|}
  \hline \hline
  CPU & CometLake i7-10700K @ 3.80GHz, 8 cores
  \\
  \hline
  L1\$, L2\$ & L1D\$, L1I\$: 32KiB,
               L2\$: 256KiB
               \\
  \hline
  LLC Cache & 16MiB
  \\
  \hline \hline
  \multicolumn{2}{| c |}{Intel Integrated Graphics}\\
  \hline \hline
  Platform & Intel UHD Graphics 630 @ 1200MHz 
  \\
  \hline
  slices, sub-slices& 1 slice, 3 sub-slices 
  \\
  \hline
  Execution Units (EU) & 24, 8EU/sub-slice
  \\
  \hline
  L3 Cache & 512KB
  \\
  \hline
  Shared Local Memory & 192KB\\
  \hline \hline
  \multicolumn{2}{| c |}{Main Memory}
  \\
  \hline \hline
  Size & 32GB
  \\
  \hline
  Channels & two channels, single memory controller 
  \\
  \hline \hline
  \multicolumn{2}{| c |}{OS environment}\\
  \hline\hline
  OS & Ubuntu 20.04.1, Linux kernel 5.13\\ 
  \hline
  OpenCL & 2.1 \\
  \hline
  \end{tabular}
\end{table}
\end{scriptsize}
\end{comment}

%We targeted Intel integrated GPU which is based on gen9.5 compute architecture. Intel UHD 630 include one slice with three sub-slices, each sub-slice has eight EUs. Maximum number of work-items in a work-group is 256 \cite{uhd630, gen9}. Intel UHD 630 share LLC, ring interconnect, memory controller and main memory with CPU cores \cite{gen9}. On the CPU side, we have the spy running on one core and trojan executing on another core. Trojan queue a kernel to execute on the integrated GPU to leak secret information by exploiting parallelism.



\begin{comment}
\noindent \textbf{Bit and Error Rates:}
%xplore bit rate and error rate with one sublice and different number of threads
%explore bit and error rate with number of memory accesses
We measured the bit and error rates for our multi-kernel and single-kernel attacks. %We discuss using higher number of threads in later sections. Previously we discussed two possible version of the attack. One which uses single kernel launch to transmit multiple bits, and another version which launch a kernel based on secret bits. 
As we discussed before, our single-kernel attack would result in a much higher bit rate than a multi-kernel attack, by removing the overhead of kernel launch for each bit. In addition, our synchronization scheme in the single-kernel attack leads to a lower error rate. Since current Intel iGPUs allow the execution of only one compute kernel at a time, there will be no noise from other concurrent kernels on the iGPU side. 

Table~\ref{tab:bit_err_rate} reports the bit-rate and error rate for both multi-kernel and single-kernel covert channels.

\noindent \textbf {Error Detection:} To reduce the error rate, the spy can detect possible error cases using outlier detection. Because we limit the spy latency in case of contention and no-contention, and we base contention detection on iterations. The number of iterations and contention level are correlated. Outlier cases have total latency larger than the limit and/or the number of iterations smaller than the average number of iterations when there is contention.
\end{comment}

\begin{comment}
\ghadeer{comment on data rates, why similar in multi-kernel and different in single kernel?}

\hoda{We can remove error detection subsection, or summarize it in a few lines to save space, very long, has many repetitive things and yet not clear or interesting. I think, just reporting bw and error rate would be fine, let's not make it more complicated to follow for reviewers. These things like the synchronization usually should be introduced by the help of some figures or diagrams to make it easy to follow. Let's remove it for now.}
\ghadeer{error detection here is a simple algorithm it is mainly based on outlier detection. i will summerize it to one paragraph.}
\noindent \textbf{Error detection:} As we mentioned before, in single-kernel attack scenario, we base determining the bit status ("1" or "0") on the total latency value and the number of spy iterations required to reach the total latency value. This value is determined based on spy total latency when there is no contention. The spy process reaches this latency value with a smaller number of iterations when there is contention. But if the spy does not observe any contention, it will iterate and access all spy buffer entries based on the selected stride. As a result, when the spy process observes contention or not, the total latency
%\hoda{what do you mean by total latency sum? can't it be written as total latency?} 
falls in a deterministic range, and this range should be small unless abnormal contention cases are observed. The difference is in the number of iterations which determines contention from no-contention cases.

Based on this observation, we can determine the correlation between total latency value and the number of iterations required for contention and no-contention cases. We also can determine outlier cases that do not coincide with the required number of iterations and total latency sum range. For example, in our single-kernel attack with 256 threads and spy with a buffer of size 1MB and stride of 64 cache lines, the spy needs 256 iterations to access its entries based on stride, and it needs total latency of approximately 110000 cycles to do so. Contention and no-contention cases should have a total latency close to this value to be considered a normal case, not an outlier. In case of no-contention, it has to be 256 iterations, and in case of contention, it has to fall in a range of smaller numbers of iterations. In our example, the number of iterations range is between 75-90 iterations for normal contention cases. This range is determined based on all secret detection results of the spy process during contention monitoring.

By applying this error detection algorithm, we were able to reduce error rate considering the noisy nature of parallel memory write requests, and using contention as a leakage vector. We should note, that the number of observed outlier cases were small in our experiments, but it can cause large error rate if not handled using our error detection algorithm. 

%This contributes in lowering the error rate because there is no other kernel running on the device other than the targeted kernel.
\end{comment}







\begin{comment}
\subsubsection{Single Kernel Execution}
With single kernel execution, a single kernel launch is just required to leak multiple bit secret. Consequently, there has to be a way to synchronize efficiently between trojan and spy to leak secret with low error rate as possible. Figure \ref{fig:bit_err_rate_single_kernel} depicts both error and bit rate results for single kernel execution.

%more comments about the results

% % Figure environment removed

\subsubsection{Multi-Kernel Execution}
With multiple kernel execution, the trojan launches a kernel based on secret bit pattern. Such approach will lower bit rate, but error rate will be lower because synchronization can per done the trojan CPU side which is straightforward compared to synchronization between CPU and integrated GPU. Figure \ref{fig:bit_err_rate_multi_kernel} depicts bit and error rates in case of executing multiple kernels and each kernel launch is representing a contention case.
\end{comment}
%more comments 

% % Figure environment removed



% \subsection{Sensitivity Analysis}

\begin{comment}
\subsection{Contention Level Factors}
\hoda{If we do not have bitrates for different number of threads, we should remove this subsection. But I think we should have some study on the sensitivity to number of threads or using more subslices, ... If you have only the bit rates let's report them in a subsection after the "bit and error rates " as the parallel attack and do not say anything about the error rates for now.}

\ghadeer{I will see if I can add more data about 512 threads. the error rate is higher than 256 threads and this is because I do not have appropriate algorithms for synchronization that can carry to different threads number. Adaptive synchronization algorithm can be an excellent contribution to this work.}

The volume of memory traffic is a key factor in determining the level of contention. Our basic attacks explained in Sections~\ref{sec:multiple_kernels} and ~\ref{sec:single_kernel} are based on using one work-group of 256 threads. But a question may arise about the role of memory traffic volume on the level of contention. Figure \ref{fig:threads_vs_contention} illustrates the relation between the number of active threads and the level of contention. 

%add comments about the figure threads vs contention

% Figure environment removed


Because we used 256 threads as a basis for our attack, we show the role of increasing the number of threads and the challenges associated with it next.
\end{comment}
