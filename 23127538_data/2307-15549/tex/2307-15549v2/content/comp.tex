%!TEX root = ../main.tex

\subsection{Contextualization}
\label{sec:contextualization}

The purpose of rule \ruleref{context} is to frame out predicates that are invariant under the command of interest.
Our goal is to obtain \theLogicSeq derivations that look something like this:
\begin{align*}
	\inferrule*[left={\ruleref{consequence}}]{
		~~
		\inferrule*[left={\ruleref{context}}]{
			~~
			\inferrule*[left={\ruleref{com}}]{
				\casemof{\acom}{\apredpp}{\apred}\predleq\apredp
			}{
				~~\choareOf{\acontext}{\apred}{\acom}{\apredp}~~
			}
			~~
		}{
			\choareOf{\emp}{\apred\mstar\acontext}{\acom}{\apredp\mstar\acontext}
		}
		\\
		\apredppp\predleq\acontext
		~~
	}{
		\choareOf{\emp}{\apred\mstar\apredppp}{\acom}{\apredp\mstar\acontext}
	}
\end{align*}
But how does one determine predicates that are guaranteed to be invariant under the command?
We first tackle this problem for the original semantics $\sem{-}$ and from this derive a schema for obtaining context-aware semantics $\casem{-}{\bullet}$.
To be precise, this is the problem we address next:
\begin{quote}
	\underline{Contextualization} \\
	Given: $\semof{\acom}{\apred\mstar\apredppp}$. \\
	Determine: Predicates $\apredp$ and $\acontext$ with $\apredppp\predleq\acontext$ so that $\semof{\acom}{\apred\mstar\acontext}\predleq \apredp\mstar\acontext$.
\end{quote}
Of course the predicates $\apredp$ and $\acontext$ should be as precise as possible.
We solve this problem in a setting that is specific enough to provide helpful assumptions, yet general enough to cover frameworks like flows~\cite{DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23}
and ghost state induced by morphisms~\cite{DBLP:journals/pacmpl/Nanevski0DF19}.
In analogy to the term framing, we say we \emph{contextualize} $\acontext$.


%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsubsection{The Semantics of updates}
\label{sec:contextualization:semantics}

The motivation for contextualization stems from the fact that the states in $\apredppp$ can be large.
In our examples from \cref{sec:motivation}, these states are full registries and full subtrees.
It is worth having a closer look at what forces us to maintain these rich states.

\begin{example}
	\label{ex:decompose-flow}
	The crucial moment in the BST proof from \cref{sec:motivation:flow} is this Hoare triple:
	\begin{lstlisting}[language=SPL,numbers=none,style=codeInline,keywords={free}]
	  $\annot{
	    \anode \pointsto (l,r,k) \MSTAR p \pointsto (\anodep,\anodepp,i) \MSTAR \anodep \pointsto (\pnull, \anodeppp, j)\MSTAR \apredppp
	  }$
	  $\anode$.$\key$ = $\anodep$.$\key$; $p$.$\lchild$ = $\anodep$.$\rchild$;
	  $\annot{
	    \anode \pointsto (l,r,j) \MSTAR p \pointsto (\anodeppp,\anodepp,i) \MSTAR \apredppp'
	  }$
	\end{lstlisting}
	The update modifies a pointer of $p$ and the key of $\anode$. %, and deallocates $\anodep$.
	This is the change on the states in the predicate $\apred$ introduced in the notion of contextualization.
	However, the update also has an effect on the subtree rooted at $r$ (without $p$ as the node belongs to $\apred$).
	We are interested in the contents of this subtree, the set of keys of all nodes reachable from the root.
	While the subtree does not change physically, the update changes the contents of $\apredppp$.
	In short, while the physical modification involves only few nodes, it influences the ghost state associated with a whole set of nodes.
	The phenomenon is independent of the formalism we use to describe states, be it recursive predicates, flow graphs, or morphisms.
	\qed
\end{example}

\begin{example}
	\label{ex:decompose-lin}
	Recall the linearizability proof goal from \cref{sec:motivation:lin}: \[
		\hoareof{\mcslstate(M(h)) \mstar (h, R)}{\acom}{\mcslstate(M(h)[k \mapsto v]) \mstar ((k,v) \cdot h, R')}
		\enspace .
	\]
	The linearization point $\acom$ of \code{upsert($k$, $v$)} modifies the physical representation $\mcslstate$ of the structure and appends the new key-value pair $(k,v)$ to the history $h$.
	Moreover, $\acom$ also affects the registry $R$: it linearizes all threads that are awaiting $(k,v)$ to be upserted, as dictated by their prophecy variables, resulting in the (potentially entirely) new registry $R'$.
	Here, we are interested in contextualizing the registry $R$ as part of $\apredppp$ and keeping both the physical representation as well as the history in $\apred$.
	The reason for this is that the registry update is induced by the change of the history.
	We wish to focus the proof on the part that matters, the history and its update.
	\qed
\end{example}

To capture the fact that an update involves a modification of the physical state and a modification of the ghost state, we wish to assume that the semantics of commands can be decomposed into the physical update and a separate operation that adjusts the ghost state according purely to the new physical state. 
However, distinguishing between physical and ghost state is unnecessarily strict and impractical in some cases, as seen in \cref{ex:decompose-lin}. 
Instead, we only assume that the semantics of commands decomposes according to the following equalities:
\[
	\semof{\acom}{\apred\mstar\apredppp} \ =\ \upof{\acom}{\apred\mstar\apredppp}\quad\text{and}\qquad \upof{\acom}{\apred\mstar\apredppp} \ =\ \upof{\acom}{\apred}\imult\apredppp\quad \text{if }\upof{\acom}{\apred}\neq\abort
	\enspace .
\]
Here, $\up{\acom}$ is a predicate transformer that implements the \emph{core update}.
The core update satisfies a condition similar to \eqref{Equation:Locality}, except that the ordinary multiplication $\mstar$ is replaced by a ghost multiplication $\imult$ applying the \emph{induced update} on the remaining state.
Going forward, one can think of the core and induced updates as updates to the physical and ghost state, respectively, but our results do not rely on this understanding.
The ghost multiplication is commutative and associative.
(There is no need to assume the existence of units.)
We lift the ghost multiplication to predicates in the expected way: $\apred\imult\apredp=\setcond{\astate\imult\astatep}{\astate\in\apred\wedge \astatep\in\apredp\wedge \astate\imultdef\astatep}$ and $\abort\imult\apred=\abort=\apred\imult\abort$.
We make the assumption that the result of a ghost multiplication decomposes uniquely as follows.
For $\apred_1, \apred_2\subseteq\setstates$ with $\apred_1\imult\apred_2=\apredp$, there are unique smallest predicates $\apredp_1, \apredp_2$ with $\apredp_1\mstar\apredp_2=\apredp$ so that $\apredp_1$ corresponds to $\apred_1$ and $\apredp_2$ corresponds to $\apred_2$.
This correspondence is formalized as an equivalence on states, which we have suppressed as we do not need it beyond this unique decomposition requirement.

\begin{example}
	\label{ex:imult-lin}
	For our registry example from \cref{sec:motivation:lin}, we define the core update $\up{\acom}$ for the linearization point $\acom$ to extend the history: $\upof{\acom}{(h,\emptyset) \mstar \apredppp} = ((k,v) \cdot h, \emptyset) \imult \apredppp$.
	The induced update $\imult$ takes care of linearizing threads according to new entries of the history.
	Formally, \[
		(h, R_1) \imult\, (h, R_2) \,=\, (h, R_1 \uplus R_2)
		\qquad\text{and}\qquad
		((k,v) \cdot h, R_1) \imult\, (h, R_2) \,=\, ((k,v) \cdot h, R_1 \uplus R_2')\ .
	\]
	Here, $R_2'$ is obtained from $R_2$ by changing all entries $R_2(\tid)=\anobl{k,v}$ to $\aful{k,v}$ and leaving all other entries unchanged.
	In all remaining cases, $\imult$ is undefined.
	With this, $\imult$ indeed captures our intuition of an induced update that adjusts the registry given the effect that the core update has on the history.

	For an induced update $(h_1, R_1) \imult\, (h_2, R_2) = (h_3, R_3)$ that is defined, its unique decomposition splits the resulting registry $R_3$ along the domains of $R_1$ and $R_2$ which are disjoint by definition of $\imult$.
	The decomposition is $(h_3, \project{R_3}{\domof{R_1}}) \mstar (h_3, \project{R_3}{\domof{R_2}})$ where $\project{R_3}{\domof{R_1}}$ is the projection of $R_3$ to the domain of $R_1$, and similarly for $R_2$.

	So far, we have ignored the physical representation $\mcslstate$ because it is orthogonal to the ghost state.
	The separation algebra for the overall proof will be a product of two independent separation algebras, one capturing the physical state and one the ghost state.
	The induced update $\imult$ on the ghost state separation algebra extends naturally to the product separation algebra: the core update keeps the entire physical state in $\upof{\acom}{\apred}$, the physical part of $\apredppp$ is $\emp$, and the ghost multiplication is the separating conjunction.
	\qed
\end{example}

The use of a ghost multiplication is inspired by the morphism framework in \cite{DBLP:journals/pacmpl/FarkaN0DF21} where the separation algebra of states $\Sigma$ is mapped to a separation algebra of ghost states  $\Gamma$ that has its own multiplication.
We stay within one separation algebra, which can be thought of as $\Sigma\times\Gamma$, and assume to inherit the second multiplication.


%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsubsection{Solution}

We approach contextualization by abstract interpretation: we give an approximate semantics for the commands from which we can construct the desired predicates.
A particularity of our approach is that we do not want to devise an abstract domain but wish to stay in the realm of separation logic where the algebraic framework is well-developed.
Another particularity is that the semantics of commands consist of a core and an induced update, both of which we have to approximate.

We mimic the core update by an \emph{approximate core update} $\absup{\acom}$.
Like the core update, it should be a predicate transformer that satisfies $\absupof{\acom}{\apred\mstar\apredppp}=\absupof{\acom}{\apred}\imult\apredppp$ if $\absupof{\acom}{\apred}\neq\abort$.
We also expect soundness, $\upof{\acom}{\apred}\predleq\absupof{\acom}{\apred}$.

To mimic the induced update, observe that the ghost multiplication induces a family of predicate transformers $\ghostconc{\apred}$ that capture the effect of the ghost multiplication on the first operand when the second operand is fixed to be~$\apred$.
For $\apred, \apredppp\subseteq\setstates$, we define $\ghostconcof{\apred}{\apredppp}=\apredppp'$, if $\apredppp\imult\apred=\apredppp'\mstar\apred'$ is the unique decomposition.
This can be understood as currying, then a partial instantiation, and finally a masking of the result.
For $\apred=\abort$ or $\apredppp=\abort$, we define $\ghostconcof{\apred}{\apredppp}=\abort$.
It is worth noting that these functions capture the ghost multiplication without loss of information: $\apredppp\imult\apred=\ghostconcof{\apred}{\apredppp}\mstar \ghostconcof{\apredppp}{\apred}$.
To define the predicates we are after, it will be beneficial to approximate this family rather than the multiplication operator.

\begin{example}
	Consider the ghost states $\apred=((k,v) \cdot h, R_1)$ and $\apredppp=(h, R_2)$.
	What is $\apredppp'=\ghostconc{\apred}(\apredppp)$?
	To find it, first compute $((k,v) \cdot h, R_1) \imult\, (h, R_2)$ along the lines of \cref{ex:imult-lin}.
	If the ghost multiplication is undefined, we have $\apredppp'=\bot$.
	Otherwise, it yields $((k,v) \cdot h, R_1 \uplus R_2')$ with $R_2'$ being the appropriately updated registry as before.
	The $\apredppp$-portion of the unique decomposition for this ghost state gives $\apredppp'=((k,v) \cdot h, R_2')$.
	As expected, $\ghostconc{\apred}$ updates $\apredppp$ by extending its history by the new event $(k,v)$ and updating the registry to $R_2'$ accordingly.

	Similarly, $\ghostconc{\apredppp}(\apred) = ((k,v) \cdot h, R_1)$ if the ghost multiplication from above is defined (recall that $\imult$ is commutative).
	We confirm $\apred\imult\apredppp = ((k,v) \cdot h, R_1) \mstar ((k,v) \cdot h, R_2') = \ghostconc{\apredppp}(\apred) \mstar \ghostconc{\apred}(\apredppp)$.
	\qed
\end{example}

An \emph{approximate ghost multiplication} is a family of predicate transformers $\ghostabs{\apred}$.
We now proceed the other way around and use the family to define $\apred\absimult\apredppp=\ghostabsof{\apredppp}{\apred}\mstar\ghostabsof{\apred}{\apredppp}$.
Again, we expect soundness, $\apred\imult\apredppp\predleq\apred\absimult\apredppp$.

With the approximate core and induced updates in place, we can now state our solution to the contextualization problem.
Recall that we are given $\semof{\acom}{\apred\mstar\apredppp}$, and we want to determine predicates $\apredp$ and $\acontext$ with $\apredppp\predleq\acontext$ so that $\semof{\acom}{\apred\mstar\acontext}\predleq \apredp\mstar\acontext$.
We define:
\begin{alignat*}{5}
	\apredpp\ &=\ \rho^*(\apredppp)\qquad&\text{with}\qquad\rho\ &=\ \ghostabs{\apred'}\qquad \text{and}\qquad \apred'=\absupof{\acom}{\apred}
	\\
	\apredp\ &=\ \sigma(\apred')\qquad&\text{with}\qquad\sigma\ &= \ghostabs{\apredpp}.
	\end{alignat*}
By assumption, $\ghostabs{\apred'}$ is a predicate transformer (i.e., strict and a complete join morphism), and so the reflexive transitive closure $\rho^* = \lfpof{(\lambda f.\, \mathit{id} \predtransjoin \rho \circ f)}$ is well-defined.
The construction  captures our intuition about the context being stable under the (ghost) updates inflicted by the command, and it solves contextualization as promised.

\begin{theorem}
	\label{thm:contextualization}
	Consider $\semof{\acom}{\apred\mstar\apredppp}$.
	Then $\semof{\acom}{\apred\mstar\apredpp}\predleq\apredp\mstar\apredpp$ and $\apredppp\predleq\apredpp$.
\end{theorem}

It is worth noting that we only lose precision in the approximations and in the transitive closure.
The transitive closure seems to be unavoidable to make $\apredpp$ invariant under the command.
The physical update is often deterministic and does not need approximation.
Hence, the only parameter worth tuning is the precision of the approximate ghost multiplication.
We illustrate the construction of $\apredp$ and $\apredpp$ in \cref{thm:contextualization} on the registry example  from \cref{sec:motivation:lin}. 
It is worth noting that, in this example, the transitive closure does not lose information because the ghost multiplication is idempotent.

\begin{example}
	Consider $\semof{\acom}{\apred\mstar\apredppp}$ with $\apred=(h,\emptyset)$, $\apredppp=(h,R)$, and $\acom$ the linearization point of an \code{upsert($k$, $v$)}.
	For simplicity, we choose not to perform any approximation here, i.e., choose $\absup{\dontcare}=\up{\dontcare}$ and $\ghostabs{\dontcare}=\ghostconc{\dontcare}$.
	However, we note that the use of approximations can enhance proof automation by improving the convergence of solving the contextualization problem.
	For an example use of approximations, refer to \cref{sec:bst-example}.

	We now compute $\apredp$ and $\apredpp$ to solve contextualization.
	First, we have $\apred'=\absupof{\acom}{\apred}=((k,v) \cdot h, \emptyset)$.
	Then, $\ghostabs{((k,v) \cdot h, \emptyset)}((h,R))=((k,v) \cdot h, R')$ with $R'$ the updated variant of $R$.
	Because $\ghostabs{\dontcare}$ is idempotent, we obtain $\apredpp=((k,v) \cdot h, R')$.
	Finally, $\apredp=\ghostabs{(h, R)}(((k,v) \cdot h, \emptyset))=((k,v) \cdot h, \emptyset)$.
	That is, $((k,v) \cdot h, \emptyset) \mstar ((k,v) \cdot h, R')$ approximates the post image of $\acom$ under $\apred\mstar\apredppp$.
	\qed
\end{example}


%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsubsection{An induced context-aware semantics}

The above solution to the contextualization problem also gives rise to a context-aware semantics based on the over-approximation principle.
The derived context-aware semantics computes the physical update $\apred'$ and applies to it the approximate ghost multiplication for the given context $\acontext$, if $\acontext$ is invariant under the update, that is, if $\acontext$ is the fixed point solution to $\rho^*(\apredppp)$.
We define the \emph{induced context-aware predicate transformer} $\icasem{\acom}{\acontext}$ for a non-empty context $\acontext\neq\emp$ by \[
	\icasemof{\acom}{\acontext}{\apred} = \begin{cases}
		\ghostabsof{\acontext}{\apred'}
		&\text{if~\:}
		\acontext = \ghostabsof{\apred'}{\acontext}
		\text{\:~where~\:}
		\apred'=\absupof{\acom}{\apred}
		\\
		\top
		&\text{otherwise}
		\enspace .
	\end{cases}
\]
For an empty context, there is no need for approximation, we simply use the original semantics, $\icasem{\acom}{\emp}=\sem{\acom}$.
Using \cref{thm:contextualization} it is easy to see that $\icasem{\acom}{\bullet}$ satisfies \eqref{Equation:Mediation}.
That is, we can instantiate \theLogicSeq with $\icasem{\acom}{\bullet}$ and obtain by \Cref{lem:conservative-extension} a conservative extension of separation logic that supports contextualization for reasoning more locally about large footprints.

\begin{theorem}
	\label{thm:approx-induced-casl-is-conservative}
	The \theLogicSeq induced by $\icasem{\acom}{\bullet}$ conservatively extends SL.
\end{theorem}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
