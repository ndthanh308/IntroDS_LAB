%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\section{Motivation and Overview}
\label{sec:motivation}

We motivate our work by demonstrating how contextual reasoning can simplify linearizability proofs for concurrent data structures.
Such proofs often require ghost state to synchronize the linearization status of all threads, particularly when dealing with future-dependent linearization points (\Cref{sec:motivation:lin}), and to relate the logical contents of the structure to its physical representation (\Cref{sec:motivation:flow}).
Reasoning about these ghost state updates is challenging because they are frequently non-local to the actual physical updates performed by the program code and may involve an unbounded number of ghost resources.
We show how to decompose these complex ghost updates into a finite \emph{core} ghost update and the remaining \emph{context}.
To prove the core ghost update, we proceed as if the context was framed.
For the context, we employ a much simpler proof argument, namely that (the assertion describing) the context is \emph{invariant} under the update.

\input{content/motivation_lin}
\input{content/motivation_flow}


\subsection{Contributions and Overview}

Our first contribution is \emph{context-aware (concurrent) separation logic (\theLogic)}, which we describe in \cref{Section:CAReasoning}.
\theLogic is a conservative extension of separation logic that enables local reasoning about computations with large footprints.
Hoare judgments in \theLogic take the form $\choareof{\acontext}{\apred}{\astmt}{\apredp}$.
The judgment decomposes the footprint of $\astmt$ into two parts: a core footprint $\apred$ and a \emph{context} $\acontext$.
In our registry example, the core footprint is $\mcslstate(M(h)) \mstar (h, \emptyset)$, meaning we focus on the physical state $\mcslstate(M(h))$ and maintain $(h, \emptyset)$ as minimimalistic information about the ghost state. 
The context $\acontext$ is the approximation of the registry that takes into account potential updates. 
In our flow example, the core footprint is the physical footprint of the update.
The context is a predicate describing the nodes shaded in gray.

Akin to the frame rule, if $\choareof{\acontext}{\apred}{\astmt}{\apredp}$ is valid, then $\astmt$ transforms $\apred \mstar \acontext$ to $\apredp \mstar \acontext$.
However, the frame rule has to work for all possible frames $\aframe$ and must therefore require that no state in $\aframe$ is affected by $\astmt$.
In contrast, when $\hoareof{\apred}{\astmt}{\apredp}$ is viewed in the context of $\acontext$, the logic can take advantage of the fact that $\acontext$ is known.
This enables new opportunities for local reasoning in the cases where the full footprint of $\astmt$ is large.
Intuitively, $\acontext$ is the part of the state whose ghost component may be affected by the update, but the ghost component changes in a way such that $\acontext$ is maintained.
In the registry example, the context is defined by a closure of the current registry under potential updates, and is therefore invariant under updates by construction.  
In the flow example, the important property being maintained is the keyset invariant.

Our second contribution addresses the question of how to derive appropriate context predicates $\acontext$.
More precisely, given a predicate $\apred \mstar \apredppp$ that describes the pre-states of a computation $\astmt$, the \emph{contextualization} problem is to identify predicates $\apredp$ and $\acontext$ such that $\choareof{\acontext}{\apred}{\astmt}{\apredp}$ and $\apredppp \Rightarrow \acontext$ are valid.
We propose a principled approach based on abstract interpretation that solves contextualization % for the general setting where changes to the physical state induce large ghost state footprints
(\cref{sec:contextualization}).
The crux of the approach is to derive $\apredpp$ using an abstract semantics of $\astmt$.
By tailoring the abstraction to the specific ghost state and property of interest, one can derive simple reasoning principles for showing that $\astmt$ preserves $\apredpp$.
This style of reasoning enables better proof automation compared to proving $\hoareof{\acontext \mstar \apred}{\astmt}{\acontext \mstar \apredp}$ directly in standard separation logic.

We then instantiate this abstract solution for the concrete setting of the flow framework (\cref{sec:instantiation}).
The technical challenge here is that one needs to approximate a fixed point that is computed over the graphs in the image of $\apred \mstar \apredppp$ under $\astmt$, without precise information about what these graphs look like.
Our instantiation is motivated by the observation that, in practice, the change of the flow that emanates from the core footprint simply propagates through the context.
For instance, in the example shown in \cref{fig:bst-remove-flows}, the insets in the left subtree of $\anode$ uniformly increase by $[4,6)$ and in the right subtree they uniformly decrease by $[4,6)$.
In both cases, the change preserves the keyset invariant (which is the desired $\acontext$).
We identify general conditions under which the induced flow changes can be uniformly approximated.
In effect, this allows us to replace complex inductive reasoning to infer $\acontext$ from $\apredppp$ and $\astmt$ with simple local monotonicity reasoning about how the flow changes in the core footprint.

We have implemented our approach in the concurrency proof outline checker \nekton \cite{DBLP:conf/cav/MeyerOWW23} and used it to verify three highly concurrent binary search tree implementations.
It would be difficult to achieve the same degree of proof automation (using flows or recursive predicates) without contextualization due to the aforementioned challenges (unbounded footprints, DAG structures).
