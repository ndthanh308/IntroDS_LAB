%!TEX root = ../main.tex

\section{Related Work and Conclusion}
\label{sec:related}

The work closest to ours is a separation logic for establishing worst-case space complexity bounds of higher-order programs under garbage collection semantics \cite{DBLP:journals/pacmpl/MoineCP23}.
A core aspect of this work is to capture the \emph{roots} of heap graphs, i.e., memory addresses that are referenced from stack variables, because the root-reachable memory cannot be garbage collected. To that end, they introduce so-called \emph{stackable} assertions $\mathsf{Stackable}(l, p)$ for a location $l$ and a fractional permission $p$. Then, referencing location $l$ from a stack variable consumes a fraction of the stackable assertion. Once the stack variable goes out of scope, the stackable assertion is regained so that $l$ can be garbage collected.

\citet{DBLP:journals/pacmpl/MoineCP23} then observe that stackable assertions add a certain complexity to proofs. To alleviate this and allow for more automation, they adapt their program logic to take the form $\langle R \rangle \{ \phi \} \astmt \{ \psi \}$. Here, $R$ is a so-called \emph{souvenir}, which keeps track of the addresses for which a stackable assertion has been consumed (i.e., the set of addresses referenced from the stack). The semantics of souvenirs requires that the actually consumed stackable assertions are maintained by $\astmt$ and contain \emph{at least} the locations $R$. Note that the souvenir does not capture the stackable assertions exactly, nor does it make an assumption about their available fractions. Thus, souvenirs can be seen as another concrete instance of our development: a souvenir is a context and its construction aligns with our idea of upward closures with respect to an estimator.

The other work closest to ours is on the modular verification of reachability properties~\cite{DBLP:journals/pacmpl/Ter-GabrielyanS19}. 
The goal is to understand how the change of reachability in a subheap impacts the reachability in the overall heap, a problem referred to as reachability framing.
The contribution is a recompution method for so-called relatively-convex footprints.
As reachability information can be encoded into flows, the reachability framing problem can be cast as an approximation of a ghost multiplication for the corresponding flow graphs.
We give an approximation method for general flow graphs, and so have to work around the absence of domain-specific knowledge.
Our approach is to introduce estimator relations, which may be seen as distant relatives of relative convexity.

The main difference is that our work studies the impact of local changes on a context in a general setting, which leads to the notion of context-aware predicate transformers, the \eqref{Equation:Mediation} property, and the development of a program logic that has the new \ruleref{context} to frame the (known) context.
Another difference is that, inspired by classical framing, our approach strives for invariance of the context predicate, while the mentioned work embraces change.
It is an interesting problem for future work to embed the modification of ghost information in the context into a program logic.

Also related to our work is the ramification rule for separation logic~\cite{DBLP:conf/popl/HoborV13} (of which the principle developed in~\cite{DBLP:journals/pacmpl/Ter-GabrielyanS19} can be seen as a concrete instance).
Ramifications ease local reasoning about overlaid structures.
The rule says that to prove a global specification $\hoareof{\apred'}{\astmt}{\apredp'}$, one can focus on a more local one $\hoareof{\apred}{\astmt}{\apredp}$ provided $\apred'\subseteq \apred\mstar(\apredp\sepimp\apredp')$.
Indeed, the proof for \code{remove} that we gave in Section~\ref{sec:motivation} to motivate our work is via ramification.
As discussed there, the predicate $\htreepred$ is hard to work with, and it is precisely the separating implication $\apredp\sepimp\apredp'$ involved in ramification.

While this is the technical link, our work has a different goal than ramification, namely to localize footprints in cases where they become unbounded. % due to complex ghost state.
In the settings of interest to us, the triple $\hoareof{\apred}{\astmt}{\apredp}$ cannot be proven in the first place, because the computation aborts due to missing resources.
Our way out was to propose context-aware reasoning $\choareof{\apredpp}{\apred}{\astmt}{\apredp}$, which guarantees that the missing resources can be found in the context $\apredpp$.
While ramification is based on the \ruleref{frame} rule, we had to integrate context-aware reasoning deeply into the program logic, down to the semantics that we had to change to context-aware predicate transformers.
What came as a surprise was that every predicate transformer can be made context-aware via the induced semantics.

We share the goal of localizing unbounded footprints with the recent work~\cite{DBLP:journals/pacmpl/MeyerWW22}.
Their technique applies in cases where the unbounded footprint is traversed prior to the data structure's update.
It relies on the traversal to build up a predicate that captures the update's effect, very much in the style of ramifications.
Here, we consider the missing case that the unbounded footprint is not traversed, but still influenced by the propagation of updated ghost information.
We observe that the essential data structure invariants are invariant under such modifications, and develop the \ruleref{context} rule to frame out the corresponding parts (although they undergo modifications).

The context $\apredpp$ in \theLogic specifications $\choareof{\apredpp}{\apred}{\astmt}{\apredp}$ looks similar to a resource invariant in concurrent separation logic~\cite{DBLP:conf/concur/Brookes04,DBLP:conf/concur/OHearn04}.
The proof rule for atomic blocks in CSL temporarily adds the resource invariant to the specification in order to prove the atomic block.
Our \ruleref{context} rule proceeds the other way around and subtracts the context from the state to be able to reason locally.
The difference becomes clear when seeing the rules side-by-side:
$$
			\inferH{atomic}{
				\choareOf{\emp}{\apred\mstar \apredpp}{\astmt}{\apredp\mstar \apredpp}
				}{
				\choareOf{\apredpp}{\apred}{\text{\bfseries atomic}\ \astmt}{\apredp}
				}\hspace{3cm}
							\inferHlab{context-dup}{context}{
				\choareOf{\acontext}{\apred}{\astmt}{\apredp}
				}{
				\choareOf{\emp}{\apred\mstar \apredpp}{\astmt}{\apredp\mstar \apredpp}\ .
                              }$$
                            
We also address the contextualization problem, the problem of determining a predicate $\apredpp$ capturing substate that remains invariant under transitions.
This is related to the resource invariant synthesis problem addressed in~\cite{DBLP:conf/pldi/GotsmanBCS07,DBLP:conf/aplas/CalcagnoDV09}.
The concurrent setting suggests a thread-modular analaysis and a focus on locks.
Also related to contextualization is bi-abduction where, given predicates $\apred$ and $\apredp$, the task is to infer a frame $\apredp'$ as an unneeded part of the state and an anti-frame $\apred'$ as a missing premise, so that $\apred\mstar\apred'\subseteq\apredp\mstar\apredp'$ holds.
Our work is about ghost state, and our goal is to approximate the ghost multiplication.
This brings the new problem of approximating fixed points over heap graphs whose shape is not known.
Bi-abduction assumes to know the recursive predicates, and therefore the approach does not seem to carry over.

Beyond bi-abduction there is a rich literature on entailment checking and frame inference for separation logic with recursive predicates (see, e.g., \cite{DBLP:journals/jacm/CalcagnoDOY11, DBLP:conf/cade/BrotherstonDP11,DBLP:conf/pldi/PekQM14,DBLP:conf/sas/ToubhansCR14,DBLP:conf/nfm/EneaLSV17,DBLP:conf/cav/DardinierPWMS22,DBLP:journals/tocl/MathejaPZ23}). However, these works are limited to reasoning about tree-like structures without sharing and often do not extend to functional correctness properties. The flow framework~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23} aims to provide a shape-agnostic formalism for reasoning about rich inductive properties of general graphs.

We already discussed the connection to the morphism framework~\cite{DBLP:journals/pacmpl/Nanevski0DF19, DBLP:journals/pacmpl/FarkaN0DF21} which inspired our ghost multiplication.
Program logics like Iris~\cite{DBLP:journals/jfp/JungKJBBD18}, CAP~\cite{DBLP:conf/ecoop/Dinsdale-YoungDGPV10}, and TaDA~\cite{DBLP:conf/ecoop/PintoDG14} also provide mechanisms for introducing rich ghost state abstractions.
There, the ghost state exists only at the level of the logic and is coupled with the physical state via resource invariants.
Rather than letting the program semantics update the ghost state, the prover has the responsibility to update the ghost state via logical view shifts whenever the physical state changes and the invariant would be violated.
As view shifts must be frame-preserving, this implies that updates can still entail large footprints at the logical level.
Our work extends to these settings in the cases where the required logical view shifts are uniquely determined by the physical updates.

We implemented our approach in the proof checker \nekton \cite{DBLP:conf/cav/MeyerOWW23}.
We note that our improvements to the tool are orthogonal to techniques implemented in other proof checkers, like 
\atoolname{GRASShopper} \cite{DBLP:conf/tacas/PiskacWZ14},
\atoolname{CIVL} \cite{DBLP:conf/cav/HawblitzelPQT15,DBLP:conf/cav/KraglQ18},
\atoolname{Caper} \cite{DBLP:conf/esop/Dinsdale-YoungP17},
\atoolname{Starling} \cite{DBLP:conf/cav/WindsorDSP17},
\atoolname{Anchor} \cite{DBLP:journals/pacmpl/FlanaganF20},
\atoolname{Voila} \cite{DBLP:conf/fm/WolfSM21}, and
\atoolname{Diaframe} \cite{DBLP:conf/pldi/MulderKG22}.
These tools do not aim to simplify the reasoning about unbounded ghost state updates.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
