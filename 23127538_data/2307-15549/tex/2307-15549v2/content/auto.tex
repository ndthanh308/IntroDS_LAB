%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\subsection{Proof Automation}
\label{sec:instantiation:automation}

We implemented contextualization for flow graphs in the proof outline checker \nekton \cite{DBLP:conf/cav/MeyerOWW23} and applied it successfully to three challenging concurrent balanced binary trees, the FEMRS tree \cite{DBLP:conf/wdag/FeldmanE0RS18}, the contention-friendly tree (CFBST) \cite{DBLP:conf/europar/CrainGR13}, and the practical concurrent tree (PCBST) \cite{DBLP:conf/ppopp/BronsonCCO10}.
Our proofs establish
\begin{inparaenum}
 	\item functional correctness for the fixed linearization points of the algorithms, and
 	\item that the maintenance operations (rotations and removals) do not alter the logical contents of the tree.
\end{inparaenum}
This is the first formal proof of the FEMRS tree's maintenance operations and, as far as we know, the first proofs of CFBST and PCBST.
Our version of \nekton cannot deal with non-fixed linearization points of the non-blocking \code{contains} method due to imprecision in the tool's hindsight reasoning (see below).
However, we believe that this is an orthogonal concern to the contextualization presented here, because only the maintenance operations suffer from an unbounded footprint.
Detailed results are given in \Cref{table:eval}.
The blow up in runtime comes from the fact that \nekton handles the computation of strongest postconditions for disjunctions suboptimally (it computes a disjunctive normal form), resulting in a large number of SMT queries per atomic step in the proof.
We believe this can be alleviated with a more careful encoding.

\begin{table*}%
	\caption{%
		Experimental results for checking proofs of challenging concurrent tree implementations with \nekton.
		Our results include the lines of code (\#code), lines of proof annotations (\#proof), lines of invariant/flow definitions (\#def), the ratio between \#code and \#proof+\#def, and the runtime and verdict of the proof check. Runtimes are averaged across 10 runs. The evaluation was conducted on an Apple M1 Pro.}%
	\label{table:eval}%
		% 
		% nekton @ commit 41d0204
		% https://github.com/OpaAnton/plankton/commit/41d0204e9b647dc0b706f3d831b73b1e1df2c3d9   
		% 
		% | File                |       Code |     Proof |       Def |     Ratio |
		% +---------------------+------------+-----------+-----------+-----------+
		% | examples/FEMRS.pl   |        251 |       318 |        95 |    1:1.65 |
		% | examples/CFBST.pl   |        257 |       276 |       107 |    1:1.49 |
		% | examples/PCBST.pl   |        444 |       657 |       115 |    1:1.74 |
		% 
		% Benchmark 1: bin/nekton ../examples/FEMRS.pl
		%   Time (mean ± σ):     1999.145 s ± 29.620 s    [User: 6781.987 s, System: 2163.500 s]
		%   Range (min … max):   1961.691 s … 2047.271 s    10 runs
		% 
		% Benchmark 2: bin/nekton ../examples/CFBST.pl
		%   Time (mean ± σ):     2659.898 s ± 25.553 s    [User: 8743.805 s, System: 2430.763 s]
		%   Range (min … max):   2596.250 s … 2687.383 s    10 runs
		%
		% Benchmark 3: bin/nekton ../examples/PCBST.pl
		%   Time (mean ± σ):     6061.561 s ± 102.750 s    [User: 14004.143 s, System: 5800.898 s]
		%   Range (min … max):   5819.870 s … 6183.645 s    10 runs
		% 
		\center%
		\newcommand{\cell}[1]{\makebox[1cm][c]{\(#1\)}}
		\newcommand{\cellYes}[1]{\makebox[1cm][r]{\(#1\)}\hspace{1.5mm}\makebox[.4cm][l]{\symbolYes}}
		\setlength{\tabcolsep}{4pt}
		\begin{tabularx}{\textwidth}{Xlccccc}%
			\toprule
			Benchmark
				& Properties verified
				& \#code
				& \#proof
				& \#def
				& Ratio
				& ~Time
				\\
			\midrule
			FEMRS tree \cite{DBLP:conf/wdag/FeldmanE0RS18}
				& fixed LPs, maintenance
				& \cell{251}
				& \cell{318}
				& \cell{95}
				& \cell{1:1.65}
				& \cellYes{34m}
				\\
			\midrule
			% Contention-friendly BST \cite{DBLP:conf/europar/CrainGR13}
			CFBST \cite{DBLP:conf/europar/CrainGR13}
				& fixed LPs, maintenance
				& \cell{257}
				& \cell{276}
				& \cell{107}
				& \cell{1:1.49}
				& \cellYes{45m}
				\\
			\midrule
			% Practical concurrent BST \cite{DBLP:conf/ppopp/BronsonCCO10}
			PCBST \cite{DBLP:conf/ppopp/BronsonCCO10}
				& all LPs, maintenance
				& \cell{444}
				& \cell{657}
				& \cell{115}
				& \cell{1:1.74}
				& \cellYes{101m}
				\\
			\bottomrule
	\end{tabularx}
\end{table*}

\nekton takes as input the program under scrutiny, its proof outline (separation logic assertions in the program), and a flow domain specifying the flow monoid and the edge functions being used.
It then checks whether the proof is valid, i.e., is a valid derivation using the rules from \Cref{Figure:PL}.
This step relies on entailment checking procedures tailored towards flows.

We adapted \nekton to support contextualization.
To that end, the flow domains that \nekton accepts as input are extended with an estimator.
Then, whenever an update is not local to the footprint that \nekton constructs, we use the given estimator and check whether the flow update is compatible with the estimator (\nekton guarantees that the physical update is contained in the footprint).
In terms of \Cref{thm:instantiation-closure}, this means we check $\afg\ctxfprel\afgp$ where $\afg$ and $\afgp$ is the footprint before and after the update, respectively.
To conform with the upward-closure requirement for such updates on the entire flow graph, $\afgp\imult\afgpp$ in \Cref{thm:instantiation-closure} where $\afgpp$ is the context, we have \nekton check that all assertions in the proof are stable wrt. the given estimator.
We do this for all assertions and not just the post assertion of the update because the update could be performed by an interfering thread at \emph{any time}, it becomes part of the interference set alluded to in \Cref{sec:og}.
With these adaptions, \nekton is able to validate our proof of the FEMRS, CFBST, and PCBST trees.

Our benchmark set is relatively small and we did not validate non-fixed linearzation points.
This is not due to incompatibility with our theory, but rather due to orthogonal challenges with \nekton.
The main problem is that \nekton breaks down interferences into per-address interferences, resulting in imprecision.
On the one hand, imprecise interferences hinder hindsight reasoning and thus our ability to validate non-fixed linearzation points.
On the other hand, it forces us to apply the upward-closure to all nodes in the context, even though some locking strategies in fine-grained concurrent trees can prevent nodes from actually experiencing a change in inflow.
As a consequence, some estimators do not work with \nekton although they allow for valid proofs in principle.
We did not improve \nekton's handling of interferences for this paper as this would require a rewrite of large parts of the code base to deal with orthogonal concerns.
We note that the contextualization that goes into our proofs reflect the estimators required for numerous other concurrent trees \cite{DBLP:conf/spaa/HowleyJ12,DBLP:conf/podc/EllenFRB10,DBLP:conf/ppopp/BrownER14,DBLP:conf/podc/ArbelA14,DBLP:conf/icdcn/RamachandranM15,DBLP:conf/ppopp/RamachandranM15,DBLP:conf/ppopp/Drachsler-Cohen18,DBLP:journals/topc/NatarajanRM20}.
