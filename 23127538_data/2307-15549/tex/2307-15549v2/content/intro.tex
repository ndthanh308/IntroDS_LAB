%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\section{Introduction}

Separation logic~\cite{DBLP:conf/csl/OHearnRY01,DBLP:conf/lics/Reynolds02} has had a formative influence on many modern program logics. Its success has been linked to its ability to reason locally about mutable state~\cite{DBLP:journals/cacm/OHearn19}. Assertions in separation logic denote physical resources such as memory locations and their contents. These resources can be composed using \emph{separating conjunction} to express disjointness constraints. Correctness judgments in the logic guarantee that a program does not access any resources that are not explicitly specified in the program's \emph{footprint}. Together, these characteristics give rise to the \emph{frame rule}, which allows one to conclude for free that any resource disjoint from the footprint is not affected by the program's execution. Thus, one can reason locally about only those parts of the program state that are relevant for the computation at hand.

Modern separation logics provide rich formalisms for layering abstractions on top of the physical resources manipulated by the program~\cite{DBLP:journals/jfp/JungKJBBD18, DBLP:conf/ecoop/Dinsdale-YoungDGPV10, DBLP:conf/ecoop/PintoDG14, DBLP:conf/pldi/GuSKWKS0CR18, DBLP:books/daglib/0034962}. These abstractions take the form of ghost resources that come equipped with their own fictional notion of separation, lifting the locality principle from the low-level program state all the way up to the level of abstract specifications of functional correctness properties.

Ghost resources induce a stronger notion of separation than mere disjointness on the abstracted physical resources~\cite{DBLP:journals/pacmpl/FarkaN0DF21}. As a consequence, the abstract footprint can comprise more physical resources than only those that the program directly manipulates. In fact, the footprint can become unbounded. For example, consider a ghost resource that abstracts a linked data structure by its contents. When the program inserts a new value into the structure, then the abstract effect will involve reasoning about the entire data structure state (because the ghost resource abstracts the whole structure), even though the insertion may only update a single memory location. Such unbounded ghost footprints also arise for other forms of ghost resources, e.g., when reasoning about future-dependent linearization points~\cite{DBLP:journals/pacmpl/JungLPRTDJ20,DBLP:journals/pacmpl/PatelKSW21} and space complexity bounds~\cite{DBLP:journals/pacmpl/MoineCP23}.

Thus, reasoning about ghost resources often deteriorates back to global reasoning about an unbounded set of physical resources. This global reasoning may, e.g., involve induction proofs for lemmas that are used to manipulate recursive predicates in the proof. While there has been much progress on automating such reasoning~\cite{DBLP:journals/jacm/CalcagnoDOY11, DBLP:conf/cade/BrotherstonDP11,DBLP:conf/pldi/PekQM14,DBLP:conf/sas/ToubhansCR14,DBLP:conf/nfm/EneaLSV17,DBLP:conf/cav/DardinierPWMS22,DBLP:journals/tocl/MathejaPZ23}, it remains a challenge for rich functional specifications and ghost resources that cannot be expressed in decidable theories.

\smartparagraph{Contributions.}
This paper aims to create new opportunities for local reasoning when dealing with computations that have unbounded footprints. We introduce \emph{context-aware (concurrent) separation logic (\theLogic)}. The key insight of \theLogic is that one can relax the locality requirement on the semantics of programs if the resources to be framed are known in advance. That is, in \theLogic one can frame a given \emph{context} $\acontext$ across a computation, provided that any changes affected on the resources in the context preserve $\acontext$. Intuitively, $\acontext$ can be subtracted from the footprint of the computation even though these resources may be subject to modification. We then present an abstract interpretation principle for computing appropriate contexts $\acontext$ to aid proof automation.

We describe several applications of context-aware reasoning. Our main application is a full instantiation of our approach to the flow framework~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23} to enable contextual reasoning about heap-manipulating programs and properties that are defined inductively over general heap graphs. In particular, this allows us to handle fine-grained concurrent search tree implementations featuring unbounded footprints due to intricate maintenance operations (e.g. removal of interior nodes) without the need for induction proofs.

To demonstrate the practical usefulness, we have implemented our approach in the proof outline checker \nekton~\cite{DBLP:conf/cav/MeyerOWW23}. We use the tool to verify the FEMRS tree~\cite{DBLP:conf/wdag/FeldmanE0RS18}, the contention-friendly binary search tree~\cite{DBLP:conf/europar/CrainGR13}, and the practical concurrent binary search tree~\cite{DBLP:conf/ppopp/BronsonCCO10}. Our proofs are the first formal proofs of these tree implementations. Beyond our verification effort, contextual reasoning applies in a similar fashion to a wide variety of concurrent search trees \cite{DBLP:conf/spaa/HowleyJ12,DBLP:conf/podc/EllenFRB10,DBLP:conf/ppopp/BrownER14,DBLP:conf/podc/ArbelA14,DBLP:conf/icdcn/RamachandranM15,DBLP:conf/ppopp/RamachandranM15,DBLP:conf/ppopp/Drachsler-Cohen18,DBLP:journals/topc/NatarajanRM20}. Overall, this makes contextual reasoning an indispensable technique for (semi-)automatic proofs.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
