%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\subsection{A Concurrent Extension}
\label{sec:og}

To reason about concurrent programs in separation logic we employ the Owicki-Gries proof principle \cite{DBLP:journals/acta/OwickiG76}.
That is, we reason in two steps.
First, we verify the program code as if it was run by a single thread in isolation.
Second, we check interference freedom to ensure that the proof remains valid in the presence of other threads.
If so, the concurrent Hoare triple $\hoareOf{\apred}{\astmt}{\apredp}$ is valid, denoted by ${}\mmodels\hoareof{\apred}{\astmt}{\apredp}$, meaning that any number of threads each executing $\astmt$ and starting in $\apred$ will reach $\apredp$.

The judgments for verifying the isolated thread take the form $\thePredicates,\theInterference\semcalc\hoareOf{\apred}{\astmt}{\apredp}$.
The proof rules for these judgments (\Cref{app:og-casl}) collect the predicates that were used during the proof in the set $\thePredicates$ and the interferences in the set~$\theInterference$~\cite[Section 7.3]{DBLP:conf/popl/Dinsdale-YoungBGPY13}.
The interferences can be thought of as pairs $(\acom, \apred)$ for which rule \ruleref{com} was applied.
Recording these pairs allows to later \emph{replay} the effect of the command on other threads.

The interference freedom check ensures that, given a set of interferences $\theInterference$ and a set of predicates $\thePredicates$, no interference $(\acom, \apred)$ from $\theInterference$ can invalidate a predicate $\apredp$ from $\thePredicates$.
Intuitively, this means that replaying $\acom$ under $\apred \cap \apredp$ results in a state covered by $\apredp$.
To support per-thread local state, one has to assume that the underlying separation algebra is a product of two separation algebras defining the global and local state.
Then, the effect of the interfering command is its update to the global state, leaving the local state unchanged.
More concretely, if $\apred=(\ashared_\apred,\alocal_\apred)$ and $\apredp=(\ashared_\apredp,\alocal_\apredp)$ then we compute $\semof{\acom}{\ashared_\apred\cap\ashared_\apredp,\alocal_\apred}=(\ashared',\alocal')$ and check if $(\ashared',\alocal_\apredp)\predleq\apredp$.
If this is the case, we write $\isInterferenceFreeOf[\theInterference]{\thePredicates}$ and say that $\thePredicates$ is interference-free wrt. $\theInterference$.

The resulting Owicki-Gries proof system is sound \cite{DBLP:journals/pacmpl/MeyerWW22}.

\begin{theorem}
	\label{thm:soundness-OG}
	$\thePredicates, \theInterference\semcalc\hoareof{\apred}{\astmt}{\apredp}$
	and
	${}\isInterferenceFreeOf[\theInterference]{\thePredicates}$
	and
	$\apred\in\thePredicates$
	imply
	${}\mmodels\hoareof{\apred}{\astmt}{\apredp}$.
\end{theorem}

We develop \emph{context-aware concurrent separation logic (\theLogicOG)} whose
judgements take the form $\thePredicates, \theInterference\semcalc\choareof{\acontext}{\apred}{\astmt}{\apredp}$.
As for \theLogicSeq, $\acontext$ is meant to be framed to the pre- and postcondition.
That is, validity $\mmodels\choareof{\acontext}{\apred}{\astmt}{\apredp}$ holds iff $\mmodels\hoareof{\apred\mstar\acontext}{\astmt}{\apredp\mstar\acontext}$.
The extended program logic is as expected, we elide it here for brevity.
Refer to \Cref{app:og-casl} for more details.
This extension is sound and it is easy to obtain a conservative extension of the standard Owicki-Gries approach.

\begin{theorem}
	\label{thm:soundness-OGCASL}
	$\thePredicates, \theInterference\semcalc\choareof{\acontext}{\apred}{\astmt}{\apredp}$
	and
	${}\isInterferenceFreeOf[\theInterference]{\thePredicates}$
	and
	$\apred\in\thePredicates$
	imply
	${}\mmodels\choareof{\acontext}{\apred}{\astmt}{\apredp}$.
\end{theorem}

Since contextualization addresses atomic commands, it is equally applicable to both the sequential $\theLogicSeq$ and the concurrent $\theLogicOG$. To avoid notational clutter, we stay within $\theLogicSeq$ throughout the remainder of the paper. However, we stress that we have evaluated our approach against concurrent benchmarks, see \cref{sec:instantiation:automation}.
