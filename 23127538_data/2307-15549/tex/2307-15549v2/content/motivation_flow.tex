%!TEX root = ../main.tex

\newcommand{\treepred}{\mathsf{tree}}
\newcommand{\htreepred}{\mathsf{htree}}
\newcommand{\findSucc}{\mymathtt{findSucc}}
\newcommand{\remove}{\mymathtt{remove}}
\newcommand{\pointsto}{\mapsto}
\newcommand{\pnull}{\mathsf{null}}
\newcommand{\aframe}{\mathit{c}}

\subsection{Flow}
\label{sec:motivation:flow}

Contextual reasoning is also useful when relating the physical representation of a data structure to the ghost state that captures its logical contents.
To illustrate this, we use a binary search tree (BST) that implements a mathematical set.
In practical implementations, a BST will have distinct \code{insert} and \code{delete} operations, rather than the single \code{upsert} operation used in our high-level linearizability argument above (\cref{sec:motivation}).
We focus on \code{delete}, specifically the in-place removal of a key stored in an inner node of the tree.
This is the most interesting case of the operation.

\input{content/fig_motivation_code}

\Cref{fig:bst-remove} shows the code of the operation and illustrates how it changes the tree.
Each node in the tree is labeled with its key. The key $k$ to be removed is stored in node $\anode$.
The operation proceeds in four steps.
First, it uses the helper function $\findSucc$ to identify the left-most node $\anodep$ in the right subtree of $\anode$, as well as its parent $p$.
That is, $j$ is the next larger key stored in the tree after $k$.
We omit the definition of $\findSucc$.
The \code{assume} statement models a branching condition.
We focus on the case where $p \neq \anode$.
The operation copies the key $j$ from $\anodep$ to $\anode$, effectively removing $k$ from the structure.
Next, it unlinks $\anodep$ from the tree by setting $p$'s left pointer to the right child of $\anodep$.
This is to maintain the invariant that each key occurs at most once in the tree.
Finally, $\anodep$ is garbage collected.

Our goal is to demonstrate the functional correctness of the operation, meaning the operation updates the tree's contents from $\contents$ to $\contents \setminus \set{k}$.
A conventional proof in separation logic would use a recursive predicate to tie the data structure's physical representation to its contents $\contents$.
However, this approach has several disadvantages, especially for proof automation.
First, the prover needs to infer auxiliary inductive predicates to decompose the proof state into the footprint and the frame.
Next, the prover needs to derive auxiliary data-structure and property-specific lemmas to enable reasoning about the involved (auxiliary) predicates.
Finally, and perhaps most importantly, the proof does not easily generalize.
In a concurrent setting, threads may temporarily break the tree structure by introducing sharing, resulting in DAGs rather than trees.
Consequently, proofs can no longer rely on simple recursive predicates but require more complex machinery such as overlapping conjunctions~\cite{DBLP:conf/aplas/DockinsHA09,DBLP:conf/popl/GardnerMS12} and ramifications~\cite{DBLP:conf/popl/HoborV13}.

\smartparagraph{Node-local reasoning.}
An alternative to recursive predicates is to use indexed separating conjunction to describe unbounded heap regions~\cite{Yang01ShorrWaite, DBLP:conf/cav/0001SS16}.
These are predicates of the form $\bigmstar_{\anode \in \setnodes} \apred(x)$ and express that $\apred(\anode)$ must hold disjointly for all nodes $\anode \in \setnodes$.
The predicate $\apred(\anode)$ specifies a node-local property (e.g., constraining the values of a single points-to predicate for $\anode$).
Indexed separating conjunctions can be easily composed and decomposed along arbitrary partitions of $\setnodes$.
This greatly simplifies framing.
They can also be used to describe general graphs.
The recently proposed flow framework~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23} extends this approach so that $\apred(\anode)$ can capture global properties of the heap graph spanned by the nodes in $\setnodes$.
The approach works by augmenting every node with additional ghost information, its \emph{flow}.
Flows are computed inductively over the graph structure using a data-flow equation.
The equation can be thought of as collecting information about all possible traversals of the graph.
The definition is such that it still yields generic reasoning principles for decomposing and composing predicates similar to those for indexed separating conjunctions.

A suitable flow for verifying the functional correctness of our $\remove$ operation assigns to each node its \emph{inset}.
Intuitively, the inset of a node $\anode$ consists of the set of keys $k$ such that an operation on $k$ may traverse $\anode$ to find $k$.
\Cref{fig:bst-remove-flows} shows two search trees, before and after execution of the $\remove$ operation, with the inset of each node annotated in {\color{blue}blue}.
For example, the inset of $\anodep$ in the pre-state is the interval $\color{blue}(4,8)$ because the largest (highest up) key on the path from the $\Root$ to $\anodep$ when moving right is $4$ and the smallest key when moving left is $8$.

If we subtract from a node's inset all the insets of its children, we derive its \emph{keyset}.
For example, in the pre-state, the keyset of $p$ is $\{8\}$ and the keyset of $\anode$'s left child is $(-\infty,1]$. 
Assuming searches follow deterministic paths through the graph (as they do for binary search trees), then the keysets are pairwise disjoint~\cite{DBLP:journals/tods/ShashaG88}.
This means the keyset of a node $\anode$ consists of exactly those keys that can only be found in $\anode$ if they are stored anywhere in the structure.

\input{content/fig_motivation_flows}

To reason about the functional correctness of the operations on the tree, we simply maintain the following \emph{keyset invariant}:  the key stored in each node is contained in the node's keyset.
The overall contents $\contents$ of the tree is the union of all keys stored in its nodes.
The keyset invariant together with the disjointness of the keysets imply that the node-local contents are also disjoint.
Hence, any change made to the contents of a node, such as replacing its key, is reflected by a corresponding change of the global contents $\contents$.
That is, we can now reason node-locally about the overall functional correctness of the search tree operations!


\smartparagraph{Unbounded footprints.}

To enable compositional reasoning about inductive properties, the flow framework adds an additional constraint on separating conjunction: two graphs augmented with flows compose only if their flow values are consistent with the flow obtained in the composite graph~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23}.
As a consequence, the footprint of an update on the graph can be larger than the \emph{physical} footprint that encompasses the changes to the graph structure (i.e., when ignoring the auxiliary ghost state).
In fact, the full footprint can be unbounded even if the physical footprint is not.

For the $\remove$ operation, the physical footprint consists of the three nodes $\anode$, $p$, and $\anodep$ (shaded yellow in \cref{fig:bst-remove-flows}).
However, observe that moving $\anodep$'s key to $\anode$ changes the insets of all the nodes shaded in gray.
These are the nodes on the path from $\anode$ to $\anodep$ as well as all nodes on the path from $\anode$ to the right-most leaf in its left subtree.
As these paths can be arbitrarily long, the footprint of the update is unbounded.

If we attempt to reason solely about the bounded physical footprint and put everything else into the frame, the proof will fail: after the update, the physical footprint no longer composes with the frame, as the insets of the two regions are inconsistent.
In a sense, the stronger notion of graph composition forces us to reconcile with the global effect of the update immediately at the point when the update occurs. Thus, reasoning about an update with an unbounded footprint appears to entail some form of quantifier instantiation or inductive argument, which adversely affects proof automation.

\begin{quote}\itshape
New reasoning techniques are needed to effectively handle unbounded footprints.
\end{quote}

Existing works on the flow framework have either considered only updates with bounded footprint~\cite{DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23} or cases where the unbounded footprint is traversed by the program prior to the update~\cite{DBLP:journals/pacmpl/MeyerWW22}.
However, not all updates fall into these categories as our example demonstrates.
In this paper, we provide a general solution.

Finally, we note that the issue of having to reason about large footprints is not unique to the flow framework or registry-like constructs.
It has been observed in the literature that this issue arises naturally whenever rich ghost state abstractions are layered on top of the physical state, thereby inducing a stronger notion of separation~\cite{DBLP:journals/pacmpl/Nanevski0DF19, DBLP:journals/pacmpl/FarkaN0DF21}.
This is why we formulate our solution in the setting of abstract separation logic~\cite{DBLP:conf/lics/CalcagnoOY07}, so that it can apply broadly.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
