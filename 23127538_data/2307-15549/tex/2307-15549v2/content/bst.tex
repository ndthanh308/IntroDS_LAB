%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\subsection{Example: Contextualization for a Binary Search Tree}
\label{sec:bst-example}

We demonstrate our shape-independent contextualization by applying it to a binary search tree (BST).
We highlight how our approach localizes the proof to bounded footprints in scenarios where framing cannot.

For clarity of the exposition, we stay in the sequential setting and 
discuss a sequential BST implementation.
However, our implementation is modeled after find-grained concurrent implementations, like \cite{DBLP:conf/wdag/FeldmanE0RS18,DBLP:conf/europar/CrainGR13,DBLP:conf/ppopp/BronsonCCO10,DBLP:conf/icdcn/RamachandranM15,DBLP:conf/ppopp/DrachslerVY14,DBLP:journals/topc/NatarajanRM20,DBLP:conf/ppopp/RamachandranM15,DBLP:conf/icdcn/RamachandranM15}.
Specifically, the structural updates are similar in both sequential and concurrent implementations. 
In our experiments in \cref{sec:instantiation:automation}, we verify the actual concurrent implementations, and confirm this similarity.

We consider a BST implementation that comes with operations \code{contains}, \code{insert}, and \code{delete} for looking up, inserting, and deleting keys, respectively.
The implementation of these operations is standard.
Operation \code{contains} traverses the tree using binary search.
Operation \code{insert} adds new keys as leaf nodes to the tree if the given key is not already present.
Operation \code{delete} marks nodes as deleted using a \code{del} bit.
Marking nodes is referred to as logical deletion, it changes the contents of the tree but does not modify its structure.
The physical removal, i.e., the unlinking of marked nodes, is performed by dedicated maintenance operations.

Due to space constraints, we elide the implementation of \code{contains}, \code{insert}, and \code{delete} here; they appear in \cref{app:bst-rot}.
Instead, we focus on the maintenance operations \code{removeSimple} and \code{removeComplex}.
They are the interesting part because their updates have an unbounded footprint.

To specify the operations of our BST implementation, we define the predicate $\bst{\abscontent}$ denoting a binary search tree with logical contents $\abscontent$.
With this understanding, we wish to verify the following specification of the maintenance operations:
\[
  \hoareof{\bst{\abscontent}}{~\mcode{removeSimple()}~}{\bst{\abscontent}}
  \quad~~\text{and}~~\quad
  \hoareof{\bst{\abscontent}}{~\mcode{removeComplex()}~}{\bst{\abscontent}}
  \enspace .
\]
In order to tie the logical contents of the specification to the physical state of the implementation, we define $\bst{\abscontent} \defeq \exists\setnodes.~\inv{\abscontent,\setnodes,\setnodes}$.
Predicate $\invraw$ is the structural invariant:
\begin{align*}
  \inv{\abscontent, \setnodesp, \setnodes} ~=~~&
    \Root\in\setnodes \MSTAR \nullptr\notin\setnodes \MSTAR
    \setnodesp\subseteq\setnodes \MSTAR \abscontent=\ctnof{\setnodesp} \MSTAR {\bigmstar}_{\!\!\anode\in\setnodesp~~} \nodeof{\anode} \mstar \ninv{\anode,\setnodes}
  \\
  \ninv{\anode,\setnodes} ~=~~&
    \set{\leftof{\anode},\rightof{\anode}}\subseteq\setnodes\uplus\set{\nullptr}
    ~~\land~~
    \bigl(\isof{\anode}\neq\bot \implies \ctnof{\anode}\subseteq\ksof{\anode})
    ~~\land~~
    \\&
    \isof{\anode} \neq \top
    ~~\land~~
    \bigl(\anode = \Root \implies (-\infty,\infty] \subseteq \isof{\anode} \land \keyof{\anode}=\infty\bigr)
    \enspace .
\end{align*}
The invariant has two main ingredients.
First, it ties the expected logical contents $\abscontent$ to the physical contents $\ctnof{\setnodesp}$ of the region $\setnodesp$.
The set $\ctnof{\setnodesp}=\bigcup_{\anodep\in\setnodesp} \ctnof{\anodep}$ collects the keys of all unmarked nodes, $\ctnof{\anodep}=(\ite{\delof{\anode}}{\emptyset}{\set{\keyof{\anode}}})$.
Second, it carries the resources $\nodeof{\anode}$ for all nodes $\anode\in\setnodesp$ and specifies their properties using the node-local invariant $\ninv{\anode,\setnodes}$ from \cref{ex:estimator-motivation} (repeated for convenience).
Predicate $\nodeof{\anode}$ boils down to a standard points-to predicate, we omit its definition.

We turn to the implementation of \code{removeSimple} and \code{removeComplex}, and prove them correct.


%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsubsection{Simple Removals}
\label{sec:bst:remove-simple}

Operation \code{removeSimple} physically removes (unlinks) nodes that have been marked as deleted.
It is a ``simple'' removal because it unlinks nodes only if they have at most one child.
To satisfy its specification, it must leave the logical contents of the tree unchanged.

\input{content/fig_bst_simple}

The implementation and proof outline of \code{removeSimple} are given in \cref{fig:simple-removal:impl}. 
Starting from an arbitrary node $\x$ currently linked into the tree, the left child $\y$ of $\x$ is read out.
If $\y$ is a non-null marked node with at most one child, \code{removeSimple} unlinks $\y$.
We focus on the case where $\y$ has no left child.
Then, it is unlinked by making $\y$'s right child the left child of $\x$, i.e., by updating $\selof{\x}{left}$ to $\rightof{\y}$ on \cref{code:simple-remove:unlink}.
\Cref{fig:simple-removal:prestate,fig:simple-removal:poststate} illustrate the pre- and post-state of the update for the part of the tree rooted in $\x$.
The \colorbg{backgroundFootprint}{footprint} of the physical unlinking contains just the nodes $\x$ and~$\y$.
The proof for the update of the footprint is as expected because it is readily checked that the invariant is maintained for the nodes $\x$ and $\y$.
This is the transition from \cref{code:simple-remove:pre-footprint} to \cref{code:simple-remove:post-footprint}.

The accompanying ghost update, however, is unbounded, it oozes into the right subtree $A$ of $\y$.
Coming back to \cref{fig:simple-removal:prestate,fig:simple-removal:poststate}, let $\ais=\isof{\x}\neq\bot$ be the inset of $\x$.
Before the update, $A$-bound searches follow the edges $\leftof{\x}$ and $\rightof{\y}$.
That is, the inset of $A$ is $\ais\cap(\keyof{\y},\keyof{\x})$.
After the update, $\y$ is skipped and the inset of $A$ is $\ais\cap[-\infty,\keyof{x})$.
Because the keys in $A$ are larger than $\keyof{\y}$, the additional inset $\ais\cap[-\infty,\keyof{\y}]$ after the update is forwarded to the left-most leaf in $A$.
That is, the ghost footprint is unbounded and the \ruleref{frame} rule does not apply.

The \ruleref{context} rule, however, does apply.
We have already seen that $\simplerel$ is an estimator that captures updates to the tree that increase the inset of reachable nodes, like the one we have here.
The invariant is $\simplerel$-closed because the inset/keyset occurs only on the right-hand sight of inclusions, the inset of unreachable nodes remains $\bot$, and no node's inset becomes $\top$.
That is, we can \colorbg{backgroundContext}{contextualize} everything outside the footprint $\set{\x,\y}$.
This is the annotation on \cref{code:simple-remove:context}.

Altogether, $\choareof{\set{\text{\Cref{code:simple-remove:context}}}}{\text{\Cref{code:simple-remove:pre-footprint}}}{\text{\Cref{code:simple-remove:unlink}}}{\text{\Cref{code:simple-remove:post-footprint}}}$ is a valid CASL statement.
Rule \ruleref{context} thus yields $\choareof{\emp}{\text{\Cref{code:simple-remove:pre}}}{\text{\Cref{code:simple-remove:unlink}}}{\text{\Cref{code:simple-remove:post}}}$ and by relative soundness this is a valid statement in classical separation logic.
That is, \code{removeSimple} does not alter the logical contents of the tree.


%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsubsection{Complex Removals}
\label{sec:bst:remove-complex}

Operation \code{removeComplex} unlinks marked nodes that have two children, without changing the logical contents of the tree.
\Cref{fig:complex-removal} gives the implementation and proof outline.
There are four steps in \code{removeComplex}.
First, it obtains a reachable, marked node $\x$ with two children.
Second, it uses the helper \code{findSucc} to find the left-most leaf $\y$ and its parent $\p$ in the subtree $B$ rooted at $\x$'s right child.
The helper implementation and proof are straightforward, we defer it to \cref{app:bst-rotate}.
To avoid distracting case distinctions, we assume $\p\neq\x$.
Third, the contents of $\x$ and $\y$ are swapped, \crefrange{code:complex-remove:move}{code:complex-remove:del-y}.
This is the most interesting part and we discuss it below.
Last, $\y$ is unlinked.
The unlinking is as in \code{removeSimple} because $\y$ has at most one child.

\input{content/fig_bst_complex}

We turn the discussion to the third step.
To avoid confusion between the values of fields before and after the following updates, we record the values $\akey_\x=\keyof{\x}$, $\akey_\y=\keyof{\y}$, and $\ais=\isof{\x}$ from before the update, as on \cref{code:complex-remove:pre}.
Note that $\akey_\x<\akey_\y$.
Now, \cref{code:complex-remove:move} copies $\akey_\y$ into $\x$.
This is challenging due to its intricate unbounded flow footprint, which is visualized in \cref{fig:complex-removal:prestate,fig:complex-removal:poststate}.
The update increases the inset of $\x$'s left subtree $A$ from $\ais\cap[-\infty,\akey_\x)$ to $\ais\cap[-\infty,\akey_\y)$.
The inset of $\x$'s right subtree $B$, in turn, decreases from $\ais\cap(\akey_\x,\infty]$ to $\ais\cap(\akey_\y,\infty]$.
That is, the portion $\aks=\ais\cap(\akey_\x,\akey_\y]\subseteq\ksof{\y}$ is redirected from $B$ to $A$.
The estimator $\complexrel$ defined by \[
  \amonval\complexrel\amonvalp
  ~~\defifff~~
    \amonval\simplerel\amonvalp
    \,~\lor~
    \bigl(\,
      \setc{\amonval,\amonvalp}\cap\setc{\bot,\top}=\emptyset ~\land~ \akey_\x\notin\amonval ~\land~ \amonval\setminus\aks\subseteq\amonvalp
    \,\bigr)
\]
captures that insets may
\begin{inparaenum}
	\item increase arbitrarily, or
	\item decrease by up to $\aks$, if they do not contain $\akey_\x$.
\end{inparaenum}
The side condition localizes the decrease to the subtrees of $\x$.

For handling the update, we choose nodes $\x$ and $\y$ as the footprint and contextualize everything else.
Technically, the context is $\inv{\abscontent_1,\setnodes\setminus\set{\x,\y},\setnodes}$ and the footprint is $\inv{\abscontent_2,\set{\x,\y},\setnodes}$ with $\abscontent=\abscontent_1\cup\abscontent_2$.
The main challenge is to show that the context is $\complexrel$-closed, in particular, tolerates reduced insets.
To that end, consider a node $\z\in\setnodes\setminus\set{\x,\y}$ with $\isof{\z}\neq\bot$.
By the invariant, $\ctnof{\z}\subseteq\isof{\z}$.
If $\z$ is marked, then $\ctnof{\z}=\emptyset$ and the inclusion is vacuously true.
Otherwise, we are obliged to show $\keyof{\z}\notin\aks$ to preserve the inclusion.
Because $\aks\subseteq\ksof{\y}$ and $\keyof{\z}\in\ksof{\z}$, it suffices to show $\ksof{\y}\cap\ksof{\z}=\emptyset$.
This follows from a result due to \citet{DBLP:journals/tods/ShashaG88}, stating that the keyset of all nodes are pairwise disjoint if all searches are deterministic and start in a dedicated root node.\footnote{%
	We could encode this into the invariant $\invraw$ using the keyset algebra proposed in~\cite{DBLP:conf/pldi/KrishnaPSW20}, but refrain from the added complexity.
}
Since the requirements are satisfied in our setting, the result applies and discharges our proof obligation.
Overall, the context $\inv{\abscontent_1,\setnodes\setminus\set{\x,\y},\setnodes}$ on \cref{code:complex-remove:ctx} is $\complexrel$-closed.

We turn to the footprint $\inv{\abscontent_2,\set{\x,\y},\setnodes}$, \cref{code:complex-remove:footprint-pre}.
The physical update changing $\selof{\x}{key}$ from $\akey_\x$ to $\akey_\y$ is as expected.
\Cref{thm:contextualization} prescribes that the footprint be $\complexrel$-closed after the update.
Because $\akey_\x,\akey_\y\in\ais$ prior to the update, $\complexrel$ does not remove $\akey_\y$ from the inset of $\x$.
Together with $\delof{\x}$, we have $\inv{\emptyset,\set{\x},\setnodes}$ after the update.
As expected, the inset of $\y$ decreases by up to $\aks$---we do not know the exact loss, and we do not care.
Consequently, the invariant of $\y$ breaks because it may no longer receive its key $\akey_\y$ in its inset.
The subsequent actions will reestablish the invariant for $\y$.
Overall, we arrive at the postcondition on \cref{code:complex-remove:footprint-post-move}.

\Cref{code:complex-remove:del-x,code:complex-remove:del-y} finalizes the swap of $\x$ and $\y$.
The update, which does not alter the flow, is straightforward and yields $\inv{\abscontent_2,\set{\x},\setnodes}$ and $\ctnof{\y}=\emptyset$.
Finally, \cref{code:complex-remove:unlink} unlinks $\y$, as in the case for \code{removeSimple}.
Unlinking the marked $\y$ reestablishes its invariant.
We arrive at $\inv{\abscontent,\setnodes,\setnodes}$, \cref{code:complex-remove:post}, as required.
