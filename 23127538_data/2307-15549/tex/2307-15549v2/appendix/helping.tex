%!TEX root = ../main.tex
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:

\section{Contextual Reasoning about Linearizability}
\label{sec:ex-helping}

In this section, we use contextual reasoning to simplify linearizability proofs of concurrent data structure operations whose linearization points are future-dependent and potentially located in other threads.
Specifically, we will focus on linearizability proofs that use prophecy variables~\cite{DBLP:journals/pacmpl/JungLPRTDJ20,DBLP:journals/pacmpl/PatelKSW21}.
Such proofs involve \emph{helping protocols} that govern the transfer of linearizability obligations between threads.
The protocol is encoded using a \emph{registry} consisting of per-thread ghost state.
When a thread linearizes its own operation, it may at the same time linearize an unbounded number of operations executed by concurrent threads.
This leads to an unbounded ghost footprint at the linearization point due to the induced updates on the registry for all linearized operations.
We show that the registry can be moved to the context of the proof and that the invariant of the helping protocol can be obtained by approximate ghost updates on the context.

Concretely, we demonstrate the key ideas of the construction by revisiting the linearizability proofs for multicopy structures developed in~\cite{DBLP:journals/pacmpl/PatelKSW21}.
A multicopy structure is a concurrent data structure that implements a (total) map $M$ from keys $K$ to values $V$.
(We assume a dedicated \emph{tombstone} value $\tombstone \in V$ that indicates the absence of an entry for a key $k \in K$ in $M$.)
The data structure supports two types of operations: \code{search(k)} retrieves the value associated with $k$ in $M$ and \code{upsert(k,v)} updates the value of $k$ in $M$ to the new value $v$.
We represent the data structure state using an abstract predicate $\mcslstate(M)$. So the goal is to prove that the operations are linearizable subject to the following sequential specification:
\begin{align*}
  & \hoareof{\mcslstate(M)}{\mcode{search}(k)}{\mcode{$v$}.\; \mcslstate(M) * M(k)=v}\\
  & \hoareof{\mcslstate(M)}{\mcode{upsert}(k,v)}{\mcslstate(M[k \mapsto v])}
\end{align*}
Conceptually, a multicopy structure consists of an in-memory data structure and an on-disk data structure.
Upserts update the in-memory component, leaving the on-disk component unchanged. Concurrent maintenance operations periodically move entries from memory to disk.
Search operations first try to find an entry for $k$ in memory. Only if no entry is found in memory do they continue their search in the slower disk component.
The disk component can itself be organized as a linked structure consisting of log files, each of which may contain an old value for a key $k$.
The important observation is that the spatial organization of the pairs $(k,v)$ for a key $k$ in a multicopy structure is consistent with the temporal order in which these pairs have been upserted.
Consequently, we can use the history $h$ of key/value pairs that have been upserted thus far as an intermediate abstraction of the data structure's physical state. The key aspects of the linearizability proof can be carried out at this level of abstraction.

Formally, a history $h$ is given by
\[h \in \Hist \defeq (K \times V)^* \enspace.\]
We can then compute the map $M$ as a function of the current history $h \in \Hist$:
\begin{align*}
  M(\varepsilon) = \; & \lambda k.\; \tombstone\\
  M((k',v) \cdot h) = \; & \lambda k.\; \ite{k = k'}{v}{M(h)(k)}\enspace.
\end{align*}

We focus on the linearizability proof of search threads. A thread executing \code{search($k$)} may return a value $v$ that must have been either $M(h)(k)$ for the history $h$ when the search started, or some \code{upsert($k$,$v$)} operation linearized during the execution of the search. In the first case, the linearization point of \code{search($k$)} is right at the start of the operation. In the second case, its linearization point coincides with the linearization point of the interfering \code{upsert($k$,$v$)} thread. 

To enable thread modular reasoning about linearizability, the proof maintains a ghost state component in the shared state that consists of a registry $R$. The registry is a partial map from the thread IDs of all active search threads to their \emph{linearizability status}. These are values in the set:
\[\Status ::= \anobl{h,k,v} \mid \aful{h,k,v} \mid \aslt{h,k,v}\enspace.\]
Status $\anobl{h,k,v}$ indicates that (i) the thread started its search when the history was $h$, (ii) it is searching for key $k$, (iii) it will return value $v$, and (iv) it still has the obligation to linearize. Status $\aful{h,k,v}$ is similar but indicates that the thread has fulfilled its obligation to linearize. Finally, status $\aslt{h,k,v}$ only tracks properties (i) to (iii) without indicating whether the thread has linearized or not. Note that the choice of the return value $v$ is implemented using a prophecy variable. We elide these details here.

We endow $\Status$ with a separation algebra structure by letting $\aslt{h,k,v}$ be the unit of  $\aslt{h,k,v}$, $\anobl{h,k,v}$, and $\aful{h,k,v}$ for all $h$, $k$, and $v$, and leaving the multiplication undefined in all other cases. We lift this multiplication to registries $R$ pointwise in the canonical way.

The separation algebra used for the proof is then given by the product algebra:
\begin{align*}
\Sigma \defeq \; & \setcond{(h,R)}{\forall \tid \in \domof{R}. \; \Valid(h,R(\tid))}\\
\text{where} \quad
\Valid(h,s(h',k,v)) \defeq \; & s \neq \slt \Rightarrow h \geq h' \land (s=\obl \Leftrightarrow  \latest(h,k,v) < |h'|)\\
\latest(\varepsilon,k,v) \defeq \; & \ite{v=\tombstone}{0}{-1}\\
\latest((k',v') \cdot h,k,v) \defeq \; & \ite{(k=k' \land v=v')}{|h|+1}{\latest(h,k,v)}\enspace.
\end{align*}
Intuitively, $\latest(h,k,v)$ is the timestamp of the latest \code{upsert($k$,$v$)} in the history $h$ (where we assume that all keys are initialized to $\tombstone$ at time 0). The constraint $h \geq h'$ expresses that $h'$ is a suffix of $h$. As we shall see, the validity condition enforces that when an \code{upsert($k$,$v$)} linearizes, it must also linearize all pending \code{search($k$)} that will return $v$. We say that $(h,R)$ is valid if it is an element of $\Sigma$.

The multiplication on the product algebra is defined as $(h_1,R_1) \mstar (h_2,R_2) \defeq (h_1,R_1 \mstar R_2)$
if $h_1=h_2$ and $R_1 \mstardef R_2$, and undefined otherwise. Observe that multiplication preserves validity.

We write $\langle h \rangle$ for the predicate $\{(h,\emptyset)\}$ and $\tid \mapsto s(h',k,v)$ for the predicate
\[\setcond{(h,\{\tid \mapsto s(h',k,v)\})}{h \in \Hist \land \Valid(h,s(h',k,v))}\enspace.\]

There is only one kind of update of the physical state: upserting a new pair $(k,v)$ by appending it to the history $h$. Let $\acom$ be the command that performs the physical update. Following the setting in \cref{sec:contextualization:semantics}, we define the semantics $\upof{\acom}{\langle h \rangle \mstar\apredppp}$ in terms of the physical update and a ghost multiplication
\[\upof{\acom}{\langle h \rangle \mstar\apredppp}\ =\ \langle (k,v) \cdot h \rangle \imult\apredppp \enspace.\]
The ghost multiplication updates the registry to reestablish validity:
\begin{align*}
 ((k,v) \cdot h, R_1)  \imult \,(h, R_2) \; & = \\
(h, R_2)  \imult \,((k,v) \cdot h, R_1) \; & \defeq ((k,v) \cdot h, R_1 \uplus (\lambda \tid \in \domof{R_2}. \; \mathit{update}(k,v,R_2(\tid)))\\
 (h, R_1)  \imult \,(h, R_2) \; & \defeq (h, R_1 \uplus R_2)
\end{align*}
where $\mathit{update}(k,v,s(h',k',v')) \defeq \ite{(k=k' \land v=v' \land s=\obl)}{\aful{h',k,v}}{s(h',k',v')}$. In all remaining cases, $\apred \imult \apredp$ is undefined.

Observe that $\upof{\acom}{\langle h \rangle \mstar\apredppp}$ has an unbounded ghost footprint because it may update the registry entries for an unbounded number of threads. Further note that when the ghost update changes a thread's status from $\anobl{h',k,v}$ to $\aful{h',k,v}$, then we have $M((k,v) \cdot h)(k)=v$, so the sequential specification of \code{search($k$)} is satisfied at this point.

Another ghost update occurs when a new \code{search($k$)} thread is spawned. In this case, the ghost state is updated by adding a registry entry $\tid \mapsto s(h,k,v)$ for a fresh thread ID $\tid$, where $h$ is the current history and $v$ is the thread's prophesied return value. If $M(h)(k)=v$ then $s$ is chosen to be $\ful$ (the thread immediately linearizes) and otherwise $s=\obl$.


When reasoning about the actual code of the \code{search} and \code{update} operations, we can now move the entire registry into the context and carry out the proof by focusing only on the physical state. This is under the assumption that the context predicate $\apredpp$ used to describe the registry is preserved under all ghost updates.

To compute an appropriate context predicate, we define an approximate ghost multiplication $\ghostabs{\apred}$ that yields the upward closure under registering new search threads and extending the history with new key value pairs, starting from $\langle \varepsilon \rangle$:
\[\ghostabs{\langle a \rangle}(\apredp) = \exists h'.\, \langle h' \rangle \mstar \bigmstar_{\tid} \exists h,k,v. \; (\tid \mapsto \anobl{h,k,v} \lor \tid \mapsto \aful{h,k,v})\enspace.\]
The left-hand side is the desired context predicate $\apredpp$.
