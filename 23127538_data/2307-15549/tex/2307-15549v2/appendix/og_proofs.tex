%!TEX root = ../main.tex

\newcommand{\clocsafe}[7]{\mathsf{safe}^{#3}_{#1, #2}(#4, #5, #6, #7)}
\newcommand{\clocsafedef}[4]{\clocsafe{\thePredicates}{\theInterference}{#1}{\acontext}{#2}{#3}{#4}}
\newcommand{\clocsafek}[3]{\clocsafedef{k}{#1}{#2}{#3}}
\newcommand{\ccfsafedef}[3]{\mathsf{cfsafe^{#1}(\acontext, #2, #3)}}
\newcommand{\ccfsafek}[2]{\ccfsafedef{k}{#1}{#2}}
\newcommand{\locsafe}[6]{\mathsf{safe}^{#3}_{#1, #2}(#4, #5, #6)}
\newcommand{\locsafedef}[4]{\locsafe{\thePredicates}{\theInterference}{#1}{#2}{#3}{#4}}
\newcommand{\locsafek}[3]{\locsafedef{k}{#1}{#2}{#3}}
\newcommand{\cfsafedef}[3]{\mathsf{cfsafe^{#1}(#2, #3)}}
\newcommand{\cfsafek}[2]{\cfsafedef{k}{#1}{#2}}


% \newcommand{\acontext}{\mathit{p}}
\newcommand{\acontextp}{\mathit{q}}


\section{Missing Details for \theLogicOG}
\label{app:og-casl}


So far we have presented context-aware reasoning in a sequential setting.
However, our proof principle also applies to the concurrent setting.
We present an Owicki-Gries-style extension for \theLogicSeq from \Cref{Section:CAReasoning}.

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Concurrent semantics}

In the concurrent setting, we assume that the underlying separation algebra $(\setstates, \mstar, \emp)$ introduced in \Cref{sec:semantics} is, in fact, a product of two separation algebras $(\setshared, \sharedmult, \sharedemp)$ and $(\setlocal, \localmult, \localemp)$.
We require $\emp= \sharedemp \times \localemp \subseteq \setstates \subseteq \setshared \times \setlocal$.
In addition, $\setstates$ must be closed under decomposition: if $(\ashared_1\sharedmult\ashared_2, \alocal_1\localmult\alocal_2) \in \setstates$ then $(\ashared_1, \alocal_1) \in \setstates$, for all $\ashared_1,\ashared_2 \in \setshared$ and $\alocal_1,\alocal_2 \in \setlocal$.
For $(\ashared, \alocal) \in \setstates$ we call $\ashared$ the \emph{global state} and $\alocal$ the \emph{local state}.
States are composed component-wise, $(\ashared_1, \alocal_1)\statemult(\ashared_2, \alocal_2)=(\ashared_1\sharedmult\ashared_2, \alocal_1\localmult\alocal_2)$, and this composition is defined only if the product is again in~$\setstates$.

The semantics of concurrent programs is defined by a transition relation among configurations.
A \emph{configuration} is a pair  $\aconfig=(\ashared, \apc)$ consisting of a global state $\ashared\in \setshared$ and a program counter $\apc:\nat\to\setlocal\times\setstmt$.
The program counter assigns to every thread, modeled as a natural number,  the current local state and the statement to be executed next.
We use $\setconfig$ to denote the set of all configurations.
A configuration $(\ashared, \apc)$ is \emph{initial} for predicate~$\apred$ and library code~$\astmt$, if the program counter of every thread yields a local state $(\alocal, \astmt)$ where the code is the given one and the state satisfies $(\ashared, \alocal)\in \apred$.
The configuration is \emph{accepting} for predicate $\apredp$, if every terminated thread  $(\alocal, \cskip)$ satisfies the predicate, $(\ashared, \alocal)\in\apredp$.
We write these configuration predicates as the following sets
\begin{align*}
	\initset{\apred}{\astmt}
		\mkern-1mu&=\mkern-1mu
		\{(\ashared, \apc) \,{\mid}\,
			\forall i,\alocal,\mkern-1mu\widehat\astmt.\mkern+2mu
				\apc(i)\prall{=}(\alocal,\mkern-1mu \widehat\astmt) \prall{\Rightarrow}
				(\ashared,\mkern-1mu \alocal)\prall{\in}\apred \prall{\wedge} \widehat\astmt\prall{=}\astmt
			\}
	\\
	\acceptset{\apredp}
		\mkern-1mu&=\mkern-1mu
		\{(\ashared, \apc) \,{\mid}\,
			\forall i,\alocal.~
			\apc(i)=(\alocal, \cskip)\Rightarrow (\ashared, \alocal)\in\apredp \,
		\}
	\ .
\end{align*}

% Figure environment removed

The transition relation among configurations is standard, see \Cref{Figure:Relations}.
A command may change the global state and the local state of the executing thread.
It will not change the local state of other threads.
A computation of the program is a finite sequence of consecutive transitions.
A configuration is reachable if there is a computation that leads to it.
We write $\reachsetof{}{\aconfig}$ for the set of all configurations reachable from $\aconfig$.

Our goal is to show $\reachsetof{}{\initset{\apred}{\astmt}}\prall{\subseteq}\acceptset{\apredp}$ with an Owicki-Gries proof principle.
If this inclusion holds, we say that the concurrent Hoare triple $\hoareof{\apred}{\astmt}{\apredp}$ is valid.
To distinguish this from the sequential case, we write $\mmodels\hoareof{\apred}{\astmt}{\apredp}$.

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{The Owicki-Gries proof principle}
As common for Owicki-Gries approaches~\cite{DBLP:journals/acta/OwickiG76}, we reason in two steps.
First, we verify the program code as if it was run by an isolated thread.
The corresponding judgments $\thePredicates,\theInterference\semcalc\hoareOf{\apred}{\astmt}{\apredp}$ collect the predicates that were used during the proof in the set $\thePredicates$ and the interferences in the set~$\theInterference$~\cite[Section 7.3]{DBLP:conf/popl/Dinsdale-YoungBGPY13}.
Second, we check interference freedom to make sure the local proof still holds in the presence of other threads.

An \emph{interference} is a pair $(\acom, \apred)$ consisting of a command and a predicate.
It represents the fact that environment threads may execute command $\acom$ when the state belongs to $\apred$.
A state $(\ashared, \alocal)$ held by the isolated thread of interest will change under the interference to a state in
\[
	\semOf{(\acom, \apred)}{\ashared, \alocal}
	~\defeq~
	\setcond{(\ashared', \alocal)}{
		\exists \alocal_1, \alocal_2.\;\; (\ashared, \alocal_1)\in \apred ~\wedge~ (\ashared', \alocal_2)\in \semof{\acom}{\ashared, \alocal_1}}
	\enspace.
\]
We consider every state $(\ashared, \alocal_1)\in \apred$ that agrees with $(\ashared, \alocal)$ on the global component, compute the post, and combine the resulting global component with the local component $\alocal$.

The thread-local proof computes a set of interferences.
We consider interference sets up to the operation of joining predicates for the same command, $\setcompact{(\acom, \apred)}\cup \setcompact{(\acom, \apredp)}=\setcompact{(\acom, \apred\cup\apredp)}$.
Then $(\acom, \apred)\subseteq \theInterference$ means there is an interference $(\acom, \apredp)\in\theInterference$ with $\apred\subseteq \apredp$.
We write $\theInterference\mstar\apredp$ for the set of interferences $(\acom, \apred\mstar\apredp)$ with $(\acom, \apred)\in\theInterference$, and similarly for the set of predicates $\thePredicates$.

The \emph{interference-freedom check} takes as input a set of interferences $\theInterference$ and a set of predicates $\thePredicates$.
It checks that no interference can invalidate a predicate, $\semOf{(\acom, \apredp)}{\apred}\subseteq \apred$ for all $(\acom, \apredp)\in\theInterference$ and all $\apred\in\thePredicates$.
If this is the case, we write $\isInterferenceFreeOf[\theInterference]{\thePredicates}$ and say that $\thePredicates$ is interference-free wrt. $\theInterference$.

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{An Owicki-Gries program logic}
We reason about the validity of concurrent Hoare triples with the program logic from \Cref{fig:og-rules} (ignore the \makeColorLogic{blue} parts for now).
We write $\thePredicates, \theInterference\semcalc\hoareof{\apred}{\astmt}{\apredp}$ if the corresponding judgement can be derived using the rules from \Cref{fig:og-rules}.
This Owicki-Gries program logic is sound \cite{DBLP:journals/pacmpl/MeyerWW22}.

\begin{theorem}
	$\thePredicates, \theInterference\semcalc\hoareof{\apred}{\astmt}{\apredp}$
	and
	${}\isInterferenceFreeOf[\theInterference]{\thePredicates}$
	and
	$\apred\in\thePredicates$
	imply
	${}\mmodels\hoareof{\apred}{\astmt}{\apredp}$.
\end{theorem}
\begin{proof}
	See proof of \Cref{thm:soundness-OG}.
\end{proof}

% Figure environment removed

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{A context-aware extension.}
Similar to \Cref{Section:CAReasoning}, the context-aware version of concurrent Hoare triples takes the form $\choareof{\acontext}{\apred}{\astmt}{\apredp}$ with the understanding that $\acontext$ is meant to be framed to the pre- and postcondition.
That is, validity $\mmodels\choareof{\acontext}{\apred}{\astmt}{\apredp}$ holds iff $\mmodels\hoareof{\apred\mstar\acontext}{\astmt}{\apredp\mstar\acontext}$.
The extended program logic is given in \Cref{fig:og-rules} (including the \makeColorLogic{blue} parts) and involves statements of the form $\thePredicates, \theInterference\semcalc\choareof{\acontext}{\apred}{\astmt}{\apredp}$.
This extension, called \theLogicOG, is sound.

\begin{theorem}
	$\thePredicates, \theInterference\semcalc\choareof{\acontext}{\apred}{\astmt}{\apredp}$
	and
	${}\isInterferenceFreeOf[\theInterference]{\thePredicates}$
	and
	$\apred\in\thePredicates$
	imply
	${}\mmodels\choareof{\acontext}{\apred}{\astmt}{\apredp}$.
\end{theorem}
\begin{proof}
	See proof of \Cref{thm:soundness-OGCASL}.
\end{proof}

Note that we did not adapt the interference-freedom check for our extension.
It still applies the standard semantics $\sem{\acom}$.
Our results from \Cref{Section:CAReasoning} apply to this check as well in the sense that one can use contextualize some predicate $\acontext$ and then apply the induced semantics $\icasem{\acom}{\acontext}$ instead of $\sem{\acom}$.
We consider this an implementation detail of how to perform the interference-freedom check and elide the straightforward technicalities that would be required to record the context in which an interference is recorded in order to apply it for the check.


