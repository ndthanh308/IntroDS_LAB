%!TEX root = ../../main.tex

\subsection{Simple Removals}
\label{sec:bst:remove-simple}

Operation \code{removeSimple} physically removes (unlinks) nodes that have been marked as deleted.
It is a ``simple'' removal because it unlinks nodes only if they have at most one child.
To satisfy the specification of \code{maintenance}, \code{removeSimple} must leave the logical contents of the tree unchanged.

\input{content/example/fig_simple}

The implementation and proof outline of \code{removeSimple} are given in \cref{fig:simple-removal:impl}.
It proceeds as follows.
Starting from an arbitrary node $\x$ currently linked into the tree, the left child $\y$ of $\x$ is read out.
If $\y$ is a non-null marked node with at most one child, \code{removeSimple} unlinks $\y$.
We focus on the case where $\y$ has no left child.
Then, it is unlinked by making $\y$'s right child the left child of $\x$, i.e., by updating $\selof{\x}{left}$ to $\rightof{\y}$ on \cref{code:simple-remove:unlink}.
\Cref{fig:simple-removal:prestate,fig:simple-removal:poststate} illustrate the pre- and post-state of the update for the part of the tree rooted in $\x$.
The \colorbg{backgroundFootprint}{footprint} of the physical unlinking contains just the nodes $\x$ and $\y$.
The proof for the update of the footprint is as expected because it is readily checked that the invariant is maintained for nodes $\x$ and $\y$.
This is the transition from \cref{code:simple-remove:pre-footprint} to \cref{code:simple-remove:post-footprint}.

The accompanying ghost update, however, is unbounded, it oozes into the right subtree $A$ of $\y$.
Coming back to \cref{fig:simple-removal:prestate,fig:simple-removal:poststate}, let $\ais=\isof{\x}\neq\bot$ be the inset of $\x$.
Before the update, $A$-bound searches follow the edges $\leftof{\x}$ and $\rightof{\y}$.
That is, the inset of $A$ is $\ais\cap(\keyof{\y},\keyof{\x})$.
After the update $\y$ is skipped, the inset of $A$ is $\ais\cap[-\infty,\keyof{x})$.
Because the keys in $A$ are larger than $\keyof{\y}$, the additional inset $\ais\cap[-\infty,\keyof{\y}]$ after the update is forwarded to the left-most leaf in $A$.
That is, the ghost footprint is unbounded, the \ruleref{frame} rule does not apply.

The \ruleref{context} rule, however, does apply.
We have already seen that $\simplerel$ is an estimator that captures updates to the tree that increase the inset of reachable nodes, like the one we have here.
The invariant is $\simplerel$-closed because the inset/keyset occurs only on the right-hand sight of inclusions, the inset of unreachable nodes remains $\bot$, and no node's inset becomes $\top$.
That is, we can \colorbg{backgroundContext}{contextualize} everything outside the footprint $\set{\x,\y}$.
This is the annotation on \cref{code:simple-remove:context}.

Altogether, $\choareof{\set{\text{\Cref{code:simple-remove:context}}}}{\text{\Cref{code:simple-remove:pre-footprint}}}{\text{\Cref{code:simple-remove:unlink}}}{\text{\Cref{code:simple-remove:post-footprint}}}$ is a valid CASL statement.
Rule \ruleref{context} thus yields $\choareof{\emp}{\text{\Cref{code:simple-remove:pre}}}{\text{\Cref{code:simple-remove:unlink}}}{\text{\Cref{code:simple-remove:post}}}$ and by relative soundness this is a valid statement in classical separation logic.
That is, \code{removeSimple} does not alter the logical contents of the tree.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
