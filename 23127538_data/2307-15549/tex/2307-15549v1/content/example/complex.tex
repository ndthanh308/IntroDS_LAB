%!TEX root = ../../main.tex

\subsection{Complex Removals}
\label{sec:bst:remove-complex}

Operation \code{removeComplex} unlinks marked nodes that have two children, without changing the logical contents of the tree.
\Cref{fig:complex-removal} gives the implementation and proof outline.
There are four steps in \code{removeComplex}.
First, it obtains a reachable, marked node $\x$ with two children.
Second, it uses the helper \code{findSucc} to find the left-most leaf $\y$ and its parent $\p$ in the subtree $B$ rooted at $\x$'s right child.
The helper implementation and proof are straight-forward, we defer it to \cref{app:bst-rotate} due to space constraints.
To avoid distracting case distinctions, we assume $\p\neq\x$.
Third, the contents of $\x$ and $\y$ are swapped, \crefrange{code:complex-remove:move}{code:complex-remove:del-y}.
This is the most interesting part and we discuss it below.
Last, $\y$ is unlinked.
The unlinking is as in \code{removeSimple} because $\y$ has at most one child.

\input{content/example/fig_complex}

We turn the discussion to the third step.
To avoid confusion between the values of fields before and after the following updates, we record the values $\akey_\x=\keyof{\x}$, $\akey_\y=\keyof{\y}$, and $\ais=\isof{\x}$ from before the update, as on \cref{code:complex-remove:pre}.
Note that $\akey_\x<\akey_\y$.
Now, \cref{code:complex-remove:move} copies $\akey_\y$ into $\x$.
This is challenging due to its intricate unbounded flow footprint, which is visualized in \cref{fig:complex-removal:prestate,fig:complex-removal:poststate}.
The update increases the inset of $\x$'s left subtree $A$ from $\ais\cap[-\infty,\akey_\x)$ to $\ais\cap[-\infty,\akey_\y)$.
The inset of $\x$'s right subtree $B$, in turn, decreases from $\ais\cap(\akey_\x,\infty]$ to $\ais\cap(\akey_\y,\infty]$.
That is, the portion $\aks=\ais\cap(\akey_\x,\akey_\y]\subseteq\ksof{\y}$ is redirected from $B$ to $A$.
The estimator $\complexrel$ defined by \[
  \amonval\complexrel\amonvalp
  ~~\defifff~~
    \amonval\simplerel\amonvalp
    \,~\lor~
    \bigl(\,
      \setc{\amonval,\amonvalp}\cap\setc{\bot,\top}=\emptyset ~\land~ \akey_\x\notin\amonval ~\land~ \amonval\setminus\aks\subseteq\amonvalp
    \,\bigr)
\]
captures that insets may
\begin{inparaenum}
	\item increase arbitrarily, or
	\item decrease by up to $\aks$, if they do not contain $\akey_\x$.
\end{inparaenum}
The side condition localizes the decrease to the subtrees of $\x$.

For handling the update, we choose nodes $\x$ and $\y$ as the footprint and contextualize everything else.
Technically, the context is $\inv{\abscontent_1,\setnodes\setminus\set{\x,\y},\setnodes}$ and the footprint is $\inv{\abscontent_2,\set{\x,\y},\setnodes}$ with $\abscontent=\abscontent_1\cup\abscontent_2$.
The main challenge is to show that the context is $\complexrel$-closed, in particular, tolerates reduced insets.
To that end, consider a node $\z\in\setnodes\setminus\set{\x,\y}$ with $\isof{\y}\neq\bot$.
By the invariant, $\keyof{\z}\in\isof{\z}$.
To preserve this inclusion, we are obliged to show $\keyof{\z}\notin\aks$.
Because $\aks\subseteq\ksof{\y}$ and $\keyof{\z}\in\ksof{\z}$, it suffices to show $\ksof{\y}\cap\ksof{\z}=\emptyset$.
This follows from a result due to \citet{DBLP:journals/tods/ShashaG88}, which states that the keyset of all nodes are pairwise disjoint if all searches are deterministic and start in a dedicated root node.\footnote{%
	We could encode this into the invariant $\invraw$ using the keyset algebra proposed in~\cite{DBLP:conf/pldi/KrishnaPSW20}, but refrain from the added complexity for clarity of the exposition.
}
Since the requirements are satisfied in our setting, the result applies and discharges our proof obligation.
Overall, the context $\inv{\abscontent_1,\setnodes\setminus\set{\x,\y},\setnodes}$ on \cref{code:complex-remove:ctx} is $\complexrel$-closed.

We turn to the footprint $\inv{\abscontent_2,\set{\x,\y},\setnodes}$, \cref{code:complex-remove:footprint-pre}.
The physical update changing $\selof{\x}{key}$ from $\akey_\x$ to $\akey_\y$ is as expected.
\Cref{thm:contextualization} prescribes that the footprint be $\complexrel$-closed after the update.
Because $\akey_\x,\akey_\y\in\ais$ prior to the update, $\complexrel$ does not remove $\akey_\y$ from the inset of $\x$.
Together with $\delof{\x}$, we have $\inv{\emptyset,\set{\x},\setnodes}$ after the update.
As expected, the inset of $\y$ decreases by up to $\aks$---we do not know the exact loss, and we do not care.
Consequently, the invariant of $\y$ breaks because it may no longer receive its key $\akey_\y$ in its inset.
The subsequent actions will reestablish the invariant for $\y$.
Overall, we arrive at the postcondition on \cref{code:complex-remove:footprint-post-move}.

\Cref{code:complex-remove:del-x,code:complex-remove:del-y} finalizes the swap of $\x$ and $\y$.
The update, which does not alter the flow, is straight forward and yields $\inv{\abscontent_2,\set{\x},\setnodes}$ and $\ctnof{\y}=\emptyset$.
Finally, \cref{code:complex-remove:unlink} unlinks $\y$, as in the case for \code{removeSimple}.
Unlinking the marked $\y$ reestablishes its invariant.
We arrive at $\inv{\abscontent,\setnodes,\setnodes}$, \cref{code:complex-remove:post}, as required.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../main"
%%% End:
