%!TEX root = ../main.tex

\newcommand{\internal}{\scalebox{0.9}{$\mathghost$}}
\newcommand{\cor}{\mathop{\sim}}
\newcommand{\imult}{\mathop{{\internal}}}
\newcommand{\imultdef}{\mathop{\#_{\scalebox{.7}{\internal}}}}
\newcommand{\paraleq}[1]{\mathop{\preceq_{#1}}}
\newcommand{\paraclof}[2]{#1\!\uparrow_{#2}}
\newcommand{\ileq}{\mathop{<_{\internal}}}

\newcommand{\funs}{\contfunof{\amonoid}}
\newcommand{\discup}{\uplus}
\newcommand{\setflowgraphs}{\mathsf{FG}}

\newcommand{\astatex}{\mathsf{x}}
\newcommand{\astatey}{\mathsf{y}}

\newcommand{\abssem}[1]{\sem{#1}^{\#}}
\newcommand{\abssemof}[2]{\abssem{#1}(#2)}

\newcommand{\phyabs}{\mathop {\rightarrow^{\footnotesize\sharp}}}

\newcommand{\ghostconc}[1]{[\imult #1]}
\newcommand{\ghostconcof}[2]{\ghostconc{#1}(#2)}
\newcommand{\ghostabs}[1]{\ghostconc{#1}^{\sharp}}
\newcommand{\ghostabsof}[2]{\ghostabs{#1}(#2)}

\newcommand{\absimult}{\mathop{{{\internal}}^{\sharp}}}

\newcommand{\vertin}{\rotatebox{270}{$\!\!\!\in$}}
\newcommand{\verteq}{\rotatebox{90}{$=$}}

\newcommand{\up}[1]{\mathop{[#1]}}
\newcommand{\upof}[2]{\up{#1}(#2)}
\newcommand{\absup}[1]{\mathop{[#1]^{\sharp}}}
\newcommand{\absupof}[2]{\absup{#1}(#2)}



\section{Contextualization}
\label{sec:contextualization}
The purpose of rule \ruleref{context} is to frame out predicates that are invariant under the command of interest.  
If $\semof{\acom}{\apred\mstar\apredpp}=\apredp\mstar\apredpp$, then \cref{Proposition:CompletenessInducedSemantics} allows us to derive:
\begin{align*}
		\ruleref{com}\inferrule{
			\phantom{.................}\icasemof{\acom}{\apredpp}{\apred}\predleq \apredp
		}{
		\ruleref{context}\inferrule{
		  \choareOf{\apredpp}{\astate}{\acom}{\apredp}
		}{
		  \choareOf{\emp}{\apred\mstar\apredpp}{\acom}{\apredp\mstar\apredpp}
		}	
		}		
\end{align*}
But how does one determine predicates that are guaranteed to be invariant under the command?
This is the problem we address next:
\begin{quote}
\underline{Contextualization}\\
Given: $\semof{\acom}{\apred\mstar\apredppp}$. \\
Determine: Predicates $\apredp$ and $\apredpp$ with $\apredppp\predleq\apredpp$ so that $\semof{\acom}{\apred\mstar\apredpp}\predleq \apredp\mstar\apredpp$. 
\end{quote}
Of course the predicates $\apredp$ and $\apredpp$ should be made as precise as possible. 
In analogy to the term framing, we say we \emph{contextualize} $\apredppp$. 
We solve this problem in a setting that is specific enough to provide helpful assumptions, yet general enough to cover frameworks like flows~\cite{DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23}
and ghost state induced by morphisms~\cite{DBLP:journals/pacmpl/Nanevski0DF19}. 
% -----------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------
\subsection{Semantics}
\label{sec:contextualization:semantics}

The motivation for contextualization stems from the fact that the states in $\apredppp$ can be large. 
%
In the example from \cref{sec:motivation}, these states are full subtrees. 
%
It is worth having a closer look at what forces us to maintain full subtrees.
%
The Hoare triple of interest is:
\begin{lstlisting}[language=SPL,numbers=none,style=codeInline,keywords={free}]
  $\annot{
    \anode \pointsto (l,r,k) \MSTAR p \pointsto (\anodep,\anodepp,i) \MSTAR \anodep \pointsto (\pnull, \anodeppp, j)\MSTAR \apredppp
  }$ $\Rightarrow \treepred(x,\contents)$
  $\anode$.$\key$ := $\anodep$.$\key$; $p$.$\lchild$ := $\anodep$.$\rchild$; free(y);
  $\annot{
    \anode \pointsto (l,r,j) \MSTAR p \pointsto (\anodeppp,\anodepp,i) \MSTAR \apredppp'
  }$ $\Rightarrow \treepred(x,\contents\setminus\set{k})$
\end{lstlisting}
The update modifies a pointer of $p$, the key of $\anode$, and deallocates $\anodep$. 
%
This is the change on $\apred$. 
%
However, it also has an effect on the subtree rooted at $r$ (without $p$ as the node belongs to $\apred$). 
%
We are interested in the contents of this subtree, the set of keys of all nodes reachable from the root. 
%
While the subtree does not change physically, the modification of the contents changes $\apredppp$. 
%
In short, while the physical modification involves only few nodes, it influences the ghost state associated with a whole set of nodes.
%
The phenomenon is independent of the formalism we use to describe states, be it recursive predicates, flow graphs, or morphisms.

To capture the fact that an update involves a modification of the physical state and a modification of the ghost state, we assume the semantics of commands is defined as: 
\begin{align*}
\semof{\acom}{\apred\mstar\apredppp}\  =\ \upof{\acom}{\apred\mstar\apredppp}\quad\text{and}\qquad \upof{\acom}{\apred\mstar\apredppp}\ =\ \upof{\acom}{\apred}\imult\apredppp\quad \text{if }\upof{\acom}{\apred}\neq\abort. 
\end{align*}
Here, $\up{\acom}$ is a predicate transformer that implements the physical update. 
It satisfies a condition similar to \eqref{Equation:Locality}, except that the ordinary multiplication $\mstar$ is replaced by a ghost multiplication $\imult$ modifying the ghost state. 
The ghost multiplication is a second partial operation on the separation algebra, which we now write as $(\setstates, \mstar, \imult, \emp)$. 
The ghost multiplication is commutative and associative, but we neither need to assume cancellativity nor the existence of units. 
We lift the ghost multiplication to predicates in the expected way: $\apred\imult\apredp=\setcond{\astate\imult\astatep}{\astate\in\apred\wedge \astatep\in\apredp\wedge \astate\imultdef\astatep}$ and $\abort\imult\apred=\abort=\apred\imult\abort$. 
We make the assumption that the result of a ghost multiplication decomposes uniquely as follows. 
For $\apred_1, \apred_2\subseteq\setstates$ with $\apred_1\imult\apred_2=\apredp$, there are unique smallest predicates $\apredp_1, \apredp_2$ with $\apredp_1\mstar\apredp_2=\apredp$ so that $\apredp_1$ corresponds to $\apred_1$ and $\apredp_2$ corresponds to $\apred_2$.
Correspondence abstracts the idea of having the same set of nodes. 
It is formalized as an equivalence on states, which we have suppressed as we do not need it beyond this unique decomposition requirement. 

In the example and before the update, the ghost multiplication propagates $\set{i}\cup C_y$ to the subtree at $r$. 
After the update, it only propagates $i$. 
The use of a ghost multiplication is inspired by the morphism framework in \cite{DBLP:journals/pacmpl/FarkaN0DF21} where the separation algebra of states $\Sigma$ is mapped to a separation algebra of ghost states  $\Gamma$ that has its own multiplication.  
We stay within one separation algebra, which can be thought of as $\Sigma\times\Gamma$, and assume to inherit the second multiplication. 
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------

We now solve contextualization in this abstract setting.  
In the next section, we show how to instantiate the solution to flow graphs, the separation algebra we chose for our proofs. 
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------
% ---------------------------------------------------------------------------------
\subsection{Solution} 
We approach contextualization by abstract interpretation: we give an approximate semantics for the commands from which we can construct the desired predicates. 
One particularity of our approach is that we do not want to devise an abstract domain but wish to stay in the realm of separation logic where the algebraic framework is well-developed. 
Another particularity is that the semantics of commands consist of a physical and a ghost update, which we both have to approximate. 

We mimic the physical update by an \emph{approximate physical update} $\absup{\acom}$. 
%
Like the physical update, it should be a predicate transformer that satisfies $\absupof{\acom}{\apred\mstar\apredppp}=\absupof{\acom}{\apred}\imult\apredppp$ if $\absupof{\acom}{\apred}\neq\abort$. 
%
We also expect soundness, $\upof{\acom}{\apred}\predleq\absupof{\acom}{\apred}$. 


To mimic the ghost update, observe that the ghost multiplication induces a family of predicate transformers $\ghostconc{\apred}$ that capture the effect of the ghost multiplication on the first operand when the second operand is fixed to be~$\apred$. 
For $\apred, \apredppp\subseteq\setstates$, we define $\ghostconcof{\apred}{\apredppp}=\apredppp'$, if $\apredppp\imult\apred=\apredppp'\mstar\apred'$ is the unique decomposition. 
This can be understood as currying, then a partial instantiation, and finally a masking of the result. 
For $\apred=\abort$ or $\apredppp=\abort$, we define $\ghostconcof{\apred}{\apredppp}=\abort$. 
It is worth noting that these functions capture the ghost multiplication without loss of information: $\apredppp\imult\apred=\ghostconcof{\apred}{\apredppp}\mstar \ghostconcof{\apredppp}{\apred}$. 
To define the predicates we are after, it will be beneficial to approximate this family rather than the multiplication operator.  

An \emph{approximate ghost multiplication} is a family of predicate transformers $\ghostabs{\apred}$. 
We now proceed the other way around and use the family to define $\apred\absimult\apredppp=\ghostabsof{\apredppp}{\apred}\mstar\ghostabsof{\apred}{\apredppp}$. 
Again, we expect soundness, $\apred\imult\apredppp\predleq\apred\absimult\apredppp$. 


With the approximate physical and ghost updates in place, we can now determine the predicates we are after. 
With $\apred'=\absupof{\acom}{\apred}$, we define: 
\begin{alignat*}{5}
\apredpp\ &=\ \rho^*(\apredppp)\qquad&\text{with}\qquad\rho\ &=\ \ghostabs{\apred'}\\
\apredp\ &=\ \sigma(\apred')\qquad&\text{with}\qquad\sigma\ &= \ghostabs{\apredpp}. 
\end{alignat*}
Recall that, by assumption, $\ghostabs{\apred'}$ is a predicate transformer (i.e., strict and a complete join morphism). Hence, the reflexive transitive closure $\rho^* = \lfpof{(\lambda f.\, \mathit{id} \predtransjoin \rho \circ f)}$ is well-defined.

\begin{theorem}\label{thm:contextualization}
Consider $\semof{\acom}{\apred\mstar\apredppp}$. 
Then $\semof{\acom}{\apred\mstar\apredpp}\predleq\apredp\mstar\apredpp$ and $\apredppp\predleq\apredpp$. 
\end{theorem}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
Note that $\apredpp$ as just defined has to be precise in order to invoke \cref{Proposition:CompletenessInducedSemantics}. 
As we will see in the next section, this will typically hold if $\apredppp$ is precise.  
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{proof}
As $\apredpp$ is a reflexive and transitive closure of $\apredppp$, we have $\apredppp\predleq\apredpp$. 
It thus remains to prove $\semof{\acom}{\apred\mstar\apredpp}\predleq\apredp\mstar\apredpp$. 
The interesting case is $\apredp\neq\abort\neq\apredpp$. 
Then also $\apred'\neq\abort$ and we have 
\begin{align*}
&\ \semof{\acom}{\apred\mstar\apredpp}\\
\explain{$\upof{\acom}{\apred}\neq \abort$ by soundness of $\absup{\acom}$ and $\apred'\neq\abort$}=&\ \upof{\acom}{\apred}\imult\apredpp\\
\explain{Soundness of $\absup{\acom}$}\predleq&\ \absupof{\acom}{\apred}\imult\apredpp\\
\explain{Soundness of $\absimult$}\predleq&\ \absupof{\acom}{\apred}\absimult\apredpp\\
\explain{Definition of $\apred'$}=&\ \apred'\absimult\apredpp\\
\explain{Definition of $\absimult$}=&\ \ghostabsof{\apredpp}{\apred'}\mstar\ghostabsof{\apred'}{\apredpp}\\
\explain{Definition of $\apredp$ and $\rho$}=&\ \apredp\mstar\rho(\apredpp)\\
\explain{Definition of $\apredpp$}\predleq&\ \apredp\mstar\apredpp. \qedhere
\end{align*}
\end{proof}
It is worth noting that we only lose precision in the approximations and in the transitive closure. 
The transitive closure seems to be unavoidable to make $\apredpp$ invariant under the command. 
The physical update is often deterministic and does not need approximation.
Hence, the only parameter worth tuning is the precision of the approximate ghost multiplication.  


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
