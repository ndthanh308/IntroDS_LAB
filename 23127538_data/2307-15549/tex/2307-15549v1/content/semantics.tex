%!TEX root = ../main.tex

\newcommand{\astatepp}{\mathsf{u}}
\newcommand{\astateppp}{\mathsf{v}}
\newcommand{\arel}{\mathit{R}}
\newcommand{\arelof}[1]{\arel(#1)}
\newcommand{\arelp}{\mathit{S}}
\newcommand{\arelpof}[1]{\arelp(#1)}
\newcommand{\arelpp}{\mathit{T}}
\newcommand{\arelppof}[1]{\arelpp(#1)}
\newcommand{\acontextrelof}[2]{\arel_{#1}(#2)}
\newcommand{\abort}{\top}
\newcommand{\footprintsof}[1]{\textit{fp}(#1)}
%\renewcommand{\astmt}{\mathit{S}}
\newcommand{\setpreds}{\mathsf{Preds}(\setstates)}
\newcommand{\setlocacts}{\mathsf{LActs}(\setstates)}
\newcommand{\predleq}{\sqsubseteq}
\newcommand{\predjoin}{\sqcup}
\newcommand{\predmeet}{\sqcap}
\newcommand{\bigpredjoin}{\bigsqcup}
\newcommand{\bigpredmeet}{\bigsqcap}
\newcommand{\predtransleq}{\mathrel{\dot\predleq}}
\newcommand{\predtransjoin}{\mathop{\dot\sqcup}}
\newcommand{\bigpredtransjoin}{\dot\bigsqcup}
%\renewcommand{\choiceof}[2]{#1\ \locactjoin\ #2}

\renewcommand{\highlight}[1]{\textcolor{blue}{#1}}
\newcommand{\makeColorLogic}[1]{\textcolor{blue}{#1}}
\newcommand{\makeColorLogicDep}[1]{\textcolor{red}{#1}}

\newcommand{\hoareOf}[3]{\hoareof{#1}{#2}{#3}}
\newcommand{\choareOf}[4]{\choareof{#1}{#2}{#3}{#4}}
\newcommand{\choareHighOf}[4]{\chhoareof{#1}{#2}{#3}{#4}}



\newcommand{\aprecond}{\mathit{p}}
\newcommand{\apostcond}{\mathit{q}}


\newcommand{\setcom}{\mathtt{COM}}

\newcommand{\setpredtrans}{\mathsf{PT}(\setstates)}
\newcommand{\setcapredtrans}{\mathsf{CAPT}(\setstates)}
\newcommand{\capredtransleq}{\ddot\sqsubseteq}
\newcommand{\capredtransjoin}{\ddot\sqcup}
\newcommand{\bigcapredtransjoin}{\ddot\bigsqcup}

\newcommand{\casem}[2]{\sem{#1}_{#2}}
\newcommand{\casemof}[3]{\casem{#1}{#2}(#3)}
\newcommand{\argument}[1]{\set{\text{#1}}}
\newcommand{\icasem}[2]{\sem{#1}_{#2}^{\mathit{i}}}
\newcommand{\icasemof}[3]{\icasem{#1}{#2}(#3)}

\newcommand{\overapprox}{\textsf{over}}
\newcommand{\overapproxof}[3]{\overapprox(\icasemof{#1}{#2}{#3})}

\newcommand{\asetpreds}{\mathit{P}}

\newcommand{\iris}{\textsf{IRIS}}

\newcommand{\sizeof}[1]{|#1|}

\section{Semantics}
\label{sec:semantics}
We briefly recall the setup of abstract separation logic~\cite{DBLP:conf/lics/CalcagnoOY07} which we adapt slightly as a basis for our formal development.

A separation algebra $(\setstates, \mstar, \emp)$ is a commutative monoid in which the multiplication $\mstar$ is only partially defined, it is cancellative, and we have a set of units $\emp$. 
By cancellativity, we mean that if $\astate_1\mstar\astatep$ and $\astate_2\mstar\astatep$ are both defined and $\astate_1\mstar\astatep=\astate_2\mstar\astatep$, then $\astate_1=\astate_2$ follows. 
For every state $\astate\in\setstates$, we require that there is a unit $\munit\in\emp$ with $\astate\mstar\munit=\astate$. 
Moreover, for every pair of units $\munit\neq \munit'$ in $\emp$, we expect that the multiplication is undefined. 
We use $\astate\statemultdef\astatep$ to denote definedness of the multiplication. 


Predicates in the set $\setpreds=\powerset{\setstates}\cup\set{\abort}$ are sets of states or a dedicated symbol~$\abort$ that indicates a failure of a computation. 
We extend the multiplication to predicates, then called separating conjunction, by defining $\apred\mstar \apredp=\setcond{\astate\mstar\astatep}{\astate\in\apred\wedge \astatep\in\apredp\wedge \astate\statemultdef\astatep}$ for $\apred, \apredp\subseteq\setstates$ and $\apred\mstar\abort=\abort\mstar\apred=\abort$ for $\apred\in\setpreds$. 
We endow predicates with an ordering that coincides with inclusion on sets of states and has $\abort$ as the top element: $\apred\predleq\apredp$ if $\apred, \apredp\subseteq\setstates$ and~$\apred\subseteq\apredp$, and $\apred\predleq\abort$ for all $\apred\in\setpreds$. 
Then $(\setpreds, \predleq)$ is a complete lattice and we use~$\bigpredjoin\asetpreds$ to denote the least upper bound, or simply join, of a set of predicates $\asetpreds\subseteq\setpreds$. 

We say $\apred \subseteq \setstates$ is \emph{precise} if it identifies unique substates: for every $\astate \in \setstates$ there exists at most one $\astatep \in \apred$ such that $\astate \in \{\astatep\} \mstar \setstates$.

We define our programming language parametric in a set of commands $\setcom$. 
The set is expected to come with a semantics 
\begin{align*}
\sem{-}: \setcom\rightarrow \setpredtrans
\end{align*}
that assigns to each $\acom\in\setcom$ a predicate transformer $\sem{\acom}\in\setpredtrans$. 
The predicate transformers used in separation logic are functions $\sem{\acom}:\setpreds\rightarrow\setpreds$ that satisfy $\semof{\acom}{\abort}=\abort$ and $\semof{\acom}{\bigpredjoin\asetpreds}=\bigpredjoin \semof{\acom}{\asetpreds}=\bigpredjoin\setcond{\semof{\acom}{\apred}}{\apred\in\asetpreds}$ for all $\asetpreds\subseteq\setpreds$. 
They are strict in $\abort$ and distribute over arbitrary joins.  
With a pointwise lifting of the ordering on predicates, predicate transformers form a complete lattice $(\setpredtrans, \predtransleq)$ as well. 

We consider sequential while-programs over $\setcom$ of the form
\begin{align*}
\astmt\quad \defebnf\quad \acom\bnf\choiceof{\astmt_1}{\astmt_2}\bnf\seqof{\astmt_1}{\astmt_2}\bnf{\loopof{\astmt}} \enspace.
\end{align*}
Programs also have a semantics in terms of predicate transformers that is derived from the semantics of commands. 
The non-deterministic choice is the join, $\sem{\choiceof{\astmt_1}{\astmt_2}}=\sem{\astmt_1}\predtransjoin\sem{\astmt_2}$, the composition is function composition, $\sem{\seqof{\astmt_1}{\astmt_2}}=\sem{\astmt_2}\circ\sem{\astmt_1}$, and the semantics of iteration is $\sem{\loopof{\astmt}}=\bigpredtransjoin_{i\in\nat}\sem{\astmt^i}$ with $\sem{\astmt^0}$ being the identity and $\sem{\astmt^{i+1}}=\sem{\seqof{\astmt}{\astmt^i}}$.
The set of predicate transformers is closed under these constructions, and so $\sem{\astmt}\in\setpredtrans$. 

We specify program correctness with Hoare triples of the form $\hoareof{\apred}{\astmt}{\apredp}$. 
The triple is valid, denoted by $\models \hoareof{\apred}{\astmt}{\apredp}$, if $\semof{\astmt}{\apred}\predleq\apredp$. 
We reason about validity using the proof rules in \cref{Figure:PL}. Ignore the colorful parts for the moment, in particular the rules \ruleref{frame} and \ruleref{context}. We refer to the remainder as the rules of Hoare logic.  
We say that a rule is sound, if validity of the premise entails validity of the conclusion. 
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
\begin{lemma}\label{Lemma:SoundnessHoare}
The rules of Hoare logic are sound.
\end{lemma}
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------

We refer to the rules in \cref{Figure:PL} without the blue annotations as the separation logic (SL) induced by $\sem{-}$. For soundness of the frame rule, it is well-known that the predicate transformers $\sem{\acom}$ need to satisfy an extra property called \emph{locality}: for all $\apred, \apredp\in\setpreds$ we need 
\begin{align}
\semof{\acom}{\apred\mstar\apredp}\predleq\semof{\acom}{\apred}\mstar\apredp.\tag{Locality}\label{Equation:Locality}
\end{align} 
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
Soundness of the frame rule is an immediate consequence of the fact that all constructions used to define the program semantics preserve \eqref{Equation:Locality}. 
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------
\begin{lemma}[Soundness of \ruleref{frame}]\label{Lemma:SoundnessFrame}
Assume $\sem{\acom}$ satisfies \eqref{Equation:Locality} for all $\acom\in\setcom$. 
Then $\models\hoareof{\apred}{\astmt}{\apredp}$ implies $\models\hoareof{\apred\mstar\apredppp}{\astmt}{\apredp\mstar\apredppp}$. 
\end{lemma}

A state $\astate$ is a footprint of $\sem{\acom}$ if $\semof{\acom}{\set{\astate}}\neq \abort$, the predicate transformer does not abort on the state.  
We use $\footprintsof{\sem{\acom}}$ for the set of all footprints.   
Due to locality, the set of footprints is closed under composition: $\astate\in \footprintsof{\sem{\acom}}$ and $\astate\statemultdef\astatep$ implies $\astate\mstar\astatep\in \footprintsof{\sem{\acom}}$.  

\input{content/rules}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
