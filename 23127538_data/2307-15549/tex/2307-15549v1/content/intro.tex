%!TEX root = ../main.tex

\section{Introduction}

Separation logic~\cite{DBLP:conf/csl/OHearnRY01,DBLP:conf/lics/Reynolds02} has had a formative influence on many modern program logics. Its success has been linked to its ability to reason locally about mutable state~\cite{DBLP:journals/cacm/OHearn19}. Assertions in separation logic denote physical resources such as memory locations and their contents. These resources can be composed using \emph{separating conjunction} to express disjointness constraints. Correctness judgments in the logic guarantee that a program does not access any resources that are not explicitly specified in the program's \emph{footprint}. Together, these characteristics give rise to the \emph{frame rule}, which allows one to conclude for free that any resource disjoint from the footprint is not affected by the program's execution. Thus, one can reason locally about only those parts of the program state that are relevant for the computation at hand.

Modern separation logics provide rich formalisms for layering abstractions on top of the physical resources manipulated by the program~\cite{DBLP:journals/jfp/JungKJBBD18, DBLP:conf/ecoop/Dinsdale-YoungDGPV10, DBLP:conf/ecoop/PintoDG14, DBLP:conf/pldi/GuSKWKS0CR18, DBLP:books/daglib/0034962}. These abstractions take the form of ghost resources that come equipped with their own fictional notion of separation, lifting the locality principle from the low-level program state all the way up to the level of abstract specifications of functional correctness properties.

Ghost resources induce a stronger notion of separation than mere disjointness on the abstracted physical resources~\cite{DBLP:journals/pacmpl/FarkaN0DF21}. As a consequence, the abstract footprint can comprise more physical resources than only those that the program directly manipulates. In fact, the footprint can become unbounded. For example, consider a ghost resource that abstracts a linked data structure by its contents. When the program inserts a new value into the structure, then the abstract effect will involve reasoning about the entire data structure state (because the ghost resource abstracts the whole structure), even though the insertion may only update a single memory location.

Thus, reasoning about ghost resources often deteriorates back to global reasoning about an unbounded set of physical resources. This global reasoning may, e.g., involve induction proofs for lemmas that are used to manipulate recursive predicates in the proof. While there has been much progress on automating such reasoning~\cite{DBLP:journals/jacm/CalcagnoDOY11, DBLP:conf/cade/BrotherstonDP11,DBLP:conf/pldi/PekQM14,DBLP:conf/sas/ToubhansCR14,DBLP:conf/nfm/EneaLSV17,DBLP:conf/cav/DardinierPWMS22,DBLP:journals/tocl/MathejaPZ23}, it remains a challenge for rich functional specifications and ghost resources that cannot be expressed in decidable theories.

\smartparagraph{Contributions.}
This paper aims to create new opportunities for local reasoning when dealing with computations that have unbounded footprints. We introduce \emph{context-aware separation logic (CASL)}. The key inside of CASL is that one can relax the locality requirement on the semantics of programs if the resources to be framed are known in advance. That is, in CASL one can frame a given \emph{context} $\acontext$ across a computation, provided that any changes affected on the resources in the context preserve $\acontext$. Effectively, this allows one to subtract $\acontext$ from the footprint of the computation. We then present an abstract interpretation principle for computing appropriate contexts $\acontext$ in cases where the unbounded footprint is induced by a ghost abstraction of the physical resources. We instantiate our approach to the flow framework that enables reasoning about inductive properties of general graphs in separation logic~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23}.

To demonstrate the usefulness of CASL, we show how to avoid reasoning about unbounded footprints when proving full functional correctness of a binary search tree implementation. The case study considers complex maintenance operations inspired by realistic concurrent implementations that introduce sharing in the data structure graph.
While the presented proofs are not yet automated, we believe that our development will open up new avenues for automating the correctness proofs of such highly complex algorithms.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
