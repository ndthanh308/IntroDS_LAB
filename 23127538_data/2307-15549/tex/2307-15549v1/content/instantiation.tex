%!TEX root = ../main.tex
\newcommand{\auxstatemult}{\uplus}
\newcommand{\auxstatemultdef}{\statemultdef_\auxstatemult}%{\statemultdef\!\statemultdef}
\newcommand{\myfg}{\astate}%{\aflowconstraint}%{\astate}
\newcommand{\afg}{\astate}%{\aflowconstraint_1}%{\astate}
\newcommand{\afgp}{\astatep}%{\aflowconstraint_2}%{\astatep}
\newcommand{\afgpp}{\astatepp}%{\aflowconstraint_c}%{\astatep}
\newcommand{\afgppp}{\astateppp}%{\aflowconstraint_c}%{\astatep}
\newcommand{\afgc}{\astatepp}%{\aflowconstraint_c}%{\astatep}
\newcommand{\emptyfg}{\astate_\emptyset}
\newcommand{\newinflow}{\inflow_\mathit{new}}
\newcommand{\fprelup}[1]{\fprel^{#1}}


\section{Contextualization for Flow Graphs}
\label{sec:instantiation}

We instantiate the contextualization principle from the previous section for the flow framework~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23}.
As alluded to in \cref{sec:motivation}, this combination of techniques allows us to handle complicated updates in a local way with relative ease even if the updates' footprints are unbounded. 
We apply the instantiation in \cref{sec:bst}.
The remainder of this section formalizes the intuition from \cref{sec:motivation} about flow graphs (\cref{sec:instantiation:flow-graphs}), studies how updates interact with flow graph composition (\cref{sec:instantiation:updates-approach} and \cref{sec:instantiation:updates}), and instantiates the contextualization principle (\cref{sec:instantiation:approximates}).

%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsection{Flow Graphs}
\label{sec:instantiation:flow-graphs}
We briefly introduce the separation algebra of flow graphs, following the recent formulation due to~\citet{DBLP:conf/tacas/MeyerWW23}. 
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Flow Monoids}
Flow graphs are parametric in the ghost state they carry.
These so-called flow values are drawn from a \emph{flow monoid}, a commutative monoid $(\amonoid, \monadd, \monunit)$. 
The monoid carries the natural order $\amonvalp \leq \amonval$ defined by $\amonval = \amonvalp+\amonvalpp$ for some $\amonvalpp\in\amonoid$. 
We require that $(\amonoid,\leq)$ is an $\omega$-cpo, a partial order in which every ascending chain $\achain=\amonval_0\leq\amonval_1\leq\ldots$ has a join $\bigjoin\achain$.
A function $\atfun:\amonoid\to\amonoid$ is \emph{continuous}~\cite{Scott70} if it commutes with joins over ascending chains, $\atfun(\bigjoin\achain)=\bigjoin\atfun(\achain)$.
We write $\contfunof{\amonoid\to\amonoid}$ for the set of all continuous functions. 
We expect the monoid operation to be continuous, $\amonvalp \monadd \bigjoin\achain = \bigjoin(\amonvalp \monadd \achain)$. 

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Flow Graphs}
\emph{Flow graphs} $\myfg=(\setnodes, \edges, \inflow)$ consist of a set of nodes $\setnodes\subseteq\nat$,  a set of edges  that are labeled by continuous \emph{edge functions} $\edges:\setnodes\times\nat\to\contfunof{\amonoid\prall{\to}\amonoid}$, and an \emph{inflow} $\inflow: (\nat\setminus\setnodes)\times\setnodes\to\amonoid$. 
The inflow can be thought of as the flow values that $\myfg$ receives from nodes outside the flow graph, from a frame or a context.
We use $\setflowconstraints$ for the set of all flow graphs and define the empty graph $\emptyfg= (\emptyset, \emptyset, \emptyset)$.
We may refer to the nodes, edges, and inflow by $\myfg.\setnodes$, $\myfg.\edges$, $\myfg.\inflow$, respectively.

To understand the ghost state that flow graphs $\myfg=(\setnodes, \edges, \inflow)$ encode, we use two derived quantities, the \emph{flow} and the \emph{outflow}.
The flow dictates how flow values propagate within $\myfg$.
It is the least function $\fval:\setnodes\to\amonoid$ satisfying the flow equation: for all nodes $\anode\in\setnodes$, we have \[
	\fvalof{\anode} ~~=~~ \sum_{\anodep\in\nat\setminus\setnodes} \inflow(\anodep,\anode) ~~\monadd~~ \sum_{\anodep\in\setnodes} \edgesatof{\anodep}{\anode}{\fval(\anodep)}\ . 
	\tag{FlowEq}
	\label{def:flow-equation}
\]
The outflow $\outflow:\setnodes\times(\nat\setminus\setnodes)\to\amonoid$ is then obtained from the flow, $\outflowof{\anode, \anodep}=\edges_{(\anode, \anodep)}(\fvalof{\anode})$. 
It is worth pointing out that the flow can be computed using standard Kleene iteration.

\begin{example}
  \label{ex:inset-flow}
  We revisit the BST example from \cref{sec:motivation}. Let $\keyspace$ be the totally ordered set of keys with minimal and maximal elements $-\infty$ and $\infty$, respectively. Recall that the inset of a node $\anode$ in a tree is the set of keys for which the BST search will traverse $\anode$. To define insets in terms of a flow, we choose the flow monoid $\bigl( \powerset{\keyspace}\uplus\set{\bot,\top},\, \oplus,\, \bot \bigr)$ with $\amonval\oplus\bot=\amonval$ and $\amonval\oplus\amonvalp=\top$ in all other cases.
%
  The flow values propagated by this flow are sets of keys $\amonval,\amonvalp\subseteq\keyspace$ (to represent the insets), or dedicated sentinel values $\bot,\top$.
  We will use the sentinel values to capture some rudimentary shape information in the data structure invariant. Value $\bot$ denotes that a node is unreachable from $\Root$.
  Note that $\bot$ and $\emptyset$ differ: $\emptyset$ means that the node is still reachable from $\Root$, but \code{find} will not traverse it.
Value $\top$ denotes that a node has multiple reachable parents, i.e., the heap graph is not a tree.
To establish this intuition, $\bot$ is neutral with respect to $\oplus$ and in all other cases $\oplus$ yields $\top$.

The edge functions encode the BST search principle. They are derived from the physical representation of nodes as follows (where we use logical variables like $\leftof{\anode}$ to refer to the value of the corresponding field):
\begin{align*}
  \edgesatof{\anode}{\anodep}{\amonval} ~=~ \begin{cases}
    \amonval\cap[-\infty,\keyof{\anode})  &\text{if }~ \anodep=\leftof{\anode} \\
    \amonval\cap(\keyof{\anode},\infty]  &\text{if }~ \anodep=\rightof{\anode} \\
    \bot  &\text{otherwise} \enspace.
  \end{cases}
\end{align*}
Here, we assume $\leftof{\anode} \neq \rightof{\anode}$, $\bot\cap\amonval=\bot$, and $\top\cap\amonval=\top$.
The first case handles edges from a node $\anode$ to its left child $\anodep$.
The edge forwards the portion of the given flow value $\amonval$ that is smaller than $\anode$'s key.
Similarly, the second case forwards the portion of $\amonval$ that is larger than $\anode$'s key to its right child.
In all other cases, the edge function produces $\bot$.

Consider a binary search tree with nodes $\setnodes$ and root node $\Root \in \setnodes$. Define the flow graph $\myfg=(\setnodes, \edges, \inflow)$ where $\inflow$ is some inflow that satisfies $(-\infty,\infty] = \sum_{\anodep \notin \setnodes} \inflowof{\anodep,\Root}$ and $\bot = \sum_{\anodep \notin \setnodes} \inflowof{\anodep,\anode}$ for all $\anode \in \setnodes \setminus \set{\Root}$. Intuitively, the inflow $\inflow$ encodes that all searches start at $\Root$. Then $\myfg.\fvalof{\anode}$ is the inset of a node $\anode \in \setnodes$. See also \cref{fig:bst-remove-flows} for a concrete example.

When $\myfg$ is understood, we write $\isof{\anode}$ for $\myfg.\fvalof{\anode}$.
%
We refer to the \emph{left outset} of a node $\anode$ as the quantity produced by the edge function $\edgesat{\anode}{\leftof{\anode}}$ for the inflow of $\anode$.
Formally, this is $\oslof{\anode} = \edgesatof{\anode}{\leftof{\anode}}{\isof{\anode}}$ if $\leftof{\anode}\neq\nullptr$ and $\oslof{\anode}=\emptyset$ otherwise.
The \emph{right outset} $\osrof{\anode}$ is defined correspondingly.
Subtracting $\anode$'s outsets from its inset yields the keys for which \code{find} terminates in $\anode$.
That is, these are the keys that could be in $\anode$ while still satisfying the BST order property for the remaining graph.
This quantity is the keyset of $\anode$: \[
  \ksof{\anode} ~=~ \begin{cases}
    \emptyset  &\text{if }~ \isof{\anode}\in\set{\bot,\top} \\
    \isof{\anode} \setminus \bigl( \oslof{\anode} \cup \osrof{\anode} \bigr)  &\text{otherwise}
  \ .
  \end{cases}
\]
The definition of the edge functions and the global inflow $\inflow$ guarantees that for $\myfg$ as defined above, the keysets of all nodes are pairwise disjoint.
\end{example}

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Multiplication}
The ghost multiplication $\afg\imult\afgp$ requires disjointness of the nodes, $\afg.\setnodes\cap\afgp.\setnodes=\emptyset$. 
In this case, it removes the inflow to $\afg$ that is provided by $\afgp$, and vice versa: \[
	\afg\imult\afgp
	~~\defeq~~
	\bigl(
		\afg.\setnodes\uplus\afgp.\setnodes,\;
		\afg.\edges\uplus\afgp.\edges,\;
		\restrictto{\afg.\inflow}{(\nat\setminus\afgp.\setnodes)\times\afg.\setnodes}
		\uplus
		\restrictto{\afgp.\inflow}{(\nat\setminus\afg.\setnodes)\times\afgp.\setnodes}
	\bigr)
	\ .
\]

The ordinary multiplication $\afg\statemult\afgp$ extends the requirements of the ghost multiplication.
It is defined if
\begin{inparaenum}
	\item $\afg\imult\afgp$ is defined,
	\item the inflow expectation of one graph matches the outflow of the other, $\afg.\outflowof{\anode,\anodep}=\afgp.\inflowof{\anode,\anodep}$ and $\afgp.\outflowof{\anodep,\anode}=\afg.\inflowof{\anodep,\anode}$ for all nodes $\anode\in\afg.\setnodes,\: \anodep\in\afgp.\setnodes$, and
	\item the inflow/outflow interface between the two graphs is faithful, $\afg.\fval\uplus\afgp.\fval=(\afg\imult\afgp).\fval$.
\end{inparaenum}
If defined, the multiplication is $\afg\statemult\afgp=\afg\imult\afgp$. 

Flow graphs satisfy the unique decomposition requirement: one recomputes the flow in $\astate_1\imult\astate_2$, separates the graphs, and assigns as missing inflow the outflow of the other component. 
%
The unique decomposition is thus the moment in which the ghost multiplication requires computational effort (a recomputation of the flow).
Phrased differently, the ghost multiplication of flow graphs has a symbolic character in which the inflow from nodes in the same graph is hidden and only made explicit when the graph is decomposed.
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{lemma}[Unique Decomposition]
	\label{thm:unique-ghost-decomposition}
	Let $\astate_1\imult\astate_2=\astatep$. Then there are $\astatep_1$ and $\astatep_2$ with $\astatep=\astatep_1\mstar\astatep_2$ and $\astate_1.\setnodes=\astatep_1.\setnodes$ and $\astate_2.\setnodes=\astatep_2.\setnodes$. Moreover, the flow graphs $\astatep_1$ and $\astatep_2$ are unique. 
\end{lemma}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
Combined with the results from~\cite{DBLP:conf/tacas/MeyerWW23}, we obtain the following.
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{lemma}\label{Lemma:FlowAlgebra}
	Flow graphs $(\setflowconstraints, \statemult, \imult, \set{\emptyfg})$ form a separation algebra.
\end{lemma}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
If the flow graphs already compose as they are, there is nothing to do for the ghost multiplication.  
We expect the following lemma will also hold for other separation algebras, but did not see a need to make it a requirement of our contextualization principle. 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{lemma}
	\label{Lemma:MultCoincides}
	If  $\afg\statemult\afgp$ is defined, so is $\afg\imult\afgp$ and we have $\afg\statemult\afgp=\afg\imult\afgp$.
\end{lemma}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\smartparagraph{Physical Updates}
Physical updates of flow graphs may only change the graph structure, but cannot change the nodes and the inflow:
if $\afgp\in \upof{\acom}{\afg}$, then we can rely on $\afg.\setnodes=\afgp.\setnodes$ and $\afg.\inflow=\afgp.\inflow$. 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsection{Problem and Approach}
\label{sec:instantiation:updates-approach}
The ghost multiplication of flow graphs is difficult to approximate as it involves a full fixed point computation. 
%
It is well-understood how to approximate fixed points with abstract interpretation. 
%
However, the challenge is that we do not want to retain precise shape information about the heap graph. This is akin to applying abstract interpretation to statically analyze a program without having precise information about the program source code.

We therefore develop a \emph{shape-independent} fixed-point approximation.
We start from the observation that commands change $\afg\mstar\afgc$ to $\afgp\imult\afgc$ with $\afgp\in\upof{\acom}{\afg}$. 
This suggests we should understand which relations  $\afg\ctxfprel\afgp$ are stable in that they entail $\afg\mstar\afgpp\ctxfprel\afgp\imult\afgpp$. 
The plan is then to strengthen the approximate physical update by such stable relations. 
That is, we define $\absupof{\acom}{\afg}=\upof{\acom}{\afg}$ if $\afg\ctxfprel\afgp$ for all $\afgp\in \upof{\acom}{\afg}$. Otherwise, we let $\absupof{\acom}{\afg}$ abort to obtain a sound approximation. The approximate physical update then allows us to transfer knowledge about the fixed point $\afg\mstar\afgpp$ to $\afgp\imult\afgpp$. 
This paves the way to a precise approximate ghost multiplication without the need for shape information. 

\begin{example}
  \label{ex:estimator-motivation}
  To build intuition for the stable relations $\ctxfprel$ and how they relate to contextualization, we return to the example from \cref{sec:motivation} (and \cref{ex:inset-flow}). Let $\ctnof{\anode} = (\ite{\anode = \Root}{\emptyset}{\set{\keyof{\anode}}})$ denote the contents of a node $\anode$. Recall that the core idea for the proof of the BST is to express its structural invariant in terms of a node-local predicate that may refer to the node's flow (or rather the derived quantities $\inset$ and $\keyset$). We denote this predicate by $\ninv{\anode,\setnodes}$ where $\setnodes$ is the set of all nodes of the tree:
\begin{align*}
  \ninv{\anode,\setnodes} ~=~~&
    \set{\leftof{\anode},\rightof{\anode}}\subseteq\setnodes\uplus\set{\nullptr} ~~\land~~ (\leftof{\anode} = \rightof{\anode} \implies \leftof{\anode} = \nullptr) ~~\land~~
    \\& \isof{\anode} \neq \top ~~\land~~ 
    \bigl(\isof{\anode}\neq\bot \implies \ctnof{\anode}\subseteq\ksof{\anode}) ~~\land~~ 
    \\&\bigl(\anode = \Root \implies (-\infty,\infty] \subseteq \isof{\anode} \land 
\keyof{\anode}=\infty\bigr)\enspace.
\end{align*}
The node-$\anode$-local invariant requires that
\begin{inparaenum}
  \item the overall structure $\setnodes$ is self-contained, i.e., $\anode$ cannot reach nodes outside of $\setnodes$,
  \item the child pointers are distinct or both $\nullptr$
  \item $\anode$ has at most one parent node that is reachable from $\Root$, i.e., at most one node sends flow to $\anode$,
  \item if $\anode$ is reachable, then its contents are contained in its keyset, i.e., the keyset invariant, and
  \item $\Root$ is a sentinel node with key $\infty$
    and it is the entry point for all searches.
\end{inparaenum}

The context $\acontext$ for an update $\acom$ on the BST will consist of a set of nodes $ \anode \in \setnodesp \subseteq \setnodes$ that satisfy $\ninv{\anode, \setnodes}$. To ensure that $\acontext$ is preserved, we must therefore understand what kind of relations $\ctxfprel$ preserve $\ninv{\anode, \setnodes}$.
A candidate is the relation stating that $\isof{\anode} \notin \{\bot,\top\}$ holds before the update and the update increases $\isof{\anode}$ to a larger set. This $\ctxfprel$ preserves $\ninv{\anode,\setnodes}$ because $\isof{\anode}$ only occurs on the right side of subset inclusions. This is exactly the kind of change that occurs in the nodes that are in the left subtree of $\anode$ in \cref{fig:bst-remove-flows}. Similarly, if $\anode$ is not the $\Root$, then $\isof{\anode}$ can be reduced, as long as it still contains $\keyof{\anode}$. On the other hand, if $\anode$ was unreachable before the update ($\isof{\anode} = \bot$) were to become reachable and receive a proper inset, then this update would not be allowed because it may violate, e.g., $\ctnof{\anode} \subseteq \ksof{\anode}$.

In summary, our main task is to identify relations $\ctxfprel$ that approximate $\up{\acom}$, preserve $\ninv{\anode,\setnodes}$, and are stable under the ghost multiplication.
\end{example}

% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\subsection{Shape-Independent Fixed-Point Approximation}
\label{sec:instantiation:updates}

We introduce estimator relations to help us identify relations $\ctxfprel$ that are stable under the ghost multiplication. 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{definition}[Estimator on a Flow Monoid]
	An \emph{estimator} $\fprel\ \subseteq\amonoid \times \amonoid$ is 
	a precongruence that is stable under joins of ascending chains and over which the edge functions are monotonic, that is, 
	\begin{compactenum}[({E}1)]
		\item
			$\fprel$ is reflexive and transitive,
		\item
			$\amonval \fprel \amonvalp$ implies $\amonval+\amonvalpp \fprel \amonvalp+\amonvalpp$ for all $\amonval,\amonvalp,\amonvalpp\in\amonoid$,
		\item
			$\bigjoin\achain\fprel\bigjoin\achainp$ for all ascending chains $\achain=\amonval_0\leq\amonval_1\leq\cdots$ and $\achainp=\amonvalp_0\leq\amonvalp_1\leq\cdots$ with $\amonval_i\fprel\amonvalp_i$ for all $i\in\nat$, 
		\item
			$\amonval \fprel \amonvalp$ implies $f(\amonval) \fprel f(\amonvalp)$ for all edge functions. 
	\end{compactenum}
\end{definition}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
As we show in the appendix, one can relax the stability under joins, but the above definition is more intuitive than the liberal one. 

\begin{example}
  \label{ex:estimator}
  Coming back to \cref{ex:estimator-motivation}, the following relation is an estimator on the inset flow monoid: $
  \amonval\simplerel\amonvalp
  \iff
  \amonval=\amonvalp
  \,\lor\,
  \bigl(\,\setc{\amonval,\amonvalp}\cap\setc{\bot,\top}=\emptyset
  \,\land\,
  \amonval\subseteq\amonvalp\,\bigr)
  $.
%
It captures updates to the BST that may increase the inset of a node if it is reachable by exactly one path from $\Root$.
\end{example}

To lift estimator relations to flow graphs, we need a concept from~\cite{DBLP:conf/tacas/MeyerWW23}. 
They associate with a flow graph its \emph{transfer function} 
\(
  \transformerof{\afg}:((\nat\setminus\setnodes)\times\setnodes\rightarrow \amonoid)\rightarrow(\nat\setminus\setnodes\rightarrow \amonoid)
\) that makes explicit how the fixed point computation for the flow turns inflows  into outflows, \[
  \transformerof{\afg}(\inflow)(\anodep)\ =\  \sum_{\anode\in\afg.\setnodes} \afg[\inflow].\outflow(\anode,\anodep)
  \ .
\]
We set the inflow to the given function, denoted by $\afg[\inflow]$, determine the outflow for the resulting flow graph, and sum up the flow values that are sent from the flow graph to the node of interest.
% 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{definition}[Estimator on Flow Graphs]
Let $\fprel$ be an estimator on the flow monoid. 
It induces the estimator $\afg_1 \ctxfprel \afg_2$ on flow graphs defined by $\afg_1.\setnodes = \afg_2.\setnodes$, $\afg_1.\inflow = \afg_2.\inflow$, and
	$\transformerof{\afg_1}\fprel_{\afg_1.\inflow}\transformerof{\afg_2}$. 
	Here, $\transformerof{\afg_1} \fprel_{\afg_1.\inflow} \transformerof{\afg_2}$ means 
	$\transformerof{\afg_1}(\inflow)(\anode) \fprel \transformerof{\afg_2}(\inflow)(\anode)$, for all $\inflow \leq \afg_1.\inflow$ and all $\anode\in\afg_1.\setnodes$. 
\end{definition}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------

The relation $\afg\ctxfprel\afgp$ guarantees the desired stability $\afg\mstar\afgpp\ctxfprel\afgp\imult\afgpp$. 
%
For the ghost multiplication, we would also like to use $\afg\mstar\afgpp$ to give an estimate on $\afgp\imult\afgpp$. 
We expect that $\afgpp$ will receive more inflow from the nodes in $\afg$, which are also the nodes of $\afgp$. 
As this additional inflow may be funneled back to $\afgp$, also $\afgp$ may receive more inflow from the nodes in $\afgpp$. 
%
This is captured by a family of relations on inflows over the same set of nodes $\setnodes$. 
For $\setnodesp\subseteq\nat\setminus\setnodes$, define 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{align*}
	\inflow_1\fprelup{\setnodesp}\inflow_2,
	\quad\text{if}\quad
	\restrictto{\inflow_1}{\overline{\setnodesp}\times\setnodes}=\restrictto{\inflow_2}{\overline{\setnodesp}\times\setnodes}
	~~\text{ and }~~
	\sum_{\anodep\in\setnodesp} \inflow_1(\anodep,\anode) \fprel \sum_{\anodep\in\setnodesp} \inflow_2(\anodep,\anode)
	~\text{ for all }\anode\in\setnodes
	\ . 
\end{align*}
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
This is the fixed-point approximation we work with. 
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
% ----------------------------------------------------------------------------------------
\begin{theorem}[Shape-Independent Fixed-Point Approximation]
	\label{thm:instantiation-closure}
	Let $\afg\ctxfprel\afgp$ and $\afg\statemultdef\afgc$.
	Then, $\afg\statemult\afgc\ctxfprel\afgp\imult\afgc=\afgp[\inflow_\afgp]\statemult\afgc[\inflow_\afgc]$ with
	$\afg.\inflow\fprelup{\afgc.\setnodes}\inflow_\afgp$ and $\afgc.\inflow\fprelup{\afg.\setnodes}\inflow_\afgc$.
\end{theorem}
%=============================================================================%
%=============================================================================%
%=============================================================================%
\subsection{Instantiation}
\label{sec:instantiation:approximates}
We are now prepared to define the approximate updates. 
% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Approximate Physical Update}
The approximate physical update $\absup{\acom}$ strengthens the original update with an estimator relation. 
If this estimator cannot be established, it aborts:
\begin{align*}
	\absupof{\acom}{\astate}=
	\begin{cases}
		\upof{\acom}{\astate}&\qquad\text{if $\upof{\acom}{\astate}\neq\abort$ and for all $\astatep\in\upof{\acom}{\astate}$ we have $\astate\ctxfprel\astatep$}\\
		\abort&\qquad\text{otherwise}. 
	\end{cases}
\end{align*}

\begin{theorem}
	\label{thm:instantiation-physical}
	$\absup{\acom}$ is an approximate physical update:
	\begin{inparaenum}
		\item $\upof{\acom}{\afg}\predleq\absupof{\acom}{\afg}$, and
		\item if $\absupof{\acom}{\afg}\neq\abort$ then $\absupof{\acom}{\afg\mstar\afgc}=\absupof{\acom}{\afg}\imult\afgc$.
	\end{inparaenum}
\end{theorem}
\begin{proof}%	\label{proof:instantiation-physical}
	The first claim holds by definition.
	For the second claim, assume $\absupof{\acom}{\afg}\neq\abort$ and $\afg\statemultdef\afgc$.
	We show $\absupof{\acom}{\afg\statemult\afgc}=\absupof{\acom}{\afg}\imult\afgc$.
	To that end, it suffices to show that $\upof{\acom}{\afg\statemult\afgc}$ does not abort and its states satisfy the estimator requirement.
	Indeed, then
	\begin{align*}
		&\absupof{\acom}{\afg\statemult\afgc}
		\\
		\explain{Definition}=~~&
		\upof{\acom}{\afg\statemult\afgc}
		\\
		\explain{$\absupof{\acom}{\afg}\neq\abort$ implies $\upof{\acom}{\afg}\neq\abort$}=~~&
		\upof{\acom}{\afg}\imult\afgc
		\\
		\explain{$\absupof{\acom}{\afg}\neq\abort$}=~~&
		\absupof{\acom}{\afg}\imult\afgc. 
	\end{align*}
	That $\upof{\acom}{\afg\statemult\afgc}$ does not abort follows from $\upof{\acom}{\afg}\neq\abort$.
	For the estimator requirement, let $\afgp\imult\afgc\in \upof{\acom}{\afg\statemult\afgc}=\upof{\acom}{\afg}\imult\afgc$.
	We have to show $\afg\statemult\afgc\ctxfprel\afgp\imult\afgc$.
	Since $\absupof{\acom}{\afg}\neq\abort$, we can rely on $\afg\ctxfprel\astatep$.
	Then, or \cref{thm:instantiation-closure} concludes the argument.
\end{proof}


% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Approximate Ghost Multiplication}
We can rely on the estimator relation in the definition of the approximate ghost multiplication.  
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
\begin{definition}\label{Definition:GhostMultiplication}
If there is $\afg\ctxfprel\afgp$ with $\afg\statemultdef\afgpp$ or there is a $\afgppp\ctxfprel\afgpp$ with $\afgppp\statemultdef\afgp$, then we define 
$\ghostabsof{\afgp}{\afgpp} = \setcond{\afgpp[\inflow]}{\afgpp.\inflow\fprelup{\afgp.\setnodes}\inflow}$.
Otherwise, we set $\ghostabsof{\afgp}{\afgpp}=\abort$.
\end{definition}
We rely on Theorem~\ref{thm:instantiation-closure} and define $\ghostabsof{\afgp}{\astatepp}$ as the set of all flow graphs that coincide with~$\astatepp$ except that they have more inflow according to $\fprelup{\afgp.\setnodes}$. 
Then $\ghostabs{\afgp}$ is a closure operator and thus idempotent. 
This means the reflexive and transitive closure $\rho^*$ in the definition of $\apredpp$ will be reached after only one iteration, provided the approximate physical update is deterministic. 
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------

Recall that $\astatep\absimult \astatepp$ is a derived operation defined as $\ghostabsof{\astatepp}{\astatep}\mstar \ghostabsof{\astatep}{\astatepp}$. 
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
% -----------------------------------------------------------------------------------------
\begin{theorem}
	\label{thm:instantiation-ghost}
	The family of relations $\ghostabs{\afgp}$ defined above is an approximate ghost multiplication. 
	%
	In particular, if there is $\afg\ctxfprel\astatep$ and $\astate\statemultdef\astatepp$ then $\astatep\imult\astatepp \in \astatep\absimult\astatepp$. 
\end{theorem}

% ----------------------------------------------------------------------------
% ----------------------------------------------------------------------------
\smartparagraph{Contextualization for Flow Graphs}
With the instantiation from above we are ready to use the contextualization principle from \cref{sec:contextualization} to handle commands $\semof{\acom}{\astate\mstar\astatepp}$.
To that end, assume the physical update is local to $\astate$, that is, $\absupof{\acom}{\astate}=\astatep$. 
Then, the task is to establish some estimation $\astate\ctxfprel\astatep$.
If $\astate\ctxfprel\astatep$ holds, construct the $\fprel$-closures for $\astate$ and $\astatep$.
They are $\apred_{\astatep}=\ghostabsof{\astatepp}{\astatep}$ and $\apred_{\astatepp}=\ghostabsof{\astatep}{\astatepp}$.
Relying on \cref{thm:contextualization}, our instantiation then guarantees that the update satisfies $\semof{\acom}{\astate\mstar\astatepp}\predleq\apred_{\astatep}\mstar\apred_{\astatepp}$. 



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
