%!TEX root = ../main.tex

\section{Related Work and Conclusion}
\label{sec:related}

The work closest to ours is on the modular verification of reachability properties~\cite{DBLP:journals/pacmpl/Ter-GabrielyanS19}. 
The goal is to understand how the change of reachability in a subheap impacts the reachability in the overall heap, a problem referred to as reachability framing. 
The contribution is a recompution method for so-called relatively-convex footprints. 
As reachability information can be encoded into flows, the reachability framing problem can be cast as an approximation of a ghost multiplication for the corresponding flow graphs. 
We give an approximation method for general flow graphs, and so have to work around the absence of domain specific knowledge. 
Our approach is to introduce estimator relations, which may be seen as distant relatives of relative convexity.  

The main difference is that our work studies the impact of local changes on a context in a general setting, which lead to the notion of context-aware predicate transformers, the \eqref{Equation:Mediation} property, and the development of a full program logic that has the new \ruleref{context} to frame the (known) context.   
Another difference is that, inspired by classical framing, our approach strives for invariance of the context predicate, while the mentioned work embraces change.
It is an interesting problem for future work to embed the modification of ghost information in the context into a program logic. 

Also related to our work is the ramification rule for separation logic~\cite{DBLP:conf/popl/HoborV13} (of which the principle developed in~\cite{DBLP:journals/pacmpl/Ter-GabrielyanS19} can be seen as a concrete instance). 
Ramifications ease local reasoning about overlayed structures.
The rule says that to prove a global specification $\hoareof{\apred'}{\astmt}{\apredp'}$, one can focus on a more local one $\hoareof{\apred}{\astmt}{\apredp}$ provided the precondition satisfies $\apred'\subseteq \apred\mstar(\apredp\sepimp\apredp')$. 
Indeed, the proof for \code{remove} that we gave in Section~\ref{sec:motivation} to motivate our work is via ramification. 
As discussed there, the predicate $\htreepred$ is hard to work with, and it is precisely the separating implication $\apredp\sepimp\apredp'$ involved in ramification. 

While this is the technical link, our work has a different goal than ramification, namely to localize footprints in cases where they become unbounded. 
In the settings of interest to us, the triple $\hoareof{\apred}{\astmt}{\apredp}$ cannot be proven in the first place, because the computation aborts due to missing resources. 
Our way out was to propose context-aware reasoning $\choareof{\apredpp}{\apred}{\astmt}{\apredp}$, which guarantees that the missing resources can be found in the context $\apredpp$. 
While ramification is based on the \ruleref{frame} rule, we had to integrate context-aware reasoning deeply into the program logic, down to the semantics that we had to change to context-aware predicate transformers.
What came as a surprise was that every predicate transformer can be made context-aware via the induced semantics. 

We share the goal of localizing unbounded footprints with the recent work~\cite{DBLP:journals/pacmpl/MeyerWW22}. 
Their technique applies in situations where the unbounded footprint is traversed prior to the data structures update. 
It relies on the traversal to build up a predicate that captures the effect of the update, very much in the style of ramifications. 
Here, we consider the missing case that the unbounded footprint is not traversed, nevertheless influenced by the physical update due to a propagation of ghost information. 
We observe that the essential data structure invariants are invariant under such modifications, and develop the \ruleref{context} rule to frame out the corresponding parts (although they undergo modifications). 

The context $\apredpp$ in CASL specifications $\choareof{\apredpp}{\apred}{\astmt}{\apredp}$ looks similar to a resource invariant in concurrent separation logic~\cite{DBLP:conf/concur/Brookes04,DBLP:conf/concur/OHearn04}. 
The proof rule for atomic blocks in CSL temporarily adds the resource invariant to the specification in order to prove the atomic block. 
Our \ruleref{context} rule proceeds the other way around and subtracts the context from the state to be able to reason locally. 
The difference becomes clear when seeing the rules side-by-side:
$$
			\inferH{atomic}{
				\choareOf{\emp}{\apred\mstar \apredpp}{\astmt}{\apredp\mstar \apredpp}
				}{
				\choareOf{\apredpp}{\apred}{\text{\bfseries atomic}\ \astmt}{\apredp}
				}\hspace{3cm}
							\inferHlab{context-dup}{context}{
				\choareOf{\acontext}{\apred}{\astmt}{\apredp}
				}{
				\choareOf{\emp}{\apred\mstar \apredpp}{\astmt}{\apredp\mstar \apredpp}\ .
				}$$

We also address the contextualization problem, the problem of determining a predicate $\apredpp$ capturing substate that remains invariant under transitions. 
This is related to the resource invariant synthesis problem addressed in~\cite{DBLP:conf/pldi/GotsmanBCS07,DBLP:conf/aplas/CalcagnoDV09}. 
The concurrent setting suggests a thread-modular analaysis and a focus on locks. 
Also related to contextualization is bi-abduction where, given predicates $\apred$ and $\apredp$, the task is to infer a frame $\apredp'$ as an unneeded part of the state and an anti-frame $\apred'$ as a missing premise, so that $\apred\mstar\apred'\subseteq\apredp\mstar\apredp'$ holds. 
Our work is about ghost state, and our goal is to approximate the ghost multiplication. 
This brings the new problem of approximating fixed points over heap graphs whose shape is not known. 
Bi-abduction assumes to know the recursive predicates, and therefore the approach does not seem to carry over.

Beyond bi-abduction there is a rich literature on entailment checking and frame inference for separation logic with recursive predicates (see, e.g., \cite{DBLP:journals/jacm/CalcagnoDOY11, DBLP:conf/cade/BrotherstonDP11,DBLP:conf/pldi/PekQM14,DBLP:conf/sas/ToubhansCR14,DBLP:conf/nfm/EneaLSV17,DBLP:conf/cav/DardinierPWMS22,DBLP:journals/tocl/MathejaPZ23}). However, these works are limited to reasoning about tree-like structures without sharing and often do not extend to functional correctness properties. The flow framework~\cite{DBLP:journals/pacmpl/KrishnaSW18,DBLP:conf/esop/KrishnaSW20,DBLP:conf/tacas/MeyerWW23} aims to provide a shape-agnostic formalism for reasoning about rich inductive properties of general graphs. 

We already discussed the connection to the morphism framework~\cite{DBLP:journals/pacmpl/Nanevski0DF19, DBLP:journals/pacmpl/FarkaN0DF21} which inspired our ghost multiplication.  
%
Program logics like Iris~\cite{DBLP:journals/jfp/JungKJBBD18}, CAP~\cite{DBLP:conf/ecoop/Dinsdale-YoungDGPV10}, and TADA~\cite{DBLP:conf/ecoop/PintoDG14} also provide mechanisms for introducing rich ghost state abstractions. 
%
There, the ghost state exists only at the level of the logic and is coupled with the physical state via resource invariants. 
%
Rather than letting the program semantics update the ghost state, the prover has the responsibility to update the ghost state via logical view shifts whenever the physical state changes and the invariant would be violated. 
%
As view shifts must be frame-preserving, this implies that updates can still entail large footprints at the logical level. 
%
Our work extends to these settings in the cases where the required logical view shifts are uniquely determined by the physical updates. 

Our next step is to develop a concurrent variant of CASL, with the goal of verifying concurrent variants of the BST and similar structures, at best in a mechanized or fully automated fashion.
The state of the art tools that can work with relatively little user guidance are the mechanized \texttt{nekton}~\cite{DBLP:conf/cav/MeyerOWW23}, a deductive verifier that expects to be given invariant annotations but can work with general flows, and the fully automated \texttt{plankton}~\cite{DBLP:journals/pacmpl/MeyerWW22}, a model checker that is able to compute invariants, but for flows that model lists.
Both developments are based on an Owicki-Gries proof system. 
Developing an Owicki-Gries-variant of CASL is not straightforward: one has to come up with a notion of interferences that suitably captures the fact that there is state in the context, and one has to understand how the new rule \ruleref{context} modifies the interference sets. 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
