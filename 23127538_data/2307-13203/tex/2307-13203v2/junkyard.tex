
%to obscure or conceal behavior 

%Prior research has explored finding a minimum sensor selection to validate
%a single pre-disclosed itinerary while, concurrently, some have investigated
%how robots themselves may obscure collected information to preserve user
%privacy. This paper bridges the gap between such works by concretely
%formulating the privacy requirements for sensor selection. 
%
%Imagine an outside system which gives us useful information about how an agent
%moves through a given environment. While we require that we be able to
%differentiate between behaviors significant to serving our purposes, we
%simultaneously stipulate that we never be able to differentiate between
%pre-specified private behaviors. Given a set of sensors situated in this
%environment, how do we select a subset of them to satisfy these criteria?
%Previous research has explored finding a minimum sensor selection to validate
%a single pre disclosed itinerary while, concurrently, some have investigated
%how robots themselves may obscure collected information to preserve user
%privacy. This paper bridges the gap between such works by concretely
%formulating the privacy requirements for sensor selection. We explore whether
%it is possible to solve the sensor selection problem on multiple itineraries,
%each of which is possibly present in different types of constraints with
%others. Fundamentally, we present two types of constraints each of which
%specify exactly which information the outside system should and should not
%learn. We present a novel approach to solving this problem and prove that when
%conflation constraints are added, the problem scales exponentially in the
%input size.  A few case studies are presented to demonstrate the usefulness
%and scalability of our proposed solution under various optimizations.



The problems of activity recognition~\cite{yu2011story},
surveillance~\cite{yu2010cyber,uddin2018ambient,ramos2021daily}, suspicious
and/or anomalous behavior detection~\cite{rowe2005detecting}, fault
diagnosis~\cite{sampath1995diagnosability,cassez2008fault}, and task
monitoring~\cite{wang18}\,---despite applying to distinct scenarios---\,all
involve the same underlying challenge.  They analyse
an agent's (or more generally a system's) behavior on the basis of streams of
observations that reflect some aspect of how it
evolves over time.  Given some set of sensors, a basic and important question
is: does the set provide \emph{sufficient}
information to yield conclusions that are both unequivocal and correct?
The question is of direct relevance to practitioners who want to know
if their current suite of sensors is adequate. Also, someone 
purchasing hardware may wish to minimize the costs involved to meet a budget.
Existing research already provides some initial answers
to specific forms of these questions regarding sensor
selection and sufficiency~\cite{rahmani2021sensor,cassez2008fault,yin2017minimization}.

But, while important, the concern that one's sensors may be too weak (i.e.,
inadequately informative) is a one-sided consideration.  It is easy to imagine
situations where obtaining \emph{too much} information may be deemed
detrimental.  For instance, in elder care and independent living applications
(cf.~\cite{uddin2018ambient}), capturing or divulging sensitive\slsh
inappropriate information could be undesirable to the point of it being for
unacceptable for use.  

The present paper re-visits, advances, and elaborates upon the model introduced in the
IROS'21 paper of Rahmani et al.~\cite{rahmani2021sensor}
in multiple interesting ways.  
One of the key directions is 
to include the ability to constrain the information obtained from sensors, in
order to meet privacy and non-disclosure requirements.
Rahmani et al.~\cite{rahmani2021sensor} consider the setting where a
claimant asserts that (future) movements within an
environment will adhere to a given itinerary. Then the objective is to select,
from some set of sensors at specific locations,
a small subset that will detect any deviations from the claim.  
The present paper is also a generalization in that multiple itineraries are
considered and, consequently, the
objective becomes more subtle. In the previous case, the problem is
to select sensors to distinguish the claimed itinerary from all other
behaviors. In the present paper, we might specify that some
itinerary might need to be distinguished from two other
itineraries, each of them distinguished from one another.
When closely-related itineraries are provided, the sensors selected must have
adequate resolving power recognize fine-grain differentiations.
In practical problems where the three
itineraries represents different classes of behavior, the sensor selection
problem is then seeking to ensure the class of behavior can be discerned.
\textcolor{teal}{We probably need an actual setting, rather than general talk.}

\input{example.tex}



however, if the reader wishes to understand the situation with greater nuance, 
we prove the hardness for a special sub-case, concretely a version of
the problem formulated previously with the extra restriction that there are no
conflation constraints in the appendices.

As it turns out, that special sub-case of the problem is also \NP-Complete, following which

One expects, of course, the full problem to be no easier at best, but potentially
harder at worst.
This latter case is nearer the mark.

construct $\mathcal{S}_{\mathcal{G}, \mathcal{I}^1, M}$ and $\mathcal{S}_{\mathcal{G}, \mathcal{I}^2, M}$. This simply replaces the alphabet in the product, which is of size $|V||Q|$). Then, determine whether $\mathcal{L}(\mathcal{S}_{\mathcal{G}, \mathcal{I}^1, M}) \cap \mathcal{L}(\mathcal{S}_{\mathcal{G}, \mathcal{I}^2, M}) = \emptyset$. Note that, by Lemma \ref{nfa-intersection}, checking the non-emptiness of the intersection of 2 NFAs can be done in polynomial time. 

Thus, the total amount of time taken to check the discrimination constraints can be upper bounded by $O\left(\sum_{[\mathcal{I}^1, \mathcal{I}^2]^{\apart} \in I_D} \poly(|V||Q_{\mathcal{I}^1}| , |V||Q_{\mathcal{I}^2}|)\right)$ which is polynomial in the input size.

Next, we turn to the conflation constraints. Following a similar process, construct their signature automata $\mathcal{S}_{\mathcal{G}, \mathcal{I}^1, M}$ and $\mathcal{S}_{\mathcal{G}, \mathcal{I}^2, M}$. Again, since this can be done in polynomial time, it can also be done in polynomial space. Next, ask whether $\mathcal{L}(\mathcal{S}_{\mathcal{G}, \mathcal{I}^1, M}) \subseteq \mathcal{L}(\mathcal{S}_{\mathcal{G}, \mathcal{I}^2, M})$. By Lemma \ref{nfa-inclusion}, we know this problem is \PSPACE-Complete, thus, it can be determined using only a polynomial amount of space. 
Thus, we have shown that $\text{MSSADDI} \in \NPSPACE \implies \text{MSSADDI} \in \PSPACE$.

Next, we shall show that MSSADDI is \PSPACE-Hard. To do so, we reduce from the NFA inclusion problem given in Lemma \ref{nfa-inclusion}.

Intuitively, we'd like to show that when we are checking a conflation constraint by solving an NFA inclusion problem on the signature automata, it is possible that we would end up in the worst possible scenario. 

In the construction, we will assume that every state of $\mathcal{A}$ and $\mathcal{B}$ is reachable from their respective start states. 


The following define $\mathcal{D}$, the discernment designation:---

\begin{enumerate}

\item In the world graph $\mathcal{G}$ constructed in the previous step, let there be $p \leq n+m$ edges collected as $\{e_{i_1}, e_{i_2}, \dots, e_{i_p}\}$ where we have that each of them has a non-empty label, i.e., $e_{i_k} \in E$, and $\lambda(e_{i_k}) \neq \emptyset$ for every $1 \leq k \leq p$.

Then let the set of itineraries $I = \{ I_{e_{i_1}}, I_{e_{i_2}}, \dots, I_{e_{i_p}} \} \cup \{ I_{e_{i_1}^+}, I_{e_{i_2}^+}, \dots, I_{e_{i_p}^+} \} \cup \{ I_A, I_B \}$.

Next, we define the language accepted by each of these itineraries.

The language accepted by each of $\{ I_{e_{i_1}}, I_{e_{i_2}}, \dots, I_{e_{i_p}} \} \cup \{ I_{e_{i_1}^+}, I_{e_{i_2}^+}, \dots, I_{e_{i_p}^+} \}$ is a singleton language which can be produced as follows.

To determine the languages $\mathcal{L}(I_{e_{i_k}})$ and $\mathcal{L}(I_{e_{i_k}^+})$ for $1 \leq k \leq p$, start a breadth first search (BFS) on $\mathcal{G}$ beginning at $v_0$. 
This co-routine will return the shortest path (consisting of specific edges) from $v_0$ to $\srcfunc{e_{i_k}}$. This path is the only string accepted by $\mathcal{L}(I_{e_{i_k}})$. This path followed by $e_{i_k}$ is the only string accepted by $\mathcal{L}(I_{e_{i_k}^+})$.

More formally, if the shortest path is of length $1 \leq q < |V|$ and traverses the edges $e_{j_1}e_{j_2}\dots e_{j_q}$ in order, then we assert that $\mathcal{L}(I_{e_{i_k}}) = \{ e_{j_1}e_{j_2}\dots e_{j_q} \}$ and $\mathcal{L}(I_{e_{i_k}^+}) = \{ e_{j_1}e_{j_2}\dots e_{j_q}e_{i_k} \}$ with the following conditions:

\begin{enumerate}
    \item $\src(e_{j_1}) = v_0$
    \item for each $2 \leq \ell \leq q$, we have $\tgt(e_{j_{\ell-1}}) = \src(e_{j_\ell})$
    \item $\tgt(e_{j_q}) = \src(e_{i_k})$
\end{enumerate}
 
Next, define the itinerary DFA $I_A$ so that it accepts a string $e_{i_1}e_{i_2}\dots e_{i_r}$ where $e_{i_k} \in E$ for all $1 \leq k \leq r$ if and only if $\tgt(e_{i_r}) \in F_A$.
Similarly, define the itinerary DFA $I_B$ so that it accepts a string $e_{i_1}e_{i_2}\dots e_{i_r}$ where $e_{i_k} \in E$ for all $1 \leq k \leq r$ if and only if $\tgt(e_{i_r}) \in F_B$. Note that we are not asking for the given NFAs $\mathcal{A}$ and $\mathcal{B}$ to be converted to DFAs. Instead, we are simply constructing a DFA which describes the \textit{path} that every accepting string in the NFAs follows to be accepted. The construction of such a DFA is rather simple. Define two states $q_0$ and $q_1$ with only $q_1$ accepting. Then, define transitions from $q_0$ to $q_1$ and $q_1$ to $q_1$ for all $e \in E$ such that $\tgt(e)$ is a final state in $\mathcal{A}$ or $\mathcal{B}$ for $I_A$ and $I_B$ respectively. Similarly, define transitions from $q_0$ to $q_0$ and $q_1$ to $q_0$ for all $e \in E$ such that $\tgt(e)$ is not a final state in $\mathcal{A}$ or $\mathcal{B}$ for $I_A$ and $I_B$ respectively.

\item Define $I_D = \left\{ [I_{e_{i_1}}, I_{e_{i_1}^+}]^{\apart}, \dots, [I_{e_{i_p}}, I_{e_{i_p}^+}]^{\apart} \right\}$.

\item Finally, define $I_C = \left\{ (I_A, I_B)^{\together} \right\}$.

\end{enumerate}

We start searching for a satisfying subset from the top down, meaning that larger size subsets of $S$ are checked before smaller ones. For each subset of $M$ of $S$ that we check, we construct signature automata for each itinerary every time it is encountered and check the discrimination and conflation constraints by verifying the intersection and subset properties respectively as shown in previous sections.
Once such a satisfying sensor selection is found, say of size $k$, we no longer continue searching for subsets of the same size and immediately jump to subsets of size $k-1$.

The first optimization is rather simple to understand. When checking the satisfiability of each sensor combination, it is very likely that one itinerary is in multiple constraints with others.
Thus, when constructing the signature automata for an itinerary on a sensor set, we cache it so that when that same itinerary appears in another constraint, we can simply retrieve its signature automaton from the cache.

Note that these may not be the only possible solutions for certain problem instances. In some cases, it is possible that both row and column occupancy sensors be activated if an entire row fails to appear in the conflation constraints  altogether. However, we are guaranteed that the special cases are always \emph{satisfying} solutions, and, indeed, that was almost always the case due to the number of conflation constraints that were added in the problem.

\newpage 
\appendix

We formulate a special sub-case of MSSADDI having no conflation constraints and prove its hardness as follows.

\decproblem{ Minimal sensor selection to accomodate discrimination in multiple itineraries (MSSADMI)}
{A world graph $\mathcal{G} = (V, E, \src, \tgt, v_0, S,\mathbb{Y},\lambda)$,
a discernment designation $\mathcal{D}=(I, I_D, \emptyset)$, and a natural number $k\in\mathbb{N}$.}
{A satisfying sensor selection \mbox{$M \subseteq S$} for $\mathcal{D}$ on $\mathcal{G}$ with $|M| \leq k$, or `\textsc{Infeasible}' if no such satisfying sensor selection exists.}

\begin{lemma}\label{MSSADMI-NP}
    MSSADMI is in \NP.
\end{lemma}

\begin{proof}

To show that MSSADMI is in \NP, we need to show that a certificate $M \subseteq S$ can be verified as a satisfying sensor selection in polynomial time. To do so, we first need to check whether $|M| \leq k$, which is trivial, and then check whether each $[\mathcal{I}^1, \mathcal{I}^2]^{\apart} \in I_D$ is satisfied by $M$.

In Lemma \ref{MSSADDI-PSPACE}, we showed that all the discrimination constraints can be checked in polynomial time against $M \subset S$.
\end{proof}

\begin{lemma} \label{MSSASMI-NP-Hard}
    MSSADMI is \NP-Hard.
\end{lemma}

To prove the above lemma, we shall simply show a reduction from MSSVI\,\cite{rahmani2021sensor} to MSSADMI, which is relatively straightforward.

\begin{proof}

Given an MSSVI instance given by $\langle\mathcal{G}, \mathcal{J}, k\rangle$, construct an instance of MSSADMI $\langle\mathcal{G}, \mathcal{D}, k\rangle$ as follows. The world graph $\mathcal{G}$ as well as the integer $k$ map to the same values in the MSSADMI instance. Complete $\mathcal{D} = (I, I_D, \emptyset)$
by
defining $I = \{\mathcal{I}_1, \mathcal{I}_2\}$ and $I_D = \{[I_1, I_2]^{\apart}\}$ with the two itineraries $\mathcal{L}(\mathcal{I}_1) = \mathcal{L}(\mathcal{J})$ and, its complement, $\mathcal{L}(\mathcal{I}_2) = \overline{\mathcal{L}(\mathcal{J})}$.
Since automata $\mathcal{J}$ is deterministic, the complement operation can be completed in polynomial time.
Correctness follows because any 
sensor selection in MSSADMI 
is satisfying 
if and only if there exist no $w_1 \in \mathcal{L}(\mathcal{I}) \cap \Walks(\mathcal{G})$ and 
$w_2 \in  \overline{\mathcal{L}(\mathcal{I})} \cap \Walks(\mathcal{G})$
such that $\beta_\mathcal{G}(w_1, M) = \beta_\mathcal{G}(w_2, M)$.
But, since $\overline{\mathcal{L}(\mathcal{I})} \cap \Walks(\mathcal{G}) = \Walks(\mathcal{G}) \setminus \mathcal{L}(\mathcal{I})$, 
this meets exactly the condition for a 
solution to MSSVI too.
\end{proof}

\begin{theorem}
    MSSADMI is \NP-Complete.
\end{theorem}

\begin{proof}
Follows directly from Lemmas~\ref{MSSADMI-NP} and~\ref{MSSASMI-NP-Hard}.
\end{proof}

% \begin{algorithm}
% \caption{Calculate $y = x^n$}
% \label{alg1}
% \begin{algorithmic}
% \REQUIRE $n \geq 0 \vee x \neq 0$
% \ENSURE $y = x^n$
% \STATE $y \leftarrow 1$
% \IF{$n < 0$}
% \STATE $X \leftarrow 1 / x$
% \STATE $N \leftarrow -n$
% \ELSE
% \STATE $X \leftarrow x$
% \STATE $N \leftarrow n$
% \ENDIF
% \WHILE{$N \neq 0$}
% \IF{$N$ is even}
% \STATE $X \leftarrow X \times X$
% \STATE $N \leftarrow N / 2$
% \ELSE[$N$ is odd]
% \STATE $y \leftarrow y \times X$
% \STATE $N \leftarrow N - 1$
% \ENDIF
% \ENDWHILE
% \end{algorithmic}
% \end{algorithm}