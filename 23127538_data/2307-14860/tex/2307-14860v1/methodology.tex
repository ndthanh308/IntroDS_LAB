\section{Methodology}\label{sec:methodology}
We develop the following suite of representative quantum applications and benchmarks to evaluate the GPU performance when running Qiskit Aer.

\noindent\textbf{\textit{Quantum Volume (QV) Circuit}}~\cite{cross2019validating} is an important benchmark circuit, composed of random instances of circuits, and used to measure the Quantum Volume metric (measure of the largest possible quantum circuit that a quantum computer can execute reliably). In particular, the QV benchmark circuit consists of layers of Haar random elements of the special unitary group SU(4) applied between corresponding pairs of qubits in a random bipartition. This bechmark takes as input the number of qubits and depth of the circuit.

\noindent\textbf{\textit{Quantum Fourier Transform (QFT)}}~\cite{shor1994algorithms} is the quantum analogue of the classical Fourier transform to convert a function in the time or spatial domain into its frequency domain representation. Probably the most important quantum algorithm at moments, the Shor's algorithm for the factorization into prime numbers, relies on QFT as a crucial step in factoring large numbers and solving the discrete logarithm problem efficiently on a quantum computer. The QFT building blocks Hadamard, controlled-rotation and swap gates. In our implementation, the QFT application takes the number of qubits as input.

\noindent\textbf{\textit{Quantum Random Circuit (QRC) Sampling}}~\cite{arute2019quantum} is a circuit proposed to demonstrate quantum computational supremacy: sampling from the output distribution of a large ($\approx > 50$ qubits) random quantum circuit is beyond the reach of classical computers, and for this reason, QRC serves as evidence for quantum computational supremacy. The QRC circuit consists of randomly chosen gates, including single-qubit gates and two-qubit gates, applied to a set of qubits. In this work, we use QASM circuits, generated by the the Google Cirq~\cite{isakov2021simulations} circuit used in~\cite{arute2019quantum}. The QRC circuit takes the number of qubits and circuit depth as the input.

\noindent\textbf{\textit{Grover's Circuit}}~\cite{grover1996fast} is another famous important quantum algorithm used for searching unsorted data. The basic building block of Grover's circuit is the so-called Amplitude Amplification (AA) primitive that allows to convert a phase difference in quantum states into an amplitude difference (therefore directly measurable). The AA primitive consists of Hadamard and phase gates. The second building block is the oracle circuit that encodes the information about the target solution that we want to find. In our benchmark, we use a simple oracle circuit that is implemented with a Toffoli gate ~\cite{adedoyin2018quantum}. The Grover's circuit takes as input the number of qubits.

\noindent\textbf{\textit{Greenberger-Horne-Zeilinger (GHZ) Circuit}}~\cite{greenberger1989going} is a circuit designed to create the so-called GHZ state that is a maximally entangled state: all qubits are in a superposition of being either all in the state $\ket{0}$ or all in the state $\ket{1}$. The GHZ state is used in quantum communication. The GHZ consists of a series of Hadamard gates and CNOT gates applied to a set of qubits. The input for the GHZ circuit is the number of qubits.

\noindent\textbf{\textit{1D Quantum Walk (QW)}}~\cite{montanaro2016quantum} is the quantum mechanics version of classical 1D random walks, e.g., a walker is placed in a one dimensional lattice and at each iteration a walker can shift either to the left or right lattice site with equal probability (in the quantum version this is implemented with a coin operator using an Hadamard gate). The beauty of quantum walks is they allow the walker to exist in a superposition of states and paths, making quantum interference effects occur. Instead of randomly choosing a path, a quantum walker follows a set of quantum operators that determine its motion. QWs are used for searching algorithms (similarly to Grover algorithms), quantum linear solvers, and quantum simulations. The basic implementation of QW circuits use right and shift operators (also known as increment and decrement primitives in quantum arithmetic) that are controlled by the coin operator, e.g., depending on the quantum state of the coin operator the walker shifts left or right. Differently, from the previous discussed quantum circuits, QW circuit depth depends on the number of iterations (or QW steps) and tends to be considerably large, even with a relatively small numbers of qubits and iterations.


\subsection{Experimental Setup}
\begin{table}[t]
    \caption{Hardware and software setup.}
    \centering
    \label{tab:exp_setup}
    \begin{tabular}{c|c}
        \toprule
        Setup & Details\\
        \midrule
         \textbf{CPU (\#)} & AMD EPYC (1)\\
         Cores   & 16\\
         Clock frequency   & 3.0 GHz\\
         Memory   & 128 GB DDR4\\
        \midrule
        \textbf{GPU (\#)} & Nvidia A100 (2)\\
        Memory per GPU & 40 GB HBM2 \\
        Theoretical peak memory BW per GPU & 1448 GiB/s \\
        Theoretical peak SP FLOPs per GPU & 10.5 TFLOP/s\\
        \midrule
        Compiler & GCC 8.5.0 \\
        MPI & OpenMPI 4.1.4 \\
        CUDA Toolkit & CUDA 11.5 \\
        Qiskit & 0.12 \\
        cuQuantum & 23.03.0 \\
        \bottomrule
    \end{tabular}
\end{table}
\input{include/scaling_fig}
\input{include/setup_table}

For the experiments, we use a multi-GPU system consisting of one AMD EPYC CPU and two Nvidia A100 GPUs. Details on the specifications of the system and the software environment are provided in Table~\ref{tab:exp_setup}. Since the focus of this work is the evaluation of GPU accelerators for state vector quantum computer simulators, we focus our profiling on the GPUs of the system, using Nvidia Nsight Systems \cite{nvidia_nsys} and Nsight Compute \cite{nvidia_ncu}. After performing scaling experiments, we utilize the Nvidia tools to obtain information regarding: 
\begin{itemize}
    \item distribution of the runtime between GPU kernels and other processes.
    \item GPU kernels occupying the largest portion of the time.
    \item roofline performance evaluation of each benchmark and the most used functions.
    \item memory footprints and data movement within each benchmark.
\end{itemize}



%

%

%

%
%

For each application, we chose a profiling setup that allows us to investigate \textit{(i)} single precision performance on a single GPU and \textit{(ii)} performance under full utilization of the system, i.e. using both GPUs and performing double precision computations. The characteristics of the chosen benchmark setups are shown in Table~\ref{tab:benchmarks_max}. For the single GPU evaluation, for each benchmark the largest number of qubits that was still executable on a single GPU was chosen. Blocking and, thus, multi-GPU execution was enabled in the system, i.e. with any qubit number larger than the one stated in the upper half of Table~\ref{tab:benchmarks_max}, two GPUs have been used automatically. Note that even the largest QW only uses single GPU. The circuit depths for each benchmark are either fixed (QV, RQC) or depend on the number of qubits (all others). In Table~\ref{tab:benchmarks_max}, we present also the total number of gates and the percentage of non-local gates (gates acting on one or more qubits, including controlled gates) \jennifer{after the circuit has been transpiled}.

For all applications, five experiments in sequence (the same circuit run five times in the same program) are carried out and we show the average execution time over the experiments. The variance of the execution time is negligible and therefore we omit the error bars when presenting the execution time. 


