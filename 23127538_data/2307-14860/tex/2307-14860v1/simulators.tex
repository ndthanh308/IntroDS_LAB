\section{Quantum Computer State Vector Simulator}\label{sec:background}
% Figure environment removed
In this work, we focus on simulators using high level abstractions, such as quantum gates and circuits, and the so-called state vector approach that stores all the information about quantum states. \\

\noindent\textbf{Quantum Systems and Transformations with Complex Arrays and Matrices.} In quantum computing, the simplest quantum system is the quantum bit or \emph{qubit}. This is a two-state quantum system that can be expressed with a linear superposition of its two orthonormal basis states (the $\ket{0}$ and $\ket{1}$ states) as $\psi = c_0 \ket{0} + c_1 \ket{1}$, where  $c_0$ and $c_1$ are two complex numbers such that $\|c_0\|^2 + \|c_1\|^2 = 1$. In a state vector simulator, the qubit is represented by a two-element complex-value array as $[c_0 \: c_1]^T$. An important abstraction is the quantum gate that allows us to manipulate the state of a quantum bit. Each quantum gate must be reversible and conserve the total probability of the states to one, to obey to the quantum mechanics law. Examples of single qubit gates are the NOT (or X), rotation gates, and the most famous Hadamard gate to prepare an initial state into equal superposition of states. In state vector quantum computer simulators, each one-qubit gate is expressed as a $2\times2$ unitary matrix  (to enforce the reversibility and conservation of probability). For instance the Hadamard matrix is $\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}$. For a comprehensive description of quantum gates and associated matrices, we refer to quantum computing textbooks~\cite{nielsen2002quantum}. A gate transformation on a qubit is expressed as a matrix-vector multiplication, where the matrix is a gate matrix and the vector is the input state vector. If two or more gates are in sequence, it is possible to calculate the final effect of the gate sequence, by simply multiplying the gate matrices. Because of this approach, the state vector calculations are dominated by small-size matrix-vector multiplications. In practice, quantum simulators do not store matrix information but they are implemented in place (matrix-free). As noted in the seminal paper on HPC state vector simulator~\cite{haner20175}, the basic computational building block of state vector simulator has relatively low arithmetic intensity (a matrix multiplication requires 14 FLOPs and 16B need to be moved when using single precision). 

When we measure the qubit, its quantum state $\psi$ collapses to either basis state of $\ket{0}$ or $\ket{1}$ with probabilities $p_{0} = \|c_0\|^2$ and $p_{1} = \|c_1\|^2 = 1 - \|c_0\|^2$. In a state vector simulator, the measurement outcome in a basis state is simply simulated with a random sampling using the probability $p_1$ and $p_2$ to decide the measurement outcome. Multiple measurements or shots can be modeled with several sampling using the same full state vector calculated by the simulator. Fig.~\ref{fig:simulator} shows an example of a simple state vector quantum computer simulation of a one-qubit circuit with an Hadamard gate. The qubit is initialized in a classical basis state ($\ket{0}$ in the Fig.~\ref{fig:simulator}), corresponding to a state vector $[1 \: 0]^T$. To apply an Hadamard gate, we multiply the Hadamard matrix to the input qubit. As result of this transformation, we obtain the state vector $\frac{1}{\sqrt{2}}[1 \: 1]^T$: the qubit is an equal superposition of the basis states $\ket{0}$ and $\ket{1}$.

In quantum mechanics, quantum systems are combined by using the tensor product. For instance, we can combine two qubit systems $q_1 = [c_0 \: c_1]^T$ and $q_2 = [c_2 \: c_3]^T$ and the result will be a multi-qubit system $q_{q_1 \otimes q_2} = q_1 \otimes q_2 = [c_0 c_2 \: c_0 c_3 \: c_1 c_2 \: c_1 c_3 ]^T$. From this simple example of combining two qubits, it is clear that combining $N$ qubit systems in one multiqubit system will require $2^N$ complex elements in the state vector simulator, leading to an exponential increase of the memory requirements with $N$. For instance, a simulation with 31 qubits requires $2^{31} \times 2 \times 4 / 10^9 \textrm{GB} = 17.2\textrm{GB}$ for the state vector array in single precision.

With multi-qubit systems, we can have one-qubit gate acting in parallel on different qubits: in this case the gate matrix acting on the full state vector can be calculated as the tensor product of the gate matrices. For instance, in the case of a two qubit system with two Hadamard gates, thanks to the tensor product, we can fuse two Hadamard matrices in one $4 \times 4$ matrix acting on the full state vector. In multi-qubit systems, we also have true multi-qubit gates, e.g. transformations that take as input the values of two or more qubits. The archetype of multi-qubit operations are the controlled operations, akin to classical conditional operations: a one-qubit gate/transformation is performed on a target qubit on the condition that a control qubit is in the state $\ket{1}$. An example of multi-qubit gate is the two-qubit C-NOT and three-qubit version of it, called CC-NOT or Toffoli gate. Controlled gates introduce entanglement. When it comes to state vector, multi-qubit operations are still one-qubit operations that act only on selected qubits as determined by the control qubits (this is because of the conditional nature of controlled operations).\\

\noindent\textbf{Qiskit Aer State Vector Simulator.} Qiskit is an open-source software stack, initially released by IBM in 2017, for developing codes for quantum computers at the level of circuits, pulses, and algorithms. The Qiskit Aer component provides a range of high-performance quantum computing simulators, including the state vector simulator we use in this work, and a GPU port by Doi et al.~\cite{doi2019,doi2020cache} using the Thrust library  and recently also a cuQuantum~\cite{the_cuquantum_development_team_2023_7806810} port. The open-source IBM Qiskit Aer programming framework~\cite{QiskitCommunity2017} provides an ideal environment to evaluate state vector performance on GPU and compare it with the CPU version. Fig.~\ref{fig:workflow} shows a high-level description of the workflow when running the IBM Qiskit Aer simulator. 

When running a quantum computer simulator, the first step is to provide a description of the quantum circuit to be executed. In quantum computing, algorithms and codes are expressed as quantum circuits with multi-qubit and a combination of quantum gates and measurements. In Qiskit Aer, this can be formulated in Python code using quantum gates, libraries of quantum gates (for instance the Quantum Volume and QFT circuits) or by loading circuit information from an input file in the QASM format~\cite{cross2017open}, a standard description of circuit in a style reminiscent of classical Assembly.

The second step is the Qiskit Aer transpilation step. This is a critical part of any quantum computing software stack and it is mainly responsible for circuit optimization and mapping to underlying quantum computer topology via several compiler passes. When using the state vector quantum computer simulator, the transpiler is responsible for performance optimization for increasing the computation intensity and minimizing the data movement. For our research, the two critical performance optimization transpiler passes are:

\begin{itemize}
\item \textit{Gate Fusion.} A key performance optimization technique in state vector simulator is to fuse two or more individual gate matrices into a fused matrix. For instance, we can fuse gates acting on different qubits by taking the tensor product of the individual gate matrices acting on different qubits. This will increase the computational intensity of the matrix multiply. It is also possible to fuse two or more gates acting on a single qubit by taking the matrix multiplication (and respecting the order since matrix multiply is not commutative). In Qiskit Aer, the parameter \texttt{fusion\_threshold} determines the threshold that the number of qubits must be greater than or equal to to enable the fusion optimization. The default threshold is 14 qubits.

\item \textit{Cache Blocking.} On multi-GPU systems and in general on distributed memory systems, we need to divide the state vector on different \textit{chunks} (to use Qiskit Aer terminology~\cite{doi2020cache}), similarly to the domain decomposition in parallel computing. In addition to divide the state vector, qubit reordering or remapping are used to decrease data exchanges between large numbers of qubit gates: these techniques require to insert swap gates in quantum circuits. 

\end{itemize}

The result of the Qiskit transpiler step is a new quantum circuit that has been optimized for performance. The new quantum circuit is then simulated by the simulator. Qiskit Aer provides a number of simulator approaches and supported hardware. In this work, we focus on GPU backends for the state vector simulator. In particular, Qiskit Aer provides two backends to enable execution on Nvidia GPUs (including multi-GPU):

\begin{itemize}
\item \textit{Nvidia Thrust.} The default GPU implementation in Qiskit uses Nvidia Thrust. Nvidia Thrust is a C++ template library that provides high-level parallel algorithms and data structures for programming GPUs~\cite{bell2012thrust}. It is part of the CUDA Toolkit, which is a set of tools and libraries provided by Nvidia for developing GPU-accelerated applications. Although Thrust allows developers to write code in C++ and leverage the power of GPUs without needing to directly write CUDA kernels or manage low-level GPU details. %

\item \textit{Nvidia cuQuantum.} Recently, Nvidia provides the cuQuantum SDK for optimized libraries and tools for accelerating quantum computing simulations~\cite{the_cuquantum_development_team_2023_7806810}. cuQuantum currently supports quantum circuit simulations based on state vector and tensor network methods and leverages Nvidia Tensor Core GPUs for speedup. The state vector cuQuantum library is a Qiskit Aer backend and can be easily executed. We note that cuQuantum is installed as binary library. 
\end{itemize}
