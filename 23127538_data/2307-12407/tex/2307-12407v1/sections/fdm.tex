\section{Auto-differentiable and sparsified FDM}\label{sec:method}


\subsection{The force density method (FDM)}\label{sec:method:fdm}

% Graph
The FDM models a structure as a pin-jointed, force network~\cite{schek_force_1974}.
Let $G=(V,E)$ be a graph with $n$ vertices $V$ connected by $m$ edges $E$ encoding this network.
% Supports
One portion of $V$ of size $n_s$ is defined as the supported vertices of the structure $V_s$, i.e., the locations in the structure that are fixed and transfer reaction forces to its anchors.
The remaining $n_u$ unsupported vertices are denoted $V_u$.
% The choice of $V_s$ is arbitrary as long as $V=\{V_u,V_s\}$.

A connectivity matrix $\mathbf{C}\in\{-1,0,1\}^{m\times n}$ encodes the relationship between the edges and the vertices of $G$.
Entry $c_{ij}$ of $\mathbf{C}$ is equal to $1$ if vertex $j$ is the start node of edge~$i$ and equal to $-1$ if vertex $j$ is the end node of edge $i$. Otherwise, $c_{ij}=0$.
Submatrices $\mathbf{C}_u$ and $\mathbf{C}_s$ are formed by the columns of $\mathbf{C}$ corresponding to the unsupported and the supported vertices of $G$, respectively.

% Here we describe the math behind the force density method.
The FDM is a function $f$ that computes a state of static equilibrium $U$ on a fixed graph $G$ given input parameters $\theta$.
% Design parameters
The input parameters $\theta=(\mathbf{q},\mathbf{P},\mathbf{X}_{\text{s}})$ are features defined on the elements of $G$:
\begin{itemize}[topsep=1pt,itemsep=1pt,partopsep=1pt,parsep=1pt]
    \item A diagonal matrix $\mathbf{Q}\in\mathbb{R}^{m\times m}$ with the force densities of the edges, $\mathbf{q}\in\mathbb{R}^{m\times 1}$. The force density $q_{i}$ of edge $i$ is the ratio between the internal force $t_{i}$ and the length $l_{i}$ of the edge, $q_{i}=t_{i}/l_{i}$. A negative $q_i$ indicates compression while a positive one indicates tension.
    \item A matrix $\mathbf{P}\in\mathbb{R}^{n\times3}$ with the 3D vectors denoting the external loads applied to all the vertices of $G$. Submatrices $\mathbf{P}_u\in\mathbb{R}^{n_u\times3}$ and $\mathbf{P}_s\in\mathbb{R}^{n_s\times3}$ correspond to the rows of $\mathbf{P}$ with the loads applied to the vertices $V_u$ and $V_s$, respectively.
    \item A matrix $\mathbf{X}_s\in\mathbb{R}^{n_s\times3}$ containing the 3D coordinates of the supported vertices, $V_s$.
\end{itemize}

% Figure environment removed

% The equilibrium state
The state $U=(\mathbf{X}_u,\mathbf{R}_s,\mathbf{t},\mathbf{l})$ characterizes the static equilibrium configuration of $G$:
\begin{itemize}[topsep=1pt,itemsep=1pt,partopsep=1pt,parsep=1pt]
    \item A matrix $\mathbf{X}_u\in\mathbb{R}^{n_u\times3}$ containing the 3D coordinates in static equilibrium of the unsupported vertices, $V_u$.
    \item A matrix $\mathbf{R}_s\in\mathbb{R}^{n_s\times3}$ with the reaction forces incident to the supported vertices, $V_s$.
    \item A vector $\mathbf{t}\in\mathbb{R}^{m\times 1}$ containing the tensile or compressive internal force of the edges.
    \item A vector $\mathbf{l}\in\mathbb{R}^{m\times 1}$ with the edge lengths.
\end{itemize}

% Form-found coordinates
The key step in the FDM is to find the 3D coordinates in static equilibrium of the free vertices $\mathbf{X}_u$ with Eq.~\ref{eq:xyz_free}:
\begin{equation}\label{eq:xyz_free}
    \mathbf{X}_u = (\mathbf{C}_u^{\text{T}}\mathbf{Q}\mathbf{C}_u)^{-1}
    (\mathbf{P}_u - \mathbf{C}_u^{\text{T}}\mathbf{Q}\mathbf{C}_s\mathbf{X}_s)\,
\end{equation}

The remaining components of $U$ are computed as:
\begin{align}
    % \mathbf{R} &= \mathbf{P} - \mathbf{C}^{\text{T}}\mathbf{Q}\mathbf{C}\mathbf{X}
    \mathbf{R}_s &= \mathbf{P}_s - \mathbf{C}_s^{\text{T}}\mathbf{Q}\mathbf{C}\mathbf{X}
    \label{eq:xyz_reactions} \\
    \mathbf{t} &= \mathbf{q}^{\text{T}}\mathbf{L} \label{eq:forces}
\end{align}
% For a structure to be in static equilibrium, the rows of $\mathbf{R}$ corresponding to $V_u$ must be the null vector.
The matrix of 3D coordinates $\mathbf{X}$ results from concatenating $\mathbf{X}_u$ and $\mathbf{X}_s$.
The diagonal matrix of edge lengths $\mathbf{L}$ can be calculated taking the row-wise L2 norm of the inner product of the connectivity matrix $\mathbf{C}$ and $\mathbf{X}$, $\mathbf{L} = \text{diag}(\lVert\mathbf{C}\,\mathbf{X}\rVert_2)$.

\subsection{Solving inverse form-finding problems}\label{sec:method:inverse}

The desideratum is to design structures in static equilibrium that attain additional architectural, fabrication, or other target properties.

The FDM parametrizes form-finding in terms of $\theta$, simplifying the computation of a state of static equilibrium $U$ to the solution of a linear system. 
However, the relationship between $\theta$ and $U$ is non-linear as linear perturbations in $\theta$ do not correspond to linear changes in $U$.
Moreover, the force densities $\mathbf{q}$ are not interpretable quantities: they express a ratio between the expected forces and lengths in the edges of a structure, but neither of them concretely.
Both issues complicate tackling inverse form-finding problems without an automated approach.

To address these challenges, we solve an unconstrained optimization problem w.r.t.~parameters $\theta$.
Let $g(f(\theta,G))$ be a non-linear goal function that computes a property of interest.
One inverse form-finding problem may contain $K$ different goal functions that are individually scaled by a weight factor $w_k$ and aggregated in a loss function $\mathcal{L}(\theta)$:
\begin{equation}\label{eq:loss}
    \mathcal{L}(\theta)=\sum_{k=1}^{K}w_k\,g_k(f(\theta,G)))
\end{equation} 
We minimize Eq.~\ref{eq:loss} by estimating optimal parameters $\theta^{\star}$ via gradient descent, iteratively updating $\theta$ in the negative direction of the gradient $\nabla_{\theta}\mathcal{L}$.
% over $k$ iterations: $\theta^{k+1}=\theta^{k}-\lambda\nabla_{\theta}\mathcal{L}$.
% Quasi-Netwon optimizers like L-BFGS \cite{nocedal_updating_1980} automatically calculate an adequate step size $\lambda$ to speed up the minimization of the loss function.
We conveniently estimate the required value of $\nabla_{\theta}\mathcal{L}$ with reverse-mode automatic differentiation~\cite{bradbury_jax_2018}.

\subsection{Differentiable sparse solver}\label{sec:method:sparse}

A bottleneck in our solver is the solution of the linear system in Eq.~\ref{eq:xyz_free}. 
Although for small problems we can materialize and invert the full dense coefficient matrix $\mathbf C_u^T \mathbf Q \mathbf C_u$, for larger problems we want to take advantage of the inherent sparsity of $\mathbf C_u$ to get computational speedup, especially as the linear solve is called many times during inverse design.

As sparse solvers have limited support on JAX at the time of writing, we use implicit differentiation to derive a custom differentiable sparse linear solver.
Given that the sparsity pattern only depends on $\mathbf{C}$, which is fixed from the beginning for a given graph $G$, we implement a differentiable map from force densities into the entries of the coefficient matrix in compressed sparse-row (CSR) format.
We then use the adjoint method to implement a custom gradient for \texttt{scipy.sparse.linalg.spsolve} on CPU, and \texttt{jax.experimental.sparse.linalg.spsolve} on GPU. 
On CPU, we use a \texttt{jax.pure\_callback} to ensure the sparse solve is compatible with JIT compilation.
% this works well even when the rest of the code is JIT compiled.

% A particular subtlety of our problem is that the right hand side of the linear system is $\mathbb R^{n \times 3}$. The CPU solver implementation supports efficiently solving this system using a single factorization, but the GPU implementation does not. We therefore need to call the GPU sparse solver $3$ times for each linear solve, significantly slowing down the implementation. In practice, we have found that for most problems the CPU sparse solver is faster than the GPU version.
