\begin{algorithm}[H]
    \caption{Frequency-based Generative Attack Framework}
    \label{optimization_advencoder}

    \begin{algorithmic}[1] % 此处的[1]控制一下算法中的每句前面都有标号 
        \REQUIRE Attacker’s surrogate data point $ x \in \mathcal{D}_{a}$, a pre-trained encoder $g_{\theta}$, max-perturbation constraint $\epsilon$, a fixed noise $z$, adversarial generator parameters  $\theta_{\mathcal{G}}$, hyper-parameters $\alpha$, $\beta$, $\lambda$, temperature parameter $\tau$.
        \ENSURE a universal adversarial noise $\delta$. 
        \STATE {Initiate learning rate $\eta$, batch size $n$.}
        \STATE {Sample a vector $z$ from $\mathcal{N}(0, 1)^{100}$}
        % \STATE {$\delta \longleftarrow \mathcal{G}(z)$}
        % \STATE {Clip $\delta$ to satisfy imperceptibility constraint $\epsilon$}
        % \FOR {$ i = 1 $; $ i < n $; $ i ++ $ }
        %     \STATE {Step C}
        % \ENDFOR
        \WHILE {max iterations or not  converge}
            \STATE {$\delta \longleftarrow \mathcal{G}(z)$}
            \STATE {Clip $\delta$ to satisfy imperceptibility constraint $\epsilon$}
            \IF {Adv-PER}
            \STATE {$x^{adv} \longleftarrow x + \delta$}
            \ENDIF
             \IF {Adv-PAT}
            \STATE {$x^{adv} \longleftarrow  x  \odot (1- m) + \delta  \odot m$}
            \ENDIF
            % \STATE {$x^{adv} \longleftarrow x + \delta$ through Eq.7}
            \STATE {Calculate loss mentioned in \cref{eq:3}} 
            % \STATE {Calculate the Euclidean distance between the HFC of $x^{adv}$ and $x$ through Eq.~(\ref{eq:7})}
            % \STATE {Calculate the adv loss through Eq.~(\ref{eq:6})}
            \STATE {Update $\mathcal{G}$ through backprop}
        \ENDWHILE
        
        % \FORALL {...}
        %     \STATE {Step E}
        % \ENDFOR
        % \IF {condition}
        %     \STATE {Step F}
        % \ENDIF
    \end{algorithmic} 
\end{algorithm}

% \begin{algorithm}[H]
%     \caption{algorithm 1}
%     \begin{algorithmic}[1] % 此处的[1]控制一下算法中的每句前面都有标号 
%         \REQUIRE input
%         \ENSURE output 
%         \STATE {Step A}
%         \STATE {Step B}
%         \FOR {$ i = 1 $; $ i < n $; $ i ++ $ }
%             \STATE {Step C}
%         \ENDFOR
%         \WHILE {$ |E_n| \leq L_1 $}
%             \STATE {Step D}
%         \ENDWHILE
%         \FORALL {...}
%             \STATE {Step E}
%         \ENDFOR
%         \IF {condition}
%             \STATE {Step F}
%         \ENDIF
%     \end{algorithmic} 
% \end{algorithm}