% !TEX root = paper.tex


\begingroup
\allowdisplaybreaks

\section{The Full Calculus for Higher-Order Asynchronous Effects}
\label{sec:appendix}

In this appendix we present \lambdaAEff~with all the higher-order 
extensions discussed in \autoref{sec:higher-order-extensions}.

%%% TERMS %%%

\subsection{Terms}

\begin{center}
  \small
  \begin{align*}
  \intertext{\textbf{Values}}
  V, W
  \bnfis& x                                       & &\text{variable} \\
  \bnfor& \tmunit \bnfor\! \tmpair{V}{W}                                & &\text{unit and pairing} \\
  \bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}    & &\text{left and right injections} \\
  \bnfor& \tmfun{x : X}{M}                        & &\text{function abstraction} \\
  \bnfor& \tmpromise V                            & &\text{fulfilled promise} \\
  \bnfor& \tmbox V                                   & &\text{boxed value}
  \\[1ex]
  \intertext{\textbf{Computations}}
  M, N
  \bnfis& \tmreturn{V}                            & &\text{returning a value} \\
  \bnfor& \tmlet{x}{M}{N}          & &\text{sequencing} \\
  \bnfor& V\,W                                    & &\text{function application} \\
  \bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{product elimination} \\
  \bnfor& \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{}                        & &\text{empty elimination} \\
  \bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}
                                                  & &\text{sum elimination} \\
  \bnfor& \tmopout{op}{V}{M}       & &\text{outgoing signal} \\
  \bnfor& \tmopin{op}{V}{M}          & &\text{incoming interrupt} \\
  \bnfor& \tmwithrest[S]{op}{x}{r}{s}{M}{V}{p}{N}      & &\text{stateful reinstallable interrupt handler} \\
  \bnfor& \tmawait{V}{x}{M}             & &\text{awaiting a promise to be fulfilled} \\
  \bnfor& \tmunbox{V}{x}{M}            & &\text{unboxing a mobile value} \\
  \bnfor& \tmspawn{M}{N}                & &\text{dynamic process creation}
  \\[1ex]
  \intertext{\textbf{Processes}}
    P, Q
  \bnfis& \tmrun M                              & &\text{individual computation} \\
  \bnfor& \tmpar P Q                         & &\text{parallel composition} \\
  \bnfor& \tmopout{op}{V}{P}            & &\text{outgoing signal} \\
  \bnfor& \tmopin{op}{V}{P}              & &\text{incoming interrupt}
  \end{align*}
\end{center}

%%% TYPES %%%

\subsection{Types}

\begin{center}
  \small
  \begin{align*}
  \text{Mobile type $A$, $B$}
  \bnfis& \tybase \bnfor \tyunit \bnfor \tyempty \bnfor \typrod{A}{B} \bnfor \tysum{A}{B} \bnfor \tybox X
  \\[1ex]
  \text{Signal or interrupt signature:}
  \phantom{\bnfis}& \op : A_\op
  \\[1ex]
  \text{Value type $X$, $Y$, $S$}
  \bnfis& A \bnfor \typrod{X}{Y} \bnfor \tysum{X}{Y} \bnfor \tyfun{X}{\tycomp{Y}{(\o,\i)}} \bnfor \typromise{X}
  \\[1ex]
  \text{Computation type:}
  \phantom{\bnfis}& \tycomp{X}{(\o,\i)}
  \\[1ex]
  \text{Process type $\tyC$, $\tyD$}
  \bnfis& \tyrun X \o \i \bnfor \typar \tyC \tyD
  \\[1ex]
  \text{Typing context $\Gamma$}
  \bnfis& \cdot \bnfor \Gamma, x \of X \bnfor \Gamma, \ctxlock
  \end{align*}
\end{center}

%%% TYPE SYSTEM %%%

\subsection{Type System}

\begin{center}
  \small
   %
  \begin{mathparpagebreakable}
  \textbf{Values}
  \\
  \coopinfer{TyVal-Var}{
    X~\text{is mobile} \quad \text{or} \quad \ctxlock \not\in \Gamma'
  }{
    \Gamma, x \of X, \Gamma' \types x : X
  }
  \qquad
  \coopinfer{TyVal-Unit}{
  }{
    \Gamma \types \tmunit : \tyunit
  }
  \qquad
  \coopinfer{TyVal-Pair}{
    \Gamma \types V : X \\
    \Gamma \types W : Y
  }{
    \Gamma \types \tmpair{V}{W} : \typrod{X}{Y}
  }
  \\
  \coopinfer{TyVal-Inl}{
    \Gamma \types V : X
  }{
    \Gamma \types \tminl[Y]{V} : X + Y
  }
  \qquad
  \coopinfer{TyVal-Inr}{
    \Gamma \types W : Y
  }{
    \Gamma \types \tminr[X]{W} : X + Y
  }
  \qquad
  \coopinfer{TyVal-Fun}{
    \Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)}
  }{
    \Gamma \types \tmfun{x : X}{M} : \tyfun{X}{\tycomp{Y}{(\o,\i)}}
  }
  \\
  \coopinfer{TyVal-Promise}{
    \Gamma \types V : X
  }{
    \Gamma \types \tmpromise V : \typromise X
  }
  \qquad
  \coopinfer{TyVal-Box}{
    \Gamma, \ctxlock \types V : X
  }{
    \Gamma \types \tmbox V : \tybox X
  }
  \end{mathparpagebreakable}  
  \mbox{}
  
  \begin{mathparpagebreakable}
  \textbf{Computations}
  \\
  \coopinfer{TyComp-Return}{
    \Gamma \types V : X
  }{
    \Gamma \types \tmreturn{V} : \tycomp{X}{(\o,\i)}
  }
  \qquad
  \coopinfer{TyComp-Let}{
    \Gamma \types M : \tycomp{X}{(\o,\i)}
    \\
    \Gamma, x \of X \types N : \tycomp{Y}{(\o,\i)}
  }{
    \Gamma \types
    \tmlet{x}{M}{N} : \tycomp{Y}{(\o,\i)}
  }
  \\
  \coopinfer{TyComp-Apply}{
    \Gamma \types V : \tyfun{X}{\tycomp{Y}{(\o,\i)}} \\
    \Gamma \types W : X
  }{
    \Gamma \types \tmapp{V}{W} : \tycomp{Y}{(\o,\i)}
  }
  \qquad
  \coopinfer{TyComp-MatchPair}{
    \Gamma \types V : \typrod{X}{Y} \\
    \Gamma, x \of X, y \of Y \types M : \tycomp{Z}{(\o,\i)}
  }{
    \Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{Z}{(\o,\i)}
  }
  \\
  \coopinfer{TyComp-MatchEmpty}{
    \Gamma \types V : \tyempty
  }{
    \Gamma \types \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{} : \tycomp{Z}{(\o,\i)}
  }
  \qquad
  \coopinfer{TyComp-MatchSum}{
    \Gamma \types V : X + Y \\\\
    \Gamma, x \of X \types M : \tycomp{Z}{(\o,\i)} \\
    \Gamma, y \of Y \types N : \tycomp{Z}{(\o,\i)} \\
  }{
    \Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{Z}{(\o,\i)}
  }
  \\
  \coopinfer{TyComp-Signal}{
    \op \in \o \\
    \Gamma \types V : A_\op \\
    \Gamma \types M : \tycomp{X}{(\o,\i)} 
  }{
    \Gamma \types \tmopout{op}{V}{M} : \tycomp{X}{(\o,\i)}
  }
  \qquad
  \coopinfer{TyComp-Interrupt}{
    \Gamma \types V : A_\op \\
    \Gamma \types M : \tycomp{X}{(\o,\i)} 
  }{
    \Gamma \types \tmopin{op}{V}{M} : \tycomp{X}{\opincomp {op} (\o,\i)}
  }
  \\
  \coopinfer{TyComp-ReStPromise}{
    ({\o'} , {\i'}) \mathrel{\order{O \times I}} \i\, (\op) \\
    \Gamma, x \of A_\op, r \of \tyfun{S}{\tycomp{\typromise X}{\big(\emptyset, \{ \op \mapsto ({\o'} , {\i'}) \}\big)}}, s \of S \types M : \tycomp{\typromise X}{(\o',\i')} \\
    \Gamma \types V : S \\
    \Gamma, p \of \typromise X \types N : \tycomp{Y}{(\o,\i)} 
  }{
    \Gamma \types \tmwithrest[S]{op}{x}{r}{s}{M}{V}{p}{N} : \tycomp{Y}{(\o,\i)}
  }        
  \\
  \coopinfer{TyComp-Await}{
    \Gamma \types V : \typromise X \\
    \Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)} 
  }{
    \Gamma \types \tmawait{V}{x}{M} : \tycomp{Y}{(\o,\i)}
  }
  \qquad
  \coopinfer{TyComp-Unbox}{
     \Gamma \types V : \tybox X \\
     \Gamma, x \of X \types M : \tycomp{Y}{(\o, \i)}
   }{
     \Gamma \types \tmunbox{V}{x}{M} : \tycomp{Y}{(\o, \i)}
   }
  \\
  \coopinfer{TyComp-Spawn}{
     \Gamma, \ctxlock \types M : \tycomp{X}{(\o, \i)} \\
     \Gamma \types N : \tycomp{Y}{(\o', \i')}
   }{
     \Gamma \types \tmspawn{M}{N} : \tycomp{Y}{(\o', \i')}
   }
  \qquad
   \coopinfer{TyComp-Subsume}{
      \Gamma \types M : \tycomp{X}{(\o, \i)} \\
      (\o,\i) \order {O \times I} (\o',\i')
    }{
      \Gamma \types M : \tycomp{X}{(\o', \i')}
    }
  \end{mathparpagebreakable}  
  \mbox{}
  
  \begin{mathparpagebreakable}
  \textbf{Processes}
  \\
  \coopinfer{TyProc-Run}{
    \Gamma \types M : \tycomp{X}{(\o,\i)}
  }{
    \Gamma \types \tmrun{M} : \tyrun{X}{\o}{\i}
  }
  \qquad
  \coopinfer{TyProc-Par}{
    \Gamma \types P : \tyC \\
    \Gamma \types Q : \tyD
  }{
    \Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
  }
  \\
  \coopinfer{TyProc-Signal}{
    \op \in \mathsf{signals\text{-}of}{(\tyC)} \\
    \Gamma \types V : A_\op \\
    \Gamma \types P : \tyC 
  }{
    \Gamma \types \tmopout{op}{V}{P} : \tyC
  }
  \qquad
  \coopinfer{TyProc-Interrupt}{
    \Gamma \types V : A_\op \\
    \Gamma \types P : \tyC 
  }{
    \Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
  }  
  \end{mathparpagebreakable}
\end{center}

%%% SEMANTICS (COMPUTATIONS) %%%

\subsection{Small-Step Operational Semantics of Computations}

\begin{center}
  \small
  \begin{align*}
    \intertext{\textbf{Standard computation rules}}
    \tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
    \\[0.5ex]
    \tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
    \\[0.5ex]
    \tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
    \\[0.5ex]
    \mathllap{
      \tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} 
    } &\reduces
    M[V/x]
    \\[0.5ex]
    \mathllap{
      \tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}
    } &\reduces
    N[W/y]
    \\[1ex]
    \intertext{\textbf{Algebraicity of signals, interrupt handlers, awaiting, and process creation}}
    \tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
    \\[0.5ex]
    \tmlet{x}{(\tmwithrest[S]{op}{y}{r}{s}{M}{V}{p}{N_1})}{N_2} &\reduces \\[-0.5ex]
        \tmwithrest[S]{op}{y}{&r}{s}{M}{V}{p}{(\tmlet{x}{N_1}{N_2})}
    \\[0.5ex]
    \tmlet{x}{(\tmawait{V}{y}{M})}{N} &\reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
    \\[0.5ex]
    \tmlet{x}{(\tmspawn{M}{N_1})}{N_2} &\reduces \tmspawn{M}{\tmlet{x}{N_1}{N_2}}
    \\[1ex]
    \intertext{\textbf{Commutativity of signals and process creation with interrupt handlers}}
    \tmwithrest[S]{op}{x}{r}{s}{M}{V}{p}{\tmopout{op'}{W}{N}} &\reduces \\[-0.5ex]
        \tmopout{op'}{W}{&\, \tmwithrest[S]{op}{x}{r}{s}{M}{V}{p}{N}}
    \\[0.5ex]
    \tmwithrest[S]{op}{x}{r}{s}{M_1}{V}{p}{\tmspawn{M_2}{N}} &\reduces \\[-0.5ex]
        \tmspawn{&M_2}{\tmwithrest[S]{op}{x}{r}{s}{M_1}{V}{p}{N}}
    \\[1ex]
    \intertext{\textbf{Interrupt propagation}}
    \tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
    \\[0.5ex]
    \tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
    \\[0.5ex]
    \tmopin{op}{V}{\tmwithrest[S]{op}{x}{r}{s}{M}{W}{p}{N}} &\reduces \tmlet{p}{M\big[V/x , R/r , W/s\big]}{\tmopin{op}{V}{N}}
    \\[-0.5ex]
    \intertext{\hfill\textbf{where} $R \defeq \tmfun{s' \of S}{\tmwithrest[S]{op}{x}{r}{s}{M}{s'}{p}{\tmreturn p}}$}
    \\[-3ex]
    \tmopin{op'}{V}{\tmwithrest[S]{op}{x}{r}{s}{M}{W}{p}{N}} &\reduces \\[-0.5ex]
        \tmwithrest[S]{op}{x}{r}{s}{&\,M}{W}{p}{\tmopin{op'}{V}{N}}
    \quad {\color{rulenameColor}(\op \neq \op')}
    \\[0.5ex]
    \tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
    \\[0.5ex]
    \tmopin{op}{V}{\tmspawn{M}{N}} &\reduces \tmspawn{M}{\tmopin{op}{V}{N}}
    \\[1ex]
    \intertext{\textbf{Awaiting a promise to be fulfilled}}
    \tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
    \\[1ex]
    \intertext{\textbf{Unboxing a mobile value}}
    \tmunbox{\tmbox V}{x}{M} &\reduces M[V/x]
  \end{align*}
  \begin{gather*}
    \intertext{\textbf{Evaluation context rule}}
    \coopinfer{}{
      M \reduces N
    }{
      \E[M] \reduces \E[N]
    }
  \\[1ex]
  \begin{align*}
    \intertext{\textbf{where}}
    \E
    \bnfis& \, [~] 
    \bnfor \tmlet{x}{\E}{N} 
    \bnfor \tmopout{op}{V}{\E}
    \bnfor \tmopin{op}{V}{\E} \\
    \bnfor& \, \tmwithrest[S]{op}{x}{r}{s}{M}{V}{p}{\E}
    \bnfor \tmspawn{M}{\E}  
  \end{align*}
  \end{gather*}    
\end{center}

%%% SEMANTICS (PROCESSES) %%%

\subsection{Small-Step Operational Semantics of Processes}

\begin{center}
\small
  \begin{align*}
  \intertext{\textbf{Individual computations}}
    \coopinfer{}{
      M \reduces N
    }{
      \tmrun M \reduces \tmrun N
    }
  \end{align*}
  \begin{align*}
  \intertext{\textbf{Signal hoisting}}
  \tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
  \\[1ex]
  \intertext{\textbf{Process creation}}
  \tmrun{(\tmspawn{M}{N})} &\reduces \tmpar{\tmrun{M}}{\tmrun{N}}
  \\[1ex]
  \intertext{\textbf{Broadcasting}}
  \tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
  \\[0.5ex]
  \tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
  \\[1ex]
  \intertext{\textbf{Interrupt propagation}}
  \tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
  \\[0.5ex]
  \tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
  \\[0.5ex]
  \tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
  \end{align*}
  \begin{gather*}
    \intertext{\quad\textbf{Evaluation context rule}}
    \quad
    \coopinfer{}{
      P \reduces Q
    }{
      \F[P] \reduces \F[Q]
    }
  \\[1ex]
  \begin{align*}
  \intertext{\textbf{where}}
  \text{$\F$}
  \bnfis& [~]
  \bnfor \tmpar \F Q \bnfor\! \tmpar P \F
  \bnfor \tmopout{op}{V}{\F}
  \bnfor \tmopin{op}{V}{\F}
  \end{align*}
  \end{gather*}
\end{center}

%%% PROCESS TYPE REDUCTION %%%

\subsection{Process Type Reduction}

\begin{center}
  \small
  %  
  \begin{mathparpagebreakable}
  \coopinfer{}{
  }{
    \tyrun{X}{\o}{\i} \tyreduces \tyrun{X}{\o}{\i} 
  }
  \quad
  \coopinfer{}{
  }{
    X \att (\opincompp {ops} {(\o , \i)}) \tyreduces X \att (\opincompp {ops} {(\opincomp {op} {(\o , \i)})})
  }
  \quad
  \coopinfer{}{
    \tyC \tyreduces \tyC' \\
    \tyD \tyreduces \tyD'
  }{
    \typar{\tyC}{\tyD} \tyreduces \typar{\tyC'}{\tyD'}
  }
  \\
  \coopinfer{}{
  }{
    X \att {(\o , \i)} \tyreduces
    \typar{(X \att {(\o , \i)})}{(Y \att {(\o' , \i')})}
  }
  \quad
  \coopinfer{}{
  }{
    Y \att {(\o' , \i')} \tyreduces
    \typar{(X \att {(\o , \i)})}{(Y \att {(\o' , \i')})}
  }
  \end{mathparpagebreakable}
\end{center}



%%% RESULT FORMS %%%

\subsection{Result Forms}

\begin{center}
\small
%
\begin{mathparpagebreakable}
  \textbf{Computations}
  \\
  \coopinfer{}{
    \CompResult {\Psi} {M}
  }{
    \CompResult {\Psi} {\tmopout {op} V M}
  }
  \qquad
  \coopinfer{}{
    \CompResult {\Psi} {N}
  }{
    \CompResult {\Psi} {\tmspawn{M}{N}}
  }
  \qquad
  \coopinfer{}{
    \RunResult {\Psi} {M}
  }{
    \CompResult {\Psi} {M}
  }
  \\
  \coopinfer{}{
  }{
    \RunResult {\Psi} {\tmreturn V}
  }
  \qquad
  \coopinfer{}{
    p \in \Psi
  }{
    \RunResult {\Psi} {\tmawait p x M}
  }
  \\
  \coopinfer{}{
    \RunResult {\Psi \cup \{p\}} {N}
  }{
    \RunResult {\Psi} {\tmwithrest {op} x r s M V p N}
  }
  \\\\
  \textbf{Processes}
  \\
  \coopinfer{}{
    \ProcResult {P}
  }{
    \ProcResult {\tmopout {op} V P}
  }
  \qquad
  \coopinfer{}{
    \ParResult {P}
  }{
    \ProcResult {P}
  }
  \qquad
  \coopinfer{}{
    \RunResult {\emptyset} {M}
  }{
    \ParResult {\tmrun M}
  }
  \qquad
  \coopinfer{}{
    \ParResult P \\
    \ParResult Q
  }{
    \ParResult {\tmpar P Q}
  }
\end{mathparpagebreakable}
\end{center}

\endgroup

