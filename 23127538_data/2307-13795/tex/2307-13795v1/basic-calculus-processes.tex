% !TEX root = paper.tex

\section{A Calculus for Asynchronous Effects: Parallel Processes}
\label{sec:basic-calculus:processes}

We now describe the parallel part of \lambdaAEff. Similarly to the sequential part, we 
present the corresponding syntax, small-step semantics, 
type-and-effect system, and type safety results.

\subsection{Parallel Processes}

To keep the presentation focussed on the asynchronous use of algebraic effects, we 
consider a very simple model of parallelism: a process is either an \emph{individual computation} 
or the \emph{parallel composition} of two processes. To facilitate interactions, processes also  
contain outward propagating \emph{signals} and inward propagating \emph{interrupts}. 

In detail, the syntax of \emph{parallel processes} is given by the following grammar:
\[
  P, Q
  \bnfis \tmrun M
  \,\bnfor\! \tmpar P Q
  \,\bnfor\! \tmopout{op}{V}{P}
  \,\bnfor\! \tmopin{op}{V}{P}
\]
%
Note that processes do not include interrupt handlers---these are local to computations.

Here the number and hierarchy of processes running in parallel is fixed---a limitation that we address
in \autoref{sec:extensions:dynamic-process-creation} by introducing a means to dynamically create new processes.

\subsection{Small-Step Operational Semantics}

We equip the parallel part of \lambdaAEff~with a small-step operational semantics that  
naturally extends the semantics of \lambdaAEff's sequential part from \autoref{sec:basic-calculus:semantics:computations}.
The semantics is defined using a reduction relation $P \reduces Q$, as given in \autoref{fig:processes}.

% Figure environment removed

\paragraph{Individual Computations}
This rule states that, as processes, individual computations evolve according to the small-step
operational semantics $M \reduces N$ we defined in \autoref{sec:basic-calculus:semantics:computations}.

\paragraph{Signal Hoisting}
This rule propagates signals out of individual computations.
Note that we only hoist those signals that have propagated to the outer boundary
of a computation.

\paragraph{Broadcasting}
These rules turn outward moving signals in one process into inward moving interrupts 
for the process parallel to it, while continuing to propagate the signals outwards to any 
further parallel processes. The latter ensures that the semantics is compositional.

\paragraph{Interrupt Propagation}
These three rules simply propagate interrupts inwards into individual computations, 
into all branches of parallel compositions, and past any issued signals.

\paragraph{Evaluation Contexts}
Analogously to the semantics of computations, the semantics of processes presented here also 
includes an evaluation context rule, which allows reductions under \emph{evaluation contexts} 
$\F$. Observe that compared to the evaluation contexts for computations, those for processes
are more standard, in the sense that they do not bind variables. 

\subsection{Type-and-Effect System}
\label{sec:basic-calculus:processes:type-and-effect-system}

Analogously to its sequential part, we also equip \lambdaAEff's parallel part with a type-and-effect system.

\paragraph{Types} The \emph{process types} are designed to match their parallel structure, and 
are given by
\[
  \text{$\tyC$, $\tyD$}
  \bnfis \tyrun X \o \i
  \bnfor \typar \tyC \tyD
\]
Namely, $\tyrun X \o \i$ is a type of an individual computation of type $\tycomp{X}{(\o,\i)}$, and $\typar \tyC \tyD$
is the type of the parallel composition of two processes that respectively have types $\tyC$ and $\tyD$.

\paragraph{Typing Judgements}
\emph{Well-typed processes} are characterised using the judgement
$\Gamma \vdash P : \tyC$. The typing rules are given in \autoref{fig:process-typing-rules}.
While our processes are not currently higher-order, we allow 
non-empty contexts $\Gamma$ to model using libraries and top-level function definitions.

% Figure environment removed

The rules \textsc{TyProc-Run} and \textsc{TyProc-Par} capture the earlier 
intuition about the types of processes matching their parallel structure. The rules 
\textsc{TyProc-Signal} and \textsc{TyProc-Interrupt} are similar to the corresponding 
computation typing rules from \autoref{fig:computation-typing-rules}.

The \emph{signal annotations} of a process type used in \textsc{TyProc-Signal} are calculated as
\[
\mathsf{signals\text{-}of}(\tyrun{X}{\o}{\i}) ~\defeq~ \o
\qquad\qquad
\mathsf{signals\text{-}of}(\typar{\tyC}{\tyD}) ~\defeq~ \mathsf{signals\text{-}of}(\tyC) \sqcup \mathsf{signals\text{-}of}(\tyD)
\]
and the \emph{action of interrupts} on process types extends the action on effect annotations as
\[
\opincomp{op}(\tyrun{X}{\o}{\i}) 
~\defeq~
X \att (\opincomp {op} {(\o , \i)})
\qquad\qquad
\opincomp{op}(\typar{\tyC}{\tyD}) 
~\defeq~
\typar{(\opincomp{op}{\tyC})}{(\opincomp{op}{\tyD})}
\]
by propagating the interrupt towards the types of individual computations. 

It is worth noting that \autoref{fig:process-typing-rules} does not include an analogue  
of the computation subtyping rule \textsc{TyComp-Subsume}. This choice is 
deliberate because as we shall see below, \emph{process types reduce}
in conjunction with the processes they are assigned to, and the outcome   
of process type reduction is generally neither a sub- nor supertype of the original type.


\subsection{Type Safety}
\label{sec:basic-calculus:type-safety:processes}

We conclude summarising the meta-theory of \lambdaAEff~by stating the type safety 
of its parallel part. Analogously to \autoref{sec:basic-calculus:type-safety}, 
we once again split type safety into separate \emph{progress} 
and \emph{preservation} results, and relegate their proofs to \autoref{sec:type-safety}.

We characterise the \emph{result forms} of processes 
by defining two judgements, $\ProcResult P$ and $\ParResult P$, 
and by using the judgement $\RunResult {\Psi} {M}$ from 
\autoref{sec:basic-calculus:type-safety}, as follows:
\begin{mathpar}
  \coopinfer{}{
    \ProcResult {P}
  }{
    \ProcResult {\tmopout {op} V P}
  }
  \qquad
  \coopinfer{}{
    \ParResult {P}
  }{
    \ProcResult {P}
  }
  \qquad
  \coopinfer{}{
    \RunResult {\emptyset} {M}
  }{
    \ParResult {\tmrun M}
  }
  \qquad
  \coopinfer{}{
    \ParResult P \\
    \ParResult Q
  }{
    \ParResult {\tmpar P Q}
  }
\end{mathpar}
%
These judgements express that a process $P$ is in a (top-level) 
result form $\ProcResult {P}$ when, considered as a tree, it has a shape in which 
\emph{all} signals are towards the root, parallel compositions are in 
the intermediate nodes, and individual computation results are at the leaves. 
Importantly, the computation results $\RunResult {\emptyset} {M}$ we use in this definition 
are those from which all signals have been propagated out of 
(as discussed in \autoref{sec:basic-calculus:type-safety}). 

Again, these result forms are operationally final, as captured by the next lemma.

\begin{lem}
\label{lem:results-are-final:processes}
Given a process $P$, such that $\ProcResult {P}$, then there is no $Q$ such that $P \reduces Q$.
\end{lem}

We are now ready to state the progress theorem for the parallel part of \lambdaAEff,
which applies to closed processes and takes the expected form:

\begin{thm}[Progress for processes]
  \label{thm:procprogress}
  Given a well-typed process $\types P : \tyC$, then either
  \begin{enumerate}[(b)]
    \item there exists a process $Q$, such that $P \reduces Q$, or
    \item the process $P$ is already in a (top-level) result form, i.e., we have $\ProcResult {P}$.
  \end{enumerate}
\end{thm}

The preservation theorem for processes that we state below is somewhat non-standard since term reductions 
also evolve effect annotations. In particular, the broadcast rule
\[
  \tmpar{\tmopout{op}{V}{P}}{Q} \reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
\]
and its symmetric counterpart from \autoref{fig:processes} introduce new 
inward propagating interrupts in their right-hand sides that originally do not exist in their left-hand sides. As a result, 
compared to the types one assigns to the left-hand sides of these reduction rules, the types assigned to 
their right-hand sides will need to feature corresponding type-level actions of these interrupts.
We formalise this idea using a \emph{process type reduction} relation $\tyC \tyreduces \tyD$:
\[
  \coopinfer{}{
  }{
    \tyrun{X}{\o}{\i} \tyreduces \tyrun{X}{\o}{\i} 
  }
  \quad
  \coopinfer{}{
  }{
    X \att \opincompp {ops} {(\o , \i)} \tyreduces X \att \opincompp {ops} {(\opincomp {op} {(\o , \i)})}
  }
  \quad
  \coopinfer{}{
    \tyC \tyreduces \tyC' \\
    \tyD \tyreduces \tyD'
  }{
    \typar{\tyC}{\tyD} \tyreduces \typar{\tyC'}{\tyD'}
  }
\]
where we write $\opincompp {ops} {(\o , \i)}$ for a recursively defined \emph{action of a list of interrupts} on $(\o , \i)$:
\[
\opincompp {[]} {(\o , \i)} ~\defeq~ (\o , \i)
\qquad
\opincompp {(\op :: \opsym{ops})} {(\o , \i)} ~\defeq~ \opincomp {op} {(\opincompp {ops} (\o , \i))}
\]

Intuitively, $\tyC \tyreduces \tyD$ describes how process types reduce by being acted upon by 
freshly arriving interrupts.
It is important that we introduce interrupts under an arbitrary enveloping sequence of interrupt actions, 
and not simply as $X \att {(\o , \i)} \tyreduces X \att (\opincomp {op} {(\o , \i)})$,
because we want to ensure that these actions preserve type reductions (see~\srefcase{Lemma}{lem:type-reduction}{3}),
which in turn ensures type preservation of reductions under arbitrary evaluation contexts~$\F$.

Using the process type reduction relation, we state the preservation theorem for the parallel part of 
\lambdaAEff~as follows:

\begin{thm}[Preservation for processes]
  \label{thm:procpreservation}
  Given a well-typed process $\Gamma \types P : \tyC$, such that $P$ can reduce as 
  $P \reduces Q$, then there exists a process type $\tyD$, such 
  that the process type $\tyC$ can reduce as $\tyC \tyreduces \tyD$, 
  and we can type the resulting process as $\Gamma \types Q : \tyD$.
\end{thm}
