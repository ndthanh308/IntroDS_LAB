% !TEX root = paper.tex

\section{Introduction}

Effectful programming abstractions are at the heart of many modern general-purpose 
programming languages. They can increase expressiveness by giving programmers access to first-class 
(delimited) continuations, but often they simply help programmers to write cleaner code, e.g., by 
avoiding having to manage a program's memory explicitly in state-passing style, 
or getting lost in callback hell while programming asynchronous computations.

An increasing number of language designers and programmers are starting to 
embrace \emph{algebraic effects}, 
where one uses algebraic operations \cite{Plotkin:NotionsOfComputation} and 
effect handlers \cite{Plotkin:HandlingEffects} to uniformly, modularly, and 
user-definably express a wide range of effectful behaviour, 
ranging from basic examples such as state, rollbacks, exceptions, 
and nondeterminism \cite{Bauer:AlgebraicEffects}, to advanced applications 
in concurrency \cite{DBLP:conf/pldi/Sivaramakrishnan21} and statistical probabilistic programming 
\cite{Bingham:Pyro}, and even quantum computation \cite{Staton:AlgEffQuantum}.

While covering many examples, the conventional treatment of 
algebraic effects is \emph{synchronous} by nature. In it 
effects are invoked by placing operation calls in one's code, 
which then propagate outwards until they trigger the actual effect, finally yielding 
a result to the rest of the computation that has been \emph{waiting} in a blocked state 
the whole time. While blocking the computation is indeed sometimes necessary, e.g., 
in the presence of general effect handlers that can execute their continuation any 
number of times, it forces all uses of algebraic effects to be synchronous, even when this
is not necessary, e.g., when the effect involves executing 
a remote query to which a response is not needed (immediately).

Motivated by the recent interest in the combination of
asynchrony and algebraic effects \cite{Leijen:AsyncAwait,DBLP:conf/pldi/Sivaramakrishnan21}, 
in this paper we explore what it takes to accompany the
synchronous treatment of algebraic effects with
an \emph{asynchronous} one (in terms of
language design, safe programming abstractions, and a 
self-contained core calculus). At the heart of our approach is the 
decoupling of the execution of algebraic operation calls
into (i) \emph{signalling} that some implementation of an operation needs to be executed, and 
(ii) \emph{interrupting} a running computation with its result, to which the computation can 
react by (iii) \emph{installing interrupt handlers}. Importantly, we show that our 
approach is flexible enough that not all signals need to have a
corresponding interrupt, and vice versa, allowing us to also model 
\emph{spontaneous behaviour}, such as a
user clicking a button or the environment pre-empting a thread.

While we are not the first ones to work on asynchrony for algebraic effects, 
the prior work in this area (in the context of general effect handlers) has 
achieved it by simply \emph{delegating} the actual asynchrony to the respective language backends 
\cite{Leijen:AsyncAwait,DBLP:conf/pldi/Sivaramakrishnan21}. In contrast, in this paper 
we demonstrate how to capture the combination of 
asynchrony and algebraic effects in a \emph{self-contained} core calculus. 
It is important to emphasise that our aim is not to replace general effect handlers,  
but instead to \emph{complement} them with robust primitives 
tailored to asynchrony---as we highlight throughout the paper, our proposed approach is 
algebraic by design, so as to be ready for future extensions with general effect handlers.

\paragraph{Paper Structure}
In \autoref{sec:overview}, we give a high-level overview of our approach to 
asynchrony for algebraic effects. 
%
In Sections~\ref{sec:basic-calculus:computations} 
and \ref{sec:basic-calculus:processes}, we recap our previous work~\cite{Ahman:POPL} on asynchronous algebraic effects
using a core calculus, \lambdaAEff, equipped with a small-step operational semantics and a type-and-effect system. 
In \autoref{sec:higher-order-extensions}, we explore extensions of \lambdaAEff~necessary to accommodate reinstallable 
interrupt handlers, higher-order signal and interrupt payloads, and the dynamic creation of processes,
and prove their type safety.
In \autoref{sec:applications}, we show how these extensions can be used in examples such as pre-emptive multi-threading,
remote function calls, and a parallel variant of runners
of algebraic effects, simplifying the examples in our prior work~\cite{Ahman:POPL}.
We conclude by discussing related and future work in \autoref{sec:conclusion}.

\paragraph{Code}
The paper is accompanied by a \emph{formalisation} of \lambdaAEff's type safety proofs 
in \pl{Agda} \cite{ahman:AeffAgda}, and a \emph{prototype implementation} of \lambdaAEff~in 
\pl{OCaml}, called \pl{{\AE}ff} \cite{pretnar21:AEff}.

In \pl{Agda}, we consider only the well-typed syntax of a 
variant of \lambdaAEff~in which the subtyping rule manifests as an explicit coercion, so as to make working with 
de Bruijn indices less painful. 
Meanwhile, the \pl{{\AE}ff} implementation provides an interpreter and 
a simple typechecker, but does not 
yet support inferring or checking effect annotations. \pl{{\AE}ff} also provides   
a web interface that allows users to interactively click through their programs' executions.
%
It also comes with implementations of all the examples we present in this paper.

Separately, Poulson~\cite{Poulson:AsyncEffectHandling} has shown how to implement \lambdaAEff~
in \pl{Frank} \cite{Convent:DooBeeDooBeeDoo}.
