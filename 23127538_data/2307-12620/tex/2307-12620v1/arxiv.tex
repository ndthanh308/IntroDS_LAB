\RequirePackage{amsmath}


\newcommand{\head}[1]{\ensuremath{\mathit{h}(#1)}} \newcommand{\Head}[1]{\ensuremath{\mathit{H}(#1)}}
\newcommand{\body}[1]{\ensuremath{\mathit{B}(#1)}}

\newcommand{\atom}[1]{\ensuremath{\mathit{A}(#1)}}

\newcommand{\poslits}[1]{\ensuremath{{#1}^+}}
\newcommand{\neglits}[1]{\ensuremath{{#1}^-}}

\newcommand{\pbody}[1]{\poslits{\body{#1}}}
\newcommand{\nbody}[1]{\neglits{\body{#1}}}

\newcommand{\atbody}[2]{\ensuremath{\mathit{B}_{#1}(#2)}}  \RequirePackage{bm}
\RequirePackage{textcomp}
\RequirePackage{upgreek}

\IfFileExists{outline.tex}{\input{outline}}{}

\newcommand{\next}{\text{\rm \raisebox{-.5pt}{\Large\textopenbullet}}}  \newcommand{\previous}{\text{\rm \raisebox{-.5pt}{\Large\textbullet}}}  \newcommand{\wnext}{\ensuremath{\widehat{\next}}}
\newcommand{\wprevious}{\ensuremath{\widehat{\previous}}}
\newcommand{\alwaysF}{\ensuremath{\square}}
\newcommand{\alwaysP}{\ensuremath{\blacksquare}}
\newcommand{\eventuallyF}{\ensuremath{\Diamond}}
\newcommand{\eventuallyP}{\ensuremath{\blacklozenge}}
\IfFileExists{outline.tex}
        {\newcommand{\until}{\ensuremath{\mathbin{\mbox{\outline{$\bm{\mathsf{U}}$}}}}}}
        {\newcommand{\until}{\ensuremath{\mathbin{\bm{\mathsf{U}}}}}}
\IfFileExists{outline.tex}
        {\newcommand{\release}{\ensuremath{\mathbin{\mbox{\outline{$\bm{\mathsf{R}}$}}}}}}
        {\newcommand{\release}{\ensuremath{\mathbin{\bm{\mathsf{R}}}}}}
\IfFileExists{outline.tex}
        {\newcommand{\while}{\ensuremath{\mathbin{\mbox{\outline{$\bm{\mathsf{W}}$}}}}}}
        {\newcommand{\while}{\ensuremath{\mathbin{\bm{\mathsf{W}}}}}}
\newcommand{\since}{\ensuremath{\mathbin{\bm{\mathsf{S}}}}}
\newcommand{\trigger}{\ensuremath{\mathbin{\bm{\mathsf{T}}}}}
\IfFileExists{outline.tex}
        {\newcommand{\finally}{\ensuremath{\mbox{\outline{$\bm{\mathsf{F}}$}}}}}
        {\newcommand{\finally}{\ensuremath{\bm{\mathsf{F}}}}}
\newcommand{\initially}{\ensuremath{\bm{\mathsf{I}}}}

\newcommand{\stp}{\ensuremath{\uptau}}
\mathchardef\mhyphen="2D
\newcommand{\prev}{\ensuremath{\stp^{\mhyphen}}}
\newcommand{\prevs}{\ensuremath{\stp^{\mhyphen *}}}

\newcommand{\dalways}[1]{\ensuremath{[#1]\,}}                        \newcommand{\DBox}[1]{\dalways{#1}}
\newcommand{\deventually}[1]{\ensuremath{\langle#1\rangle\,}}        \newcommand{\DDia}[1]{\deventually{#1}}
\newcommand{\drel}[2]{\ensuremath{{\parallel}{#1}{\parallel}^{#2}}}

\newcommand{\intervcc}[2]{\ensuremath{[#1..#2]}}
\newcommand{\intervco}[2]{\ensuremath{[#1..#2)}}
\newcommand{\intervoc}[2]{\ensuremath{(#1..#2]}}
\newcommand{\intervoo}[2]{\ensuremath{(#1..#2)}}
\newcommand{\rangecc}[3]{\ensuremath{#1 \in \intervcc{#2}{#3}}}
\newcommand{\rangeco}[3]{\ensuremath{#1 \in \intervco{#2}{#3}}}
\newcommand{\rangeoc}[3]{\ensuremath{#1 \in \intervoc{#2}{#3}}}
\newcommand{\rangeoo}[3]{\ensuremath{#1 \in \intervoo{#2}{#3}}}

\newcommand{\cl}[1]{\ensuremath{\mathit{cl}({#1})}}
\newcommand{\last}{\ensuremath{\mathit{last}}}
 \providecommand{\logfont}{\textrm}

\newcommand{\HT}{\ensuremath{\logfont{HT}}}
\newcommand{\EL}{\ensuremath{\logfont{EL}}}

\newcommand{\HTC}{\ensuremath{\logfont{HT}_{\!c}}}

\newcommand{\LTL}{\ensuremath{\logfont{LTL}}}
\newcommand{\LTLf}{\ensuremath{\LTL_{\!f}}}
\newcommand{\LTLo}{\ensuremath{\LTL_{\omega}}}
\newcommand{\THT}{\ensuremath{\logfont{THT}}}
\newcommand{\THTf}{\ensuremath{\THT_{\!f}}}
\newcommand{\THTo}{\ensuremath{\THT_{\!\omega}}}
\newcommand{\TEL}{\ensuremath{\logfont{TEL}}}
\newcommand{\TELf}{\ensuremath{\TEL_{\!f}}}
\newcommand{\TELo}{\ensuremath{\TEL_{\omega}}}
\newcommand{\LDL}{\ensuremath{\logfont{LDL}}}
\newcommand{\LDLf}{\ensuremath{\LDL_{\!f}}}
\newcommand{\LDLo}{\ensuremath{\LDL_{\omega}}}
\newcommand{\DHT}{\ensuremath{\logfont{DHT}}}
\newcommand{\DHTf}{\ensuremath{\DHT_{\!f}}}
\newcommand{\DHTo}{\ensuremath{\DHT_{\!\omega}}}
\newcommand{\DEL}{\ensuremath{\logfont{DEL}}}
\newcommand{\DELf}{\ensuremath{\DEL_{\!f}}}
\newcommand{\DELo}{\ensuremath{\DEL_{\omega}}}
\newcommand{\DL}{\ensuremath{\logfont{DL}}}

\newcommand{\MTL}{\ensuremath{\logfont{MTL}}}
\newcommand{\MTLf}{\ensuremath{\MTL_{\!f}}}
\newcommand{\MTLo}{\ensuremath{\MTL_{\omega}}}
\newcommand{\MHT}{\ensuremath{\logfont{MHT}}}
\newcommand{\MHTf}{\ensuremath{\MHT_{\!f}}}
\newcommand{\MHTo}{\ensuremath{\MHT_{\!\omega}}}
\newcommand{\MEL}{\ensuremath{\logfont{MEL}}}
\newcommand{\MELf}{\ensuremath{\MEL_{\!f}}}
\newcommand{\MELo}{\ensuremath{\MEL_{\omega}}}
 \newcommand{\domain}[1]{\ensuremath{\mathit{dom}(#1)}}

\newcommand{\ass}{\ensuremath{A}}

\newcommand{\tlits}[1]{\ensuremath{{#1}^{\true}}}
\newcommand{\flits}[1]{\ensuremath{{#1}^{\false}}}
\newcommand{\prefix}[2]{\ensuremath{#1[#2]}}

\newcommand{\clno}[1]{\ensuremath{\delta(#1)}}
\newcommand{\ClNo}[1]{\ensuremath{\Delta(#1)}}


\newcommand{\CN}[1]{\ensuremath{\Delta_{#1}}}
\newcommand{\LN}[1]{\ensuremath{\Lambda_{#1}}}

\newcommand{\dl}[0]{\ensuremath{\mathit{dl}}}
\newcommand{\dlevel}[1]{\ensuremath{\mathit{dlevel}(#1)}}
\newcommand{\opp}[1]{\ensuremath{\overline{#1}}}

\newcommand{\scc}[1]{\ensuremath{\mathit{scc}(#1)}}
\newcommand{\source}[1]{\ensuremath{\mathit{source}(#1)}}
 \providecommand{\sysfont}{\textit}

\newcommand{\Abstem}{\sysfont{Abstem}}
\newcommand{\aspviz}{\sysfont{aspviz}}
\newcommand{\aspcorei}{\sysfont{ASP-Core}}
\newcommand{\aspcoreii}{\sysfont{ASP-Core-2}}
\newcommand{\Clingo}{\sysfont{Clingo}}
\newcommand{\clorm}{\sysfont{clorm}}
\newcommand{\clingraph}{\sysfont{clingraph}}
\newcommand{\clinguin}{\sysfont{clinguin}}
\newcommand{\Clingraph}{\sysfont{Clingraph}}
\newcommand{\Gringo}{\sysfont{Gringo}}
\newcommand{\abstem}{\sysfont{abstem}}
\newcommand{\acthex}{\sysfont{acthex}}
\newcommand{\adsolver}{\sysfont{adsolver}}
\newcommand{\anthem}{\sysfont{anthem}}
\newcommand{\asparagus}{\sysfont{asparagus}}
\newcommand{\aspartame}{\sysfont{aspartame}}
\newcommand{\aspcud}{\sysfont{aspcud}}
\newcommand{\aspeed}{\sysfont{aspeed}}
\newcommand{\aspic}{\sysfont{aspic}}
\newcommand{\aspmt}{\sysfont{aspmt}}
\newcommand{\asprilo}{\sysfont{asprilo}}
\newcommand{\asprin}{\sysfont{asprin}}
\newcommand{\assat}{\sysfont{assat}}
\newcommand{\autofolio}{\sysfont{autofolio}}
\newcommand{\berkmin}{\sysfont{berkmin}}
\newcommand{\caspo}{\sysfont{caspo}}
\newcommand{\caspots}{\sysfont{caspo-ts}}
\newcommand{\chasp}{\sysfont{chasp}}
\newcommand{\chuffed}{\sysfont{chuffed}}
\newcommand{\claspD}{\sysfont{claspD}}
\newcommand{\claspar}{\sysfont{claspar}}
\newcommand{\claspfolio}{\sysfont{claspfolio}}
\newcommand{\claspre}{\sysfont{claspre}}
\newcommand{\clasp}{\sysfont{clasp}}
\newcommand{\clingcon}{\sysfont{clingcon}}
\newcommand{\clingo}{\sysfont{clingo}}
\newcommand{\clingodl}{\clingoM{dl}}
\newcommand{\clingolp}{\clingoM{lp}}
\newcommand{\cmodels}{\sysfont{cmodels}}
\newcommand{\coala}{\sysfont{coala}}
\newcommand{\cplex}{\sysfont{cplex}}
\newcommand{\dflat}{\sysfont{dflat}}
\newcommand{\dingo}{\sysfont{dingo}}
\newcommand{\dlvhex}{\sysfont{dlvhex}}
\newcommand{\dlv}{\sysfont{dlv}}
\newcommand{\eclingo}{\sysfont{eclingo}}
\newcommand{\embasp}{\sysfont{embasp}}
\newcommand{\ezcsp}{\sysfont{ezcsp}}
\newcommand{\ezsmt}{\sysfont{ezsmt}}
\newcommand{\fastdownward}{\sysfont{fastdownward}}
\newcommand{\ftolp}{\sysfont{f2lp}}
\newcommand{\gasp}{\sysfont{gasp}}
\newcommand{\gecode}{\sysfont{gecode}}
\newcommand{\gfd}{\sysfont{g12fd}}
\newcommand{\gidl}{\sysfont{gidl}}
\newcommand{\ginkgo}{\sysfont{ginkgo}}
\newcommand{\gnt}{\sysfont{gnt}}
\newcommand{\gringo}{\sysfont{gringo}}
\newcommand{\graphviz}{\sysfont{graphviz}}
\newcommand{\harvey}{\sysfont{harvey}}
\newcommand{\iclingo}{\sysfont{iclingo}}
\newcommand{\idlv}{\sysfont{idlv}}
\newcommand{\idp}{\sysfont{idp}}
\newcommand{\inca}{\sysfont{inca}}
\newcommand{\jdlv}{\sysfont{jdlv}}
\newcommand{\lctocasp}{\sysfont{lc2casp}}
\newcommand{\lparse}{\sysfont{lparse}}
\newcommand{\lpconvert}{\sysfont{lpconvert}}
\newcommand{\lpsolve}{\sysfont{lpsolve}}
\newcommand{\lptodiff}{\sysfont{lp2diff}}
\newcommand{\lptosat}{\sysfont{lp2sat}}
\newcommand{\mchaff}{\sysfont{mchaff}}
\newcommand{\measp}{\sysfont{measp}}
\newcommand{\metasp}{\sysfont{metasp}}
\newcommand{\mingo}{\sysfont{mingo}}
\newcommand{\minisatid}{\sysfont{minisatid}}
\newcommand{\minisat}{\sysfont{minisat}}
\newcommand{\minizinc}{\sysfont{minizinc}}
\newcommand{\mznfzn}{\sysfont{mzn2fzn}}
\newcommand{\nomorepp}{\sysfont{nomore++}}
\newcommand{\oclingo}{\sysfont{oclingo}}
\newcommand{\omiga}{\sysfont{omiga}}
\newcommand{\picatsat}{\sysfont{picatsat}}
\newcommand{\picat}{\sysfont{picat}}
\newcommand{\piclasp}{\sysfont{piclasp}}
\newcommand{\picosat}{\sysfont{picosat}}
\newcommand{\plasp}{\sysfont{plasp}}
\newcommand{\plingo}{\sysfont{plingo}}
\newcommand{\Plingo}{\sysfont{Plingo}}
\newcommand{\qasp}{\sysfont{qasp}}
\newcommand{\quontroller}{\sysfont{quontroller}}
\newcommand{\reify}{\sysfont{reify}}
\newcommand{\rosoclingo}{\sysfont{rosoclingo}}
\newcommand{\sag}{\sysfont{sag}}
\newcommand{\satz}{\sysfont{satz}}
\newcommand{\siege}{\sysfont{siege}}
\newcommand{\smac}{\sysfont{smac}}
\newcommand{\smodelscc}{\sysfont{smodels$_{\!cc}$}}
\newcommand{\smodelsr}{\sysfont{smodels}$_r$}
\newcommand{\smodels}{\sysfont{smodels}}
\newcommand{\stelp}{\sysfont{stelp}}
\newcommand{\sugar}{\sysfont{sugar}}
\newcommand{\teaspoon}{\sysfont{teaspoon}}
\newcommand{\tefoli}{\sysfont{tefoli}}
\newcommand{\telingo}{\sysfont{telingo}}
\newcommand{\tel}{\sysfont{tel}}
\newcommand{\unclasp}{\sysfont{unclasp}}
\newcommand{\wasp}{\sysfont{wasp}}
\newcommand{\xorro}{\sysfont{xorro}}
\newcommand{\zchaff}{\sysfont{zchaff}}
\newcommand{\zzz}{\sysfont{z3}}

\newcommand{\clingoM}[1]{\clingo{\small\textnormal{[}\textsc{#1}\textnormal{]}}}
\newcommand{\ASPm}[1]{ASP\raisebox{.7pt}{[\textsc{#1}]}}

\newcommand{\flatzinc}{\sysfont{FlatZinc}}
\newcommand{\aspif}{\sysfont{aspif}}

\providecommand{\C}{C}
\newcommand{\cpp}{C++}
\newcommand{\haskell}{Haskell}
\newcommand{\java}{Java}
\newcommand{\lua}{Lua}
\newcommand{\prolog}{Prolog}
\newcommand{\python}{Python}
\newcommand{\rust}{Rust}

\newcommand{\tuple}[1]{\ensuremath{\langle #1 \rangle}}
\newcommand{\Htrace}{\ensuremath{\mathbf{H}}}
\newcommand{\Ttrace}{\ensuremath{\mathbf{T}}}
\newcommand{\M}{\ensuremath{\mathbf{M}}}

\newcommand{\handt}{\ensuremath{\langle H,T \rangle}}
\newcommand{\tandt}{\ensuremath{\langle T,T \rangle}}
\newcommand{\thandt}{\ensuremath{\langle \bm{H},\bm{T} \rangle}}
\newcommand{\ttandt}{\ensuremath{\langle \bm{T},\bm{T} \rangle}}


\newcommand{\Bd}{\ensuremath{B}} \newcommand{\Hd}{\ensuremath{H}}

\newcommand{\Stamp}[2]{\ensuremath{#1_{#2}}} \newcommand{\initial}[1]{\ensuremath{\mathit{I}(#1)}} \newcommand{\dynamic}[1]{\ensuremath{\mathit{D}(#1)}} \newcommand{\final}[1]{\ensuremath{\mathit{F}(#1)}}

\newcommand{\module}[1]{\ensuremath{\mathbb{#1}}}
\newcommand{\prog}[1]{\ensuremath{P(#1)}}
\newcommand{\inp}[1]{\ensuremath{I(#1)}}
\newcommand{\out}[1]{\ensuremath{O(#1)}}
\newcommand{\inst}[2]{\ensuremath{#1(#2)}}

\newcommand{\eqdef}{\ensuremath{\mathbin{\raisebox{-1pt}[-3pt][0pt]{$\stackrel{\mathit{def}}{=}$}}}}

\newcommand{\tr}[2]{\ensuremath{\tau}_{\lambda}(#1,#2)} \newenvironment{proofof}[1]{\noindent {\bf Proof of #1.}}{\leavevmode\qed}


\newcommand{\true}{\ensuremath{\boldsymbol{T}}}
\newcommand{\false}{\ensuremath{\boldsymbol{F}}}

\newcommand{\Tl}[1]{\ensuremath{\true{#1}}}
\newcommand{\Fl}[1]{\ensuremath{\false{#1}}}

\newcommand{\tTl}[2]{\ensuremath{\true{#1}_{#2}}}
\newcommand{\tFl}[2]{\ensuremath{\false{#1}_{#2}}}


\newcommand{\tng}[2]{\ensuremath{#1[#2]}}
\newcommand{\tngo}[2]{\ensuremath{#1[#2)}}

\newcommand{\slice}[2]{\ensuremath{P_{#1}^{#2}}}
\newcommand{\treduct}[2]{\ensuremath{#1^{#2}}}

\newcommand{\prelits}[1]{\ensuremath{#1^{\star}}} \newcommand{\paslits}[1]{\ensuremath{#1^{\previous}}}

\newcommand{\abody}[2]{\ensuremath{B_{#1}(#2)}}

\newcommand{\A}{\ensuremath{\mathcal{A}}}
\newcommand{\B}{\ensuremath{\mathcal{B}}}
\newcommand{\D}{\ensuremath{\mathcal{D}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}

\newcommand{\tCF}[1]{\ensuremath{CF(#1)}}
\newcommand{\tCFa}[2]{\ensuremath{CF_#1(#2)}}
\newcommand{\TG}[1]{\ensuremath{TG(#1)}}

\newcommand{\naf}[1]{\ensuremath{{\neg{#1}}}} \newcommand{\Lab}[1]{\ensuremath{{\ell_{#1}}}}
\newcommand{\Tra}[1]{\ensuremath{{\eta(#1)}}}

\newcommand{\Def}[1]{\mathbf{Def}(#1)}

\newcommand{\X}{\ensuremath{\mathbf{X}}}
\newcommand{\Y}{\ensuremath{\mathbf{Y}}}

\newcommand{\sq}{\ensuremath{s(q)}}

\newcommand{\trivaluation}[3]{\ensuremath{\bm{#3}(#1,#2)}}
\newcommand{\trival}[2]{\trivaluation{#1}{#2}{m}} \newcommand{\trivalp}[2]{{\bm{m'}}(#1,#2)}


\newcommand{\Atoms}[1]{\ensuremath{Atoms(#1)}}
\newcommand{\LF}[1]{\ensuremath{\mathit{LF}(#1)}}
\newcommand{\Graph}[1]{\ensuremath{\mathit{G}(#1)}}
\newcommand{\Loops}[1]{\ensuremath{\mathit{L}(#1)}}
\newcommand{\support}[2]{\ensuremath{\mathit{S}_{#2}(#1)}}
\newcommand{\myatom}{\ensuremath{p}}

\renewcommand{\H}{\ensuremath{\mathbf{H}}} \newcommand{\T}{\ensuremath{\mathbf{T}}}

\newcommand{\intervo}[2]{[#1..#2)}
\newcommand{\rangeo}[3]{#1 \in \intervo{#2}{#3}}
\newcommand{\intervc}[2]{[#1..#2]}
\newcommand{\rangec}[3]{#1 \in \intervc{#2}{#3}}
\newcommand{\TS}{\ensuremath{\mathrm{TS}}}


\documentclass[a4paper]{llncs}
\renewcommand{\next}{\text{\rm \raisebox{-.5pt}{\Large\textopenbullet}}}  \usepackage[utf8]{inputenc}
\usepackage{amssymb}


\usepackage{url}\urlstyle{tt}

\hbadness=10000
\vbadness=10000
\hfuzz=1000pt
\vfuzz=1000pt

\begin{document}

\title{Past-present temporal programs over finite traces}
\author{Pedro Cabalar\inst{1} \and
	Mart\'in Di\'eguez\inst{2} \and
	Fran\c{c}ois Laferri\`ere\inst{3} \and
	Torsten Schaub\inst{3,4}
}
\authorrunning{Cabalar et al.}

\institute{
$^1$ University of Corunna, Spain\\$^2$ University of Angers, France\\$^3$ University of Potsdam, Germany\\$^4$ Potassco Solutions, Germany
}



\maketitle

\begin{abstract}
Extensions of Answer Set Programming with language constructs from temporal logics,
such as temporal equilibrium logic over finite traces (\TELf), provide an expressive
computational framework for modeling dynamic applications.
In this paper, we study the so-called past-present syntactic subclass, which consists
of a set of logic programming rules whose body references to the past and head to
the present. Such restriction ensures that the past remains independent of the future,
which is the case in most dynamic domains.
We extend the definitions of completion and loop formulas to the case of past-present
formulas, which allows capturing the temporal stable models of a set of past-present temporal programs by
means of an \LTLf expression.
\end{abstract}
 \section{Introduction}\label{sec:introduction}

The representation and reasoning on dynamic scenarios is a central problem in the areas of  Knowledge Representation~\cite{bale04} (KR) and Artificial Intelligence (AI).
Several formal approaches and systems have emerged in order to introduce non-monotonic reasoning features in scenarios where the formalisation of time is fundamental~\cite{emerson90a,BaralZ08,BaralZ07,sandewall94a,Gonzalez2002}.

In the area of \emph{Answer Set Programming}~\cite{breitr11a} (ASP), former approaches to temporal reasoning use first-order encodings~\cite{lifschitz99b} where the time is represented by means of a variable whose value comes from a finite domain.
The main advantage of those approaches is that the computation of the answer sets of the previous approaches can be achieved via incremental solving~\cite{gekakaosscth08a}.
Their downside is that they require an explicit representation of time points.

\emph{Temporal Equilibrium Logic}~\cite{cabper07a,AguadoCDPSSV23} (\TEL{}) was proposed as a temporal extension of \emph{Equilibrium Logic}~\cite{pearce96a,pearce06a}
with connectives from the modal temporal logics, \emph{Linear Time Temporal Logic}~\cite{pnueli77a} (\LTL{}).
Due to the computational complexity of its satisfiability problem (\textsc{ExpSpace}), finding tractable fragments of \TEL{} with good computational properties have also been a topic in the literature.
Within this context, the so-called \emph{splittable temporal logic programs}~\cite{agcapevi11a} have been proved to be a syntactic fragment of \TEL{} that allows a reduction to \LTL{} via the use of Loop Formulas~\cite{feleli06a}.

When considering incremental solving, logics on finite traces such as \LTLf{}~\cite{giavar13a} have been shown to be more suitable.
Accordingly, \emph{Temporal Equilibrium Logic on Finite traces}(\TELf)~\cite{cakascsc18a} was created and became the foundations of the temporal ASP solver \telingo{}~\cite{cakamosc19a}.




We present a new syntactic fragment of \TELf{}, named \emph{past-present} temporal logic programs.
Inspired by Gabbay's seminal paper~\cite{gabbay87a}, where the declarative character of past temporal operators is emphasized, this new language consists of a set of logic programming rules whose formulas in the head are disjunctions of atoms that reference the present, while in its body we allow any arbitrary temporal formula without the use of future operators.

The use of only past operators in the body has the advantage that, when using incremental solving, the body of each rule can be seen as a query whose satisfiability can be checked on the (partial) incremental computation at each step.


As a contribution, we study the Lin-Zhao theorem~\cite{linjzh03a} within the context of past-present temporal logic programs.
More precisely we show that when the program is \emph{tight}~\cite{erdlif03a}, extending Clark's completion~\cite{clark78a,fages94a} to the temporal case suffices to capture the answer sets of a finite past-present program $\Pi$ as the \LTLf{}-models of a temporal formula $\varphi$.

We also show that, when the program is not tight, the use of loop formulas is necessary. To this purpose, we  extend the definition of loop formulas to the case of past-present programs and we prove the Lin-Zhao theorem in our setting.
Finally, we also prove the generalisation of Lin-Zhao theorem in the sense of~\cite{feleli06a}, where the computation of the completion is be replaced by the consideration of unitary loops.

The paper is organised as follows: in Section~\ref{sec:background} we introduce the logic of temporal here and there over finite traces and its equilibrium counterpart.
In Section~\ref{sec:ppp} we introduce the concept of past-present temporal programs while, in Section~\ref{sec:tcompletion} we extend the completion property to the temporal case and we prove that, for the case of tight programs, computing the temporal completion suffices to characterise the temporal answer sets of a past-present programs in terms of \LTLf{} formulas.
The non-tight case is studied in Section~\ref{sec:lf}, where we introduce our temporal extension of loop formulas and extend the results presented in Section~\ref{sec:tcompletion} to the case of non-tight programs.
Our last contribution, presented in Section~\ref{sec:unitary-cycles}, shows that temporal completion can be captured in the general theory of loop formulas by considering unitary cycles.
Finally, in Section~\ref{sec:conclusions} we present the conclusions of the paper an we outline some future research lines.
 \section{Background}\label{sec:background}
For this paper to be self-contained, we first recall the definitions of \emph{Temporal Here-and-There over finite traces} (\THTf{} for short)\ and its non-monotonic counterpart \emph{Temporal Equilibrium Logic over finite traces} (\TELf)\ as in~\cite{AguadoCDPSSV23}.
All logics treated in this paper share the common syntax of \LTL{} with past operators~\cite{emerson90a}.
We start from a given set $\mathcal{A}$ of atoms which we call the \emph{alphabet}.
Then, \emph{temporal formulas} $\varphi$ are defined by the grammar:
\[
\varphi ::= a \mid \bot \mid \varphi_1 \otimes \varphi_2 \mid \previous\varphi \mid \varphi_1 \since \varphi_2 \mid \varphi_1 \trigger \varphi_2 \mid \next \varphi \mid \varphi_1 \until \varphi_2 \mid \varphi_1 \release \varphi_2
\]
where $a\in\A$ is an atom and $\otimes$ is any binary Boolean connective $\otimes \in \{\to,\wedge,\vee\}$.



The intended meaning of the (modal) temporal operators is as in the \LTL{} case.
Several equivalences from propositional and temporal logics also hold in \THTf{}:
\(
\top \eqdef \neg \bot
\),
\(
\neg \varphi \eqdef  \varphi \to \bot
\),
\(
\varphi \leftrightarrow \psi \eqdef (\varphi \to \psi) \wedge (\psi \to \varphi)
\),
$\alwaysP \varphi  \eqdef \bot \trigger \varphi$,
$\eventuallyP \varphi   \eqdef  \top \since \varphi$,
$\initially \eqdef  \neg \previous \top$,
$\wprevious \varphi   \eqdef  \previous \varphi \vee \initially$,
$\alwaysF \varphi   \eqdef  \bot \release \varphi$,
$\eventuallyF \varphi   \eqdef  \top \until \varphi$,
$\finally   \eqdef  \neg \next \top$ and
$\wnext \varphi   \eqdef  \next \varphi \vee \finally$.


A \emph{(temporal) theory} is a (possibly infinite) set of temporal formulas.

Given $a \in \mathbb{N}$ and $b \in \mathbb{N} \cup \{\omega\}$,
we let $\intervc{a}{b}$ stand for the set $\{i \in \mathbb{N} \mid a \leq i \leq b\}$, $\intervo{a}{b}$ for $\{i \in \mathbb{N} \mid a \leq i < b\}$ and $\intervoc{a}{b}$ for $\{i \in \mathbb{N} \mid a < i \leq b\}$.
A \emph{trace} \T\ of length $\lambda$ over alphabet \A\ is
a sequence $\T=(T_i)_{\rangeo{i}{0}{\lambda}}$ of sets $T_i\subseteq\A$.
We say that \T\ is \emph{infinite} if $\lambda=\omega$ and \emph{finite} otherwise.
To represent a given trace, we write a sequence of sets of atoms concatenated with `$\cdot$'.
For instance, the finite trace $\{a\} \cdot \emptyset \cdot \{a\} \cdot \emptyset$ has length 4 and makes $a$ true at even time points and false at odd ones.


A \emph{Here-and-There trace} (for short \emph{\HT-trace}) of length $\lambda$ over alphabet \A\ is
a sequence of pairs
\(
(\tuple{H_i,T_i})_{\rangeo{i}{0}{\lambda}}
\)
with $H_i\subseteq T_i$ for any $\rangeo{i}{0}{\lambda}$.
For convenience, we usually represent the \HT-trace as the pair $\tuple{\Htrace,\Ttrace}$ of traces $\Htrace = (H_i)_{\rangeo{i}{0}{\lambda}}$ and $\T = (T_i)_{\rangeo{i}{0}{\lambda}}$.
Given $\M=\tuple{\Htrace,\Ttrace}$, we also denote its length as $|\M| \eqdef |\Htrace|=|\T|=\lambda$.
Note that the two traces \Htrace, \T\ must satisfy a kind of order relation, since $H_i \subseteq T_i$ for each time point $i$.
Formally, we define the ordering $\Htrace \leq \T$ between two traces of the same length $\lambda$ as $H_i\subseteq T_i$ for each $\rangeo{i}{0}{\lambda}$.
Furthermore, we define $\Htrace<\T$ as both $\Htrace\leq\T$ and $\Htrace\neq\T$.
Thus, an \HT-trace can also be defined as any pair $\tuple{\Htrace,\Ttrace}$ of traces such that $\Htrace \leq \T$.
The particular type of \HT-traces satisfying $\Htrace=\T$ are called \emph{total}.

\begin{definition}[\THT-satisfaction;~\cite{agcadipevi13a,cakascsc18a}]\label{def:dht:satisfaction}An \HT-trace $\M=\tuple{\Htrace,\Ttrace}$ of length $\lambda$ over alphabet \A\
  \emph{satisfies} a temporal formula $\varphi$ at time point $\rangeo{k}{0}{\lambda}$,
  written \mbox{$\M,k \models \varphi$}, if the following conditions hold:
  \begin{enumerate}
  \item $\M,k \models \top$ and  $\M,k \not\models \bot$
  \item $\M,k \models \myatom$ if $\myatom \in H_k$ for any atom $\myatom \in \A$
  \item $\M, k \models \varphi \wedge \psi$
    iff
    $\M, k \models \varphi$
    and
    $\M, k \models \psi$
  \item $\M, k \models \varphi \vee \psi$
    iff
    $\M, k \models \varphi$
    or
    $\M, k \models \psi$
  \item $\M, k \models \varphi \to \psi$
    iff
    $\langle \mathbf{H}', \mathbf{T} \rangle, k \not \models \varphi$
    or
    $\langle \mathbf{H}', \mathbf{T} \rangle, k \models  \psi$, for all $\mathbf{H'} \in \{ \mathbf{H}, \mathbf{T} \}$
  \item $\M, k \models \previous \varphi$
    iff
    $k>0$ and $\M, k{-}1 \models \varphi$
  \item $\M, k \models \varphi \, \since \, \psi$
    iff
    for some $\rangec{j}{0}{k}$, we have
    $\M, j \models \psi$
    and
    $\M, i \models \varphi$ for all $\rangeoc{i}{j}{k}$
  \item $\M, k \models \varphi \trigger \psi$
    iff
    for all $\rangec{j}{0}{k}$, we have
    $\M, j \models \psi$
    or
    $\M, i \models \varphi$ for some $\rangeoc{i}{j}{k}$
  \item $\M, k \models \next \varphi$
    iff
    $k+1<\lambda$ and $\M, k{+}1 \models \varphi$
  \item $\M, k \models \varphi \until \psi$
    iff
    for some $\rangeo{j}{k}{\lambda}$, we have
    $\M, j \models \psi$
    and
    $\M, i \models \varphi$ for all $\rangeo{i}{k}{j}$
  \item $\M, k \models \varphi \release \psi$
    iff
    for all $\rangeo{j}{k}{\lambda}$, we have
    $\M, j \models \psi$
    or
    $\M, i \models \varphi$ for some $\rangeo{i}{k}{j}$
\end{enumerate}
 \qed
\end{definition}




An \HT-trace $\M$ is a \emph{model} of a temporal theory $\Gamma$ if $\M,0 \models \varphi$ for all $\varphi \in \Gamma$.
We omit specifying \LTL\ satisfaction since it coincides with \THT\ when \HT-traces are total.
\begin{proposition}[\cite{agcadipevi13a,cakascsc18a}]\label{prop:total}
Let \T\ be a trace of length $\lambda$, $\varphi$ a temporal formula, and $k\in\intervo{0}{\lambda}$ a time point.
Then,
$\Ttrace,k \models \varphi$ in \LTL\ iff $\tuple{\Ttrace,\Ttrace},k \models \varphi$.\qed
\end{proposition}




A formula $\varphi$ is a \emph{tautology} (or is \emph{valid}), written $\models \varphi$,
iff $\M,k \models \varphi$ for any \HT-trace \M\ and any $\rangeo{k}{0}{\lambda}$.


\begin{proposition}[Persistence]\label{prop:persistance}
  Let $\tuple{\Htrace,\Ttrace}$ be an \HT-trace of length $\lambda$ and $\varphi$ be a temporal formula.
Then, for any $\rangeo{k}{0}{\lambda}$, $k \neq \omega$,
  if $\tuple{\Htrace,\Ttrace}, k \models \varphi$ then $\tuple{\Ttrace,\Ttrace}, k \models \varphi$ (or, if preferred, $\Ttrace,k \models \varphi$).\qed
\end{proposition}
As a corollary, we have that
$\langle\mathbf{H},\mathbf{T}\rangle \models \neg \varphi$ iff ${\T} \not\models \varphi$ in \LTL{}.

Given a set of \THT-models, we define the ones in equilibrium as follows.
\begin{definition}[Temporal Equilibrium/Stable Model]\label{def:tem}
Let $\mathfrak{S}$ be some set of \HT-traces.

A total \HT-trace $\tuple{\Ttrace,\Ttrace} \in\mathfrak{S}$ is a \emph{temporal equilibrium model} of $\mathfrak{S}$ iff
there is no other $\Htrace < \T$ such that $\tuple{\Htrace,\Ttrace} \in\mathfrak{S}$.

The trace \T\ is called a \emph{temporal stable model} (\TS-model) of $\mathfrak{S}$.
\qed
\end{definition}

\section{Past-present programs}\label{sec:ppp}

Given alphabet $\mathcal{A}$, a \emph{pure past formula} $\varphi$ is defined by the grammar:
\[
\varphi ::= a \mid \bot \mid \neg\varphi \mid \varphi_1 \wedge \varphi_2\mid \varphi_1 \vee \varphi_2 \mid \previous\varphi \mid \varphi_1 \since \varphi_2 \mid \varphi_1 \trigger \varphi_2.
\]
where $a\in\mathcal{A}$.

\begin{definition}[Past-present Program]
Given alphabet $\mathcal{A}$, the set of \emph{temporal literals} is defined  as
$\{a, \neg a, \previous a, \neg \previous  a \mid a \in \mathcal{A}\}$.
We refer to its subset $\{a, \neg a \mid a \in \mathcal{A}\}$ as \emph{regular literals},
and $\{\previous a, \neg \previous a \mid a \in \mathcal{A}\}$ as \emph{past literals}.

A \emph{past-present rule} is either:
\par
\begin{tabular}{l@{\quad}r@{\;}c@{\;}l}
\hspace{\itemindent} \ {\labelitemi} \ an \emph{initial rule} of form &                           $\Hd$ & $\leftarrow$ & $\Bd$     \\
\hspace{\itemindent} \ {\labelitemi} \ a  \emph{dynamic rule} of form &  $\wnext\,\alwaysF (       \Hd$ & $\leftarrow$ & $\Bd)$    \\
\hspace{\itemindent} \ {\labelitemi} \ a  \emph{final   rule} of form &  $\alwaysF(\,\finally \to (\bot$ & $\leftarrow$ & $\Bd )\,)$
\end{tabular}
\par
where $\Bd$ is an pure past formula for dynamic rules and $\Bd=b_1 \wedge \dots \wedge b_n$
with $n\geq 0$ for initial and final rules, the $b_i$ are regular literals,
$\Hd=a_1 \vee \dots \vee a_m$ with $m \geq 0$ and $a_j\in \mathcal{A}$.
A \emph{past-present program} is a set of past-present rules.
\end{definition}


We let \initial{P}, \dynamic{P}, and \final{P} stand for the set of all initial, dynamic, and final rules in a temporal
program $P$, respectively.
Additionally we refer to \Hd\ as the \emph{head} of a rule $r$ and to \Bd\ as the \emph{body} of $r$.
We let $\body{r}=B$ and $\Head{r}=H$ for all types of rules above.


For example, let consider the following past-present program $P_1$:
\begin{align}
                   &load \leftarrow  \label{r1}\\
                   \wnext\alwaysF(&shoot \vee load \vee unload \leftarrow \ ) \label{r2}\\
                   \wnext\alwaysF(&dead  \leftarrow shoot \wedge \neg unload \since load)\label{r3}\\
                   \wnext\alwaysF(&shoot  \leftarrow dead)\label{r4}\\
                   \alwaysF(&\finally \to (\bot \leftarrow\neg dead))\label{r5}
\end{align}

We get $\initial{P_1}=\{(\ref{r1})\}$, $\dynamic{P_1}=\{(\ref{r2}), (\ref{r3}), (\ref{r4})\}$, and $\final{P_1}=\{(\ref{r5})\}$.
Rule~(\ref{r1}) states that the gun is initially loaded.
Rule~(\ref{r2}) give the choice to shoot, load, or unload the gun.
Rule~(\ref{r3}) states that if the gun is shot while it has been loaded, and not unloaded since, the target is dead.
Rule~(\ref{r4}) states that if the target is dead, we shoot it again.
Rule~(\ref{r5}) ensure that the target is dead at the end of the trace.
For length $\lambda = 0$, $P_1$ has a unique \TS-model $\{load\}\cdot\{shoot, dead\}$.
 \section{Temporal completion}\label{sec:tcompletion}

\begin{definition}[Positive occurence]
An occurrence of an atom in a formula is positive if it is in the antecedent of an even number of implications,
negative otherwise.
\end{definition}

\begin{definition}[Present occurence]
An occurrence of an atom in a formula is present if it is not in the scope of $\previous$ (previous).
\end{definition}

\begin{definition}[Dependency graph]
      Given a past-present program $P$ over $\mathcal{A}$,
      we define its (positive) \emph{dependency graph}
      \Graph{P} as $(\mathcal{A}, E)$ such that
      $(a,b) \in E$ if there is a rule $r\in P$ such that $a\in\Head{r}\cap\mathcal{A}$ and $b$
      has positive and present occurence in $\body{r}$  that is not in the scope of negation.
\end{definition}

\begin{definition}[Loop]
  A nonempty set $L\subseteq \mathcal{A}$ of atoms is called $\emph{loop}$ of $P$ if, for every pair $a,b$ of atoms in $L$,
  there exists a path of length $> 0$ from $a$ to $b$ in \Graph{P} such that all vertices in the path belong to $L$.
\end{definition}

We let \Loops{P} denote the set of loops of $P$.
Due to the structure of past-present programs, dependencies from the future to the past cannot happen,
and therefore there can only be loops within a same time point.
To reflect this, the definitions above only consider atoms with present occurences.
For example, rule $a\leftarrow b\wedge \previous c$ generate the edge $(a,b)$ but not $(a,c)$.

\begin{definition}[Tight program]
    A past-present program $P$ is said to be \emph{tight} if $\initial{P}$ and
    $\dynamic{P}$ do not contain any loop.
\end{definition}

For $P_1$, we get for the initial rules
\begin{align*}
    \Graph{\initial{P_1}}&=(\{load, unload, shoot, dead\},\emptyset)\\
    \Loops{\initial{P_1}}&=\emptyset
\end{align*}
and for the dynamic rules,
\begin{align*}
    \Graph{\dynamic{P_1}}&=(\{load, unload, shoot, dead\},\{(dead,shoot), (dead, load), (shoot, dead)\})\\
    \Loops{\dynamic{P_1}}&=\{\{shoot, dead\}\}
\end{align*}

\begin{definition}[Temporal completion]
    We define the temporal \emph{completion} formula of an atom $a$ in a past-present program $P$ over \A, denoted \tCFa{P}{a} as:

        \begin{align*}
            \alwaysF\big( a \leftrightarrow
                \ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
            \vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))\big)
        \end{align*}

where  \(
  S(r,a) = \body{r}\wedge \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p
  \).

  The temporal \emph{completion} formula of $P$, denoted \tCF{P} is

    \begin{align*}
        \{\tCFa{P}{a}	\mid a\in\A\}
        \cup\ \{r\mid r\in \initial{P}\cup\dynamic{P}, \Head{r}=\bot\}
        \cup \final{P}
        \end{align*}

\end{definition}

\begin{theorem}\label{thm:tcompletion}
    Lets $P$ be a tight past-present program and \T\ a trace of length $\lambda$.
    Then, \T\ is a \TS-model of $P$ iff \T\ is a \LTLf-model of \tCF{P}.
\end{theorem}


The completion of $P_1$, $\tCF{P_1}$ is
\begin{align*}
                   \alwaysF(&load \leftrightarrow \initially \vee
                                                   (\neg\initially\wedge \neg shoot \wedge \neg unload))\\
                   \alwaysF(&shoot \leftrightarrow (\neg\initially\wedge \neg load \wedge \neg unload))
                                                   \vee (\neg\initially\wedge dead)) \\
                   \alwaysF(&unload \leftrightarrow (\neg\initially\wedge \neg shoot \wedge \neg load)) \\
                   \alwaysF(&dead \leftrightarrow (\neg\initially\wedge shoot \wedge \neg unload \since load)) \\
                   \alwaysF(&\finally \to (\bot \leftarrow\neg dead))
\end{align*}

For $\lambda=2$, $\tCF{P_1}$ has a unique \LTLf-model $\{load\}\cdot\{shoot, dead\}$,
which is identical to the \TS-model of $P_1$.
Notice that for this example, the \TS-models of the program match the \LTLf-models
of its completion despite the program not being tight. It is generally not the case.
Let $P_2$ be the program made of the rules $(\ref{r1}), (\ref{r3}), (\ref{r4})$ and $(\ref{r5})$.
The completion of $P_2$, $\tCF{P_2}$ is
\begin{align*}
                   \alwaysF(&load \leftrightarrow \initially)\\
                   \alwaysF(&shoot \leftrightarrow (\neg\initially\wedge dead)) \\
                   \alwaysF(&unload \leftrightarrow \bot)\\
                   \alwaysF(&dead \leftrightarrow (\neg\initially\wedge shoot \wedge \neg unload \since load)) \\
                   \alwaysF(&\finally \to (\bot \leftarrow\neg dead))
\end{align*}
$P_2$ does not have any \TS-model, but $\{load\}\cdot\{shoot, dead\}$ is a \LTLf-model of $\tCF{P_2}$.
Under ASP semantic, it is impossible to derive any element of the loop $\{shoot, dead\}$,
as deriving $dead$ requires $shoot$ to be true, and deriving $shoot$ requires $dead$ to be true.
The completion does not restrict this kind of circular derivation and therefore is insufficient to fully capture ASP semantic.
 \section{Temporal loop formulas}\label{sec:lf}
Lin and Zhao~\cite{linjzh03a} introduced the concept of loop formulas to restrict circular derivations.
In this section, we extend the notion of loop formula to past-present programs.
\begin{definition}
    Let $\varphi$ be a implication-free past-present formula and $L$ a loop.
    We define the supporting transformation of $\varphi$ with respect to $L$ as

\begin{eqnarray*}
	\support{L}{\bot} & \eqdef & \bot \\
	\support{L}{\myatom} & \eqdef &
	\begin{cases}
		\bot & \text{if} \ \myatom \in L  \\
		\myatom & \text{otherwise}
	\end{cases}\hspace{15pt} \text{for any atom } \myatom \in \A\\
	\support{L}{\neg\varphi} & \eqdef & \neg\varphi \\
	\support{L}{\varphi\wedge\psi} & \eqdef & \support{L}{\varphi}\wedge\support{L}{\psi} \\
	\support{L}{\varphi\vee\psi} & \eqdef & \support{L}{\varphi}\vee\support{L}{\psi} \\
	\support{L}{\previous\varphi} & \eqdef & \previous\varphi\\
    \support{L}{\varphi\trigger\psi} & \eqdef & \support{L}{\psi}\wedge
                                            (\support{L}{\varphi}\vee\previous(\varphi\trigger\psi))\\
    \support{L}{\varphi\since\psi} & \eqdef & \support{L}{\psi}\vee
                                            (\support{L}{\varphi}\wedge\previous(\varphi\since\psi))
\end{eqnarray*}
\end{definition}

\begin{definition}[External support]
Given a past-present program $P$,
the external support formula of a set of atoms $L \subseteq \mathcal{A}$ wrt $P$, is defined as
\[
    \mathit{ES}_P(L) = \bigvee_{r\in P,\Head{r} \cap L \neq \emptyset } \big ( \support{L}{\body{r}} \wedge \bigwedge_{a\in \Head{r}\setminus L} \neg a \big)
\]
\end{definition}


For our examples $P_1$ and $P_2$, and $L=\{shoot, dead\}$, we have
\begin{align*}
    \mathit{ES}_{P_2}(L) &= \support{L}{dead} \vee \support{L}{shoot \wedge \neg unload \since load}\\
                         &= \support{L}{dead} \vee (\support{L}{shoot}\wedge\support{L}{ \neg unload \since load})\\
                         &= \support{L}{dead} \vee (\support{L}{shoot} \wedge \support{L}{\neg unload} \vee \previous(\neg unload \since load))\\
                         &= \bot \vee (\bot \wedge \neg unload \vee \previous(\neg unload \since load))\\
                         &= \bot
\end{align*}

and
\begin{align*}
    \mathit{ES}_{P_1}(L) &= \support{L}{dead} \vee \support{L}{shoot \wedge \neg unload \since load} \vee (\neg load \wedge \neg unload)\\
                         &= \neg load \wedge \neg unload\\
\end{align*}

Rule~(\ref{r2}) provide an external support for $L$. The body $dead$ of rule~(\ref{r4}) is also a support for $L$, but not external as $dead$ belongs to $L$.
The supporting transformation only keeps external supports by removing from the body any positive and present occurence of element of $L$.

\begin{definition}[Loop formulas]
We define the set of loop formulas of a past-present program $P$ over $\mathcal{A}$, denoted \LF{P}, as:
  \begin{align}
    \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\initial{P}}(L)
            & \text{ for any loop } L \text{ in } \initial{P} \label{eq:loop:initial}\\
    \wnext \alwaysF \Big(\bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L) \Big)
            & \text{ for any loop } L \text{ in } \dynamic{P} \label{eq:loop:dynamic}
  \end{align}
\end{definition}

\begin{theorem}\label{thm:loops}
  Let $P$ be a past-present program and $\T$ a trace of length $\lambda$.
  Then,
  \T\ is a \TS-model of $P$
  iff
  \T\ is a \LTLf-model of $\tCF{P} \cup \LF{P}$.
\end{theorem}

For our examples, we have
\[
\LF{P_1}= \wnext\alwaysF(shoot\vee dead \rightarrow \neg load \wedge\neg unload)
\]
and
\[
\LF{P_2}= \wnext\alwaysF(shoot\vee dead \rightarrow \bot)
\]

$\{load\}\cdot\{shoot, dead\}$ satisfies $\LF{P_1}$, but not $\LF{P_2}$.
So, we have that $\tCF{P_1} \cup \LF{P_1}$ has a unique \LTLf-model $\{load\}\cdot\{shoot, dead\}$, while
$\tCF{P_2} \cup \LF{P_2}$ has no \LTLf-model, matching the \TS-models of the respective programs.

 \section{Temporal loop formulas with unitary cycles}\label{sec:unitary-cycles}

Ferraris et al.~\cite{feleli06a} proposed an approach where the computation of the completion
can be avoided by considering unitary cycles.
In this section, we extend such results for past-present programs.
We first redefine loops so that unitary cycles are included.
\begin{definition}[Unitary cycle]
  A nonempty set $L\subseteq \mathcal{A}$ of atoms is called $\emph{loop}$ of $P$ if, for every pair $a,b$ of atoms in $L$,
  there exists a path (possibly of length 0) from $a$ to $b$ in $G(P)$ such that all vertices in the path belong to $L$.
\end{definition}

With this definition, it is clear that any set consisting of a single atom is a loop.
For example, $\Loops{\dynamic{P_1}}=\{\{load\},\{unload\},\{shoot\},\{dead\},\{shoot, dead\}\}$.

\begin{theorem}\label{thm:loops0}
  Let  $P$ be a past-present program and $\T$ a trace of length $\lambda$.
  Then,
  \T\ is a \TS-model of $P$
  iff
  \T\ is a \LTLf-model of $P \cup \LF{P}$.
\end{theorem}

With unitary cycle, $\LF{P_1}$ becomes
\begin{align*}
    load &\rightarrow \top\\
    unload &\rightarrow \bot\\
    shoot &\rightarrow \bot\\
    dead &\rightarrow \bot\\
    \wnext\alwaysF( load &\rightarrow \neg shoot \wedge\neg unload)\\
    \wnext\alwaysF( unload &\rightarrow \neg shoot \wedge\neg load)\\
    \wnext\alwaysF( shoot &\rightarrow (\neg shoot \wedge\neg load)\vee dead)\\
    \wnext\alwaysF( dead &\rightarrow shoot \wedge \neg unload \since load)\\
    \wnext\alwaysF(shoot\vee dead &\rightarrow \neg load \wedge\neg unload)
\end{align*}

$P_1\cup\LF{P_1}$ has the same \LTLf-model $\tCF{P_1} \cup \LF{P_1}$, $\{load\}\cdot\{shoot, dead\}$, which is the \TS-model of $P_1$.
 \section{Conclusions and Future Work}\label{sec:conclusions}

In this paper we have focused on the computation methods for temporal logic programming within the context of Temporal Equilibrium Logic over finite traces.
More precisely, we have studied a fragment close to logic programming rules in the spirit of~\cite{gabbay87a}: a past-present temporal logic program
consists of a set of rules whose body refers to the past and present while their head refers to the present.
This fragment is very interesting for implementation purposes since it can be solved by means of incremental solving techniques like those implemented in \telingo{}.
Moreover, restricting the body of the rules to only present and past formulas makes it so that the body of the rules can be seen as queries on the set of conclusions generated during the solving phase.

Contrary to the propositional case~\cite{feleli06a}, where the answer sets of an arbitrary propositional formula can be captures by means of the classical models of another formula $\psi$, in the temporal case this is not possible to do the same mapping among the temporal equilibrium models of a formula $\varphi$ and the \LTL{} models of another formula $\psi$~\cite{bozpea16a}.

In this paper we show that past-present temporal logic programs can be effectively reduced to \LTL{} formulas by means of completion and loop formulas.
More precisely we extend the definition of completion and temporal loop formulas in the spirit of Lin and Zhao~\cite{linjzh03a} to the temporal case, and we show that for tight past-present programs, the use of completion is sufficient to achieve a reduction to an \LTLf{} formula.
Moreover, when the program is not tight, we also show that the computation of the temporal completion and a finite number of loop formulas suffices to reduce \TELf{} to \LTLf{}.
Finally, we consider Ferraris et al. approach~\cite{feleli06a} where the computation of the completion can be automatically replaced by the consideration of unitary loops.
In this contribution, we extend such result to the case of past-present logic programs.

As future work we plan to study in detail the relation between temporal completion and loop formulas and \emph{unfounded sets}~\cite{feleli06a,Lifschitz19}, since the latter plays a central role in the solving algorithm of \clingo{}~\cite{gekakasc14a,gekakasc14b}.
Lastly, we will study the case of past-present temporal programs with variables~\cite{AguadoCPVD17} in order to get a second-order characterisation of loop formulas, in the spirit of~\cite{leemen08a}.
% \bibliographystyle{include/latex-class-llncs/splncs04}
%\bibliography{krr,procs,local}


\begin{thebibliography}{10}
\providecommand{\url}[1]{\texttt{#1}}
\providecommand{\urlprefix}{URL }
\providecommand{\doi}[1]{https://doi.org/#1}

\bibitem{agcadipevi13a}
Aguado, F., Cabalar, P., Di{\'{e}}guez, M., P{\'{e}}rez, G., Vidal, C.:
  Temporal equilibrium logic: a survey. Journal of Applied Non-Classical Logics
   \textbf{23}(1-2),  2--24 (2013)

\bibitem{agcapevi11a}
Aguado, F., Cabalar, P., P{\'{e}}rez, G., Vidal, C.: Loop formulas for
  splitable temporal logic programs. In: Delgrande, J., Faber, W. (eds.)
  Proceedings of the Eleventh International Conference on Logic Programming and
  Nonmonotonic Reasoning (LPNMR'11). Lecture Notes in Artificial Intelligence,
  vol.~6645, pp. 80--92. Springer-Verlag (2011)

\bibitem{AguadoCDPSSV23}
Aguado, F., Cabalar, P., Di{\'{e}}guez, M., P{\'{e}}rez, G., Schaub, T.,
  Schuhmann, A., Vidal, C.: Linear-time temporal answer set programming. Theory
  Pract. Log. Program.  \textbf{23}(1),  2--56 (2023)

\bibitem{AguadoCPVD17}
Aguado, F., Cabalar, P., P{\'{e}}rez, G., Vidal, C., Di{\'{e}}guez, M.:
  Temporal logic programs with variables. Theory Pract. Log. Program.
  \textbf{17}(2),  226--243 (2017). \doi{10.1017/S1471068416000570},
  \url{https://doi.org/10.1017/S1471068416000570}

\bibitem{BaralZ07}
Baral, C., Zhao, J.: Non-monotonic temporal logics for goal specification. In:
  Veloso, M.M. (ed.) {IJCAI} 2007, Proceedings of the 20th International Joint
  Conference on Artificial Intelligence, Hyderabad, India, January 6-12, 2007.
  pp. 236--242 (2007)

\bibitem{BaralZ08}
Baral, C., Zhao, J.: Non-monotonic temporal logics that facilitate elaboration
  tolerant revision of goals. In: Fox, D., Gomes, C.P. (eds.) Proceedings of
  the Twenty-Third {AAAI} Conference on Artificial Intelligence, {AAAI} 2008,
  Chicago, Illinois, USA, July 13-17, 2008. pp. 406--411. {AAAI} Press (2008)

\bibitem{bozpea16a}
Bozzelli, L., Pearce, D.: On the expressiveness of temporal equilibrium logic.
  In: Michael, L., Kakas, A. (eds.) Proceedings of the Fifteenth European
  Conference on Logics in Artificial Intelligence (JELIA'16). Lecture Notes in
  Artificial Intelligence, vol. 10021, pp. 159--173. Springer-Verlag (2016)

\bibitem{bale04}
Brachman, R.J., Levesque, H.J.: Knowledge Representation and Reasoning.
  Elsevier (2004),
  \url{http://www.elsevier.com/wps/find/bookdescription.cws\_home/702602/description}

\bibitem{breitr11a}
Brewka, G., Eiter, T., Truszczy{\'n}ski, M.: Answer set programming at a
  glance. Communications of the {ACM}  \textbf{54}(12),  92--103 (2011)

\bibitem{cakamosc19a}
Cabalar, P., Kaminski, R., Morkisch, P., Schaub, T.: telingo = {ASP} + time.
  In: Balduccini, M., Lierler, Y., Woltran, S. (eds.) Proceedings of the
  Fifteenth International Conference on Logic Programming and Nonmonotonic
  Reasoning (LPNMR'19). Lecture Notes in Artificial Intelligence, vol. 11481,
  pp. 256--269. Springer-Verlag (2019)

\bibitem{cakascsc18a}
Cabalar, P., Kaminski, R., Schaub, T., Schuhmann, A.: Temporal answer set
  programming on finite traces. Theory and Practice of Logic Programming
  \textbf{18}(3-4),  406--420 (2018)

\bibitem{cabper07a}
Cabalar, P., Vega, G.P.: Temporal equilibrium logic: {A} first approach. In:
  Moreno{-}D{\'{\i}}az, R., Pichler, F., Quesada{-}Arencibia, A. (eds.)
  Proceedings of the Eleventh International Conference on Computer Aided
  Systems Theory (EUROCAST'17). Lecture Notes in Computer Science, vol.~4739,
  pp. 241--248. Springer-Verlag (2007)

\bibitem{clark78a}
Clark, K.: Negation as failure. In: Gallaire, H., Minker, J. (eds.) Logic and
  Data Bases, pp. 293--322. Plenum Press (1978)

\bibitem{giavar13a}
{De Giacomo}, G., Vardi, M.: Linear temporal logic and linear dynamic logic on
  finite traces. In: Rossi, F. (ed.) Proceedings of the Twenty-third
  International Joint Conference on Artificial Intelligence (IJCAI'13). pp.
  854--860. IJCAI/AAAI Press (2013)

\bibitem{emerson90a}
Emerson, E.: Temporal and modal logic. In: van Leeuwen, J. (ed.) Handbook of
  Theoretical Computer Science, pp. 995--1072. MIT Press (1990)

\bibitem{erdlif03a}
Erdem, E., Lifschitz, V.: Tight logic programs. Theory and Practice of Logic
  Programming  \textbf{3}(4-5),  499--518 (2003)

\bibitem{fages94a}
Fages, F.: Consistency of {C}lark's completion and the existence of stable
  models. Journal of Methods of Logic in Computer Science  \textbf{1},  51--60
  (1994)

\bibitem{feleli06a}
Ferraris, P., Lee, J., Lifschitz, V.: A generalization of the {L}in-{Z}hao
  theorem. Annals of Mathematics and Artificial Intelligence  \textbf{47}(1-2),
   79--101 (2006)

\bibitem{gabbay87a}
Gabbay, D.: The declarative past and imperative future: Executable temporal
  logic for interactive systems. In: Banieqbal, B., Barringer, H., Pnueli, A.
  (eds.) Proceedings of the Conference on Temporal Logic in Specification.
  Lecture Notes in Computer Science, vol.~398, pp. 409--448. Springer-Verlag
  (1987)

\bibitem{gekakaosscth08a}
Gebser, M., Kaminski, R., Kaufmann, B., Ostrowski, M., Schaub, T., Thiele, S.:
  Engineering an incremental {ASP} solver. In: {Garcia de la Banda}, M.,
  Pontelli, E. (eds.) Proceedings of the Twenty-fourth International Conference
  on Logic Programming (ICLP'08). Lecture Notes in Computer Science, vol.~5366,
  pp. 190--205. Springer-Verlag (2008)

\bibitem{gekakasc14a}
Gebser, M., Kaminski, R., Kaufmann, B., Schaub, T.: \textit{Clingo} = {ASP} +
  control: Extended report. Tech. rep., Universit√§t Potsdam (2014),
  \url{http://www.cs.uni-potsdam.de/wv/pdfformat/gekakasc14a.pdf}

\bibitem{gekakasc14b}
Gebser, M., Kaminski, R., Kaufmann, B., Schaub, T.: \textit{Clingo} = {ASP} +
  control: Preliminary report. In: Leuschel, M., Schrijvers, T. (eds.)
  Technical Communications of the Thirtieth International Conference on Logic
  Programming (ICLP'14). Theory and Practice of Logic Programming, Online
  Supplement, vol. 14(4-5) (2014), available at
  \url{http://arxiv.org/abs/1405.3694v1}

\bibitem{Gonzalez2002}
Gonz{\'a}lez, G., Baral, C., Cooper, P.A.: Modeling Multimedia Displays Using
  Action Based Temporal Logic, pp. 141--155. Springer US, Boston, MA (2002)

\bibitem{leemen08a}
Lee, J., Meng, Y.: On loop formulas with variables. In: Brewka, G., Lang, J.
  (eds.) Proceedings of the Eleventh International Conference on Principles of
  Knowledge Representation and Reasoning (KR'08). pp. 444--453. AAAI Press
  (2008)

\bibitem{lifschitz99b}
Lifschitz, V.: Answer set planning. In: {de Schreye}, D. (ed.) Proceedings of
  the International Conference on Logic Programming (ICLP'99). pp. 23--37. MIT
  Press (1999)

\bibitem{Lifschitz19}
Lifschitz, V.: Answer Set Programming. Springer (2019)

\bibitem{linjzh03a}
Lin, F., Zhao, J.: On tight logic programs and yet another translation from
  normal logic programs to propositional logic. In: Gottlob, G., Walsh, T.
  (eds.) Proceedings of the Eighteenth International Joint Conference on
  Artificial Intelligence (IJCAI'03). pp. 853--858. Morgan Kaufmann Publishers
  (2003)

\bibitem{pearce96a}
Pearce, D.: A new logical characterisation of stable models and answer sets.
  In: Dix, J., Pereira, L., Przymusinski, T. (eds.) Proceedings of the Sixth
  International Workshop on Non-Monotonic Extensions of Logic Programming
  (NMELP'96). Lecture Notes in Computer Science, vol.~1216, pp. 57--70.
  Springer-Verlag (1997)

\bibitem{pearce06a}
Pearce, D.: Equilibrium logic. Annals of Mathematics and Artificial
  Intelligence  \textbf{47}(1-2),  3--41 (2006)

\bibitem{pnueli77a}
Pnueli, A.: The temporal logic of programs. In: Proceedings of the Eight-teenth
  Symposium on Foundations of Computer Science (FOCS'77). pp. 46--57. {IEEE}
  Computer Society Press (1977)

\bibitem{sandewall94a}
Sandewall, E.: Features and fluents: the representation of knowledge about
  dynamical systems, vol.~1. Oxford University Press, New York, NY, USA (1994)

\end{thebibliography}

\appendix
\section{Proofs}

\begin{definition}\label{def:forgettable:future}
Let $\tuple{\Htrace,\Ttrace}$ and $\tuple{\Htrace',\Ttrace}$ be two \HT-traces of length $\lambda$ and let $\rangeco{i}{0}{\lambda}$. We say denote by
$\tuple{\Htrace,\Ttrace} \sim_{i}\tuple{\Htrace',\Ttrace}$ the fact for all $\rangeo{j}{0}{i}$, $H_i = H'_i$.
\end{definition}

\begin{proposition}\label{prop:pure-past}
For all \HT-traces $\tuple{\Htrace,\Ttrace}$ and $\tuple{\Htrace',\Ttrace}$  and for all $\rangeco{i}{0}{\lambda}$, if
$\tuple{\Htrace,\Ttrace} \sim_{i}\tuple{\Htrace',\Ttrace}$ then for all $\rangeo{j}{0}{i}$ and for all past formulas $\varphi$,
$\tuple{\Htrace,\Ttrace},j \models \varphi$ iff $\tuple{\Htrace',\Ttrace}, j \models \varphi$
\end{proposition}


\begin{definition}[$\X^{i}$]\label{def:bigX}
Let $\tuple{\Htrace,\Ttrace}$ be a \HT{-trace} of length $\lambda$ and $\rangeo{i}{0}{\lambda}$.
We denote $\X^{i}$ the trace of length $\lambda$ satisfying $X^i_k = \emptyset$ for all $\rangeo{k}{0}{i}$.
\end{definition}






\begin{lemma}\label{lem:pastocc}
    For all \HT{-traces} $\tuple{\Htrace,\Ttrace}$ of length $\lambda$, for all $\rangeo{i}{0}{\lambda}$ and for any pure past formula $\varphi$,
    if each present and positive occurrence of an atom from $X^i_i$
    in $\varphi$ is in the scope of negation then $\tuple{\Htrace,\Ttrace}, i \models \varphi$ iff $\tuple{\Htrace\setminus \X^i , \Ttrace},i \models \varphi$.
\end{lemma}

\begin{proofof}{Lemma \ref{lem:pastocc}}
By induction on $\varphi$.
First, note that for any formula $\phi$ of the form $\varphi\vee\psi$, $\varphi\wedge\psi$,
$\varphi\trigger\psi$ or $\varphi\since\psi$, if all present and positive occurrences of an atom $p$ are in the
scope of negation in $\phi$, then all present and positive occurrences of $p$ are also in the scope of negation
in $\varphi$ and $\psi$.

\begin{itemize}
    \item case $\bot$: clearly, $\tuple{\Htrace,\Ttrace},i\not\models\bot$  and $\tuple{\Htrace\setminus\X^i,\Ttrace},i\not\models\bot$.
    \item case $p$:
    	we consider two cases.
        If $p\not\in X^i_i$,
        $\tuple{\Htrace,\Ttrace},i\models p$ iff $p\in H_i$, iff $p\in H_i\setminus X_i$,
        iff $\tuple{\Htrace\setminus\X^i,\Ttrace},i\models p$.

        If $p\in X^i_i$, then $p$ has a present and positive occurence in $\varphi$, which is not in the scope of negation.
        Therefore, the lemma automatically holds.

    \item case $\neg \varphi$:
        $\tuple{\Htrace,\Ttrace},i \models \neg\varphi$ iff
        $\tuple{\Ttrace,\Ttrace},i \not\models \varphi$ iff
        $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i \models \neg\varphi$ (because of persistency).


    \item case $\previous \varphi$:
    \begin{itemize}
        \item if $i=0$, then $\tuple{\Htrace,\Ttrace},i \not\models \previous\varphi$ and
                  $\tuple{\Htrace\setminus\X^i,\Ttrace},i \not\models \previous\varphi$.
    	\item if $i>0$, then $\tuple{\Htrace,\Ttrace},i \models \previous\varphi$ iff
    	$\tuple{\Htrace,\Ttrace},i-1 \models \varphi$.
Let $X^{i-1}$ be such that $X^{i-1}_{i-1}=\emptyset$. Then, we can apply the induction hypothesis, so
    	$\tuple{\Htrace,\Ttrace},i-1 \models \varphi$ iff (IH)
    	$\tuple{\Htrace\setminus\X^{i-1},\Ttrace},i-1 \models \varphi$.
    	Since $\tuple{\Htrace\setminus\X^{i-1},\Ttrace}\sim_{i} \tuple{\Htrace\setminus\X^{i},\Ttrace}$ (Proposition~\ref{prop:pure-past})
    	then $\tuple{\Htrace\setminus\X^{i-1},\Ttrace},i-1 \models \varphi$
    	iff $\tuple{\Htrace\setminus\X^{i},\Ttrace},i-1 \models \varphi$,
    	iff $\tuple{\Htrace\setminus\X^{i},\Ttrace},i \models \previous\varphi$.
    \end{itemize}

    \item case $\varphi\vee\psi$:
        $\tuple{\Htrace,\Ttrace},i \models \varphi\vee\psi$ iff
        $\tuple{\Htrace,\Ttrace},i \models \varphi$ or $\tuple{\Htrace,\Ttrace},i \models \psi$.
        Since all positive and present occurences of atoms from $X^i_i$ in $\varphi$ and $\psi$ are in the scope of
        negation, we can apply the induction hypothesis to get
        $\tuple{\Htrace\setminus\X^i,\Ttrace},i \models \varphi$ or $\tuple{\Htrace\setminus\X^i,\Ttrace},i \models \psi$.
        Therefore, $\tuple{\Htrace\setminus\X^i,\Ttrace},i \models \varphi\vee\psi$.
    \item case $\varphi\wedge\psi$: Similar as for $\varphi\vee\psi$.
    \item case $\varphi\since\psi$:
        $\tuple{\Htrace,\Ttrace},i \models \varphi\since\psi$ iff
        for some $\rangec{j}{0}{i}$, $\tuple{\Htrace,\Ttrace},j \models \psi$ and
        $\tuple{\Htrace,\Ttrace},k \models \varphi$ for all $\rangeoc{k}{j}{i}$.
        By induction we get that iff
        for some $\rangec{j}{0}{i}$, $\tuple{\Htrace\setminus \X^j,\Ttrace},j \models \psi$ and
        $\tuple{\Htrace\setminus \X^k,\Ttrace},k \models \varphi$ for all $\rangeoc{k}{j}{i}$.
        Since $\tuple{\Htrace\setminus \X^t,\Ttrace} \sim_t \tuple{\Htrace\setminus \X^i,\Ttrace}$ for all
        $\rangeco{t}{0}{i}$, by Proposition~\ref{prop:pure-past} we get that iff
        for some $\rangec{j}{0}{i}$, $\tuple{\Htrace\setminus \X^i,\Ttrace},j \models \psi$ and
        $\tuple{\Htrace\setminus \X^i,\Ttrace},k \models \varphi$ for all $\rangeoc{k}{j}{i}$.
        iff $\tuple{\Htrace\setminus\X^i,\Ttrace},i \models \varphi\since\psi$.
    \item case $\varphi\trigger\psi$:
        assume by contradiction that $\tuple{\Htrace\setminus\X^i,\Ttrace},i \not\models \varphi\trigger\psi$.
        This means that there exist $\rangec{j}{0}{i}$ such that $\tuple{\Htrace\setminus\X^i,\Ttrace},j \not\models \psi$ and
        $\tuple{\Htrace\setminus\X^i,\Ttrace},k \not\models \varphi$ for all $\rangeoc{k}{j}{i}$.
	    Since $\tuple{\Htrace\setminus \X^t,\Ttrace} \sim_t \tuple{\Htrace\setminus \X^i,\Ttrace}$ for all
	    $\rangeco{t}{0}{i}$, by Proposition~\ref{prop:pure-past} we get
		that there exist $\rangec{j}{0}{i}$ such that $\tuple{\Htrace\setminus\X^j,\Ttrace},j \not\models \psi$ and
		$\tuple{\Htrace\setminus\X^k,\Ttrace},k \not\models \varphi$ for all $\rangeoc{k}{j}{i}$.
		By induction, there exist $\rangec{j}{0}{i}$ such that $\tuple{\Htrace,\Ttrace},j \not\models \psi$ and
		$\tuple{\Htrace,\Ttrace},k \not\models \varphi$ for all $\rangeoc{k}{j}{i}$
		iff $\tuple{\Htrace,\Ttrace},i \not\models \varphi\trigger\psi$: a contradiction.
\end{itemize}
\end{proofof}


\begin{definition}
	Let $L \subseteq \A$ and let $\lambda >0$ and $\rangeco{i}{0}{\lambda}$. By $\X(L)^i$ we mean a trace of length $\lambda$ satisfying the following conditions:
		\begin{enumerate}
			\item  $L \subseteq X(L)^i_i \subseteq \A$;
			\item  $X(L)^i_t = \emptyset$ for all $\rangeco{t}{0}{i}$.
		\end{enumerate}
\end{definition}



\begin{lemma}\label{lem:support}
    Let $\tuple{\Htrace,\Ttrace}$ be a \HT{-trace} of length $\lambda$, $\varphi$ an pure past formula. Let us consider the set of atoms $L\subseteq\A$.
    For all $\rangeo{i}{0}{\lambda}$, if each positive occurrence of an atom from $X(L)^i_i\setminus L$ in $\varphi$ is in the scope of negation,
    $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi}$ iff $\tuple{\Htrace\setminus\X(L)^i,\Ttrace},i\models\varphi$.
\end{lemma}
\begin{proofof}{Lemma~\ref{lem:support}}
    By induction on $\varphi$.
    First, note that for any formula $\phi$ of the form $\varphi\vee\psi$, $\varphi\wedge\psi$,
    $\varphi\trigger\psi$ or $\varphi\since\psi$, if all present and positive occurrences of an atom $p$ are in the
    scope of negation in $\phi$, then all present and positive occurrences of $p$ are also in the scope of negation
    in $\varphi$ and $\psi$.

    \begin{itemize}
    \item case $\bot$: $\tuple{\Htrace,\Ttrace},i\not\models\bot$ and $\tuple{\Htrace\setminus\X(L)^i,\Ttrace},i\not\models\bot$.
    \item case $p\not\in L$: we consider the following two cases
    	\begin{itemize}
    		\item If $p\not\in L$, $\support{L}{p}=p$ and, by definition, $p \not \in X(L)^i_i$.
    		      Therefore,  $\tuple{\Htrace,\Ttrace},i\models \support{L}{p}$ iff $\tuple{\Htrace,\Ttrace},i\models p $, iff $p\in H_i$
    		      iff $p\in H_i\setminus X(L)_i^i$, iff $\tuple{\Htrace\setminus\X(L)^i,\Ttrace},i\models p$.

    		\item If $p\in L$ then $p \not \in X(L)^i_i \setminus L$ and $\support{L}{p}=\bot$.
    		Therefore, we get that $\tuple{\Htrace,\Ttrace},i\not\models \support{L}{p}$ and $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not\models p$.
    	\end{itemize}

    \item case $\neg\varphi$:
        $\tuple{\Htrace,\Ttrace},i\models \support{L}{\neg\varphi}$ iff $\tuple{\Htrace,\Ttrace},i\models \neg\varphi$,
        iff $\tuple{\Ttrace,\Ttrace},i\not\models \varphi$, iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models \neg\varphi$.
    \item case $\previous\varphi$:
        $\tuple{\Htrace,\Ttrace},i\models\support{L}{\previous\varphi}$ iff $\tuple{\Htrace,\Ttrace},i\models\previous\varphi$.
        \begin{itemize}
        	\item If $i=0$, then both $\tuple{\Htrace,\Ttrace},0\not\models\previous\varphi$ and
        	      $\tuple{\Htrace\setminus\X(L)^0,\Ttrace},0\not\models\previous\varphi$.
        	\item If $i>0$, then
        	        $\tuple{\Htrace,\Ttrace},i\models\previous\varphi$ iff $\tuple{\Htrace,\Ttrace},i-1\models\varphi$.
        	        By definition, $X(L)^i_{j} = \emptyset$
        	        for $\rangeo{j}{0}{i}$ so by Lemma~\ref{lem:pastocc},
        	        $\tuple{\Htrace\setminus\X^{i}(L),\Ttrace},i-1\models\varphi$,
        	        iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\previous\varphi$.

        \end{itemize}



    \item case $\varphi\wedge\psi$:
        $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi\wedge\psi}$\\
        iff $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi}$ and $\tuple{\Htrace,\Ttrace},i\models\support{L}{\psi}$,\\
        iff (IH) $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi$ and $\tuple{\Htrace\setminus\X^i(X),\Ttrace},i\models\psi$,\\
        iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi\wedge\psi$.
    \item case $\varphi\vee\psi$:
        $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi\vee\psi}$\\
        iff $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi}$ or $\tuple{\Htrace,\Ttrace},i\models\support{L}{\psi}$,\\
        iff (IH) $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi$ or $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\psi$,\\
        iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi\vee\psi$.
\item case $\varphi\since\psi$:
        $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi\since\psi}$ iff
        \begin{enumerate}
        	\item $\tuple{\Htrace,\Ttrace},i\models\support{L}{\psi}$ iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\psi$ (IH) or
        	\item $\tuple{\Htrace,\Ttrace},i\models\support{L}{\varphi}$ and $\tuple{\Htrace,\Ttrace},i\models\previous(\varphi\since\psi)$
        	iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi$ (IH) and $\tuple{\Htrace,\Ttrace},i\models\previous(\varphi\since\psi)$
        	iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models\varphi$ and $\tuple{\Htrace\setminus \X^i(L),\Ttrace},i\models\previous(\varphi\since\psi)$
        \end{enumerate}
        From the previous items we conclude iff
        $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models \psi \vee \left( \varphi \wedge \previous \left(\varphi \since \psi\right)\right)$
        iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\models \varphi \since \psi$.

    \item case $\varphi\trigger\psi$:
		$\tuple{\Htrace,\Ttrace},i\not \models\support{L}{\varphi\trigger\psi}$ iff
		\begin{enumerate}
			\item $\tuple{\Htrace,\Ttrace},i\not \models\support{L}{\psi}$ iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not \models\psi$ (IH) or
			\item $\tuple{\Htrace,\Ttrace},i\not \models\support{L}{\varphi}$ and $\tuple{\Htrace,\Ttrace},i\not \models\previous(\varphi\trigger\psi)$
			iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not \models\varphi$ (IH) and $\tuple{\Htrace,\Ttrace},i\not \models\previous(\varphi\trigger\psi)$
			iff  $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not \models\varphi$ and $\tuple{\Htrace\setminus \X^i(L),\Ttrace},i\not \models\previous(\varphi\trigger\psi)$
\end{enumerate}
From the previous items we conclude iff
$\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not \models \psi \wedge \left( \varphi \vee \previous \left(\varphi \trigger \psi\right)\right)$
iff $\tuple{\Htrace\setminus\X^i(L),\Ttrace},i\not \models \varphi \trigger \psi$.




\end{itemize}
\end{proofof}

\begin{proofof}{Theorem \ref{thm:tcompletion}}
From left to right, let us assume towards a contradiction that \Ttrace\ is a temporal answer set of $P$,
but \Ttrace\ is not an \LTLf-model of $\tCF{P}$.
By construction, if $\Ttrace$ is a temporal answer set of $P$ then $\T$ is an \LTLf{} model of $P$ so $\T, 0 \models P$.
Therefore, $\T,0 \models r$, for all $r \in P$ such that $\Head{r} = \bot$ and
$\T, 0 \models r$ for all $r \in F(P)$.
Since $\T, 0 \not \models \tCF{P}$, there exists $a \in \A$ such that

\begin{align*}
	\T, 0 \not \models \alwaysF\big( a \leftrightarrow
	\ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
	\vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))\big)
\end{align*}


So, there exists $\rangeco{i}{0}{\lambda}$ such that

\begin{align*}
	\T, i \not \models a \leftrightarrow
	\ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
	\vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))
\end{align*}

We consider two cases:

\begin{enumerate}
	\item $\T, i \models a$ and $\T, i \not \models
	\ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
	\vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))$:

	\begin{itemize}
		\item If $i = 0$ then we get that for all $r \in \initial{P}$, if $a \in \Head{r}$ then $\tuple{\Ttrace,\Ttrace}, 0 \not \models S(r,a)$.
		Therefore, for all $r \in \initial{P}$, if $a \in \Head{r}$ then $\tuple{\Ttrace,\Ttrace}, 0 \not \models \S(r,a)$.
		Let \Htrace\ be a trace of length $\lambda$ such that $H_0=T_0\setminus\{a\}$ and $H_i=T_i$ for $\rangeo{i}{1}{\lambda}$.
		Clearly, $\Htrace < \Ttrace$.
		We show a contradiction by proving that $\tuple{\Htrace,\Ttrace}\models P$:
		\begin{enumerate}
			\item  $\tuple{\Htrace,\Ttrace},0\models \initial{P}$: note that $\tuple{\Ttrace,\Ttrace},0\models \body{r}\to\Head{r}$ for all $r\in\initial{P}$, iff for any $r\in\initial{P}$, $\tuple{\Ttrace,\Ttrace},0\not\models \body{r}$ or $\tuple{\Ttrace,\Ttrace},0\models \Head{r}$.
			If $\tuple{\Ttrace,\Ttrace},0\not\models \body{r}$ then, by persistence, $\tuple{\Htrace,\Ttrace},0\not\models \body{r}$, and $\tuple{\Htrace,\Ttrace},0\models \body{r}\to\Head{r}$.
			If $\tuple{\Ttrace,\Ttrace},0\models \body{r}$, then $\tuple{\Ttrace,\Ttrace},0\models \Head{r}$.
			There are two cases.
			\begin{itemize}
				\item Case $a\not\in\Head{r}$:
				$\tuple{\Ttrace,\Ttrace},0\models \Head{r}$ so there is some $p\in\Head{r}$ such that $p\in T_0$ and $p \not = a$.  Then, $p\in H_0$, $\tuple{\Htrace,\Ttrace},0\models \Head{r}$ and $\tuple{\Htrace,\Ttrace},0\models r$.
				\item Case $a\in\Head{r}$:
				We know that $\tuple{\Ttrace,\Ttrace},0\not\models \body{r}\wedge \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$.
				Since, by assumption, $\tuple{\Ttrace,\Ttrace},0\models \body{r}$, it follows
				$\tuple{\Ttrace,\Ttrace}, 0\not\models  \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$
				Therefore, there is $p\in\Head{r}\setminus\{a\}$ such that $p\in T_0$. Then $p\in H_0$, $\tuple{\Htrace,\Ttrace},0\models\Head{r}$ and $\tuple{\Htrace,\Ttrace},0\models r$.
\end{itemize}
				As $r$ is chosen arbitrarily, $\tuple{\Htrace,\Ttrace}\models \initial{P}$.


			\item $\tuple{\Htrace,\Ttrace},0\models \dynamic{P}$: $\tuple{\Ttrace,\Ttrace}\models \dynamic{P}$, then $\tuple{\Ttrace,\Ttrace},i\models \body{r}\to\Head{r}$
			for all $r\in\dynamic{P}$ and $\rangeo{i}{1}{\lambda}$. Then, for any $r\in\dynamic{P}$ and
			$\rangeo{i}{1}{\lambda}$, $\tuple{\Ttrace,\Ttrace},i\not\models \body{r}$ or $\tuple{\Ttrace,\Ttrace},i\models \Head{r}$.
			If $\tuple{\Ttrace,\Ttrace},i\not\models \body{r}$ then, by persistence, $\tuple{\Htrace,\Ttrace},i\not\models \body{r}$,
			and $\tuple{\Htrace,\Ttrace},i\models r$.
			If, $\tuple{\Ttrace,\Ttrace},i\models \Head{r}$, there is some $p\in\Head{r}$ such that $p\in T_i$.
			$H_i = T_i$, so $p\in H_i$ and $\tuple{\Htrace,\Ttrace},i\models \Head{r}$.
			Then $\tuple{\Htrace,\Ttrace},i\models r$. As $r$ and $i$ are chosen arbitrarily,
			$\tuple{\Htrace,\Ttrace}\models \dynamic{P}$.
			\item $\tuple{\Htrace,\Ttrace},0\models \final{P}$: final rules are constraints, so $\tuple{\Ttrace,\Ttrace}\models \final{P}$ implies $\tuple{\Htrace,\Ttrace}\models \final{P}$.
		\end{enumerate}
		We showed that $\tuple{\Htrace, \Ttrace}, 0 \models P$ : a contradiction.


		\item If $i > 0$: we follow a very similar reasoning as for the case $i=0$.

	\end{itemize}



	\item $\T, i \not \models a$ but $\T, i \models
	\ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
	\vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))$: again, we consider two cases here
		\begin{itemize}
			\item there exists $r\in\initial{P}, a\in\Head{r}$ and  $\T, i \models \initially\wedge S(r,a)$: in this case, it follows that $i= 0$, so $\T, 0 \models a$ and $\T, 0 \models  S(r,a)$.
			Therefore, $\T, 0 \models \body{r}$.
			Since $\T, 0 \models r$ and $\T, 0 \models \body{r}$ then $\T, 0 \models p$ for some $p \in \Head{r}$, which contradicts
			$\T, 0 \not \models a$ and $\T, 0 \models \neg q$ for all $p \in \Head{r} \setminus\lbrace a\rbrace$.

			\item there exists $r\in\dynamic{P}, a\in\Head{r}$ and  $\T, i \models  \neg \initially\wedge S(r,a)$: in this case we conclude that $i >0$ and so $\T, i \models a$ and $\T, i \models  S(r,a)$.
			Therefore, $\T, i \models \body{r}$.
			Since $\T, 0 \models r$ and $\T, i \models \body{r}$ then $\T, i \models q$ for some $q \in \Head{r}$.
			However, from $\T, i \models  S(r,a)$ and $\T, i \not \models a$ we conclude that $\T, i \not \models p$ for all $p \in \Head{r}$: a contradiction.
		\end{itemize}

\end{enumerate}




For the converse direction, assume, again, by contradiction that $\tuple{\Ttrace,\Ttrace}$ is not a \TELf{} model of $P$.
We consider two cases:

\begin{enumerate}
	\item $\tuple{\Ttrace,\Ttrace},0 \not \models P$.
	Therefore, there exists $r \in P$ such that $\tuple{\Ttrace,\Ttrace}, 0 \not \models r$.
	Clearly, $r$ cannot be a constraint, otherwise we would already reach a contradiction.
	We still have to check two cases:
	\begin{itemize}
		\item If $r \in \initial{P}$, then $\tuple{\Ttrace,\Ttrace}, 0 \models \body{r}$ and $\tuple{\Ttrace,\Ttrace},0 \not \models \Head{r}$.
		Take any $a \in \Head{r}$. It follows that $\tuple{\Ttrace,\Ttrace}, 0 \models \initially \wedge S(r,a)$.
		so $\tuple{\Ttrace,\Ttrace}, 0 \not \models \tCFa{P}{a}$: a contradiction.
		\item If $r \in \dynamic{P}$ we follow a similar reasoning as for the previous case.
	\end{itemize}

	\item $\tuple{\Ttrace,\Ttrace},0 \models P$ but $\tuple{\Htrace,\Ttrace}, 0 \models P$ for some $\Htrace < \Ttrace$.
	By definition, there exists $i \ge 0$ such that $H_i \subset T_i$. Let us take the smallest $i$ satisfying this property.
	Therefore, $H_j = T_j$ for all $\rangeco{j}{0}{i}$.
	.Moreover, Let us take $a \in T_i\setminus H_i$ and let us proceed depending on the value of $i$

	\begin{itemize}
		\item If $i > 0 $ and $a \in T_i$ then $\tuple{\Ttrace,\Ttrace},i \models \tCFa{P}{a}$ then there exists $r \in \dynamic{P}$ such that $\tuple{\Ttrace,\Ttrace},i \models S(r,a)$.
			  Therefore $\Head{t} \setminus \lbrace a \rbrace \cup T_i = 0$
			  Since $a \not \in H_i$ then $\tuple{\Htrace,\Ttrace}, i \not \models \Head{r}$ and $\tuple{\Htrace,\Ttrace}, i \not \models \body{r}$.


			  At this point of the proof we have that $\tuple{\Ttrace,\Ttrace},i \models \body{r}$, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$ and $T_j\setminus H_j = \emptyset$ for any $j<i$.
By Lemma~\ref{lem:pastocc}, there must be some $b\in T_i\setminus H_i$ with a present and positive occurence
		in $\body{r}$ that is not in the scope of negation.
		Then, for any $a\in T_i\setminus H_i$, there is some $b\in T_i\setminus H_i$ such that $(a,b)\in G(\dynamic{P})$.
		$P$ is tight, so $G(\dynamic{P})$ is acyclic. Then, there is a topological ordering of the nodes in $G(\dynamic{P})$,
		and therefore of the atoms in $T_i\setminus H_i$, such that if $a,b \in T_i\setminus H_i$ and $(a,b)\in G(\dynamic{P})$,
		then $a$ appears before $b$ in the topoligical ordering.
		Then, there is no outgoing edge from the last node in the ordering, which contradict the fact that,
		for any $a\in T_i\setminus H_i$, there is some $b\in T_i\setminus H_i$ such that $(a,b)\in G(\dynamic{P})$.\\

		\item If $i = 0$ we proceed as in the previous case.
	\end{itemize}



\end{enumerate}


\end{proofof}

\begin{proofof}{Theorem \ref{thm:loops}}

We first prove that if \Ttrace\ is a temporal answer set of $P$, then \Ttrace\ is a \LTLf-model of \tCF{P} and \LF{P}.
The proof for \tCF{P} is the same as for Theorem~\ref{thm:tcompletion}.
Remains to prove that \Ttrace\ is a \LTLf-model of \LF{P}.
Assume by contradiction that $\tuple{\Ttrace,\Ttrace}\not\models \LF{P}$. Two different cases must be considered:
\begin{itemize}
    \item
        there is a loop $L$ in \Graph{\dynamic{P}} such that
        $\tuple{\Ttrace,\Ttrace},i\not\models \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L)$
        for some $\rangeo{i}{1}{\lambda}$, or
    \item
        there is a loop $L$ in \Graph{\initial{P}} such that
        $\tuple{\Ttrace,\Ttrace},0\not\models \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\initial{P}}(L)$.
\end{itemize}

For the first case, let \Htrace\ be a trace of length $\lambda$ such that $H_i=T_i\setminus L$ and
$H_k=T_k$ otherwise.
We show that $\tuple{\Htrace,\Ttrace},0\models P$, which will contradict the hypothesis \Ttrace\ is a \TELf-model of $P$:
\begin{enumerate}
    \item
        $\tuple{\Htrace,\Ttrace},0\models \initial{P}$: follows from  $\tuple{\Ttrace,\Ttrace}\models \initial{P}$
        by Lemma~\ref{lem:pastocc} as $T_0\setminus H_0 = \emptyset$.
    \item
        $\tuple{\Htrace,\Ttrace},0\models \final{P}$: follows from  $\tuple{\Ttrace,\Ttrace}\models \final{P}$ as rules in \final{P} are
        constraints.
   \item
        $\tuple{\Htrace,\Ttrace},0\models \dynamic{P}$: $\tuple{\Ttrace,\Ttrace},0\models \dynamic{P}$ since $\Ttrace$ is a \TELf{}-model of $P$.
        Therefore, $\tuple{\Ttrace,\Ttrace},k \models r$ for all $\rangeo{k}{1}{\lambda}$ and for all $r\in\dynamic{P}$.
        Then, $\tuple{\Ttrace,\Ttrace},k \not\models \body{r}$ or $\tuple{\Ttrace,\Ttrace},k \models \Head{r}$.
        If $\tuple{\Ttrace,\Ttrace},k \not\models \body{r}$, by persistence, $\tuple{\Htrace,\Ttrace},k \not\models \body{r}$ and
        $\tuple{\Htrace,\Ttrace},k \models r$.
        If $\tuple{\Ttrace,\Ttrace},k \models \body{r}$, then $\tuple{\Ttrace,\Ttrace},k \models \Head{r}$.

        In the case $k\neq i$, $H_k=T_k$ and $\tuple{\Ttrace,\Ttrace}, k \models \Head{r}$ imply  $\tuple{\Htrace,\Ttrace},k \models \Head{r}$.In the case $k=i$, we have two cases.
        \begin{itemize}
            \item
                if $\tuple{\Ttrace,\Ttrace},i\not\models\support{L}{\body{r}}$, then,
                as $(T_i\setminus H_i)\setminus L=\emptyset$ and $T_k\setminus H_k=\emptyset$ for $k<i$,
                by Lemma~\ref{lem:support},
                $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$. So $\tuple{\Htrace,\Ttrace},i \models r$.
            \item if $\tuple{\Ttrace,\Ttrace},i\models\support{L}{\body{r}}$ and $\Head{r}\cap L =\emptyset$ then
            $\tuple{\Htrace,\Ttrace},i \models \Head{r}$ follows from $\tuple{\Ttrace,\Ttrace},i \models \Head{r}$ and $\tuple{\Htrace,\Ttrace},i \models r$.
            \item if $\tuple{\Ttrace,\Ttrace},i\models\support{L}{\body{r}}$ and $\Head{r}\cap L =\emptyset$ then
                        \begin{itemize}
                            \item if there is some $p\in\Head{r}\setminus L$ such that $p\in T_i$, then $p\in H_i$. So
                                $\tuple{\Htrace,\Ttrace},i \models \Head{r}$ and then $\tuple{\Htrace,\Ttrace},i \models r$.
                            \item if there is no $p\in\Head{r}\setminus L$ such that $p\in T_i$, then
                                $\tuple{\Ttrace,\Ttrace},i\models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
                                As we also have $\tuple{\Ttrace,\Ttrace},i\models\support{L}{\body{r}}$,
                                $\tuple{\Ttrace,\Ttrace},i\models \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L)$,
                                which contradict our hypothesis.
                        \end{itemize}
        \end{itemize}
\end{enumerate}

The proof of the second case follows a similar reasoning as for the first one.

Next, we prove that if \Ttrace\ is a \LTLf-model of \tCF{P} and \LF{P}, then \Ttrace\ is a \TELf-model of $P$.
The proof for $\tuple{\Ttrace,\Ttrace}\models P$ is the same as for Theorem~\ref{thm:tcompletion}.
Remains to prove that there is no $\Htrace<\Ttrace$ such that $\tuple{\Htrace,\Ttrace}\models P$.

Let assume that there exists such a trace $\Htrace$, and let $i$ be the smallest time point such that $H_i\subset T_i$.
Therefore, $H_k = T_k$ for all $\rangeco{k}{0}{i}$.

\begin{itemize}
	\item If $i>0$:
	Let $a\in T_i\setminus H_i$. $\tuple{\Ttrace,\Ttrace}\models \tCF{P}$, so $\tuple{\Ttrace,\Ttrace},i \models a \leftrightarrow
	\bigvee_{r\in\dynamic{P}, a\in\Head{r}}(\body{r}\wedge\bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p)$.
	As $a\in T_i$, there is some rule $r\in\dynamic{P}$ such that $a\in\Head{r}$,
	$\tuple{\Ttrace,\Ttrace},i \models \body{r}$, and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$.
	$\tuple{\Htrace,\Ttrace}\models P$, so $\tuple{\Htrace,\Ttrace},i \models \body{r} \rightarrow a \vee\bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	Then, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$ or $\tuple{\Htrace,\Ttrace},i \models a$ or
	$\tuple{\Htrace,\Ttrace},i \models \bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	As $a\not\in H_i$, $\tuple{\Htrace,\Ttrace},i \not\models a$.
	As $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$,
	$\tuple{\Htrace,\Ttrace},i \not\models \bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	So, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$.

$\tuple{\Ttrace,\Ttrace},i \models \body{r}$, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$ and $T_j\setminus H_j = \emptyset$ for $j<i$, so,
by Lemma~\ref{lem:pastocc}, there must be some $b\in T_i\setminus H_i$ with a present and positive occurence in $\body{r}$ that is not in the scope of negation.
Therefore, for any $a\in T_i\setminus H_i$, there is some $b\in T_i\setminus H_i$ such that $(a,b)\in G(\dynamic{P})$.
It implies a loop $L$ in $\dynamic{P}$, with $L\subseteq T_i\setminus H_i$.

The strongly connected components (SCC) of the dependency graph of $\dynamic{P}$ over $T_i\setminus H_i$ form
a directed acyclic graph, so there is some SCC $L$, such that,
for any $a\in L$, there is no $b\in (T_i\setminus H_i)\setminus L$ such that $(a,b)\in \Graph{\dynamic{P}}$.

For any $a\in T_i\setminus H_i$, $\tuple{\Htrace,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$
such that $a\in\Head{r}$ and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$.
So $\tuple{\Htrace,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
Let \X\ be a trace of length $\lambda$ with $X_i=L$ and $X_j=\emptyset$ for $ j\neq i$.
For any $a\in L$ there is no $b\in (T_i\setminus H_i)\setminus L$ such that $(a,b)\in \Graph{\dynamic{P}}$,
so all positive and present occurences of atoms from $L$ in $\body{r}$ are in the scope of negation.
Then, we can apply Lemma~\ref{lem:pastocc}, and get that
$\tuple{\Ttrace\setminus \X,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
Then, as $X_i\setminus L = \emptyset$, by Lemma~\ref{lem:support},
$\tuple{\Ttrace,\Ttrace},i\not\models \support{L}{\body{r}}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
So, $\tuple{\Ttrace,\Ttrace},i\not\models \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L)$,
and then $\tuple{\Ttrace,\Ttrace}\not\models \LF{P}$. Contradiction.\\

\item Case $i=0$: we reach a contradiction in a similar way as above.

\end{itemize}
\end{proofof}

\begin{proofof}{Theorem \ref{thm:loops0}}

We first prove that if \Ttrace\ is a temporal answer set of $P$, then \Ttrace\ is a \LTLf-model of $P \cup \LF{P}$.
\Ttrace\ is a temporal answer set of $P$, so \Ttrace\ is a \LTLf-model of $P$.
We can show that \Ttrace\ is a \LTLf-model of \LF{P} the same way as for Theorem~\ref{thm:loops}.\\

Next, we prove that if \Ttrace\ is a \LTLf-model of $P \cup \LF{P}$, then \Ttrace\ is a temporal answer set of $P$.
It amounts to showing that there is no $\Htrace<\Ttrace$ such that $\tuple{\Htrace,\Ttrace}\models P$.
Let assume that there is such a trace $\Htrace$, and let $i$ be the smallest time point such that $H_i\subset T_i$.
\begin{enumerate}
	\item If $i>0$,
	Let $a\in T_i\setminus H_i$. $\tuple{\Ttrace,\Ttrace}\models \LF{P}$, so $\tuple{\Ttrace,\Ttrace},i \models a \leftrightarrow
	\bigvee_{r\in\dynamic{P}, a\in\Head{r}}(\support{a}{\body{r}}\wedge\bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p)$.
	As $a\in T_i$, there exists $r\in\dynamic{P}$ such that $a\in\Head{r}$,
	$\tuple{\Ttrace,\Ttrace},i \models \support{a}{\body{r}}$ and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$.
	$\tuple{\Htrace,\Ttrace}\models P$, so $\tuple{\Htrace,\Ttrace},i \models \body{r} \rightarrow a \vee\bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	Then, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$ or $\tuple{\Htrace,\Ttrace},i \models a$ or
	$\tuple{\Htrace,\Ttrace},i \models \bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	As $a\not\in H_i$, $\tuple{\Htrace,\Ttrace},i \not\models a$.
	As $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$,
	$\tuple{\Htrace,\Ttrace},i \not\models \bigvee_{p\in\Head{r}\setminus\{a\}} p$.
	So, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$.


	$\tuple{\Ttrace,\Ttrace},i \models \support{a}{\body{r}}$, $\tuple{\Htrace,\Ttrace},i \not\models \body{r}$ and $T_j\setminus H_j = \emptyset$ for $j<i$, so,
	by Lemma~\ref{lem:support}, there must be some $b\in T_i\setminus H_i$ with a present and positive occurence in $\body{r}$ that is not in the scope of negation.
	Therefore, for any $a\in T_i\setminus H_i$, there is some $b\in T_i\setminus H_i$ such that $(a,b)\in G(\dynamic{P})$.
	It implies a loop $L$ in $\dynamic{P}$, with $L\subseteq T_i\setminus H_i$.

	The strongly connected components (SCC) of the dependency graph of $\dynamic{P}$ over $T_i\setminus H_i$ form
	a directed acyclic graph, so there is some SCC $L$, such that,
	for any $a\in L$, there is no $b\in (T_i\setminus H_i)\setminus L$ such that $(a,b)\in \Graph{\dynamic{P}}$.


	For any $a\in T_i\setminus H_i$, $\tuple{\Htrace,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$
	such that $a\in\Head{r}$ and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p$.
	So $\tuple{\Htrace,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
	and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
	Let \X\ be a trace of length $\lambda$ with $X_i=L$ and $X_j=\emptyset$ for $ j\neq i$.
	For any $a\in L$ there is no $b\in (T_i\setminus H_i)\setminus L$ such that $(a,b)\in \Graph{\dynamic{P}}$,
	so all positive and present occurences of atoms from $L$ in $\body{r}$ are in the scope of negation.
	Then, we can apply Lemma~\ref{lem:pastocc}, and get that
	$\tuple{\Ttrace\setminus \X,\Ttrace},i\not\models \body{r}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
	and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
	Then, as $X_i\setminus L = \emptyset$, by Lemma~\ref{lem:support},
	$\tuple{\Ttrace,\Ttrace},i\not\models \support{L}{\body{r}}$, for all $r \in \dynamic{P}$ such that $L\cap\Head{r}\neq \emptyset$
	and $\tuple{\Ttrace,\Ttrace},i \models \bigwedge_{p\in \Head{r}\setminus L} \neg p$.
	So, $\tuple{\Ttrace,\Ttrace},i\not\models \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L)$,
	and then $\tuple{\Ttrace,\Ttrace}\not\models \LF{P}$: a contradiction.\\


	\item For the case when $i=0$ we reach a contradiction in a similar way as above.
\end{enumerate}

\end{proofof}

\end{document}
