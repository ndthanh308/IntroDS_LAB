\section{Temporal loop formulas}\label{sec:lf}
To restrict circular derivations, Lin and Zhao introduced the concept of loop formulas in~\cite{linjzh03a}.
In this section, we extend their work to past-present programs.
\begin{definition}
    Let $\varphi$ be a implication-free past-present formula and $L$ a loop.
    We define the supporting transformation of $\varphi$ with respect to $L$ as
\begin{eqnarray*}
	\support{L}{\bot} & \eqdef & \bot \\
	% \support{L}{\myatom} & \eqdef &
	% \begin{cases}
	% 	\bot & \text{if} \ \myatom \in L  \\
	% 	\myatom & \text{otherwise}
	% \end{cases}\hspace{15pt} \text{for any atom } \myatom \in \A\\
    \support{L}{\myatom}  &\eqdef &\bot \text{ if } \myatom \in L\text{ ; }
    \myatom \text{ otherwise, for any } \myatom \in \A\\
	\support{L}{\neg\varphi} & \eqdef & \neg\varphi \\
	\support{L}{\varphi\wedge\psi} & \eqdef & \support{L}{\varphi}\wedge\support{L}{\psi} \\
	\support{L}{\varphi\vee\psi} & \eqdef & \support{L}{\varphi}\vee\support{L}{\psi} \\
	\support{L}{\previous\varphi} & \eqdef & \previous\varphi\\
    \support{L}{\varphi\trigger\psi} & \eqdef & \support{L}{\psi}\wedge
                                            (\support{L}{\varphi}\vee\previous(\varphi\trigger\psi))\\
    \support{L}{\varphi\since\psi} & \eqdef & \support{L}{\psi}\vee
                                            (\support{L}{\varphi}\wedge\previous(\varphi\since\psi))
\end{eqnarray*}\qed
%\begin{itemize}[itemsep=0pt]
%	\item $\support{L}{\myatom}  \eqdef \bot$ if $\myatom \in L$; $\myatom$ otherwise, for any $\myatom \in \A$; \hspace{4pt} $\support{L}{\bot}  \eqdef  \bot$; \hspace{4pt}  $\support{L}{\neg\varphi}  \eqdef  \neg\varphi$;
%	\item  $\support{L}{\varphi\wedge\psi}  \eqdef  \support{L}{\varphi}\wedge\support{L}{\psi}$; \hspace{5pt} $\support{L}{\varphi\vee\psi}  \eqdef  \support{L}{\varphi}\vee\support{L}{\psi}$; \hspace{5pt} $\support{L}{\previous\varphi}  \eqdef  \previous\varphi$ ;
%	\item  $\support{L}{\varphi\trigger\psi}  \eqdef  \support{L}{\psi}\wedge (\support{L}{\varphi}\vee\previous(\varphi\trigger\psi))$; \hspace{5pt} $\support{L}{\varphi\since\psi}  \eqdef  \support{L}{\psi}\vee
%	(\support{L}{\varphi}\wedge\previous(\varphi\since\psi))$.
%\end{itemize}\qed

%\begin{tabular}{lll}
%
%
%\multicolumn{2}{l}{

%\end{tabular}
%\begin{cases}
%	\bot & \text{if} \ \myatom \in L  \\
%	\myatom & \text{otherwise}
%\end{cases}\hspace{5pt} \text{with } \myatom \in \A$  \\[20pt]
%
% &  \\
%
\end{definition}

\begin{definition}[External support]
Given a past-present program $P$,
the external support formula of a set of atoms $L \subseteq \mathcal{A}$ wrt $P$, is defined as
\begin{equation*}
    \mathit{ES}_P(L) = \bigvee_{r\in P,\Head{r} \cap L \neq \emptyset } \big ( \support{L}{\body{r}} \wedge \bigwedge_{a\in \Head{r}\setminus L} \neg a \big)
\end{equation*}\qed
\end{definition}


For instance, for $L=\{shoot, dead\}$, $\mathit{ES}_{P_2}(L)$ and $\mathit{ES}_{P_1}(L)$ are
\begin{align*}
    \mathit{ES}_{P_2}(L) &= \support{L}{dead} \vee \support{L}{shoot \wedge \neg unload\hspace{1pt}\since\hspace{1pt} load}\\
                         &= \support{L}{dead} \vee (\support{L}{shoot}\wedge\support{L}{ \neg unload\hspace{1pt}\since\hspace{1pt} load})\\
                         &= \support{L}{dead} \vee (\support{L}{shoot} \wedge \support{L}{\neg unload} \vee \previous(\neg unload \since load))\\
                         &= \bot \vee (\bot \wedge \neg unload \vee \previous(\neg unload \since load)) = \bot.\\
    \mathit{ES}_{P_1}(L) &= \support{L}{dead} \vee \support{L}{shoot \wedge \neg unload\hspace{1pt}\since\hspace{1pt} load} \vee (\neg load \wedge \neg unload)\\
						 &= \neg load \wedge \neg unload.
\end{align*}
Rule~(\ref{r2}) provides an external support for $L$. The body $dead$ of rule~(\ref{r4}) is also a support for $L$, but not external as $dead$ belongs to $L$.
The supporting transformation only keeps external supports by removing from the body any positive and present occurence of element of $L$.

\begin{definition}[Loop formulas]
We define the set of loop formulas of a past-present program $P$ over $\mathcal{A}$, denoted \LF{P}, as:
  \begin{align*}
    \bigvee_{a\in L} a \rightarrow \mathit{ES}_{\initial{P}}(L)
            & \text{ for any loop } L \text{ in } \initial{P}\\
    \wnext \alwaysF \Big(\bigvee_{a\in L} a \rightarrow \mathit{ES}_{\dynamic{P}}(L) \Big)
            & \text{ for any loop } L \text{ in } \dynamic{P}
  \end{align*}
\end{definition}
\begin{theorem}\label{thm:loops}
  Let $P$ be a past-present program and $\T$ a trace of length $\lambda$.
  Then,
  \T\ is a \TS-model of $P$
  iff
  \T\ is a \LTLf-model of $\tCF{P} \cup \LF{P}$.\qed
\end{theorem}

For our examples, we have that
$\LF{P_1}= \wnext\alwaysF(shoot\vee dead \rightarrow \neg load \wedge\neg unload)$ and
$\LF{P_2}= \wnext\alwaysF(shoot\vee dead \rightarrow \bot)$.
It can be also checked that $\{load\}\cdot\{shoot, dead\}$ satisfies $\LF{P_1}$, but not $\LF{P_2}$.
So, we have that $\tCF{P_1} \cup \LF{P_1}$ has a unique \LTLf-model $\{load\}\cdot\{shoot, dead\}$, while
$\tCF{P_2} \cup \LF{P_2}$ has no \LTLf-model, matching the \TS-models of the respective programs.


% Ferraris et al.~\cite{feleli06a} proposed an approach where the computation of the completion
% can be avoided by considering unitary cycles.
% We extended such results for past-present programs in the extended version~\cite{cabalar2023pastpresent}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
