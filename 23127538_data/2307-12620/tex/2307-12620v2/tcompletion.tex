\section{Temporal completion}\label{sec:tcompletion}
In this section, we extend the completion property to the temporal case of past-present programs.

%\begin{definition}[Positive occurence]
An occurrence of an atom in a formula is \emph{positive} if it is in the antecedent of an even number of implications,
negative otherwise.
%\end{definition}
%\begin{definition}[Present occurence]
An occurrence of an atom in a formula is \emph{present} if it is not in the scope of $\previous$ (previous).
%\end{definition}
%\begin{definition}[Dependency graph]
Given a past-present program $P$ over $\mathcal{A}$,
we define its \emph{(positive) dependency graph}
\Graph{P} as $(\mathcal{A}, E)$ such that
$(a,b) \in E$ if there is a rule $r\in P$ such that $a\in\Head{r}\cap\mathcal{A}$ and $b$
has positive and present occurence in $\body{r}$  that is not in the scope of negation.
%\end{definition}
%\begin{definition}[Loop]
A nonempty set $L\subseteq \mathcal{A}$ of atoms is called \emph{loop} of $P$ if, for every pair $a,b$ of atoms in $L$,
there exists a path of length $> 0$ from $a$ to $b$ in \Graph{P} such that all vertices in the path belong to $L$.
%\end{definition}
We let \Loops{P} denote the set of loops of $P$.

Due to the structure of past-present programs, dependencies from the future to the past cannot happen,
and therefore there can only be loops within a same time point.
To reflect this, the definitions above only consider atoms with present occurences.
For example, rule $a\leftarrow b\wedge \previous c$ generates the edge $(a,b)$ but not $(a,c)$.

%\begin{definition}[Tight program]
%    A past-present program $P$ is said to be \emph{tight} if $\initial{P}$ and
%    $\dynamic{P}$ do not contain any loop.
%\end{definition}
For $P_1$, we get for the initial rules $\Graph{\initial{P_1}}=(\{load, unload, shoot, dead\},\emptyset)$ whose loops are $\Loops{\initial{P_1}}=\emptyset$.
For the dynamic rules, we get
$\Graph{\dynamic{P_1}}=(\{load,\linebreak[1] unload,\linebreak[1] shoot,\linebreak[1] dead\},\{(dead,shoot),\linebreak[1] (dead, load),\linebreak[1] (shoot, dead)\})$ and
$\Loops{\dynamic{P_1}}=\{\{shoot, dead\}\}$.
% \begin{align*}
%     \Graph{\dynamic{P_1}}&=(\{load, unload, shoot, dead\},\{(dead,shoot), (dead, load), (shoot, dead)\})\\
%     \Loops{\dynamic{P_1}}&=\{\{shoot, dead\}\}
% \end{align*}

In the following, $\varphi\rightarrow\psi\eqdef\psi\leftarrow\varphi$ and
$\varphi\leftrightarrow\psi\eqdef\varphi\rightarrow\psi\wedge\varphi\leftarrow\psi$.
\begin{definition}[Temporal completion]
    We define the temporal \emph{completion} formula of an atom $a$ in a past-present program $P$ over \A, denoted \tCFa{P}{a} as:

        \begin{equation*}
            \alwaysF\big( a \leftrightarrow
                \ \bigvee_{r\in\initial{P}, a\in\Head{r}} (\initially\wedge S(r,a))
            \vee \bigvee_{r\in\dynamic{P}, a\in\Head{r}} (\neg\initially\wedge S(r,a))\big)
        \end{equation*}

\noindent where  \(
  S(r,a) = \body{r}\wedge \bigwedge_{p\in \Head{r}\setminus \{a\}} \neg p
  \).

The temporal \emph{completion} formula of $P$, denoted \tCF{P}, is
    \begin{equation*}
        \{\tCFa{P}{a}	\mid a\in\A\}
        \cup \{r\mid r\in \initial{P}\cup\dynamic{P}, \Head{r}=\bot\}
        \cup \final{P}.
    \end{equation*}

\end{definition}

    A past-present program $P$ is said to be \emph{tight} if $\initial{P}$ and
    $\dynamic{P}$ do not contain any loop.
\begin{theorem}\label{thm:tcompletion}
    Let $P$ be a tight past-present program and \T\ a trace of length $\lambda$.
    Then, \T\ is a \TS-model of $P$ iff \T\ is a \LTLf-model of \tCF{P}.\qed
\end{theorem}

The completion of $P_1$ is
\begin{equation*}
\tCF{P_1} = \left\{
\begin{array}{c}
\alwaysF(load \leftrightarrow \initially \vee
(\neg\initially\wedge \neg shoot \wedge \neg unload)),\\
\alwaysF(shoot \leftrightarrow (\neg\initially\wedge \neg load \wedge \neg unload))
\vee (\neg\initially\wedge dead)), \\
\alwaysF(unload \leftrightarrow (\neg\initially\wedge \neg shoot \wedge \neg load)), \\
\alwaysF(dead \leftrightarrow (\neg\initially\wedge shoot \wedge \neg unload \since load)), \\
\alwaysF(\finally \to (\bot \leftarrow\neg dead))
\end{array}
\right\}.
\end{equation*}

For $\lambda=2$, $\tCF{P_1}$ has a unique \LTLf-model $\{load\}\cdot\{shoot, dead\}$,
which is identical to the \TS-model of $P_1$.
Notice that for this example, the \TS-models of the program match the \LTLf-models
of its completion despite the program not being tight. This is generally not the case.
Let $P_2$ be the program made of the rules $(\ref{r1}), (\ref{r3}), (\ref{r4})$ and $(\ref{r5})$.
The completion of $P_2$ is
\begin{equation*}
\tCF{P_2} = \left\{
\begin{array}{ll}
& \alwaysF(load \leftrightarrow \initially),\;
\alwaysF(shoot \leftrightarrow (\neg\initially\wedge dead)), \;
\alwaysF(unload \leftrightarrow \bot),\\
&\alwaysF(dead \leftrightarrow (\neg\initially\wedge shoot \wedge \neg unload \since load)),\; \alwaysF(\finally \to (\bot \leftarrow\neg dead))
\end{array}
	\right\}.
\end{equation*}

$P_2$ does not have any \TS-model, but $\{load\}\cdot\{shoot, dead\}$ is a \LTLf-model of $\tCF{P_2}$.
Under ASP semantics, it is impossible to derive any element of the loop $\{shoot, dead\}$,
as deriving $dead$ requires $shoot$ to be true, and deriving $shoot$ requires $dead$ to be true.
The completion does not restrict this kind of circular derivation and therefore is insufficient to fully capture ASP semantics.
