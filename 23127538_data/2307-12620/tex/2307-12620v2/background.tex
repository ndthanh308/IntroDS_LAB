\section{Past-present temporal programs over finite traces}\label{sec:background}
In this section, we introduce the so-called \emph{past-present} temporal logic programs and its semantics based on \emph{Temporal Equilibrium Logic over Finite traces} (\TELf{} for short)  as in~\cite{AguadoCDPSSV23}.
The syntax of our language is inspired from the pure-past fragment of Linear Time Temporal Logic (\LTL{})~\cite{GiacomoSFR20}, since the only future operators used are \emph{always} and \emph{weak next}.

%\comment{M: rewrite}For this paper to be self-contained, we first recall the definitions of \emph{Temporal Here-and-There over finite traces} (\THTf{} for short)\ and its non-monotonic counterpart \emph{Temporal Equilibrium Logic over finite traces} (\TELf)\
%\comment{M:rewrite}All logics treated in this paper share the common syntax of \LTL{} with past operators~\cite{emerson90a}.
We start from a given set $\mathcal{A}$ of atoms which we call the \emph{alphabet}.
Then, \emph{past temporal formulas} $\varphi$ are defined by the grammar:
\[
\varphi ::= a \mid \bot\mid \neg \varphi \mid \varphi_1 \wedge \varphi_2 \mid \varphi_1 \vee \varphi_2  \mid\previous\varphi \mid \varphi_1 \since \varphi_2 \mid \varphi_1 \trigger \varphi_2
\]
where $a\in\A$ is an atom.
The intended meaning of the (modal) temporal operators is as in \LTL{}.
$\previous \varphi$  means that $\varphi$ is true at the previous time point;
$\varphi \since \psi$ can be read as $\varphi$ is true since $\psi$ was true and
$\varphi \trigger \psi$ means that $\psi$ is true since both $\varphi$ and $\psi$ became true simultaneously or $\psi$ has been true from the beginning.

%
%to the temporal connectives whose names are listed below:
%\[
%\begin{array}[t]{r|cl}
%\mathit{Past} & \previous & \text{for \emph{previous}}\\
%              & \since    & \text{for \emph{since}}   \\
%              & \trigger  & \text{for \emph{trigger}}
%\end{array}
%\qquad\qquad\qquad
%\begin{array}[t]{r|cl}
%\mathit{Future} & \next    & \text{for \emph{next}}\\
%                & \until   & \text{for \emph{until}}\\
%                & \release & \text{for \emph{release}}
%\end{array}
%\]

%$\varphi \until \psi$ means that $\varphi$ is true until $\psi$ is true,
%while
%For $\varphi \release \psi$ and $\varphi \trigger \psi$ the meaning is not as direct as for the previous operators.
%$\varphi \release \psi$ means that $\psi$ is true until both $\varphi$ and $\psi$ become true simultaneously or $\psi$ is true forever.

%Several equivalences from propositional and temporal logics also hold in \THTf{}:
%\(
%\top \eqdef \neg \bot
%\),
%\(
%\neg \varphi \eqdef  \varphi \to \bot
%\),
%\(
%\varphi \leftrightarrow \psi \eqdef (\varphi \to \psi) \wedge (\psi \to \varphi)
%\),
%$\alwaysP \varphi  \eqdef \bot \trigger \varphi$,
%$\eventuallyP \varphi   \eqdef  \top \since \varphi$,
%$\initially \eqdef  \neg \previous \top$,
%$\wprevious \varphi   \eqdef  \previous \varphi \vee \initially$.
%$\alwaysF \varphi   \eqdef  \bot \release \varphi$,
%$\eventuallyF \varphi   \eqdef  \top \until \varphi$,
%$\finally   \eqdef  \neg \next \top$ and
%$\wnext \varphi   \eqdef  \next \varphi \vee \finally$.


%\[
%\begin{array}{rcll}
%       \alwaysP \varphi  & \eqdef & \bot \trigger \varphi             & \text{\emph{always before}} \\
%   \eventuallyP \varphi  & \eqdef & \top \since \varphi               & \text{\emph{eventually before}} \\
%             \initially\,& \eqdef & \neg \previous \top               & \text{\emph{initial}}\\
%     \wprevious \varphi  & \eqdef & \previous \varphi \vee \initially & \text{\emph{weak previous}}
%\end{array}
%\qquad
%\begin{array}{rcll}
%       \alwaysF \varphi  & \eqdef & \bot \release \varphi             & \text{\emph{always afterward}}\\
%   \eventuallyF \varphi  & \eqdef & \top \until \varphi               & \text{\emph{eventually afterward}}\\
%               \finally  & \eqdef & \neg \next \top                   & \text{\emph{final}}\\
%         \wnext \varphi  & \eqdef & \next \varphi \vee \finally       & \text{\emph{weak next}}
%\end{array}
%\]
%A \emph{(temporal) theory} is a (possibly infinite) set of temporal formulas.

%Note that we use solid operators to refer to the past, while future-time operators are denoted by outlined symbols.
%
%Although \THT\ and \LTL\ share the same syntax, they have a different semantics,
%the former being a weaker logic than the latter.
%%
%The semantics of \LTL\ relies on the concept of a \emph{trace},
%a (possibly infinite) sequence of \emph{states},
%each of which is a set of atoms.
%%
%For defining traces, we start by introducing some notation to deal with intervals of integer time points.
%
Given $a \in \mathbb{N}$ and $b \in \mathbb{N}$,
we let $\intervc{a}{b}\eqdef \{i \in \mathbb{N} \mid a \leq i \leq b\}$ and
$\intervo{a}{b}\eqdef \{i \in \mathbb{N} \mid a \leq i < b\}$.
%and $\intervoc{a}{b}\eqdef \{i \in \mathbb{N} \mid a < i \leq b\}$.
%
A \emph{finite trace} \T\ of length $\lambda$ over alphabet \A\ is
a sequence $\T=(T_i)_{\rangeo{i}{0}{\lambda}}$ of sets $T_i\subseteq\A$.
%
%We say that \T\ is \emph{infinite} if $\lambda=\omega$ and \emph{finite} otherwise.
%
To represent a given trace, we write a sequence of sets of atoms concatenated with `$\cdot$'.
%
For instance, the finite trace $\{a\} \cdot \emptyset \cdot \{a\} \cdot \emptyset$ has length 4 and makes $a$ true at even time points and false at odd ones.
%

%At each state $T_i$ in a trace, an atom $a$  can only be true, viz.\ $a \in T_i$, or false, $a \not\in T_i$.
%%
%The logic \THT\ weakens this truth assignment, following the same intuitions as the (non-temporal) logic of \HT.
%%
%In \THT, an atom can have one of three truth-values in each state, namely,
%\emph{false}, \emph{assumed} (or true by default) or \emph{proven} (or certainly true).
%%
%Anything proved has to be assumed, but the opposite does not necessarily hold.
%%
%Following this idea,
%a state $i$ is represented as a pair of sets of atoms $\tuple{H_i,T_i}$ with $H_i \subseteq T_i \subseteq \A$ where
%$H_i$ (standing for ``here'') contains the proven atoms, whereas $T_i$ (standing for ``there'') contains the assumed atoms.
%%
%On the other hand, false atoms are just the ones not assumed, captured by $\A \setminus T_i$.
%%
%Accordingly,
A \emph{Here-and-There trace} (for short \emph{\HT-trace}) of length $\lambda$ over alphabet \A\ is
a sequence of pairs
\(
(\tuple{H_i,T_i})_{\rangeo{i}{0}{\lambda}}
\)
with $H_i\subseteq T_i$ for any $\rangeo{i}{0}{\lambda}$.
%
For convenience, we usually represent the \HT-trace as the pair $\tuple{\Htrace,\Ttrace}$ of traces $\Htrace = (H_i)_{\rangeo{i}{0}{\lambda}}$ and $\T = (T_i)_{\rangeo{i}{0}{\lambda}}$.
%
Given $\M=\tuple{\Htrace,\Ttrace}$, we also denote its length as $|\M| \eqdef |\Htrace|=|\T|=\lambda$.
%
Note that the two traces \Htrace, \T\ must satisfy a kind of order relation, since $H_i \subseteq T_i$ for each time point $i$.
%
Formally, we define the ordering $\Htrace \leq \T$ between two traces of the same length $\lambda$ as $H_i\subseteq T_i$ for each $\rangeo{i}{0}{\lambda}$.
Furthermore, we define $\Htrace<\T$ as both $\Htrace\leq\T$ and $\Htrace\neq\T$.
%
Thus, an \HT-trace can also be defined as any pair $\tuple{\Htrace,\Ttrace}$ of traces such that $\Htrace \leq \T$.
%
The particular type of \HT-traces satisfying $\Htrace=\T$ are called \emph{total}.

%We proceed by generalizing the extension of \HT\ with temporal operators,
%called \THT~\cite{agcadipevi13a},
%to \HT-traces of fixed length in order to integrate finite as well as infinite traces.
%%
%Given any \HT-trace $\M=\tuple{\Htrace,\Ttrace}$,
%we define the \THT\ satisfaction of formulas as follows.
%
% --------------------------------------------------------------------------------
%\begin{definition}[\THT-satisfaction;~\cite{agcadipevi13a,cakascsc18a}]\label{def:dht:satisfaction}%
  %\footnotetext{The while operator \while\ was introduced by~\cite{agcafapevi20a}.}
  An \HT-trace $\M=\tuple{\Htrace,\Ttrace}$ of length $\lambda$ over alphabet \A\
  \emph{satisfies} a past temporal formula $\varphi$ at time point $\rangeo{k}{0}{\lambda}$,
  written \mbox{$\M,k \models \varphi$}, if the following conditions hold:
  \begin{enumerate}
  \item $\M,k \models \top$ and  $\M,k \not\models \bot$
  \item $\M,k \models \myatom$ if $\myatom \in H_k$ for any atom $\myatom \in \A$
  \item $\M, k \models \varphi \wedge \psi$
    iff
    $\M, k \models \varphi$
    and
    $\M, k \models \psi$
  \item $\M, k \models \varphi \vee \psi$
    iff
    $\M, k \models \varphi$
    or
    $\M, k \models \psi$
  \item $\M, k \models \neg \varphi$
    iff
    $\langle \mathbf{T}, \mathbf{T} \rangle, k \not \models \varphi$
  \item $\M, k \models \previous \varphi$
    iff
    $k>0$ and $\M, k{-}1 \models \varphi$
  \item $\M, k \models \varphi \, \since \, \psi$
    iff
    for some $\rangec{j}{0}{k}$, we have
    $\M, j \models \psi$
    and
    $\M, i \models \varphi$ for all $\rangeoc{i}{j}{k}$
  \item $\M, k \models \varphi \trigger \psi$
    iff
    for all $\rangec{j}{0}{k}$, we have
    $\M, j \models \psi$
    or
    $\M, i \models \varphi$ for some $\rangeoc{i}{j}{k}$
%  \item $\M, k \models \next \varphi$
%    iff
%    $k+1<\lambda$ and $\M, k{+}1 \models \varphi$
%  \item $\M, k \models \varphi \until \psi$
%    iff
%    for some $\rangeo{j}{k}{\lambda}$, we have
%    $\M, j \models \psi$
%    and
%    $\M, i \models \varphi$ for all $\rangeo{i}{k}{j}$
%  \item $\M, k \models \varphi \release \psi$
%    iff
%    for all $\rangeo{j}{k}{\lambda}$, we have
%    $\M, j \models \psi$
%    or
%    $\M, i \models \varphi$ for some $\rangeo{i}{k}{j}$
    %
%  \item $\M, k \models \varphi \while \psi$
%    iff
%    for all $\rangeo{j}{k}{\lambda}$, we have
%    $\tuple{\Htrace',\Ttrace},j \models \varphi$ or $\tuple{\Htrace',\Ttrace},i \not\models \psi$ for some $\rangeo{i}{k}{j}$ and for all $\Htrace' \in \{\Htrace,\T\}$
  \end{enumerate}
% \qed
%\end{definition}

A formula $\varphi$ is a \emph{tautology} (or is \emph{valid}), written $\models \varphi$,
iff $\M,k \models \varphi$ for any \HT-trace \M\ and any $\rangeo{k}{0}{\lambda}$.
We call the logic induced by the set of all tautologies \emph{Temporal logic of Here-and-There over finite traces} (\THTf\ for short).

%\begin{proposition}
    The following equivalences hold in  \THTf{}:
\begin{enumerate*}
%	\item \(\neg \varphi \eqdef  \varphi \to \bot\),
	\item \(\top \equiv \neg \bot\),
	\item $\initially \equiv  \neg \previous \top$,
%	\item \(\varphi \leftrightarrow \psi \eqdef (\varphi \to \psi) \wedge (\psi \to \varphi)\),
	\item $\alwaysP \varphi  \equiv \bot \trigger \varphi$,
	\item $\eventuallyP \varphi   \equiv  \top \since \varphi$,
	\item $\wprevious \varphi   \equiv  \previous \varphi \vee \initially$.
\end{enumerate*}
%Several equivalences from propositional and temporal logics also hold in
%$\alwaysF \varphi   \eqdef  \bot \release \varphi$,
%$\eventuallyF \varphi   \eqdef  \top \until \varphi$,
%$\finally   \eqdef  \neg \next \top$ and
%$\wnext \varphi   \eqdef  \next \varphi \vee \finally$.
%\end{proposition}
% --------------------------------------------------------------------------------
%In general, these conditions inherit the interpretation of connectives from \LTL{} (with past operators) with just a few differences.
%%
%A first minor variation is that we allow traces of arbitrary length $\lambda$,
%including both infinite ($\lambda=\omega$) and finite ($\lambda \in \Nat$) traces.
%%
%The most significant difference, however, has to do with the treatment of implication,
%which is inherited from the intermediate logic of \HT.
%%
%It requires that the implication is satisfied in ``both dimensions'' $\Htrace$ (here) and $\T$ (there) of the trace, using $\tuple{\Htrace,\Ttrace}$ (as in the other connectives) but also $\tuple{\Ttrace,\Ttrace}$.
%%
%Finally, one last difference with respect to \LTL\ is the new connective $\varphi \while \psi$
%which is also a kind of temporally-iterated \HT\ implication.
%%
%Its intuitive reading\footnote{A dual, past operator could also be easily defined, but it would not have a natural, intuitive reading and its purpose would be unclear.} is ``keep doing $\varphi$ while condition $\psi$ holds.''
%%
%In \LTL, $\varphi \while \psi$ would just amount to $\neg \psi \release \varphi$,
%but under \HT\ semantics both formulas have a different meaning,
%as the latter may provide evidence for $\varphi$ even though the condition $\psi$ does not hold.
\begin{definition}[Past-present Program]
	Given alphabet $\mathcal{A}$, the set of \emph{regular literals} is defined  as
	$\{a, \neg a,  \mid a \in \mathcal{A}\}$.

	A \emph{past-present rule} is either:
	%
	\par
	\begin{tabular}{l@{\quad}r@{\;}c@{\;}l}
		\hspace{\itemindent} \ {\labelitemi} \ an \emph{initial rule} of form &                           $\Hd$ & $\leftarrow$ & $\Bd$     \\
		\hspace{\itemindent} \ {\labelitemi} \ a  \emph{dynamic rule} of form &  $\wnext\,\alwaysF (       \Hd$ & $\leftarrow$ & $\Bd)$    \\
		\hspace{\itemindent} \ {\labelitemi} \ a  \emph{final   rule} of form &  $\alwaysF(\,\finally \to (\bot$ & $\leftarrow$ & $\Bd )\,)$
	\end{tabular}
	\par
	%
	where $\Bd$ is an pure past formula for dynamic rules and $\Bd=b_1 \wedge \dots \wedge b_n$
	with $n\geq 0$ for initial and final rules, the $b_i$ are regular literals,
	$\Hd=a_1 \vee \dots \vee a_m$ with $m \geq 0$ and $a_j\in \mathcal{A}$.
	A \emph{past-present program} is a set of past-present rules.\qed
\end{definition}

We let \initial{P}, \dynamic{P}, and \final{P} stand for the set of all initial, dynamic, and final rules in a
past-present program $P$, respectively.
Additionally we refer to \Hd\ as the \emph{head} of a rule $r$ and to \Bd\ as the \emph{body} of $r$.
We let $\body{r}=B$ and $\Head{r}=H$ for all types of rules above.
For example, let consider the following past-present program $P_1$:
\begin{align}
	&load \leftarrow  \label{r1}\\
	\wnext\alwaysF(&shoot \vee load \vee unload \leftarrow \ ) \label{r2}\\
	\wnext\alwaysF(&dead  \leftarrow shoot \wedge \neg unload \since load)\label{r3}\\
	\wnext\alwaysF(&shoot  \leftarrow dead)\label{r4}\\
	\alwaysF(&\finally \to (\bot \leftarrow\neg dead))\label{r5}
\end{align}
%The set of bodies in $P$ is $\body{P} = \{\body{r} \mid r\in P\}$.
%The set of heads in $P$ is $\Head{P} = \{\Head{r} \mid r\in P\}$.
%Rule~(\ref{r1}) is the only initial rule of $P$, rules~(\ref{r2}) to~(\ref{r4}) are dynamic rules, and rule~(\ref{r5}) is a final rule.
We get $\initial{P_1}=\{(\ref{r1})\}$, $\dynamic{P_1}=\{(\ref{r2}), (\ref{r3}), (\ref{r4})\}$, and $\final{P_1}=\{(\ref{r3})\}$.
Rule~(\ref{r1}) states that the gun is initially loaded.
Rule~(\ref{r2}) gives the choice to shoot, load, or unload the gun.
Rule~(\ref{r3}) states that if the gun is shot while it has been loaded, and not unloaded since, the target is dead.
Rule~(\ref{r4}) states that if the target is dead, we shoot it again.
Rule~(\ref{r5}) ensures that the target is dead at the end of the trace.

The satisfaction relation of a past-present rule on an \HT-trace $\M$ of length $\lambda$ and
at time point $\rangeo{k}{0}{\lambda}$ is defined below:

\begin{itemize}
\item $\M, k \models \Hd \leftarrow \Bd$ iff $\M', k \not \models \Bd$ or $\M', k \models \Hd$, for all $\M' \in \lbrace \M,\tuple{\T,\T} \rbrace$
\item $\M, k \models \wnext\,\alwaysF ( \Hd$  $\leftarrow$ $\Bd)$  iff $\M', i \not \models \Bd$ or $\M', i \models \Hd$ for all $\M' \in \lbrace \M,\tuple{\T,\T} \rbrace$ and all $\rangeo{i}{k+1}{\lambda}$
\item $\M, k \models \alwaysF(\,\finally \to (\bot \leftarrow \Bd )\,)$ iff $\tuple{\T,\T}, \lambda -1 \not \models \Bd$
\end{itemize}

An \HT-trace $\M$ is a \emph{model} of a past-present program $P$ if $\M,0 \models r$ for all rule $r \in P$.
%We write $\THT(P,\lambda)$ to stand for the set of \THTf-models of length $\lambda$ of a program $P$.
%Given a set of \THTf-models, we define the ones in equilibrium as follows.
%and define $\THT(\Gamma) \eqdef \THT(\Gamma,\omega) \cup \bigcup_{\lambda\in\mathbb{N}}\THT(\Gamma,\lambda)$.
%That is, $\THT(\Gamma)$ is the whole set of models of $\Gamma$ of any length.
%For $\Gamma=\{\varphi\}$, we just write $\THT(\varphi,\lambda)$ and $\THT(\varphi)$.
%%
%We can analogously define $\LTL(\Gamma,\lambda)$, that is, the set of traces of length $\lambda$ that satisfy theory $\Gamma$, and $\LTL(\Gamma)$, that is, the \LTL-models of $\Gamma$ any length.
%
%We omit specifying \LTL\ satisfaction since it coincides with \THT\ when \HT-traces are total.
%% ----------------------------------------------------------------------
%\begin{proposition}[\cite{agcadipevi13a,cakascsc18a}]\label{prop:total}
%Let \T\ be a trace of length $\lambda$, $\varphi$ a temporal formula, and $k\in\intervo{0}{\lambda}$ a time point.
%Then,
%%
%$\Ttrace,k \models \varphi$ in \LTL\ iff $\tuple{\Ttrace,\Ttrace},k \models \varphi$.\qed
%\end{proposition}
% ----------------------------------------------------------------------
%In fact, total models can be forced by adding the following set of \emph{excluded middle} axioms:
%\begin{align}
%\alwaysF (a \vee \neg a) \tag{\EM}
%\qquad
%\text{ for each atom }
%a \in \A\
%\text{ in the alphabet.}
%\end{align}
%% ----------------------------------------------------------------------
%\begin{proposition}[\cite{agcadipevi13a,cakascsc18a}]\label{prop:emtotal}
%Let $\tuple{\Htrace,\Ttrace}$ be an \HT-trace and (EM) the theory containing all excluded middle axioms for every atom $a \in \A$.
%Then, $\tuple{\Htrace,\Ttrace}$ is a model of (EM) iff $\Htrace=\T$.\qed
%\end{proposition}
%% ----------------------------------------------------------------------
%Satisfaction of derived operators can be easily deduced, as shown next.
%%
%% ----------------------------------------------------------------------
%\begin{proposition}[\cite{agcadipevi13a,cakascsc18a}]\label{prop:satisfaction:tel}
%  Let $\M=\tuple{\Htrace,\Ttrace}$ be an \HT-trace of length $\lambda$ over \A.
%  Given the respective definitions of derived operators, we get the following satisfaction conditions:
%  \begin{enumerate} \setcounter{enumi}{11}
%  \item $\M, k \models \initially$
%    iff
%    $k =0$
%  \item $\M, k \models \wprevious\varphi$
%    iff
%    $k =0$ or
%    $\M, k{-}1 \models \varphi$
%  \item $\M, k \models \eventuallyP\varphi$
%    iff
%    $\M, i \models \varphi$ for some $\rangec{i}{0}{k}$
%  \item $\M, k \models \alwaysP\varphi$
%    iff
%    $\M, i \models \varphi$ for all $\rangec{i}{0}{k}$
%  \item $\M, k \models \finally$
%    iff
%    $k+1 = \lambda$
%  \item $\M, k \models \wnext\varphi$
%    iff
%    $k + 1=\lambda$ or
%    $\M, k{+}1 \models \varphi$
%  \item $\M, k \models \eventuallyF\varphi$
%    iff
%    $\M, i \models \varphi$ for some $\rangeo{i}{k}{\lambda}$
%  \item $\M, k \models \alwaysF\varphi$
%    iff
%    $\M, i \models \varphi$ for all $\rangeo{i}{k}{\lambda}$
%  \end{enumerate}
%  \qed
%\end{proposition}
%A formula $\varphi$ is a \emph{tautology} (or is \emph{valid}), written $\models \varphi$,
%iff $\M,k \models \varphi$ for any \HT-trace \M\ and any $\rangeo{k}{0}{\lambda}$.
%We call the logic induced by the set of all tautologies \emph{Temporal logic of Here-and-There} (\THT\ for short).
%\begin{proposition}[Persistence]\label{prop:persistance}
%  Let $\tuple{\Htrace,\Ttrace}$ be an \HT-trace of length $\lambda$ and $\varphi$ be a temporal formula.
%  %
%  Then, for any $\rangeo{k}{0}{\lambda}$, $k \neq \omega$,
%  if $\tuple{\Htrace,\Ttrace}, k \models \varphi$ then $\tuple{\Ttrace,\Ttrace}, k \models \varphi$ (or, if preferred, $\Ttrace,k \models \varphi$).\qed
%\end{proposition}
%As a corollary, we have that
%$\langle\mathbf{H},\mathbf{T}\rangle \models \neg \varphi$ iff ${\T} \not\models \varphi$ in \LTL{}.
%
% --------------------------------------------------------------------------------
% \begin{definition}[Temporal Equilibrium/Stable Model]\label{def:tem}
Let $P$ be past-present program.
A total \HT-trace $\tuple{\Ttrace,\Ttrace}$ is a \emph{temporal equilibrium model} of $P$ iff
$\tuple{\Ttrace,\Ttrace}$ is a \emph{model} of $P$,
and there is no other $\Htrace < \T$ such that $\tuple{\Htrace,\Ttrace}$ is a \emph{model} of $P$.
The trace \T\ is called a \emph{temporal stable model} (\TS-model) of $P$.
% \qed
% \end{definition}

For length $\lambda = 2$, $P_1$ has a unique \TS-model $\{load\}\cdot\{shoot, dead\}$.
