\section{Temporal loop formulas with unitary cycles}\label{sec:unitary-cycles}

Ferraris et al.~\cite{feleli06a} proposed an approach where the computation of the completion
can be avoided by considering unitary cycles.
In this section, we extend such results for past-present programs.
We first redefine loops so that unitary cycles are included.
\begin{definition}[Unitary cycle]
  A nonempty set $L\subseteq \mathcal{A}$ of atoms is called $\emph{loop}$ of $P$ if, for every pair $a,b$ of atoms in $L$,
  there exists a path (possibly of length 0) from $a$ to $b$ in $G(P)$ such that all vertices in the path belong to $L$.
\end{definition}

With this definition, it is clear that any set consisting of a single atom is a loop.
For example, $\Loops{\dynamic{P_1}}=\{\{load\},\{unload\},\{shoot\},\{dead\},\{shoot, dead\}\}$.

\begin{theorem}\label{thm:loops0}
  Let  $P$ be a past-present program and $\T$ a trace of length $\lambda$.
  Then,
  \T\ is a \TS-model of $P$
  iff
  \T\ is a \LTLf-model of $P \cup \LF{P}$.
\end{theorem}

With unitary cycle, $\LF{P_1}$ becomes
\begin{align*}
    load &\rightarrow \top\\
    unload &\rightarrow \bot\\
    shoot &\rightarrow \bot\\
    dead &\rightarrow \bot\\
    \wnext\alwaysF( load &\rightarrow \neg shoot \wedge\neg unload)\\
    \wnext\alwaysF( unload &\rightarrow \neg shoot \wedge\neg load)\\
    \wnext\alwaysF( shoot &\rightarrow (\neg shoot \wedge\neg load)\vee dead)\\
    \wnext\alwaysF( dead &\rightarrow shoot \wedge \neg unload \since load)\\
    \wnext\alwaysF(shoot\vee dead &\rightarrow \neg load \wedge\neg unload)
\end{align*}

$P_1\cup\LF{P_1}$ has the same \LTLf-model $\tCF{P_1} \cup \LF{P_1}$, $\{load\}\cdot\{shoot, dead\}$, which is the \TS-model of $P_1$.
