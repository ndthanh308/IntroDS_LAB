%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the template for submission to MICRO 2023
% The cls file is modified from 'sig-alternate.cls'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass{sig-alternate}
\usepackage{mathptmx} % This is Times font

\usepackage{fancyhdr}
\usepackage[normalem]{ulem}
\usepackage[hyphens]{url}
\usepackage[sort,nocompress]{cite}
\usepackage[final]{microtype}
\usepackage[keeplastbox]{flushend}
% Always include hyperref last
\usepackage[dvipsnames]{xcolor}
\usepackage[bookmarks=true,breaklinks=true,colorlinks,allcolors=BlueViolet]{hyperref}

% added packages (not included in MICRO template)
\usepackage{authblk}

\usepackage{braket}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{courier}
\usepackage{tikz}
\usetikzlibrary{quantikz}

\usepackage{lipsum}
\usepackage{afterpage}
\usepackage{stfloats}
\usepackage{caption}
\usepackage{subcaption}

\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\sign}{sign}
\DeclareMathOperator{\qubits}{qubits}
\DeclareMathOperator{\concat}{concat}

\newcommand{\passed}{\mathrm{passed}}
\newcommand{\caught}{\mathrm{caught}}
\newcommand{\remaining}{\mathrm{remaining}}
\newcommand{\orig}{\mathrm{orig}}
\newcommand{\SQG}{\mathrm{SQG}}
\newcommand{\tmax}{\mathrm{max}}

\captionsetup{labelfont=bf, textfont=bf}

\usepackage{float}  % allow [H] figure placement
\usepackage{graphicx}
\graphicspath{{./figures/}} % set path for all figures

\usepackage{enumitem}

%%% algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\SetAlgoCaptionSeparator{:}
\SetAlCapFnt{\normalsize}
\SetAlCapNameFnt{\normalsize}


% Ensure letter paper
\pdfpagewidth=8.5in
\pdfpageheight=11in

%%%%%%%%%%%---SETME-----%%%%%%%%%%%%%
\newcommand{\microsubmissionnumber}{1204}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\fancypagestyle{firstpage}{
  \fancyhf{}
  \renewcommand{\headrulewidth}{0pt}
  \fancyhead[C]%{\vspace{10pt}\normalsize{MICRO 2023 Submission
  %    \textbf{\#\microsubmissionnumber} -- Confidential Draft -- Do NOT Distribute!!}\\\vspace{-25pt}} 
  %\fancyfoot[C]{\thepage}
}

\pagenumbering{arabic}

%%%%%%%%%%%---SETME-----%%%%%%%%%%%%%
\title{Decomposing and Routing Quantum Circuits Under Constraints for Neutral Atom Architectures} 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\author[1,*]{Natalia Nottingham}
\author[2]{Michael A. Perlin}
\author[1]{Ryan White}
\author[1]{Hannes Bernien}
\author[1]{Frederic T. Chong}
\author[3,4]{Jonathan M. Baker}
\affil[1]{University of Chicago, Chicago, Illinois, USA}
\affil[2]{Infleqtion, Chicago, Illinois, USA}
\affil[3]{Duke University, Durham, North Carolina, USA}
\affil[4]{University of Texas at Austin, Austin, Texas, USA}
%\affil[*]{nottingham@uchicago.edu}

% for footnote with symbol instead of number (hack for providing author email)
\usepackage[symbol]{footmisc}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\begin{document}
\sloppy % prevents text from going outside the margins
\maketitle
\thispagestyle{firstpage}
\pagestyle{plain}

\footnotetext[1]{nottingham@uchicago.edu}

%%%%%% -- PAPER CONTENT STARTS-- %%%%%%%%


\begin{abstract}

Quantum computing is in an era defined by rapidly evolving quantum hardware technologies, combined with persisting high gate error rates, large amounts of noise, and short coherence times. Overcoming these limitations requires systems-level approaches that account for the strengths and weaknesses of the underlying hardware technology. Yet few hardware-aware compiler techniques exist for neutral atom devices, with no prior work on compiling to the neutral atom native gate set. In particular, current neutral atom hardware does not support certain single-qubit rotations via local addressing, which often requires the circuit to be decomposed into a large number of gates, leading to long circuit durations and low overall fidelities. 

We propose the first compiler designed to overcome the challenges of limited local addressibility in neutral atom quantum computers. We present algorithms to decompose circuits into the neutral atom native gate set, with emphasis on optimizing total pulse area of global gates, which dominate gate execution costs in several current architectures. Furthermore, we explore atom movement as an alternative to expensive gate decompositions, gaining immense speedup with routing, which remains a huge overhead for many quantum circuits. Our decomposition optimizations result in up to $\sim3.5$x and $\sim2.9$x speedup in time spent executing global gates and time spent executing single-qubit gates, respectively. When combined with our atom movement routing algorithms, our compiler achieves up to $\sim10$x reduction in circuit duration, with over $\sim2$x improvement in fidelity. We show that our compiler strategies can be adapted for a variety of hardware-level parameters as neutral atom technology continues to develop. 
\end{abstract}


\section{Introduction} \label{introduction}

Recent years have shown drastic improvements in the development of quantum computing hardware technologies, including superconducting qubits, neutral atoms, and trapped ions. Neutral atom quantum computers have demonstrated immense promise due to their exceptionally long coherence times, scalability, native multi-qubit gates, higher connectivity resulting from longer-range interactions, and the ability to produce identical and well-characterized qubits \cite{jaksch_fast_2000,morgado_quantum_2021}.

% Figure environment removed


Despite these advancements, quantum computing remains in an era defined by large amounts of noise, high gate error rates, and the possibility of qubit states decohering prior to completion of the circuit. Given these constraints, hardware-aware optimizations at the compiler level--that successfully exploit the hardware platform's advantages while employing techniques to overcome its limitations--are absolutely essential. At the same time, since neutral atoms are a newer and rapidly evolving hardware platform, we need compiler approaches that can be easily applied to a wide variety of hardware models as the technology grows.

While considerable prior work exists on quantum compilation \cite{anis_qiskit_2021,cirq_developers_2022_7465577,sivarajah_tket_2020,cowtan_qubit_2019,murali_noise-adaptive_2019,xu_quartz_2022,molavi_qubit_2022}, the majority of such work has either been hardware-agnostic or tailored to the constraints of superconducting qubits, with limited work focusing on compiler approaches for neutral atoms. Baker et al.~\cite{baker_exploiting_2021}, Patel et. al.~\cite{patel_geyser_2022}, and Li et. al.~\cite{li_timing-aware_2023} took the first steps towards developing compilers specific to neutral atom hardware, accounting for properties such as long-distance interactions, atom loss, and native multi-qubit gates.  %Baker et al.~\cite{baker_exploiting_2021} proposed the first compiler to account for hardware-level characteristics specific to neutral atom devices, including long-distance interactions and atom loss. Patel et al.~\cite{patel_geyser_2022} expanded upon this work with compiler strategies to replace one- and two-qubit circuit blocks with native three-qubit gates, thereby reducing total pulse count.

However, \cite{baker_exploiting_2021,patel_geyser_2022,li_timing-aware_2023} assume a native gate set in which all single-qubit gates can be executed via locally-addressing beams. This assumption is inconsistent with current neutral atom hardware, where execution of certain single-qubit gates is only supported natively via globally-addressing beams that rotate all qubits homogeneously. Though global addressing presents fewer engineering challenges and lower costs on a hardware level, it creates a more difficult compiler problem: if a global gate is used to execute an operation that acts only on a small subset of qubits in the original circuit, the compiler must ensure that any operation on off-target qubits is ``undone''. This consideration can lead to expensive decompositions and contributes significantly to circuit runtimes.

In this paper, we propose two main contributions to address this problem. First, we develop compiler passes to decompose a high-level input quantum circuit, expressed in terms of any arbitrary gate set, into a native gate set that is realistic of current neutral atom hardware with limited local control. We significantly reduce the cost of the single-qubit gate decompositions by minimizing the total global gate pulse area, with additional optimizations to lower \texttt{Rz} gate costs.

Second, we observe that a large number of native neutral atom gates is required to decompose each \texttt{SWAP} gate, greatly increasing routing overhead when using conventional \texttt{SWAP}-based routing strategies on neutral atom devices. We therefore develop routing methods that incorporate atom movement as an alternative to expensive \texttt{SWAP} decompositions. Because physical rearrangement of atoms is not limited by blockade radius, it provides a strong alternative to \texttt{SWAP} gates, allowing us to overcome device connectivity constraints and providing greater flexibility in routing decisions. Our approach greatly lowers two-qubit gate costs and routing overhead, improving both circuit duration and fidelity. 


We combine these steps into a full compiler pipeline designed to overcome the challenges of global addressing while exploiting the benefits of atom movement. Our specific contributions are the following: 
%Our work is the first to propose strategies and optimizations for translating a circuit into a native gate set in which certain operations can only be implemented globally, and furthermore, one of the first to explore the implications of atom movement from a compiler and architectural standpoint. 

\begin{itemize}
    \item Two decomposition methods, including optimizations that minimize the global rotation angle necessary to decompose a collection of parallel single-qubit gates, resulting in up to 3.5x improvement in total global gate execution time. 
    \item A routing algorithm using atom movement that achieves 2.5x average speedup in circuit duration across all benchmarks and hardware models tested, with this number increased to 3.5x average speedup on hardware where global gate durations are dominant.
    %\item A routing algorithm using atom movement, allowing us to avoid the expensive decompositions necessary to convert \texttt{SWAP} gates into the native neutral atom gate set, achieving 2.5x average speedup in circuit duration, with this number increased to 3.5x average speedup on hardware where global gate durations are dominant.
    \item A holistic pipeline (shown in Figure \ref{fig:overview}) that, when all components are combined, achieves up to 10x speedup and 2x improvement in fidelity. 
    \item Evaluations which account for several key hardware-level parameters, demonstrating that our compiler passes can be successfully applied to a diverse set of neutral atom hardware models. 
\end{itemize}

\section{Background}

% Figure environment removed


\subsection{Quantum Computing} \label{background, quantum computing}

The state of quantum bits, or \textit{qubits}, is represented as a complex linear superposition $\alpha\ket{0}+\beta\ket{1}$ of the single-qubit basis states $\ket{0}$ and $\ket{1}$. 
This state is manipulated by gates;
% , transforming the state by changing the probability amplitudes (e.g., the $\alpha$ and $\beta$) of each basis state.
%or, in the case of multi-qubit gates, by creating entanglement.
an $n$-qubit gate is represented by a $2^n\times 2^n$ unitary matrix. %transformation expressed as a $2^n\times 2^n$ matrix. 
All single-qubit quantum gates can be visualized as rotating the state by a given angle around a specified axis on the Bloch sphere, where the unit vectors along the sphere's $+z$ and $-z$ axes represent the computational basis states $\ket{0}$ and $\ket{1}$, respectively. Examples of these rotations are in Figure \ref{fig:decomposition_visualizations}.

%The state of an $n$-qubit circuit is a $2^n$-dimensional complex-valued vector in Hilbert space. The potential for quantum speedup over classical computing can be thought of as arising from this property: a linear increase in the number of qubits leads to an exponential increase in the amount of information stored in the quantum circuit. 



\subsection{Native Gate Set \& Global Addressing}

At a high level, a quantum program is expressed in terms of operations from a chosen universal gate set, usually consisting of arbitrary \texttt{U3} single-qubit rotations plus a two-qubit entangling gate such as \texttt{CZ}. 
We refer to this gate set $\{\texttt{U3},\texttt{CZ}\}$ as the \texttt{StandardGateSet}. However, this may contain operations are not in the hardware's \textit{native gate set}, i.e., the set of gates that can be directly executed on hardware, usually in the form of laser or microwave pulses. The compiler must convert high-level quantum circuits into an equivalent circuit using only gates from the hardware's native gate set. 

%not all quantum gates can be directly implemented on physical hardware. The set of quantum operations that can be directly executed on hardware, usually in the form of laser or microwave pulses, is referred to as the \textit{native gate set} and varies depending on the hardware technology. The compiler must convert high-level quantum circuits into an equivalent circuit using only gates from the hardware's native gate set. 

%At a high level, a quantum program is expressed in terms of operations from a chosen universal gate set. This high-level gate set does not necessarily correspond to the hardware's \textit{native gate set}--the set of quantum operations that can be directly executed on the hardware, usually in the form of laser of microwave pulses. The compiler must therefore convert the high-level quantum circuits into equivalent circuits using only gates from the hardware's native gate set. 

Current neutral atom technology does not natively support individually-addressing single-qubit rotations about an axis in the xy-plane of the Bloch sphere, where \textit{individually-addressing} or \textit{locally-addressing} gates refer to operations applied to a chosen qubit without affecting other qubits. Instead, \textit{globally-addressing} gates must be used where the same operation is applied simultaneously to all qubits in the circuit. 

The neutral atom native gate set we consider is referred to as the \texttt{NeutralAtomGateSet},
consisting of local \texttt{CZ} gates, local \texttt{Rz}$(\lambda)$ gates, and global \texttt{GR}$(\theta,\phi)$ gates:
\begin{gather}
    \texttt{CZ} = \diag(1, 1, 1, -1),
    %\begin{bmatrix}
    %    1 & 0 & 0 & 0 \\
    %    0 & 1 & 0 & 0 \\
    %    0 & 0 & 1 & 0 \\
    %    0 & 0 & 0 & -1 
    %\end{bmatrix}  
    \label{eqn:Cz_gate_matrix} \\
    \texttt{Rz}(\lambda) = \exp\left(-i\lambda \hat{Z}/2\right)
    = \diag(e^{-i\lambda/2}, e^{i\lambda/2}),
    %\begin{bmatrix}
    %    e^{-i\frac{\lambda}{2}} & 0 \\
    %    0 & e^{i\frac{\lambda}{2}}
    %\end{bmatrix} 
    \label{eqn:Rz_gate_matrix} \\
    \texttt{GR}(\theta,\phi)
    = \exp\left(-i\frac{\theta}{2}\sum_{j=1}^{n} (\cos(\phi)\hat{X_j} + \sin(\phi)\hat{Y_j})\right).
    % =  \prod_{i=1}^n \exp\left(-i \frac{\theta}{2}(cos(\phi)\hat{X_j}+sin(\phi)\hat{Y_j})\right)
    \label{eqn:GR_gate_matrix}
\end{gather}
Here, $\hat{Z}$ is a single-qubit Pauli-$Z$ matrix, $\hat{X}_j$ and $\hat{Y}_j$ are Pauli-$X$ and Pauli-$Y$ matrices for qubit $j$, $\lambda$ and $\theta$ are rotation angles for \texttt{Rz} and \texttt{GR} gates, and the angle $\phi$ parameterizes the \texttt{GR} gate's axis of rotation.
The globally-addressing \texttt{GR}$(\theta,\phi)$ gate implements the same operation as $n$ locally-addressing \texttt{R}$(\theta,\phi)$ gates executed separately on each qubit in the circuit.

When decomposing to a gate set containing global operations, there is the potential for significant increases in the circuit's total gate count (see Section \ref{section: decomposing to native gate set}). Optimizing this step is crucial to maximizing performance and fidelity.

\subsection{Atom Movement}
One advantage of neutral atoms is the ability to physically move qubits from one location to another during execution of the circuit. In contrast, with superconducting hardware, for example, physical qubits must remain in a fixed location on the hardware, and quantum states stored in the qubits are exchanged via gate-level \texttt{SWAP} operations: \texttt{SWAP}$(\ket{\psi_1}\otimes\ket{\psi_2})=\ket{\psi_2}\otimes\ket{\psi_1}$. Bluvstein et al.~\cite{bluvstein2022quantum} show experimentally that entangled qubits can be coherently transported across a two-dimensional atom array with no negative effect on qubit entanglement nor fidelity when qubits are moved at a speed of 0.55$\mu$m/$\mu$s or slower. Though atom loss was noted to be the dominant error source with atom movement, this did not begin to have any effect until movement speed was increased beyond the threshold of 0.55$\mu$m/$\mu$s. This ability to rearrange atoms mid-experiment creates the possibility of changing the connectivity of the atomic array, enabling higher levels of control over how and when \texttt{CZ} and \texttt{Rz} gates are applied.

\subsection{Neutral Atom Hardware}

With neutral atom quantum computing, the computational states $\ket{0}$ and $\ket{1}$ are encoded in the hyperfine ground states of an alkali atom such as Cesium (Cs) or Rubidium (Rb), or alkaline-earth atom such as Strontium (Sr) or Ytterbium (Yb).
Two-qubit entangling interactions are mediated with highly-excited Rydberg states \cite{saffman2010quantum}. \texttt{CZ} and \texttt{Rz} gates are implemented via locally-addressing beams involving a blue-wavelength laser -- which off-resonantly addresses an atomic transition between the computational $\ket{0}$ state and an intermediate state -- and an infrared laser, which bridges the excitation from the intermediate state to a Rydberg state. Simultaneous application of both the blue and infrared lasers on two nearby qubits is used to achieve a \texttt{CZ} gate if the qubits are within a ``blockade radius'', i.e., if they are close enough that excitation to the Rydberg state in one atom shifts the Rydberg transition to be off-resonant in the other atom. Application of the blue laser alone induces an AC Stark shift, which shifts the $\ket{0}$ and $\ket{1}$ energy levels relative to each other without changing the state populations, thereby accomplishing a single-qubit \texttt{Rz} gate. Single-qubit \texttt{Rx} and \texttt{Ry} gates, which change the $\ket{0}$ and $\ket{1}$ state populations, require a different infrastructure, implemented via globally-addressing microwaves introduced with a microwave horn \cite{graham_rydberg_2019} or Raman laser system \cite{lukin_raman}.

Atoms are held in place within a two-dimensional array by optical tweezers, generated using e.g. a spatial light modulator (SLM). Acousto-optic deflectors (AODs) rearrange atoms within the array \cite{bluvstein2022quantum}, with one AOD controlling horizontal movement and another controlling vertical movement. While SLMs allow for any arbitrary two-dimensional arrangement of atoms, certain arrangements work better than others with AOD constraints; specifically, grid-like patterns allow for greater parallelism of movement operations. Spacing between atom sites is usually between $\sim$2-10$\mu$m\cite{graham_multi-qubit_2022,singh_dual-element_2022}. 

%in the array is chosen based on various hardware tradeoffs. With smaller spacing, less time is required to move atoms between sites, and qubit connectivity may be increased. However, placing atoms too close together increases cross-talk, whereby local operations on one atom site may affect nearby atoms, and atomic spacing must be kept much greater than the thermal motion of the atoms, such that local operations remain accurate. In most cases,  spacing is used .  

\subsection{Related Work \& Motivation}

%\subsubsection{General Quantum Compilation}

Numerous works exist on general quantum compilers or those tailored to superconducting systems, including \cite{anis_qiskit_2021,cirq_developers_2022_7465577,sivarajah_tket_2020,cowtan_qubit_2019,murali_noise-adaptive_2019,xu_quartz_2022,molavi_qubit_2022}. However, none of these frameworks support atom movement operations in circuits nor decompositions involving \texttt{GR} gates. Both components are important in neutral atom systems, and modifying previous frameworks to incorporate these components is not trivial.

%\subsubsection{Neutral Atom Specific Quantum Compilation}
Baker et al.~\cite{baker_exploiting_2021} proposed the first compiler to account for hardware-level characteristics specific to neutral atom devices, including long-distance interactions and atom loss. Patel et al.~\cite{patel_geyser_2022} expanded upon this work with compiler strategies to replace one- and two-qubit circuit blocks with native three-qubit gates, thereby reducing total pulse count. Li et al.~\cite{li_timing-aware_2023} developed scheduling techniques based on connectivity and parallelism constraints in neutral atom computers. 
Note that these works cannot be directly compared to our work in evaluations because they assume local addressibility for every gate. To execute circuits on hardware, their compilers would require additional passes (such as those implemented in our work) to decompose into a more realistic neutral atom native gate set. 

%\subsubsection{Routing on Reconfigurable Atom Arrays}\label{section: olsqraa background}

Tan et al.~\cite{tan_qubit_2022} developed the first compiler to incorporate atom movement into the routing step. While they provide a strong first step to build upon, particularly with accounting for hardware-level constraints at the compiler level, their algorithm is not scalable to larger circuits. Additionally, their approach requires a very large space overhead, which also leads to high atom movement costs, as atoms must travel farther distances. Their work minimizes two-qubit gate costs, but further work is needed to reduce atom movement costs.


%\subsubsection{Atom Shuffling With Trapped Ions}
%\textcolor{cyan}{
%Physical movement of atoms is also supported on trapped ion hardware, and Murali et al.~\cite{murali_architecting_2020} explore this at a compiler and architectural level. 
%However, this work does not extend to neutral atoms, primarily because ion traps are 1D, while neutral atoms are arranged within a 2D array. Additionally, the heuristics proposed in \cite{murali_architecting_2020} focus on avoiding congestion in shuttling paths between different traps in a modular architecture, which is not relevant to neutral atom arrays. 
%}

\section{Decomposing to Native Gates} \label{section: decomposing to native gate set}

\subsection{Pre-Processing}
We assume every circuit has been ``pre-compiled'' by commuting any sequence of single-qubit \texttt{Rz} gates past two-qubit \texttt{CZ} gates to merge \texttt{Rz} gates with other single-qubit gates. Additionally, the circuit must be transpiled into the \texttt{StandardGateSet} of \{U3, CZ\}. Existing transpiler passes from \texttt{Qiskit} or \texttt{Cirq} are sufficient for this \cite{anis_qiskit_2021,cirq_developers_2022_7465577}.

Before applying the decomposition steps, the circuit must be scheduled such that each moment contains either a) a group of parallelizable \texttt{U3} gates or b) a group of parallelizable \texttt{CZ} gates; i.e., a \texttt{U3} gate and \texttt{CZ} gate cannot be scheduled into the same moment. Using the decompositions presented below, any collection of parallelizable single-qubit gates can be decomposed together using the same number of global gates required to decompose only one single-qubit gate. Thus, maximizing single-qubit gate parallelism prior to decomposition minimizes the number of global gates in the final circuit.

Note that if routing occurs prior to decomposing into the native gate set, the circuit that is input into decomposition step can also contain movement operations, which can be scheduled into the same moments as \texttt{CZ} gates.

\subsection{Axial Decomposition} \label{section: axial decomposition}

Next, we decompose collections of parallelizable single-qubit gates from the \texttt{StandardGateSet} into the \texttt{NeutralAtomGateSet}.
We begin by decomposing any single-qubit \texttt{U3} gate into Euler-angle rotations as
\begin{align}
  \texttt{U3}(\theta, \phi, \lambda)
  = \texttt{Rz}(\phi)
  \, \texttt{Ry}(\theta)
  \, \texttt{Rz}(\lambda),
  \label{eqn:euler-angle}
\end{align}
where \texttt{Rz} and \texttt{Ry} are single-qubit rotations about the $z$ and $y$ axes.
The \texttt{Rz} gate is already an element of the \texttt{NeutralAtomGateSet}, so we only need to decompose the \texttt{Ry} gate further. 

In the \texttt{axial} decomposition, the single-qubit \texttt{Ry} gates are decomposed into the form
\begin{align}
  \prod_j \texttt{Ry}_j(\theta_j) =
  \texttt{GR}\left(-\frac{\pi}{2},0\right)
  \left[\prod_j\texttt{Rz}_j(\theta_j)\right]
  \texttt{GR}\left(\frac{\pi}{2},0\right),
  \label{eq:axial_decomp}
\end{align}
where $\texttt{Ry}_j(\theta_j)$ and $\texttt{Rz}_j(\theta_j)$ are respectively \texttt{Ry} and \texttt{Rz} gates addressing qubit $j$.
This decomposition is visualized in Figure \ref{fig:decomposition_visualizations}(a).
Intuitively, this decomposition uses a \texttt{GR} gate to move the $y$ axis to the $z$ axis, rotates qubits about the $z$ axis with local \texttt{Rz} gates, and then moves the $z$ axis back to the $y$ axis with another \texttt{GR} gate.
%This decomposition is called \emph{axial} because the rotation angles $\theta_j$ are imprinted into qubits using ``axial'' \texttt{Rz} gates that rotate qubits around the quantization axis that defines the $\ket{0}$ and $\ket{1}$ states.

\subsection{Transverse Decomposition}\label{section: transverse decomposition}

% Figure environment removed

The key feature of the \texttt{transverse} decomposition, as compared to the \texttt{axial} decomposition presented above, is that it has a net \texttt{GR} pulse area of $|\theta|$ rather than $\pi$, which is the minimum \texttt{GR} pulse area possible to implement an $\texttt{Ry}(\theta)$ gate. This minimization results in significantly reduced runtimes in hardware platforms that implement the \texttt{GR} gates with relatively slow microwave beams.

We start by once again decomposing the single-qubit \texttt{U3} gate into Euler angles according to \ref{eqn:euler-angle}. The difference comes from our decomposition of the single-qubit \texttt{Ry} gate, which relies on the decomposition of a rotation into two reflections:  

\begin{align}
  \texttt{Ry}(\theta) \label{eqn: transverse_beginning}
  = \texttt{Rv}\left(\pi, \frac{\theta}{2}\right)\texttt{Rz}(-\pi)
\end{align}
where $\texttt{Rv}(\xi,\omega)$ is a single-qubit rotation by the angle $\xi$ about the axis $\texttt{V}_\omega=\cos\omega\texttt{Z}+\sin\omega\texttt{X}$.
In turn, we can decompose
\begin{align}
  \texttt{Rv}(\xi, \omega)
  = \texttt{GR}\left(\omega, \frac{\pi}{2}\right)
  \texttt{Rz}(\xi)
  \texttt{GR}\left(-\omega, \frac{\pi}{2}\right).
\end{align}
This decomposition is visualized in Figure \ref{fig:decomposition_visualizations}(b).
Similarly to the \texttt{axial} decomposition, this decomposition can be understood as moving the $\texttt{V}_\omega$ axis to the $z$ axis, rotating about the $z$ axis, and moving the $z$ axis back to $\texttt{V}_\omega$.
%We call this decomposition ``transverse'' because it imprints the rotation angle $\theta$ onto a qubit using \texttt{GR} gates that rotate about an axis transverse to the qubit quantization axis.

Putting everything together, when multiple qubits are addressed by \texttt{U3} gates the \texttt{transverse} decomposition takes the form
\begin{align}
  \prod_j\texttt{U3}_j(\theta_j, \phi_j^-, \phi_j^+) 
  = \prod_j
  \texttt{Rz}_j(\gamma_j^-)
  \texttt{Rv}_j\left(\chi_j, \frac{\theta_\tmax}{2}\right)
  \texttt{Rz}_j(\gamma_j^+)
\end{align}
where $\theta_\tmax=\pm\max_j|\theta_j|$ (sign arbitrary), and the angles $\gamma_j^+$, $\gamma_j^-$, and $\chi_j$ are defined in terms of arbitrary signs $\sigma_j\in\set{+1,-1}$ by
\begin{align}
  \gamma_j^\pm &= \phi_j^\pm - \sigma_j (\alpha_j \pm \beta_j), \\ \label{eqn: transverse_decomposition_first}
  \alpha_j &= \arctan(\cos(\theta_\tmax/2) \kappa_j), \\
  \beta_j &= \sign(\theta_j) \sign(\theta_\tmax) \times \frac{\pi}{2}, \\
  \chi_j &= \sigma_j \times 2\arctan(\kappa_j), \\
  \kappa_j &= \sqrt{\frac{\sin(\theta_j/2)^2}{\sin(\theta_\tmax/2)^2-\sin(\theta_j/2)^2}}. \label{eqn: transverse_decomposition_last}
\end{align}
Here $\sign(x)=x/|x|\in\set{+1,-1}$ if $x\ne 0$ and 0 otherwise. We define $\kappa_j = \infty$ if $\theta_j = \pm\theta_\tmax$, with $\arctan(\infty)=\pi/2$.
The axis of rotation for the \texttt{GR} gate can be changed with the addition of extra \texttt{Rz} gates on qubits before and after the decomposition. Eqn.~\eqref{eqn: transverse_beginning}-\eqref{eqn: transverse_decomposition_last} may give \texttt{Rz} angles with absolute value greater than $\pi$. To reduce duration, these should be converted to the equivalent rotation amount with absolute value less than $\pi$ by adding or subtracting multiples of $2\pi$.

\subsection{Post-Processing} \label{section: post-processing}

While the steps presented in \ref{section: axial decomposition} and \ref{section: transverse decomposition} are sufficient to convert a circuit into the \texttt{NeutralAtomGateSet}, there are additional steps we can take to further reduce gate count and total rotation amount. In particular, the axis of rotation of the \texttt{GR} gates can be changed from $0$ to $\eta$ at the cost of adding the gates $\prod_j\texttt{Rz}_j(\mp\eta)$ before ($-$) and after ($+$) the right-hand side of Eq.~\eqref{eq:axial_decomp}.
This freedom in rotation axis can be used to eliminate some of the \texttt{Rz} gates that precede the first \texttt{GR} gate in the decomposition of \texttt{U3} gates.
Additionally, all \texttt{Rz} gates after the last \texttt{GR} gate in this decomposition can be eliminated by being ``pushed forward'' in the circuit and absorbed into the next layer of single-qubit gates.

%\subsection{Alternative Using Atom Movement}

% Figure environment removed 

% Figure environment removed

\subsection{Routing With Atom Movement}\label{section: routing with movement}

\section{Routing Procedure}   

\subsection{Initial Mapping}

The initial mapping assigns each \textit{program qubit} (i.e., a qubit in the circuit) to a unique \textit{hardware qubit} (i.e., a physical atom). The goal is to find an initial mapping that minimizes the number of operations that must be added via routing. This is typically achieved via heuristic methods that place frequently-interacting program qubits close together on the hardware, often weighting interactions higher if they occur closer to the circuit's start \cite{sivarajah_tket_2020,cowtan_qubit_2019,murali_noise-adaptive_2019}. These prior works are effective for our compilation scheme.  

%We note that attempts to minimize noise by accounting for variations in hardware qubits, such as those that rely on machine calibration data to map frequently-used program qubits to higher-reliability hardware qubits \cite{murali_noise-adaptive_2019,sivarajah_tket_2020}, are not relevant with neutral atom quantum computing. Unlike superconducting systems--which display varying hardware characteristics across different qubits--neutral atom systems have identical qubits if the same species and isotope are used for all atoms.

\subsection{Routing With SWAP Gates} \label{section: routing with SWAPs}

\subsubsection{Baseline SWAP-Based Routing}

Routing consists of inserting operations into the circuit, often in the form of \texttt{SWAP} gates, to ensure the entire circuit can be executed while respecting the target architecture's connectivity constraints. This process relies on the use of a \textit{connectivity graph}, where nodes correspond to hardware qubits, and edges correspond to pairs of hardware qubits on which two-qubit gates can be executed. For each moment $t$ in the circuit, we must satisfy the following constraint: $\forall\texttt{CZ}\left(q_a,q_b\right)\in t$, $\left(m_t\left(q_a\right),m_t\left(q_b\right)\right)\in E_{cg}$, where $m_t$ is the mapping from program qubits to hardware qubits for moment $t$ and $E_{cg}$ is the connectivity graph's edge set. If not satisfied, the mapping is permuted by inserting \texttt{SWAP} gates until the 
\texttt{CZ} gates' operands are assigned to connected hardware qubits.

For our baseline routing strategy using \texttt{SWAP} gates, we follow the algorithm in \cite{sivarajah_tket_2020}, with the connectivity graph determined by constraints given below. Each \texttt{SWAP} gate is replaced with the decomposition in Figure \ref{fig:swap_decomposition}.

\subsubsection{Two-Qubit Gate Constraints on Neutral Atoms}\label{section: two-qubit gate constraints}

On neutral atom hardware, connectivity is determined by Rydberg blockade radius: to execute a two-qubit gate, the distance between the qubits involved in that gate must be less than the blockade radius. The edge set of the \texttt{connectivity graph} contains all qubit pairs that satisfy this constraint.

Multiple two-qubit gates are parallelizable if 1) the gates act on disjoint subsets of qubits, and 2) operands of \textit{different} gates are \textit{farther} than a blockade radius--i.e., \texttt{CZ}$\left(q_a,q_b\right)$ and \texttt{CZ}$\left(q_c,q_d\right)$ can execute simultaneously if none of $\{\left(q_a,q_c\right),\left(q_a,q_d\right),\left(q_b,q_c\right),\left(q_b,q_d\right)\}$ are in the \texttt{connectivity graph}.

\subsection{Routing With Atom Movement}\label{section: atom movement routing}

\subsubsection{Movement Constraints on Neutral Atoms} \label{section: movement constraints}

Unlike two-qubit \texttt{SWAP} and \texttt{CZ} gates, movement operations are not constrained by blockade radius. However, there are other considerations when routing with atom movement:
\begin{enumerate}
    \item When moving from one location to another, an atom cannot get within some threshold distance $d_{thr}$ from any other (stationary or moving) qubits, where $d_{thr}$ is the distance below which two adjacent optical traps significantly interfere with each other, resulting in a high probability of losing atomic qubits. This is not the same as the distance at which qubits experience crosstalk during gate execution, which determines spacing $s$.  
    \item If we label atoms' starting positions within the 2D array with coordinates $\left(x,y\right)$ and ending coordinates $\left(x',y'\right)$, simultaneous movement operations can occur on atoms with the same $x$ value only if it will also result in the same $x'$ value. Stated more simply, columns of atoms move horizontally together. 
    \item Similarly, we can simultaneously move atoms with the same $y$ value only if they end at the same $y'$ value, i.e., rows of atoms must move vertically together. 
\end{enumerate}

The last two constraints, depicted in Figure \ref{fig:atom movement}(a) and \ref{fig:atom movement}(b), are a consequence of the AOD technology used to move atoms, which can only create rectangular arrays of optical traps. However, when moving atoms one at a time, any arbitrary movement path can be completed; thus, if two movement operations do not meet these AOD-related constraints for parallel movement, they are scheduled in serial. This serialization often does not have significant effect on circuit duration, as 1) in the case of routing, opportunities for parallelism of movement operations are related to opportunities for parallelism of two-qubit gates, which are already low in many quantum circuits, and 2) if necessary, we can tailor our routing approach to these constraints. We address the first point, related to atom separation during movement, in \ref{section: adjusting atom placements}.

Our routing algorithm assumes AOD rows and columns can cross--specifically when two atoms are simultaneously being moved in opposite directions without otherwise breaking these constraints. While this is feasible, it may lower fidelity on some hardware \cite{bluvstein2022quantum}. If this is an issue on the given hardware, we can make small adjustments to our algorithm without losing much of the improvements observed here. A simple solution is to move the two atoms in parallel up to the point where the AOD beams are close enough that atom loss or reduced fidelity is a risk, then move the first atom past the other while keeping the second atom stationary (allowing us to turn off the associated AOD beam), then move both in parallel the rest of the way. This will cause circuit duration to increase, though not by a significant amount, without any significant changes to the fidelity results simulated in this work. As a more sophisticated approach, we can develop mapping and routing algorithms aimed at minimizing crossings of rows and columns. We leave this for future work.

\subsubsection{Naive Movement Algorithm} \label{section: naive movement algorithm}

As a naive approach to routing with atom movement, we start by inserting \texttt{SWAP} gates into the circuit via the same steps described in \ref{section: routing with SWAPs}. Then, instead of replacing each \texttt{SWAP}$\left(q_a,q_b\right)$ with a decomposition (\ref{fig:swap_decomposition}), we replace it with two atom movement operations that can execute in parallel: one to move $q_a$ to atom site $m^{-1}_t\left(q_b\right)$ and another to move $q_b$ to atom site $m^{-1}_t\left(q_a\right)$, where $m^{-1}_t$ is the inverse of $m_t$. We determine which movement operations can be executed in parallel, according to constraints 2 and 3 in \ref{section: movement constraints}.

There is a subtle difference here in how the mapping is defined:  instead of mapping program qubits to \textit{hardware qubits}, we now map \textit{program qubits} (whose states are stored by the same hardware qubits throughout circuit execution) to \textit{atom sites}. We update our definition of the \textit{connectivity graph} such that nodes are atoms sites, and an edge exists between a pair of atom sites if a two-qubit gate can be performed on program qubits mapped to those sites. 

\subsubsection{Improved Movement Algorithm} \label{section: improved movement algorithm}

When routing with movement operations instead of \texttt{SWAP} gates, our choice of which qubit pairs to permute in the mapping is not limited by blockade radius. This allows for much greater flexibility when making routing decisions. 

Our algorithm relies on a simple yet powerful adjustment to the naive movement approach. We define a \textit{movement graph}, shown in figure \ref{fig:routing_graphs}, where nodes are atom sites, an edge $\left(s_i,s_j\right)$ indicates that an atom can be moved directly between sites $s_i$ to $s_j$ without breaking constraint 1 in \ref{section: movement constraints}, and edge weights give the distance between the corresponding atom sites. When iterating through the circuit, upon reaching a gate \texttt{CZ}$\left(q_a,q_b\right)$ that cannot be executed with the current mapping, we now use the \textit{movement graph} instead of the \textit{connectivity graph} to determine which qubits to permute in the mapping. We consider all pairs of program qubits $\left(u,v\right)$ such that 1) $\left(m_{t-1}\left(u\right),m_{t-1}\left(v\right)\right)\in E_{mg}$ where $E_{mg}$ is the movement graph's edge set, 2) $u\in\{q_a,q_b\}$ or $v\in\{q_a,q_b\}$, and 3) moving $u$ to $m_{t-1}\left(v\right)$ and $v$ to $m_{t-1}\left(u\right)$ will bring $q_a$ and $q_b$ closer than in the current mapping. Of these, we choose the program qubit pair $\left(u',v'\right)$ that results in the smallest distance between $q_a$ and $q_b$ after switching the places of $u'$ and $v'$, i.e., after permuting the mapping such that $m_{t}\left(u'\right)=m_{t-1}\left(v'\right)$ and $m_{t}\left(v'\right)=m_{t-1}\left(u'\right)$. We break any ties in the same way as before. Importantly, throughout this algorithm, the \textit{connectivity graph}, not the movement graph, still determines whether a \texttt{CZ} gate can execute between two qubits.

This approach increases average movement distance per operation but requires far fewer total operations, resulting in lower total movement distance and thereby reducing circuit runtime and amount of idle errors. Additionally, without long chains of \texttt{SWAP} gates, there is less disruption to the mappings of other qubits. % not involved in that particular \texttt{CZ} gate. 
%When we can avoid separating other frequently-interacting qubits in order to move \texttt{CZ} operands together in the current timestep, we eliminate extra movement operations to bring such qubits back together to execute \texttt{CZ} gates in later timesteps.

%Though, in this approach a single movement operation will on average require a longer distance to be traveled, significantly fewer operations will be required to bring a \texttt{CZ} gates' operands within a blockade radius. The benefit of this is two-fold. First, the total movement distance of routing operations across the entire circuit will be lower; this not only reduces circuit runtime, as the movement time cost is directly proportional to distance, but also leads to higher fidelity due to fewer idle errors. 

\subsubsection{Adjusting Atom Placements} \label{section: adjusting atom placements}

Routing with atom movement frequently requires us to switch the places of two atoms: the equivalent of a \texttt{SWAP$\left(q_a,q_b\right)$} gate is replaced with moving $q_a$ to $m\left(q_b\right)$ and $q_b$ to $m\left(q_a\right)$, which we will label as \texttt{Switch$\left(q_a,q_b\right)$}. However, if we assume an evenly-spaced grid-like positioning of atom sites, executing this operation breaks condition 1 in \ref{section: movement constraints}, and executing the two movement operations in serial does not fix the issue. To solve this problem, we take advantage of the fact that neutral atom arrays allow for any arbitrary arrangement of sites, while still maintaining the rectangular structure required by the AOD. To switch the locations of atoms, we can ``displace'' one atom in the pair from its evenly-spaced grid point by $d_{thr}$, as shown in \ref{fig:atom movement}(c).

Our goal is to find an initial atom array configuration (i.e., initial set of ``displacements'' assigned to the qubits) that allow us to execute as many \texttt{Switch} operations as possible before needing to insert extra movement operations to adjust displacements mid-circuit. We iterate through the list of \texttt{Switch} operations determined by the algorithm in \ref{section: improved movement algorithm} and decide displacements in the manner shown in \ref{fig:atom movement}(c) and \ref{fig:atom movement}(d).

For simplicity with this example, each displaced atom in Figure \ref{fig:atom movement} is shifted diagonally (up and right) from the grid point. To achieve more flexibility, if possible without breaking atom movement constraints, we may choose to displace in only one direction: if the two qubits are in the same \textit{row}, one must be displaced \textit{up}; if in the same \textit{column}, one must be displaced \textit{right}. To ensure atom sites are no closer than $s-d_{thr}$, we do not allow displacement \textit{down} or to the \textit{left}, and we choose spacing $s$ such that $s-d_{thr}$ is no smaller than the distance at which crosstalk begins to occur. Additionally, we may adjust movement distance of the \texttt{Switch} operation instead of adjusting initial displacements. E.g., in Figure \ref{fig:atom movement}(c), $q7$ could be moved a \textit{shorter} distance so that it is vertically aligned with the grid point after executing \texttt{Switch$\left(q7,q8\right)$}, allowing us to execute \texttt{Switch$\left(q7,q8\right)$} without the changes described in \ref{fig:atom movement}(d). If achieving this effect requires moving \textit{farther}, it usually is better to adjust initial displacements.

%\subsection{Hybrid: Combining SWAPs \& Movement}
%In theory, there is nothing preventing us from combining \texttt{SWAP} gates and movement operations in the same routing algorithm. However, we choose not to do this for two main reasons. First, as discussed in \ref{section: results routing fidelity}, the fidelity cost of a \texttt{SWAP} gate is currently significantly worse than that of a movement operation. Second, as discussed in \ref{section: results routing circuit duration}, the duration of a \texttt{SWAP} gate (when decomposed to the \texttt{NeutralAtomGateSet}) is longer than, or at best approximately equal to, that of a movement operation on most current hardware. There may be situations where parallelism could be better optimized via a hybrid approach, since movement operations and \texttt{SWAP} gates have different parallelism constraints (see Section \ref{section: calculating circuit duration}), though it is not obvious that this would provide significant improvements. We leave more in-depth explorations of this for future work, acknowledging that hybrid approaches may be more relevant once neutral atom two-qubit gate fidelities improve. %One area where a hybrid approach may be useful is if there are hardware-level limitations on, e.g., the number of sites that can be addressed by the AOD lasers that are used to move the atoms. We leave this exploration for future work.}

\section{Metrics}\label{section: metrics}

\subsection{Calculating Circuit Duration} \label{section: calculating circuit duration}

For a given neutral atom hardware model, we define the following values, given in Section \ref{section: evaluation methods}: \texttt{CZ} gate duration, \texttt{Rz$\left(\pi\right)$} gate duration, \texttt{GR$\left(\pi,\phi\right)$} duration, and atom movement speed. For each single-qubit gate, duration is scaled by rotation amount; i.e., $t_{\gamma}=t_{\pi} \cdot \gamma/\pi$, where $t_{\gamma}$ and $t_{\pi}$ are the times required for rotations by angles $\gamma$ and $\pi$, respectively. The duration of each atom movement operation is equal to the distance traveled divided by the movement speed.

Once the circuit has been routed and decomposed into the \texttt{NeutralAtomGateSet}, the circuit structure is naturally split into a) columns of parallel \texttt{Rz} gates, b) \texttt{GR} gates that are each applied to all qubits, and c) groups of \texttt{CZ} gates. Within each group of \texttt{CZ} gates and movement operations, we must determine which of these can execute in parallel, according to constraints specified in \ref{section: two-qubit gate constraints} and \ref{section: movement constraints}.

The duration of each moment, where a moment is a group of gates executed in parallel, is equal to the duration of the longest gate within that moment. The total circuit duration is calculated by summing over the durations of all moments. 

Note that dead time between pulses -- an experimental limitation on how quickly control devices can be switched -- is about 15ns \cite{graham_multi-qubit_2022}, approximately two orders of magnitude shorter than most neutral atom gate durations. Therefore, effects on circuit duration and idle errors from dead time are negligible and do not need to be considered. Also note that, in this case, there is not significant benefit from more sophisticated scheduling techniques than the layer-by-layer approach (such as those in \cite{li_timing-aware_2023}). This is because of the large number of \texttt{GR} gates in circuits decomposed to the \texttt{NeutralAtomGateSet}; even if a gate finishes earlier than other gates in the same moment, we still must wait until all gates in the moment have completed before executing the \texttt{GR} gate, since it is applied to all qubits in the circuit.

\subsection{Noise Simulation} \label{section: noise simulation}

To evaluate fidelity of the quantum circuits produced by our compiler, we use the trajectory method with a Pauli noise model \cite{brun_simple_2002} adapted to neutral atom hardware-level details. % We follow the algorithm provided in \cite{gokhale_asymptotic_2019} with a few minor adjustments to better account for specifics of neutral atom hardware. 

% Figure environment removed


% Figure environment removed


We model two types of errors:

\begin{enumerate}

\item \textbf{\underline{Gate errors}} occur from imperfections in the laser or microwave pulses used to implement gates (e.g., variations in Rabi frequency) or from atomic decay processes due to the finite lifetime of the Rydberg state or off-resonant scattering from the intermediate state. We make the common approximation that possible single-qubit gate errors are sampled from \{\textit{no error} (identity matrix), \textit{bit flip error} ($\sigma_x$), \textit{phase flip error} ($\sigma_z$), \textit{bit and phase flip error} ($\sigma_y$)\} and two-qubit gate errors from $\mathcal{P}^{\otimes 2}$, randomly drawing an error for each gate in the circuit. The probabilities of drawing an error on a single-qubit and two-qubit gate are given, respectively, by $p_{1k}$ and $p_{2k}$ for $k\in\{X,Y,Z\}$, and probabilities of drawing no error are $1-\sum{p_{1k}}$ and $1-\sum{p_{2k}}$, where $p_{1x}=p_{1y}=0.1\%$, $p_{1z}=0.4\%$, $p_{2x}=p_{2y}=0.2\%$ and $p_{2z}=0.5\%$ \cite{bluvstein2022quantum}. 

\item \textbf{\underline{Idle errors}} occur from unwanted interactions with the environment causing qubit states to decohere. \textit{Amplitude damping}, related to the device's $\mathrm{T_1}$ time, describes relaxation from a higher to lower energy level. \textit{Dephasing} describes loss of relevant phase information (i.e., undesired rotations about the Bloch sphere's z-axis) and is related to the $\mathrm{T_2}$ and $\mathrm{T_2^*}$ times. Because the effects of dephasing in neutral atoms significantly dominate those of amplitude damping \cite{morgado_quantum_2021}, at each moment we apply $(1 - \exp{(t / \mathrm{T_2^*}))}\sigma_z$ where $t$ is the duration of the moment, determined by the longest gate in the moment. 
% we consider the following idle error noise channels: \textit{no error} (identity matrix) and \textit{dephasing error} (Pauli-Z matrix).
\end{enumerate}

Experimental work \cite{bluvstein2022quantum} clearly demonstrates that, at the movement speed which we assume, movement operations incur no decrease in fidelity nor loss of atoms. Thus, each atom movement operation in the circuit is subjected to an idle error but not a gate error. When not being moved, atoms can survive on the order of $\sim$10 seconds before being lost; for the circuit sizes we study in this work, the rate at which we lose atoms is negligible, particularly compared to the rate at which we lose quantum information due to decoherence. Other sources of error -- e.g., thermal motion of atoms, imperfect laser polarization, off-resonant scattering from the intermediate state in the two-photon Rydberg excitation -- are accounted for in our gate error probabilities and do not need to be modeled separately.



% Figure environment removed

\section{Evaluation Methods}\label{section: evaluation methods}

We evaluate our compiler methods on six different benchmarks, which are chosen to be reflective of relevant quantum computing programs. These include subroutines (multi-controlled X gate decomposition \texttt{CNX} and Greenberger-Horne-Zeilinger State Generator \texttt{GHZ}), arithmetic circuits (Cuccaro Adder \texttt{Cuccaro} and Quantum Fourier Transform \texttt{QFT}), and promising applications (Quantum Variational Optimization Algorithms \texttt{VQAOA} and Hamiltonian Simulation \texttt{HamSim}). We use scalable implementations found in \cite{tomesh_supermarq_2022, qcb}

%\begin{itemize}
    %\item \textbf{\textit{Quantum Approximate Optimization Algorithm}} (\texttt{VQAOA}): QAOA is a hybrid quantum-classical variational algorithm that approximates solutions to hard combinatorial problems. We use the "Vanilla QAOA" circuits from the SupermarQ benchmark suite \cite{tomesh_supermarq_2022}, which implement a single iteration of QAOA for MaxCut on complete graphs. 
    
    
    %\item \textbf{\textit{Greenberger-Horne-Zeilinger State Generator}} (\texttt{GHZ}): These circuits consist of a \texttt{Hadamard} gate followed by several \texttt{CNOT} gates, which produce the state $\left(\ket{0}^{\otimes n} + \ket{1}^{\otimes n}\right)/\sqrt{2}$, where $n$ is number of qubits \cite{tomesh_supermarq_2022}. 
    
    
    %\item \textbf{\textit{Hamiltonian Simulation Circuit}} (\texttt{HamSim}): This benchmark provides circuits, generated via Trotterization, that simulate the time-evolution of a one-dimensional transverse-field Ising system \cite{tomesh_supermarq_2022}. 
  
    %\item \textbf{\textit{Cuccaro Adder Circuit}} (\texttt{Cuccaro}): The Cuccaro adder circuit is an example of an arithmetic quantum circuit, consisting mostly of \texttt{Rx}, \texttt{CNOT}, and \texttt{Toffoli} gates. We use the implementation provided in \textcolor{red}{[cite qcb]}.
    
    %\item \textbf{\textit{Quantum Fourier Transform}} (\texttt{QFT}): The quantum Fourier transform is the quantum version of the discrete Fourier transform. The circuits contain primarily \texttt{Hadamard} gates and \texttt{C-Phase} gates \textcolor{red}{[cite qcb]}.
    
    %\item \textbf{\textit{Multi-Controlled-X Gate Decomposition}} (\texttt{CNX}): The multi-controlled {X} gate, or \texttt{CNX}, is a generalization of the \texttt{Toffoli} gate to any number of control qubits. The circuits in this benchmark give log-depth (in terms of number of qubits) decompositions of an $n$-qubit \texttt{CNX} into single-qubit and two-qubit gates \textcolor{red}{[cite qcb]}.
%\end{itemize}

Additionally, we evaluate our approaches on two different hardware models, representing different possible technical specifications for a real atomic system. In the first hardware model (\texttt{A1}), the duration of an \texttt{Rz} gate is equal to the duration of a \texttt{GR} gate of the same rotation amount, both of which are shorter than the duration of a two-qubit gate: durations of \texttt{Rz$\left(\pi\right)$}, \texttt{GR$\left(\pi,\phi\right)$}, and \texttt{CZ} gates are $0.25\mu$s, $0.25\mu$s, $2.5\mu$s, respectively \cite{bluvstein2022quantum}. In the second hardware model (\texttt{A2}), global gates dominate gate execution times, compared to both two-qubit and local \texttt{Rz gates}: durations of \texttt{Rz$\left(\pi\right)$}, \texttt{GR$\left(\pi,\phi\right)$}, and \texttt{CZ} gates are $0.2\mu$s, $5\mu$s, $0.75\mu$s, respectively \cite{graham_multi-qubit_2022}. The first is representative of laser control for both local and global gates, while the second is representative of laser control for local gates combined with microwave control for global gates. We do not need to consider the case in which \texttt{Rz} gate durations are dominant, as this is unlikely to occur in hardware.

We run our compiler algorithms with all possible benchmark and hardware combinations and, to demonstrate scalability of our compiler, vary the number of qubits in the circuit from $n=10$ to $n=70$. To convert to the \texttt{StandardGateSet}, we use Qiskit's \texttt{transpile} function with basis gates \{\texttt{U3}, \texttt{CZ}\} \cite{anis_qiskit_2021}. To find an initial mapping, we use t$\ket{\mathrm{ket}}$'s \texttt{LinePlacement} method \cite{cowtan_qubit_2019}.

%As noted previously, methods from prior work suffice to convert an input circuit into the \texttt{StandardGateSet} and to find an initial mapping. The former is achieved using Qiskit's \texttt{transpile} function with basis gates \{\texttt{U3}, \texttt{CZ}\} \cite{anis_qiskit_2021}. For the latter, we use t$\ket{\mathrm{ket}}$'s \texttt{LinePlacement} method \cite{cowtan_qubit_2019}. 


After applying our compiler pipeline steps, we compute the fidelity and total duration of the final circuit as described in Section \ref{section: metrics}. When simulating noise, we decrease all error probabilities by a factor of 10x from the values given in \ref{section: noise simulation}, allowing us to better distinguish fidelity results between the different compiler methods. Since gate error rates and coherence lifetimes will improve as the hardware develops, this is equivalent to simulating noise for quantum computers several years in the future. We assume a $\mathrm{T_2^*}$ time of $4$ms \cite{bluvstein2022quantum}.

Unless otherwise stated--e.g., when evaluating the impact of varying such parameters--we assume a 7$\mu$m blockade radius, 5$\mu$m spacing between atom sites, $d_{thr}$ of 1$\mu$m, and 0.55$\mu$m/$\mu$s movement speed \cite{bluvstein2022quantum,scholl_quantum_2021,graham_multi-qubit_2022}. In section \ref{section: results effect of hardware-level parameters}, we study the effect of different blockade radii and spacing. %\textcolor{cyan}{These values give nearest-neighbor connectivity, which is still used in experimental work \cite{bluvstein2022quantum,scholl_quantum_2021,graham_multi-qubit_2022}; though beyond nearest-neighbor connectivity is possible, this can cause weaker Rydberg interaction strength \cite{saffman_rydberg_2011}. In section \ref{section: results effect of hardware-level parameters}, we study the effect of different blockade radii and spacing, including beyond nearest-neighbor connectivity}.

\section{Results \& Discussion}

% Figure environment removed

% Figure environment removed

\subsection{Decompositions to Native Gate Set}\label{section: results decompositions}

Because our work is the first to address decomposing into the \texttt{NeutralAtomGateSet}, there does not exist a reasonable baseline from prior work to which to compare our methods. Here, we compare the optimized decomposition method (\texttt{transverse}) to the unoptimized version (\texttt{axial}). 

\subsubsection{Circuit Duration}\label{section: results decompositions circuit duration}

Compared to the \texttt{axial} decomposition method, the \texttt{transverse} decomposition method achieves up to 3.5x reduction in total global gate pulse durations and up to 2.9x reduction in time spent executing single-qubit gates (\texttt{GR} and \texttt{Rz}). As shown in \ref{fig:all_benchmarks_decomposition}, this is especially important on \texttt{H1}, where \texttt{GR} durations dominate gate execution time costs. 

For some of the circuits--namely \texttt{QFT}, \texttt{Cuccaro}, and \texttt{CNX}--the \texttt{Rz} cost is lower with \texttt{axial} decompositions. This is because, when the Euler-angle decomposition in equation \eqref{eqn:euler-angle} is applied to a single-qubit gate with rotation angle of $\pi/2$ or $\pi$ (which occurs frequently in \texttt{QFT}, \texttt{Cuccaro}, and \texttt{CNX}), at least one of the resulting $\theta$, $\phi$, or $\lambda$ values is zero. These $\theta$, $\phi$, and $\lambda$ become the rotation amounts of the \texttt{Rz} gates in the \texttt{axial} decomposition, and a \texttt{Rz} with rotation angle of zero is equivalent to no gate. In comparison, when equations \eqref{eqn: transverse_beginning}-\eqref{eqn: transverse_decomposition_last} are applied for the \texttt{transverse} decomposition, the \texttt{Rz} gate rotation angles are typically all nonzero. 

However, this difference in \texttt{Rz} costs is small compared to the improvement in \texttt{GR} costs with \texttt{transverse} decompositions, and \texttt{transverse} therefore has better overall circuit duration for all benchmarks and hardware combinations. 

Since these decompositions act only on moments containing single-qubit gates, the two-qubit gate costs are identical for both decomposition strategies.


\subsubsection{Fidelity}\label{section: results decompositions circuit duration}

As shown in Figure \ref{fig:fidelity_decomposition}, there is no noticeable difference in circuit fidelity between the \texttt{axial} and \texttt{transverse} decomposition strategies. While differences in circuit duration between the two decomposition strategies lead to slightly different idle error amounts, this difference is negligible.


\subsection{Routing via Atom Movement}\label{section: results routing}

% Figure environment removed

The largest amount of improvement in our compiler is achieved with the routing step. We compare our strategy using atom movement, described in \ref{section: improved movement algorithm}, to 1) the baseline algorithm \cite{cowtan_qubit_2019} using decomposed \texttt{SWAP} gates, discussed in \ref{section: improved movement algorithm} and 2) the OLSQ-RAA compiler \cite{tan_qubit_2022}. 

\subsubsection{SWAP-Based Comparison: Circuit Duration}\label{section: results routing circuit duration}

%\textcolor{purple}{[todo: update this section with numbers from the improved (transverse) SWAP decomposition]}

The improvements from routing with atom movement come from the fact that a single \texttt{SWAP} gate must be decomposed into 21 gates from the \texttt{NeutralAtomGateSet}, as shown in Figure \ref{fig:swap_decomposition}, to be executed on neutral atom hardware. This requires 10.5$\mu$s and 24$\mu$s per \texttt{SWAP} on hardware \texttt{A1} and \texttt{A2}, respectively. In comparison, a single \texttt{SWAP} implemented via movement operations requires 9$\mu$s, assuming atom spacing of 5$\mu$m. Thus, in almost all cases, and due to factors discussed in \ref{section: improved movement algorithm}, routing via atom movement will result in speedup. It is possible for the total circuit duration using movement routing to exceed the baseline, due to the added movement operations described in \ref{section: adjusting atom placements} or differences in parallelism opportunities between \texttt{SWAP} gates and movement operations. However, we only observe this with \texttt{Cuccaro} on \texttt{A1}. For \texttt{A2}, every benchmark achieved significant speedup when atom movement is used for routing.

\subsubsection{SWAP-Based Comparison: Fidelity}\label{section: results routing fidelity}

All benchmarks, on both models, saw immense improvement in fidelity, as shown in Figure \ref{fig:fidelity_routing}. This is because each of the 21 gates in the \texttt{SWAP} decomposition can potentially cause gate errors, which are the main source of error on neutral atom devices. In the majority of cases, routing with atom movement will also lead to fewer idle errors due to shorter circuit durations. In the single case where circuit duration is longer when using atom movement (\texttt{Cuccaro} on \texttt{A2}), the slightly higher idle errors relative to the baseline is negligible compared to the lower amount of gate errors (Figure \ref{fig:fidelity_routing}). 

%\textcolor{cyan}{Previous experimental work on \cite{bluvstein2022quantum} demonstrates that dynamical decoupling during atom movement operations can increase coherence time to $\mathrm{T_2}=1.5s$, rather than the $\mathrm{T_2^*}=4$ms we assume in our noise simulations, further decreasing idle errors. Thus, fidelity for movement-based routing may be even better than the results we present here.}

\subsubsection{OLSQ-RAA Comparison: Circuit Duration}
Compared to the \texttt{OLSQ-RAA} compiler \cite{tan_qubit_2022}, we achieve 10x average speedup across all benchmarks for the circuit sizes shown in Figure \ref{fig:olsqraa_comparison}. This improvement stems primarily from the large space requirements for \texttt{OLSQ-RAA}, meaning that atoms must be moved much farther distances, thus taking more time. \texttt{OLSQ-RAA} focuses primarily on minimizing costs due to two-qubit gates, without fully accounting for or optimizing atom movement overheads. Also, \texttt{OLSQ-RAA}'s approach relies on transferring atoms between AOD and SLM traps mid-circuit. Each transfer can take 20-50$\mu$s or longer \cite{beugnon_two-dimensional_2007, bluvstein2022quantum}, and this cost can add up. Our approach assumes all atoms remain in AOD traps throughout circuit execution, eliminating the need for transfer times.

As shown by the blue bars in Figure \ref{fig:olsqraa_comparison}, \texttt{OLSQ-RAA} achieves lower two-qubit gate time costs. This is due to differences in parallelism, as both approaches require the same number of two-qubit gates; neither approach adds gates from the unrouted circuit since routing is achieved via atom movement. Achieving this extra parallelism while respecting constraints (see Section \ref{section: two-qubit gate constraints}), however, requires higher atom movement cost; if qubits of different \texttt{CZ} gates have overlapping blockade radii, we find it is better to serialize the \texttt{CZ} gates than to incur the cost of moving qubits apart.

\subsubsection{OLSQ-RAA Comparison: Fidelity}
We expect gate errors to be the same, as both approaches have the same number of gates (as mentioned above).  We expect idle errors to be slightly worse for \texttt{OLSQ-RAA} due to longer circuit durations. We note that \texttt{OLSQ-RAA} may have slightly better fidelity because it prevents crossings of AOD rows and columns, which can cause some additional heating, though it is unclear how much of an effect this will have. For more details on heating during atom movement, we refer the reader to \cite{bluvstein2022quantum}.


\subsection{Scalability}\label{section: results scaling}

\subsubsection{Results for Increased Circuit Sizes}\label{section: results scaling increased circuit sizes}

Figure \ref{fig:scaling} shows the effects of scaling up the size of circuits. As the number of qubits in the circuit grows, the qualitative results--which compiler strategies are better in which contexts--remain unchanged. With bigger circuits, particularly as circuit duration approaches device coherence time, it becomes increasingly more important to optimize the compiler steps in the ways discussed in this paper. 

\subsubsection{Compilation Overhead \& Complexity Analysis}\label{section: results scaling complexity analysis}

The decomposition steps presented in \ref{section: axial decomposition} and \ref{section: transverse decomposition} are linear in the number of gates in the circuit, and the additional post-processing steps and optimizations discussed in \ref{section: post-processing} do not further increase complexity. The routing algorithms provided in \ref{section: atom movement routing} have the same complexity as the baseline SWAP-based approach from \cite{cowtan_qubit_2019,sivarajah_tket_2020}; incorporating movement into routing does not worsen compilation overhead. If necessary, other SWAP-based routing approaches with lower complexity than \cite{cowtan_qubit_2019,sivarajah_tket_2020} can easily be adapted to incorporate atom movement by following the same approach presented in our work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
%\subsubsection{Scheduling}

%We compare our scheduling algorithm to Cirq's \texttt{stratified\_circuit} method with two-qubit operations specified for the \texttt{categories} parameter. As intended, our \texttt{Sifting} algorithm significantly reduces the amount of time spent executing single-qubit rotations. However, we also observe an unintended and unexpected consequence: optimizing parallelism among single-qubit gates can result in less two-qubit gate parallelism. On hardware \texttt{A1}, where two-qubit gates have the longest duration, this can cause the \texttt{Sifting} algorithm to perform worse than the baseline. It may be possible to regain some of the lost two-qubit parallelism through additional compiler passes, and we plan to explore this further in future work. 
\subsection{Effect of Hardware-Level Parameters}\label{section: results effect of hardware-level parameters}

% Figure environment removed

\subsubsection{Effect of Blockade Radius} \label{section:effect_of_blockade_radius}

Shown in Figure \ref{fig:varying_blockade_radius}, we study the effect of increasing blockade radius within the range of $r_b=5\mu$m to $r_b=15\mu$m, which is currently supported by neutral atom hardware \cite{lukin_mis}. With greater $r_b$, and thus higher connectivity, fewer \texttt{SWAP} gates (or the equivalent movement operations) are needed to make the circuit's \texttt{CZ} gates executable, leading to improved results for both routing approaches. With both, there is also a decrease in two-qubit gate parallelism with increasing $r_b$, as this makes it more likely that operands of different \texttt{CZ} gates will have overlapping blockade radii. However, for the majority of circuits, the decrease in \texttt{SWAP} gates or movement operations far outweighs any loss in two-qubit parallelism. 

In Figure \ref{fig:varying_blockade_radius}, we also observe that, as $r_b$ increases, the cost of routing with the \texttt{SWAP} gate decomposition approaches the cost of routing with movement. This results from a greater number of edges in the connectivity graph (determining \texttt{SWAP} insertion) without impacting the number of edges in the movement paths graph (determining \texttt{Switch} insertion). Stated less abstractly, larger $r_b$ grants more flexibility with routing decisions when using \texttt{SWAP} gates, which was already present with movement routing at lower $r_b$. 

This indicates that movement allows us to achieve some of the benefits of a larger blockade radius, while in reality keeping the blockade radius relatively small. One huge advantage of this is that we can avoid the greater two-qubit gate error rates that occur when accessing higher Rydberg energy levels necessary to implement a larger blockade radius \cite{evered2023highfidelity}. 

\subsubsection{Effect of Atom Spacing} \label{section:effect_of_atom_spacing}

Figure \ref{fig:varying_atom_spacing} shows the impact of varying spacing $s$ between atom array sites. As with blockade radius, we choose a range based on recent hardware research: $s=3\mu$m to $s=11\mu$m. To isolate the effect of spacing from the effect of connectivity, we set $r_b=s+1\mu$m (note we need $r_b>s$, otherwise there would exist no pairs of qubits on which a \texttt{CZ} gate could be executed). As expected, since movement time is proportional to distance, the cost of routing with movement increases with larger spacing. With most of the circuits, routing with movement still performed better than the baseline (in terms of both circuit duration and fidelity) even at the largest $s$ tested. 

Though spacing does not effect gate durations--thus leaving the time overhead unchanged when routing with the \texttt{SWAP} gate decomposition--larger spacing will require a greater blockade radius to execute the \texttt{CZ} gates. As mentioned in \ref{section:effect_of_blockade_radius}, this will lead to higher two-qubit gate error rates.  

\subsubsection{Adapting to Hardware Specifications}

The exact amount of speedup we achieve with movement will depend on the chosen $r_b$ and $s$, which may depend on the hardware device. With $s$, we want the smallest value that does not lead to non-negligible increases in crosstalk. With $r_b$, we want the largest value -- leading to highest connectivity -- that does not significantly decrease two-qubit gate fidelity.


\section{Conclusion}

We present a compiler that converts a circuit into a realistic neutral atom gate set, in which \texttt{Rx} and \texttt{Ry} rotations can only be implemented globally. This step is essential to be able to execute circuits on current hardware. To overcome expensive single-qubit decompositions involving global gates, we specifically optimize rotation amount of \texttt{GR} and \texttt{Rz} gates. As an alternative to expensive \texttt{SWAP} decompositions, we propose routing strategies involving atom movement operations. Together, these approaches achieve significant improvement in circuit duration and fidelity. We demonstrate that our compiler passes are effective for a wide variety of hardware specifications and hardware-level parameter values, which is of great importance as neutral atom hardware technologies continue to develop and evolve.

\section*{ACKNOWLEDGMENTS}
This work is funded in part by EPiQC, an NSF Expedition in Computing, under award CCF-1730449; in part by STAQ under award NSF Phy-1818914; in part by the US Department of Energy Office of Advanced Scientific Computing Research, Accelerated Research for Quantum Computing Program; and in part by the 
NSF Quantum Leap Challenge Institute for Hybrid Quantum Architectures and 
Networks (NSF Award 2016136) and in part based upon work supported by the 
U.S. Department of Energy, Office of Science, National Quantum 
Information Science Research Centers.  

FTC is Chief Scientist for Quantum Software at Infleqtion and an advisor to Quantum Circuits, Inc.



%%%%%%% -- PAPER CONTENT ENDS -- %%%%%%%%


%%%%%%%%% -- BIB STYLE AND FILE -- %%%%%%%%
\bibliographystyle{IEEEtranS}
\bibliography{refs}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
