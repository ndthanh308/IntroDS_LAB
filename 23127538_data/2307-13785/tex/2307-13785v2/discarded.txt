\subsection{1D shock tube} 

\begin{figure}
\centering
\fig{Sod.png}{0.45\textwidth}{}
\caption{1D Cartesian Sod shock tube test results at t=0.25 using a fixed mesh. The numerical results obtained by using 256 zones are compared to the analytical solution, shown in red.
\label{fig:Sod}}
\end{figure}

\begin{figure}
\centering
\fig{Sod_MMesh.png}{0.45\textwidth}{}
\caption{Density plotted against distance from the shock scaled with time for the 1D shock tube test. The moving mesh results (dashed lines) at different instants of time are compared to the fixed mesh result (plus symbols) at $t=100$, as well as the analytical solution (solid line). The moving mesh captures the shocks more accurately compared to the fixed mesh, as well preserves self-similarity after a timespan of two orders of magnitude. In both cases, 256 computational zones are used.
\label{fig:Sod_MMesh}}
\end{figure}


The 1D Sod shock tube test is a simple test used to test shock-capturing capability of numerical schemes. The domain is defined on $x \in [0,1]$, with a resolution of 256 zones. The following initial conditions are used, along with an adiabatic index $\gamma=1.4$:

\begin{equation}
   \begin{split}
       \rho &= 1.0,\,P = 1.0;\;\;x\leqslant0.5, \\
       \rho &= 0.125,\,P = 0.1;\;\;x>0.5, \\
       v &= 0. \\
   \end{split}
\end{equation}

The calculation is performed till the time $t=0.25$. Fig \ref{fig:Sod} shows the density, pressure and velocity at this point, compared to the analytical solution.



We repeat the Sod shock tube with a moving mesh to demonstrate \sprout 's ability to capture shocks on an expanding mesh over several orders of magnitude in time. The initial conditions are scale-free, meaning the solution should be self-similar. The shocks originate from the initial point of discontinuity, that is, $x=0.5$, and move in either direction. We start with a small mesh of length unity and 256 computational zones and let it expand about the center of expansion $x_0 = 0.5$. Calculations are performed till $t=100$. We compare our result to the analytical solution and a fixed mesh calculation that is also run till $t=100$ with 256 zones. The comparison is shown in Fig \ref{fig:Sod_MMesh}, which plots density vs $(x-x_0)/t$. The moving mesh solution is found to be more accurate than the fixed mesh solution at the same time instant.

To capture this, we use $x_0 = 0.5$ and $H(t)=1/(t+1)$, where $x_0$ and $H(t)$ are as defined in Section \ref{sec:mesh}. The self-similarity of the solutions is shown by Fig \ref{fig:Sod_MMesh}, where we plot density vs $(x-x_0)\times t$ for several time instances.






\subsection{2D cylindrical shock tube}

\begin{figure}
\centering
\fig{Sod_2D.png}{0.45\textwidth}{}
\caption{Angle-averaged values of hydro variables for the 2D cylindrical shock tube test, at t=0.25. The angle averaged data from $(256)^2$ resolution is compared to the high-resolution 1D solutions obtained by the DISCO code, shown in red. We find qualitative agreement for the shock structure.
\label{fig:Sod2D}}
\end{figure}


A 2D cylindrical version of the Sod shock tube test is performed to check \sprout's capability to resolve shocks in directions not aligned to the grid. The initial conditions are:

\begin{equation}
   \begin{split}
       \rho &= 1.0,\,P = 1.0;\;\;r\leqslant0.5, \\
       \rho &= 0.125,\,P = 0.1;\;\;r>0.5, \\
       v &= 0, \\
   \end{split}
\end{equation}

where $r = \sqrt{x^2+y^2}$. The test is performed till $t=0.25$ in a domain $(x,y)\in[0,1]\times[0,1]$ with a $256\times256$ resolution. We then compute the polar angle averaged density, pressure and radial velocity as a function of the cylindrical radius (distance from $x=0$, $y=0$) and compare it with a high-resolution 1D cylindrical solution obtained by the DISCO code, as shown in Figure \ref{fig:Sod2D}.





\subsection{Kelvin-Helmholtz Instability}



Fluid instabilities provide an effective way to test the artificial diffusion arising in numerical schemes. The first one we study is the Kelvin-Helmholtz instability, which occurs when fluid layers of different densities exert a shear force on each other. We set up a static domain $[0,1]\times[0,1]$ with periodic boundaries. Pressure is constant throughout. Shear flow is introduced by setting up flows in opposite directions in the middle half of the domain ($0.25<y<0.75$) and the rest of the domain:

\begin{equation}
    P=2.5,
\end{equation}

\begin{equation}
    \rho=
\begin{cases}
  2, & 0.25<y<0.75 \\
  1, & \text{otherwise}
\end{cases}
\end{equation}

\begin{equation}
    v_x=
\begin{cases}
  0.5, & 0.25<y<0.75 \\
  -0.5, & \text{otherwise.}
\end{cases}
\end{equation}

It is also necessary to add a small perturbation to the y-velocity so as to excite a perturbation mode:

\begin{equation}
    v_y = w_0 \text{sin}(4\pi x)f(y),
\end{equation}

where

\begin{equation}
    f(y) = \text{exp}\left[ -\frac{(y-0.25)^2}{2\sigma^2} \right] + \text{exp}\left[ -\frac{(y-0.75)^2}{2\sigma^2} \right]
\end{equation}

We choose $w_0 = 0.1$ and $\sigma = 0.05/\sqrt{2}$, similar to \cite{Springel2010MNRAS}. A visual comparison of their Kelvin-Helmholtz Instability test results using a fixed mesh with Figure \ref{fig:KHI} indicates qualitative agreement between the two.


\subsection{Scaling}


%\begin{figure}\centering\fig{scaling.png}{0.45\textwidth}{} \caption{Performance scaling of \sprout\, when run on many processors, based on the 3D isentropic pulse test. \label{fig:scaling}} \end{figure}


%Finally, we test \sprout's\, performance when scaled to a large number of processors. The moving mesh version of the 3D isentropic pulse test (Section \ref{sec:3dpulse}) is performed on various number of processors, with a fixed resolution (``strong scaling") as well as a fixed number of zones per process (``weak scaling"). The results are shown in Figure \ref{fig:scaling}. \textbf{Comment on peak and typical performance, scalings, and latency.} The calculations were performed on the Petunia cluster at Purdue University, which houses 28 nodes, with 128 X.Y Ghz Intel XXXX processors per node.

%weak scaling runs:
%32^3 per core on 1,8,27,64,125,216,512,1331,14^3=2744 cores
%DONE: 