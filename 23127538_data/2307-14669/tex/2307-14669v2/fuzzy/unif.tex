\section{Fuzzy \osf term unification}%
\label{sec:unification}

Unification is an essential operation in automated reasoning. In crisp \osf
logic, the unification of two \osf terms allows to find their GLB in the
\osf term subsumption lattice. This operation is at the core of the
application of \osf logic and its variants in computational linguistics
\cite{Carpenter1992} and, more recently, it has enabled the implementation
of the very efficient CEDAR Semantic Web reasoner
\cite{AitKaciAmir2017,AmirAitKaci2017}.
In this section we prove that computing the GLB of two \osf terms in the
fuzzy subsumption lattice is no more difficult than computing
it in the crisp setting, as the same unification procedure can be employed,
and we also provide the complexity of computing the subsumption degree of
one term with respect to another.

\begin{definition}[Fuzzy \osf term unification]
\label{def:fuzzy_osf_term_unification}
  The \textit{unifier} of two normal \osf terms $\psi_1$ and $\psi_2$ is
  their GLB in the \osf term fuzzy subsumption lattice (modulo \osf term
  equivalence) and is denoted $\psi_1\fmeet\psi_2$.
  The \textit{unification degree} of $\psi_1$ and $\psi_2$ is defined as
  $\min(\fisop(\psi_1\fmeet\psi_2, \psi_1), \fisop(\psi_1\fmeet\psi_2,
  \psi_2))$.
  We write $\psi = \psi_1\fmeet_\beta\psi_2$ if $\psi$ is the
  unifier of $\psi_1$ and $\psi_2$ with unification degree $\beta$.
\end{definition}

Recall that applying the \osf constraint normalization rules
to an \osf clause results in a normal form $\phi$ that is either
the inconsistent clause $\X:\bots$, or an \osf clause in solved form
together with a conjunction of equality constraints
(\cref{prop:osf_clause_normalization}). The subclause of
$\phi$ in solved form is denoted $\solved(\phi)$.
The following theorem is an immediate consequence of the analogous result
for crisp \osf logic \cite{AitKaci1993b}, \cref{prop:glbs,thm:crispfuzzy}.

\begin{theorem}[Fuzzy \osf term unification]
\label{thm:fuzzy_osf_term_unification}
  Let $\psi_1$ and $\psi_2$ be \osf terms with no common variables, and let
  $\phi$ be the \osf clause obtained by non-deterministically applying any
  applicable \textit{constraint normalization rule}
  (\Cref{fig:osf_normalization}) to the clause $\phi(\psi_1) \osfwith
  \phi(\psi_2) \osfwith \rtag(\psi_1) \doteq \rtag(\psi_2)$
  until none applies. Then, $\phi$ is the inconsistent clause iff the GLB
  of $\psi_1$ and $\psi_2$ is $\X:\bots$. If $\phi$ is not the
  inconsistent clause, then $\psi_1\fmeet \psi_2 = \psi(\solved(\phi))$.
\end{theorem}

\input{figures/algo}

  \cref{alg:unif} shows a procedure to unify two normal \osf terms and to
compute their unification degree\footnote{%
    The following notation is adopted in \cref{alg:unif}.
    The reflexive and transitive closure of a binary relation $R$ is
    denoted $R^*$.
    The expression
    $\quot[\osfeq][\tags(\phi)]$
    denotes the quotient of the set $\osftags(\phi)$ modulo the equivalence
    relation $\osfeq\subseteq\tags(\phi)^2$. For a variable $\X\in \tags(\phi)$, its equivalence
    class with respect to the relation
    $\osfeq$ is $[\X] \defeq \{ \Y \mid (\X, \Y)\in\osfeq \}$.}.
  Given two normal \osf terms $\psi_1$ and $\psi_2$, the algorithm proceeds
as follows.
\begin{itemize}
  \item
    \cref{line:2,line:3,line:4} involve the application of the
    constraint normalization rules of \cref{fig:osf_normalization} to the
    clause $\phi(\psi_1) \osfwith \phi(\psi_2) \osfwith \rtag(\psi_1)
    \doteq \rtag(\psi_2)$, resulting in an \osf clause $\phi$ in normal
  form.
  \item
    If this normal form is (equivalent to) the inconsistent clause,
  then $\X:\bots$ is returned with unification degree $1$\footnotemark{}
    on \cref{line:6}. Otherwise, the algorithm proceeds with the
    computation of the unification degree.
    \footnotetext{%
        Recall that by \cref{def:fuzzy_lattice} $\bots$ is subsumed by
    every sort with degree $1$.}
  \item
    In \cref{line:8,line:9,line:10,line:11,line:12}
    the set $\tags(\phi)$ is partitioned into equivalence classes
    according to the equality constraints contained in $\phi$, and each
    variable $\X$ in $\phi' = \solved(\phi)$ is uniformly renamed with a new variable
    $\Z_{[\X]} \in \V\setminus \tags(\phi)$ corresponding to its
    equivalence class. This step allows each term to maintain its own
    variable scope, and facilitates the computation of the unification
    degree in the next lines.
  \item
    Finally,
    the GLB $\psi = \psi_1\fmeet\psi_2$ is obtained on \cref{line:13}
    as the \osf term corresponding to $\phi'$,
    while \cref{line:14,line:14,line:15,line:16} deal with the
    computation of the unification degree $\beta$ of the two \osf terms.
\end{itemize}
The output of the algorithm is a pair $(\psi, \beta)$ such that
$\psi=\psi_1\fmeet_\beta\psi_2$.
Note that the unifier of the two terms can already be obtained on
\cref{line:8} as $\psi(\solved(\phi))$, and the subsequent steps are
only concerned with the computation of the unification degree.
The same algorithm can also be employed to decide whether the two terms
subsume each other, and to what degree:
if $\psi$ is equivalent to $\psi_1$, then $\fisop(\psi_1, \psi_2) =
\beta$; alternatively, if $\psi$ is equivalent to $\psi_2$, then
$\fisop(\psi_2, \psi_1) = \beta$.

\begin{restatable}%
  [{\protect\hyperlink{proof:algo}{Correctness of \cref{alg:unif}}}]%
  {theorem}{thmalgo}
\label{thm:algo}
  Let $\psi_1$ and $\psi_2$ be normal \osf terms.
  If $(\psi, \beta)$ is the output of the procedure
  $\textsc{Unify}(\psi_1, \psi_2$) of \cref{alg:unif},
  then $\psi = \psi_1\fmeet_\beta\psi_2$.
\end{restatable}

The following example clarifies each step of \cref{alg:unif}.

\input{fuzzy/unif_ex}


Finally, let us analyze \cref{alg:unif} in terms of complexity.
Finding the unifier of the two normal \osf terms $\psi_1$ and $\psi_2$ with
respect to a fuzzy sort subsumption lattice
has the same complexity of deciding the problem in the crisp setting.
This is due to the fact that GLBs in a fuzzy lattice and its crisp
counterpart can be computed in the same way (also see \cref{prop:glbs}),
and the rules for fuzzy \osf constraint normalization and crisp \osf
constraint normalization are essentially the same.
The algorithm from \cite{AitKaci1986b} is based
on the union-find problem \cite{Aho1974} and has a worst-case complexity of
$O(mG(m))$, where $m = \card{\tags(\psi_1)\cup\tags(\psi_2)}$ and
the growth rate of the function $G$ is of the order of an inverse of the
Ackermann function ($G(m)\leq 5$ for all practical purposes)
\cite{AitKaci1986b}.

Partitioning the set $\tags(\phi)$ according to the equality constraints in
$\phi$ (\cref{line:9,line:10}) is an application of the union-find problem.
The complexity is thus $O(mG(m))$, where $G$ is as above and $m =
\card{\tags(\psi_1)\allowbreak\cup\allowbreak\tags(\psi_2)}$.

 Computing $\fisop(\s, \su)$ for two sorts $\s,\su\in\S$ can be performed
 in $O(\card{\S}+e)$ time -- where $e$ is the number of edges in the DAG
 representation of the fuzzy sort subsumption relation -- with an approach
 that is analogous to solving the shortest paths problem in a DAG
 \cite{Milanese2021a}.
 The overall complexity of the computation of the subsumption degrees
 $\beta_1$ and $\beta_2$ in \cref{line:14,line:15} is thus
 $O(m(\card{\S}+e))$, where $m = \card{\tags(\psi_1)\cup\tags(\psi_2)}$.
