\section{Introduction}%
\label{cha:introduction}

Order-Sorted Feature (\osf) logic is a Knowledge Representation and
Reasoning language that originates in Hassan \ak's work \cite{AitKaci1984}
and, similarly to Description Logics (DLs), it was initially meant as a
formalization of Ron Brachmann's structured inheritance networks
\cite{DLKRHB,AitKaci2007b}.
\osf logic and related formalisms
-- e.g., feature logic \cite{Smolka1988} or the logic of typed feature
structures \cite{Carpenter1992} --
have been applied in computational linguistics \cite{Carpenter1992} and
implemented in constraint logic programming languages such as LOGIN
\cite{AitKaci1986b}, LIFE \cite{AitKaci1993b} and CIL \cite{Mukai1987} and,
more recently, in the very efficient CEDAR Semantic Web reasoner
\cite{AitKaciAmir2017,AmirAitKaci2017}.%

At the core of \osf logic are \textit{sort symbols} denoting conceptual classes such as
$\s[person]$ or $\s[student]$, and a \textit{sort subsumption relation}
that denotes inclusion between classes, comparable to the inclusion axioms
of a DL terminological box. Concept subsumption relations are a
central part of any ontology, and \osf logic and its
implementations rely on graph encoding techniques to perform Boolean
operations on a concept lattice very efficiently
\cite{AitKaciAmir2017,AitKaci1989}.
Besides sort symbols, \osf logic employs \textit{feature symbols} to
describe attributes of objects, like $\f[name]$, $\f[directed\_by]$ or
$\f[written\_by]$.
While feature symbols denote \textit{total functions}, which %
may
appear less versatile than the relational roles of DLs, versions
of \osf logic that support partial functions or relations have also been
defined
\cite{Smolka1988,Carpenter1992,AitKaci2007b}.

Together with \textit{variables}, also named \textit{coreference tags}, sort symbols and
feature symbols can be used to construct record-like structures called
\osf terms that can describe complex concepts, such as the
following, which denotes the class of movies that are written and
directed by the same person:%
\[
  \X[X] : \s[movie]
  \left(
    \begin{array}{lll}
      \f[directed\_by] & \to & \X[Y] : \s[person],\\
      \f[written\_by] & \to & \X[Y]
    \end{array}
  \right).
\]
The unification algorithm for such structures provides an efficient way
to decide whether two \osf terms are subsumed by each other, and, in
general, for finding the most general \osf term that is subsumed by both
terms, thus offering an efficient calculus of partially ordered types
\cite{AitKaci1986b}.%

This work presents a fuzzy generalization of Order-Sorted Feature (\osf)
logic in which both sorts and \osf terms
are interpreted as
\textit{fuzzy subsets} of the domain of an interpretation rather than crisp
subsets, and where the sort subsumption relation is generalized to a
\textit{fuzzy subsumption relation between sorts}, which is then
extended to a fuzzy subsumption between \osf terms.

The idea of a fuzzy generalization of \osf logic
was first introduced in \cite{AitKaciPasi2020}
where a
weaker notion of
first-order term
unification based on similarity relations between
term constructors is introduced that also allows mismatches
between functor arities and argument positions.
While the interpretation of sort symbols (concept names in DL lingo) as
fuzzy subsets of a domain and the notion of fuzzy or graded subsumption
have already been studied extensively within fuzzy DLs,
the generalization of the semantics of \osf logic to a fuzzy setting is
novel.
In particular, the way in which we interpret
fuzzy subsumption relations
departs significantly from their treatment in fuzzy DLs, which relies
on the fuzzy implication operator \cite{Straccia2014,Borgwardt2017}.

In the rest of this section we provide an informal presentation of our
definition of fuzzy sort subsumption and how it is extended to the terms
of \osf logic, and we motivate the development of fuzzy \osf logic by
outlining its possible implementation
as an extension of the CEDAR reasoner
\cite{AitKaciAmir2017,AmirAitKaci2017} that would be capable of providing
approximate solutions in retrieval applications,
and as a fuzzy logic programming language.

\paragraph{Fuzzy sort subsumption}%

Let $\S$ and $\F$ be (finite) sets of \textit{sort symbols}
  and \textit{feature symbols}, respectively, and let us fix
 an interpretation
  $\ii = \osfa$, i.e., a structure with a domain
  $\dom$ and a function $\cdot^\ii$ that provides an interpretation to the
  elements of $\S$ and $\F$\footnote{Fuzzy interpretations will be defined
  properly in \cref{cha:semantics}.}.
  In our fuzzy setting, a sort $\s\in\S$ is interpreted as a
  fuzzy subset\footnotemark{}
  $\s^\ii:\dom\to[0,1]$, while a feature symbol $\f\in\F$ is
  interpreted as a function $\f^\ii:\dom\to\dom$.
  We rely on the minimum t-norm (denoted $\land$) and the maximum
  t-conorm (denoted $\lor$).
  \footnotetext{The definitions of fuzzy sets, fuzzy binary relations and
  fuzzy orders are recalled in \cref{app:fuzzy}.}%


In the crisp setting, a subsumption relation $\mathop{\isa} \subseteq
\S\times\S$ is a binary relation that denotes set inclusion. A natural
fuzzy generalization of this notion is Zadeh's inclusion of fuzzy sets
 \cite{DuboisPrade1980}, according to which the subsumption $\s\isa\su$ has
the following meaning:
\begin{align}
  \label{eq:fuzzy_inclusion}
  \text{if}~\s\isa\su,\text{then}~\forall d\in\dom: \s^\ii(d)\leq\su^\ii(d).
\end{align}
That is, this definition of fuzzy inclusion requires
  that, whenever $d$ is an
instance of $\s^\ii$ with degree
$\s^\ii(d)=\beta\in[0,1]$, then $d$ must
also be an instance of $\su^\ii$ with a degree
\textit{greater than or equal to} $\beta$.
\input{figures/fuzzy_sub_small}

We consider a \textit{fuzzy subsumption relation}
as a way to model a weaker notion of inclusion, where the element $d$ can
be an instance of $\su^\ii$ with a degree
that \textit{may possibly be smaller than} its degree
of membership to $\s^\ii$.
Thus, we define a fuzzy subsumption relation as a fuzzy partial order,
i.e., a function $\fisa: \S^2\to[0,1]$ that associates a subsumption degree
$\beta$ with each pair of sort symbols $\si[0], \si[1]$ (and satisfying
every constraint of \cref{def:fuzzy_poset} in
\cref{app:fuzzy}) and having the following semantics:
\begin{align}
  \label{eq:fuzzy_subsumption}
  \text{if}~\fisop(\si[0], \si[1])=\beta,~\text{then}~\forall d\in\dom:
  \sii[0](d) \land \beta \leq \sii[1](d).
\end{align}
That is, any object $d$ which is an instance of $\sii[0]$ with degree
$\beta_0$ must also be an instance of $\sii[1]$ with a degree $\beta_1$
  that is \textit{greater than or equal to the minimum of}
$\beta_0$ and $\beta$.
Note that \cref{eq:fuzzy_inclusion} is a special case of this equation with
$\beta = 1$.
An example of a fuzzy sort subsumption
relation is given in \cref{fig:fuzzy_sub_small}\footnotemark{}.
\footnotetext{We represent a fuzzy subsumption relation $\fisa$ graphically
  as a weighted directed acyclic graph (DAG), of which $\fisa$ is the
reflexive and transitive closure (see \cref{def:fuzzy_transitive_closure}
in \cref{app:fuzzy}).}

\paragraph{Fuzzy \osf term subsumption and unification}%

Sort symbols are analogous to the primitive or named concepts
of DLs. Complex concepts can be expressed with
\textit{\osf terms},
structures built from \sortcol{sort symbols}, \featcol{\textit{feature
symbols}} (attributes) and \tagcol{variables}. For example, the term
\[\arraycolsep=2pt
  t_1 = \Xj[1]:\s[movie]
  \left(
    \begin{array}{lll}
      \dirby& \to & \Yj[1]:\person,\\
      \f[genre] & \to & \Zj[1]:\thriller
    \end{array}
  \right)
\]
denotes the class of movies directed by some person and whose genre is
thriller.

In this work we will show that
a fuzzy subsumption relation between sort
symbols can be extended to a fuzzy subsumption relation between \osf terms.
For example, consider the fuzzy subsumption relation depicted in
\cref{fig:fuzzy_sub_small}
and consider the term
\[
  \arraycolsep=2pt
  t_2 = \X[X_{2}]:\s[movie]
  \left(
    \begin{array}{lll}
      \f[title] & \to & \X[W_{2}]:\strng,  \\
      \f[genre] & \to & \X[Z_{2}]:\slasher, \\
      \dirby    & \to & \X[Y_{2}]:\director
    \end{array}
  \right).
\]
This term is more specific that $t_1$, as it provides
additional information by
introducing the feature title and by constraining its value
to be of sort $\strng$,
and because it defines more restrictive constraints,
by requiring
that the value of the feature $\dirby$ be of sort $\director$, which is
subsumed by $\person$, and
that the value of the feature $\f[genre]$ be of sort
$\s[slasher]$, which is subsumed by $\s[thriller]$ (with degree
\appdegree).
In this case we say that $t_1$ \textit{subsumes} $t_2$ with degree
$\appdegree$.

One of the reasoning tasks supported by \osf logic is deciding whether a
given term is subsumed by another, or in general finding the most general
term which is subsumed by two given terms. As we will see,
  this problem can be solved by their \textit{unification}, a
  process which aims to combine the constraints expressed by the two terms
  in a consistent way.
\input{fuzzy/extra/unif_intro_example}

\input{fuzzy/applications}

\input{fuzzy/structure}
