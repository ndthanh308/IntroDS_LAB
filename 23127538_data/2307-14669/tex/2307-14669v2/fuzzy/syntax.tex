\section{Fuzzy \osf logic: syntax}%
\label{cha:syntax}

In this section we provide the definitions of fuzzy \osf signature
and of two formal languages
that are used to
represent knowledge with \osf logic: \textit{\osf terms} and \textit{\osf clauses}.
As discussed in the introduction, \osf terms are comparable to the defined
concepts of DLs, and they will be interpreted as fuzzy subsets of a domain
of interpretation. An \osf clause is an equivalent representation that can
be seen as a logical reading of an \osf term, and for which a notion of graded
satisfaction will be defined. In \osf logic, both syntactic
representation are important from an implementation perspective, as \osf
terms are the abstract syntax employed by an user, while \osf clauses
are used in the constraint normalization rules needed for \osf term
unification
\cite{AitKaci1993b}.

As far as syntax is concerned, the \textit{only difference with crisp \osf
logic} is that we consider a fuzzy sort subsumption relation rather than a
crisp one (the most significant differences concern the
  semantics, as will be seen starting from \cref{cha:semantics}). The
  definitions of \osf terms and \osf constraints and the result concerning
  their equivalence are reported from \cite{AitKaci1993b} for
  self-containment.

\begin{definition}[Fuzzy \osf signature]
\label{def:sort_signature}
A \emph{fuzzy \osf signature} is a tuple $\fss$ where
  $\S$ is a set of \emph{sort symbols},
  $\F$ is a set of \emph{feature symbols}, and
  $\ftax$ is a fuzzy finite bounded lattice with least element
    $\bots$ and greatest element $\tops$\footnotemark.
\footnotetext{See \cref{def:fuzzy_lattice} in \cref{app:fuzzy}.}
Elements of $\S$ and $\F$ will also simply be called \emph{sorts} and
\emph{features}, respectively.
The greatest lower bound (GLB) $\s\fmeet\su$ of two sorts $\s$ and $\su$ is
also called their \emph{greatest common subsort}.
\end{definition}

\begin{example}[Fuzzy \osf signature]
\label{ex:fuzzy_osf_signature}
  As an example of a fuzzy \osf signature we may take the set of sorts and
  the fuzzy subsumption relation corresponding to the graph of
  \cref{fig:fuzzy_sub_small}, and $\F = \{ \f[directed\_by], \f[title] \}$
  as the set of features.
\end{example}

\input{common/terms}

\input{common/constraints}

Finally, we report the constraint normalization rules from
\cite{AitKaci1993b} that are needed to transform an \osf clause into a
solved form. Each rule is of the form
\begin{center}
\osfrulec{\text{Side condition}}{\lab{Rule name}{osf:rn}}
{\text{Premise}~\phi}{\text{Conclusion}~\phi'}\\
\end{center}
and it expresses that, whenever the (optional) side condition holds, the
premise
$\phi$ can be simplified into the conclusion $\phi'$.
The rules of \cref{fig:osf_normalization} are the same as the ones from
\cite{AitKaci1993b}, except that we are considering the GLB operation
$\fmeet$ in a fuzzy lattice rather than an ordinary one. Thanks to
\cref{prop:glbs}, this does not constitute a significant difference as far
as the properties of the normalization procedure are concerned.
An \osf term $\psi$ can be normalized by applying the constraint
normalization rules to $\phi(\psi)$ and translating the result back into an
\osf term.%

\begin{restatable}%
  [{{\osf} clause normalization \cite{AitKaci1993b}}]%
    {theorem}{propclausenormalization}
\label{prop:osf_clause_normalization}
The rules of \cref{fig:osf_normalization} are finite terminating and
confluent (modulo variable renaming). Furthermore, they always result in a
normal form that is either the inconsistent clause or an \osf clause in
solved form together with a conjunction of equality constraints.
\end{restatable}

% Figure environment removed
