A method for transforming an \osf term into a normal one is more easily
presented as a constraint normalization procedure for \osf constraints,
which are defined next.
\begin{definition}[\osf constraints and clauses \cite{AitKaci1993b}]
\label{def:osf_clause}
  An \osf constraint is an expression of the form $\xs$, $\osfce$, or
  $\osfcf$. An \osf clause $\phi$ is a conjunction of \osf constraints. The
  set of variables occurring in $\phi$ is denoted $\osftags(\phi)$, while
  $\phi[\X/\Y]$ is the \osf clause obtained by replacing all occurrences
  of $\Y$ with $\X$.
\end{definition}
Informally,
the constraint $\xs$ means that the value assigned to $\X$ is of sort $\s$;
$\osfce$ means that the same value is assigned to the variables $\X$ and $\X[X']$; while
$\osfcf$ means that applying the feature $\f$ to the value assigned to $\X$ returns the
value assigned to $\X[X']$.%



\begin{example}[\osf clause]
  \label{ex:osf_clause}
  Let $\phi$ be the following \osf clause.
  \[\arraycolsep=4pt
    \begin{array}[b]{llllllll}
      \X[X_{0}] : \s[movie] & \with & \X[X_{0}].\f[title] \doteq \X[X_{1}] & \with & \X[X_{1}] : \s[string] & \with & \X[X_{0}].\f[directed\_by] \doteq \X[X] & \with\\
      \X[X] : \s[director] & \with & \X[X].\f[name] \doteq \X[X_{2}] & \with & \X[X_{2}] : \s[string] & \with & \X[X].\f[spouse] \doteq \X[Y] & \with\\
      \X[X_{0}].\f[written\_by] \doteq \X[Y] & \with & \X[Y] : \s[writer] &
      \with & \X[Y].\f[spouse] \doteq \X[X].
    \end{array}
  \]
  Note that $\phi$ is simply a translation of the term from
  \cref{ex:osf_term} into an \osf clause.
  The variables that
  were left implicit in \cref{ex:osf_term} must be written explicitly in
  the \osf clause.
\end{example}

While every \osf term can be rewritten as an \osf clause, the converse is
in general only true for the class of
\ifrefer
\textit{rooted solved \osf clauses}, which are defined in \cite{AitKaci1993b}.
  A rooted \osf clause is denoted $\phi_{\X}$, where $\X$ is the
  root of the clause $\phi$. For an \osf clause $\phi$ and a variable
  $\X\in\osftags(\phi)$, the maximal
  subclause of $\phi$ rooted in $\X$ is denoted $\phi(\X)$.
  The set of all \osf clauses in solved form is denoted $\Phi$, and the
  subset of rooted solved \osf clauses is denoted $\PhiR$.%
\else
\textit{rooted solved \osf clauses} \cite{AitKaci1993b},
which are defined next.
\begin{definition}[Rooted \osf clause \cite{AitKaci1993b}]
\label{def:rooted_clause}
  Given an \osf clause $\phi$, the binary relation ${\reach}\subseteq
  \osftags(\phi)\times\osftags(\phi)$ is defined as follows, for all $\X,
  \Y\in\osftags(\phi)$: (i) $\X\reach\X$, and (ii) $\X\reach\Y$ if there is
  a constraint $\X.\f\doteq\Z$ in $\phi$ and $\Z\reach\Y$.
  A \textit{rooted \osf clause} $\phi_{\X}$ is an \osf clause $\phi$ together
  with a distinguished variable $\X$ (its root) such that every variable
  $\Y$ occurring in $\phi$ is explicitly sorted (possibly as $\Y:\tops$)
  and reachable from $\X$.
\end{definition}

\begin{definition}[Maximal subclause of {$\phi$} rooted in {$\X[X]$}
  \cite{AitKaci1993b}]
\label{def:maximal_subclause_of_phi_rooted_in_x_}
  Given an \osf clause $\phi$ and a variable $\X\in\osftags(\phi)$,
  the maximal subclause of $\phi$ rooted in $\X$ is denoted $\phi(\X)$.
\end{definition}

\begin{definition}[Solved \osf clause \cite{AitKaci1993b}]
\label{def:solved_clause}
  An \osf clause $\phi$ is called \textit{solved} if, for each variable
  $\X$, $\phi$ contains
  (i) at most one sort constraint of the form $\X:\s$ with $\s\neq\bots$,
  (ii) at most one feature constraint of the form $\X.\f\doteq \Y$ for each
  $\f$, and
  (iii) no equality constraint of the form $\X\doteq\Y$.
  The set of all \osf clauses in solved form is denoted $\Phi$, and the
  subset of rooted solved \osf clauses is denoted $\PhiR$.
\end{definition}
\fi

\begin{prop}[Equivalence of $\psi$-terms and rooted solved \osf
  clauses \cite{AitKaci1993b}]
\label{prop:bijections_terms_clauses}
  There exist bijective mappings $\phi:\Psi\to\PhiR$ and
  $\psi:\PhiR\to\Psi$, i.e., such that
  $\id[\PhiR] = \phi\circ\psi$ and
  $\id[\Psi] = \psi\circ\phi$.
\end{prop}
Note that we use the same symbol $\phi$ to denote an \osf clause and the
function mapping an \osf term to a clause (and similarly for the symbol
$\psi$), as the meaning is always clear from context.
