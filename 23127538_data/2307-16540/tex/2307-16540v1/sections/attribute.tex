% \subsection{Scalability of number of attributes}
% \label{sub:attribute}

% Loomis-Whitney Query


% Generalized three clique query

% $edge(a, b, c), edge(b, c, d), edge(c, d, a), edge(d, a, b)$



% \pgfplotstableread[col sep=comma,]{data/lw.csv}\generalizedquery


% % Figure environment removed


\section{Scalability in the Number of Join Attributes per Relation}
\label{sec:attributescalability}

Many of the benchmarks presented so far have an elevated number of tables and join attributes (e.g., up to 16 tables for JOB). However, the number of join attributes per table is typically small (two join attributes per table for graph benchmarks, reaching up to four attributes for some JOB queries). The number of attributes per table influences the number of sort orders ADOPT has to maintain, possibly influencing its relative performance. Next, we study the impact of the number of attributes per table on the relative performance of ADOPT. 

%This number influences the number of sort orders ADOPT may have to create during processing, thereby potentially. 

%To test the performance of ADOPT when scaling to larger number of attributes, we vary the number of degree in Loomis-Whitney query.

% degree 5 edge(a, b, c, d), edge(b, c, d, e), edge(a, c, d, e), edge(a, b, d, e), edge(a, b, c, e).

We use Loomis-Whitney queries with varying degree for this purpose. A Loomis-Whitney query with degree $n$ (i.e., the number of join attributes in each table is $n-1$) is defined as,

% \vspace{-1em}
\begin{equation*}
\begin{split}
    & edge(a_1, a_2, \cdots, a_{n-2}, a_{n-1}), edge(a_2, \cdots, a_{n-2}, a_{n-1}, a_{n}), \\
    & edge(a_1, a_3, \cdots, a_{n-1}, a_n), edge(a_1, a_2, a_4, \cdots, a_n), \cdots, \\
    & edge(a_1, a_2, \cdots, a_{n-2}, a_n) \\
\end{split}
\end{equation*}


\pgfplotstableread[col sep=comma,]{data/lw.csv}\generalizedquery


% Figure environment removed

% For the Loomis-Whitney with degree $n + 1$, the input table is Loomis-Whitney with degree $n$.

We use the query result of Loomis-Whitney with degree $n$ as the input table of Loomis-Whitney query with degree $n + 1$ (truncating the query result to 200M rows as, otherwise, none of the compared systems finish for the highest degree within the timeout of ten minutes). For the different degrees, in ascending order, the table sizes are (approximately) 13M rows, 105M rows, and 200M rows.%For the degree 5, we truncate the input table to 200,000,000, since all systems cannot finish using the origin input table which contains roughly 800,000,000 rows.

The wall-clock execution time for Loomis-Whitney queries on ego-Twitter is depicted in Figure~\ref{fig:attributescalability}. ADOPT performs better than the other baselines and the relative performance gap grows as the number of join attributes increases. Clearly, without adaptive processing, finding good query plans becomes harder as queries become more complex. In addition, we measure overheads for index creation before run time for all systems separating index creation from query evaluation (see Appendix~\ref{sec:indexcreation} for details). For Postgres, we create indexes on each column of the input table. EmptyHeaded automatically selects indexes to create. For ADOPT, we create indexes to support all possible attribute orders. Table~\ref{tab:lmindexing} reports corresponding results. For both baselines implementing worst-case optimal join algorithms (ADOPT and EmptyHeaded), index creation time is higher than for Postgres and grows faster with increasing degree (note that, as discussed previously, the size of the input data increases as well). However, among the two baselines with worst-case optimal join algorithms, ADOPT generates indexes significantly faster. For all systems, the resulting indexes can be reused across all future queries.

\begin{table}[b]
    \centering
        \caption{Index generation times for different systems (in seconds), preparing evaluation of Loomis-Whitney queries with varying degree.}
    \begin{tabular}{l|rrr}
    \toprule[1pt]
    \textbf{System} & \textbf{Degree 3} & \textbf{Degree 4} & \textbf{Degree 5} \\
    \midrule[1pt]
         Postgres & 14 & 161 & 407\\
         ADOPT & 3 & 81 & 1003 \\
         EmptyHeaded & 99 & 949 & 3719 \\
    \bottomrule[1pt]
    \end{tabular}
    \label{tab:lmindexing}
\end{table}

%ADOPT outperforms all other baseline methods once the number of join attributes in each table is at least three. This is because non-adaptive approaches face significant challenges in selecting a good execution plan, making it difficult for them to compete with ADOPT's adaptive approach.

