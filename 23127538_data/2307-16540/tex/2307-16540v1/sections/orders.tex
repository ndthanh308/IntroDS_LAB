
\subsection{Time Breakdown by Attribute Order}
\label{sub:optimalattributeorder}

\nop{We run experiments to verify the following hypothesis.}

\begin{hyp}
ADOPT spends most time on executing near-optimal attribute orders.
\end{hyp}

\pgfplotstableread[col
sep=space,]{data/five_clique_order.csv}\fivecliqueorder

\pgfplotstableread[col
sep=space,]{data/five_cycle_order.csv}\fivecycleorder

\pgfplotstableread[col
sep=space,]{data/four_clique_order.csv}\fourcliqueorder

\pgfplotstableread[col
sep=space,]{data/four_cycle_order.csv}\fourcycleorder

% Figure environment removed

We verified this hypothesis for $n$-clique and $n$-cycle queries with $n\in\{4,5\}$, since for these queries it was feasible to generate and execute all possible attribute orders. This was necessary to understand which orders are better than others and assess whether ADOPT uses predominantly good or poor orders.
We plot the orders that we select and their quality relative to the optimal orders (i.e., with lowest execution time) in Figure~\ref{fig:orderdetail}. The x-axis is the number of time slices  that use an order: the larger the x-value, the more we use an order. The y-axis is execution time of an order relative to the optimal one: The smaller the y-value, the closer to the optimal the order is. For $4$-clique and $4$-cycle, ADOPT spends more than $10^6$ (over 95\% frequency) times on executing an order with near-optimal performance. For $5$-cycle and $5$-clique,  ADOPT picks a near-optimal order more than $10^8$ times (over 98\% frequency). ADOPT thus quickly converges to a near-optimal order and then uses it for most of the processing, which confirms our hypothesis.

% We show orders that we select and its quality in Figure~\ref{fig:orderdetail}.

\begin{table}[t]
\centering 
\caption{Execution times (sec) for clique and cycle queries on ego-Twitter of: ADOPT, LFTJ with optimal attribute order (OPT), average runtime of LFTJ over all attribute orders (AVG).  Relative speedup of OPT over ADOPT (last column).}
\begin{tabular}{l|rrrr}
\toprule[1pt]  & ADOPT & OPT & AVG & ADOPT/OPT \\
\midrule[1pt]
3 clique & 4.1	 & 1.6	  & 3.7	   & 2.52 \\
4 clique & 10.5  & 6.8	  & 23.9   & 1.54 \\
5 clique & 77.9	 & 52.5	  & 275.6  & 1.48 \\
3 cycle	 & 4.1	 & 1.6	  & 3.5	   & 2.52 \\
4 cycle	 & 20.1  & 17.4	  & 58.9   & 1.16 \\
5 cycle	 & 377.9 & 328.8  &	3618.1 & 1.14 \\
\bottomrule[1pt]
\end{tabular}
\label{tab:ratio_with_opt}
\end{table}

Table~\ref{tab:ratio_with_opt} compares ADOPT and LFTJ with an optimal attribute order: The runtime gap decreases from 2.52x for 3-clique/cycle to 1.48x (1.14x) for 5-clique (5-cycle). This is remarkable, given that ADOPT tries out several attribute orders and switches between them, whereas LFTJ only uses one attribute order, which is optimal. Table~\ref{tab:ratio_with_opt} also shows that ADOPT takes significantly less time than the average runtime of LFTJ over all attribute orders\nop{ the larger the query gets}.



% R_1(a, b), R_2(b, c), R_3(c, a)
% R_1(a, b, c), R_2(b, c, d), R_3(c, d, a), R_4(d, a, b)
% R_1(a, b, c, d), R_2(b, c, d, e), R_3(c, d, e, a), R_4(d, e, a, b), R_5(e, a, b, c)
% R_1(a, b, c, d, e), R_2(b, c, d, e, f), R_3(c, d, e, f, a), R_4(d, e, f, a, b), R_5(e, f, a, b, c), R_6(f, a, b, c, d)

% E(a, b, a), E(b, a, b), E(a, b, a), E(b, a, b)
% R_1(a, b, a, b), R_2(b, a, b, a), R_3(a, b, a, a), R_4(b, a, a, b), R_5(a, a, b, a)


