\section{Sorting and Synchronization Overheads}
\label{sec:ablation}

\nop{
 \begin{table}[t]
\centering 
\caption{Sorting and synchronization times for 5 clique/cycle.}
\begin{tabular}{llccc}
\toprule[1pt] Graph & Query & Sorting & Synchronization \\
\midrule[1pt]
\multirow{2}{*}{ego-Facebook} & 5 clique  & 0.022 & 0.046 \\
                              & 5 cycle	& 0.003 & 0.077 \\
\hline                       
\multirow{2}{*}{ego-Twitter}  & 5 clique & 0.015 & 0.017 \\
                              & 5 cycle  & 0.001	& 0.013 \\
\hline                           
\multirow{2}{*}{soc-Pokec}   & 5 clique  & 0.021	& 0.067 \\
                             & 5 cycle  & 0.018	& 0.063 \\
\hline                       
\multirow{2}{*}{soc-LiveJournal1} & 5 clique  & 0.021	& 0.049\\
                                  & 5 cycle  & 0.001	& 0.059 \\
\bottomrule[1pt]
\end{tabular}
\label{tab:time_breakdown}
\end{table}
}

\begin{hyp}
    The times required by ADOPT for sorting and  thread synchonization are small relative to the total execution time.
\end{hyp}

% Graph	Query	Sort Time	Wait Time	Execution Time	Sort Ratio	Wait Ratio
% ego-Facebook	5 clique	354	749	16204	0.022	0.046
% 	5 cycle	70	2052	26743	0.003	0.077
% ego-Twitter	5_clique	1318	1473	87255	0.015	0.017
% 	5_cycle	299	4088	311227	0.001	0.013
% soc-Pokec	5_clique	18148	5681	84933	0.214	0.067
% 	5_cycle	6287	21869	345698	0.018	0.063
% soc-LiveJournal1	5_clique	37676	86187	1770447	0.021	0.049
% 	5_cycle	11406	518615	8719080	0.001	0.059


\nop{Table ~\ref{tab:time_breakdown} confirms this hypothesis for two queries.}

To implement efficient seek operations in the context of its LFTJ variant, ADOPT requires data structures representing different table sort orders (see Appendix~\ref{sec:lftjinadopt} for details). For base tables, ADOPT creates those sort orders at pre-processing time, corresponding overheads are reported in Appendix~\ref{sec:indexcreation}. However, ADOPT creates temporary tables during query evaluation, representing base tables after filtering via unary predicates. For those tables, ADOPT creates all required sort orders at run time. We measured the relative overhead of run time sorting, compared to total query evaluation time. Over all queries and benchmarks, sorting overheads reach at most 2.5\% of total query evaluation time. This means that time required for run time sorting is fairly modest (which is explained, in part, by the fact that tables resulting from filter operations tend to be quite small, compared to the source tables).



%Whenever ADOPT starts a new episode with an attribute order different from the order used in the previous episodes, it might need to re-sort the tables so as to support the intersection of sorted lists as required by the leapfrog triejoin. We quantify the sorting time by invoking \texttt{System.currentTimeMillis()} before and after the sorting process, and then calculating the duration between the two timestamps. In our experiments, the time for sorting only accounts for at most 2.5\% of the total execution time of ADOPT for all queries. Sorting has thus negligible overhead, even though ADOPT frequently switches orders.

For each episode and thread, we can sum up the time spent by that thread in processing the LFTJ join on different cubes (considering all cubes processed by the thread during the episode). When measuring the total duration of an episode, the episode time typically exceeds the accumulated join processing time. The difference is due to various bookkeeping and synchronization overheads, e.g., waiting for the lock on the data structure containing unprocessed cubes (locking is necessary to avoid redundant work across threads). Considering all queries and benchmark, the maximal percentage of such overheads, relative to total query execution time, was 7\%. This means that the largest part of run time is spent doing useful work.

%At the start of a new episode, ADOPT assigns a thread to handle an unprocessed hypercube. This process involves some synchronization overhead to manage the hypercubes. To measure the synchronization time, we invoke \texttt{System.currentTimeMillis()} before and after accessing the hypercube and compute the time difference. The synchronization time accounts for a maximum of 7\% of the overall execution time.


% \vldbchange{In the multi-thread environment, when ADOPT starts a new episodes, a thread will be assigned with a unprocessed hypercube. Thus 
% We argue the hypercube partition approach have}


% So we conclude that ADOPT does not waste time on sorting when frequently switching orders.


