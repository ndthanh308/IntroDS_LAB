\subsection{Anytime Join Algorithm}
\label{sub:join}

\begin{algorithm}[t!]
\caption{Parallel anytime version of worst-case optimal join algorithm.\label{alg:anytimeLFTJ}}
\renewcommand{\algorithmiccomment}[1]{// #1}
\begin{small}
\begin{algorithmic}[1]
\State \textbf{Input:} Query $q$, attribute order $o$, number of threads $n$, per-episode budget $b$, Result set $R$
\State \textbf{Output:} Reward $r$
\Function{AnytimeWCOJ}{$q,o,n,b,R$}
\State \Comment{Initialize accumulated reward}
\State $r\gets 0$
\State \Comment{Execute in parallel for all threads}
\For{$1\leq t\leq n$ in parallel}
\State \Comment{Initialize remaining cost budget}
\State $l_t\gets b$
\State \Comment{Iterate until per-episode budget spent}
\While{$l_t>0$}
\State \Comment{Retrieve unprocessed target cube}
\State $c_t\gets$\Call{TM.Retrieve}{}
\State \Comment{Process cube until timeout, add results}
\State $\langle P_t,s_t\rangle\gets$\Call{JoinOneCube}{$q,l_t,o,c_t,R$}
\State \Comment{Update constraints via processed cube}
\State \Call{TM.Remove}{$c_t,P_t$}
\State \Comment{Update accumulated reward (see Section~\ref{sub:estimation})}
\State $r\gets r+Reward(P_t,q)$
\State \Comment{Update remaining budget}
\State $l_t\gets l_t-s_t$
\EndWhile
\EndFor
\State \Comment{Return accumulated reward}
\State \Return{$r$}
\EndFunction
\end{algorithmic}
\end{small}
\end{algorithm}

Algorithm~\ref{alg:anytimeLFTJ} is the (worst-case optimal) join algorithm, used to execute a given attribute order for a fixed number of steps. Execution proceeds in parallel: different worker threads operate on non-overlapping cubes. Each worker thread iterates the following steps until its computational budget is depleted \revision{(Lines~11 to 22)}. First, it retrieves an unprocessed cube, the target cube, from the task manager \revision{(Line~13)}. Then, it uses a sub-function (an anytime version of the LFTJ) to process the retrieved target cube \revision{(Line~15)}. In practice, it is often not possible to process the entire target cube under the remaining computation budget. Hence, the result of the triejoin invocation (Function~\textproc{JoinOneCube}) reports the set of cubes, contained within the target cube, that were successfully processed. In addition, it returns the number of computation steps spent. The task manager is notified of successfully processed cubes which will be excluded from further consideration \revision{(Line~17)}. Also, a reward value is calculated that represents progress towards generating a full join result \revision{(Line~19)}. We postpone a detailed discussion of the reward function to Section~\ref{sub:rl}. Finally, Algorithm~\ref{alg:anytimeLFTJ} returns the reward value, accumulated over all threads and iterations \revision{(Line~25)}.


% \begin{algorithm}[t!]
% \caption{Worst-case optimal join algorithm with timeout, joining a single cube.\label{alg:joinOneCube}}
% \renewcommand{\algorithmiccomment}[1]{// #1}
% \begin{small}
% \begin{algorithmic}[1]
% \State \textbf{Input:} Query $q$, remaining budget $b$, attribute order $o$, cube to process $c$, result set $R$, attribute counter $a$
% \State \textbf{Output:} Processed cube $p$, computational steps performed $s$
% \Function{JoinOneCube}{$q,b,o,c,R,a$}
% \If{$a\geq|q.A|$} \Comment{Check for completed result tuples}
% \State Insert tuple with current attribute values into $R$
% \Else
% \State \Comment{Initialize value iterator (do not evaluate it!)}
% \State $V\gets$ iterator over matching values for $o_a$ in $[c.l_{o_{a}},c.u_{o_{a}}]$
% \State \Comment{Iterate over values until timeout}
% \For{$v\in V$}
% \State \Comment{Select values for remaining attributes}
% \State \Call{JoinOneCube}{$q,l,o,c,R,a+1$}
% \State \Comment{Check for timeouts}
% \If{Total computational steps $>b$}
% \State \textbf{Break}
% \EndIf
% \EndFor
% \EndIf
% \State \Comment{Return processing statistics only for top-level instance}
% \If{$a=0$}
% \State $s\gets$ Total number of computational steps performed
% \State $P\gets\emptyset$
% \For{$0\leq a< |q.A|$}
% \State $p_{1\leq i<a}\gets[v_i,v_i]$ s.t.\ $v_i$ is current value for attribute $o_i$
% \State $p_{a}\gets[c.l_{o_{a}},v_a)$ s.t.\ $v_a$ is current value for attribute $o_a$
% \State $p_{a<i}\gets[c.l_{o_{i}},c.u_{o_{i}}]$
% \State $P\gets P\cup\{p\}$
% \EndFor
% \State \Return{$\langle P,s\rangle$}
% \Else
% \State \Return{$\langle -,-\rangle$}
% \EndIf
% \EndFunction
% \end{algorithmic}
% \end{small}
% \end{algorithm}

\begin{algorithm}[t!]
\caption{Worst-case optimal join algorithm with timeout, joining a single cube.\label{alg:joinOneCube}}
\renewcommand{\algorithmiccomment}[1]{// #1}
\begin{small}
\begin{algorithmic}[1]
\State \textbf{Input:} Query $q$, remaining budget $b$, attribute order $o$, target cube to process $c$, result set $R$, attribute counter $a$, value mappings $M$
\State \textbf{Effect:} Iterates over attribute values and possibly adds results to $R$
\Procedure{JoinOneCubeRec}{$q,b,o,c,R,a,M$}
\If{$a\geq|q.A|$} \Comment{Check for completed result tuples}
\State Insert tuple with current attribute values $M$ into $R$
\Else
\State \Comment{Initialize value iterator (do not evaluate it!)}
\State $V\gets$ iterator over values for $o_a$ in $[c.l_{o_{a}},c.u_{o_{a}}]$ \revision{that satisfy}
\Statex $\quad\quad\quad\quad$ \revision{all applicable join predicates in $q$.}
\State \Comment{Iterate over values until timeout}
\For{$v\in V$}
\State \Comment{Select values for remaining attributes}
\State \Call{JoinOneCubeRec}{$q,l,o,c,R,a+1,M\cup\{\langle o_a,v\rangle\}$}
\State \Comment{Check for timeouts}
\If{Total computational steps $>b$}
\State \textbf{Break}
\EndIf
\EndFor
\EndIf
\EndProcedure
\vspace{0.25cm}
\State \textbf{Input:} Query $q$, remaining budget $b$, attribute order $o$, target cube to process $c$, result set $R$
\State \textbf{Output:} Processed cube $p$, computational steps performed $s$
\Function{JoinOneCube}{$q,b,o,c,R$}
\State \Comment{Resume join for fixed number of steps}
\State \Call{JoinOneCubeRec}{$q,b,o,c,R,0,\emptyset$}
\State \Comment{Retrieve state from \textproc{JoinOneCubeRec} invocation}
\State $s\gets$ Number of computational steps spent
\State $v\gets$ Vector s.t.\ $v_a$ is last value considered for attribute $o_a$
\State \Comment{Calculate processed cubes}
\State $P\gets\emptyset$
\For{$0\leq a< |q.A|$}
\State Create new cube $p$ s.t.\
\State $\quad$ $\forall i<a:p_i=[v_i,v_i];$
\State $\quad$ $\quad$ $p_a=[c.l_{o_a},v_a);$
\State $\quad$ $\quad$ $\quad$ $\forall a<i:p_i=[c.l_{o_i},c.u_{0_i}]$
\State $P\gets P\cup\{p\}$
\EndFor
\State \Return{$\langle P,s\rangle$}
\EndFunction
\end{algorithmic}
\end{small}
\end{algorithm}

Algorithm~\ref{alg:joinOneCube} describes the sub-function, used to process a single cube, at a high level of abstraction. The actual join is performed by Procedure~\textproc{JoinOneCubeRec}. This procedure is based on the leapfrog triejoin~\cite{DBLP:conf/icdt/Veldhuizen14}, a classical, worst-case optimal join algorithm\footnote{\revision{A detailed example of the LFTJ execution is given in Appendix \ref{sec:illustrating_LFTJ}.}}. For conciseness, the pseudo-code describes the algorithm as a recursive function (whereas the actual implementation does not use recursion). The input to the algorithm is the join query, the remaining computational budget, an attribute order, a target cube to process, the result set, and the index of the current attribute. The algorithm considers query attributes sequentially, in the given attribute order. The attribute index marks the currently considered attribute. Once the attribute index reaches the total number of attributes (represented as $q.A$), the algorithm has selected one value for each attribute. Furthermore, at that point, it is clear that the combination of attribute values satisfies all applicable join conditions. Hence, the algorithm adds the corresponding result tuple into the result set \revision{(Line~5)}. \revision{As a variant (not shown in Algorithm~\ref{alg:joinOneCube}), for queries with simple aggregates without grouping, ADOPT does not store result tuples but merely updates partial aggregate values for each aggregate.} If the attribute index is below the total number of attributes, the algorithm iterates over values for that attribute (i.e., attribute $o_a$ where $o$ is the order and $a$ the attribute index) \revision{in the loop from Line~10 to 17}. 

In Line~8, Algorithm~\ref{alg:joinOneCube} creates an iterator over values for the current attribute that \revision{satisfy all \textit{applicable} join predicates and are within the target cube,} i.e., values contained in the interval $[c.l_{o_a},c.u_{o_a}]$ for attribute number $a$ within order $o$ ($c.l$ and $c.u$ designate vectors, indexed by attribute, that represent lower and upper target cube bounds respectively). The algorithm does not assemble the full set of matching values before iterating (as that would create significant overheads when switching attribute orders before being able to try all collected values). Instead, Line~8 is meant to represent the initialization of data structures that allow iterating over matching values efficiently. \revision{Join predicates are applicable if, beyond the current attribute $o_a$, they only refer to attributes whose values have been fixed previously (i.e., a corresponding value assignment is contained in $M$). For equality join predicates, ADOPT uses the same mechanism as LFTJ~\cite{DBLP:conf/icdt/Veldhuizen14} to efficiently iterate over satisfying values. This mechanism is described in detail in Appendix~\ref{sec:illustrating_LFTJ}. It is based on data structures that support fast seek operations on query relations. Whenever required data structures are not available, ADOPT dynamically creates them at run time. For base relations, but not for relations filtered via unary predicates, ADOPT caches and reuses those data structures across queries.}

% As those data structures depend on the order in which attributes are considered, ADOPT dynamically creates them if required. At the same time, ADOPT caches  

% For all other join predicates, ADOPT simply evaluates the predicate and skips values where it evaluates to false.} It should be well understood that the algorithm does not assemble the full set of matching values before iterating (as that would create significant overheads when switching attribute orders before being able to try all collected values). Instead, Line~8 is meant to represent the initialization of data structures that allow iterating over matching values efficiently.


%appear in all input relations (as indicated by the expression ``matching values''). \revision{At the same time, values are filtered to the ones that satisfy all predicates of query $q$ that can already be evaluated, given the } It focuses only on attribute values within the target cube, i.e.\ values contained in the interval $[c.l_{o_a},c.u_{o_a}]$ for attribute number $a$ within order $o$ ($c.l$ and $c.u$ designate vectors, indexed by attribute, that represent lower and upper target cube bounds respectively). It should be well understood that the algorithm does not assemble the full set of matching values before iterating (as that would create significant overheads when switching attribute orders before being able to try all collected values). Instead, Line~8 is meant to represent the initialization of data structures that allow iterating over matching values efficiently. More precisely, those data structures allow ADOPT to efficiently intersect values from different relations for the same join attribute. We refer to the original publication for a detailed discussion~\cite{DBLP:conf/icdt/Veldhuizen14}. Note that ADOPT, instead of creating all potentially required data structures a-priori (which depend on the attribute order), it creates them on-demand, only if required for executing a new order.

Join processing via Procedure~\textproc{JoinOneCube} terminates once the computational budget is depleted \revision{(check in Line~14)}, or if the current cube is entirely processed. Function~\textproc{JoinOneCube} retrieves the number of computational steps, spent during join processing, as well as the last selected value for each attribute. It uses the latter to calculate the set of processed cubes (to be removed from the set of unprocessed cubes). Procedure~\textproc{JoinOneCubeRec} does not advance from one value of an attribute to the next, unless all value combinations for the remaining attributes have been fully considered. Hence, if value range  $c.l_{o_{a}}$ to $v_a$ was covered for the current attribute $a$, the cube representing processed value combinations reaches the full cube dimensions for all attributes that appear later than $a$ in the order $o$, and is fixed to the currently selected value for all attributes appearing before $a$ in $o$. Note that the pseudo-code uses a shortcut to assign both cube bounds at once (e.g., $p_i=[v_i,v_i]$ is equivalent to $[p.l_i,p.u_i]=[v_i,v_i]$) \revision{in Lines~32 to 34}.

\tikzstyle{cube}=[draw=black, thick]

% Figure environment removed

\begin{example}
\rm
Figure~\ref{fig:cubes} illustrates the containment relationships between different cubes when processing a query with two attributes. Processed cubes are contained within target cubes and target cubes are contained within the entire query cube. The figure represents target cubes that were processed, in different episodes, according to both possible attribute orders. The first one (left) was processed using order $A_1,A_2$. Hence, values for the first attribute change only after trying all values for the second attribute. Therefore, processed cubes fill the target cube ``column by column''. The other target was processed using the order $A_2,A_1$. Hence, processed cubes fill the target cube ``row by row''.
\end{example}

% The cube representing the scope of a single thread is located within the overall cube representing the entire query. The target cube is contained within the thread scope and represents the (maximal) goal for one invocation of Algorithm~\ref{alg:joinOneCube}. Processed cubes are contained within the target cube and may not entirely cover it, in case of a timeout. The figure indicates that a timeout occurred while processing the target cube. Also, it indicates that Attribute~1 comes, indeed, first in the processed attribute order. Hence, the cube associated with the value range considered for the first attribute covers the entire value range (of the target cube) for the second attribute.