\section{Illustration of LeapFrog TrieJoin}
\label{sec:illustrating_LFTJ}
In this section, we illustrate the LFTJ algorithm.
In Section~\ref{sec:leapfrog_join},
we describe leapfrog join on unary relations, which is the basic building block of LFTJ.
We explain in Section~\ref{sec:trie_representation} how LFTJ traverses non-unary relations. 
In Sections~\ref{sec:lftj_acyclic_query} and \ref{sec:lftj_cyclic_query}, we 
illustrate LFTJ for an acyclic and respectively a cyclic query. 



\subsection{Leapfrog Join on Unary Relations}
\label{sec:leapfrog_join}
Assume we want to  
join several unary relations over the same attribute. 
This amounts to computing the intersection of the relations. 
The leapfrog join algorithm navigates each relation
using an iterator that sees the relation as an ordered list. 
The iterators provide the following operations:
%$value()$ returns the value at the current position
%of the iterator;
$next()$ moves the iterator to the next position 
in the list, or to \textbf{EOF} if no such position exists;
given a value $v$, $seek(v)$ moves the iterator to the position with the least 
value $w$ such that $w \geq  v$, 
%(using binary search) 
or to \textbf{EOF} if no such value exists.
%$atEnd()$ returns true if the iterator is at the end.
At the beginning, each iterator is at the first position of its list.
As long as all values  
at the current positions of the iterators do not match,
the leapfrog join algorithm proceeds as follows. Given that the largest 
value at the current positions of the iterators is $v$,
the algorithm   calls $seek(v)$ for one of the iterators with the smallest current value. In case the values 
at the current iterator positions match,
the common value is added to the output. Then, the algorithm 
calls $next()$ for one of the list and repeats the above strategy 
to find the next common value. The algorithm stops once 
one of the iterators reaches \textbf{EOF}.  
%The algorithm runs in time 
%$\Theta(N_{\text{min}}(1 + \log (\frac{N_{\text{max}}}{N_{\text{min}}})))$, 
%where $N_{\text{min}}$ and $N_{\text{max}}$ are the sizes 
%of the smallest and respectively largest relation. 

% Figure environment removed

% Figure environment removed

\begin{example}
\rm
We illustrate leapfrog join 
for the query 
$q(a)$ $=$ $r(a), s(a), t(a)$
that computes the intersection of the 
three unary relations
depicted in Figure~\ref{fig:join_unary_relations}.
Figure~\ref{fig:leapfrog_join} visualizes 
how the iterators traverse the three relations. 
The iterators start at the initial positions 
of the ordered lists representing
the relations. 
The values at the initial positions do not match 
and the largest such value is the value $2$ in $t$.
Hence, the algorithm calls $seek(2)$ for $r$, which moves the 
iterator of $r$ to the position with value $3$. 
Now, the largest value of the current iterator positions is
$3$, so the algorithm calls 
$seek(3)$ for $s$. This operation moves the iterator of $s$ to the position with value $6$. Then, it calls $seek(6)$ for $t$, which moves $t$'s iterator  to the position with value $8$.
Afterwards, it calls $seek(8)$ for $r$ and then for $s$, upon which the iterators of both relations move to their respective positions holding value $8$.
Now, all iterators point to the value $8$, so we have a match. 
The algorithm adds $8$ to the output and moves
the iterator of $t$ to the next position, which holds 
the value $10$. 
Then, it calls $seek(10)$ for $r$, which  moves $r$'s iterator to the position with value 
$11$. Finally, it calls $seek(11)$ for $s$, upon which the iterator of $s$ moves to \textbf{EOF}, so the algorithm stops.

We conclude that the only output value is $8$.
\end{example}




\subsection{Navigation over Non-Unary Relations}
\label{sec:trie_representation}
LFTJ navigates non-unary relations using iterators that interpret
the relations as tries that follow attribute orders. 
Each level in a trie corresponds to one attribute.
The iterators support the following operations:
$open()$ moves the iterator to the first child node of the current node;
$up()$ returns the iterator to the parent node; 
$next()$ moves the iterator to the next sibling
or \textbf{EOF} if no such sibling exists;
given a value $v$, $seek(v)$ moves the iterator to the sibling with the least 
value $w$ such that $w \geq  v$, 
or to \textbf{EOF} if no such value exists.

% Figure environment removed

% Figure environment removed

\begin{example}
\rm
Figure~\ref{fig:trie_representation} depicts a relation $r$ and its 
interpretation as a trie that follows the 
attribute order $a-b-c$. The children of each node are sorted. 
The children of the root carry the 
$a$-values of $r$, which are $0$ and $1$. The children of the $a$-value $0$  
carry the values $3$, $4$, and $5$, which are the $b$-values paired with $0$ in $r$.
The children of the $c$-value $3$ carry the values $4$ and $5$, 
which are the $c$-values paired with $0$ and $3$ in $r$. 
The rest of the trie is organized analogously. 
%
Figure~\ref{fig:trie_traversal} visualizes  how an iterator 
traverses the values in relation $r$
via the operation sequence $open()$, $open()$, $next()$, $open()$, $seek(2)$, $up()$.
\end{example}


\subsection{Leapfrog Triejoin for an Acyclic Query}
\label{sec:lftj_acyclic_query}
Given a set of relations, a global attribute order 
is an ordering of all attributes appearing in the relations.  
LFTJ requires that all input relations can be navigated 
following a global attribute order.
Consider a set of relations and a global attribute order 
$att_1, \ldots , att_n$.
To create all tuples in the join result, LFTJ proceeds as follows. 
It uses leapfrog join to fix the first $att_1$-value that appears in all relations 
containing attribute $att_1$.
Given that the values for $att_1, \ldots , att_i$ with $i < n$
are already fixed to values $a_1, \ldots , a_i$, it uses again leapfrog join to fix the first 
$att_{i+1}$-value 
that appears in all relations containing $att_{i+1}$ when restricted  
to $a_1, \ldots , a_i$.
Once all attributes are fixed 
to values $a_1, \ldots , a_n$, it means that 
$(a_1, \ldots , a_n)$ constitutes a tuple in the join result, so
the algorithm adds it to the output. 
Then, it triggers leapfrog join to traverse the remaining   
$att_{n}$-values that appear in all relations containing $att_{n}$ when restricted  
to $a_1, \ldots , a_{n-1}$. For each such $att_{n}$-value $a_n'$, it 
adds  
$(a_1, \ldots , a_n')$ to the output. Once all $att_{n}$-values are exhausted, it backtracks 
and searches for the next $att_{n-1}$-value that appears in the join 
in the context of $(a_1, \ldots , a_{n-2})$, and so on.
In the following, we illustrate how LFTJ computes an acyclic
join. 
 
% Figure environment removed 

\input{sections/LFTJ_strategy_acyclic}

\begin{example}
\label{ex:acyclic}
\rm
Consider the acyclic query $q(a,b,c,) =$ $r(a,b,c),$ $s(a,c),$ $t(b),$ $u(b,c)$
joining the four relations depicted in Figure~\ref{fig:acyclic_join}.
As shown in the figure, the only tuple in the join result is 
$(0,2,1)$.
Figure~\ref{fig:trie_acyclic_join}
shows how LFTJ traverses the four relations 
following the global attribute order $a-b-c$ to compute the join result.
First, the algorithm calls $open()$ for $r$ and $s$, since these are the only 
relations containing attribute $a$. 
The iterators of these relations move to nodes carrying 
$0$, which  means that we have a match for the $a$-values 
(second row in Figure~\ref{fig:trie_acyclic_join}).
Next, the algorithm calls $open()$ for $r$, $t$, and $u$, 
since these are the relations that have attribute $b$. 
The current value of the iterator for $r$ becomes $2$ while the current value 
of the iterators for $t$ and $u$ become $0$
(third row in Figure~\ref{fig:trie_acyclic_join}). This means that the $b$-values
do not match yet. Since the largest current $b$-value is $2$, the algorithm calls $seek(2)$ for $t$, which moves the iterator of $t$ to the sibling node with value $2$ (fourth row in Figure~\ref{fig:trie_acyclic_join}).
In this situation, the $b$-values
still do not match and the largest current $b$-value is $2$. 
The algorithm calls $seek(2)$ for $u$, moving the iterator of $u$ to the sibling node with value $2$ (fifth row in Figure~\ref{fig:trie_acyclic_join}). Now, the iterators of $r$, $t$, and $u$
point to $2$, so the algorithm   
fixes the $b$-value to $2$. Calling $open()$ for
$r$, $s$, and $u$ moves their iterators to child nodes with value $1$.
Hence, the algorithm fixes the $c$-value to $1$ (sixth row in Figure~\ref{fig:trie_acyclic_join}). 
It follows that $(0,2,1)$ constitutes
the first result tuple, which is added to the output. 
After backtracking, the algorithm realizes that there is no further tuple in the 
join result and stops.
\end{example}


\subsection{Leapfrog Triejoin for a Cyclic Query}
\label{sec:lftj_cyclic_query}
The next example illustrates that traditional 
join algorithms are suboptimal 
in the sense that they can produce intermediate results that are larger than the final 
result. In contrast, LFTJ does not produce intermediate results and constructs
one output tuple at a time. The example considers the triangle query 
and showcases a database that  
was used in prior work to demonstrate the suboptimality of traditional 
join algorithms on skewed data~\cite{DBLP:journals/sigmod/NgoRR13}.

\begin{example}
\rm
Consider the triangle query $q(a,b,c)$ $=$ $r(a,b),$ 
$s(a,c),$ $t(b,c)$, which joins the three relations $r$, $s$, and $t$ depicted in Figure~\ref{fig:triangle_join}. 
Each relation has two values of degree $m+1$ and $2m$ values 
of degree $1$. For instance, in relation $r$, each of the values $a_0$ and $b_0$ is paired with $m+1$ distinct values and each of the remaining values is paired with exactly one value.  
Each input relation has $2m + 1$ tuples while  the result (Figure~\ref{fig:triangle_join} right)
has $3m + 1$ tuples. Hence, the size of the result is linear in $m$.


% Figure environment removed 
%


Traditional join algorithms first join  two of the three input relations and then join in the remaining one. 
%The join of any two relations has size quadratic in $m$ and hence requires at least quadratic time to compute. 
Figure~\ref{fig:binary_join} shows the result of 
any pairwise join.
In each case, the result contains $(m+1)^2 + m$ tuples, which 
is quadratic in $m$. This means that any join plan that first joins two of the three input relations needs at least quadratic time, while
the size of the final result is linear in $m$.

% Figure environment removed


LFTJ does not produce any intermediate result
and its computation time is proportional to the size of the final result. 
Figure~\ref{fig:trie_traversal_triangle_join} visualizes how LFTJ 
traverses the three relations following the global attribute order 
$a-b-c$. The last column in the Figure
shows how the join result is produced.  
Just as in Example~\ref{ex:acyclic}, LFTJ uses leapfrog join to compute
the intersection of $a$-values, the intersection of $b$-values in the context of 
a given $a$-value, and the intersection of $c$-values in the context 
of a given $(a,b)$-pair. Hence, in the sequel we focus more on the order in which complete 
result tuples are produced. 



The first result tuple is constructed by fixing the attributes 
$a$, $b$, and $c$ to the values $a_0$, $b_0$, and $c_0$, respectively
(second row in Figure~\ref{fig:trie_traversal_triangle_join}).
The $c$-values in the context of $a_0$ in $s$ and in the context of 
$b_0$ in $t$ are teh same: $c_1, \ldots , c_m$. So, we obtain the result tuples 
$(a_0, b_0, c_1)$, $\ldots$, $(a_0, b_0, c_m)$
(third row in Figure~\ref{fig:trie_traversal_triangle_join}).
The $b$-values in the context of $a_0$ in $r$ are the same as the $b$-values in 
$t$. All $b$-values in $t$ have $c_0$ as a child, which 
is also child of $a_0$ in $s$. 
So, the algorithm produces the result tuples 
$(a_0, b_1, c_0)$, $\ldots$, $(a_0, b_m, c_0)$
(fourth row in Figure~\ref{fig:trie_traversal_triangle_join}).
At this point, all $b$- and $c$-values in the context of $a_0$
are exhausted. The algorithm moves to the next $a$-value $a_1$
in the intersection of the $a$-values in $r$ and $s$. The value 
$b_0$ appears in $t$ and in the context of $a_1$ in $r$. Moreover, 
the value $c_0$ appears in the context of $a_1$ in $s$ and of $b_0$
in $t$. Since this is a match, the algorithm adds $(a_1, b_0, c_0)$
to the output (fifth row in Figure~\ref{fig:trie_traversal_triangle_join}).
Next, the algorithm iterates over the $a$-values $a_2, \ldots, a_m$. 
Each of these values have $b_0$ as child in $r$ and $c_0$ as child in $s$. 
Hence, the algorithm produces the result tuples
$(a_2, b_0, c_0)$, $\ldots$, $(a_m, b_0, c_0)$
(sixth row in Figure~\ref{fig:trie_traversal_triangle_join}).
\end{example}

\color{black}
%\input{sections/LFTJ_strategy_acyclic}
\input{sections/LFTJ_strategy_cyclic}

%\color{red}
\section{LFTJ Implementation in ADOPT}
\label{sec:lftjinadopt}

ADOPT uses a variant of the LFTJ, described in Algorithm~\ref{alg:joinOneCube} at a relatively high level of abstraction. The loop from Lines~10 to 17 iterates over values for the current attribute that satisfy all applicable join predicates. Here, ADOPT uses the LFTJ approach, discussed in the preceding subsections, to efficiently identify the next attribute value that appears in all input relations. As discussed previously, identifying the next value ($v$ in Algorithm~\ref{alg:joinOneCube}) may involve repeated ``seek'' operations on all input relations that contain the current attribute. The LFTJ, as presented so far, focuses on equality join predicates. In addition, ADOPT processes other join predicates by simply skipping to the next attribute value if predicates evaluate to false with the current value. Also, ADOPT only considers values for each attribute that fall within the current target cube (by starting from the lower bound and terminating iterations once seek operations return values above the upper bound). Whenever ADOPT proceeds to a new attribute, it performs the equivalent of the ``open'' operation on all input tables containing the new attribute. Finally, whereas the original LFTJ focuses on set data, ADOPT supports multi-sets by iterating over all tuple combinations having the currently selected combination of values in all join columns (variable $M$ in Algorithm~\ref{alg:joinOneCube}), when updating the query result set (Line~5 in Algorithm~\ref{alg:joinOneCube}).

LFTJ variants generally rely on data structures that enable efficient seek operations. Each table is \emph{logically} organized as a trie, where each level corresponds to one attribute and the order of the levels follows the global attribute order. This logical organization can be supported \emph{physically} by sorted tables as done by ADOPT, B$^+$-trees as in the original LFTJ implementation in LogicBlox~\cite{Aref2015}, or nested hashing~\cite{Freitag2020}. More precisely, assume we want to process the global attribute order $a_1$ to $a_m$. For a specific table, denote by $a_{i_1}$ to $a_{i_n}$ the subset of attributes that appear in that table, in the same order as they appear in the global attribute order. ADOPT sorts the rows in that table according to values for attributes $a_{i_1}$ to $a_{i_n}$, prioritizing attribute values in this order during comparisons (e.g., rows are ordered according to their value for $a_{i_1}$ as first priority, considering the value for $a_{i_2}$ only when comparing rows with the same value for $a_{i_1}$). ADOPT avoids materializing the sorted table but merely stores the ordered row indexes in an integer array of the same length as the table. Since ADOPT is a column store and stores columns as arrays, data access via the row index is efficient. Having sorted rows enables ADOPT to implement seek operations efficiently.

The original LFTJ algorithm assumes that tables have been sorted during pre-processing before run time~\cite{DBLP:conf/icdt/Veldhuizen14}. To try out different global attribute orders, ADOPT may require multiple alternative sort orders for the input relations. Whenever ADOPT selects a global attribute order, it determines which local sort orders are required for each table. If the corresponding order (i.e., the array containing sorted row indexes) is not cached, ADOPT creates the corresponding order at run time. In its caching policy, ADOPT distinguishes tables with and without unary predicates. For tables obtained after applying unary predicates, ADOPT stores associated sort orders only while processing the current query. Note that tables tend to be small after applying unary predicates, making sorting them relatively cheap. Tables without unary predicates tend to be large and sorting is more expensive. Here, ADOPT caches corresponding sort orders beyond the duration of the current query, reusing them for future queries if possible. 

% to support processing with a specific attribute order, ADOPT stores 


% LFTJ requires indices on the input tables for efficient intersection of lists of attribute values expressing multiway joins.

% The original LFTJ uses one single attribute order, which only requires a single index per joined table. As ADOPT explores several attribute orders during the processing of a single query, it may need several sorting orders of the input tables. These sorting orders are supported by lists of pointers to the original tables. An input table  with $n$ join attributes has up to $n!$ sorting orders. Whenever a new attribute order is selected by the reinforcement learning algorithm, ADOPT checks for the presence of the required sorting for each table. Before resuming join execution with the selected order, it first creates the required sorting order.