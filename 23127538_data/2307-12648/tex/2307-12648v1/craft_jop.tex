\section{Crafting a JOP Chain for RISC-V applications}
\label{ref:craft_jop}

As mentioned in Section~\ref{ref:riscv-isa}, we adopted a conservative approach regarding
our selection of registers of interest. We used the same approach regarding their
exploitation: we defined a subset of register of interest to be \emph{reserved registers},
that are used by the attack to store addresses necessary to the continuity of the
attack. These registers are:
\begin{itemize}
  \item \emph{a5}, the gadget dispatcher address (which can consists in one or two
    addresses, depending on the kind if gadget dispatcher);
  \item \emph{a4}, the current entry in the dispatch table.
\end{itemize}

We did not consider in our experiment the possibility to save and restore these
registers' values, so any writing on the registers by any gadget after the gadget
initialization will interrupt the attack. To find a way to save/restore these
registers (either through memory or through direct register copy) would considerably
ease the finding of gadgets and the crafting of the JOP chain.

\subsection{JALR Instruction}

The Jump-And-Link-Register instruction may be generated by the compiler when the
code tries executing a function pointer. The specific case of JALR performed
on a parameter happens when said function pointer was passed to the parent
function through arguments -- in that case, JALR will jump to the address
contained in the related argument. Hence manipulating this argument allows
modifying the execution flow.

For example, a generic comparison function would take as arguments 2 structures
to be compared, and a pointer on a comparison function. The two structures will
occupy registers a0 and a1 (supposing they fit in), and the comparison function
address will be stored in register a2. When calling the comparison function, the
generic comparison function will use a JALR (depending on compiler options) and
branch to register a2, as illustrated in Figure~\ref{fig:jalr}. The generic function
is a good candidate for chaining JOP gadgets, as it allows taking control of
execution flow with the assumption that the arguments are already controlled by
the attacker.

% Figure environment removed

\subsection{Dispatcher Gadget}\label{subsec:dispatcher-gadget}

The dispatcher gadget is an essential part of any JOP attack. Its behaviour is
similar to an instruction pointer, as it allows (1) loading an address in the
dispatch table, (2) jumping to said address and (3) moving to the next gadget
table entry. The dispatch table is typically injected in the application through
through the buffer that was used to initiate the attack. The execution
order of gadgets is generally sequential, but it may be more complex, according
to available dispatcher gadget candidates in the application. In any case, it is
defined by the dispatch table layout which is crafted by the attacker during the
weaponization phase of the attack (as defined in Lockeed Martin cyber kill 
chain\footnote{https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html}).

While its expected behaviour is simple, to find an ideal dispatcher gadget is a
difficult task. In the case of a RISC-V application, the attacker must find the
following pattern:
\begin{itemize}
  \item one instruction to increment a1 (supposing the dispatch table was
    stored there);
  \item one instruction loading a2 from a1 (were a2 will contain the next
    address to be jumped to);
  \item one instruction to perform an indirect jump (JALR) to the address stored
    in a2.
\end{itemize}
While other instructions may be interlacing with the instructions above, they must
not tamper with either a1 or a2 (neither any registers used in further
operations, such as the one containing the address of the gadget dispatcher
itself). While this issue may be solved by using other registers than argument
registers, another solution to address this issue is to use a 2-stage gadget
dispatcher, as proposed by~\cite{joprocket21}. In that case, the
first ``stage'' of the dispatcher gadget is effectively a gadget allowing to parse
the dispatch table (generally by incrementing a pointer), and then branches on the
second stage, which in turn performs a load on the dispatch table current position,
and then branches on this value using the JALR instruction. Figure~\ref{fig:2stages}
illustrates a 2-stage dispatcher gadget on RISC-V.

% Figure environment removed

\subsection{Functional Gadgets}\label{subsec:func-gadgets}

The dispatcher gadget is only useful if it can address the functional gadgets
needed to perform the attack. There are different families of functional gadgets,
as described for ROP attacks by~\cite{bletsch11}:
\begin{itemize}
\item arithmetic and logic gadgets
\item memory access gadgets
\item function call gadgets
\item system call gadgets
\item branching gadgets
\end{itemize}
Even in ROP attacks, one or more gadgets of each of these families need
(e.g. memory access will require a loader and a saver gadget) to be present in
order to achieve Turing-completeness~\cite{Cheng11}.
In the case of JOP attacks were more than one register may be exploited to chain
the gadgets, the number of gadgets needed may increase even further.

Reaching Turing-completeness however, although intellectually satisfying, is
often not needed to perform an actual attack -- hence the question whether 
there is enough functional gadgets available in an application to perform an 
attack is hard to answer, particularly since the attacker may adapt the attack 
to available gadgets. In our experiment we did not aim for Turing-completeness, 
so we did not need all the gadgets types listed above. We needed, and were 
able to find (or rather to generate in our vulnerable application) (1) 
arithmetic gadgets, (2) memory access gagdets and (3) system call gadgets. 

In addition to these functional gagdets, we also needed a initializing gagdet, 
which is a one-shot functional gadget used to configure the registers containing 
the dispatcher gadget and the dispatch table addresses. While it is actually a 
memory access gadget in literature, its specific role makes it unique, as it will 
be the only gadget allowed to write in the reserved registers.

\subsubsection{Arithmetic and logic gadgets}

As suggested by their name, arithmetic and logic gadgets are used to perform
arithmetic and logic operations on registers' values. During our experiment, we
focused on argument registers, thus one needs to find a gadget performing the
needed operations on the current function parameters. An example of an AND operation
executed on arguments of a function is provided in Figure~\ref{fig:andgadget}.

% Figure environment removed

\subsubsection{Memory access gadgets}\label{subsubsec:mem-access-regs}

Memory access gadgets are the most important gadget in any attack scenario -- second only to
system call gadgets. They allow reading and writing values from/into memory, and are always
necessary to parametrize said system calls, but also more generally to access
sensitive data. One simple example is to write in memory the name of a sensitive
file in file system (e.g. /etc/shadow in a Linux context) and then calling the
syscall \emph{open}, allowing tampering of said file (providing the target
application has root privilege) and thus allowing the attacker to modify users'
passwords. 

Memory access gadgets can be found, amongst other places, in functions manipulating
structures. As these structures' size is typically greater than XLEN*2, they are
passed by reference, and then a memory read will be performed. Conversely,
modification on the values of the structure parameters will be performed through memory
writings.

The location of writing and reading depends on the structure address, passed
through a register. Manipulating this register allows arbitrary reading or writing
within the memory (e.g. the dispatch table).

\subsubsection{System call gadgets}

As mentioned in Section~\ref{ref:riscv-syscalls}, system calls following the
RISC-V ABI use argument register a7 to pass the ecall identifier. Since argument
registers are assigned lower index first, finding functions manipulating a7 out of
system libraries is possible, yet very likely to lead to side effects on lower 
argument registers. In our research, we did not found gagdets manipulating a7 
without overwriting one of the reserved registers. Hence performing system calls 
practically means branching into related primitives in system libraries while 
ensuring a configuration of registers that will trigger the kernel action expected 
by the attacker.

Practically, that means we exploit entries into the Procedure Linkage Table (PLT).
This table and related functions are generated by the Linker during the linking
phase and points towards used functions in the libraries linked to the
application. From these addresses, we have an entrypoint to functions of interest
(e.g. open in libc), and then we can jump up to a fixed offset of the function 
with the instruction of interest (in our case, the instruction setting a7), and 
then executing the syscall.
