\section{Bringing JOP to RISC-V}\label{sec:riscv-jop}

\subsection{Attack Surface}

Ability to perform JOP attacks for a given architecture heavily relies on
gadget availability. As such, they represent the attack surface. We used
RaccoonV\footnote{\url{https://github.com/lfalkau/raccoonv}}, an open-source tool 
to search for RISC-V JOP gadgets, to gather statistics about available gadgets 
for some applications. Table~\ref{tab:rvstat} shows the number of available 
gadgets per register in the GNU libc 2.34 compiled for RISC-V 32 bits with M, A 
and C extensions (RV32IMAC).

\begin{table}[tb]
	\begin{center}
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
                Register & \reg{ra} & \reg{e5} & \reg{t1} & \reg{t3} & \reg{tp} & \reg{a4} & \reg{s0} & \reg{s2} & \reg{a2} & \reg{a0} & \reg{sp} & \reg{s1} & \reg{a3} & \reg{t5} & \reg{s8} \\ \hline
		Available gadgets & 4557 & 810 & 318 & 255 & 239 & 184 & 183 & 157 & 147 & 106 & 97 & 86 & 83 & 79 & 68 \\ \hline
	\end{tabular}
	\caption{Gadget availability per register in libc (top 15).}\label{tab:rvstat}
    \vspace{-4mm}
	\end{center}
\end{table}

\subsection{Introducing Autonomous Dispatcher Gadgets}

Table~\ref{tab:rvstat} shows that \reg{ra} and \reg{a5} are the registers of
choice for the dispatcher gadget register using a classic JOP scheme. However,
jumping to \reg{ra} from functional gadgets would trigger shadow stack
detection if implemented. On the other hand, \reg{a5} tends to be used by GCC
when calling function pointers. In our experience, as most dispatcher gadgets
are generated by the call of function pointers in a loop, they already use
\reg{a5} to jump to functional gadgets, making them impractical candidates.
In practice we did not find any suitable combination of reserved
registers allowing to chain system calls in a convenient
way~\cite{gilles2022}.

While searching for more suitable gadgets in RISC-V applications, we found a
new kind of a dispatcher gadget, illustrated in
Figure~\ref{fig:dispatcher_gadget}, that we call an \emph{autonomous dispatcher gadget}
(ADG).

% Figure environment removed

It has two differences from a classical dispatcher gadget. First, the
instruction used to link to functional gadgets is a JALR, instead of a JR. In
order to use such dispatcher gadget without triggering shadow stack detection,
functional gadgets ending with a jump to \reg{ra} now can --- and must ---  be used.
Doing so, each round-trip between the dispatcher gadget and functional gadgets
will correspond to a legit procedure call.
However, when using a JALR instruction to link to functional gadgets, \reg{ra}
will be set to the next instruction in the dispatcher gadget, instead of the
dispatcher gadget address itself. While this would be an issue with a classical
dispatcher gadget, the second difference of the ADG is that it links back to
itself when getting control back, which justifies its name. However, in each ADG we found
or managed to reproduce, this self-linking instruction was conditional. While
the attacker has to ensure the condition remains true in order to preserve the
chain, it is in practice easily feasible as discussed in Section~\ref{sec:experiment}.

\subsubsection{Code pattern}

The first autonomous dispatcher we found was in the GNU libc 2.34, compiled with
the second GCC level of optimization (\textit{-O2}). We also managed to generate
several autonomous dispatcher gadgets with simple and realistic code patterns,
each involving function pointer calls inside a loop. Figure~\ref{fig:adg_code}
is one of them.

% Figure environment removed

\subsubsection{Reserved registers}

In order to craft a JOP attack using an ADG, only one reserved register is
required: the dispatch table register. Indeed, the ADG links back to itself with
a JAL instead of a JALR, which would  require another reserved register as
classic dispatcher gadgets.

As a consequence, the initializer can use any register to jump to the dispatcher
gadget the first time.
The only register it must share with the ADG is the dispatch table register.
Reducing the reserved registers constraint between these two gadgets considerably increases
 the probability to find a compatible pair.

From our experience, generated ADGs often use first available saved registers
(\reg{s0--11}) as the dispatch table register, which is convenient because there
is a good balance of gadgets loading them from the stack (potential initializer
gadgets) and gadgets which do not clobber them, making them compatible
functional gadgets.
