\section{RISC-V attack surface}\label{sec:attack-surface}

JOB attacks rely on the ISA and ABI of the target, and as such they
represent the attack surface of the target.
In this section we present the RISC-V ISA and ABI elements and properties of
interest for the realisation of JOB attacks.

Note that the ABI is purely a convention, i.e. while an application on a RISC-V
processor must follow the RISC-V ISA specificiations, it is not mandatory to
follow any particular ABI.
In this article, we made the hypothesis that the target application binary and
all related software artifacts were generated (e.g. compiled) following the
convention described in Chapter 18 of the RISC-V specification\cite{rvspecs}.

\subsection{ISA: Instruction Set Definition}
\label{ref:riscv-isa}

The RISC-V ISA defines multiple extensions to the base instruction set.
Amongst these extensions, only the Base Integer ISA (RV32I) is mandatory in all
RISC-V implementations. Depending on supported extensions, new registers
will be available (e.g. floating registers). A 16-bits compressed version
of Base Integer ISA is also available. Available registers in the target
architecture will strongly impact its attack surface relatively to JOP
attacks, as more gadgets will be eligible when more registers are present.

In our experiment, we had the most possible conservative approach by only
considering the Base RISC-V ISA and the Base Integer ISA, thus exploiting a
minimal attack surface. Any added extension will increase the likelihood of
finding gadgets within the target application.

\subsection{ISA: Instructions Alignment}

The number of gadgets available is increased if the instructions are not
aligned, since in the latter case, instructions may be loaded after their
intended beginning, and thus interpreted with unintended opcodes and
arguments~\cite{Jaloyan20}. Contrary to CISC architectures such as
x86, RISC-V being a RISC architecture, RISC-V instructions have a fixed size.
However, an extension providing compressed instructions (RV32C and RV64C)
is defined in the standard, although not mandatory. RISC-V implementations
supporting this extension may be target to instruction offset shifting
attacks, where the attacker jumps after the begining of an instruction and
thus execute unintended instructions.

\subsection{ISA: Instructions of Interest}

Designing a JOP attack relies on chaining functional gadgets. This chaining is
performed by using control transfer instructions exploiting registers as jump
target designator. In the RISC-V Base Integer ISA, there is only one instruction
allowing such operation: the Jump-And-Link-Register instruction (JALR), as
illustrated in Figure~\ref{fig:cva6jalr}.

% Figure environment removed

JALR computes the target address for the control transfer by adding a 12-bits
signed immediate to the rs1 register, then setting the least-significant bit
of the result to zero, allowing to reach +/- 2 ko from the source address.
Reachable addresses can be further extended by using the Add Upper Immediate
to PC (AUIPC) instruction, which add 20 bits to the memory, effectively making
all the physical memory addressable with the immediate. In the case of a JOP
attacks, exact addresses of the gadgets are stored into the dispatch table
and loaded directly into \emph{rs1} (one register argument), so immediate is
set to zero and thus no AUIPC instruction is needed by the attacker.

\subsection{ABI: Registers of Interest}

JOP attacks exploit instructions allowing jumping to an address stored within a
register. The Base Integer ISA from RISC-V defines 32 generic registers usable in
user mode:
\begin{itemize}
\item a global pointer addressing different symbols (functions, global variables)
  within the application;
\item a return register containing the return
  address of the last caller function;
\item a stack pointer;
\item a thread pointer;
\item 8 argument registers, used to pass arguments to functions;
\item 6 temporary registers, used to store intermediary results;
\item 12 save registers, used by compiler to otimize access to non-volatile values
  accessed from different functions.
\end{itemize}

Table~\ref{tab:rvabi} shows the registers mnemonics and usage purpose as defined
by the RISC-V specification ABI.
As shown in the table, the ABI states that return, argument and temporary
registers are the only registers saved by caller functions.

% \begin{table}
% % Figure removed
%   \caption{RISC-V registers usage as describe by ABI}\label{tab:rvabi}
% \end{table}

% \begin{table}[h]
%   \scriptsize
%   \begin{center}
%     \begin{tabular}{|p{4em}|p{4em}|p{9.5em}|p{3em}|}
%       \hline
%       Register & ABI Name & Description & Saver \\
%       \hline
%       x0 & zero & Hard-wired zero & --- \\
%       x1 & ra & Return address & Caller \\
%       x2 & sp & Stack pointer & Callee \\
%       x3 & gp & Global pointer & --- \\
%       x4 & tp & Thread pointer & --- \\
%       x5 & t0 & Temporary/alternate link register & Caller \\
%       x6-7 & t1-2 & Temporaries & Caller \\
%       x8 & s0/fp & Saved register/frame pointer & Callee \\
%       x9 & s1 & Saved register & Callee \\
%       x10-11 & a0-1 & Function arguments/return value & Caller \\
%       x12-17 & a2-7 & Function arguments & Caller \\
%       x18-27 & s2-11 & Saved registers & Callee \\
%       x28-31 & t3-6 & Temporaries & Caller \\
%       \hline
%     \end{tabular}
%   \end{center}
%   \caption{RISC-V registers usage as describe by ABI}\label{tab:rvabi}
% \end{table}

\begin{table}[h]
  \scriptsize
  \begin{center}
    \begin{tabular}{|p{4em}|p{3em}|p{9em}|p{3em}|}
      \hline
      Register & ABI Name & Description & Saver \\
      \hline
      x0 & zero & Hard-wired zero & --- \\
      x1 & ra & Return address & Caller \\
      x2 & sp & Stack pointer & Callee \\
      x3 & gp & Global pointer & --- \\
      x4 & tp & Thread pointer & --- \\
      x5 & t0 & Temporary / alternate link register & Caller \\
      x6-7 & t1-2 & Temporaries & Caller \\
      \hline
    \end{tabular}
    \begin{tabular}{|p{4em}|p{3em}|p{9em}|p{3em}|}
      \hline
      Register & ABI Name & Description & Saver \\
      \hline
      x8 & s0/fp & Saved register / frame pointer & Callee \\
      x9 & s1 & Saved register & Callee \\
      x10-11 & a0-1 & Function arguments / return value & Caller \\
      x12-17 & a2-7 & Function arguments & Caller \\
      x18-27 & s2-11 & Saved registers & Callee \\
      x28-31 & t3-6 & Temporaries & Caller \\
      \hline
    \end{tabular}
  \end{center}
  \caption{RISC-V registers usage as describe by ABI}\label{tab:rvabi}
\end{table}

\subsection{ABI: Convention on Function Calls}

Convention on RISC-V function calls favors passing arguments by registers
when possible. Eight integer registers are saved for this purpose in the RV32I.
When no register is available, arguments are stored in the stack.

As mentioned in Section~\ref{introcra}, CRA in general and JOP in particular consist in
using existing functions and system calls within the target application.
Since the behaviour of these functions and system calls is controlled by their
parameters, those will be the favorite targets for an attacker. Two information
in particular are interesting regarding argument passing: (1) assignment of
registers and (2) layout of parameters' values within these registers. In the
next subsections, we use the XLEN term to describe the registers size in bits (32 or 64
according to the RISC-V architecture).

\subsection{ABI: Argument Registers Allocation}

Arguments with a size equal or less than XLEN are assigned to registers
according to their position within the function's signature, e.g. first
argument is assigned to first argument register (a0), second argument is
assigned to second argument register (a1) and so on. Arguments with a size
greater than 2*XLEN are passed by reference (so they occupy a single register).
Finally, arguments with a size greater than XLEN and less or equals to 2*XLEN use
a pair of registers. Hence in the case of manipulation of data belonging to the
latter group (such as \textit{long long} in a RV32I), more arguments
registers than actual arguments will be used. This makes the application more
likely to use upper argument registers. Since the number of argument registers
used in the application is a strong limitation in the attacker ability to find
gadgets due to our approach (see~\ref{ref:craft_jop}), this pattern increases
its vulnerability against JOP.

\subsection{ABI: System Calls}
\label{ref:riscv-syscalls}

In RISC-V system calls are performed through the ecall instruction. Each
system function has an integer identifier allowing identification during the
call. This identifier must be set into the last argument register (a7) before
call execution. If any arguments are necessary to the system call, they must be
passed through the other argument registers (a0-a7).

While it is possible to manipulate a7 to change any syscall to the desired one,
we found that their was not many occurrences of manipulation of a7 outside of
setting of syscalls and without of adversary side-effects on lower argument
registers. Hence, we rather identified within the application the system call
of interest, which was easy in our case, since we target the commonly used
\emph{write} syscall.
