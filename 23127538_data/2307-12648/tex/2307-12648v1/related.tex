\section{Related Work}\label{sec:related}

\subsection{Building JOP Attacks}

Brizendine et al.~\cite{joprocket21} proposed and implemented a method allowing
building JOP gadget chains for the x86 architecture. The method
relies on predefined gagdets of known characteristics, found in Microsoft
Foundation Class (MFC). While this approach can reliably build JOP chains when
known libraries are involved, it implies to update the tool catalog whenever
these libraries are updated, and to perform in-depth analysis of them. 

Other
approaches try to build partial gadget chains by analyzing the whole used
code, binary and libraries~\cite{Vishnyakov21,Nurmukhametov21}. While
some can integrate sub-chains of JOP gagdets within a ROP chain, none of them
can build full JOP chains to our knowledge, making them easily detected by
ROP-targeted countermeasures such as the shadow stack. Other tools able to help
building JOP chains on RISC-V include ROPgadget\footnote{\url{https://github.com/JonathanSalwan/ROPgadget}}
and radare2\footnote{\url{https://github.com/radareorg/radare2}}, which can search JOP
gadgets but not build gadget chains on RISC-V architectures, as they have no method
for discovering dispatcher gadget or initializer gadget. They are primarily designed
to build ROP chains.

Gu et al.~\cite{gu2020riscvrop} identified a specific pattern of instructions
allowing linking functional gadgets in RISC-V architectures, introducing the
concept of ``self-modifying gadget chain'' to save and restore register values in
memory. They also demonstrated the Turing-completeness of their solution. Adapting
self-modifying gadget chain to JOP is indeed a promising solution to increase our
capacity to build effective gadget chains. Jaloyan et al.~\cite{Jaloyan20} reached
the same result by abusing compressed instructions (\emph{overlapping}). Our attack
also uses this approach, and applies it to JOP attacks.

Trampolines-based approaches are somewhat a missing link between ROP and JOP.
A trampoline itself (an update-load-branch suite of instructions) is the 
ancestor of the dispatcher gadget and, instead of exploiting an arbitrary 
memory, uses hardware-maintained registers such as \reg{ra} (return address 
register) to jump to the next functional gadget~\cite{Checkoway10}. While they 
do not rely on return-specific instructions (which do not exist in RISC-V 
anyway), they do imply that large segments of the stack need to be corrupted, 
hence making them vulnerable to stack canaries and the shadow stack. 
Erd\"odi~\cite{Erdodi13} proposed 
a solution to find classical dispatcher gadgets on x86 for different operating
systems. As they are scarce, and trampolines patterns tend to be more common,
the latter are still used~\cite{Sadeghi14}. In addition to providing a solution
in RISC-V architecture for JOP gadget chaining, our discovery of the ADG
greatly increases the number of available JOP gadgets, effectively making them 
as common as ROP gadgets and eliminating the need for trampolines.


\subsection{Defenses from CRA}

Austin et al.~\cite{morpheus21} published the MORPHEUS II solution for RISC-V. This
hardware-based solution aims at defeating memory probes trying to bypass address
randomization by providing a reactive, fine-grain, continuous randomization of
virtual addresses, as well as encryption of pointers and caches. This solution,
while having a low overhead in terms of energy consumption and area, is quite
intrusive in the hardware and may require efforts for certification in critical
applications. While authors make no claim about stopping JOP attacks, probe-resistant
ASLR may be difficult to bypass for an attacker.

Palmiero et al.~\cite{Palmiero18} proposed a hardware-based adaptation of Dynamic
Flow Information Tracking (DIFT) for RISC-V, with the ability to detect most function
pointers overwriting, whether directly or indirectly, and in any memory segment, thus
allowing blocking the attack at its initialization stage. Although this approach seems
indeed powerful, it implies modification of RISC-V instructions behavior in I and M 
extensions for RISC-V 32-bits, as well as in the memory layout (by adding a bit every 
8 bits of memory). Such modifications, in addition to drifting away from the RISC-V 
ABI, are likely to make certification difficult, a serious drawback in critical 
industrial systems. De et al.~\cite{heapsafe22} implemented a chip compliant to RISC-V, including a Rocket Custom Coprocessor (RoCC) which extends the RISC-V ISA with new 
instructions allowing safe operation on the heap. The authors ensure heap size 
integrity and prevent use-after-free attacks, at the cost of an increase of 50\% 
of average execution time on their benchmarks.

