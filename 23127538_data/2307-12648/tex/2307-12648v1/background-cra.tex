\section{Code-Reuse Attacks Overview}\label{sec:background}
%\todonk{relecture NK de la section en cours}

The aim of a \emph{Code-Reuse Attack} (CRA) is to take control of an application
execution through the use of existing code within the target application in
order to perform unintended or malicious actions.

A CRA is not in itself a primary attack, but relies on an earlier memory
corruption allowing to hijack the execution flow. Such vulnerabilities are
well-known, but still prevalent in many systems~\cite{Younan04codeinjection}.
The originality of CRAs comparatively to regular code injection is that, instead
of redirecting the execution flow toward injected code (generally, a shellcode
in a buffer), it redirects the execution toward existing code in the
application in order to obtain a malicious effect. A simple example of such
attacks is return-to-libc~\cite{Solardesigner97}, where the execution flow is
redirected to a single function after manipulation of arguments within the
stack of the corrupted function. More sophisticated attacks with the same
principle of stack corruption have emerged, among which the Return-Oriented
Programming (ROP) technique~\cite{Shacham07,Carlini14}. It consists in chaining
\emph{gadgets}, i.e. code snippets composed of a few instructions and ending with a
linking instruction. In the case of ROP, the linking instruction is a return to a
caller instruction which pops the next gadget address from the corrupted stack,
handing on execution flow to it, and so on. Using this approach, the attacker
can run an arbitrary sequence of legit instructions, effectively running a
malicious action using the target application code.

\subsection{Countermeasures}\label{sec:background:countermeasures}

Multiple methods were proposed and used in order to defend against
return-to-libc and ROP.
Address Space Layout Randomization (ASLR) randomize base addresses of memory
mappings. The attacker needs to guess the address of target function or gadgets.
Stackguard~\cite{Cowan98} introduced the notion of canaries to protect the
integrity of the stack. Yet solutions relying on secrets depend much on the
system entropy, which tends to decline as the system uptime increases --- an
important issue for embedded systems that can run for decades without reboot.
Both ASLR and Stackguard are even weaker on 32-bit
systems~\cite{Shacham05}, and several techniques have been proposed to bypass
them.

Abadi et al.~\cite{abadi05} first formally identified a process property named
\emph{Control-Flow Integrity} (CFI), defined by the adherence of the runtime execution
flow to its intended behavior. In order to ensure this property against
attackers, they proposed two complementary protections: shadow stack and landing
pads\footnote{A specification of shadow stack and landing pads for RISC-V is
currently under ratification~\url{https://github.com/riscv/riscv-cfi/}}.
\emph{Shadow stack} protects backward-edge jumps by pushing procedure return addresses
to a memory protected stack at call time. When a procedure returns,  its return
address is popped from both stacks and compared. If they differ, a memory
corruption is detected.
\emph{Landing pads} are special instructions protecting forward-edge jumps. When
implemented, each jump destination must be one of these instructions. However,
they rely on the compiler generating them, and even if an application is
compiled with them, it can still use shared libraries that do not
use landing pads, effectively loosing benefits for corresponding code.
Nevertheless, these protections make theoretically all kinds of CRA nearly
impossible to implement, and do indeed stop most
return-to-libc and ROP attacks, although often leading to significant fall of 
performances~\cite{Burow17}.


\subsection{Overcoming the Shadow Stack: Jump-Oriented Programming}\label{sec:background:overcoming-shadow-stack}

Much like ROP, JOP consists in assembling \emph{functional gadgets} containing
useful instructions present in the target application in order to perform 
a malicious action. 
However in the case of JOP, the chaining
mechanism must be done by a \emph{dispatcher gadget}. Its role is to load and
jump to the next {functional gadget} from a \emph{dispatch table},
generally injected into a buffer. Each {functional gadget} must then end
with a jump to the {dispatcher gadget}. To do this, at least two registers
need to be reserved: one for the dispatcher gadget and one for the dispatch
table. The \emph{initializer gadget} is responsible to set them to their
respective addresses. Figure~\ref{fig:jop} illustrates this mechanism
with an  example, where  \reg{r1} and \reg{r2} are
reserved registers (respectively, for the dispatch
table and the dispatcher gadget), and \reg{r0} is used to branch to functional gadgets.


% Figure environment removed


Assembling a JOP gadget chain is far more complex than doing so for a ROP gadget
chain for multiple reasons.
First, reserved registers must be set to appropriate values prior to passing
execution flow to the dispatcher gadget. This must be done with another
specialized gadget, which is only executed once, and is referred to as the
\emph{initializer gadget}. The dispatcher and initializer gadgets are thus intimately
tied, as they must work with the same reserved registers. Although the
initializer and dispatcher gadget patterns are quite simple, there are few of
them in practice, and viable combinations of both are even more scarce. In
addition to this difficulty, for any viable pair, there must be enough
compatible functional gadgets, i.e. ending with a jump to the dispatcher gadget
register in order to build the actual attack code. For this reason, the best
dispatcher gadget register is the one for which we find the most functional
gadgets. In practice, most common functional gadgets are procedure epilogues but
using them would trigger shadow stack detection if implemented. Other registers,
e.g. argument registers, are hard to use as reserved registers. Reserving them
would make argument passing complex, reducing the attack effectiveness.
Side-effects in functional gadget must also be considered as they break the
gadget chain management by clobbering the reserved registers.
For these reasons, JOP remains mostly theoretical. The most prominent example
publicly known to this day is a complex rootkit targeting
x86/Linux2.6~\cite{Cheng11}.

Since searching and chaining gadgets is highly dependent on both ISA and 
Application Binary Interface (ABI),
%application binary interface,
its feasibility in new architectures is not proven. In the following sections, we
demonstrate the feasibility of JOP attacks on applications compiled for the
RISC-V architecture, and introduce a new kind of dispatcher gadget enabling the
use of procedure epilogues as functional gadgets without triggering shadow stack
detection, allowing to craft stealth attacks with a greater attack surface.
