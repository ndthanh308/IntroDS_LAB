
We introduced the logical system $\CFP$ by extending $\IFP$ \cite{IFP}
with two propositional operators $\rt{A}{B}$ and $\Set(A)$,
and developed a method for
extracting nondeterministic and concurrent 
programs that are provably total and  satisfy
their specifications. 

While $\IFP$ already imports classical logic through nc-axioms that
need only be true classically, in $\CFP$ the access to classical logic
is considerably widened through the rule (Conc-lem) which,
when interpreting $\rt{A}{B}$ as $A \to B$ and identifying $\Set(A)$ with $A$,
is constructively 
invalid but has nontrivial 
nondeterministic
computational content.


We applied our system to extract a 
concurrent
translation from infinite Gray 
code to the signed digit representation, thus demonstrating that this approach
not only is about program extraction `in principle' but can be used to
solve nontrivial 
concurrent
computation problems through 
program extraction.
%

After an overview of related work, 
we conclude with a brief discussion of further applications of our approach.
%
%conclude with some ideas for follow-up research.

\subsection{Related work}
\label{sub-related}
%
The CSL 2016 paper \cite{BergerCSL16} 
is an early attempt to capture the concurrent execution of partial programs
via program extraction and can be seen as the starting point of our work.
Our main advance, compared to that paper, is the specification of 
globally angelic choice with the help of the new logical connective $B|_A$ 
which allows us to express bounded nondeterminism with complete
control of the number of threads.
In contrast, \cite{BergerCSL16} 
modelled nondeterminism with countably infinite branching,
which is unsuitable or an overkill for most applications. 
Furthermore, our approach has a typing discipline,
and a sound and complete small-step reduction that permits switching 
between global and local nondeterminism (see Section~\ref{sub-local} below).



As for the study of angelic nondeterminism, it is not easy to develop 
a denotational semantics as we noted in Section \ref{sec-ang}, 
and it has been mainly studied from the operational point of view, e.g.,  
notions of equivalence or refinement of processes and associated proof methods,
which are all fundamental for correctness and termination
\cite{LassenMoran99,MoranSandsCarlsson2003,Lassen2006,sabel_schmidt-schauss_2008,CarayolHirschkoffSangiori2005,Levy07}.
%
Regarding imperative languages, Hoare logic and its extensions 
have been applied to nondeterminism and proving totality from the very 
beginning (\cite{Apt2019FiftyYO} is a good survey on this subject).
\cite{Mamouras15} studies angelic nondeterminism with 
an extension of Hoare Logic.
%
In \cite{Geoffroy18} it is shown that nondeterminism can be modelled 
within Krivine's classical realizability~\cite{Krivine03}.


There are many logical approaches to concurrency.
%
For example, Reynolds' separation logic~\cite{Reynolds:2002} has been extended  
to the concurrent and higher-order setting~\cite{OHearn07,Brookes07,Jungetal18},
and there are logics for session types
and process calculi ~\cite{Wadler14a,CairesPfenningToninho16,Kouzapasetal16}
as well as logics based on Avron's hypersequent calculus \cite{AscieriCiabattoniGenco20}, 
which are oriented more towards the 
formulae-as-types/proofs-as-programs~\cite{Howard80,Wadler14} or 
proofs-as-processes paradigm~\cite{Abramsky94}.
Another line of research are process 
algebras~\cite{Milner80,Hoare85,MilnerParrowWalker92} with associated temporal and modal 
logics~\cite{Stirling91},
as well as axiomatic approaches to process algebra~\cite{BergstraKlop89}.
%
In~\cite{SchmidtSchau2020}
a translation of Milner's $\pi$-calculus in a formal model of concurrent Haskell
is provided and proven to be correct. Based on this, we hope to give a similar
correctness proof of the current implementation of our calculus in concurrent Haskell.



The work cited above introduces highly specialized logics and expressive languages that model and reason about concurrent programs with complex communication patterns. While we do not model communication, our approach focuses on a form of choice that can be seen as the formal representation of a race condition, where two threads of a process attempt to modify the same memory cell simultaneously (in our case, the same cell of a stream of digits representing a real number). Race conditions generally lead to unpredictable behavior, so they are typically \emph{avoided} through proper memory access management. In contrast, our work provides a logical framework for the \emph{safe use} of racy programs, an area that has not been fully explored. Additionally, while the cited work is concerned with formal systems for \emph{processes}, our work focuses on the formalization of \emph{abstract mathematics} (e.g., the axiomatic description of real numbers), which connects to concurrency through realizability and program extraction. The result is programs (with a limited form of concurrency) that compute provably correct witnesses for statements in abstract mathematics.



\subsection{Further applications in computable analysis}
\label{sub-analysis}
Our formalization of infinite Gray code in $\CFP$ has been extended 
from real numbers to compact sets of reals~\cite{BergerSpreen23},
building upon a general theory of digital representation 
in compact metric spaces~\cite{BergerSpreen16,Spreen20}.
%
In~\cite{BergerSpreen23} further rules for $\rt{A}{B}$ and $\Set(B)$
are introduced whose realizers are expressed using a generalized case-construct
with overlapping clauses.

Another application in computable analysis is
Gaussian elimination which involves the task of finding
a non-zero entry in a non-singular matrix. 
As shown in~\cite{BergerSeisenbergerSpreenTsuiki22}, 
our approach makes it possible to search for such `pivot elements'
in a concurrent way.


\subsection{Modelling locally angelic choice} 
\label{sub-local}
%
We remarked earlier that our interpretation of $\Amb$ corresponds to
\emph{globally} angelic choice. Surprisingly, \emph{locally} angelic choice
can be modelled by a slight modification of the restriction and 
the total concurrency
operators: Simply replace $A$ by the logically equivalent formula
$A \lor \False$, more precisely, set
%
$\rtp{A}{B} \eqdef \rt{A}{(B\lor\False)}$ and
$\Set'(A) \eqdef \Set(A\lor\False)$.
%
Then the proof rules in 
Section~\ref{sec-cfp}
with $\rt{}{}$ and $\Set$ replaced by $\rtp{}{}$ and
$\Set'$, respectively but without the 
strictness
condition, are theorems of $\CFP$. 
%
To see that the operator $\Set'$ indeed corresponds to locally angelic choice
it is best to compare the realizers of the rule (Conc-mp) for $\Set$ and $\Set'$.
Assume $A$, $B$ are non-Harrop and $f$ is a realizer of $A \to B$.
Then, 
%
if $\Amb(a,b)$ realizes $\Set(A)$, 
then $\Amb(\strictapp{f}{a}, \strictapp{f}{b})$ realizes $\Set(B)$.
This means that to choose, say, the left argument of $\Amb$ as a result,
$a$ must terminate and so must the ambient (global) computation 
$\strictapp{f}{a}$.
%
On the other hand, the program extracted from the proof of (Conc-mp) for
$\Set'$ takes a realizer $\Amb(a,b)$ of $\Set'(A)$ and returns 
$\Amb(\strictapp{(\aup \circ f \circ \adown)}{a}, \strictapp{(\aup \circ f \circ \adown)}{b})$
as realizer of $\Set'(B)$, where $\aup$ and $\adown$ are the realizers of $B \to (B\lor\False)$ and 
$(A \lor\False) \to A$, 
namely,
$\aup \eqdef \lambda a.\, \Left(a)$ and
$\adown \eqdef \lambda c.\, \caseof{c}\{\Left(a) \to a\}$.
%
Now, to choose the left argument of $\Amb$, 
it is enough for $a$ to terminate since the non-strict operation $\aup$
will immediately produce a w.h.n.f. without invoking the ambient computation.
%
%
By redefining realizers of $\rt{A}{B}$ and $\Set(A)$ as realizers of 
$\rtp{A}{B}$ and $\Set'(A)$ and 
the realizers of the rules of $\CFP$ as those extracted from the proofs 
of the corresponding rules for $\rtp{}{}$ and $\Set'$,
we have another realizability interpretation of CFP that models
locally angelic choice.  

\subsection{Markov's principle with restriction}
\label{sub-markov}
%
So far, (Rest-intro) is the only rule that derives a restriction in a 
non-trivial way. 
However, there are other such rules,
for example
%
\begin{center}
\AxiomC{$\forall x \in \NN (P(x) \lor \neg P(x))$}
\RightLabel{Rest-Markov}
\UnaryInfC{$\rt{\exists x \in\NN\,P(x)}{\exists x \in\NN\,P(x)}$}
            \DisplayProof \ \ \ \ 
          \end{center}
%
If $P(x)$ is Harrop, then (Rest-Markov) 
is realized by minimization.
%
More precisely, if $f $ realizes $\forall x \in \NN (P(x) \lor \neg P(x))$,
then $\min(f)$ realizes the formula  
$\rt{\exists x \in\NN\, P(x)}{\exists x \in\NN\,P(x)}$,
where $\min(f)$ computes the least $k \in \NN$ such that $f\, k = \Left$
if such $k$ exists, and does not terminate, otherwise. 
%
One might expect as conclusion of (Rest-Markov) the formula
$\rt{(\neg\neg\exists x \in\NN\,P(x))}{\exists x \in\NN\,P(x)}$.  
However, because of (Rest-stab) (which is realized by the identity), 
this wouldn't make a difference.
%
The rule (Rest-Markov) can be used, for example, to prove that
Harrop predicates that are recursively enumerable (re) and 
have re complements are decidable. 
From the proof one can extract a program 
that 
concurrently searches for evidence of membership in the predicate and
its complement.
%



