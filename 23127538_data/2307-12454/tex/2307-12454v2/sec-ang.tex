



In \cite{McCarthy1963}, 
McCarthy defined 
the ambiguity operator $\amb$ as
\[
\amb(x, y) = \left\{ \begin{array}{ll} x  &(x \ne \bot)\\
                       y & (y \ne \bot) \\
                       \bot & (x =  y = \bot)
                              \end{array}\right.
\]                              
where $\bot$ means `undefined' and the values $x$ and $y$ are taken nondeterministically 
if they
%when both $x$ and $y$ 
are not $\bot$.
%
This is called \emph{locally} angelic nondeterministic choice  
since convergence is chosen over divergence for each local call for 
the computation of $\amb(x, y)$.
It can be implemented by executing both of the arguments
in parallel and taking the result obtained first.  
%
Despite being a simple construction,
$\amb$ is known to have a lot of expressive power, 
and many constructions of nondeterministic and parallel computation 
such as erratic choice, countable choice (random assignment), 
and `parallel or' can be encoded through it \cite{LassenMoran99}.
%
These multifarious aspects of the operator $\amb$ are reflected by 
the difficulty of its mathematical treatment in denotational semantics.
For example, 
$\amb$ is not monotonic when interpreted over powerdomains
with the Egli-Milner order~\cite{Broy1986}.


Alternatively, 
one can consider an interpretation of $\amb$ as  
\emph{globally} angelic choice, where  an argument of $\amb$ 
is chosen so that the whole ambient computation converges 
if convergence 
is possible at all~\cite{ClingerHalpern85,SondergardSestoft92}.
It can be implemented by 
running the {\em whole} computation for both
of the arguments of $\amb$ in parallel and taking the 
result obtained first.
The difference between 
%
the locally and the globally angelic interpretation
%
of $\amb$ 
is highlighted
by the fact that the 
former 
does not commute with function application.
For example, if 
$f(0) = 0$ but $f(1)$ diverges,
then,
with the local interpretation,  
$\amb(f(0), f(1))$ will always terminate with the value $0$, whereas
$f(\amb(0, 1))$ may return 0 or diverge.
On the other hand, 
the latter term will always return $0$ 
if $\amb$ is implemented with a globally angelic semantics.
Though globally angelic choice is not defined compositionally,  
one can, as suggested in \cite{ClingerHalpern85},  
integrate it into the design of a programming 
language by using this commutation property.


%
%
%
%
%
Denotationally, globally angelic choice 
can be modelled by
the Hoare powerdomain construction. 
However, this would not be suitable for analyzing total correctness
  because the ordering of the Hoare powerdomain does 
not discriminate $X$ and $X \cup \{\bot\}$~\cite{HughesM92,HughesO89}.
Instead, we consider a two-staged approach (see~Section~\ref{sub-denot})
and provide a simple denotational semantics for a language with angelic choice.



\subsection{Programs and types}
\label{Sec:2.1}
%
Our target language for program extraction
is an untyped lambda calculus with recursion operator and
constructors as in~\cite{IFP}, but extended by an additional 
constructor $\Amb$ that corresponds to globally angelic version
of McCarthy's $\amb$.
%
This could be easily generalized to 
$\Amb$ operators 
of any arity $\ge 2$.
%
\label{sub-prog}
%
\begin{align*}
&  \mathit{Programs} \owns M,N,L,P, Q,R :: = 
  a, b, \ldots, f, g \ \ \text{(program variables)}\\
&\quad  |\  \lambda a.\,M 
\ | \ M\,N 
\ | \ \strictapp{M}{N} 
\ | \ \rec\,M \ | \  \botexp \\
&\quad |\    \Nil\ | \ \Left(M)\ | \ \Right(M)\ | \ \Pair(M,N) |\ \Amb(M,N)\\
&\quad |\  \caseof{M}\{\Left(a) \to L; \Right(b) \to R\} \\ 
&\quad |\  \caseof{M}\{\Pair(a,b) \to N\} \\
&\quad |\  \caseof{M}\{\Amb(a,b) \to N\}  
\end{align*}
%
Denotationally, $\Amb$ is just another pairing operator. 
Its interpretation as globally angelic choice 
will come to effect only through its operational semantics 
(see Section~\ref{sec-ops}).
Though essentially a call-by-name language, 
it also has strict application $\strictapp{M}{N}$. 

We use $a, \ldots, g$ for program variables to distinguish them from the variables
$x, y, z$ of 
the logical system 
CFP (Section~\ref{sec-cfp}). 
%
$\Nil, \Left, \Right, \Pair, \Amb$ are called \emph{constructors}.
Constructors different from $\Amb$ are called \emph{data constructors} and
$\mathrm{\datacons}$ denotes the set of data constructors.

$\strictapp{\Left}{M}$ stands for $\strictapp{(\lambda a.\Left(a))}{M}$, etc.,
and we sometimes write $\Left$ and $\Right$ for $\Left(\Nil)$ and 
$\Right(\Nil)$.  
%
Natural numbers are
 encoded as $0 \eqdef \Left$,  $1 \eqdef \Right(\Left)$, 
$2 \eqdef \Right(\Right(\Left))$, etc.


%
Although programs are untyped, programs extracted from
proofs will be typable by the following system of 
simple recursive types:
\[
Types \ni \rho, \sigma ::=  \alpha\ (\hbox{type variables})
                         \mid \one  
                         \mid \rho \times \sigma
                         \mid \rho + \sigma
                         \mid \ftyp{\rho}{\sigma}
                         \mid \tfix{\alpha}{\rho}
                         \mid \Am(\rho) 
\]
The intention of $\Am(\rho)$ is to denote the type of
programs which, if they terminate (see Section~\ref{sec-ops}), 
reduce to a form
$\Amb(M, N)$ with $M,N\!:\!\rho$.

To obtain a well-behaved semantics of types (see Section~\ref{sub-denot}) 
we impose restrictions
on the formation of $\tfix{\alpha}{\rho}$ and $\Am(\rho)$:
A type is \emph{regular} if 
(1) for every subtype
$\tfix{\alpha_1}{\ldots\tfix{\alpha_n}{\rho}}$, 
the type $\rho$ has no free occurrence of any $\alpha_i$ in the
left side of a function type and doesn't equal any of the $\alpha_i$,
(2) for every subtype $\Am(\rho)$, $\rho$ is {\em determined}, that is,  % (see below)
$\rho$ is of the form
$\tfix{\alpha_1}{\ldots\tfix{\alpha_n}{\rho'}}$ ($n\ge 0$) where $\rho'$ 
is neither a type variable nor of the form $\Am(\rho'')$.

The restriction 
imposed 
on fixed point types 
$\tfix{\alpha}{\rho}$ ensures
that the (semantics of) the type transformer $\alpha \mapsto \rho$
has a unique fixed point, which is taken as the semantics of $\tfix{\alpha}{\rho}$
(see Section~\ref{sub-denot}).
%The restriction on the formation of $\Am(\rho)$ 
The prohibition of $\Am(\Am(\rho))$
enables the interpretation of $\Amb$ as a bottom-avoiding choice operator
(see the explanation below Corollary~\ref{cor:ddatabot}).
%
An example of a regular type is
\[\nat \eqdef \tfix{\alpha}{\one+\alpha},\]
the type of lazy partial natural numbers. Besides the natural numbers $0,1,2,\ldots$
%(represented in $D$ as described above) 
described as programs above,
this type contains the 
`partial natural numbers' 
$\bot$, $\Right(\bot)$, $\Right(\Right(\bot))$, \ldots, as well as 
their supremum, $\Right(\Right(\ldots)) = \bigsqcup\{\Right^n(\bot) \mid n\in\NN\}$.

\begin{table}
\fbox{\begin{minipage}{\textwidth}
\begin{center}
%
$\Gamma, a:\rho \vdash a:\rho$
\hspace{3em} 
$\Gamma \vdash \Nil:\one$
\hspace{3em}
$\Gamma \vdash \bot:\rho$
\hspace{3em}
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\rho$}
             \UnaryInfC{$\Gamma \vdash \Left(M) : \rho + \sigma$}
            \DisplayProof 
\hspace{3em} 
\AxiomC{$\Gamma\vdash M:\sigma$}
             \UnaryInfC{$\Gamma \vdash \Right(M) : \rho + \sigma$}
            \DisplayProof \ \ \ \ 
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\rho$}
\AxiomC{$\Gamma\vdash N:\sigma$}
             \BinaryInfC{$\Gamma \vdash \Pair(M,N) : \rho\times\sigma$}
            \DisplayProof 
\ \ \ \ \ \ \ \ 
\AxiomC{$\Gamma\vdash M:\rho$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash \Amb(M,N) : \Am(\rho)$}
            \DisplayProof 
%
\\[0.5em]
%
\AxiomC{$\Gamma, a:\rho\vdash M:\sigma$}
             \UnaryInfC{$\Gamma \vdash \lambda a.\,M : \ftyp{\rho}{\sigma}$}
            \DisplayProof 
\ \ \ \ \ \ \ \ \ \ 
\AxiomC{$\Gamma, a:\rho\vdash M\,a:\rho$}
             \UnaryInfC{$\Gamma \vdash \rec\,M : \rho$}
            \DisplayProof 
{($a$ not free in $M$)}
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\ftyp{\rho}{\sigma}$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash M\,N : \sigma$}
            \DisplayProof \ \ \ \ 
\hspace{3em} 
\AxiomC{$\Gamma\vdash M:\ftyp{\rho}{\sigma}$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash \strictapp{M}{N} : \sigma$}
            \DisplayProof \ \ \ \ 
%
\\[0.5em]
%
\AxiomC{$\Gamma \vdash M : \rho[\tfix{\alpha}{\rho}/\alpha]$}
\RightLabel{{}}
             \UnaryInfC{$\Gamma \vdash M : \tfix{\alpha}{\rho}$}
            \DisplayProof 
\hspace{3em} 
\AxiomC{$\Gamma \vdash M : \tfix{\alpha}{\rho}$}
\RightLabel{{}}
             \UnaryInfC{$\Gamma \vdash M : \rho[\tfix{\alpha}{\rho}/\alpha]$}
            \DisplayProof 
%
\\[1em]
%
\AxiomC{$\Gamma \vdash M:\rho + \sigma$\ \ \ \ 
$\Gamma, a:\rho \vdash L:\tau$\ \ \ \ 
$\Gamma, b:\sigma \vdash R:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Left(a) \to L; \Right(b) \to R \} :\tau$}
            \DisplayProof \ \ \ \ 
%
\\[1em]
\AxiomC{$\Gamma \vdash M:\rho\times\sigma$\ \ \ \ 
$\Gamma, a:\rho, b:\sigma \vdash N:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Pair(a, b) \to N\} :\tau$}
            \DisplayProof 
\ \ 
\AxiomC{$\Gamma \vdash M:\Am(\rho)$\ \ \ 
$\Gamma, a,b:\rho \vdash N:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Amb(a, b) \to N\} :\tau$}
            \DisplayProof 
%
%
\end{center}
\end{minipage}
}
\caption{Typing rules}
\label{fig-typing}
\end{table}


The typing rules, listed in Fig.~\ref{fig-typing},
derive sequents of the form $\Gamma\vdash M:\rho$ where
$\Gamma = a_1:\rho_1,\ldots,a_n:\rho_n$ (considered as a set) is
a \emph{typing context} assigning to each variable $a_i$ a unique type $\rho_i$.
If restricted to \emph{regular contexts}, i.e.\ contexts where all types $\rho_i$ are
regular, the rules (which extend the rules given in~\cite{IFP}) 
are valid w.r.t.~the denotational semantics given in Section~\ref{sub-denot}. 
%
Recursive types are equirecursive \cite{Pierce:2002} in the sense that
$\Gamma\vdash M : \tfix{\alpha}{\rho}$ iff
$\Gamma\vdash M : \rho[\tfix{\alpha}{\rho}/\alpha]$.
%
\begin{lem}
\label{lem-typing-subst}
\begin{enumerate}
%
%\item[(-1)]
\item\label{lem-typing-subst-tsubst}
If $\alpha$ occurs free in $\rho$, then $\rho[\sigma/\alpha]$ is regular
iff $\rho$ and $\sigma$ are both regular.
%\item[(0)]
\item\label{lem-typing-subst-reg}
If $\Gamma\vdash M:\rho$ where $\Gamma$ is regular, then $\rho$ is regular.
%\item[(1)]
\item\label{lem-typing-subst-poly}
(Polymorphism) If 
$\Gamma \vdash M:\rho$, 
%and $\alpha$ is not free in $\Gamma$, 
then 
$\Gamma[\sigma/\alpha]\vdash M:\rho[\sigma/\alpha]$ 
for every type $\sigma$.
%\item[(2)]
\item\label{lem-typing-subst-cut}
(Cut)
If $\Gamma,a:\rho\vdash M:\sigma$ and $\Gamma\vdash N:\rho$, then 
$\Gamma\vdash M[N/a] :\sigma$.
\end{enumerate}
%
\end{lem}
\begin{proof}
(\ref{lem-typing-subst-tsubst})
%(-1)
is proved by induction on $\rho$.
The other items are proved by induction on typing derivations.
The easy proofs are omitted.
\end{proof}


As an example of a program consider
%
\begin{equation}
\label{eq-f}
f\eqdef\lambda a.\,\caseof{a} \{\Left(\_)\to\Left;
                                    \Right(\_)\to \bot\}
\end{equation}
%
which implements the function $f$ discussed earlier, i.e.,
$f\,0 = 0$ and $f\,1 = \bot$.
$f$ has type $\ftyp{\nat}{\nat}$. 
%
Since 
$\Amb(0,1)$ has type $\Am(\nat)$,
the application $f\,\Amb(0,1)$ 
is not well-typed. 
Instead, we consider
$\mapamb\,f\,\Amb(0, 1)$
where 
$\mapamb : (\alpha \to \beta) \to \Am(\alpha) \to \Am(\beta)$ 
is defined as
%
\begin{eqnarray*}
\mapamb\eqdef \ \lambda f.\, \lambda c.\ \caseof{c}\,
%\caseof{c}\,
\{\Amb(a,b) \to 
 \Amb(\strictapp{f}{a}, \strictapp{f}{b})\}
\end{eqnarray*}
%

This operator realizes the globally angelic semantics:
$\mapamb\ f\ \Amb(0, 1)$ is reduced to $\Amb(\strictapp{f}{0}, \strictapp{f}{1})$,
 and then $\strictapp{f}{0}$ and $\strictapp{f}{1}$ 
are computed concurrently and 
the whole expression
is reduced to 0, using 
the operational semantics in Section \ref{sec-ops}.
%
In Section~\ref{sec-cfp}, we will introduce a concurrent (or nondeterministic) 
version of Modus Ponens, (Conc-mp), 
which will automatically generate an application of $\mapamb$.
%

\subsection{Denotational semantics}
\label{sub-denot}
%
The denotational semantics has two phases: 
%
\emph{Phase~I} interprets programs in a Scott domain $D$
defined by the 
following
recursive domain equation
%
\[
D = (\Nil + \Left(D) + \Right(D) + \Pair(D\times D) 
    + \Amb(D\times D) + \Fun(D\to D))_\bot \,.
\]  
%
where $+$ and $\times$ denote separated sum and cartesian product,
$D \to D$ is the continuous function space, 
and the operation $\cdot_\bot$ adds a least element $\bot$.
%
We recommend~\cite{GierzHofmannKeimelLawsonMisloveScott03}
as a reference for domain theory and the solution of domain equations.
%
In the following, we will use the fact that $D$ carries the structure
of a partial combinatory algebra
(and hence can interpret the $\lambda$-calculus), and that
continuous functions on $D$ have least fixed points.
We also use that  $D$ is a bounded-complete algebraic
directed-complete partial order with least element $\bot$ and
the set $D_0$ of compact elements of $D$ is countable.
%
Furthermore, there exists a \emph{rank function}, $\rk$, 
which assigns to each element of $D_0$ a natural number capturing
its finite nature. 
One way of defining $\rk(a)$ is as the first stage in the
iterative construction of $D$ (see e.g.~\cite{GierzHofmannKeimelLawsonMisloveScott03})
where $a$ appears. All we need of the rank is that the following two
properties hold for $a\in D_0$ \cite{IFP}:
%
\begin{enumerate}
% 
  %
\item[$\rk 1$]
  If $a$ has the form $C(a_1,\ldots,a_k)$ for a constructor $C$,
  then $a_1,\ldots,a_k$ are compact and $\rk(a) > \rk(a_i)$ $(i \leq k)$.
  % 
\item[$\rk 2$] If $a$ has the form $\Fun(f)$, then 
for every $b\in D$, $f(b)$ is compact with $\rk(a) > \rk(f(b))$ and 
there exists a compact $b_0 \dle b$ such that $\rk(a) > \rk(b_0)$ and $f(b_0)=f(b)$.
%
Moreover, there are finitely many %compacts
$b_1,\ldots b_n\in D_0$ with $\rk(b_i) < \rk(a)$ such that 
$f(b) = \bigsqcup \{f(b_i) | i=1,\ldots n, b_i\dle b\}$.
\end{enumerate}
%
Many facts about compact elements will be proven by induction on their ranks.

Table~\ref{fig-semantics-programs} defines the denotational semantics
of programs 
which interprets 
a program $M$ as an element $\valu{M}{\eta}\in D$
for every environment $\eta$ assigning domain elements to the free variables of $M$. 
Note that $\Amb$ is interpreted (like $\Pair$) as a simple pairing operator.


Types are interpreted as subdomains, i.e.\ as subsets of $D$
that are downward closed and closed under suprema of bounded subsets.
%
To interpret the type constructors we use the following operations
on subsets of $D$: 
%
\begin{eqnarray*}%
X_\bot &\eqdef& X \cup\{\bot\}\\
X+Y &\eqdef& \{\Left(a)\mid a\in X\} \cup 
                           \{\Right(b) \mid b \in Y\}\\ 
X\times Y &\eqdef& \{\Pair(a,b) \mid a\in X, b\in Y \}\\
\ftyp{X}{Y} &\eqdef& \{\Fun(f) \mid f:D\to D\hbox{ continuous, }
                           \forall a\in X (f(a) \in Y) \}\\
\Amb(X,Y) &\eqdef& \{\Amb(a,b) \mid a\in X, b\in Y \}
\end{eqnarray*}
%
Clearly, if $X$ and $Y$ are subdomains of $D$, so are 
$(X+Y)_{\bot}$, $(X\times Y)_{\bot}$, $\Amb(X,Y)_{\bot}$, $(\ftyp{X}{Y})_{\bot}$.
The denotational semantics of types, shown in Table~\ref{fig-semantics-types},
maps every type $\rho$ to a subdomain $\tval{\rho}{\zeta}$ for every environment 
$\zeta$ that assigns subdomains to the free type variables of $\rho$.
%
It is easy to see that the typing rules in Table~\ref{fig-typing} are sound w.r.t.\ 
this semantics.



\begin{table}
\fbox{\small
\begin{minipage}{\textwidth}
\vspace*{-0.2cm}
\begin{eqnarray*}
%
\valu{a}{\eta} &=& \eta(a)\\
%
\valu{\lambda a.\,M}{\eta} &=& \Fun(f)\quad  
  \hbox{where $f(d) = \valu{M}{\eta[a\mapsto d]}$}\\
%
\valu{M\,N}{\eta} &=& f(\valu{N}{\eta})\quad 
                        \hbox{if $\valu{M}{\eta}= \Fun(f)$}\\
%
\valu{\strictapp{M}{N}}{\eta} &=& f(\valu{N}{\eta})\quad 
                        \hbox{if $\valu{M}{\eta}= \Fun(f)$ and $\valu{N}{\eta}\neq\bot$}\\
%
\valu{\rec\,M}{\eta} &=& \hbox{the least fixed point of $f$ if $\valu{M}{\eta}=\Fun(f)$}\\
%
\valu{C(M_1,\ldots,M_k)}{\eta} &=& C(\valu{M_1}{\eta},\ldots,
                                       \valu{M_k}{\eta})
\quad \hbox{($C$ a constructor (including $\Amb$))}\\
%
\valu{\caseof{M}{\vec{Cl}}}{\eta} &=& 
       \valu{K}{\eta[\vec a \mapsto \vec d]} 
       \quad \hbox{if $\valu{M}{\eta} = C(\vec d)$ 
and $C(\vec a) \to K\in\vec{Cl}$}\\
%
\valu{M}{\eta} &=& \bot\ \ 
\hbox{in all other cases, in particular $\valu{\botexp}{\eta} = \bot$}
%
\end{eqnarray*}

\hspace{1cm}${\eta}$ is an environment that assigns elements of $D$ to variables.
%
\end{minipage}
}
\caption{Denotational semantics of programs (Phase I)}
\label{fig-semantics-programs}
\end{table}

\begin{table}
  \fbox{\small
  \begin{minipage}{\textwidth}
\vspace*{-0.2cm}
%
\begin{eqnarray*}
%
\tval{\alpha}{\zeta} &=& \zeta(\alpha),\qquad\\
%
\tval{\one}{\zeta} \ &=&  \ \{\Nil,\bot\},\\
\tval{\tfix{\alpha}{\rho}}{\zeta} &=& 
\bigcap\{\subdom{X} \mid \tval{\rho}{\zeta[\alpha \mapsto X]} \subseteq X \} 
\text{\qquad ($\subdom{X}$ means $X$ is a subdomain of $D$)}\\
%
\tval{\Am(\rho)}{\zeta} &=&
  \Amb(\tval{\rho}{\zeta},\tval{\rho}{\zeta})_\bot \\
\tval{\rho\diamond\sigma}{\zeta} &=& 
(\tval{\rho}{\zeta}\diamond\tval{\sigma}{\zeta})_{\bot}\quad 
(\diamond\in\{+,\times,\ftyp{}{}\})   \end{eqnarray*}                           

\hspace*{1cm}
${\zeta}$ is a type environment that assigns subdomains of $D$ to type variables.
%
\end{minipage}
}
\caption{Denotational semantics of types}
\label{fig-semantics-types}
\end{table}

In \emph{Phase~II} of the denotational semantics we assign to every $a\in D$
a set $\ddata(a)\subseteq D$ 
that reveals the role of $\Amb$ as a choice operator. 
The relation $\ddata(a,d)$, also written 
`$d\in\ddata(a)$',  
is defined (coinductively) as the largest relation satisfying
%
\begin{align}
d \in \ddata(a) \quad \eqnu \quad 
&\exists a',b'\,(a = \Amb(a', b') \land a' \ne \bot \land d \in \ddata(a')) \ \lor \notag\\
&\exists a',b'\,(a = \Amb(a', b') \land b' \ne \bot \land  d \in \ddata(b')) \ \lor \notag\\
&(a = \Amb(\bot, \bot) \land d = \bot) \ \lor \notag\\  
&\bigvee_{C \in \mathrm{\datacons}} 
\exists \vec{a'},\vec{d'}
\left(a =  C(\vec{a'}) \land
d = C(\vec{d'}) \land \bigwedge_i d'_i \in \ddata(a'_i)\right) \ \lor\notag\\
&\exists f\,(a = \Fun(f)  \land d = a )\  \lor\notag\\ 
&(a = d = \bot)\,. \label{e-data} 
\end{align} 
%
Now, every closed program $M$ denotes the set 
$\ddata(\val{M}) \subseteq D$ containing all possible globally 
angelic choices derived from its denotation in $D$.
%
For example, $\ddata(\Amb(0,1)) = \{0,1\}$ and, for $f$ as
defined in~(\ref{eq-f}), we have, as expected,
$\ddata(\mapamb\ f\ \Amb(0, 1)) = \ddata(\Amb(0,\bot)) = \{0\}$. 
%
In Section~\ref{sec-ops} we will define an operational semantics whose fair
execution sequences starting with a regular-typed program 
$M$ compute exactly the elements of $\ddata(\val{M})$.

\begin{rem}
%
In~\cite{IFP} the meaning of the word `data' is different.
There, it means that a domain element has no function component.
Therefore, in $\IFP$, `data' means `no $\Fun$', 
whereas here, it means `no $\Amb$'.
%
\end{rem}


\begin{example}\label{ex:random}
  Let $M = \rec\ \lambda a. \Amb(\Left(\Nil), \Right(a))$. $M$ is a closed program
of type
  $\tfix \alpha \Am(\one + \alpha)$.
  We have $\ddata(\val{M}) = \{0, 1, 2, \ldots,\infty\}$
where $\infty = \Right(\Right(\ldots))$.
Thus, we can express countable choice (random assignment) with $\Amb$.
%
\end{example}

\begin{lem}\label{lem:ddatabot}
%
%If $a\in\rho$ (w.r.t.\ some type environment) 
If $a\in\tval{\rho}{\zeta}$ 
where $\rho$ is a regular
type but not a variable, then the following are equivalent:
  (i) $\bot \in \ddata(a)$;
  (ii) $\{\bot\} = \ddata(a)$;
  (iii) $a \in\{\bot,\Amb(\bot, \bot)\}$.   
\end{lem}
\begin{proof}
%
Obviously (iii) implies (ii), and (ii) implies (i).
Therefore, it suffices to show that (i) implies (iii).
%
By the definition of $\ddata$, 
$\bot \in \ddata(a)$ if and only if $a = \bot$ or ($a = \Amb(a', b')$
  and (($a' \ne \bot$ and $\bot \in \ddata(a')$) or 
      ($b' \ne \bot$ and $\bot \in \ddata(b')$) or $a' = b' = \bot$)).
%
If $a=\bot$, then (iii) holds.
%
If $a=\Amb(a',b')$, then, since $\rho$ is not a variable (but regular),
$\rho$ must be of the form $\tfix{\alpha_1}{\ldots\tfix{\alpha_n}{\Am(\sigma)}}$
where $\sigma$ is determined.  
%
Therefore, $a',b'\in\tval{\sigma}{\zeta'}$ (for some type environment $\zeta'$) and hence 
neither $a'$ nor $b'$ have the form $\Amb(a'', b'')$.  
It follows that,
  $\bot \in \ddata(a')$ if and only if $a' = \bot$, and
  $\bot \in \ddata(b')$ if and only if $b' = \bot$.
  Therefore, (iii) holds.
%
\end{proof}






