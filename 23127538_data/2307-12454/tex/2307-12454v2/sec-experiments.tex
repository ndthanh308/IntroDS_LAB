We describe the Haskell implementation of extracted programs in general,
and the particular extracted program for infinite Gray code conversion in particular.

Since our programming language can be viewed as a fragment of Haskell,  
we can execute the extracted program in Haskell by
implementing the Amb operator with the Haskell concurrency module.
We comment on the essential points of the implementation.
The full code is listed in the appendix.


First, we define the domain $D$ as a Haskell data type: %
\begin{verbatim}
data D = Nil | Le D | Ri D | Pair(D, D) | Fun(D -> D) | Amb(D, D)
\end{verbatim}
The $\ssp$-reduction, which preserves the Phase I denotational semantics and reduces a program to a w.h.n.f. 
with the leftmost outermost reduction strategy,  coincides with reduction in Haskell. 
Thus, we can identify extracted programs with programs of type D that compute 
that phase.
The $\newprintc$ reduction that concurrently calculates the arguments of $\Amb$
can be implemented  with the Haskell concurrency module.   
In \cite{BoisPLT02}, the (locally angelic) amb operator 
was implemented in Glasgow Distributed Haskell (GDH).
Here, we implemented it 
with  the Haskell libraries \verb|Control.Concurrent| and \verb|Control.Exception|
as 
a simple function 
\verb|ambL :: [b] -> IO b|
that concurrently evaluates the elements of a list and writes the 
result first obtained in a mutable variable.

Finally, the function 
\verb|ed :: D -> IO D|  produces an element of  $\ddata(a)$  from $a \in D$
by activating \verb|ambL| for the case of $\Amb(a, b)$.
It corresponds to $\newprintp$-reduction though it computes arguments of 
a pair 
sequentially.
This function is nondeterministic since the result of executing \verb|ed (Amb a b)|
depends on which of the arguments \verb|a,b| delivers a result first.
The set of all possible results of \verb|ed a| corresponds to the set $\ddata(a)$.

We executed the program extracted in Section \ref{sec-gray} with
\verb|ed|. 
As we have noted, the number $0$ has three Gray-codes
(i.e., realizers of $\myG(0)$):  
$a = \bot\!:\!1\!:\!(-1)^\omega$,
$b = 1\!:\!1\!:\!(-1)^\omega$, and 
$c = -1\!:\!1\!:\!(-1)^\omega$.  On the other hand, 
the set of signed digit representations of $0$ is
$A \cup B \cup C$ where
$A = \{0^\omega\}$,
$B = \{0^k\!:\!1\!:\!(-1)^\omega \mid k \geq 0\}$, 
and
$C = \{0^k\!:\!(-1)\!:\!1^\omega \mid k \geq 0\}$, 
i.e.,
$A \cup B \cup C$ is the set of realizers of $\myC(0)$.
One can calculate
$$\gtos (a) = \Amb(\bot, 0\!:\! \Amb(\bot,  0\!:\! \ldots))$$
and $\ddata(\gtos (a)) = A$. Thus 
$\gtos (a)$ is reduced uniquely to $0 \!:\! 0 \!:\! \ldots$
by the operational semantics.
%
On the other hand,  one can calculate $\ddata(\gtos (b)) = A \cup B$ and
$\ddata(\gtos (c)) = A \cup C$.  They are subsets of 
the set of realizers of $\myC(0)$ as Theorem \ref{thm-soundnessII} says, and
$\gtos (b)$ is reduced to an element of $A \cup B$ 
as Theorem \ref{thm-pe} says.

We wrote a program that produces a $\{-1, 1, \bot\}$-sequence 
with the option to control the speed of computation of each digit ($-1$ and $1$). 
Applying this to \texttt{gtos} and then to \texttt{ed} yields the expected results. 
