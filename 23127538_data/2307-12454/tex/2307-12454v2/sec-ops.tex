We define a small-step operational semantics 
that, in the limit, reduces each closed program $M$ nondeterministically
to an element in $\ddata(\val{M})$ (Theorem~\ref{thm:data}). 
If $M$ has a regular type, the converse holds as well: 
For every $d\in\ddata(\val{M})$ there exists
a reduction sequence for $M$ computing $d$ in the limit 
(Theorem~\ref{thm:dataconv}).
If $M$ denotes a compact data, then the limit is obtained 
after finitely many reductions.
%
In the following, all programs and types are assumed to be closed.

\subsection{Reduction to weak head normal form}
%
A program is called a \emph{weak head normal form (w.h.n.f.)} if it
 begins with a constructor 
(including $\Amb$) or has the form $\lambda a. M$, and
called a \emph{deterministic weak head normal form (deterministic w.h.n.f.)} if it is 
a w.h.n.f.\ that does not begin with $\Amb$.
Note that a w.h.n.f.\ (deterministic or not) always has a non-bottom value.
%\mps{\HT{d.w.h.n.f. $\to$ deterministic w.h.n.f.}}

In the first part of Table \ref{table:reduction},
we inductively define a 
small-step leftmost-outermost reduction 
relation $\ssp$ on 
programs.
%
\begin{table}
\fbox{
\begin{minipage}{\textwidth}
\noindent Rules of $\ssp$:  
\medbreak
\begin{quote}
\begin{enumerate}\setlength{\itemsep}{0.2cm}
\setlength{\itemindent}{0.4cm}
  \item[(s-i)] $(\lambda a.\,M)\ N \ssp M[N/a]$
%
\item[(s-ii)] \AxiomC{$M \ssp M'$}
            \UnaryInfC{$M\,N \ssp M'\,N$}
            \DisplayProof 
%
\item[(s-iii)]  $\strictapp{(\lambda a.\,M)}{N} \ssp M[N/a]$ \quad 
if $N$ is a w.h.n.f.

\item[(s-iv)] \AxiomC{$M \ssp M'$}
            \UnaryInfC{$\strictapp{M}{N} \ssp \strictapp{M'}{N}$}   
            \DisplayProof  \quad  
if $N$ is a w.h.n.f.
%
\item[(s-v)]  \AxiomC{$N \ssp N'$}
            \UnaryInfC{$\strictapp{M}{N} \ssp \strictapp{M}{N'}$}
            \DisplayProof 
%
\item[(s-vi)] $\rec\,M \ssp M\,(\rec\,M)$
%
\item[(s-vii)] $\caseof{C(\vec M)} \{\ldots;C(\vec b)\to N;\ldots\}\ssp  N[\vec M/\vec b]$\\
 \hspace*{4cm}($C$ ranges over constructors including $\Amb$)

%
\item[(s-viii)] \AxiomC{$M \ssp M'$}
             \UnaryInfC{$\caseof{M}\{\vec{Cl}\}\ssp 
               \caseof{M'}\{\vec{Cl}\}$}
            \DisplayProof 
%
\item[(s-ix)] $M \ssp \bot$ \quad if $M$ is $\bot$-like (see below)
\end{enumerate}
\end{quote}

\bigskip
\noindent Rules of $\newprintc$:
\begin{quote}
\begin{enumerate}
  \setlength{\itemsep}{0.2cm}
  \setlength{\itemindent}{0.4cm}
  \item[(c-i)] \AxiomC{$M \ssp M' $} 
  \UnaryInfC{$M \newprintc M'$}
  \DisplayProof 
  
  \item[(c-ii)] 
  \AxiomC{$M_1 \ssp M_1'$}  
  \UnaryInfC{$\Amb(M_1,M_2) \newprintc \Amb(M_1',M_2)$}
  \DisplayProof 
  \item[(c-ii')] 
  \AxiomC{$M_2 \ssp M_2'$}  
  \UnaryInfC{$\Amb(M_1,M_2) \newprintc \Amb(M_1,M_2')$}
  \DisplayProof 
  \item[(c-iii)] 
    $\Amb(M_1, M_2) \newprintc M_1$  \ 
  if $M_1$ is a w.h.n.f.
    
  \item[(c-iii')] 
    $\Amb(M_1, M_2) \newprintc M_2$  \ 
  if $M_2$ is a w.h.n.f.
  \end{enumerate}
\end{quote}

\bigskip
\noindent Rules of $\newprintp$:
  \begin{quote}
  \begin{enumerate}    \setlength{\itemsep}{0.2cm}
    \setlength{\itemindent}{0.4cm}
    \item[(p-i)]
    \AxiomC{$M \newprintc M' $} 
    \UnaryInfC{$M \newprintp M'$}
    \DisplayProof 
    %
    \item[(p-ii)]
    \AxiomC{$M_i \newprintp M_i'$ $(i = 1,\ldots, k)$} 
    \UnaryInfC{$C(M_1,\ldots,M_k) \newprintp C(M_1',\ldots,,M_k')$}
    \DisplayProof 
        ($C\in\datacons$)      \\    %
    \item[(p-iii)]
          $\lambda a.\,M \newprintp \lambda a.\,M$ 
  \end{enumerate}
\end{quote}      

\bigskip
$\bot$-like programs are such that their syntactic forms immediately imply that
they denote $\bot$, more precisely they are of the form  $\bot$,
$C(\vec M)\,N$, $\strictapp{C(\vec M)}{N}$, 
and $\caseof{M}\,\{\ldots\}$ where $M$ is a lambda-abstraction or
of the form $C(\vec M)$ such that there is no clause in $\{\ldots\}$ 
which is of the form $C(\vec a) \to N$. 
W.h.n.f.s 
are never $\bot$-like, and the only typable $\bot$-like
program is $\bot$.

\end{minipage}
}
\caption{
Operational semantics of programs
\label{table:reduction}}
\end{table}
%

The following Lemma establishes fundamental properties of the reduction relation $\ssp$.
Part~(5) provides the crucial link to the denotational semantics and lies at the core
of the Adequacy Theorems.
%



\begin{lem}\label{lem:ssp}
\begin{enumerate}
%\item[(1)]
\item\label{lem:ssp:sred}
[Subject reduction] $\ssp$ preserves types  
(i.e., if $M \ssp M'$ and $\Gamma \vdash M:\rho$, then 
$\Gamma \vdash M':\rho$).
%\item[(2)]
\item\label{lem:ssp:det}
$\ssp$ is deterministic (i.e., for every program $M$, $M \ssp M'$ for at most one $M'$).
%\item[(3)]
\item\label{lem:ssp:pres}
$\ssp$ preserves the denotational semantics 
(i.e., 
$\val{M} = \val{M'}$ 
if $M \ssp M'$).
%\item[(4)]
\item\label{lem:ssp:norm}
$M$ is a $\ssp$-normal form iff $M$ is a  
w.h.n.f.  
%\item[(5)]
\item\label{lem:ssp:ade}
[Adequacy Lemma]\label{lem:ade}
  If $\val{M} \ne \bot$, then there is a 
w.h.n.f.~$V$ 
s.t.\ $M \ssp^* V$. 
%\UB{This does NOT hold! (see below)}
\end{enumerate}
\begin{proof}
  (\ref{lem:ssp:sred}) to (\ref{lem:ssp:norm}) are easy.

We sketch the proof of~(\ref{lem:ssp:ade}), which is similar
to the proof of Theorem~11 in \cite{Berger10}.

To every $a\in D_0$ one assigns a set $\cl{a}$ of closed programs,  
by recursion on $\rk(a)$: 
%
\begin{eqnarray*}
%
\cl{\bot} &=& \hbox{the set of all closed programs}\\
%
\cl{C(a_1,\ldots,a_k)} &=& 
 \{M \mid \exists M_1,\ldots,M_k,\,M\ssp^* C(M_1,\ldots,M_k) \land\\
 &&\quad\quad\quad\quad\bigwedge_{i \leq k}M_i\in\cl{a_i}) \}\\
%
\cl{\Fun(f)} &=& \{M\mid \exists x, M',\,(M\ssp^*\lambda x.\,M' \land\\
&&\quad\quad\quad\quad\forall b\in D_0\,(\rk(b) <\rk(\Fun(f))\to\\
&& \quad\quad\quad\quad\quad\forall N\in\cl{b}\,(M'[N/x]\in\cl{f(b)})))\} 
%
\end{eqnarray*}

One can show:
%
\begin{enumerate}[(a)]
%
\item\label{ade-lem-mon}
If $a\dle b$, then $\cl{a}\supseteq\cl{b}$, for all $a,b\in D_0$. \\
% 
(induction on the maximum of $\rk(a)$ and $\rk(b)$)
%
\item\label{ade-lem-whnf}
If $a\in D_0$ is different from $\bot$,
then for every closed program $M$:

$M\in\cl{a}$ iff  $M\ssp^*M'$ for some
w.h.n.f.\ $M'$ with $M'\in\cl{a}$.\\
%
(easy induction on $\rk(a)$ using (\ref{lem:ssp:norm}))
%
\item\label{ade-lem-denot}
If $a \dle \val{M}$, then $M\in\cl{a}$,
for all closed programs $M$ and $a\in D_0$.\\
(one shows by induction on programs $M$, 
and using \ref{ade-lem-mon} and \ref{ade-lem-whnf},
the more general statement:
If $a \dle \valu{M}{\eta}$ where $a\in D_0$, then
$M\theta\in\cl{a}$, provided $\eta(x)\in D_0$ and $\theta(x)$ is closed 
with $\theta(x)\in\cl{\eta(x)}$ for all free variables $x$ of $M$)
%
\end{enumerate} 
%
Now, assume $\val{M}\neq\bot$ where $M$ is a closed program. 
Then $\bot\neq a\dle\val{M}$ for some $a\in D_0$.
By \ref{ade-lem-denot}, $M\in\cl{a}$. 
By \ref{ade-lem-whnf}, $M\ssp^* V$ for some program $V$ in w.h.n.f.



\end{proof}
\end{lem}


\subsection{Making choices}
%
Next, we define the reduction relation $\newprintc$ (`c' for 'choice') 
%
that asynchronously reduces the arguments of $\Amb$, or chooses one
that is in deterministic w.h.n.f.
\ (middle part of Table~\ref{table:reduction}). 
%
This reduction does not preserve the denotational semantics and is not deterministic. Therefore, 
properties corresponding to
Lemma~\ref{lem:ssp}~(\ref{lem:ssp:sred}, \ref{lem:ssp:det}, \ref{lem:ssp:pres})
do not hold. As for (\ref{lem:ssp:norm}), we have
\begin{lem}\label{lem:newprintc}
$M$ is a $\newprintc$-normal form iff $M$ is a  
deterministic w.h.n.f.
%d.w.h.n.f.  
\end{lem}
\begin{proof}
Immediate from 
the definition and Lemma \ref{lem:ssp}(\ref{lem:ssp:norm}).
\end{proof}
A property corresponding to \ref{lem:ssp}~(\ref{lem:ssp:ade}) requires fairness of computation, and
we present it in 
Corollary \ref{cor:ddatabot} for  $\newprintp$.


Finally, we define the reduction relation $\newprintp$ 
(third part of Table~\ref{table:reduction})
which reduces the arguments of the constructor $\Pair$ in parallel 
%synchronously,  
and ensures the reduction of every (closed) program (a property that can be easily proven by structural induction).
For example, $\Nil\newprintp \Nil$ follows from (p-ii).
This organization of the operational semantics secures adequacy w.r.t.\ 
the denotational semantics in Section \ref{sec:adequacy}.
For a practical implementation, one might prefer a sequential version of (p-ii) and remove (p-iii) as discussed in the appendix.


%
We call a $\newprintp$-reduction sequence 
\emph{unfair} if, intuitively, from some point on, one side of an 
$\Amb$ term is permanently reduced but not the other. 
More precisely, we inductively  define 
$M_0\newprintp M_1 \newprintp \ldots$ to be unfair if
\begin{itemize}
%
\item each $M_i$ is of the form $\Amb(L_i,R)$ (with fixed $R$) 
and $L_i \ssp L_{i+1}$, or  
%
\item each $M_i$ is of the form $\Amb(L,R_i)$ (with fixed $L$) and
$R_i \ssp R_{i+1}$, or   
%
\item each $M_i$ is of the form $C(N_{i,1},\ldots,N_{i,n})$ 
(with a fixed $n$-ary data constructor $C$) and $N_{1,k} \newprintp N_{2,k}\newprintp \ldots$
is unfair for some $k$, or
%
\item the tail of the sequence, $M_2\newprintp M_3\ldots$, is unfair.
%
\end{itemize}
%
A $\newprintp$-reduction sequence is \emph{fair} if it is not unfair.




A {\em computation} of $M$ is an infinite fair sequence 
$M = M_0 \newprintp M_1 \newprintp \ldots$  
Intuitively,  
computation proceeds as follows:
A program $L$ is head reduced by $\ssp$ to a 
w.h.n.f.\ $L'$, 
and
if $L'$ is a data constructor term, all arguments are reduced in parallel by (p-ii).
If $L'$ has the form $\Amb(M, N)$, 
two concurrent threads 
are invoked for the reductions of $M$ and $N$ in parallel, 
and the one reduced to a 
w.h.n.f.\ first is used. 
%
Fairness corresponds to the requirement 
%\mps{\HT {fact}}
that the `speed' of each thread is positive
which means, in particular, that no thread can block another.
%
Note that $\newprintc$ is not used for the reductions of 
$M$ and $N$ in (s-ii), (s-iv), (s-v) and (s-viii).
This means that  $\newprintc$ is applied only to the outermost redex.
%
Also, (c-ii) is 
defined through $\ssp$, not $\newprintc$,  and thus no thread creates new threads.
%
%This ability to limit the bound of threads was not available
This ability to control the number of threads was not available
in an earlier version of this language~\cite{BergerCSL16}
(see also the discussion in Section~\ref{sub-related}).
%


\subsection{Computational adequacy:
  Matching denotational and operational semantics}\label{sec:adequacy}
We define 
${M}_{{D}} \in {D}$ by structural induction on programs:
%
\begin{align*}
{C(M_1,\ldots,M_k)}_{D} &= C({M_1}_{D},\ldots, {M_k}_{D})
&  \hbox{($C\in\datacons$)}\\
{(\lambda a. M) }_{D} &= \val{\lambda a. M}   \\
{M}_{D} &= \bot  & \mbox{otherwise}
\end{align*}
Since clearly $M \newprintp N$ implies $M_{D} \sqsubseteq_{D} N_{D}$,
for every computation sequence $ M_0 \newprintp M_1 \newprintp  \ldots$,  
  the sequence $((M_i)_{D})_{i \in \NN}$ is increasing and therefore
  has a least upper bound in $D$. %
Intuitively, $M_{D}$ is the part of $M$ that has been fully evaluated to a data.

%
\begin{thm}[Computational Adequacy: Soundness]
\label{thm:data}
For every computation  $M =  M_0 \newprintp M_1 \newprintp  \ldots$, 
$\sqcup_{i \in \NN} (M_i)_{D} \in \ddata(\val{M})$. 
%
\begin{proof}
In the proof we will use the principle of coinduction for the binary predicate 
$\ddata$ 
which was defined coinductively in (\ref{e-data}). 
In general, for a coinductive predicate
$Q(\vec x) \eqnu \Phi(Q)(\vec x)$ 
and any predicate $P$ of the same arity, one can prove
$P\subseteq Q$ by coinduction
by proving 
$P\subseteq \Phi(P)$.
This proof principle is formalized in IFP/CFP
(last rule in Table~\ref{table-proof-ifp} in Section~\ref{sec-cfp}).
Here, we apply it on the meta-level. 

  Set $P(a, d) \eqdef d = \sqcup_{i \in \NN} (M_i)_D$ for some
  computation
    $M_0 \newprintp M_1 \newprintp\ldots$ with $a = \val{M_0}$.
     We show $P\subseteq\ddata$, that is, 
$P(a, d) \to d \in \ddata(a)$, 
by coinduction.
    Therefore, we have to show $P(a, d) \to \Phi(P)(a, d)$ where
   $\Phi(P)(a,d)$ is obtained by replacing in the right-hand side of 
   (\ref{e-data}), the predicate $\ddata$ by $P$.
     Assume $P(a,d)$, witnessed by the computation, that is, 
  fair reduction sequence 
  $M = M_0 \newprintp M_1 \newprintp \ldots$ with $a = \val{M}$
  and $d = \sqcup_{i \in \NN} (M_i)_{D}$.
   We have to show that at least one of the following six conditions holds:
  \begin{enumerate}
  \item[(1)] $a = \Amb(a', b') \land a' \ne \bot \land P(a',d)$
  \item[(2)] $a = \Amb(a', b') \land b' \ne \bot \land P(b',d)$
  \item[(3)] $a = \Amb(\bot, \bot) \land d = \bot$
  \item[(4)] $ a =  C(\vec{a'}) \land d = C(\vec{d'})\land\bigwedge_i P(a'_i,d'_i)$
 for some data constructor $C$.     \item[(5)] $a = \Fun(f)  \land d = a$
  \item[(6)] $a = d = \bot$
  \end{enumerate}
  %
  Any computation $M = M_0 \newprintp M_1 \newprintp \ldots$ belongs to one the following categories:
  
  Case a: All reductions $M_i \newprintp M_{i+1}$ are (p-i) derived from (c-i):
  That is, $M_0 \ssp M_1 \ssp \ldots$ In this case,  $d = \bot$ and (6) holds by
  Lemma~\ref{lem:ssp} (\ref{lem:ssp:pres}) and (\ref{lem:ssp:ade}).
 
  Case b: For some $n$, $M_i \ssp M_{i+1}$  ($i< n$) and
  $M_i \newprintc M_{i+1}$  ($n \leq i$) by (c-ii) and (c-ii'):
  In this case, $M_i = \Amb(L_i, R_i)$ for $i \geq n$.
  We have $L_i \ssp L_{i+1}$ and $R_i = R_{i+1}$ or 
  $L_i = L_{i+1}$ and $R_i \ssp R_{i+1}$.  
  By fairness, both happen infinitely often and therefore
  (3) holds by Lemma~\ref{lem:ssp}~(\ref{lem:ssp:pres}) and~(\ref{lem:ssp:ade}).
  
  
  Case c:
  $M_i \ssp M_{i+1}$ for $i< n$  and $M_i \newprintp M_{i+1}$ for $i \geq n$ by (p-iii):
  (5) holds by Lemma \ref{lem:ssp}(\ref{lem:ssp:pres}).
  
  
  Case d:
  $M_i \ssp M_{i+1}$ for $i< n$ and $M_i \newprintp M_{i+1}$ for $i \geq n$ by (p-ii):
  $M_{i}$ has the form 
%$C(N_{i,1},\ldots,N_{i,k})$ 
$C(N_{n,1},\ldots,N_{n,k})$ 
for $i \geq n$ 
  and $N_{n,j} \newprintp N_{n+1,j} \newprintp \ldots$ are fair reductions.  In addition, 
  $a = C(\val{N_{i,1}},\ldots,\val{N_{i,k}})$ and 
  $d = C(\sqcup_{i \in \NN} ({N_{i,1}})_D,\ldots, \sqcup_{i \in \NN} (N_{i,k})_D)$.  Therefore, (4) holds.
  
  Case e:
  $M_i \ssp M_{i+1}$ for $i< n$, $M_n = \Amb(L,R)$, 
  $M_{i} \newprintc M_{i+1}$ for $n \leq i< m$ by (c-ii) and (c-ii'),
  $M_{m} \newprintc M_{m+1}$ by (c-iii) or (c-iii'):
  $a = \Amb(a',b')$ with $a' = \val{L}$ and 
  $b' = \val{R}$. $M_m = \Amb(L',R')$.
  If (c-iii) is used, $M_{m+1} = L'$ with 
  $a' = \val{L} = \val{L'} \neq \bot$.
  Since the reduction sequence 
  $M_{m+1} \newprintp M_{m+2} \newprintp \ldots$ is fair again,
  $P(a',d)$ and hence (1) holds.  
  Similarly, (2) holds for the case (c-iii') is used.
    
\end{proof}
    \end{thm}

The converse of Theorem~\ref{thm:data} does not hold in general,
%
i.e.\ $d \in \ddata(\val{M})$ does not necessarily imply
$d = \sqcup_{i \in \NN} ((M_i)_D)$  
for some computation $M=M_0\newprintp M_1\newprintp \ldots$
%
For example, for $M \eqdef \rec\, \lambda\, a.\, \Amb(a,\bot)$
%% %(for which $\val{M} = \val{\Amb(M,\bot)}$)
(for which $\val{M} = \Amb(\val{M},\bot)$)
one sees that $d \in \ddata(\val{M})$ 
for every $d \in D$ (by coinduction).
%
However, clearly $M \newprintp^* N$ iff
$N\in\{M,\Amb(M,\bot),\Amb(\Amb(M,\bot),\bot)\}$.
Hence, $N_D=\bot$ for all such $N$.
%
But $M$ has the type $\tfix{\alpha}{\Am(\alpha)}$ which is not
regular (see Section~\ref{sub-prog}). 
For programs of a regular type, 
the converse of Theorem~\ref{thm:data} does hold. 

\begin{thm}[Computational Adequacy: Completeness]
\label{thm:dataconv}
%If $M$ is a member of a regular type,
If $M$ has a regular type, 
then for every $d \in \ddata(\val{M})$, there is a computation 
$M = M_0 \newprintp M_1 \newprintp \ldots$ with
$d = \sqcup_{i \in \NN} ((M_i)_{D})$.
%\end{thm}
%
\begin{proof}
 %
  The key to the proof of the theorem is the following
  
%  \begin{quote}
%  \emph{Claim.}
\paragraph{Claim.}
    Let $e$ be a 
    compact
  element of $D$.
  If $M$ is a 
    program 
  with $M : \rho$ for some 
    regular
    type $\rho$,
  $d \in \ddata(\val{M})$ and $e \sqsubseteq d$, then there exists 
  $M'$ such that 
  $M \newprintp^* M'$, $d \in \ddata(\val{M'})$, and 
  $e \sqsubseteq M'_{D} \sqsubseteq d$.
%  \end{quote}
  
%  \noindent
%\emph{Proof of the Claim.}
\paragraph{Proof of the Claim.}
  %
%\mps{\UB{The rank is now defined before Lemma 3.1}}
%
Induction on $\rk(e)$.
%
  It is easy to see that the regularity of $\rho$ entails that
  $\tval{\rho}{} = \tval{\Am^k(\sigma)}{}$ 
where $k \in\{0, 1\}$ and  $\sigma$ is neither a fixed point type nor of the form $\Am(\sigma')$.
  
  \emph{Case $e = \bot$}. Then the assertion holds with $M' = M$, 
  since clearly $M_{D} \sqsubseteq d$
  for all $d \in\ddata(\val{M})$ (induction on $M$). 
  
  \emph{Case $e = C(\vec{e'})$.}  Note that
$C \ne \Amb$ because $e \sqsupseteq d$ with $d \in \ddata(\val{M})$. We have 
%$C \ne \Amb$}. \UB{with $C \not\in \{\Amb,\Fun\}$}}. Then 
$d = C(\vec{d'})$ with $d_i' \sqsupseteq e_i'$.
  
  If $k=0$, then $\rho$ %$\tau$ 
is semantically equal to a type of the form 
  $\one$,  $\rho_1+ \rho_2$ or $\rho_1\times\rho_2$,
  and therefore $\val{M}$ has the form $C(\vec{a'})$. 
  By the Adequacy Lemma (Lemma~\ref{lem:ssp}~(\ref{lem:ssp:ade})), 
  $M \ssp^* C(\vec{M'})$ for some $\vec{M'}$
  and $d \in \ddata(\val{M}) = \ddata(C(\vec{\val{M'}}))$.
  Therefore, by the definition of $\ddata$, $d_i' \in \ddata(\val{M'_i})$.  
  Furthermore, by Lemma~\ref{lem:ssp}~(pres), $C(\vec{M'})$ has 
  the same denotation as $M$ and therefore, each $M_i'$ has a denotation
  in some regular type (for example, if $\rho=\rho_1\times\rho_2$, then 
  $M_1':\rho_1$). 
  Since the ranks of the $e_i'$ are smaller than that of $e$, 
  by   induction hypothesis, there exists $\vec{M''}$ such that 
  $M'_i \newprintp^* M''_i$, $d_i' \in \ddata(\val{M''_i})$ 
  and $e_i' \sqsubseteq ({M_i}'')_{D} \sqsubseteq d_i'$.
  Therefore, $C(\vec{M'}) \newprintp^* C(\vec{M''})$ by (p-ii),  
  $d \in \ddata(\val{C(\vec{M''})})$, and
  $e \sqsubseteq C(\vec{M''})_{D} \sqsubseteq d$.
  Since $M \newprintp^* C(\vec{M'})$, we are done.
  

  If $k = 1$,   then $\val{M}$ has the form $\Amb(a', b') $.
  Since $d \sqsupseteq e \ne \bot$, 
    $a' \ne \bot \land d \in \ddata(a')$
  or $b' \ne \bot \land d \in \ddata(b')$.
  %
  By the Adequacy Lemma, $M \ssp^* \Amb(N_1, N_2)$.
  If   $\defined{\val{N_1}} \land d \in \ddata(\val{N_1})$ then 
  $N_1 \ssp^* K$ for some w.h.n.f.\ $K$ and therefore
  $M \newprintc^* K$ by applying (c-i), (c-ii), and (c-iii),
  and thus $M \newprintp^* K$ by (p-i).
  Note that   $K : \Am^{0}(\rho)$ and
  $d \in \ddata(\val{K})$.  Therefore,   there exists $K'$ such that $K \newprintp^* K'$,
  $d \in \ddata(\val{K'})$, and $e \sqsubseteq K'_{D} \sqsubseteq d$.
  Since $M \newprintp^* K'$, we have the result.
  
  \emph{Case $e =\Fun(g)$}. 
  %
  If $k=0$, then $d = \Fun(f)$ and therefore $\val{M} = \Fun(f)$.
  Furthermore, by the Adequacy Lemma, 
  $M \ssp^*M'$ for some $M'$ in w.h.n.f. Since $\val{M'} = \val{M} = \Fun(f)$,
  $M'$ is a $\lambda$-abstraction and hence $M'_{D} = \val{M'}$.
  It follows that $M'_{D} = d$.
  %
  If $k = 1$   the same argument as in the case $e = C(\vec{e'})$ applies. 
  %
  This completes the proof of the Claim.

  
  To prove the Theorem,  
  let $d\in\ddata(\val{M})$.  
Let $d_0 \sqsubseteq d_1 \sqsubseteq \ldots$ 
  be an infinite sequence of 
      compact
    approximations of
    $d$ such that $d = \sqcup_i d_i$.  
    We construct a sequence $(M_i)_{i\in \NN}$ 
    such that $d \in \ddata(\val{M_i})$ and $M_i$ has a regular type as follows.
    Let $M_0 = M$.  By applying the Claim to 
    $d_i$, $d$ and $M_i$, we have $M_{i+1}$ such that $M_i \newprintp^* M_{i+1}$ 
    (hence, by Lemma~\ref{lem:ssp}~(\ref{lem:ssp:sred}),
    $M_{i+1}$ has a regular type as well),
    $d \in \ddata(\val{M_{i+1}})$, and 
    $d_i \sqsubseteq (M_{i+1})_{D} \sqsubseteq d$.
    By concatenating the reduction sequences, we have an infinite sequence
    $M = N_0 \newprintp N_1 \newprintp \ldots$ such that 
   $d = \sqcup_{i \in \NN} ((N_i)_{D})$.
%
\end{proof}
\end{thm}
%



We say that a closed program $M$ is {\em productive} if every computation
$M = M_0 \newprintp M_1 \newprintp \ldots$ produces 
a deterministic w.h.n.f. (i.e., some $M_i$ is a deterministic w.h.n.f).
We consider this property 
a counterpart of termination for a nondeterministic infinite computation.
Therefore, in informal discussions we sometimes call productive programs \emph{terminating}.
%\mps{\HT{How about this?}} 

As a consequence of 
the first Adequacy Theorem and Lemma~\ref{lem:ddatabot} we have: 
%
\begin{thm}\label{cor:ddatabot}
For a closed program $M$ of regular type, the following 
are equivalent.
  \begin{enumerate}
%   \item[(1)] 
   \item\label{cor:ddatabot:prod}
   $M$ is productive.
%   \item[(2)] 
   \item\label{cor:ddatabot:det}
   Some computation $M = M_0 \newprintp M_1 \newprintp \ldots$ 
   produces a deterministic w.h.n.f.
%   \item[(3)] 
   \item\label{cor:ddatabot:bot}
$\val{M}$ is neither $\bot$ nor $\Amb(\bot,\bot)$.
\end{enumerate}
\begin{proof}
  %
%\mps{\HT{a fair ... sequences $\to$ delete a, every sequences $\to$ singular form}
%\UB{done}}
Clearly, every program has a fair $\newprintp$-reduction sequence. 
Therefore, 
(\ref{cor:ddatabot:prod}) implies (\ref{cor:ddatabot:det}). 
  %
  Next, assume 
(\ref{cor:ddatabot:det}). 
%
Then, by Theorem~\ref{thm:data}, $\ddata(\val{M})$ must contain a
  non-bottom element. By Lemma~\ref{lem:ddatabot}, (\ref{cor:ddatabot:bot}) holds.
  %
  Finally, if (\ref{cor:ddatabot:bot}) holds, then by Lemma~\ref{lem:ddatabot}, 
  $\bot\not\in\ddata(\val{M})$.
  Hence, by Theorem~\ref{thm:data},   every $\newprintp$-reduction sequences 
  of $M$ reduces to a deterministic w.h.n.f.
  %
\end{proof}
%  \end{cor}
  \end{thm}
%
The corollary 
does not hold without  the 
regularity
condition.
For example,  $M = \Amb(\Amb(\Nil,\Nil), \Amb(\bot, \bot))$  can be reduced to $M_1 = \Amb(\bot, \bot)$ and then
repeats $M_1$ forever,  whereas it can also be reduced to $\Nil$.
McCarthy's $\amb$ operator is bottom-avoiding
in that when it can terminate, it always terminates.
Corollary~\ref{cor:ddatabot}  guarantees a similar property for our 
globally angelic choice operator $\Amb$.



