As our main case study, we extract a concurrent conversion program between
two representations of real numbers 
in [-1, 1],
the signed digit representation and infinite Gray code.
%




In the following, we also write $d:p$ for $\Pair(d,p)$.

The signed digit representation is an extension of the usual binary expansion
that uses the set $\SD \eqdef \{-1, 0, 1\}$ of \emph{signed digits}. 
The following predicate $\myC(x)$ expresses coinductively
that $x$ has a signed digit representation.
\begin{eqnarray*}
  \myC(x) &\eqnu& |x|\le 1 \land \exists\, d \in \SD\, \myC(2x-d)\,,
\end{eqnarray*}
%Indeed, the formal realizability interpretation of the predicate $\myC$ is
%Its type is $\tau(\myC) = \stream{\tri} \eqdef \tfix{\alpha}{\tri \times \alpha}$
with $\SD(d) \eqdef (d = -1 \lor d = 1) \lor d = 0$.
The type of $\myC$ is $\tau(\myC) = \stream{\tri}$
where $\tri \eqdef (\one + \one) + \one$ and 
$\stream{\rho} \eqdef  \tfix{\alpha}{\rho \times \alpha}$,
and its realizability interpretation is
%
\begin{eqnarray*}
  \ire{p}{\myC(x)} &\eqnu& |x|\le 1\land\exists\, d\in\SD\,\exists p'\ (
  p = d: p'\ \land 
  \ire{p'}{\myC(2x-d)})\, 
\end{eqnarray*}
%
which expresses indeed that $p$ is a signed digit representation of $x$, that is,
%% $p = \Pair(d_0,\Pair(d_1,\ldots$ with
$p = d_0:d_1:\ldots$ with
%
$d_i\in\SD$ and
%
$x = \sum_{i}d_i2^{-(i+1)}$.
%
%We define a concurrent variant of $\myC$ %(\ref{eq:sd})}
Here, we identified the three digits $d = -1, 1, 0$ with their realizers
$\Left(\Left),    \Left(\Right), \Right$.
%which are programs of type $\tri$.


Infinite Gray code (\cite{Gianantonio99,Tsuiki02}) is an almost redundancy free
representation of real numbers in [-1, 1] using the partial digits 
$\{-1,1, \bot\}$. A stream 
%% $p =\Pair(d_0,\Pair(d_1,\ldots$ 
$p =d_0:d_1:\ldots$ 
of such digits
is an infinite Gray code of $x$ iff 
%$d_i = \sg_{\bot}(\tent^{i}(x))$  %sg_{\bot} --> sgb
$d_i = \sgb(\tent^{i}(x))$
 where $\tent$ is the tent function 
$\tent(x) = 1-|2x|$ and $\sgb$ is 
a multi-valued version of the sign function for which 
$\sgb(0)$ is any element of $\{-1, 1,\bot\}$
  (see also Example~\ref{example-ConsSD}).
Clearly,
%One easily sees that
$d_i = \bot$ 
%$\tent^i(x) = 0$ 
for at most one $i$,
%since $\tent(0) = 1$ and $\tent(1)=\tent(-1)=-1$,
after which the sequence continues with $1:(-1)^\omega$.
%
Therefore, 
this coding has 
little 
redundancy in that the
code is uniquely determined and total except for at most one digit
which may be undefined. 
%% (and which may be implemented by a non-terminating program).
Hence, infinite Gray code 
is accessible through concurrent computation with two threads.
%
The coinductive predicate 
\begin{eqnarray*}
%
\myG(x) &\eqnu& |x|\le 1 \land \D(x) \land \myG(\tent(x))\,,
%
\end{eqnarray*}
where $\D$ is the predicate 
$
\D(x) \eqdef  x\neq 0 \to (x\leq 0 \lor x\geq 0)\,
$  
from Example~\ref{ex-d},
expresses that $x$ has an infinite Gray code. 
%(identifying $-1, 1, \bot$ with $\Left, \Right, \bot$).
Indeed,
$\tau(\myG) = \bool^{\omega}$ and
%
\[
\ire{p}{\myG(x)} \eqnu |x|\le 1\land \,\exists d,p'(p = d:p' \land
  (x\neq 0 \to \ire{d}{(x \le 0 \lor x \ge 0)})\ \land 
  \ire{p'}{\myG(\tent(x))})\,.
\]
%
Identifying $\Left, \Right, \bot$ (the range of the variable $d$) with
$-1, 1, \bot$, one sees that the realizer $p$ is indeed a Gray code of $x$.

In \cite{IFP}, 
the inclusion $\myC \subseteq \myG$ was proved in IFP and a sequential conversion
function from signed digit representation to infinite Gray code extracted.
On the other hand, a program producing a signed digit representation from an
infinite Gray code cannot access its input sequentially 
from left to right since it will diverge when it accesses $\bot$.
Therefore, the program needs to evaluate 
two consecutive digits concurrently to obtain at least one
of them. 
With this idea in mind, we define
a concurrent version of $\myC$ as
%(\ref{eq:sd})} 
\begin{eqnarray*}
\myC_2(x) &\eqnu& |x|\le 1 \land \Set(\exists\, d \in \SD\, \myC_2(2x-d)),
\end{eqnarray*}
%$\tau(\SD) = \tri$ and
so that $\tau(\myC_2) = \tfix{\alpha}{\Am(\tri \times \alpha)}$, and
% and extract from the proof a concurrent program 
%that converts infinite Gray code to signed digit representation.
prove $\myG \subseteq \myC_2$ in CFP (Theorem~\ref{thm-g-mc}).
Then we can extract from the proof a concurrent algorithm that 
converts infinite Gray code to signed digit representation.  
%
Note that, while the formula $\myG \subseteq \myC_2$ is \emph{not} admissible,
%(it contains $\Set$ at an F-position), 
the formula $\myC_2(x)$ \emph{is}.
Therefore, if for some real number $x$ we can prove $\myG(x)$,
the proof of $\myG \subseteq \myC_2$ will give us a proof of $\myC_2(x)$ to which
Theorem~\ref{thm-pe} applies. Since $\myC_2(x)^-$ is $\myC(x)$, this means that 
we have a nondeterministic program all whose fair computation paths will result in a
(deterministic) signed digit representation of $x$.


Now we carry out the proof of $\myG \subseteq \myC_2$.
For simplicity, we use 
%% list notation $(a:t)$ for infinite sequences and
%use
pattern matching on constructor expressions for defining functions.  
For example, we write
${\mathsf f}\ (a:t) \eqdef M$
for
${\mathsf f} \eqdef \lambda x.\, \caseof{x}\,\{\Pair(a, t) \to M \}.$

The crucial step in the proof is accomplished by
Example~\ref{example-ConsSD}, since it yields nondeterministic
information about the first digit of the signed digit representation
of $x$, as expressed by the predicate
\[
\ConSD(x)  \eqdef  \Set((x\leq 0 \lor x\geq 0) \lor |x| \leq 1/2).
\]


\begin{lem}
\label{lem-gsd}
%
%$\myG(x) \to \Set(\B(x) \lor \B(\tent(x)))$
%$\forall x\ (\myG(x) \to \Set((x \leq 0 \lor x \geq 0) \lor |x| \leq 1/2))$ .
$\myG \subseteq \ConSD$.
%
\end{lem}
\begin{proof}
$\myG(x)$ implies $\D(x)$ and $\D(\tent(x))$, 
and hence $\ConSD$, by Example~\ref{example-ConsSD}.
\end{proof}
The extracted program $\gscomp:\ftyp{\stream{\bool}}{\Am(\tri)}$  
uses the program $\conSD$ defined in Example~\ref{example-ConsSD}:
$$
\gscomp\ (a:b:p)  \eqdef \conSD\  (\Pair(a, b))\,.
$$

We also need the following closure properties of $\myG$:
%
\begin{lem}
\label{lem-gclosure}
Assume $\myG(x)$. Then:
\begin{itemize}
\item[(1)] $\myG(\tent(x))$, $\myG(|x|)$, and $\myG(-x)$;
\item[(2)] if $x \ge 0$, then $\myG(2x-1)$ and $\myG(1-x)$;
\item[(3)] if $|x|\le 1/2$, then $\myG(2x)$.
\end{itemize}
\end{lem}
%
\begin{proof}
  %
  This follows directly from the definition of $\myG$ and 
  elementary properties
  of the tent function (recall $\tent(x)=1-|2x|$).
  The extracted programs consist of simple manipulations of 
  the given digit stream realizing $\myG(x)$, concerning only its tail and  
  first two digits. No nondeterminism is involved.
  
  %% Here are some more details: By definition of $\myG$, 
  We only use the fixed point property of $\myG$, namely that
  for all $y$,  $\myG(y)$ is equivalent to 
  $|y|\le 1 \land \D(y) \land \myG(\tent(y))$.
  
  This equivalence has computational content which will show up in the programs
  extracted from the proofs below: If it is used from left to right a 
  stream (the realizer of $\myG(y)$) is split into its head (realizer of $\D(y)$)
  and tail (realizer of $\myG(\tent(y))$). Using it
  from right to left corresponds to the converse operation of adding 
  a digit to a stream.
  
  Proofs of (1-3):
  
  (1) follows directly from the equivalence above and the fact that
  $\tent(x)=\tent(-x)$. 
  The three extracted programs are ${\sf f}_1(d:p) = p$, 
  ${\sf f}_2(d:p) = 1:p$, and 
  ${\sf f}_3(p) = \nh\ p$ where $\nh\ (d:p) = \nnot\ d: p$.
  
  (2) Assume in addition $x\ge 0$. Then $\tent(x) = 1 - 2x$. 
  Since $\myG(\tent(x))$ and, by (1), $\myG$ is closed under negation, we have
  $\myG(2x-1)$. 
  %
  Furthermore, since $0 \le 1-x\le 1$ we have $|1-x|\le 1$ and $\D(1-x)$.
  Therefore, to establish $\myG(1-x)$, it suffices to show $\myG(\tent(1-x))$.
  But $\tent(1-x) = 1-2(1-x)= 2x-1$ and we have shown $\myG(2x-1)$ already.
  The extracted programs are ${\sf f}_4(d:p) = \nh\ p$ and 
  ${\sf f}_5(d:p) = 1:\nh\ p$.
  
  
  (3) Now assume $|x|\le 1/2$. Then $1-|2x| \ge 0$ and we have 
  $\myG(1-|2x|)$ (since $\myG(x)$). Therefore, by (2), $\myG(|2x|)$. 
  Hence $\myG(\tent(|2x|))$ and therefore also $\myG(\tent(2x))$ since
  $\tent(2x)=\tent(|2x|)$. Since $|x|\le 1/2$ implies $|2x|\le 1$ and 
  $\myG(x)$ implies $\D(x)$ and hence $\D(2x)$, it follows $\myG(2x)$.
  The extracted program is ${\sf f}_6(d:e:q) = d:\nh\ q$.
\end{proof} 
%
\begin{thm}
\label{thm-g-mc}
%
$\myG\subseteq\myC_2$.
%
\end{thm}
%
\begin{proof}
%
By coinduction. Setting 
$A(x) \eqdef \exists d \in \SD\, \myG(2x-d)$, 
we have to show 
%
\begin{equation}
\label{eq-step}
\myG(x) \to |x| \leq 1 \land \Set(A(x))\,.
\end{equation}
%
Assume $\myG(x)$. 
Then $\ConSD(x)$, by Lemma \ref{lem-gsd}.
Therefore, it suffices to show 
%
\begin{equation}
\label{eq-consd}
\ConSD(x)  \to \Set(A(x))\,
\end{equation} 
which, with the help of the rule (Conc-mp), can be reduced to
%
\begin{equation}
\label{eq-onedigit}
(x \leq 0 \lor x \geq 0 \lor |x| \leq 1/2)   \to A(x).
\end{equation}
%
(\ref{eq-onedigit}) can be easily shown 
using Lemma~\ref{lem-gclosure}:
%
If $x\le 0$, then $\tent(x) = 2x+1$. Since $\myG(\tent(x))$, we have 
$\myG(2x-d)$ for $d=-1$.
%
If $x \ge 0$, then $\myG(2x-d)$ for $d=1$ by (2).
%
If $|x|\le 1/2$, then $\myG(2x-d)$ for $d=0$ by (3).
%
\end{proof}


The program 
$\onedigit : \ftyp{\stream{\bool}}{\ftyp{\tri}{\tri\times\stream{\bool}}}$
extracted from the proof of (\ref{eq-onedigit}) 
from the assumption $\myG(x)$ is
%
\begin{align*}
\onedigit\ (a:b:p)\ c \eqdef 
&  \caseof{c} \{\\
& \hspace{1em} \Left(d) \to 
                       \caseof{d} \{\\
&\hspace{7em} \Left(\_) \to \Pair(-1, b:p); \\
&\hspace{7em}               \Right(\_) \to \Pair(1,(\nnot\ b):p) \};\\
&\hspace{1em}\Right(\_) \to    \Pair(0, a: (\nh\ p))\}\\
\nnot\ a \eqdef& \caseof{a} \{\Left(\_) \to \Right; \\
&\hspace*{4.7em}\Right(\_) \to \Left\}\\
\nh\ (a: p) \eqdef& (\nnot\ a): p
\end{align*}
%
%
This is lifted to a proof of (\ref{eq-consd}) using $\mapamb$ (the realizer of
(Conc-mp)). Hence the extracted realizer 
${\mathsf s} : \ftyp{\stream{\bool}}{\Am(\tri \times \stream{\bool})}$
of~(\ref{eq-step}) is 
\[
{\mathsf s}\ p \eqdef  \mapamb\ (\onedigit\ p)\  (\gscomp\ p)
\]
%
The main program extracted  from the proof of  Theorem~\ref{thm-g-mc} is
obtained from the step function $\mathsf{s}$ by a special form of recursion, 
commonly known as \emph{coiteration}. Formally, we use the realizer of the
coinduction rule $\COIND(\Phi_{\myC_2},\myG)$ where $\Phi_{\myC_2}$ is the operator 
used to define $\myC_2$ as largest fixed point, i.e.\ 
\begin{align*}
\Phi_{\myC_2} &\eqdef \lambda X\,\lambda x\, |x| \leq 1 \land \Set(\exists d \in \SD\, 
       X(2x-d)).
\end{align*}
%
The realizer of coinduction (whose correctness is shown in~\cite{IFP}) 
also uses a program 
$\mon : \ftyp{(\ftyp{\alpha_X}{\alpha_Y})}{\Am(\ftyp{\tri \times \alpha_X)}{\Am(\tri \times \alpha_Y)}}$ 
extracted from the canonical proof of 
the monotonicity of $\Phi_{\myC_2}$:
%
\begin{align*}
&\mon\ f\ p = \mapamb\ (\mon'\ f)\  p\\ 
&\qquad \hbox{where}\quad
\mon'\ f\ (a:t) = a : f\ t
\end{align*}
%
Putting everything together, we obtain the 
\emph{infinite Gray code to signed digit representation conversion program} 
%
\[\gtos : \ftyp{\stream{\bool}}{\tfix{\alpha}{\Am(\tri \times \alpha)}}, 
\quad\gtos \eqrec (\mon\ \gtos) \circ \mathsf{s}\]
%
\begin{picture}(80,75)(-80,5)                                      
\put(20,60){$\stream{\bool}$}
\put(65,61){$\Longrightarrow$}
\put(64,70){$\gtos$}
\put(120,60){$\tfix{\alpha}{\Am(\tri \times \alpha)}$}
\put(24,40){$\Big\Downarrow$}
\put(15,40){$\mathsf{s}$}
\put(130,40){$\rotatebox{90}{=}$ % $=$
}
\put(0,13){$\Am(\tri \times \stream{\bool})$}
\put(58,25){$\mon\ \gtos$}
\put(65,13){$\Longrightarrow$}
\put(110,13){$\Am(\tri \times (\tfix{\alpha}{\Am(\tri \times \alpha)}))$}
\end{picture} 
%\caption{}
%\end{figure}
%\end{center}


Using the equational theory of RCFP,
one can simplify $\gtos$ to the following program.
%
The soundness of RIFP axioms with respect to the denotational semantics and the
adequacy property of our language guarantees that these two programs are equivalent.
%
\begin{align*}
  \gtos\ &(a:b:t) =\Amb(\\
  &\ \ (\caseof{a} \{\Left(\_) \to  -1: \gtos\ (b:t);\\
  &\ \ \hspace*{1.7cm}                   \Right(\_) \to  1: \gtos((\nnot\ b):t)\}),\\
  &\ \        (\caseof{b} \{\Right(\_) \to  0: \gtos(a:(\nh\ t))\})).\\
  &\ \   \hspace*{1.7cm}      \Left(\_) \to  \bot\})).
  \end{align*}
In \cite{Tsuiki05}, a Gray-code to signed digit conversion program was written
with the locally angelic $\Amb$ operator
that evaluates the first two cells $a$ and $b$  in parallel and continues the computation based
on the value obtained first.  In that program,  if the value of $b$ is first obtained and 
it is $\Left$, then it has to evaluate $a$ again.   With globally angelic choice, as the above program shows, 
one can simply neglect the value %and sleep 
to use the value of the other thread.  
%\mps{\HT{Skipped ``Note that this program come up through this logical study of nondeterminism.''}}
%Note that this program come up through this logical study of nondeterminism.
Globally angelic choice also has the possibility to speed up the computation  if 
the two threads of $\Amb$ are computed in parallel and 
the {\em whole} computation based on the secondly-obtained value of $\Amb$ terminates first.













