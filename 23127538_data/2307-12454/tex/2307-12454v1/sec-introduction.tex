
%
Nondeterministic bottom-avoiding choice is an important and useful idea. 
With the wide-spread use of hardware supporting parallel computation,
it 
can speed up practical computation and, at the same time,
%it is related
relates 
to computation over mathematical structures like real 
numbers~\cite{Escardo96,Tsuiki02}.
On the other hand, it is not easy to apply 
theoretical tools like denotational semantics to nondeterministic bottom-avoiding choice~\cite{HughesO89,Levy07}, and guaranteeing 
correctness and totality of such programs 
%through logical systems 
is a difficult task.
% and to our knowledge, not much work has been done in this direction.
% 

To explain the subtleties of the problem, let us start with an example.
%
Suppose that $M$ and $N$ are partial programs that,  
under the conditions $A$ and $\neg A$, respectively, 
are guaranteed to terminate and produce values satisfying specification $B$. 
Then, by executing $M$ and $N$ in parallel 
and taking the result 
%obtained
returned
first, we should always obtain a result satisfying $B$. 
This kind of bottom-avoiding nondeterministic program
is known as \emph{McCarthy's amb (ambiguous) operator} \cite{McCarthy1963}, and 
we denote such a program by  $\Amb(M, N)$.
$\Amb$ is called the angelic choice operator and
is usually studied as one of the three 
nondeterministic choice operators (the other two are erratic choice and demonic choice).



If one tries to formalize this idea naively, one will face some 
obstacles.  
Let $\ire{M}{B}$ (``$M$ realizes $B$'') denote the fact 
that a program $M$ satisfies a specification $B$ and 
let $\Set(B)$ be the specification that can be satisfied by 
a concurrent program of the form $\Amb(M, N)$ that  always terminates and 
produces a value satisfying $B$.  
Then, the above inference could be written as
\[
  \infer[\hbox{}]{
  \ire{\Amb(M, N)} \Set(B)
}{
A \to (\ire{M}{B})  \ \ \ \     \neg A \to (\ire{N}{B}) 
}
\]
%
However, this inference is not sound for the following reason.
Suppose that $A$ does not hold, that is, $\neg A$ holds. 
Then, the execution of $N$ will produce a
value %following refereee A's suggestion
%data 
satisfying $B$. But the execution of $M$ may terminate as well, and
with a data that does not satisfy $B$ since there is no condition on $M$
if $A$ does not hold.
Therefore,  if $M$ terminates first in the execution of $\Amb(M, N)$, 
%then 
we obtain a result that may not satisfy $B$.

To amend this problem, we add a new operator $\rt{A}{B}$ 
(pronounced ``$B$ restricted to $A$'')
%(pronounced ``$A$ restricts $B$'')
and consider the rule
\begin{equation}\label{eq0}
  \infer[\hbox{}]{
  \ire{\Amb(M, N)} \Set(B)
}{
\ire{M}{(\rt{A}{B})}\ \ \ \  \ire{N}{(\rt{\neg A}{B})}}
\end{equation}

Intuitively, $\ire{M}{(\rt{A}{B})}$ means  two things:
%(1) $M$ terminates if $A$ holds, and
(1) If $A$ holds, then $M$ terminates, and
(2) if 
%% the execution of 
$M$ terminates, then the result satisfies $B$,
even for the case $A$ does not hold.
As we will see in Section~\ref{sub-conc}, 
the above rule is derivable in classical logic
and can therefore be used to prove total correctness of Amb programs.

In this paper, we go 
a step further and
introduce a logical system $\CFP$ whose formulas
can be interpreted as specifications of 
%concurrent and 
nondeterministic programs
although they do not talk about programs explicitly.
%instead of proving correctness of a program given a program and a specification, 
$\CFP$ is defined by adding the two logical operators $\rt{A}{B}$ and 
$\Set(B)$ to the system $\IFP$, 
a logic for program extraction~\cite{IFP} 
(see also \cite{Berger11,SeisenBerger12,BergerPetrovska18}). 
$\IFP$ supports the extraction of lazy functional programs 
from inductive/coinductive proofs in intuitionistic first-order logic.
It has a prototype implementation in Haskell,
called Prawf \cite{DBLP:conf/cie/0001PT20}.
A related approach
has been developed in the
 proof system Minlog~\cite{SchwichtenbergMinlog06,BergerMiyamotoSchwichtenbergSeisenberger11,SchwichtenbergWainer12}.
 
We show that from a $\CFP$-proof of a formula, both
a program and a proof that the program
satisfies the specification can be extracted
(Soundness theorem, Theorem \ref{thm-soundnessI}). 
For example, in $\CFP$ we have the rule 
 \begin{equation}\label{eq00}
   \infer[\hbox{(Conc-lem)}]{
   \Set(B)
 }{
 \rt{A}{B}\ \ \ \    \rt{\neg A}{B}}
  \end{equation}
which is realized by the program %$\lambda a_0. \lambda b. \Amb(b, c)$ is extracted
  $\lambda a. \lambda b. \Amb(a, b)$,
  and whose correctness is expressed by the rule (\ref{eq0}).
Programs extracted from $\CFP$ proofs can be  
executed in Haskell,
implementing $\Amb$
%% with the Amb operator implemented
with  %primitives of 
the concurrent Haskell package.

 
Compared with program verification, the
%% Compared with proving properties of programs, this 
extraction approach has the benefit that 
%
(a) the proofs 
programs are extracted from 
take place in a formal system
that is of a very high level of abstraction and therefore is simpler and
easier to use than a logic that formalizes concurrent programs
(in particular, programs do not have to be written manually at all);
%
(b) not only the complete extracted program is proven correct but also
all its sub-programs come with their specifications and correctness proofs
since these correspond to sub-proofs. This makes it easier to locally
modify programs without the danger of compromising overall correctness.

%We extract, as a case study,  a concurrent 
%As a case study, 
As an application,
we extract a nondeterministic 
program that converts 
infinite Gray code to signed digit representation, where 
infinite Gray code is a 
coding of real numbers by partial digit streams
that are allowed to contain a $\bot$, that is, a digit
whose computation does not terminate~\cite{Gianantonio99,Tsuiki02}. 
Partiality and multi-valuedness are common phenomena in computable analysis 
and exact real number computation~\cite{Weihrauch00,LUCKHARDT1977321}.
This case study connects these two aspects through a nondeterministic and
concurrent program whose correctness is guaranteed by a CFP-proof. % with axioms for real numbers. 
The extracted Haskell programs are listed in the Appendix, and are also 
available in the repository~\cite{githubUB}.   

% 
Organization of the paper: 
In Sections~\ref{sec-ang} and~\ref{sec-ops}
we present the denotational and operational semantics of a functional 
%% programming 
language with $\Amb$ and prove that they match 
(Thorems.~\ref{thm:data} and~\ref{thm:dataconv}).
Sections~\ref{sec-cfp} and~\ref{sec-pe} describe the formal system $\CFP$ 
and its realizability interpretation 
%on which our program extraction method is based 
which our program extraction method is based on 
(Theorems~\ref{thm-soundnessI},~\ref{thm-soundnessII}, and~\ref{thm-pe}).
In Sections~\ref{sec-gray} we extract
%%, as a case study, 
a concurrent program that converts 
representations
 of real numbers 
and study its behaviour in Section~\ref{sec-experiments}.






