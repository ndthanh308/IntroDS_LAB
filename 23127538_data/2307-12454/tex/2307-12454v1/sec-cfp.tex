In \cite{IFP}, the system $\IFP$ (Intuitionistic Fixed Point Logic) was
introduced.
$\IFP$ is an intuitionistic first-order logic with strictly positive 
inductive and coinductive definitions, from the proofs of which programs 
can be extracted.
%
The system $\CFP$ 
%% \HT{(Concurrent Fixed Point Logic)}
is obtained by adding to $\IFP$ two propositional
operators, $\rt{A}{B}$ and $\Set(B)$, that facilitate the extraction of 
nondeterministic and concurrent 
programs. 
In this section, we introduce CFP after a short overview of IFP.


\subsection{IFP}
\label{sub-IFP}
%
\paragraph{Language.}
The system $\IFP$ is defined relative to a
many-sorted first-order language. 
IFP expressions consist of formulas, predicates, and operators. 
%(determining sorts, terms, and predicate constants).
%
$\IFP$ Formulas 
have the form 
$A \land B$,  $A \lor B$, $A \to B$,  
$\forall x\, A$, $\exists x\, A$, 
$s = t$ ($s$, $t$ terms of the same sort), 
$P(\vec t)$ (for a predicate $P$ and terms $\vec t$ of fitting arities).
%as well as $\rt{A}{B}$ (restriction) and $\Set(B)$ (concurrency).
%
Predicates are either predicate constants (as given by the first-order language),
or predicate variables (denoted $X,Y,\ldots$), 
or comprehensions $\lambda\vec x\,A$ (where $A$ is a formula and $\vec x$ 
is a tuple of first-order variables), 
or fixed points $\mu(\Phi)$ and $\nu(\Phi)$
%first-order variables, \HT{or fixed points}), 
(least fixed point aka inductive predicate 
and greatest fixed point aka coinductive predicate) where $\Phi$ is a
strictly positive (s.p.) operator. 
%
Every term has a fixed sort and every predicate variable has a 
fixed arity which is a tuple of sorts. We usually 
suppress sorts and arities, notationally. 
%
Operators are of the form
$\lambda X\,Q$ where $X$ is a predicate variable and $Q$ is a predicate  
%,   Deleted ","
of the same arity as $X$. 
$\lambda X\,Q$ is s.p.\ if 
%% $Q$ is s.p. in $X$, that is, 
every free occurrence of $X$ in $Q$ 
is at a strictly positive position,
that is, at a position that is not in
the left part of an implication.

%
%
\emph{Notation}: $P(\vec t)$ will also be written $\vec t \in P$, and
if $\Phi$ is 
%% the operator 
$\lambda X\,Q$, then
$\Phi(P)$ stands for $Q[P/X]$.
% (capture avoiding substitution).
Definitions (on the meta level) 
of the form 
$P \eqdef \munu(\Phi)$ 
($\munu\in\{\mu,\nu\}$) 
where $\Phi = \lambda X\,\lambda \vec x\,A$,
will usually be written $P(\vec x) \eqmunu A[P/X]$. 
%will usually be written $P \eqmu \Phi(P)$ and $P \eqnu \Phi(P)$. 
We write $P \subseteq Q$ for 
$\forall \vec{x}\  (P(\vec{x}) \to Q(\vec{x}))$,
  $\forall x \in P\ A$ for $\forall x\  (P(x) \to  A)$, and
  $\exists x \in P\ A$ for $\exists  x\  (P(x) \land  A)$.
$\neg A \eqdef A \to \False$ where $\False\eqdef\mu(\lambda X\, X)$
and $X$ has empty arity (i.e.\ $X$ is a propositional variable). 
We identify $(\lambda\vec x\,A)(\vec t)$ with $A[\vec t/\vec x]$ where
$[\vec t/\vec x]$ means capture avoiding substitution.
%
Formulas are identified with predicates of empty arity. 
Hence, every statement about predicates is also a statement about formulas.

\begin{example}[Inductively defined predicates]
\label{ex-ind}
In our examples and case studies, we work with
an instance of $\IFP$ (and also its extension $\CFP$) 
that contains a sort for real numbers,
whose language includes
constants, operations and relations such as 
$0,1,+,-,*, <, |\cdot|, /$.
 %and assume their expected properties as axioms 
%(expressed as nc-formulas).
In this instance, one can express the predicate 
$\NN(x)$ that $x$ is a natural number inductively as
%
$$\NN(x) \eqmu  x = 0 \lor \NN(x-1) $$
%
which  is shorthand for 
%
$\NN \eqdef \mu(\lambda X\, \lambda x\, (x = 0 \lor X(x-1)))$.
\end{example}


\paragraph{Proofs.}
The proof rules 
of $\IFP$ %\cite{IFP} 
are the 
usual natural deduction rules for 
intuitionistic first-order logic with equality 
plus rules for induction and 
coinduction, as shown in Table~\ref{table-proof-ifp}.
In the last four rules (called closure, induction, coclosure, coinduction),
$\Phi$ is a s.p.\ operator, i.e.\ an abstraction
$\lambda X\,Q$ where $Q$ is a predicate that is strictly positive in the predicate variable $X$.
The application $\Phi(P)$ is defined as $Q[P/X]$. 
The induction rule has a strong and a half strong
variant where the premise is weakened to
$\Phi(P\cap\mu(\Phi))\subseteq P$ respectively $\Phi(P)\cap\mu(\Phi)\subseteq P$.
Similarly, the coinduction rule has a strong and a half strong
variant where the premise is weakened to
$P\subseteq\Phi(P\cup\nu(\Phi))$ respectively $P\subseteq\Phi(P)\cup\nu(\Phi)$.
Logically, these variants are redundant since they 
can be derived form the original versions. However, they can be given
more efficient realizers than those that would be obtained by extraction from 
their derivations (see~\cite{IFP}). 

\begin{table}
%
\fbox{\small
\begin{minipage}{\textwidth}
%
\begin{center}
%
$\Gamma, A \vdash A$
\hspace{3em} 
$\Gamma \vdash A$\quad ($A$ a non computational axiom)
%
\\[1em]
%
$\Gamma \vdash t=t$
\hspace{3em} 
\AxiomC{$\Gamma\vdash A[s/x]$}
\AxiomC{$\Gamma\vdash s=t$}
             \BinaryInfC{$\Gamma \vdash A[t/x]$}
            \DisplayProof 
%
\\[1em]
%
\AxiomC{$\Gamma\vdash A$}
\AxiomC{$\Gamma\vdash B$}
             \BinaryInfC{$\Gamma \vdash A \land B$}
            \DisplayProof 
%
\hspace{2em} 
%
\AxiomC{$\Gamma \vdash A \land B$}
       \UnaryInfC{$\Gamma \vdash A$}
            \DisplayProof 
%
\hspace{2em} 
%
\AxiomC{$\Gamma \vdash A \land B$}
       \UnaryInfC{$\Gamma \vdash B$}
            \DisplayProof 
%
\\[1em]
%
\AxiomC{$\Gamma\vdash A$}
             \UnaryInfC{$\Gamma \vdash A\lor B$}
            \DisplayProof 
\hspace{2em} 
%
\AxiomC{$\Gamma\vdash B$}
             \UnaryInfC{$\Gamma \vdash A\lor B$}
            \DisplayProof %\\[0.5em]
%
\hspace{2em} 
%
\AxiomC{$\Gamma\vdash A \lor B$}%\hspace{-1em}}
\AxiomC{$\Gamma, A\vdash C$}%\hspace{-1em}}
\AxiomC{$\Gamma, B\vdash C$}%\hspace{-1em}}
             \TrinaryInfC{$\Gamma \vdash C$}
            \DisplayProof \ \ \ \ 
%
\\[1em]
%
\AxiomC{$\Gamma, A\vdash B$}
             \UnaryInfC{$\Gamma \vdash A\to B$}
            \DisplayProof 
\hspace{3em} 
\AxiomC{$\Gamma\vdash A \to B$}  
\AxiomC{$\Gamma\vdash A$}
             \BinaryInfC{$\Gamma \vdash B$}
            \DisplayProof \ \ \ \ 
%
\\[1em]
%
\AxiomC{$\Gamma \vdash A$}
             \UnaryInfC{$\Gamma \vdash \forall x\,A$}
            \DisplayProof
($x$ not free in $\Gamma$)
\hspace{2em}  
\AxiomC{$\Gamma \vdash \forall x\,A$}
             \UnaryInfC{$\Gamma \vdash A[t/x]$}
            \DisplayProof 
%
\\[0.5em]
%
\AxiomC{$\Gamma \vdash A[t/x]$}
             \UnaryInfC{$\Gamma \vdash \exists x\,A$}
            \DisplayProof
\hspace{2em}  
\AxiomC{$\Gamma \vdash \exists x\,A$}
%\AxiomC{$\Gamma \vdash \forall x\,(A \to B)$}
\AxiomC{$\Gamma, A \vdash B$}
             \BinaryInfC{$\Gamma \vdash B$}
            \DisplayProof 
($x$ not free in $\Gamma,B$) 
%
\\[1em]
%
$\Gamma \vdash \Phi(\mu(\Phi))\subseteq \mu(\Phi)$
\hspace{3em} 
\AxiomC{$\Gamma \vdash \Phi(P)\subseteq P$}
             \UnaryInfC{$\Gamma \vdash \mu(\Phi)\subseteq P$}
            \DisplayProof 
%
\\[1em]
%
$\Gamma\vdash\nu(\Phi) \subseteq \Phi(\nu(\Phi))$
\hspace{3em} 
\AxiomC{$\Gamma \vdash P \subseteq \Phi(P)$}
             \UnaryInfC{$\Gamma \vdash P \subseteq \nu(\Phi)$}
            \DisplayProof 
\end{center}
\end{minipage}
}
\caption{Derivation rules of IFP. \label{table-proof-ifp}}
\end{table}

\paragraph{Axioms.}
$\IFP$ is parametric in a set $\ax$ 
of \emph{axioms}, which have to be closed 
\emph{non computational (nc)} formulas, i.e., formulas
containing no disjunctions.
Axioms should be chosen such that they are true in an intended 
Tarskian model.
% Though we are mainly interested in the realizability interpretation of IFP, all proof rules of IFP are also valid w.r.t. a standard Tarskian semantics.
Since Tarskian semantics admits classical logic, this means that
a fair amount of classical logic is available through axioms.
For example, for each nc-formula $A(\vec x)$, stability, 
$\forall \vec x\,(\neg\neg A(\vec x) \to A(\vec x))$
can be postulated as an axiom.
%
The significance of the restriction to nc-formulas is that these
are identical to their (formalized) realizability interpretation given below. In particular, Tarskian and realizability semantics coincide for axioms, which is the base of the soundness of our realizability interpretation.





%\newpage

%******** begin new ***********

\paragraph{Realizability.}
From an IFP proof of a formula $A$, one can extract a program $M$ that is a realization of the
computational content of $A$. Program extraction is done by
\begin{enumerate}
\item[(1)] defining, for each formula $A$, a type $\tau(A)$  
%of `potential realizers', % of $A$, 
and
a predicate $\rea(A)$ on 
the Scott-domain $D$ (defined in Section~\ref{sub-denot})  
specifying which $a\in\tau(A)$ %actually 
realizes $A$. % , i.e., represents a possible computational content of $A$;
\item[(2)] showing that if there is a 
proof of $A$, then there is a program 
%whose denotation satisfies 
satisfying
$\rea(A)$. 
%$\rea(A)$ is defined in a way such that $\rea(A)\subseteq\tau(A)$,
%i.e., all realizers of $A$ have type $\tau(A)$. 
%(Theorems~\ref{thm-soundnessII}, \ref{thm-soundnessII}, \ref{thm-pe}).
\end{enumerate}
%
% 
For a given instance of $\IFP$, realizability is formalized in another instance of $\IFP$,
called $\RIFP$, which extends $\IFP$ by additional sorts, constants,
and axioms.
%More precisely, 
$\RIFP$ has the new sorts $\delta$ 
for the domain $D$ 
%for the Scott-domain $D$ (defined in Section~\ref{sub-denot}) 
and $\subd$ for the set of subdomains of $D$,
a binary relation symbol $:$ for the typing relation
as well as constants for the type and program constructs in Section~\ref{sec-ang}, 
excluding $\Am$, $\Amb$ and $\strictapp{}{}$. 
%
It also has axioms describing the denotational semantics of $\RIFP$ programs and types,
which can be found in~\cite{IFP}.
In addition, RIFP has special predicate variables and type variables, corresponding to IFP 
predicate variables, as well as axioms connecting them, which we describe below.

%
To avoid `computational garbage' we distinguish between formulas with (nontrivial)
computational content and those with trivial computational content.
%whose computational content is rivial.
The latter are called \emph{Harrop formulas} and are defined as those $\IFP$ formulas
%For each IFP-formula $A$, a type $\tau(A)$ is defined as in Table \ref{table-type}. 
%Here, a \emph{Harrop} expression is one 
which contain  neither free predicate variables nor 
disjunctions ($\lor$) at strictly positive positions.
Their
%and they have type $\one$ and a 
trivial computational content is represented by the
program $\Nil$.
A formula is \emph{non-Harrop} if it is not Harrop.
The definition of the Harrop property can be extended to predicates 
in an obvious way.


%% \mps{\HT{I am sorry for the confusion, but the type correctness axiom
%% $\reali{X} \subseteq \adummy{\alpha_X}$ may not work because
%% it introduces a connection between two variables and thus impossible to
%% substitute to predicate / type independently.
%% }
%% \UB{A restricted form of substitution is still possible (Lemma~\ref{lem-rcfp-subst}
%% and Corollary~\ref{cor-pred-subst}). It is unusual to have axioms with free variables.
%% Maybe they should be called 'global assumptions', like in Minlog. We don't really need
%% the axioms since they can replaced by local assumptions in Lemmas. 
%% But the lemmas look nicer without these local assumptions.
%% }
%% }


%In Table~\ref{table-type} to every formula $A$ the type $\tau(A)$ is assigned
%in such a way that $\tau(A) = \one$ iff $A$ is a Harrop formula.
\begin{table}
\fbox{
\begin{minipage}{\textwidth}  
\begin{align*}
  %
  \tau(P(\vec t)) &= \tau(P)\\
  %
  \tau(A \lor B) &= \tau(A) + \tau(B)\\
  %
  \tau(A \land B) &= \tau(A) \times \tau(B) &\hbox{($A,B$ non-Harrop)}\\
  %
  %                &= \tau(A)  &\hbox{($B$ Harrop)}\\             
                  &= \tau(A)  &\hbox{($B$ Harrop, $A$ non-Harrop)}\\             
  %
  %                &= \tau(B)  &\hbox{(otherwise)}\\             
                  &= \tau(B)  &\hbox{($A$ Harrop, $B$ non-Harrop)}\\             
  %
                 &= \one  &\hbox{($A,B$ Harrop)}\\             
  %
  \tau(A \to B) &= \ftyp{\tau(A)}{\tau(B)}  &\hbox{($A,B$ non-Harrop)}\\
                &= \tau(B)  &\hbox{(otherwise)}\\
  %
  \tau(\diamond x\,A) &= 
    \tau(A) &\hbox{($\diamond \in\{\forall,\exists\}$)}\\[.5em]
  %
  \tau(X) &= \alpha_X & \hspace{-1cm}
           \hbox{($X$ a predicate variable, $\alpha_X$ a fresh type variable)}\\
  %
  \tau(P) &= \one &\hbox{($P$ a predicate constant)}\\
  %
  \tau(\lambda \vec x\,A) &= \tau(A)\\
  %
  \tau(\diamond (\lambda X\,P)) &= \tfix{\alpha_X}{\tau(P)}
                    &\hbox{($\diamond \in\{\mu,\nu\}$, $\diamond (\lambda X\,P)$ non-Harrop)}\\
           &= \one &\hbox{($\diamond \in\{\mu,\nu\}$, $\diamond (\lambda X\,P)$ Harrop)}
%%                     &\hbox{($\diamond \in\{\mu,\nu\}$, $P$ not $X$-Harrop)}\\
%%            &= \one &\hbox{($\diamond \in\{\mu,\nu\}$, $P$ $X$-Harrop)}
  %
  \end{align*}
%% % 
%% Here, $P$ is $X$-Harrop if $\lambda X P$ is Harrop, that is, 
%%    if $P$ is strictly positive in $X$ and $P[\pcv{X}/X]$ is Harrop where $\pcv{X}$ is a predicate constant associated with $X$. 
%
\end{minipage}
}
\caption{Types of $\IFP$ expressions. \label{table-type}}
\end{table}
%
Table~\ref{table-type} defines the type $\tau(A)$ of an $\IFP$ formula. 
%
Simultaneously, a type $\tau(P)$ is defined for every $\IFP$ predicate $P$.
For a predicate variable, $\tau(X)$ is a fresh type variable 
$\alpha_X$ representing the unknown type of the unknown predicate $X$.
One can see that $\tau(A) = \one$ iff $A$ is a Harrop formula.

The realizability predicate
$\rea(A)$ is defined 
in Table \ref{table-realizability} 
by structural recursion on the IFP formula $A$.
We often write $\ire{a}{A}$ for $\rea(A)(a)$ (`$a$ realizes $A$')
and $\ire{}{A}$ for $\exists\, a\ \ire{a}{A}$ (`$A$ is realizable').
Simultaneously with $\rea(A)$, we define for every IFP predicate $P$ an 
$\RIFP$-predicate $\rea(P)$ with an extra argument for (potential) realizers.
Since Harrop formulas have trivial computational content, 
it only matters whether they are  realizable or not. 
Therefore, we define for a Harrop formula $A$, an $\RIFP$-formula
 $\reah(A)$ that represents the realizability of $A$. %but with suppressed realizer.
%% Thus, we define $\rea(A)$
%% for all formulas $A$, and $\reah(A)$ for a Harrop formulas $A$ 
%% mutually recursively, as in Table \ref{table-realizability}.
%For this definition, we add to $\RIFP$, 
For a predicate variable, $\rea(X)$ is a fresh type variable $\reali{X}$
representing the unknown computational content of the unknown predicate $X$.



%% \UB{In the definition of $\rea(A)$ and $\tau(A)$ we assign to every}
%% $\IFP$ predicate variable $X$ of arity $(\vec s)$
%% (where $\vec s$ is a tuple of sorts),
%% a type variable $\alpha_X$ and a predicate variable $\reali{X}$ of arity $(\vec s,\delta)$
%% \UB{for which we}
%% postulate the $\RIFP$ axiom
%% %
%% \[ \hspace*{8em}
%%    \reali{X} \subseteq \adummy{\alpha_X} 
%%    \hspace{3em} \hbox{(Type correctness)} \]
%% %
%% where 
%% %
%% \[\adummy{\rho} \eqdef \lambda (\vec x,a)\,(a:\rho) .\]
%% %
%% \UB{Hence,} the axiom unfolds to $\forall (\vec x,a)\,(\reali{X}(\vec x,a) \to a:\alpha_X)$.
%% The idea is that $\reali{X}$ represents the realizability interpretation of $X$ and 
%% $\alpha_X$ represents the type of realizers of elements of $X$. 
%
%% Finally, $\RIFP$ has for every $\IFP$ predicate variable $X$ a predicate constant
%% $\pcv{X}$ of the same arity as $X$ which is used if we want to consider $X$ as a 
%% predicate without computational content (see Table~\ref{table-realizability}). 

\begin{table}
%
\fbox{\small
\begin{minipage}{\textwidth}
%For Harrop formulas $A$: 
%$\tau(A) = \one$ and  $\rea(A) = \lambda a\,(a = \Nil \land \reah(A))$.

$\rea(A)$ for Harrop formulas $A$:
\begin{align*}
%
\rea(A) &= \lambda a\,(a = \Nil \land \reah(A))
\hspace*{17.7em}
\\
%      \quad\hbox{if $A$ is a Harrop formula. Otherwise:}\\
%
\end{align*}

$\rea(A)$ for non-Harrop
formulas $A$:
\begin{align*}
%% %
%% \rea(A) &= \lambda a\,(a = \Nil \land \reah(A))
%%       \quad\hbox{if $A$ is a Harrop formula. Otherwise:}\\
%
%\rea(P(\vec t)) &= \lambda a\,(\rea(P)(\vec t,a)) &\\%\hbox{($P$ non-Harrop)}\\
\rea(P(\vec t)) &= \lambda a\,(\rea(P)(\vec t,a))\\
                                        %\quad\hbox{($P$ non-Harrop)}\\
% 
\rea(A\lor B)   &=\lambda c\,(\ex{a}(c=\inl{a}\land\ire{a}{A})\lor
                              \ex{b}(c=\inr{b}\land\ire{b}{B}))\\
%
\rea(A\land B)  &=\left\{ \begin{array}{ll}
   \lambda c\,(\exists a,b\,(c = \Pair(a,b) \land \ire{a}{A}\land \ire{b}{B}))
                            &\hbox{($A,B$ non-Harrop)}\\
              \lambda a\,(\ire{a}{A} \land \reah(B)) 
                            &\hbox{($B$ Harrop)}\\
              \lambda b\,(\reah(A) \land \ire{b}{B})
                            &\hbox{($A$ Harrop)}
                          \end{array} \right.\\ 
\rea(A\to B)    &= \left\{ \begin{array}{ll}
  \lambda c\,(c:\ftyp{\tau(A)}{\tau(B)} \land  
          \all{a}(\ire{a}{A}\to\ire{(c\,a)}{B})) 
                     &\hbox{($A$ non-Harrop)}\\ 
          \lambda b\,(b:\tau(B) \land (\reah(A) \to \ire{b}{B}))  
                     &\hbox{($A$ Harrop)}
                           \end{array}\right.\\
\rea(\allex x\,A)  &=\lambda a\,(\allex x\,(\ire{a}{A})) 
  \qquad \hbox{($\allex\in\{\forall,\exists\}$)}\\
\end{align*} 

$\rea(P)$ for non-Harrop predicates $P$:
\begin{align*}
\rea(X) &= \reali{X} \\
%
\rea(\lambda \vec x\,A) &= \lambda (\vec x,a)\,(\ire{a}{A})  \\
\rea(\munu(\lambda X\,P)) &= 
\munu(\lambda\reali{X}\,\rea(P)
[\tfix{\alpha_X}{\tau(P)}/\alpha_X])
 \qquad \hbox{($\munu\in\{\mu,\nu\}$)} 
\hspace*{9em}
\\
% &\HT{\text{Intuitively, it is a fixedpoint on pair $(\reali{X}, \alpha_X)$ }}\\
% &\HT{\text{and substitution should be done to the fixedpoint???}} \\
% &\HT{\text{I am afraid that the predicate returned by $\lambda\reali{X}\,\rea(P)[\tfix{\alpha_X}{\tau(P)}/\alpha_X]$ does not satisfy the axiom.}} \\
% &\UB{\text{You mean you doubt that 
% $\munu(\lambda\reali{X}\,\rea(P)[\tfix{\alpha_X}{\tau(P)}/\alpha_X])\subseteq
%                                                 \tfix{\alpha_X}{\tau(P)}/\alpha_X]$?}}\\
% &\UB{\text{This is shown (with some effort) in main2023 in Lemma 15 (e).}}
%      $
\end{align*}
% \HT{I understand it. My question is whether $\lambda\reali{X}\,\rea(P) [\tfix{\alpha_X}{\tau(P)}/\alpha_X]$ is type correct? The tree example,
% \[
%   tree = \mu (\Lambda X\  \lambda x\ x = leaf \lor x = lim(f) \land \forall n\ \NN(n) \to X(f\ n))
% \]
% \begin{align*}
%   R(T) = \mu(\lambda \reali{X}\, \lambda(x, a). &a = \Left (\Nil) \land x = leaf \lor\\
%   &a = \Right(g) \land g : \tau(N) \to \tau(tree) \land x = lim(f) \land \forall n, b. (\ire{b}{\NN(x) \to \reali{X}(f\ n)(g\ b)}))
% \end{align*}
% }
%
%
$\reah(A)$ for Harrop formulas $A$:
\begin{align*}
  \reah(P(\vec t)) &= \reah(P)(\vec t) \\ %\qquad \hbox{($P$ Harrop)}\\
%
\reah(A\land B)  &=
      \reah(A)\land \reah(B) \\
%
%% \reah(A\to B)    &= \left\{ \begin{array}{ll}
%% %    (\exists a, \rea(A)(a)) \to\reah(B) &\hbox{($A$ non-Harrop)}\\ 
%%   \ire{}{A} \to\reah(B) &\hbox{($A$ non-Harrop)}\\
%%   \reah(A)\to\reah(B) &\hbox{($A$ Harrop)}
%%                            \end{array}\right.\\
%
\reah(A\to B)    &= \re\,A \to\reah(B)\\
%
\reah(\allex x\,A)  &=\allex x\,\reah(A)
  \quad \hbox{($\allex\in\{\forall,\exists\}$)}
\hspace*{18.6em}
\\
\end{align*}
%
$\reah(P)$ for Harrop predicates  $P$:
\begin{align*}
%
\reah(P) &= P\quad \hbox{($P$ a predicate constant)}\\
%
\reah(\lambda \vec x\,A) &= \lambda \vec x\,\reah(A) 
%&\hbox{($A$ Harrop)}
\\
%
%
\reah(\munu(\lambda X\,P)) &= \munu(\lambda X\,\reah_X(P))
  \qquad \hbox{($\munu\in\{\mu,\nu\}$)}
\hspace*{16em}
\\
%
\end{align*}
%
%
\begin{itemize}
\item To each $\IFP$ predicate variable $X$ there are 
assigned a fresh type variable $\alpha_X$ and a fresh $\RIFP$ predicate 
variable $\reali{X}$ with one extra argument for domain elements. 
%\HT{that satisfy $\forall\, \vec x, a\, (\reali{X}(\vec x, a) \to a : \alpha_X)$.}
%$\reali{X} \subseteq \Delta \alpha_X}.$
%
\item $\reah_X(P) \eqdef\reah(P[\pcv{X}/X])[X/\pcv{X}]$
where $\pcv{X}$ is a fresh predicate constant assigned to the (non-Harrop) 
predicate variable $X$. 
This is motivated by the fact that $\lambda X\,P$ is Harrop
iff $P[\pcv{X}/X]$ is. The idea is that $\reah_X(P)$ is the same as 
$\reah(P)$ but considering $X$ as a (Harrop) predicate constant.
\end{itemize}
\end{minipage}
}
\caption{Realizability interpretation of $\IFP$}
\label{table-realizability}
\end{table}
% \mps{\HT{I wonder if $c: \ftyp{\tau(A)}{\tau(B)}$ is derivable from 
% $\all{a}(\ire{a}{A}\to\ire{(c\,a)}{B})$ in Table 7.
% Types are needed in the definition of realizability when the formula is not strict?
% }
% \UB{Yes, that's why we added the condition $c : \ftyp{\tau(A)}{\tau(B)}$.} 
% } 

% \mps{\UB{Do you propose to add $\reali{X} \subseteq \Delta(\alpha_X)$ as axioms?}
% \HT{It sounds natural for me and I expect that it is harmless.  But I am not sure.}
% \UB{In \cite{IFP} (and also here) we use closure of derivations under substitution
% for predicate variables. This would need to be restricted: If RIFP proves $A$
% and $P\subseteq\adummy{\rho}$,
% then RIFP proves $A[P/\reali{X}][\rho/\alpha_X]$}
% \HT{It sounds natural, though I do not know how much modifications we need.}
% }

The main difference of our interpretation to the 
usual realizability interpretation of intuitionistic number theory lies in the
interpretation of quantifiers. While in number theory variables range over
natural numbers, which have concrete computationally meaningful representations,
we make no general assumption of this kind,
since it is our goal to extract programs from proofs in abstract mathematics.
This is the reason why we interpret quantifiers \emph{uniformly}, that is, 
a realizer of a universal statement must be independent
of the quantified variable and a realizer of an existential statement does not contain a
witness.
%
A similar uniform interpretation of quantifiers can be found in the
Minlog system.
%Minlog system~\cite{SchwichtenbergMinlog06,BergerMiyamotoSchwichtenbergSeisenberger11,SchwichtenbergWainer12}.
The usual definition of realizability of quantifiers in intuitionistic number theory 
can be recovered by relativization to the inductively defined predicate $\NN$ in 
Example~\ref{ex-ind}, i.e., by writing
%
$\forall x\,(\NN(x) \to A)$.

\begin{example}[Natural numbers]
The type $\tau(\NN)$ assigned to the predicate $\NN$ 
(recall that $\NN(x) \eqmu  x = 0 \lor \NN(x-1)$)
is the 
%recursive 
type of unary lazy natural numbers,
%
$\nat\eqdef  \tfix{\alpha}{1+\alpha}$, introduced in Section~\ref{sec-ang}. 
%
Realizability for $\NN$ works out as
%
\[
\ire{a}{\NN(x)} \eqmu (a = \Left \land x = 0)  
\lor \exists b\,(a = \Right(b) \land \ire{b}{\NN(x-1))}\,.
\]
Therefore, the formulas $\NN(0)$, $\NN(1)$, $\NN(2)$, \ldots 
are realized by 
the domain elements $\Left$ ($= \Left(\Nil)$),
$\Right(\Left)$, $\Right(\Right(\Left))$, \ldots,
which means that if $x$ is a natural number, 
then the (unique) realizer of $\NN(x)$ is the unary 
(domain) representation of $x$ introduced in Section~\ref{sec-ang}.
%% Note that 
Other ways of defining natural numbers may induce different
(e.g.~binary) representations.  
%We have examples of predicates defined as greatest
%fixed points in Section \ref{sec-gray}.
%
\end{example}

\begin{example}[Functions]
As an example of an extraction of a program with function type,
consider the formula 
expressing that the sum of two natural number is a natural number,
%can be expressed as
\begin{equation}
\label{eq:intro1}
\forall x, y\ (\NN(x) \to \NN(y) \to \NN(x+y)).
\end{equation}
It has type %$\nat \to \nat \to \nat$  
$\ftyp{\nat}{\ftyp{\nat}{\nat}}$ and
is realized by a function $f$ that, given realizers of $\NN(x)$ and $\NN(y)$, 
returns a realizer of $\NN(x+y)$, hence $f$ performs addition of unary numbers.
\end{example}

\begin{example}[Non-terminating realizer - this example will be used in Section~\ref{sec-gray}]
\label{ex-d}
Let
$$
\D(x) \eqdef  x\neq 0 \to (x\leq 0 \lor x\geq 0)\,.
$$  
Then 
$\tau(\D) = \bool$ where $\bool = \one + \one$, and $\ire{a}{\D(x)}$ unfolds to
$$
a: \tau(\bool) \land (x \neq 0 \to (a = \Left \land x \leq 0) \lor 
(a = \Right \land x \geq 0)).
$$
Therefore, $\D(x)$ is realized by $\Left$ if $x < 0$ and by $\Right$ if $x > 0$.
If $x=0$, any element of $\bool$ realizes $\D(x)$,
in particular $\bot$. 
%% (not only $\Left$ and $\Right$ but also $\bot$). 
Hence, nonterminating programs,
%(which, by %Lemma \ref{lem:ssp}~(4)\HT{and Lemma \ref{lem-strict}~(3)}, denote $\bot$)
which, by Lemma \ref{lem-strict}~(4), denote $\bot$,
realize 
%$\D(x)$.
$\D(0)$.
%
In contrast, \emph{strict} formulas (defined in Section~\ref{sub-cfp}) are never realized 
by a nonterminating program, as shown in Lemma~\ref{lem-strict}~(2). %(b).
 
\end{example}


\subsection{CFP}
\label{sub-cfp}

\paragraph{Language.}
$\CFP$ extends $\IFP$ by two propositional operators,
$\rt{A}{B}$ for restriction, and $\Set(B)$ for concurrency.
Logically, 
these operators 
are equivalent to $A \to B$ and $B$, respectively because
the logical rules in Table \ref{table-infrule} are valid in 
a Tarskian semantics provided we identify $\rt{A}{B}$ with $A \to B$ and 
$\Set(B)$ with $B$.  Their importance relies exclusively on their realizability
interpretations, which are meaningful only when the realizers of $B$ 
%
are neither $\bot$ nor of the form $\Amb(a,b)$.
%are not $\bot$. 
Therefore, we require in $\rt{A}{B}$ and $\Set(B)$ 
the formula $B$ to be \emph{strict} in the following inductively defined sense,
where the notion of a \emph{Harrop formula} is extended to 
$\CFP$ by requiring that
in addition to disjunctions and predicate variables, also restriction and the concurrency
operator are disallowed at strictly positive positions:
%
\begin{itemize}
\item[-] Harrop formulas and disjunctions are strict. 
\item[-] A non-Harrop conjunction is strict if either both conjuncts are non-Harrop or it is a conjunction of a Harrop formula and a strict formula.
\item[-] A non-Harrop implication is strict if the premise is non-Harrop.
\item[-] A formula of the form $\diamond x\,A$ ($\diamond\in\{\forall,\exists\}$) or $\munu(\lambda X\lambda\vec x\,A)$ ($\munu\in\{\mu,\nu\}$) is
 strict if $A$ is strict.
 \item[-] Formulas of other forms ($\rt{A}{B}$,  $\Set(B)$, $X(\vec{t})$) are not strict.
\end{itemize} 
%\mps{\UB{Why is $\Set(B)$ not strict?}}

\paragraph{Proofs.}
The inference rules of $\CFP$ are those of $\IFP$ extended with the rules 
in Table~\ref{table-infrule} 
%
where %the latter are explained in the next section,
%\mps{\HT{omitted "the latter are explained in the next section", and}}
   the formulas and predicates in the $\IFP$ rules run now over $\CFP$.
%
%The rules are to be understood with arbitrary assumptions $\Gamma$, 
%i.e.\ every premise or conclusion $A$ of a rule should be replaced 
%by the sequent $\Gamma\vdash A$.
Since the rules do not change the assumptions of a sequent, we display them
%for ease of readability, 
with formulas instead of sequents.
Hence, each premise or conclusion $A$ stands for a sequent $\Gamma\vdash A$
with the same $\Gamma$ in each rule.
%
The notion of strict positivity, 
which the well-formedness of the fixed points $\mu(\Phi)$ and $\nu(\Phi)$ refer to, 
is extended to $\CFP$ expressions by stipulating that the strictly positive positions 
in $\rt{A}{B}$ and $\Set(B)$ are exactly those in $B$.
%
The rules in Table~\ref{table-infrule} are only applicable 
if all occurring formulas are well-formed, 
in particular, $B$ must be strict
in all occurring formulas of the form $\rt{A}{B}$ or $\Set(B)$. 

\begin{table}
\medbreak
\noindent
\fbox{\small
\begin{minipage}{\textwidth}

\[
\infer[\hbox{\begin{tabular}{l}Rest-intro\\
($A, B_0, B_1$ Harrop)\end{tabular}
%($A_0, A_1, B$ Harrop (Defined in Sect.~\ref{sec-pe}))\end{tabular}
}]{
        \rt{A}{(B_0 \vee B_1)}
}{
A \to (B_0 \vee B_1) \ \ \     \neg A \to B_0 \wedge B_1
}
\]

\smallskip

\[
\begin{array}{ll}
\infer[\hbox{Rest-bind}]{
      \rt{A}{B'}
}{
 \rt{A}{B}\ \ \          B \to (\rt{A}{B'})
}
\ \ \ \ \ \ \ \ & 
\infer[\hbox{Rest-return \ \ \ }]{  % ($A$  productive)
 \rt{A}{B}
}{
  B
}  \\\\
  \infer[\hbox{Rest-antimon}]{
    \rt{A'}{B}
    }{
      A' \to A \ \ \ \rt{A}{B}  
%    \rt{A}{B} \ \ \    A' \to A
}&
  \infer[\hbox{Rest-mp}]{
    B
}{
\rt{A}{B} \ \ \    A
}
\end{array}
\]

\smallskip

\[
\begin{array}{ll}
  \infer[\hbox{Rest-efq}]{
  \rt{\False}{B}
}{
}
\ \ \ \ \ \ \ \ &
\infer[\hbox{Rest-stab}]{
    \rt{\neg\neg A}{B}
    }{
    \rt{A}{B}
}
%
\end{array}
\]

\smallskip

\[
  \infer[\hbox{Conc-lem}]{
  \Set(B)
}{
\rt{A}{B}   \ \ \ \     \rt{\neg A}{B}
}
%
\qquad
%
  \infer[\hbox{Conc-return}]{\ 
%\HT{(\text{$A$ is productive})}]{
  \Set(B)
}{
B
}
%
\]

\smallskip

\[
  \infer[\hbox{Conc-mp}]{\
%\HT{(\text{$B$ is productive})}]{
\Set(B)
}{
  A\to B\ \ \  \Set(A) 
}\ \ \ \ \ 
%
\]
%
\end{minipage}
}
\medbreak
\caption{Inference rules for $\rt{A}{B}$ and $\Set{B}$ \label{table-infrule}.}
\end{table}
%
%% \mps{\HT{Formally, $\Amb$ is also added though
%% the axioms of $\Amb$ corresponding to reduction rules
%% are not.
%% }}

\paragraph{Realizability.} 
Typing and realizability interpretation of $\CFP$-formulas are the 
extension of Table \ref{table-type} 
and Table \ref{table-realizability} with those in Table \ref{table-realizability-cfp}.
%
\begin{table}
\medbreak
\noindent
\fbox{\small
\begin{minipage}{\textwidth}
\begin{align*}
\tau(\rt{A}{B}) &= \tau(B) \\ %\hbox{($B$ strongly non-Harrop)}\\
\tau(\Set(B)) &= \Am(\tau(B))\ %\qquad\hbox{($B$ strict)}
\end{align*}
\begin{align*}
  \rea(\rt{A}{B}) &= \lambda b\,( b\! :\! \tau(B) \land  
                                (\re\, A \to \defined{b}) \land
                               (\defined{b} \to b\,\re\,B)) 
                                         %\qquad\hbox{($B$ strict)}
\\
% 
\rea(\Set(B)) &= \lambda c\, \ex{a,b}\, 
      (c = \Amb(a, b) \land a,b:\tau(B) \land (\defined{a} \lor \defined{b})\ \land \\
              &\hspace{5em} (\defined{a} \to a\, \re\, B) \land 
                             (\defined{b} \to b\, \re\, B))
\end{align*}
\end{minipage}
}
\medbreak
\caption{Typing and realizability for $\rt{A}{B}$ and $\Set{B}$\label{table-realizability-cfp}.}
\end{table}
%
Formally, realizability for $\CFP$ is expressed in an extension of $\RIFP$ by the 
type constructor $\Am$, the amb operator $\Amb$
 and the strict application operator $\strictapp{}{}$.
This extension is called $\RCFP$ where the `C' stands for `classical' 
(rather than `concurrent') since it is based on classical logic
but does not have nonstandard constructs for concurrency.
The proof rules of $\RCFP$ are those of $\RIFP$ (extended to $\RCFP$ formulas)
plus the law of excluded middle,
$A \lor \neg A$.
%
%% \[ 
%%     \AxiomC{$A \to B$}
%%     \AxiomC{$\neg A \to B$}
%%      \RightLabel{LEM}
%%              \BinaryInfC{$B$}
%%             \DisplayProof 
%% \]
%% \[ 
%%     \AxiomC{$\Gamma, A \vdash B$}
%%     \AxiomC{$\Gamma, \neg A \vdash B$}
%%      \RightLabel{LEM}
%%              \BinaryInfC{$\Gamma \vdash B$}
%%             \DisplayProof 
%% \]
In addition to the axioms of $\RIFP$, $\RCFP$ has axioms for
strict application ($b\neq\bot \to\strictapp{a}{b}=a\,b$, $\strictapp{a}{\bot}=\bot$) 
and the type operator $\Am$ ($c:\Am(\rho) \toot (\exists a,b:\rho\,(c=\Amb(a,b)) \lor c=\bot)$).



\begin{lem}
  \label{lem-strict}
  %
  For every $\CFP$-formula $A$:
  \begin{enumerate}
  \item[(1)] $\tau(A)$ is a regular type.
  \item[(2)] 
    If $A$ is strict, then $\bot$ and domain elements of the form 
     $\Amb(a,b)$ do not realize $A$. %, provably in $\RCFP$.
% If $A$ is strict, then $\bot$ does not realize $A$.%, provably in $\RCFP$.
  \item[(3)]  
  $\Amb(\bot, \bot)$ is not a realizer of $A$,
       and if $\Amb(a, b)$ realizes $A$, then neither $a$ nor $b$ is
       of the form $\Amb(u,v)$. 
  \item[(4)]  For a program $M$ that realizes $A$, $M$ is productive iff $\val{M} \neq \bot$.
  \end{enumerate}
  \end{lem}
  %
  \begin{proof}
    (1) and (2)  
  are easily proved by structural induction on formulas.
  (3) follows from the fact that if $A$ is of the form 
%$\Amb(B)$, 
$\Set(B)$,
then $B$
  must be strict.
%% \mps{\UB{To see that $\Amb(\bot,\bot)$ does not realize $\Set(B)$
%%          strictness of $B$ is not needed.}} 
  (4) follows from (1), (3) and Corollary~\ref{cor:ddatabot}. % was (4)
  \end{proof}
  
\begin{rem}
\label{rem-partial}

  For a closed program $M$, we study 
  the meanings of $\rea(\rt{A}{B})(M)$  and $\rea(\Set(B))(M)$
  (identifying $M$ with $\val{M} \in D$):

  By combining the definition of $\rea(\rt{A}{B})$ 
  with Lemma~\ref{lem-strict}(4), we see that 
  $\rea(\rt{A}{B})(M)$ says two things: 
  (1) if $A$ is realizable, then $M$ is productive, and
  (2) if $M$ is productive then $M$ realizes $B$.
  Recall that `productive' is the counterpart of `terminating' for concurrent 
  infinite computation. Therefore, one can consider (2) the 
 `partial correctness'  of $M$ with respect to the specification $B$.
  
  (1) and (2) together imply that if $A$ is realizable, then
 $M$ realizes $B$, a property one can call `conditional correctness' of $M$,
 and which is what $\rea(A \to B)(M)$ means if $A$ is Harrop
 (see Example~\ref{ex-d}).
 However, $\rea(\rt{A}{B})(M)$ says more than that.
 It says that even if $A$ is not realizable, 
 all the defined (i.e., non-bottom) values obtained by computing $M$ are correct.
 This is what we need for concurrent computation as we explained 
 in the introduction.


  To highlight the difference between restriction and implication
in a more concrete situation, 
consider $\rt{A}{(A\lor B)}$ vs.\ $A \to (A \lor B)$
where $A$ is Harrop. Clearly $\Left$ realizes $A \to (A \lor B)$,
but $\Left$ does not realize $\rt{A}{(A\lor B)}$ if $A$ is not realizable.
%but in general $\rt{A}{(A\lor B)}$ is not realizable.
\end{rem}

As to the intuitive meaning of the formula $\rea(\Set(B))(M)$,
it says, by the Adequacy Lemma (\ref{lem:ssp}(4)), that    
$M$ is reduced by $\ssp^*$ to $\Amb(N, K)$ 
such that        
both $N$ and $K$ are partially correct programs of $B$ and at least one of 
  $N$ or $K$ is productive.  
    Therefore, by executing $N$ and $K$ concurrently and 
taking the one that produces some
value (i.e., is reduced to a deterministic w.h.n.f.), one have a realizer of $B$.
Hence, if $\rea(\Set(B))(M)$, 
then there is a program $M'$ such that $M\newprintp^* M'$  and 
$M'$ realizes $B$. 
This is a part of the program extraction theorem (Theorem \ref{thm-pe}).



%
%% We use the notation 
%% %$\adummy\,\alpha := \lambda (\vec x,a)\,(a:\alpha)$ 
%% \[\adummy{\alpha} \eqdef \{(\vec x,a) \mid a:\alpha\}\]
%% where it is assumed that the arity of the tuple $\vec x$ is given by the context.
%% Hence $Q\subseteq \adummy{\alpha}$ is equivalent to 
%% $\forall \vec x,a\,(Q(\vec x,a) \to a:\alpha)$.
%
%% \begin{lem}
%% \label{lem-realizers-typed}
%% If $\ire{a}{A}$, then $a:\tau(A)$, for every closed $\CFP$ formula $A$.

%% More generally, for every $\CFP$ predicate $P$, 
%% $\rea(P)\subseteq\adummy{\tau(P)}$ 
%% under the assumptions  $\reali{X}\subseteq\adummy{\alpha_X}$ 
%% for every free predicate variable $X$ of $P$.
%% %
%% \end{lem}


The following lemma says that the result from \cite{IFP} regarding 
the typability
of realizers carries over to $\CFP$.
%
We use the notation
%
\[\adummy{\rho} \eqdef \lambda (\vec x,a)\,(a:\rho),\]
%
so that $Q\subseteq\adummy{\rho}$   unfolds to 
$\forall (\vec x,a)\,(Q(\vec x,a) \to a:\rho)$.
%
\begin{lem}
\label{lem-realizers-typed}
%
If $P$ is a $\CFP$ predicate, then 
$\RCFP$ proves $\rea(P)\subseteq\adummy{\tau(P)}$ from the 
%(type correctness) 
assumptions
$\reali{X}\subseteq\adummy{\alpha_X}$ for every free predicate variable 
$X$ in $P$. 
In particular, if $P$ is a formula $A$, then $\ire{a}{A}$ implies $a:\tau(A)$
under these assumptions.
%
\end{lem}
%
\begin{proof}
%% One proves more generally:
%% If $P$ is a $\CFP$ predicate with free predicate variables among $\vec X$, then
%% $\RCFP$ proves $\rea(P)\subseteq\adummy{\tau(P)}$ from the assumptions
%% $\reali{X}\subseteq\adummy{\alpha_X}$ for every $X\in\vec X$.
%
The proof is by structural induction on $P$ and,
in the largest parts, carries over from \cite{IFP}.
For the case that $P$ is a predicate variable $X$, the assumption
$\reali{X}\subseteq\adummy{\alpha_X}$ is used. 
Looking at the definitions of realizability for $\rt{A}{B}$ and $\Set(B)$, 
one sees that they preserve the type correctness of realizers.
\end{proof}


%% \paragraph{Type correctness.}
%% %
%% The type variable $\alpha_X$ and the predicate variable $\reali{X}$ associated with $X$
%% are connected since $\alpha_X$ is the type of the realizers of $X$, 
%% which are specified by $\reali{X}$.
%% %
%% It is therefore natural to consider for every $\IFP$ predicate variable $X$ 
%% the following \emph{type correctness axiom} which express this fact:
%% %
%% \[ \hspace*{8em}
%%    \reali{X} \subseteq \adummy{\alpha_X} 
%%    \hspace{3em} \qquad\TC(X) \]
%% %
%% where 
%% %
%% \[\adummy{\rho} \eqdef \lambda (\vec x,a)\,(a:\rho) .\]
%% %
%% \UB{Hence, $\TC(X)$ unfolds to 
%% $\forall (\vec x,a)\,(\reali{X}(\vec x,a) \to a:\alpha_X)$.
%% %
%% We denote by $\RCFPTC$ the extension of $\RCFP$ 
%% by the type correctness axioms $\TC(X)$ for all $\CFP$ predicate variable $X$.
%% More specifically, we write $\RCFPT{\vec X}$ for the extension of $\RCFP$
%% by the axioms $\TC(X)$ for $X\in\vec X$.
%% }


%% The following lemma says that the result from \cite{IFP} regarding the typability
%% of realizers carries over to $\CFP$.
%% %
%% %% We use the notation 
%% %% %$\adummy\,\alpha := \lambda (\vec x,a)\,(a:\alpha)$ 
%% %% \[\adummy{\alpha} \eqdef \{(\vec x,a) \mid a:\alpha\}\]
%% %% where it is assumed that the arity of the tuple $\vec x$ is given by the context.
%% %% Hence $Q\subseteq \adummy{\alpha}$ is equivalent to 
%% %% $\forall \vec x,a\,(Q(\vec x,a) \to a:\alpha)$.
%% %
%% %% \begin{lem}
%% %% \label{lem-realizers-typed}
%% %% If $\ire{a}{A}$, then $a:\tau(A)$, for every closed $\CFP$ formula $A$.

%% %% More generally, for every $\CFP$ predicate $P$, 
%% %% $\rea(P)\subseteq\adummy{\tau(P)}$ 
%% %% under the assumptions  $\reali{X}\subseteq\adummy{\alpha_X}$ 
%% %% for every free predicate variable $X$ of $P$.
%% %% %
%% %% \end{lem}

%% \begin{lem}
%% \label{lem-realizers-typed}
%% \UB{$\RCFPT{\vec X}$} proves $\rea(P)\subseteq\adummy{\tau(P)}$, for every 
%% $\CFP$ predicate $P$ with free type variables among $\vec X$.
%% In particular, if $\ire{a}{A}$, then $a:\tau(A)$.
%% %under the assumptions  $\reali{X}\subseteq\adummy{\alpha_X}$ 
%% %for every free predicate variable $X$ of $P$.
%% %
%% \end{lem}
%% %
%% \begin{proof}
%% The proof is by structural induction on $P$ and,
%% in the largest parts, carries over from \cite{IFP}.
%% For the case that $P$ is a predicate variable $X$, the axiom $\TC(X)$ is used. 
%% Looking at the definitions of realizability for $\rt{A}{B}$ and $\Set(B)$, 
%% one sees that they preserve the type correctness of realizers.
%% \end{proof}


%% \begin{lem}
%% \label{lem-rcfp-subst}
%% If  $\RCFPT{\vec X,X}$ proves $B$ and $\RCFPT{\vec X}$ proves 
%% $Q\subseteq\adummy{\rho}$,
%% %under assumptions that contain neither the predicate variable $\reali{X}$ 
%% %nor the type variable $\alpha_X$, 
%% then $\RCFPT{\vec X}$ proves $B[Q/\reali{X}][\rho/\alpha_X]$.
%% \end{lem}
%% %
%% \begin{proof}
%% Induction on the derivation of $B$.
%% %% One shows more generally that if $\RCFPTC$ proves $\Gamma\vdash B$ and
%% %% $\Gamma'\vdash Q\subseteq\adummy{\rho}$, then $\RCFPTC$ proves
%% %% $\Gamma[Q/\reali{X}][\rho/\alpha_X], \Gamma'\vdash B[Q/\reali{X}][\rho/\alpha_X]$.
%% %% The proof is by induction on the derivation of $\Gamma\vdash B$.
%% %% In the case that $B$ is the type correctness axiom $\reali{X}\subseteq\adummy{\alpha}$,
%% %% $B[Q/\reali{X}][\rho/\alpha_X]$ is $Q\subseteq\adummy{\rho}$ 
%% %% which is provable by assumption.
%% \end{proof}


%% \UB{The following Corollary show that realizers are polymorphic, 
%% not only with respect to typing and type substitution (Lemma~\ref{lem-typing-subst}~(1)), 
%% but also with respect to 
%% provable realizability and predicate substitution.}
%% %
%% \UB{
%% \begin{cor}
%% \label{cor-pred-subst}
%% If $\RCFPT{\vec X,X}$ proves $\ire{M}{A}$, 
%% %under assumptions that contain neither the predicate variable $X$ 
%% %nor the type variable $\alpha_X$, 
%% then $\RCFPT{\vec{X}}$ proves $\ire{M}{(A[P/X])}$
%% for every $\CFP$ predicate $P$ with free predicate variables among $\vec X$.
%% \end{cor}
%% %
%% \begin{proof}
%% Using Lemma~\ref{lem-rcfp-subst} with $B\eqdef\ire{M}{A}$, $Q\eqdef\rea(P)$, 
%% $\rho\eqdef\tau(P)$, 
%% and the fact that, by Lemma~\ref{lem-realizers-typed},
%% $\RCFPT{\vec X}$ proves $\rea(P)\subseteq\adummy{\tau(P)}$,
%% we obtain that $\RCFPT{\vec X}$ proves $(\ire{M}{A})[\rea(P)/\reali{X}][\tau(P)/\alpha_X]$.
%% But $\rea(A)[\rea(P)/\reali{X}][\tau(P)/\alpha_X]$ is the same as
%% $\rea(A[P/X])$ (proof by induction on $A$), hence 
%% $(\ire{M}{A})[\rea(P)/\reali{X}][\tau(P)/\alpha_X]$ is the same as $\ire{M}{(A[P/X])}$.
%% \end{proof}


%% This Corollary shows that $\RCFPTC$ is conservative over $\RCFP$:
%% \begin{cor}
%% \label{cor-conservative}
%% If $\RCFPTC$ proves $A$ where $A$ has no free predicate variables,
%% then $\RCFP$ proves $A$.
%% \end{cor}
%% \begin{proof}
%% This follows by iterated applications of Lemma~\ref{lem-rcfp-subst} and the fact that
%% each axiom $\TC(X)$ has a substitution instance that is provable in $\RCFP$
%% (e.g., $\TC(X)[\lambda (\vec x,a).\False/\reali{X}][\one/\alpha_X]$
%% unfolds to the tautology $\forall(\vec x,a)\,(\False\to a:\one)$).
%% %(e.g., $\TC(X)[\lambda (\vec x,a).(a=\Nil)/\reali{X}][\one/\alpha_X]$
%% %is equivalen to $\Nil:\one$).

%% \end{proof}
%% } 
