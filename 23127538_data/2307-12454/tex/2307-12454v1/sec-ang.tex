



In \cite{McCarthy1963}, 
%John 
McCarthy defined 
the ambiguity operator $\amb$ as
\[
\amb(x, y) = \left\{ \begin{array}{ll} x  &(x \ne \bot)\\
                       y & (y \ne \bot) \\
                       \bot & (x =  y = \bot)
                              \end{array}\right.
\]                              
where $\bot$ means `undefined' and $x$ and $y$ are taken nondeterministically 
when both $x$ and $y$ are not $\bot$.
%
This is called \emph{locally} angelic nondeterministic choice  
since convergence is chosen over divergence for each local call for 
the computation of $\amb(x, y)$.
%It embodies a form of fair parallel evaluation and
It can be implemented by executing both of the arguments
in parallel and taking the result obtained first.  
%
Despite being a simple construction,
%that embodies fair nondeterministic computation, 
$\amb$ is known to have a lot of expressive power, 
and many constructions of nondeterministic and parallel computation 
such as erratic choice, countable choice (random assignment), 
and `parallel or' can be encoded through it \cite{LassenMoran99}.
%
These multifarious aspects of the operator $\amb$ are reflected by 
the difficulty of its mathematical treatment in denotational semantics.
For example, 
$\amb$ is not monotonic when interpreted over powerdomains
with the Egli-Milner order~\cite{Broy1986}.


%On the other hand, 
Alternatively, 
one can consider an interpretation of $\amb$ as  
\emph{globally} angelic choice, where  an argument of $\amb$ 
is chosen so that the whole ambient computation converges, 
%\HT{if possible}~\cite{ClingerHalpern85}.
if convergence 
is possible at all~\cite{ClingerHalpern85,SondergardSestoft92}.
It can be %easily 
implemented by 
running the {\em whole} computation for both
of the arguments of $\amb$ in parallel and taking the 
result obtained first.
%%%% 
%\mps{\HT{removed three sentences}} 
The difference between 
%
the locally and the globally angelic interpretation
%these two interpretations 
%
of $\amb$ 
%% can be understood 
is highlighted
by the fact that the 
%% locally angelic $\amb$ operator 
former 
does not commute with function application.
For example, if 
$f(0) = 0$ but $f(1)$ diverges,
then,
with the local interpretation,  
$\amb(f(0), f(1))$ will always terminate with the value $0$, whereas
$f(\amb(0, 1))$ may return 0 or diverge.
On the other hand, 
%the globally angelic $\amb$ operator commutes with function application and
the latter term will always return $0$ 
if $\amb$ is implemented with a globally angelic semantics.
Though globally angelic choice is not defined compositionally,  
one can, as suggested in \cite{ClingerHalpern85},  
integrate it into the design of a programming 
language by using this commutation property.


% Since globally angelic choice is not defined compositionally,  
% it is not easy to integrate it into a design of a programming 
% language with clear denotational semantics.
% However, it can be easily implemented by 
% running the whole computation for both
% of the arguments of $\amb$ in parallel and taking the 
% result obtained first.
%
%
% \mps{\UB{Then, why don't we use the Hoare powerdomain?}
% \HT{It sounds like a serious problem to submit it to POPL.
%  Do you have a good explanation?}
% }
%
%% Though it poses some restrictions on
%% the way the choice operator is used,  it is not a problem in that
%% the extracted program always satisfy the restrictions.
%\UB{however, for our purposes, a different, two-staged approach 
%will be more suitable~(see Sect.~\ref{sub-denot}).}
%%%%% end remove
%
%\mps{\UB{I commented out the sentence on restrictions since it's not 
%necessary and might just confuse the reader.}}
%
Denotationally, globally angelic choice 
%corresponds to 
can be modelled by
the Hoare powerdomain construction. 
However, this would not be suitable for analyzing total correctness
  because the ordering of the Hoare powerdomain does 
not discriminate $X$ and $X \cup \{\bot\}$~\cite{HughesM92,HughesO89}.
%\mps{\UB{I'm not sure about ``present a programming language 
% with clear denotational semantics''} \HT{How about this?}
% \UB{I'd prefer 'simple' instead of 'clear' (writing 'clear' sounds as if we think previous semantics were unclear).}}
Instead, we consider a two-staged approach (see~Section.~\ref{sub-denot})
and provide a simple denotational semantics for a language with angelic choice.



\subsection{Programs and types}
\label{Sec:2.1}
%
Our target language for program extraction
is an untyped lambda calculus with recursion operator and
constructors as in~\cite{IFP}, but extended by an additional 
constructor $\Amb$ that corresponds to globally angelic version
of McCarthy's $\amb$.
%
This could be easily generalized to 
%an $\Amb$ operator
$\Amb$ operators 
of any arity $\ge 2$.
%
\label{sub-prog}
%
\begin{align*}
&  \mathit{Programs} \owns M,N,L,P, Q,R :: = 
  a, b, \ldots, f, g \ \ \text{(program variables)}\\
%a,b,c\ \ \text{(program variables; occasionally, we also use $x, y, f$)}\\ 
&\quad  |\  \lambda a.\,M 
\ | \ M\,N 
\ | \ \strictapp{M}{N} 
\ | \ \rec\,M \ | \  \botexp \\
&\quad |\    \Nil\ | \ \Left(M)\ | \ \Right(M)\ | \ \Pair(M,N) |\ \Amb(M,N)\\
%&\quad  |\
%& | & \case\,M\,\of\,\{Cl_1;\ldots;Cl_n\} \\ 
&\quad |\  \caseof{M}\{\Left(a) \to L; \Right(b) \to R\} \\ 
&\quad |\  \caseof{M}\{\Pair(a,b) \to N\} \\
&\quad |\  \caseof{M}\{\Amb(a,b) \to N\}  
%  \caseof{M} \{\Nil \to N; \Left(a) \to L; \Right(a) \to R; 
%\Pair(a,b) \to P; \Amb(a,b) \to A \}% ; \fun(f) \to F \} 
\end{align*}
%
Denotationally, $\Amb$ is just another pairing operator. 
Its interpretation as globally angelic choice 
will come to effect only through its operational semantics 
(see Section~\ref{sec-ops}).
Though essentially a call-by-name language, 
it also has strict application $\strictapp{M}{N}$. 

We use $a, \ldots, g$ for program variables to distinguish them from the variables
$x, y, z$ of 
the logical system 
CFP (Section~\ref{sec-cfp}). 
%
$\Nil, \Left, \Right, \Pair, \Amb$ are called \emph{constructors}.
Constructors different from $\Amb$ are called \emph{data constructors} and
$\mathrm{\datacons}$ denotes the set of data constructors.

$\strictapp{\Left}{M}$ stands for $\strictapp{(\lambda a.\Left(a))}{M}$, etc.,
and we sometimes write $\Left$ and $\Right$ for $\Left(\Nil)$ and 
$\Right(\Nil)$.  
%
Natural numbers are
 encoded as $0 \eqdef \Left$,  $1 \eqdef \Right(\Left)$, 
$2 \eqdef \Right(\Right(\Left))$, etc.


%\subsection{Types}
%
Although programs are untyped, programs extracted from
proofs will be typable by %a type from 
the following system of 
simple recursive types:
\[
Types \ni \rho, \sigma ::=  \alpha\ (\hbox{type variables})
                         \mid \one  
                         \mid \rho \times \sigma
                         \mid \rho + \sigma
                         \mid \ftyp{\rho}{\sigma}
                         \mid \tfix{\alpha}{\rho}
                         \mid \Am(\rho) 
\]
The intention of $\Am(\rho)$ is to denote the type of
programs which, if they terminate (see Section~\ref{sec-ops}), 
reduce to a form
$\Amb(M, N)$ with $M,N\!:\!\rho$.

To obtain a well-behaved semantics of types (see Section~\ref{sub-denot}) 
we impose restrictions
on the formation of $\Am(\rho)$ and $\tfix{\alpha}{\rho}$:
A type is \emph{regular} if 
(1) for every subtype $\Am(\rho)$, $\rho$ is determined (see below)
and 
(2) for every subtype $\tfix{\alpha}{\rho}$, $\rho$ is 
properly strictly positive in $\alpha$.
Here, a type is \emph{determined} if it is of the form
$\tfix{\alpha_1}{\ldots\tfix{\alpha_n}{\rho}}$ ($n\ge 0$) with $\rho$ 
of the form $\one$, $\rho_1\times\rho_2$, $\rho_1+\rho_2$, 
or $\ftyp{\rho_1}{\rho_2}$,
and a type is \emph{properly strictly positive in $\alpha$} 
if it contains $\alpha$ free
but is different from $\alpha$ and it has no free occurrence of $\alpha$ 
in the left side of a function type. 
%
\begin{center}
\emph{In the following we will tacitly assume that all types under consideration are regular.}
\end{center}
The restrictions 
imposed 
on fixed point types ensures
that every type transformer $\alpha \mapsto \rho$
has a unique fixed point, which is taken as the semantics of $\tfix{\alpha}{\rho}$.
The restriction on the formation of $\Am(\rho)$ enables the interpretation of $\Amb$ 
as a bottom-avoiding choice operator
(see the explanation below Corollary~\ref{cor:ddatabot}).
%
An example of a (regular) type is
% 
\[\nat \eqdef \tfix{\alpha}{\one+\alpha},\]
% 
the type of lazy partial natural numbers. Besides the natural numbers $0,1,2,\ldots$
(represented in $D$ as described above) this type contains the 
`partial natural numbers' 
$\bot$, $\Right(\bot)$, $\Right(\Right(\bot))$, \ldots, as well as 
their supremum, $\Right(\Right(\ldots)) = \bigsqcup\{\Right^n(\bot) \mid n\in\NN\}$.


\begin{table}
\fbox{%\small
\begin{minipage}{\textwidth}
\begin{center}
%
$\Gamma, a:\rho \vdash a:\rho$
\hspace{3em} 
$\Gamma \vdash \Nil:\one$
\hspace{3em}
$\Gamma \vdash \bot:\rho$
\hspace{3em}
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\rho$}
             \UnaryInfC{$\Gamma \vdash \Left(M) : \rho + \sigma$}
            \DisplayProof 
\hspace{3em} 
\AxiomC{$\Gamma\vdash M:\sigma$}
             \UnaryInfC{$\Gamma \vdash \Right(M) : \rho + \sigma$}
            \DisplayProof \ \ \ \ 
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\rho$}
\AxiomC{$\Gamma\vdash N:\sigma$}
             \BinaryInfC{$\Gamma \vdash \Pair(M,N) : \rho\times\sigma$}
            \DisplayProof 
\ \ \ \ \ \ \ \ 
\AxiomC{$\Gamma\vdash M:\rho$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash \Amb(M,N) : \Am(\rho)$}
            \DisplayProof 
%
\\[0.5em]
%
\AxiomC{$\Gamma, a:\rho\vdash M:\sigma$}
             \UnaryInfC{$\Gamma \vdash \lambda a.\,M : \ftyp{\rho}{\sigma}$}
            \DisplayProof 
\ \ \ \ \ \ \ \ \ \ 
\AxiomC{$\Gamma, a:\rho\vdash M\,a:\rho$}
             \UnaryInfC{$\Gamma \vdash \rec\,M : \rho$}
            \DisplayProof 
{($a$ not free in $M$)}
%
\\[0.5em]
%
\AxiomC{$\Gamma\vdash M:\ftyp{\rho}{\sigma}$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash M\,N : \sigma$}
            \DisplayProof \ \ \ \ 
\hspace{3em} 
\AxiomC{$\Gamma\vdash M:\ftyp{\rho}{\sigma}$}
\AxiomC{$\Gamma\vdash N:\rho$}
             \BinaryInfC{$\Gamma \vdash \strictapp{M}{N} : \sigma$}
            \DisplayProof \ \ \ \ 
%
\\[0.5em]
%
\AxiomC{$\Gamma \vdash M : \rho[\tfix{\alpha}{\rho}/\alpha]$}
\RightLabel{{}}
             \UnaryInfC{$\Gamma \vdash M : \tfix{\alpha}{\rho}$}
            \DisplayProof 
\hspace{3em} 
\AxiomC{$\Gamma \vdash M : \tfix{\alpha}{\rho}$}
\RightLabel{{}}
             \UnaryInfC{$\Gamma \vdash M : \rho[\tfix{\alpha}{\rho}/\alpha]$}
            \DisplayProof 
%
\\[1em]
%
% \AxiomC{$\Gamma, a:\rho\vdash M\,a:\rho$}
%              \UnaryInfC{$\Gamma \vdash \rec\,M : \rho$}
%             \DisplayProof 
% {($a$ not free in $M$)}
% \\[1em]
% \hspace{3em} 
% \AxiomC{$\Gamma \vdash M:\rho\times\sigma$}
% \AxiomC{$\Gamma, a:\rho, b:\sigma \vdash N:\tau$}
%        \BinaryInfC{$\Gamma \vdash \caseof{M}{\{\Pair(a,b) \to N\}} : \tau$}
%             \DisplayProof 
% %
% \\[1em]
% %
% \AxiomC{$\Gamma \vdash M:\rho + \sigma$}
% \AxiomC{$\Gamma, a:\rho \vdash L:\tau$}
% \AxiomC{$\Gamma, b:\sigma \vdash R:\tau$}
% \TrinaryInfC{$\Gamma\vdash\caseof{M}{\{\Left(a)\to L\,;\,\Right(b)\to R\}}:\tau$}
%             \DisplayProof \ \ \ \ 
% %
% %
\AxiomC{$\Gamma \vdash M:\rho + \sigma$\ \ \ \ 
$\Gamma, a:\rho \vdash L:\tau$\ \ \ \ 
$\Gamma, b:\sigma \vdash R:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Left(a) \to L; \Right(b) \to R \} :\tau$}
            \DisplayProof \ \ \ \ 
%
\\[1em]
\AxiomC{$\Gamma \vdash M:\rho\times\sigma$\ \ \ \ 
$\Gamma, a:\rho, b:\sigma \vdash N:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Pair(a, b) \to N\} :\tau$}
            \DisplayProof 
\ \ 
\AxiomC{$\Gamma \vdash M:\Am(\rho)$\ \ \ 
$\Gamma, a,b:\rho \vdash N:\tau$}
\UnaryInfC{$\Gamma\vdash \caseof{M} \{\Amb(a, b) \to N\} :\tau$}
            \DisplayProof 
% \AxiomC{$\Gamma \vdash M:\ftyp{\rho}{\sigma}$}
% \AxiomC{$\Gamma, f:\ftyp{\rho}{\sigma} \vdash F:\tau$}
% \BinaryInfC{$\Gamma\vdash {\bf caseexp} :\tau$}
%             \DisplayProof 
%
%\\[1em]
%
\end{center}
\end{minipage}
}
\caption{Typing rules}
\label{fig-typing}
\end{table}


The typing rules, listed in Fig.~\ref{fig-typing},
are valid w.r.t.~the denotational semantics given in Section~\ref{sub-denot} 
and extend the rules given in~\cite{IFP}. 
Recursive types are equirecursive \cite{Pierce:2002} in that
$M : \tfix{\alpha}{\rho}$ iff $M : \rho[\tfix{\alpha}{\rho}/\alpha]$.
%
\begin{lem}
\label{lem-typing-subst}
Typing is closed under substitution of types and programs.
In other words, typed programs are polymorphic and the cut-rule holds:
\begin{enumerate}
\item[(1)] (Polymorphism) If 
$\Gamma \vdash M:\rho$ and $\alpha$ is not free in $\Gamma$, 
then $\Gamma\vdash M:\rho[\sigma/\alpha]$ for every type $\sigma$.
\item[(2)] (Cut)
%Furthermore, we have closure under cut (substitution of programs), i.e. if
If $\Gamma,x:\rho\vdash M:\sigma$ and $\Gamma\vdash N:\rho$, then 
$\Gamma\vdash M[N/x] :\sigma$.
\end{enumerate}
%
\end{lem}
\begin{proof}
Induction on typing derivations
\end{proof}


As an example of a program consider
%
\begin{equation}
\label{eq-f}
f\eqdef\lambda a.\,\caseof{a} \{\Left(\_)\to\Left;
                                    \Right(\_)\to \bot\}
\end{equation}
%
which implements the function $f$ discussed earlier, i.e.,
$f\,0 = 0$ and $f\,1 = \bot$.
$f$ has type $\ftyp{\nat}{\nat}$. 
%
Since 
%% the term 
$\Amb(0,1)$ has type $\Am(\nat)$,
the application $f\,\Amb(0,1)$ 
%\mps{\HT{It sounds a bit strange. omit?} }
%\HT{(which has the `wrong' denotational semantics) }
is not well-typed. 
%% in our type system.
Instead, we consider
$\mapamb\,f\,\Amb(0, 1)$
where 
$\mapamb : (\alpha \to \beta) \to \Am(\alpha) \to \Am(\beta)$ 
is defined as
%
\begin{eqnarray*}
\mapamb\eqdef \ \lambda f.\, \lambda c.\ \caseof{c}\,
%\UB{\mapamb\,f\,c\ \eqdef\ }
\caseof{c}\,
\{\Amb(a,b) \to 
 \Amb(\strictapp{f}{a}, \strictapp{f}{b})\}
\end{eqnarray*}
%

This operator realizes the globally angelic semantics:
$\mapamb\ f\ \Amb(0, 1)$ is reduced to $\Amb(\strictapp{f}{0}, \strictapp{f}{1})$,
 and then $\strictapp{f}{0}$ and $\strictapp{f}{1}$ 
%(which are the same as $f\,0$ and $f\,1$ since $0$ and $1$ are defined) 
are computed concurrently and 
the whole expression
is reduced to 0, using 
the operational semantics in Section \ref{sec-ops}.
%
In Section~\ref{sec-pe}, we will introduce a concurrent (or nondeterministic) 
version of Modus Ponens, (Conc-mp), 
which will automatically generate an application of $\mapamb$.
%

%\subsection{The domain of realizers}
%\label{sub-dom}
\subsection{Denotational semantics}
\label{sub-denot}
%
The denotational semantics has two phases: 
%
\emph{Phase~I} interprets programs in a Scott domain $D$
defined by the 
following
recursive domain equation
%\HT{Here, $\Nil, \Left, \Right, \Pair, \Fun, \Amb$ are names introduced to specify a component of the sum.}
%
\[
D = (\Nil + \Left(D) + \Right(D) + \Pair(D\times D) 
    + \Amb(D\times D) + \Fun(D\to D))_\bot \,.
\]  
%
where $+$ and $\times$ denote separated sum and cartesian product, 
and the operation $\cdot_\bot$ adds a least element 
$\bot$~(\cite{GierzHofmannKeimelLawsonMisloveScott03} is a recommended 
reference for domain theory and the solution of domain equations).
%


Table~\ref{fig-semantics-programs} gives the denotational semantics
of programs 
%according to which
which interprets 
a program $M$ as % denotes 
an element $\valu{M}{\eta}\in D$
for every environment $\eta$ assigning domain elements to the free variables of $M$. 
Note that $\Amb$ is interpreted (like $\Pair$) as a simple pairing operator.


Types are interpreted as subdomains, i.e.\ as subsets of $D$
that are downward closed and closed under suprema of bounded subsets.
%
To interpret the type constructors we use the following operations
on subsets of $D$: 
%
\begin{eqnarray*}%
X_\bot &\eqdef& X \cup\{\bot\}\\
X+Y &\eqdef& \{\Left(a)\mid a\in X\} \cup 
                           \{\Right(b) \mid b \in Y\}\\ 
X\times Y &\eqdef& \{\Pair(a,b) \mid a\in X, b\in Y \}\\
\ftyp{X}{Y} &\eqdef& \{\Fun(f) \mid f:D\to D\hbox{ continuous, }
                           \forall a\in X (f(a) \in Y) \}\\
\Amb(X,Y) &\eqdef& \{\Amb(a,b) \mid a\in X, b\in Y \}
\end{eqnarray*}
%
Clearly, if $X$ and $Y$ are subdomains of $D$, so are 
$(X+Y)_{\bot}$, $(X\times Y)_{\bot}$, $\Amb(X,Y)_{\bot}$, $(\ftyp{X}{Y})_{\bot}$.
The denotational semantics of types, shown in Table~\ref{fig-semantics-types},
maps every type $\rho$ to a subdomain $\tval{\rho}{\zeta}$ for every environment 
$\zeta$ that assigns subdomains to the free type variables of $\rho$.
%
It is easy to see that the typing rules in Table~\ref{fig-typing} are sound w.r.t.\ 
this semantics.

In the following we will often write $M$ instead of $\valu{M}{\eta}$ if it is clear
from the context that we mean the denotation of $M$ and not its syntax and if it is
clear which assignment $\eta$ we are referring to, or the assignment is irrelevant. 
Similarly, we will often write just $\rho$ instead of $\tval{\rho}{\zeta}$,
hence $a \in\rho$, which we also write as $a:\rho$, means $a\in\tval{\rho}{\zeta}$,
and $M\in\rho$ (or $M:\rho$) means $\valu{M}{\eta}\in\tval{\rho}{\zeta}$.
We write $\vdash M:\rho$ if the typing is derivable 
by the typing rules.


\begin{table}
\fbox{\small
\begin{minipage}{\textwidth}
\vspace*{-0.2cm}
\begin{eqnarray*}
%
\valu{a}{\eta} &=& \eta(a)\\
%
\valu{\lambda a.\,M}{\eta} &=& \Fun(f)\quad  
  \hbox{where $f(d) = \valu{M}{\eta[a\mapsto d]}$}\\
%
\valu{M\,N}{\eta} &=& f(\valu{N}{\eta})\quad 
                        \hbox{if $\valu{M}{\eta}= \Fun(f)$}\\
%
\valu{\strictapp{M}{N}}{\eta} &=& f(\valu{N}{\eta})\quad 
                        \hbox{if $\valu{M}{\eta}= \Fun(f)$ and $\valu{N}{\eta}\neq\bot$}\\
%
\valu{\rec\,M}{\eta} &=& \hbox{the least fixed point of $f$ if $\valu{M}{\eta}=\Fun(f)$}\\
%
\valu{C(M_1,\ldots,M_k)}{\eta} &=& C(\valu{M_1}{\eta},\ldots,
                                       \valu{M_k}{\eta})
\quad \hbox{($C$ a constructor (including $\Amb$))}\\
%
\valu{\caseof{M}{\vec{Cl}\}}}{\eta} &=& 
       \valu{K}{\eta[\vec a \mapsto \vec d]} 
       \quad \hbox{if $\valu{M}{\eta} = C(\vec d)$ 
and $C(\vec a) \to K\in\vec{Cl}$}\\
%
\valu{M}{\eta} &=& \bot\ \ 
\hbox{in all other cases, %(i.p.~$\valu{\botexp}{\eta} = \bot$)}
in particular $\valu{\botexp}{\eta} = \bot$}
%
\end{eqnarray*}

%\vspace*{-0.2cm}  

\hspace{1cm}${\eta}$ is an environment that assigns elements of $D$ to variables.
%
\end{minipage}
}
\caption{Denotational semantics of programs (Phase I)}
\label{fig-semantics-programs}
\end{table}

\begin{table}
  \fbox{\small
  \begin{minipage}{\textwidth}
\vspace*{-0.2cm}
%
\begin{eqnarray*}
%
%\tval{\alpha}{\zeta} &=& \gendom{\zeta(\alpha)},\\
\tval{\alpha}{\zeta} &=& \zeta(\alpha),\qquad\\
%
\tval{\one}{\zeta} \ &=&  \ \{\Nil,\bot\},\\
\tval{\tfix{\alpha}{\rho}}{\zeta} &=& 
\bigcap\{\subdom{X} \mid \tval{\rho}{\zeta[\alpha \mapsto X]} \subseteq X \} 
\text{\qquad ($\subdom{X}$ means $X$ is a subdomain of $D$)}\\
%
\tval{\Am(\rho)}{\zeta} &=&
%  \{\Amb(a, b) \mid a, b \in \tval{\rho}{\zeta}\} \cup \{\bot\}\\
  \Amb(\tval{\rho}{\zeta},\tval{\rho}{\zeta})_\bot \\
\tval{\rho\diamond\sigma}{\zeta} &=& 
(\tval{\rho}{\zeta}\diamond\tval{\sigma}{\zeta})_{\bot}\quad 
(\diamond\in\{+,\times,\ftyp{}{}\})   %\ \hbox{where}\\
\end{eqnarray*}                           

%\vspace*{-0.2cm}  

\hspace*{1cm}
${\zeta}$ is a type environment that assigns subdomains of $D$ to type variables.
%
\end{minipage}
}
\caption{Denotational semantics of types}
\label{fig-semantics-types}
\end{table}

In \emph{Phase~II} of the denotational semantics we assign to every $a\in D$
a set $\ddata(a)\subseteq D$ 
that reveals the role of $\Amb$ as a choice operator. 
The relation $\ddata(a,d)$, also written 
`$d\in\ddata(a)$',  
is defined (coinductively) as the largest relation satisfying
%
%\begin{center}
\begin{align}
%&\hspace*{-0.4cm}  d \in \ddata(a) \eqnu \ \\
d \in \ddata(a) \quad \eqnu \quad 
&(a = \Amb(a', b') \land a' \ne \bot \land d \in \ddata(a')) \ \lor \notag\\
&(a = \Amb(a', b') \land b' \ne \bot \land  d \in \ddata(b')) \ \lor \notag\\
&(a = \Amb(\bot, \bot) \land d = \bot) \ \lor \notag\\  
%&((a = \Amb(a', b) \lor  a = 
%               \Amb(b, a')) \land \defined{a'} \land  d \in \ddata(a'))   
&\bigvee_{C \in \mathrm{\datacons}} 
\left(a =  C(\vec{a'}) \land d = C(\vec{d'}) \land \bigwedge_i d'_i \in \ddata(a'_i)\right) \ \lor\notag\\
&(a = \Fun(f)  \land d = a )\  \lor\notag\\ 
&(a = d = \bot)\,. \label{e-data} 
%&(\nondata(a) \land d = \bot)
\end{align} 
%
Now, every closed program $M$ %now also 
denotes the set 
$\ddata(\val{M}) \subseteq D$ containing all possible globally 
angelic choices derived form its denotation in $D$.
%
For example, $\ddata(\Amb(0,1)) = \{0,1\}$ and, for $f$ as
defined in~(\ref{eq-f}), we have, as expected,
$\ddata(\mapamb\ f\ \Amb(0, 1)) = \ddata(\Amb(0,\bot)) = \{0\}$. 
%
In Section~\ref{sec-ops} we will define an operational semantics whose fair
execution sequences starting with a regular-typed program 
$M$ compute exactly the elements in $\ddata(\val{M})$.

\begin{rem}
%
In~\cite{IFP} the meaning of the word `data' is slightly different.
There, it means that a domain element has no function component.
Therefore, in $\IFP$, `data' means `no $\Fun$', 
whereas here, it means `no $\Amb$'.
%
\end{rem}


\begin{example}\label{ex:random}
  Let $M = \rec\ \lambda a. \Amb(\Left(\Nil), \Right(a))$. $M$ is a closed program
of type
  $\tfix \alpha \Am(\one + \alpha)$.
  We have $\ddata(M) = \{0, 1, 2, \ldots\}$.
%As this example shows, our non-determinism is unbounded nondeterminism. and 
Thus, we can express countable choice (random assignment) with $\Amb$.
%
\end{example}

\begin{lem}\label{lem:ddatabot}
%
If $a\in\rho$ (w.r.t.\ some type environment) where $\rho$ is a (regular) 
type but not a variable, then the following are equivalent:
  (i) $\bot \in \ddata(a)$;
  (ii) $\{\bot\} = \ddata(a)$;
  (iii) $a \in\{\bot,\Amb(\bot, \bot)\}$.   
\end{lem}
\begin{proof}
%
Obviously (iii) implies (ii), and (ii) implies (i).
Therefore, it suffices to show that (i) implies (iii).
%
By the definition of $\ddata$, 
$\bot \in \ddata(a)$ if and only if $a = \bot$ or ($a = \Amb(a', b')$
  and (($a' \ne \bot$ and $\bot \in \ddata(a')$) or 
      ($b' \ne \bot$ and $\bot \in \ddata(b')$) or $a' = b' = \bot$)).
%
If $a=\bot$, then (iii) holds.
%
If $a=\Amb(a',b')$, then, since $\rho$ is not a variable (but regular),
$\rho$ must be of the form $\tfix{\alpha_1}{\ldots\tfix{\alpha_n}{\Am(\sigma)}}$
where $\sigma$ is determined.  
%
Therefore, $a',b'\in\sigma$ (w.r.t.\ some type environment) and hence 
neither $a'$ nor $b'$ have the form $\Amb(a'', b'')$.  
It follows that,
  $\bot \in \ddata(a')$ if and only if $a' = \bot$, and
  $\bot \in \ddata(b')$ if and only if $b' = \bot$.
  Therefore, (iii) holds.
%
\end{proof}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:




