We show that the realizability interpretation 
of $\CFP$ is sound in 
the sense that from every $\CFP$ derivation one can extract 
a program realizing the proven formula (Theorem~\ref{thm-soundnessI}). 
%
Proofs take place in the system $\RCFP$ introduced in Section~\ref{sub-cfp}
which is based on classical logic. Classical logic is needed 
since for 
the rules (Rest-intro), (Rest-stab), and (Conc-lem), 
the verification that the extracted 
programs are realizers uses the law of excluded middle.
%
In Section~\ref{sub-partial} we show the realizability
of the new proof rules and hence the soundness of the extracted programs.
% 
In Section~\ref{subsec:soundness} we show that,
for a class of `admissible' formulas, the data of an 
extracted program $M$ (i.e., the elements of $\ddata(\val{M})$) realize
the formula obtained by 
%deleting the operator $\Set$.
deleting the operator $\Set$ 
and replacing every restriction by the corresponding implication.
Recall that, 
by the Computational Adequacy Theorems \ref{thm:data} and ~\ref{thm:dataconv}, 
the elements of $\ddata(\val{M})$ are exactly the data computed by
the operational semantics of $M$. 

%\subsection{Partial correctness and concurrency}
\subsection{Soundness of extracted programs}
\label{sub-partial}
\label{sub-conc}   
%
%% We show that the proof rules in Table \ref{table-infrule} are realizable
%% and therefore a program is extracted from an CFP proof.
%% In this proof, we use classical logic.  
%% Therefore, the proof is done not in RIFP but
%% RCFP that is RIFP with the law of excluded middle. 

The realizers of the proof rules for restriction and concurrency
in Table~\ref{table-infrule}
are depicted %shown 
in Table~\ref{table-infrule-sound} for those instances
where the conclusion of the rule is non-Harrop.
%
Proofs of the correctness of the realizers are given in Lemma~\ref{lem-restrict}.
The cases where the conclusions of the rules are Harrop formulas are easy
and the verification of the correctness of the realizability 
interpretation is skipped.
We use the 
following typable programs:
%
\begin{eqnarray*}
\leftright
%\UB{\leftright\,b} 
&\eqdef& 
  \lambda b.\,  
\caseof{b}  \{\Left(\_) \to \Left; \Right(\_) \to \Right\}
:
(\alpha+\beta)\to1+1\\
\mapamb
%\UB{\mapamb\,f\,c} 
&\eqdef& 
\lambda f.\,\lambda c.\ 
\caseof{c}\,\{\Amb(a,b)\to\Amb(\strictapp{f}{a},\strictapp{f}{b})\}
:
(\alpha\to\beta) \to \Am(\alpha) \to \Am(\beta)\\
%a\, \seq\, b &\eqdef& \strictapp{(\lambda c.\ b)}{a}
\seq 
&\eqdef& 
\lambda a.\,\lambda b.\,\strictapp{(\lambda c.\ b)}{a}
:
\alpha \to \beta\to \beta
\quad \hbox{(used infix)}
\end{eqnarray*}






\begin{table}
\medbreak
\noindent
\fbox{
\begin{minipage}{\textwidth}
\medskip
\[
\infer[{\small \hbox{\begin{tabular}{l}Rest-intro
($A, B_0, B_1$ Harrop)\end{tabular}}
}]{
        \ire{(\leftright\ b)}{\rt{A}{(B_0 \vee B_1)}}
}{
\ire{b}{(A \to (B_0 \vee B_1))} \ \ \     \reah({\neg A \to B_0 \wedge B_1})
}
\]
%
\vspace{0.2em}
%
\[
\begin{array}{ll}
%% \infer[\hbox{\begin{tabular}{l}
%%                Rest-bind\ ($B$ non-Harrop)\\
%%                \small ($\ire{(a\,\seq\,f)}{\rt{A}{B'}}$ ($B$ Harrop))
%%              \end{tabular}}]
%% {\ire{(\strictapp{f}{a})}{\rt{A}{B'}}
%% }{
%% \ire{a}{ \rt{A}{B}}\ \ \          \ire{f}{( B \to (\rt{A}{B'}))}
%% }  
\infer[{\small \hbox{Rest-return\ }}]{  % ($A$  productive)
 \ire{a}{\rt{A}{B}}
}{
  \ire{a}{B}
} 
&
\infer[{\small
        \hbox{Rest-bind}
        \hbox{\begin{tabular}{l}
                $c=\strictapp{f}{a}$ if $B$ non-Harrop\\
                $c=a\,\seq\,f$ if $B$ Harrop
             \end{tabular}}
       }
]{\ire{c}{\rt{A}{B'}}
}{
\ire{a}{ \rt{A}{B}}\ \ \          \ire{f}{( B \to (\rt{A}{B'}))}
}
\end{array}
\]
\vspace{0.2em}
\[
\begin{array}{ll}
  \infer[{\small \hbox{Rest-antimon}}]{
    \ire{a}{\rt{A'}{B}}
    }{
      \ire{}{(A' \to A)} \ \ \ \ire{a}{\rt{A}{B}  }
%    \rt{A}{B} \ \ \    A' \to A
}\ \ \ \ \ \ \ &
  \infer[{\small \hbox{Rest-mp}}]{
    \ire{b}{B}
}{
\ire{b}{\rt{A}{B}} \ \ \    \ire{}{A}
}
\end{array}
\]
\[
\begin{array}{ll}
  \infer[{\small \hbox{Rest-efq}}]{
  \ire{\bot}{\rt{\False}{B}}
}{
}
\ \ \ \ \ \ \ \ &
\infer[{\small\hbox{Rest-stab}}]{
    \ire{b}{\rt{\neg\neg A}{B}}
    }{
    \ire{b}{\rt{A}{B}}
}

%
\end{array}
\]
%
\vspace{0.2em}
%
\[
  \infer[{\small \hbox{Conc-lem}}]{
  \ire{\Amb(a,b)}{\Set(B)}
}{ 
\ire{a}{\rt{A}{B}}   \ \ \ \     \ire{b}{\rt{\neg A}{B}}
}
%
\qquad
%
  \infer[{\small \hbox{Conc-return}}]{\ 
  \ire{\Amb(a,\bot)}{\Set(B)}
}{
\ire{a}{B}
}
%
\]
%
\vspace{0.2em}
%
\[
  \infer[{\small
            \hbox{Conc-mp}
            \hbox{\begin{tabular}{l}
               $d=\mapamb\ f\ c$ if $A$ non-Harrop\\
               $d=\Amb(f, \bot)$ if $A$ Harrop
                  \end{tabular}}
         }
]
{\
\ire{d}{\Set(B)}
}{
  \ire{f}{(A\to B)}\ \ \  \ire{c}{\Set(A) }
}\ \ \ \ \ 
\]
\smallskip
\end{minipage}
}
\medbreak
\caption{Realizers of the inference rules for $\rt{A}{B}$ and $\Set{B}$ with non-Harrop conclusions\label{table-infrule-sound}.}
\end{table}



\begin{lem}
\label{lem-restrict}
%
The rules for restriction and concurrency are realizable.
%provably in \HT{$\RIFP$
%extended with classical logic.} %$\RCFP$
\end{lem}
%
\begin{proof}\quad\\


  \noindent\emph{Rest-intro}:
  \ \raisebox{-0.2cm}{$\infer[\hbox{($A, B_0, B_1$ Harrop)}]{
          \ire{(\leftright\ b)}{\rt{A}{(B_0 \vee B_1)}}
  }{
  \ire{b}{(A \to (B_0 \vee B_1))} \ \ \     \reah({\neg A \to B_0 \wedge B_1}) 
  }
  $}.\medbreak
  
  $\ire{b}{(A \to (B_0 \vee B_1))}$ means $b:\tau(B_0\lor B_1)$ and
  $\reah(A) \to \ire{b}{(B_0 \vee B_1)}$, and
  %
  $\reah(\neg A \to B_0 \wedge B_1) \equiv 
  \neg \reah(A) \to \reah(B_0) \wedge \reah(B_1)$.
  We claim that $\rt{A}{(B_0 \vee B_1)}$ 
  is realized by %$a$.
  $\leftright\,b$.
  %% $$\leftright\ b = 
  %% \caseof{b} \{\Left(\_) \to \Left, \Right(\_) \to \Right\}.
  %% $$
  %
  %(hence $a'=\bot$ if $a\not\in\{\Left,\Right\}$).
  %
  %
  Assume $\re\,A$, that is, $\reah(A)$. 
  Then $b$ realizes $B_0 \lor B_1$. 
  Hence $b\in\{\Left,\Right\}$ and therefore $\defined{b}$
  and thus $\leftright\ b \ne \bot$.
  %
  Now assume $\leftright\ b \ne \bot$.
  We do a (classical) case analysis on whether or not $\reah(A)$ holds.
  If $\reah(A)$, then $\ire{b}{(B_0 \vee B_1)}$.
  If $\neg \reah(A)$, then $\reah(B_0)$ and $\reah(B_1)$. Hence,
  $\Left$ and $\Right$ both realize $B_0 \lor B_1$.
  Since $b:\tau(B_0\lor B_1)$ and $\defined{b}$,
  $b \in \{\Left, \Right \}$.   Therefore, $\ire{b}{(B_0 \lor B_1)}$.
  
  \medbreak\noindent
  \emph{Rest-return}:\ \raisebox{-0.2cm}{$\infer{  
   \ire{a}{\rt{A}{B}}
  }{
    \ire{a}{B}
  }$}. % for strict $B$.
\medbreak
  
  Since $B$ is strict, $\ire{a}{B}$ implies $a \ne \bot$.
  Therefore, clearly $\ire{a}{\rt{A}{B}}$.
%  \UB{(Note that without $B$ being strict we could have
%  $\ire{\bot}{B}$ but $\neg(\ire{\bot}{\rt{A}{B}})$ if $A$ is a true formula.)} 
  
  \medbreak
  \noindent
  \emph{Rest-bind}:\ \raisebox{-0.2cm}{
  \infer{
        \ire{(\strictapp{f}{a})}{\rt{A}{B'}}
  }{
  \ire{a}{ \rt{A}{B}}\ \ \          \ire{f}{( B \to (\rt{A}{B'}))}
  }
  } 
%for strict $B$, $B'$, non-Harrop $B$.\medbreak
$B$ non-Harrop.\medbreak
  
  We have $\forall c\,(\ire{c}{B} \to \ire{(f\,c)}{\rt{A}{B'})})$.
  If $\re\,A$ then $\defined{a}$ and  $\ire{a}{B}$, and therefore $f\, a$ 
  realizes $\rt{A}{B'}$.
  Therefore $\defined{f\, a}$ because $\re\,A$.
  Note that $\strictapp{f}{a} = f\, a$ because $\defined{a}$.
  If $\defined{\strictapp{f}{a}}$, then $\defined{a}$.
  Since $\defined{a}$ and $\ire{a}{\rt{A}{B}}$,  we have $\ire{a}{B}$.
  Therefore,  $\strictapp{f}{a} = f\, a$ realizes $\rt{A}{B'}$.
  If $B$ is Harrop,  
  %we can show that 
  then
  $a\,\seq\,b$ realizes $\rt{A}{B'}$ with a similar argument.
  
  \medbreak
  \noindent \emph{Rest-antimon}: \ \raisebox{-0.2cm}{
  $\infer{
    \ire{a}{\rt{A'}{B}}
      }{
        \ire{}{(A' \to A)} \ \ \ \ire{a}{\rt{A}{B}  }}$}. 
%for strict $B$.
\medbreak

  
  Clearly, $\ire{a}{\rt{A'}{B}}$
  since $\re\,A'$ implies $\re\,A$.
  
  \medbreak
  \noindent \emph{Rest-mp}: \ \raisebox{-0.2cm}{
  $  \infer{
      \ire{b}{B}
  }{
  \ire{b}{\rt{A}{B}} \ \ \    \ire{}{A}
  }
  $}. 
%for strict $B$.
\medbreak
  
  Clear from the definition of $\ire{b}{\rt{A}{B}}$.
  
  \medbreak
  \noindent \emph{Rest-efq}: \ {
  $\ire{\bot}{\rt{\False}{B}} $} for strict $B$.\medbreak
  
  Clear.
  
  \medbreak
  \noindent \emph{Rest-stab}: \ \raisebox{-0.2cm}{
  $
  \infer{
      \ire{b}{\rt{\neg\neg A}{B}}
      }{
      \ire{b}{\rt{A}{B}}}
  $}.  %for strict $B$.
\medbreak
  
We use classical logic.
%
Clearly, $\re\,(\neg\neg A)$ is equivalent to  
$\neg\neg (\re\, A)$, and hence, by classical logic, equivalent to $\re\, A$.
Therefore, premise and conclusion 
%of the rule 
are equivalent.

  
  \medbreak
  \noindent \emph{Conc-lem}: \ \raisebox{-0.2cm}{
  $
    \infer{
    \ire{\Amb(a,b)}{\Set(B)}
  }{
  \ire{a}{\rt{A}{B}}   \ \ \ \     \ire{b}{\rt{\neg A}{B}}
  }$}. 
%for strict $B$.
\medbreak
  
  By classical logic
  $\re\,A$, or $\neg(\re\,A)$ i.e.\ $\re\,(\neg A)$. In the first case
  $a \ne \bot$  and in the second case $b \ne \bot$. Further, if $a \ne \bot$,
  then $a$ is a realizer of 
  $B$ since  $a$ realizes $\rt{A}{B}$. Similarly for $b$.
  
  \medbreak
  \noindent \emph{Conc-return}: \ \raisebox{-0.2cm}{
  $  \infer{\   \ire{\Amb(a,\bot)}{\Set(B)}
  }{
  \ire{a}{B}
  }$}. %\ for strict $B$.
\medbreak
  
  Clear.
  
  \medbreak
  \noindent \emph{Conc-mp}: \ \raisebox{-0.2cm}{
  $  \infer{\
  \ire{(\mapamb\,f\,c)}{\Set(B)}
  }{
    \ire{f}{(A\to B)}\ \ \  \ire{c}{\Set(A) }
  }
  $}
%\ for strict $A$, $B$, non-Harrop $A$.
$A$ non-Harrop
\medbreak
  
  We show that $\mapamb\,f\,c$ realizes $\Set(B)$.
  %
  If $\ire{\Amb(a, b)}{\Set(A)}$, then 
  $\defined{a} \lor \defined{b}$.  If $\defined{a}$, then
  $\strictapp{f}{a} = f\ a$ and $\ire{a}{A}$, therefore
  $\ire{(\strictapp{f}{a})}{B}$.  Since $B$ is strict, we have
  $\defined{\strictapp{f}{a}}$.   In the same way, 
  if $\defined{b}$ then $\defined{\strictapp{f}{b}}$.
  Therefore, we have $\defined{\strictapp{f}{a}} \lor \defined{\strictapp{f}{b}}$.  If $\defined{\strictapp{f}{a}}$, then $\defined{a}$ and thus
  $\ire{(\strictapp{f}{a})}{B}$ as we have observed.
  If  $A$ is Harrop,  then, since clearly $\re{A}$,
  it is realized by $\Amb(f,\bot)$.
  %
  \end{proof}
  %
%
\begin{thm}[Soundness Theorem I]
\label{thm-soundnessI}
%
%Let $\Gamma$ be a set of Harrop formulas and
%$\Delta$ a set of non-Harrop formulas.
From a 
%$\CFP(\ax)$-proof 
$\CFP$-proof 
of a 
closed
formula $A$ from a set of axioms
one can extract a 
program $M$ 
such that 
the typing rules prove $M : \tau(A)$
and
%(where $\tau(A)$ is a regular type) and 
%of type $\tau(A)$ (which is a regular type)
%such that 
$\RIFP$ proves $\ire{M}{A}$ 
from the same axioms. 
%in $\RCFP(\ax)$ from the assumptions 
%$\reah(\Gamma)$ and $\ire{\vec u}{\Delta}$. 
%
%If $A$ is Harrop, then $M = \Nil$ and $\ire{M}{A} =\reah(A)$.
%%


More generally, let $\Gamma$ be a set of Harrop formulas and
$\Delta$ a set of non-Harrop formulas.
%
Then, from a $\CFP(\ax)$ proof of 
a formula $A$ 
from the assumptions $\Gamma,\Delta$
one can extract a program $M$ with $\FV(M) \subseteq \vec u$ 
such that $\vec u : \tau(\Delta) \vdash M: \tau(A)$ 
is derivable by the typing rules
of Table~\ref{fig-typing}
and $\ire{M}{A}$ is 
provable in $\RCFP(\ax)$
from the assumptions $\reah(\Gamma)$,
$\ire{\vec u}{\Delta}$. 
%and $\vec u : \tau(\Delta)$.
%% \UB{
%% and $\reali{X}\subseteq\adummy{\alpha_X}$ for every free predicate variable
%% $X$ in $\Gamma$, $\Delta$, $A$.
%% }



\end{thm}
%
\begin{proof} %(of Soundness Theorem I)
%
Induction on $\CFP$-proofs. 
%One has to show that 
%each proof rule of $\CFP$ is realizable,  that is, there is a program
%that, maps any realizers of the premises to a realizer of the 
%conclusion. 
Realizability of the rules of $\IFP$ was shown in %to
~\cite{IFP}.
The rules for restriction and concurrency are taken care of
in Lemma~\ref{lem-restrict}.
%
The type correctness of the extracted programs for 
Rest-intro, Rest-bind and Conc-mp follows from the typings
of $\leftright$, $\mapamb$, and $\seq$.
%
\end{proof}

\begin{lem}\label{class-orelim-sleep}
In $\CFP$, one can prove all well-formed instances of the following formulas:
%
\begin{enumerate}
  \item[(1)] $(B\to B') \to \rt{A}{B} \to \rt{A}{B'}$  (Rest-mon)\medbreak
  \item[(2)] ${\rt{A_0}{B} \to \rt{A_1}{B} \to \neg\neg(A_0\lor A_1) \to \Set(B)}$
  (Class-orelim)\medbreak
  \item[(3)]
${\rt{A_0}{B_0} \to \rt{A_1}{B_1} \to \neg\neg(A_0\lor A_1) \to \Set(B_0\lor B_1)}$\medbreak
\item[(4)]
$A  \to {\rt{\neg A}{B}} $\medbreak
\item[(5)]
$(A \lor B) \to {\rt{\neg A}{B}} $\medbreak
\item[(6)]
$\rt{A_0}{(A \lor B)} \to {\rt{A_0\land\neg A}{B}} $\medbreak
%
\end{enumerate}
The extracted programs and their types 
for the case that $B,B',B_0,B_1,A$ are non-Harrop are:
\begin{enumerate}
  \item[(1)]
  $  \lambda f.\,\lambda b.\, \strictapp{f}{b}\ : \ 
  (\tau(B) \to \tau(B')) \to \tau(B) \to \tau(B')$, \smallskip

  \item[(2)]
  $\lambda a.\, \lambda b.\, \Amb(a,b)\ : \ 
  \tau(B) \to \tau(B) \to \Am(\tau(B))$, \smallskip
  
 \item[(3)]
 $  \lambda a.\, \lambda b.\, \Amb(\strictapp{\Left}{a},\strictapp{\Right}{b})\  : \ 
 \tau(B_0) \to \tau(B_1) \to \Am(\tau(B_0) + \tau(B_1))$,\smallskip
   
  \item[(4)]
  $\lambda a.\, \bot\ : \ 
  \tau(A) \to \tau(B)$, \smallskip
    
  \item[(5)]
  $\lambda a.\, \caseof{a} \{\Left(\_) \to \bot;\Right(b) \to b\}\ : \ 
  (\tau(A) + \tau(B)) \to \tau(B)$, \smallskip
    
    \item[(6)] The same as (5).
  \end{enumerate}
\end{lem}

\begin{proof}
(1) This is an immediate consequence of (Rest-bind) and (Rest-return).

(2)  Assume $\rt{A_0}{B}$, $\rt{A_1}{B}$, and $\neg\neg(A_0\lor A_1)$.
By the second assumption and the rule (Rest-stab) we have $\rt{\neg\neg A_1}{B}$.
Since, by the third assumption, we have $\neg A_0 \to \neg\neg A_1$, 
%it follows, by (Rest-antimon), $\rt{\neg A_0}{B}$. 
$\rt{\neg A_0}{B}$ follows by (Rest-antimon). 
Together with the first assumption and
the rule (Conc-lem), we get $\Set(B)$.

  (3) Since $A_i \to A_0\lor A_1$ ($i=0,1$), this is an immediate consequence of
of (Rest-mon) and (Class-orelim), i.e.\ (1) and (2).

(4) Immediate, from (Rest-efq) and (Rest-antimon).

(5)
Suppose that $A \lor B$.  If $A$, then $\rt{\neg A}{B}$ by (Rest-efq)  
and (Rest-antimon). If $B$, then $\rt{\neg A}{B}$ by (Rest-return).

(6)
Suppose $\rt{A_0}{(A \lor B)}$. 
By (Rest-antimon), $\rt{A_0 \land \neg A}{(A \lor B)}$.
By (Rest-antimon) and $(A \lor B) \to \rt{\neg A}{B}$, we have 
$(A \lor B) \to \rt{A_0 \land \neg A}{B}$.
Therefore, by (Rest-bind), $\rt{A_0 \land \neg A}{B}$.
\end{proof}
%\end{lem}

% \begin{lemma}\label{class-orelim}
%   The following variants of the rule Conc-lem,  which are
% concurrent forms of classical disjunction elimination, are derivable.
% %
% \[
%   \infer[\hbox{\rm Conc-class-orelim}]{
%   \Set(C)
% }{
%    C\ \rest\ A \ \ \ \  C\ \rest\ B   \ \ \ \  \neg\neg(A\lor B)
% }
% %
% \]
% %
% \[
% %
%   \infer[\hbox{\rm Conc-class-orelim-or}]{
%   \Set(C\lor D)
% }{
%  C\ \rest\ A\ \ \ \ \ D\ \rest\ B  \ \ \ \ \neg\neg(A\lor B)    
% }
% \]
% \end{lemma}
% \begin{proof}
% The first rule can be easily derived from (Conc-lem) using the rule (Rest-antimon)
% and (Rest-stab) and has the same realizer as (Conc-lem). The second rule follows
% from the first with (Rest-mon) and has the realizer
% %%%%
% %%%%$\neg A \to \neg \neg B$, $C \rest B \to C \rest \neg \neg B$ Therefore, $C \rest \neg A$.
% %
% %\[\AmbLR \eqdef 
% %    \lambda a.\,\lambda b.\,\Amb(\mapJust \Left\, a,\mapJust \Right\,b)\]
% \[\ambLR \eqdef 
%     \lambda a.\,\lambda b.\,\Amb(\strictapp{\Left}{a},\strictapp{\Right}{b})\,.\]
% \end{proof}


\begin{example}
  \label{ex-dprime}
Continuing Example~\ref{ex-d}, we modify $\D(x)$ to 
$$\D'(x) \eqdef  \rt{x\neq 0}{(x\leq 0 \lor x\geq 0)}\,.$$
%
%
A realizer of $\D'(x)$, which has type $\bool$, may or may not terminate
(non-termination occurs when $x = 0$).
However, in case of termination,  the result is guaranteed to 
realize $x\le 0 \lor x\ge 0$.
Note that, a realizer of $\D(x)$ also has type $\bool$ and may or may not terminate,
but there is no guarantee that
it realizes $x\le 0 \lor x\ge 0$ when it does terminate.
Nevertheless, 
%
%
$\D \subseteq \D'$ follows from (Rest-intro) 
(since $\D(x)$ is $x\ne 0\to x\le 0 \lor x\ge 0$, and 
$\neg x\ne 0\to x\le 0 \land x\ge 0$ is provable using stability of equality) 
and is realized by $\leftright$.
%
%
$\D' \subseteq \D$ holds trivially.
\end{example}
%
\begin{example}
\label{example-ConsSD}
%
This 
%% example 
builds on Examples~\ref{ex-d} and~\ref{ex-dprime}
and will be used in 
%% our main case study in 
Section~\ref{sec-gray}.
Let $\tent(x) = 1-2|x|$ and consider the predicates
$\E(x) \eqdef  \D(x) \land \D(\tent(x))$ and
%
%D(x) &\eqdef&  x\neq 0 \to (x\leq 0 \lor x\geq 0)\\
%% \mps{\UB{I find the name $\ConSD$ a bit intimidating (4 capital letters!)
%% Do we need the `X'?}}
\[
\ConSD(x)  \eqdef  \Set((x\leq 0 \lor x\geq 0) \lor |x| \leq 1/2).
\]
%% \begin{eqnarray*}
%% %
%% %D(x) &\eqdef&  x\neq 0 \to (x\leq 0 \lor x\geq 0)\\
%% \E(x) &\eqdef&  \D(x) \land \D(1-2|x|),\\ 
%% \ConSD(x)  &\eqdef&  \Set((x\leq 0 \lor x\geq 0) \lor |x| \leq 1/2).
%% \end{eqnarray*}
% 
We show $\E \subseteq \ConSD$:
%
From $\E(x)$ and Example~\ref{ex-dprime} we get $\D'(x)$ and $\D'(\tent(x))$
which unfolds to $\rt{x\neq 0}{(x\le 0  \lor x \ge 0 )}$ and 
$\rt{|x|\neq 1/2}{(|x| \geq 1/2  \lor |x| \leq 1/2 )}$. 
By Lemma \ref{class-orelim-sleep}~(6),
%% it follows 
$\rt{|x| < 1/2}{(|x| \leq 1/2)}$. 
%% $\D(1-2|x|)$ means $|x|\neq 1/2 \to (|x| \geq 1/2  \lor |x| \leq 1/2 )$.
%% Therefore, as well as $\D'$,  we have 
%% $(|x| \geq 1/2  \lor |x| \leq 1/2 )\, \rest\, |x|\neq 1/2$ 
%% and therefore $(|x| \leq 1/2)\, \rest\, |x| < 1/2$ by Lemma \ref{lem:sleep}.
%
Since $\neg\neg((x \ne 0) \lor |x| < 1/2)$, we have $\ConSD(x)$ 
by  %(Conc-class-orelim-or). 
Lemma \ref{class-orelim-sleep}~(3).
 Moreover, $\tau(\E) = \bool\times \bool$ and 
$\tau(\ConSD) = \Am(\tri)$  where $\tri \eqdef \bool + \one$.
The extracted realizer of $\E \subseteq \ConSD$ is
%The realizer of $\E \subseteq \ConSD$ corresponding to this proof is
% \mps{\HT{I wonder if we can rewrite $(\leftright\ a)$ to $a$ for $a:bool$}
% \UB{I think we need $\leftright$ since it's needed for rest-intro. $a$ could be $\Left(\bot)$.
% Then $a$ is defined, hence must realize the disjunction. Therefore, $\bot$ must 
% be replaced by $\Nil$.}}
%% \begin{align*}
%% &\conSD \eqdef \lambda c.\, \caseof{c} \{\Pair(a, b) \to  
%%    \Amb(\strictapp{\Left}{(\leftright\ a)},\\
%%   & \hspace*{4.2cm} 
%%   \strictapp{\Right}{(\caseof{b}\{\Left(\_) \to \bot; \Right(\_) \to \Nil\})})\}   
%% %&\hspace*{2.5cm}\ambLR\ (\leftright\ a)\   (\caseof{b}\{\Left(\_) \to \bot; \Right(\_) \to \Nil\})\}
%% \end{align*}
%
\begin{align*}
&\conSD \eqdef \lambda c.\, 
   \caseof{c} \{ \\
& \hspace*{7em} \Pair(a, b) \to  
                  \Amb(\strictapp{\Left}{(\leftright\ a)},\\
& \hspace*{15.7em}        \Right {\downarrow} 
                         (\caseof{b} \{\Left(\_) \to \bot;\\
& \hspace*{23.9em}                        \Right(\_) \to \Nil\}))\}   
\end{align*}
%
   %    \ambLR\ (\leftright\ a)\ (\restslp\ (\leftright\ b))\}
%% \[
%% \conSD = \lambda c. \caseof{c} \\ \{\Pair(a, b) \to 
%%       \ambLR\ (\leftright\ a)\ (\caseof{b}\{\Right(\_) \to \Nil\})\}
%% %      \ambLR\ (\leftright\ a)\ (\restslp\ (\leftright\ b))\}
%% \]
%which is 
of type $\tau(\E \subseteq \ConSD) =  \bool\times \bool \to \Am(\tri)$.
%
Explanation of this program:
$a$ is $\Left$ or $\Right$ depending on whether $x \leq 0$ or $x \geq 0$
but may also be $\bot$ if $x = 0$.
$b$ is $\Left$ or $\Right$ depending on whether $|x| \leq 1/2$ or $|x| \geq 1/2$ 
but may also be $\bot$ if $|x| = 1/2$.  Since $x = 0$ and $x = 1/2$ do not
happen simultaneously, by evaluating $a$ and $b$ concurrently, we obtain one of them
from which we can determine one of the cases $x \leq 0$, $x \geq 0$, or $|x| \leq 1/2$.
\end{example}









%\subsection{Soundness and program extraction}
\subsection{Soundness of extracted data}
\label{subsec:soundness}
%
In $\CFP$, we have a second Soundness Theorem 
%(Thm.~\ref{thm-soundnessII}) 
which ensures the correctness
of all computations, i.e.\ fair reduction paths, 
of an extracted program $M$. 
%provided the proven formula $A$ is 
%closed and 
%`admissible' as defined below.
%
More precisely, 
%correctness of $M$ means that
we show that 
if  $M$ realizes a $\CFP$ formula $A$ satisfying a certain syntactic 
admissibility condition (see below), 
then all $d\in\ddata(\val{M})$ 
realize the formula $A^-$ obtained from $A$ by deleting all concurrency 
operators $\Set$ 
%
and replacing every restriction by the corresponding implication
%(to be precise, $\rt{A}{B}$ is replaced by $A\to B$ if $A$ is Harrop
%and by $\neg\neg A \to B$ if $A$ is non-Harrop).
(Theorem~\ref{thm-soundnessII}). 
Hence, by Computational Adequacy, all computations of $M$ 
converge to a realizer of $A^-$ (Theorem~\ref{thm-pe}).
Since $A^-$ is an $\IFP$ formula, this shows that 
the realizability interpretation of $\CFP$ is faithful to
%the realizability interpretation 
that of
$\IFP$.
%
The proof of 
this result
%the Faithfulness Theorem (Theorem~\ref{thm-faithfulness}) 
requires some preparation.

Since the domain $D$ is algebraic (i.e.\ every element of $D$ is the 
directed supremum of compact elements), 
subdomains of $D$ can be charactrized as follows. 
%
\begin{lem}
\label{lem-subdom}
A subset $X\subseteq D$ is a subdomain of $D$ iff the following two conditions hold:
%
\begin{enumerate}
\item[(i)] 
For all $a\in D$, $a$ is in $X$ iff all compact approximations are in $X$.
\item[(ii)] If $a_0,b_0\in X$ are compact and consistent (in $D$), 
then $a_0\sqcup b_0\in X$.
\end{enumerate}
\end{lem}
%
\begin{proof}
The easy proof is omitted.
\end{proof}



We define coinductively two subsets of $D$. The first, $\Data$, disallows
the constructor $\Amb$ altogether, the second, $\regD$, disallows immediate
nestings of $\Amb$ and can be seen as a semantic counterpart to the syntactic
regularity property of types. 
We call elements of $\regD$ \emph{regular}.
%
\begin{eqnarray*}
\Data &\eqnu& 
  (
   \{\Nil\} \cup 
   (\Data\times \Data) \cup 
   (\Data+\Data) \cup 
   (\ftyp{D}{D}))_{\bot} \\
\regD &\eqnu& 
  (
   \{\Nil\} \cup 
   (\regD\times \regD) \cup 
   (\regD+\regD) \cup 
   (\ftyp{D}{D}) \cup\\
 &&\hspace{0.5em}  \Amb(\regD\setminus\Amb(D,D),\regD\setminus\Amb(D,D))
  )_{\bot} 
\end{eqnarray*}
%
%where $\regD\setminus\Amb$ is shorthand for $\regD\setminus\Amb(D,D)$.
%
Clearly, $\Data\subseteq\regD\subseteq D$.

\begin{lem}
\label{lem-regular}
%
\begin{enumerate}
%\item[]
\item[(1)]$\Data$ and $\regD$ are subdomains of $D$. % with $\Data\subseteq \regD$.
%
\item[(2)]$\rho\subseteq\Data$ for every type $\rho$ without $\Am$
under the assumption that $\alpha\subseteq\Data$ for every 
free type variable of $\rho$.
%
\item[(3)]$\rho\subseteq\regD$ for every (regular) type $\rho$
under the assumption that $\alpha\subseteq\regD$ for every 
free type variable of $\rho$.
%
\item[(4)] 
If all free predicate variables of $P$ are strictly positive, then 
$\rea(P)\subseteq\adummy{\regD}$, 
%for every $\CFP$ predicate $P$,
under the assumption that 
%$\reali{X}\subseteq\adummy{\alpha_X}$ and 
$\reali{X}\subseteq\adummy{\regD}$ and 
$\alpha_X\subseteq\regD$ for every 
free predicate variable $X$ of $P$.
%
\end{enumerate}
\end{lem}

\begin{proof}
The proof of Part (1) is easy using the characterization of subdomains 
in Lemma~\ref{lem-subdom}. We skip details..
%We skip the easy proof that $\Data$ and $\regD$ are subdomain of $D$ with $\Data\subseteq\regD$.
%\smallskip

Part~(2) is proven by structural induction on $\rho$.
%
For a type variable, this holds by assumption. 
For $\one, \rho\times\sigma,\rho+\sigma, \ftyp{\rho}{\sigma}$ it suffices to observe that
$\bot$, $\Nil$ and $\Fun(f)$ are data (for arbitrary $f\in[D\to D]$),
and that the constructors $\Pair,\Left,\Right$ preserve the property $\Data$.
%
To show that $\tfix{\alpha}{\rho}\subseteq\Data$ it suffices to show that
$\rho\subseteq \Data$ under the assumption that $\alpha\equiv\Data$. But this holds by 
the structural induction hypothesis.
%\smallskip

Part (3) is proven again by structural induction on $\rho$,
using the fact that for a determined type $\rho$ the non-bottom elements of 
$\tval{\rho}{\zeta}$ are not of the form $\Am(a)$. 
% with $\one$, $\Left$, $\Right$, $\Pair$, or $\Fun$.

%Part (4) follows immediately from (3) and Lemma~\ref{lem-realizers-typed}.

We prove Part (4) first with a strengthening of the assumption $\alpha_X\subseteq\regD$
to $\alpha_X\equiv\regD$ 
(keeping the assumption $\reali{X}\subseteq\adummy{\regD}$ unchanged).  
Under this strengthened assumption, $\reali{X}\subseteq\adummy{\alpha_X}$ and therefore
$\rea(P)\subseteq\adummy{\tau(P)}$, by Lemma~\ref{lem-realizers-typed}.
But $\tau(P)\subseteq \regD$, by Part (3).
%% %
To prove Part (4) in general, we observe that, since all free predicate variables
are s.p. in $P$,  $\rea(P)$ depends monotonically on $\alpha_X$.
Therefore, if $\alpha_X\subseteq\regD$, 
the inclusion $\rea(P)\subseteq \adummy{\regD}$ continues to hold.
This proves part (4) provided the assumption $\alpha_X\equiv\regD$ is consistent, 
that is, a type $\alpha_X$ satisfying it actually does exist.
But, by Part (1), $\regD$ is a subdomain of $D$ and hence a possible
value for $\alpha_X$.
\end{proof}
%}


\begin{lem}\label{lem-data-nonempty}
\begin{enumerate}
\item[(1)] $\ddata(a)$ is nonempty for all $a\in D$.
\item[(2)] If $a\in\Data$, then $\ddata(a) = \{a\}$.
%           If $a\in\Data$, then \UB{$a\in\ddata(a)$}.
\item[(3)] If $a\in\regD$, then $\ddata(a) \subseteq \Data$.
%
%% \item[(4)]
%%   %% Suppose that $a \in D$ belongs to a regular type.  The following (1) to (3) are equivalent.
%%   %% (1) $a = \bot$ or $a = \Amb(\bot, \bot)$;   
%% If $a \in \regD$, then the following are equivalent:
%%   (i) $a \in\{\bot,\Amb(\bot, \bot)\}$;   
%%   (ii) $\{\bot\} = \ddata(a)$;
%%   (iii) $\bot \in \ddata(a)$.
\end{enumerate}
\end{lem}
\begin{proof}

%% (1) Set $P(a,d)\eqdef$ `$d$ and $a$ are the suprema of increasing sequences
%% $(d_i)_{i\in\NN}$ and $(a_n)_{n\in\NN}$ such that $d_n\in\ddata(a_n)$ for all $n\in\NN$'. 
%% One easily shows $P(a,d)$ implies $d\in\ddata(a)$, by coinduction.
  
(1) For every nonempty finite increasing sequence 
$\vec a,a_n = a_0,\ldots,a_{n-1},a_n$ of compact
elements $a_i\in D$ ($i\le n$) we define $\cd{\vec a,a_n}\in D$ by recursion on 
the rank of $a_n$ (where the rank of a compact element of $D$ is defined 
as in the proof of Theorem~\ref{thm:dataconv}):
%% \UB{$\rk(a_n)$, where the rank function, $\rk$,
%% is defined as in the proof of Theorem~\ref{thm:dataconv}}:
\begin{itemize}
\item[] If $a_n\in\{\bot,\Nil,\Fun(f)\}$, then $\cd{\vec a,a_n} \eqdef a
_n$.
\item[] If $a_n=\Amb(b_n,c_n)$, then let 
$\vec b = b_0,\ldots,b_{n-1}$ and $\vec c = c_0,\ldots,c_{n-1}$
such that $a_i = \Amb(b_i,c_i)$ if $a_i\neq\bot$, and $b_i=c_i=\bot$, otherwise.
Now set 
\[ \cd{\vec a,a_n} \eqdef \left\{
\begin{array}{ll}
   \bot            & \hbox{if }b_n=c_n=\bot\\ 
%   \cd{\vec b,b_n} & \hbox{if $b_n\neq\bot$ and for all $i<n$, if $b_i=\bot$, then $c_i=\bot$}\\
    \cd{\vec b,b_n} & \hbox{if $b_n\neq\bot$ and, for all $i<n$, $b_i=\bot$ implies $c_i=\bot$}\\
    
   \cd{\vec c,c_n} & \hbox{otherwise}
\end{array}
\right.
\]
%% \item[] $\cd{\vec a,\Left(b_n)} \eqdef \Left(\cd{b_n})$ 
%% (where $\cd{b_n}$ means $\cd{\emptyseq,b_n}$ with $\emptyseq$ the empty sequence).
%% \item[] $\cd{\vec a,\Right(b_n)} \eqdef \Right(\cd{b_n})$.
%% \item[] $\cd{\vec a,\Pair(b_n,c_n)} \eqdef \Pair(\cd{b_n},\cd{c_n})$.
\item[] If $a_n=\Left(b_n)$, then let 
$\vec b = b_0,\ldots,b_{n-1}$ such that $a_i = \Left(b_i)$ if $a_i\neq\bot$, 
and $b_i=\bot$, otherwise.
Set $\cd{\vec a,a_n} \eqdef \Left(\cd{\vec b,b_n})$.
The cases that $a_n$ begins with $\Right$ or $\Pair$ are similar.
\end{itemize}
%
It is easy to see that 
%$\cd{\vec a,a_n}\in\ddata(a_n)$. Furthermore,
if $a_n\dle a_{n+1}$, then $\cd{\vec a,a_n}\dle\cd{\vec a,a_n,a_{n+1}}$.

Now let $a\in D$. Since $D$ is algebraic with a countable base, 
there exists an increasing sequence of compact elements, $(a_n)_{n\in\NN}$,  
that has $a$ as its supremum. 
We show that for
$d \eqdef \bigsqcup\{\cd{a_0,...a_{n-1},a_n}\mid n\in\NN\}$, 
we have $d\in\ddata(a)$. 
To this end, we define the relation `$d\in P(a)$' as
`$a$ is the supremum of an increasing sequence 
$(a_n)_{n\in\NN}$ of compact elements such that 
$d = \bigsqcup\{\cd{a_0,\ldots,a_{n-1},a_n}\mid n\in\NN\}$'
and prove:
%
\paragraph{Claim} 
%
%Set $P(a,d)\eqdef$ 
%
%\UB{$P(a) \subseteq \ddata(a)$ for all $a\in D$.} 
If $P(a,d)$ then $d\in\ddata(a)$, for all $d,a\in D$.

We prove the Claim by coinduction: Assume 
$d\in P(a)$.
%$P(a,d)$. 
We have to show that the right hand side of the definition of `$d\in\ddata$'
holds if $\ddata$ is replaced by $P$.
%
Let $a$ be the supremum of the increasing sequence $(a_n)_{n\in\NN}$ 
of compact elements.
%

\emph{Case $a=\Amb(b,c)$}.
%
Then, for some $m$, $a_k=\bot$ for all $k<m$ and $a_k=\Amb(b_k,c_k)$
for all $k\ge m$. Set $b_k=c_k=\bot$ for $k<m$.
%
If $b=c=\bot$ then $\cd{a_0,\ldots,a_{n-1},a_n}=\bot$ for all $k$ 
and therefore $d=\bot$ which is correct.
%
If $b$ and $c$ are not both $\bot$, then there is a least $n\ge m$ such that 
$a_n =\Amb(b_n,c_n)$ and
$b_n,c_n$ are not both $\bot$. 
%
If $b_n\neq\bot$, then 
$\cd{a_0,\ldots,a_{k-1},a_k}= \cd{b_0,\ldots,b_{k-1},b_k}$ for all $k\ge n$.
Since for $k<n$, $\cd{a_0,\ldots,a_{k-1},a_k}= \bot=\cd{b_0,\ldots,b_{k-1},b_k}$,
$d\in P(b)$ and we are done. 
%
If $b_n=\bot$, then $c_n\neq\bot$ and, with a similar argument,  
%
%$\cd{a_0,\ldots,a_{k-1},a_k}= \cd{c_0,\ldots,c_{k-1},c_k}$ for all $n$
%which implies that \UB{$d\in P(c)$} and we are done again. 
$\cd{a_0,\ldots,a_{k-1},a_k}= \cd{c_0,\ldots,c_{k-1},c_k}$ for all $k \geq n$
which implies that $P(c,d)$ holds and we are done again. 


The other cases are easy.

\medskip

(2) To show that $a\in\Data$ implies $\{a\}\subseteq\ddata(a)$, 
one sets $P(a,b) \eqdef a=b\in\Data$ and shows 
$P\subseteq\ddata$ by coinduction.

To show that  $a\in\Data$ implies $\ddata(a)\subseteq \{a\}$, 
one proves that for all compact $a_0\in D$,
if $a\in\Data$ and $d\in\ddata(a)$, then $a_0\dle a$ iff $a_0\dle d$. 
The proof can be done by induction
on $\rk(a_0)$. 

\medskip

(3) 
%This is easy and the proof is omitted.
One shows $\forall d\,(\exists a\in\regD\,(d\in\ddata(a)) \to d\in\Data)$
by coinduction.
%\medskip
%
\end{proof}
%
\begin{rem}
The proof of (1) is constructive since for every compact approximating sequence 
of $a$, a compact approximating sequence of some element in $\ddata(a)$ is constructed. 
In particular, if $a$ is computable, then $\ddata(a)$ contains a computable element. 
However, there can be no computable function $f:D\to D$ such that $f(a)\in\ddata(a)$ 
for all $a\in D$, since such a function cannot even be monotone: 
We would necessarily have $f(\Amb(0,\bot))=0$ and $f(\Amb(\bot,1))=1$, hence
$f$ would map the consistent inputs $\Amb(0,\bot)$ and $\Amb(\bot,1)$ 
(`consistent' meaning `having a supremum') to the inconsistent outputs $0$ and $1$,
which is impossible for a monotone function.
%$f(\Amb(0,1))$ cannot be defined such that $f$ is monotone.
\end{rem}
%
\begin{lem}
\label{lem-data-compact}
\begin{enumerate}
\item[(1)] If $a_0$ is compact (in $D$), 
then all elements of $\ddata(a_0)$ are compact.
\item[(2)] If $a_0$ is a compact approximation of $a$,
then for every $d_0\in\ddata(a_0)$ there exists 
some $d\in\ddata(a)$ such that $d_0\dle d$.
\item[(3)] If $a$ is regular and $d\in\ddata(a)$, 
then for every compact approximation $d_0$ of 
$d$ there exists a compact approximation $a_0$ of $a$ 
such that $d_0\in\ddata(a_0)$.
\item[(4)] If $a,b,c$ are compact such that $c = a\sqcup b$,
then for every $w\in\ddata(c)$, $w\in\ddata(a)\cup\ddata(b)$ or 
$w = u \sqcup v$ for some $u\in\ddata(a)$ and $v\in\ddata(b)$.
\end{enumerate}
\end{lem}

\begin{proof}
%
(1) Easy induction on $\rk(a_0)$.
\medskip

(2)
%
Induction on $\rk(a_0)$.
%
If $a_0\in\{\bot,\Amb(\bot,\bot)\}$, then $d_0=\bot$ 
and we can take $d$ to be any element of 
$\ddata(a)$ (which is nonempty, as shown in 
Lemma~\ref{lem-data-nonempty}~(1)).
%
If $a_0=\Amb(b_0,c_0)$ where, w.l.o.g., $b_0\neq\bot$ and $d_0\in\ddata(b_0)$, then,
since $a=\Amb(b,c)$ with $b_0\dle b$, by i.h.\ there is some $d\in\ddata(b)$ 
(hence also $d\in\ddata(a)$) with $d_0\dle d$.
%
The other cases are easy.
\medskip

(3) 
%
Induction on $\rk(d_0)$. 
The most complicated case is $a = \Amb(b,c)$ where $b\neq\bot$ and $d\in\ddata(b)$. 
Since $a$ is regular, $b$ starts with one of the 
constructors $\Fun,\Left,\Right,\Pair$.
W.o.l.g.\ assume $b=\Pair(b^1,b^2)$. Then $d=\Pair(d^1,d^2)$ with $d^i\in\ddata(b^i)$
and $d_0=\Pair(d^1_0,d^2_0)$ with $d^i_0\dle d^i$. 
By i.h.\ there are compact approximations
$b^i_0$ of $b^i$ such that $d^i_0\in\ddata(b^i_0)$. 
Hence $\Pair(d^1_0,d^2_0)\in\ddata(\Pair(b^1_0,b^2_0))$. 
Hence, $a_0 \eqdef \Amb(\Pair(b^1_0,b^2_0),\bot)$ is a compact approximation of $a$
with $d_0\in\ddata(a_0)$.
\medskip

(4) 
%
Induction on $\rk(c)$.
%
We assume that $a,b,c,w$ are all different from $\bot$, otherwise, the solution is easy.

Case $c=\Amb(c^1,c^2)$. 
Then $a=\Amb(a^1,a^2)$ and $b=\Amb(b^1,b^2)$ with $c^i = a^i\sqcup b^i$,
and, w.l.o.g., $c^1\neq\bot$ and $w\in\ddata(c^1)$.
By i.h., there are two cases: 
1. $w\in\ddata(a^1)\cup\ddata(b^1)$, say $w\in\ddata(a^1)$. 
Then $a^1\neq\bot$ and $w\in\ddata(a)$.
2. $w = u \sqcup v$ for some $u\in\ddata(a^1)$ and $v\in\ddata(b^1)$.
If $a^1=\bot$ or $b^1=\bot$, say $a^1=\bot$, then $u=\bot$ and $w=v$ and $w\in\ddata(b)$.
If $a^1$ and $b^1$ are both different from $\bot$, then $u\in\ddata(a)$ and $v\in\ddata(b)$ 
and we are done as well.

The other cases are easy.
\end{proof}


For the Faithfulness Theorem to hold, an admissibility condition
must be imposed on $A$ which we describe now.


A CFP formula is a \emph{fuctional implication} if it is of the form 
$A \to B$ where $A$ and $B$ are both non-Harrop 
(hence realizers of $A \to B$ are functions).

A CFP expression is \emph{quasi-closed} if it contains no free predicate variables. 

A $\CFP$ expression is \emph{admissible} if it is quasi-closed, 
the concurrency operator and restriction occur only at s.p.~positions,
every restriction $\rt{A}{B}$ has a Harrop premise $A$,
and every occurrence of a functional implication is part of a quasi-closed 
subexpression 
without $\Set$ and restriction.\footnote{The definition of admissibility in~\cite{CFPesop} is similar but disallows restrictions.}


For example, 
$\Set(\mu(\lambda X\,\lambda x\,(x=0 \lor \forall y\,(\NN(y)\to X(f(x,y))))))$
is admissible, whereas the expression
$\mu(\lambda X\,\lambda x\,\Set(x=0 \lor \forall y\,(\NN(y)\to X(f(x,y)))))$
is not since it contains 
%$\Set$ at a position which is captured by a functional implication
%($X$ is inside the functional implication $\NN(y)\to X(f(x,y))$).
the functional implication $\NN(y)\to X(f(x,y))$ for which the only quasi-closed
subexpression it is contained in is
$\lambda X\,\lambda x\,\Set(x=0 \lor \forall y\,(\NN(y)\to X(f(x,y)))))$
which does contain $\Set$.

Further examples of admissible expressions are the predicate
$\ConSD$ from Example~\ref{example-ConsSD}, 
$\lambda x\,\Set((x\leq 0 \lor x\geq 0) \lor |x| \leq 1/2)$,
as well as the coinductive predicate $\myC_2$ from Sect.~\ref{sec-gray},
$\nu(\lambda X\,\lambda x\,(|x|\le 1 \land \Set(\exists\, d (\SD(d) \land X(2x-d)))))$. 
%
%% \mps{\UB{I hope now it's correct.}}
\begin{thm}[Faithfulness]
\label{thm-faithfulness}
%
If $a\in D$ realizes an admissible formula $A$, 
%that does not contain restrictions, 
then all $d\in\ddata(a)$ realize $A^-$.

Formally, $\RCFP$ proves 
%$\forall\vec x\,\forall a\,(\rea(A)(a) \to \forall d\in\ddata(a)\,\rea(A^-)(d))$
$\forall\vec x\,\forall a\,(\rea(A)(a) \to \ddata(a)\subseteq \rea(A^-))$
where $\vec x$ are the free object variables of $A$.
%
\end{thm}
%
\begin{proof}
%
The proof is accomplished through a series of definitions and claims. 


We call a $\CFP$ expression \emph{parametrically admissible (p-admissible)}
if it satisfies the same conditions as an admissible expression except
that it is no longer required to be quasi-closed but s.p.\ occurrences 
of predicate variables are allowed.
Hence, a $\CFP$ expression is p-admissible iff 
%it contains no restriction, 
%
the concurrency operator $\Set$, restriction, 
and predicate variables occur only at s.p. positions,
every restriction has a Harrop premise,
and every occurrence of a functional implication is part of a quasi-closed
subexpression without $\Set$ or restriction.


A \emph{p-admissible type} is a type that contains type variables 
and $\Am$ only at s.p.\ positions and every function type is
part of a closed sub type without $\Am$.

%Claim 4.
Clearly, if $P$ is p-admissible, then $\tau(P)$ is p-admissible
(easy structural induction on $P$).


We call an $\RCFP$ predicate $P$ whose last argument place 
ranges over $D$ \emph{regular}
if $P(\vec x,a)$ implies that $a$ is regular.
More precisely, ``$P$ is regular'' stands for the formula 
$\forall\vec x\forall a\,(P(\vec x,a) \to \regD(a))$.



For any $\RCFP$ predicate $P$ whose last argument place ranges over $D$
we define a regular predicate $P'$ of the same arity by
%
\[P'(\vec x,a) \eqdef %\ddata(a)\neq\emptyset
                  a\in\regD \land 
                  \forall d\in\ddata(a)\, P(\vec x,d)\,.\]
%

We also define  
%
\[\ddata(P)(\vec x,d) \eqdef \exists a\in D\,(P(\vec x,a) \land d\in\ddata(a)).\]
%
Clearly, if $P$ is regular, then $P\subseteq Q'$ iff $\ddata(P)\subseteq Q$.

For the special case of a subdomain $\alpha$, considered as the unary predicate 
$\lambda a\,.\,a:\alpha$, 
$\ddata(\alpha) \equiv \bigcup\{\ddata(a)\mid a:\alpha\}$, 
and if $\alpha$ is regular, then
$\alpha\subseteq\beta'$ iff $\ddata(\alpha)\subseteq\beta$. 




%\paragraph{Claim 6.}
\paragraph{Claim 1.}
%
If $\alpha$ is a subdomain of $D$, 
%then $\alpha'$ is a regular subdomain of $D$.
then so is $\alpha'$.



\paragraph{Proof of Claim~1.}
%
Let $\alpha$ be a subdomain of $D$. 
We show that $\alpha'$ satisifies the 
characterizing properties (i) and (ii) of subdomains from Lemma~\ref{lem-subdom}.

(i) Let $a\in\alpha'$ and $a_0$ a compact approximation of $a$. We have to show that
$a_0\in\alpha'$. Hence assume $d_0\in\ddata(a_0)$. 
Then, by Lemma~\ref{lem-data-compact}~(2), 
there exists some $d\in\ddata(a)$ such that $d_0\dle d$.
Since $a\in\alpha'$, $d\in\alpha$. Hence $d_0\in\alpha$, since, being a subdomain, 
$\alpha$ is downward closed.
%
Conversely, assume all compact approximations of $a$ are in $\alpha'$ 
and let $d\in\ddata(a)$.
We have to show that $d\in\alpha$. Since $\alpha$ is a subdomain, 
it suffices to show that all
compact approximations of $d$ are in $\alpha$. 
Hence let $d_0$ be a compact approximation of $d$.
Then, by Lemma~\ref{lem-data-compact}~(3) 
(by Lemma~\ref{lem-regular}~(1), $a$ is regular since all its compact approximations are), 
there is  some compact approximation $a_0$ of $a$ 
such that $d_0\in\ddata(a_0)$. Since, by assumption, $a_0\in\alpha'$, 
it follows $d_0\in\alpha$.

(ii) Let $a_0,b_0$ be compact and consistent elements of $\alpha'$. 
We have to show that 
$c_0 \eqdef a_0\sqcup b_0 \in \alpha'$. Hence let $d_0\in\ddata(c_0)$.
By Lemma~\ref{lem-data-compact}~(4), $d_0\in\ddata(a_0)\cup\ddata(b_0)$, 
in which case $d_0\in\alpha$ since $a_0,b_0\in\alpha'$,
or there are $a_1\in\ddata(a_0)$ and 
$b_1\in\ddata(b_0)$ such that $d_0 = a_1 \sqcup b_1$, in which case, 
since $a_1,b_1\in\alpha$ and $\alpha$ is a subdomain, $d_0\in\alpha$ as well.
%since $a_0,b_0\in\alpha'$ and $\alpha$ is a subdomain, $c_1\in\alpha$ as well.
This completes the proof of Claim~1.
 
%
For any type $\rho$ and $i=1,2$ let $\variant{\rho}{i}$ be obtained 
from $\rho$ by replacing 
each free type variable $\alpha$ by the fresh type variable $\alpha_i$.
% (of course $\alpha_1\neq\beta_2$ for all $\alpha,\beta$ that are free in $\rho$).
%
Further, let $\rho^-$ be obtained from $\rho$ by deleting all occurrences of $\Am$.

%\paragraph{Claim 7.}
\paragraph{Claim 2.}
%
For every p-admissible type $\rho$,
$\variant{\rho}{1}\subseteq \variant{\rho^-}{2}'$ 
under the assumption that 
%$\alpha_1$ and $\alpha_2$ are regular subdomains with 
$\alpha_i\subseteq\regD$ ($i=1,2$) 
and
$\alpha_1\subseteq\alpha_2'$
for every free type variable $\alpha$ of $\rho$.

%\paragraph{Proof of Claim 7.}
\paragraph{Proof of Claim 2.}
%
Induction on $\rho$. 

If $\rho$ is closed and doesn't contain $\Am$ 
(by p-admissibility, this includes the case that $\rho$ is a function type),
then $\variant{\rho}{1} = \variant{\rho^-}{2} = \rho$ and, 
by 
Lemma~\ref{lem-regular}~(2)
%Claim~3, 
$\rho\subseteq\Data$.
Hence 
%$\ddata(\rho) \equiv \rho$ 
$\ddata(\rho)\subseteq\rho$, by Lemma~\ref{lem-data-nonempty}~(2),  
and we are done.

Now assume that the above case does not apply.

If $\rho$ is a type variable $\alpha$, then 
$\variant{\rho}{1} = \alpha_1 \subseteq \alpha_2' = \variant{\rho^-}{2}'$.

If $\rho = \Am(\sigma)$, then $\rho^- = \sigma^-$ and, by the i.h.,\ 
$\variant{\sigma}{1} \subseteq \variant{\sigma^-}{2}'$. 
%
Let $a:\variant{\rho}{1}$. Then either $a=\bot$, 
in which case $\ddata(a) = \{\bot\} \subseteq\variant{\sigma^-}{2}$,
or else $a=\Amb(b,c)$ with $b,c:\variant{\sigma}{1}$, in which case 
$\ddata(a) = \ddata(b) \cup \ddata(c) \subseteq \variant{\sigma^-}{2}$.

If $\rho=\tfix{\alpha}{\sigma}$, then we have, up to bound renaming, 
$\variant{\rho}{1} = \tfix{\alpha_1}{\variant{\sigma}{1}}$ and
$\variant{\rho^-}{2} = \tfix{\alpha_2}{\variant{\sigma^-}{2}}$.
%We have to show $\rho_1\subseteq \rho_2^-'$. 
Since $\variant{\rho^-}{2}$ is a subdomain and hence, by Claim~1, 
%Claim~6, 
so is $\variant{\rho^-}{2}'$, we can set
\begin{enumerate}
\item[] (1) $\alpha_1 \equiv \variant{\rho^-}{2}'$ 
\end{enumerate}
%
and achieve our goal (of proving $\variant{\rho}{1}\subseteq \variant{\rho^-}{2}'$) 
by proving $\variant{\sigma}{1} \subseteq \alpha_1$.
Setting further
\begin{enumerate}
\item[] (2) $\alpha_2 \equiv \variant{\rho^-}{2}$
\end{enumerate}
%
we have $\alpha_1\subseteq\alpha_2'$ and therefore, by the induction hypothesis,
($\variant{\rho^-}{2}'$ and $\variant{\rho^-}{2}$ are both regular subdomains,
and $\sigma$ is p-admissible, 
since otherwise we would be in the first case),
$\variant{\sigma}{1}\subseteq \variant{\sigma^-}{2}'$. 
We further have $\variant{\sigma^-}{2} \equiv \variant{\rho^-}{2}$, by (2).
%
Therefore,
%
\[ \variant{\sigma}{1}\subseteq\variant{\sigma^-}{2}' \equiv  
\variant{\rho^-}{2}' \equiv \alpha_1.\]
%

The cases that $\rho$ is a product or a sum are easy.
This completes the proof of Claim~2.

For any $\CFP$ predicate $P$ and $i=1,2$,
let $\variant{\rea(P)}{i}$ be obtained from $\rea(P)$ 
by replacing 
each free predicate variable $\reali{X}$ by
the fresh predicate variable $\reali{X}_i$
and
each free type variable $\alpha_X$
by the fresh type variable $(\alpha_X)_i$. 

% (of course $\alpha_1\neq\beta_2$ for all $\alpha,\beta$ that are free in $\rho$).

%\paragraph{Claim 8.}
\paragraph{Claim 3.}
%
If $P$ is p-admissible, then
%For every p-admissible $\CFP$ predicate $P$,
$\variant{\rea(P)}{1}\subseteq \variant{\rea(P^-)}{2}'$ 
under the assumption that 
$(\alpha_X)_i\subseteq\regD$ 
%and $\reali{X}_i\subseteq\adummy{(\alpha_X)_i}$ 
($i=1,2$),
and furthermore $(\alpha_X)_1\subseteq(\alpha_X)_2'$ 
and $\reali{X}_1 \subseteq \reali{X}_2'$, 
for every free predicate variable $X$ of $P$.


%\paragraph{Proof of Claim 8.}
\paragraph{Proof of Claim 3.}
If $P$ is a Harrop predicate, then it contains neither free predicate variables,
nor $\Set$, nor restriction, and therefore 
$\variant{\rea(P)}{1}=\variant{\rea(P^-)}{2} = \reah(P)$.
% at all.
Hence, the required inclusion reduces to % the implication
%
$\forall a\,((a =\Nil\land\reah(P)) \to \forall d\in\ddata(a)\,(d=\Nil \land\reah(P)))$, 
%
which is a triviality since $\ddata(\Nil)=\{\Nil\}$.

From now on we assume that $P$ is non-Harrop. 

If $P$ is quasi-closed and contains neither $\Set$ nor restriction 
(because of p-admissibility, this includes the case that $P$ 
is a functional implication), then $\rea(P)$ is quasi-closed and $P = P^-$.
Therefore, $\variant{\rea(P)}{1}= \variant{\rea(P^-)}{2} = \rea(P)$.
By Lemma~\ref{lem-regular}~(2) and Lemma~\ref{lem-realizers-typed}, 
$\rea(P)\subseteq\Data$. Hence $\ddata(\rea(P)) = \rea(P)$ 
%, by Lemma~\ref{lem:ddatabot}~(4),
by Lemma~\ref{lem-data-nonempty}~(2),
%Claim~2, 
and we are done.

If $P$ is a predicate variable $X$, then we have to prove
%
$\reali{X}_1\subseteq\reali{X}_2'$ which holds by the assumption.

From now on we assume that none of the above cases applies.

If $P$ is 
%an implication 
$A \to B$, then $A$ has  no free predicate variables
and $B$ is non-Harrop.
%
%\emph{Case $A$ is Harrop}.
Since the case of a functional implication is excluded, $A$ must be Harrop.
Assume $\variant{\rea(A\to B)}{1}(b)$, that is, $b:\variant{\tau(B)}{1}$ and 
$\reah(A) \to \variant{\rea(B)}{1}(b)$.
We have to show $\variant{\rea(A\to B^-)}{2}'(b)$, that is,  
$b\in\regD$ and 
$\forall d\in\ddata(b)\,\variant{\rea(A\to B^-)}{2}(d)$, that is, for all
$d\in\ddata(b)$, $d : \variant{\tau(B^-)}{2}$ and 
$\reah(A) \to \variant{\rea(B^-)}{2}(d)$.
%
$b\in\regD$ holds since, 
%by Claim~7, 
by Claim~2, 
$\variant{\tau(B)}{1}\subseteq\variant{\tau(B)^-}{2}'\subseteq\regD$, 
and $\tau(B^-)=\tau(B)^-$.
%
Let $d\in\ddata(b)$.
$d : \variant{\tau(B^-)}{2}$ holds,
since, by 
%Claim~7,  
Claim~2,  
$b:\variant{\tau(B^-)}{2}'$ 
(to apply Claim~2 we need the assumptions $\alpha_1\subseteq\alpha_2'$).
Assume $\reah(A)$. Then $\variant{\rea(B)}{1}(b)$ and, 
by the structural induction hypothesis (clearly, $B$ is again p-admissible), 
$\variant{\rea(B^-)}{2}(d)$.


If $P$ is $\rt{A}{B}$ where $A$ is a Harrop formula, then $P^-$ is $A \to B^-$.
Assume $\variant{\rea(P)}{1}(b)$. 
Then, clearly, $\variant{\rea(A\to B)}{1}(b)$. 
Hence, the rest of the proof is exactly as in the previous case.


If $P$ is $\Set(B)$, then 
%\rea(B)(\zeta,\zeta_0))
$\variant{\rea(P^-)}{2} = \variant{\rea(B^-)}{2}$ and,  
since $B$ is again p-admissible, by the induction hypothesis,
$\variant{\rea(B)}{1} \subseteq \variant{\rea(B^-)}{2}'$
Assume $\variant{\rea(P)}{1}(c)$ and $d\in\ddata(c)$.
Then $c = \Amb(a,b)$ with $a,b : \variant{\tau(B)}{1}$ and 
\[(a \neq\bot \land d\in\ddata(a) \land \variant{\rea(B)}{1}(a))\lor 
  (b \neq\bot \land d\in\ddata(b) \land \variant{\rea(B)}{1}(b)).\]
%
In either case, it follows $\variant{\rea(B^-)}{2}(d)$.


If $P$ is $\mu\,(\lambda X\,.\,Q)$, 
then $\rea(P)$ is 
$\mu(\lambda\reali{X}\,.\,\rea(Q)[\tfix{\alpha_X}{\tau(Q)}/\alpha_X])$
whereas $\rea(P^-)$ is 
$\mu(\lambda\reali{X}\,.\,\rea(Q^-)[\tfix{\alpha_X}{\tau(Q^-)}/\alpha_X])$.
Hence, setting 
\begin{itemize}
\item[] $(\alpha_X)_1 \equiv\variant{(\tfix{\alpha_X}{\tau(Q)})}{1}$
\item[] $(\alpha_X)_2 \equiv\variant{(\tfix{\alpha_X}{\tau(Q^-)})}{2}$
\end{itemize} 
we have
$\variant{\rea(P)}{1} \equiv \mu(\lambda\reali{X}_1\,.\,\variant{\rea(Q)}{1})$,
and 
$\variant{\rea(P^-)}{2} \equiv \mu(\lambda\reali{X}_2\,.\,\variant{\rea(Q^-)}{2})$. 
%with $\theta_1 := \theta_0[\alpha_X\mapsto\tfix{\alpha_X}{\tau(Q^-)\theta_0}]$,
%$\rea(P^-)(\theta,\theta_0) = \mu(\lambda\reali{X}\,.\,\rea(Q^-)(\theta,\theta_1))$.
Therefore, we can prove the assertion of Claim~3
(which is $\variant{\rea(P)}{1} \subseteq \variant{\rea(P^-)}{2}'$)
%s{\UB{`strong' no longer needed}}  
by s.p.\ induction %\HT{(\cite{SchwichtenbergWainer12, IFP})}, 
i.e.,
%with $P_1 : = \rea(P^-)(\theta,\theta_1)$, 
it suffices to show $\variant{\rea(Q)}{1} \subseteq \variant{\rea(P^-)}{2}'$
under the assumption 
%
\begin{itemize}
\item[] $\reali{X}_1 \equiv \variant{\rea(P^-)}{2}'$.
\end{itemize}
%where $\Delta\,\alpha := \{ (\vec x,a) \mid \lapha \}$.
Setting further 
\begin{itemize}
\item[] $\reali{X}_2 \equiv \variant{\rea(P^-)}{2}$
\end{itemize} 
we have $\reali{X}_1 \subseteq (\reali{X}_2)'$, trivially, and furthermore,  
%by Claim~7, 
by Claim~2,  
$(\alpha_X)_1 \subseteq ((\alpha_X)_2)'$ since 
$(\tfix{\alpha_X}{\tau(Q)})^-=\tfix{\alpha_X}{\tau(Q^-)}$.
Therefore, by the structural induction hypothesis
($Q$ is p-admissible since otherwise we would be in the second case),
$\variant{\rea(Q)}{1} \subseteq \variant{\rea(Q^-)}{2}'$. 
By the closure axiom, 
$\variant{\rea(Q^-)}{2}\subseteq \reali{X}_2$. 
Hence, $\variant{\rea(Q^-)}{2}' \subseteq (\reali{X}_2)'$
by the monotonicity of the operation $\cdot'$.
But $(\reali{X}_2)' \equiv \variant{\rea(P^-)}{2}'$.

If $P$ is $\nu\,(\lambda X\,.\,Q)$, then we work with $\ddata(\cdot)$ 
instead of $\cdot'$
using the earlier mentioned fact that 
if $Y \subseteq \regD$, then
$Y \subseteq Z'$ iff $\ddata(Y) \subseteq Z$.
%
Since the condition $\reali{Y}_1 \subseteq\reali{Y}_2'$ implies that 
$\reali{Y}_1\subseteq\adummy{\regD}$ for all free predicate variables $Y$ of $P$,
and these variables are all s.p., Lemma~\ref{lem-regular}~(4) yields that 
% and Lemma~\ref{lem-realizers-typed},}  
$\variant{\rea(P)}{1} \subseteq\regD$. 
%\UB{(here we use the assumptions $\reali{X}_1 \subseteq \Delta\,(\alpha_X)_1$,
%however, only to prove regularity)},
Therefore,
the assertion to be proven is equivalent to 
$\ddata(\variant{\rea(P)}{1}) \subseteq \variant{\rea(P^-)}{2}$.
%
%
%We have that
$\rea(P)$ is $\nu(\lambda\reali{X}\,.\,\rea(Q)[\tfix{\alpha_X}{\tau(Q)}/\alpha_X])$
and $\rea(P^-)$ is 
$\nu(\lambda\reali{X}\,.\,\rea(Q^-)[\tfix{\alpha_X}{\tau(Q^-)}/\alpha_X])$.
%
This means that, setting $(\alpha_X)_i$ as before, we have that
$\variant{\rea(P)}{1} \equiv \nu(\lambda\reali{X}_1\,.\,\variant{\rea(Q)}{1})$,
and 
$\variant{\rea(P^-)}{2} \equiv \nu(\lambda\reali{X}_2\,.\,\variant{\rea(Q^-)}{2})$. 
%
Therefore, 
$\ddata(\variant{\rea(P)}{1}) \subseteq \variant{\rea(P^-)}{2}$ can be proven
by 
%\mps{\UB{`strong' no longer needed}}  
%strong 
s.p.\ coinduction, that is, we show 
$\ddata(\variant{\rea(P)}{1}) \subseteq \variant{\rea(Q^-)}{2}$
under the assumption 
%
\begin{itemize}
\item[] $\reali{X}_2 \equiv \ddata(\variant{\rea(P)}{1})$.
\end{itemize}
%
Setting 
%
\begin{itemize}
\item[] $\reali{X}_1 \equiv \variant{\rea(P)}{1}$
\end{itemize} 
we have 
%
$\ddata(\reali{X}_1) \subseteq \reali{X_2}$, 
hence $\reali{X}_1 \subseteq \reali{X_2}'$, 
since $\variant{\rea(P)}{1} \subseteq\regD$.
%
Therefore, by the structural induction hypothesis,
$\variant{\rea(Q)}{1} \subseteq \variant{\rea(Q^-)}{2}'$,  i.e.\ 
$\ddata(\variant{\rea(Q)}{1}) \subseteq \variant{\rea(Q^-)}{2}$.
%
Finally, by the coclosure axiom, 
$\reali{X}_1 \subseteq \variant{\rea(Q)}{1}$ and therefore,
by the monotonicity of the operation $\ddata(\cdot)$, we get
$\ddata(\variant{\rea(P)}{1}) \subseteq \ddata(\variant{\rea(Q)}{1})$.



\paragraph{Proof of the Faithfulness Theorem.}
%
The theorem is a special case of 
%Claim~8:
Claim~3:
%
If $a\in D$ realizes the admissible formula $A$, 
then, by 
%Claim~8, 
Claim~3, 
$\rea(A^-)'(a)$ and therefore
all $d\in\ddata(a)$ realize $A^-$.
%
\end{proof}
\bigskip

Theorems~\ref{thm-soundnessI} and~\ref{thm-faithfulness} imply:
%
 \begin{thm}[Soundness Theorem II]
 \label{thm-soundnessII}
 %
 From a $\CFP$ proof of an admissible %data 
formula $A$ from a set of axioms one can extract a 
program $M :\tau(A)$ such that 
$\RCFP$ proves 
$\forall d\in\ddata(\val{M})\,\ire{d}{A^-}$ from the same axioms.
%
\end{thm}
%
Theorems~\ref{thm-soundnessII} and~\ref{thm:data}, together with 
and classical soundness yield:
%(see Sect.~\ref{sub-tarski}), yield:
%
\begin{thm}[Program Extraction]
  \label{thm-pe}
 %
 From a $\CFP$ proof of an admissible 
formula $A$ from a set of axioms
one can extract a 
%% closed ?  
program $M:\tau(A)$ such that for any 
%% fair 
computation 
%% path 
$M =  M_0 \newprintp M_1 \newprintp  \ldots$,
%% of $M$, 
the limit, $\sqcup_{i \in \NN} (M_i)_{D}$, realizes  $A^-$ in every  
model of the axioms.

% In addition, if $\tau(A)$ contains no function types, each  $(M_i)_{D}$ is a compact
% data constructor element, and the $(M_j)_{D}$ with $j > i$ are obtained 
% by filling some $\bot$s in $(M_i)_{D}$  %$((M_i)_{D})_i$
%  with data constructor elements.
\end{thm}

 
\begin{rem}
The theorems above can be generalized by weakening the  admissibility condition 
in two ways: 

(1) The condition that restrictions must have Harrop premises may be dropped.
The definition of $A^-$ must then be modified by replacing $\rt{A}{B}$, where
$A$ is non-Harrop, by $\neg\neg A \to B$ (instead of $A\to B$). 
Since, by the the rules (rest-antimon) and
(rest-stab), the formulas $\rt{A}{B}$ and $\rt{\neg\neg A}{B}$ are equivalent 
and, moreover, have the same realizers, 
the proof of Theorem~\ref{thm-faithfulness} requires
only minimal changes and the Theorems~\ref{thm-soundnessII} and~\ref{thm-pe}
are unchanged.
 
(2) Arbitrary free predicate variables may be permitted. The statement of
Theorems~\ref{thm-faithfulness} and~\ref{thm-soundnessII} are then to be
modified by adding the assumptions $\reali{Y}\subseteq\adummy{\Data}$ 
and $\alpha_Y\subseteq\Data$
for all
free predicate variables $Y$ of $A$. 
%
In the proof of Theorem~\ref{thm-faithfulness}, 
the definition of $\variant{\rho}{i}$,
used in Claim~2, refers only to other free type variables
of $\rho$.
%
Claim~3 is modified in a similar way. 
%
The proof hinges on the fact that for $a\in\Data$, $\ddata(a)=\{a\}$ 
(Lemma~\ref{lem-data-nonempty}~(2)).
%
Generalization (2) applies to Theorem~\ref{thm-pe} only in the restricted
form that free predicate variable must not occur at strictly positive positions. 
This is necessary, since the extracted program $M$ must be closed.
%
\end{rem}

