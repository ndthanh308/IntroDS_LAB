We define a small-step operational semantics 
that, in the limit, reduces each closed program $M$ nondeterministically
to an element in $\ddata(\val{M})$ (Theorem~\ref{thm:data}). 
%% Under some typability condition
%% for $M$ (which is satisfied in all non-pathological situations) 
If $M$ has a regular type, the converse holds as well: 
For every $d\in\ddata(\val{M})$ there exists
a reduction sequence for $M$ computing $d$ in the limit 
(Theorem~\ref{thm:dataconv}).
If $M$ denotes a compact data, then the limit is obtained 
after finitely many reductions.
%
In the following, all programs and types are assumed to be closed.

\subsection{Reduction to weak head normal form}
%
A program is called a \emph{weak head normal form (w.h.n.f.)} if it
 begins with a constructor 
(including $\Amb$), %$\Just$ and 
or has the form $\lambda a. M$.
In Table \ref{table:reduction},
we inductively define 
a 
small-step leftmost-outermost reduction 
relation $\ssp$ on 
%% closed  
programs.
%
%\bigskip

\begin{table}
\fbox{
\begin{minipage}{\textwidth}
\noindent Rules of $\ssp$:  
\medbreak
\begin{quote}
\begin{enumerate}%[\itemsep=0.2cm \itemindent=0.2cm]
\setlength{\itemsep}{0.2cm}
\setlength{\itemindent}{0.4cm}
  % 
\item[(s-i)] $(\lambda a.\,M)\ N \ssp M[N/a]$
%
\item[(s-ii)] \AxiomC{$M \ssp M'$}
            \UnaryInfC{$M\,N \ssp M'\,N$}
            \DisplayProof 
%
\item[(s-iii)]  $\strictapp{(\lambda a.\,M)}{N} \ssp M[N/a]$ \quad 
if $N$ is a w.h.n.f.

\item[(s-iv)] \AxiomC{$M \ssp M'$}
            \UnaryInfC{$\strictapp{M}{N} \ssp \strictapp{M'}{N}$}   
            \DisplayProof  \quad  
if $N$ is a w.h.n.f.
%
\item[(s-v)]  \AxiomC{$N \ssp N'$}
            \UnaryInfC{$\strictapp{M}{N} \ssp \strictapp{M}{N'}$}
            \DisplayProof 
%
\item[(s-vi)] $\rec\,M \ssp M\,(\rec\,M)$
%
\item[(s-vii)] $\caseof{C(\vec M)} \{\ldots;C(\vec b)\to N;\ldots\}\ssp  N[\vec M/\vec b]$\\
 \hspace*{4cm}($C$ ranges over constructors including $\Amb$)

%
\item[(s-viii)] \AxiomC{$M \ssp M'$}
             \UnaryInfC{$\caseof{M}\{\vec{Cl}\}\ssp 
               \caseof{M'}\{\vec{Cl}\}$}
            \DisplayProof 
%
\item[(s-ix)] $M \ssp \bot$ \quad if $M$ is $\bot$-like (see below)
\end{enumerate}
\end{quote}

\bigskip
\noindent Rules of $\newprintc$:
\begin{quote}
\begin{enumerate}
  \setlength{\itemsep}{0.2cm}
  \setlength{\itemindent}{0.4cm}
  \item[(c-i)] \AxiomC{$M \ssp M' $} 
  \UnaryInfC{$M \newprintc M'$}
  \DisplayProof 
  
  \item[(c-ii)] 
  \AxiomC{$M_1 \ssp M_1'$}  
  \UnaryInfC{$\Amb(M_1,M_2) \newprintc \Amb(M_1',M_2)$}
  \DisplayProof 
  \item[(c-ii')] 
  \AxiomC{$M_2 \ssp M_2'$}  
  \UnaryInfC{$\Amb(M_1,M_2) \newprintc \Amb(M_1,M_2')$}
  \DisplayProof 
  \item[(c-iii)] 
    $\Amb(M_1, M_2) \newprintc M_1$  \ 
  if $M_1$ is a w.h.n.f.
    
  \item[(c-iii')] 
    $\Amb(M_1, M_2) \newprintc M_2$  \ 
  if $M_2$ is a w.h.n.f.
  \end{enumerate}
\end{quote}

\bigskip
\noindent Rules of $\newprintp$:
  \begin{quote}
  \begin{enumerate}%[\itemsep=0.2cm \itemindent=0.2cm]
    \setlength{\itemsep}{0.2cm}
    \setlength{\itemindent}{0.4cm}
    \item[(p-i)]
    \AxiomC{$M \newprintc M' $} 
    \UnaryInfC{$M \newprintp M'$}
    \DisplayProof 
    %
    \item[(p-ii)]
    \AxiomC{$M_i \newprintp M_i'$ $(i = 1,\ldots, k)$} 
    \UnaryInfC{$C(M_1,\ldots,M_k) \newprintp C(M_1',\ldots,,M_k')$}
    \DisplayProof 
    %($C\in\mathrm{C_d}$) 
    ($C\in\datacons$)  % data constructor, not $\Amb$)}
    \\%[1em] 
    %
    \item[(p-iii)]
    %$M \newprintp M$ \hspace{.5cm} otherwise.
      $\lambda a.\,M \newprintp \lambda a.\,M$ 
  \end{enumerate}
\end{quote}      

\bigskip
$\bot$-like programs are such that their syntactic %form immediately implies that
forms immediately imply that
they denote $\bot$, more precisely they are of the form  $\bot$,
$C(\vec M)\,N$, $\strictapp{C(\vec M)}{N}$, 
and $\caseof{M}\,\{\ldots\}$ where $M$ is a lambda-abstraction or
of the form $C(\vec M)$ such that there is no clause in $\{\ldots\}$ 
which is of the form $C(\vec a) \to N$. 
%% Note that 
W.h.n.f.s 
%w.h.n.fs 
are never $\bot$-like, and the only typeable $\bot$-like
program is $\bot$.

\end{minipage}
}
\caption{
Operational semantics of programs
%Reduction rules.
\label{table:reduction}}
\end{table}
%

\begin{lem}\label{lem:ssp}
%% Let $M$ be a 
%% closed 
%% program.
\begin{enumerate}
\item[(1)] $\ssp$ is deterministic (i.e., $M \ssp M'$ for at most one $M'$).
\item[(2)] $\ssp$ preserves the denotational semantics 
(i.e., 
%$M = M'$ 
$\val{M} = \val{M'}$ 
if $M \ssp M'$).
\item[(3)] $M$ is a $\ssp$-normal form iff $M$ is a  
w.h.n.f.  
% v.w.h.n.f.  
%\HT{For a typable term $M$,} 
\item[(4)] [Adequacy Lemma]\label{lem:ade}
  If $\val{M} \ne \bot$, then there is a 
w.h.n.f.~$V$ 
%v.w.h.n.f.~$V$ 
s.t.\ $M \ssp^* V$.
\end{enumerate}
\begin{proof}
  (1) to (3) are easy.
  The proof of (4) is standard and is 
  as the proof of Lemma~33 in \cite{IFP} 
  for the case that $M$ begins with a constructor, 
  and an easy consequence of Lemma~32 in \cite{IFP}
  for the case that $M$ is a $\lambda$-abstraction. 
\end{proof}
\end{lem}


\subsection{Making choices}
%
Next, we define the reduction relation $\newprintc$ (`c' for 'choice') 
that reduces 
arguments of $\Amb$ in parallel
as in  Table \ref{table:reduction}. 
%
From this definition and Lemma \ref{lem:ssp}, it is immediate that
$M$ is a $\newprintc$-normal form iff $M$ is a 
\emph{deterministic weak head normal form (d.w.h.n.f.)}, that is,
a w.h.n.f.\ that does not begin with $\Amb$.

Finally, we define a reduction relation $\newprintp$ 
that reduces arguments of data constructors in parallel.
%
Every (closed) 
program reduces under $\newprintp$
(easy proof by structural induction). 
For example, $\Nil\newprintp \Nil$ %$\Nil\newprintpl{\emptyset} \Nil$
 by (p-ii). In the following, all $\newprintp$-reduction sequences are assumed 
to be infinite.


%
We call a $\newprintp$-reduction sequence 
\emph{unfair} if, intuitively, from some point on, one side of an 
$\Amb$ term is permanently reduced but not the other. 
More precisely, we inductively  define 
%an infinite reduction sequence 
$M_1\newprintp M_2 \newprintp \ldots$ to be unfair if
\begin{itemize}
%
\item each $M_i$ is of the form $\Amb(L_i,R)$ (with fixed $R$) 
and $L_i \ssp L_{i+1}$, or  
%$L_i \ssp^{(l_i)}L_{i+1}$, or 
%with $l_i>0$, or
%
\item each $M_i$ is of the form $\Amb(L,R_i)$ (with fixed $L$) and
$R_i \ssp R_{i+1}$, or   
%$R_i \ssp^{(r_i)}R_{i+1}$, or 
%with $r_i>0$, or
%
\item each $M_i$ is of the form $C(N_{i,1},\ldots,N_{i,n})$ 
(with a fixed $n$-ary data constructor $C$) and $N_{1,k} \newprintp N_{2,k}\newprintp \ldots$
is unfair for some $k$, or
%
\item the tail of the sequence, $M_2\newprintp M_3\ldots$, is unfair.
%
\end{itemize}
%
A $\newprintp$-reduction sequence is \emph{fair} if it is not unfair.




A {\em computation} of $M$ is an infinite fair sequence 
$M = M_0 \newprintp M_1 \newprintp \ldots$.  
Intuitively,  
computation proceeds as follows:
%reduction by $\newprintp$ proceeds as follows:
A program $L$ is head reduced by $\ssp$ to a 
w.h.n.f.\ $L'$, 
% v.w.h.n.f. $L'$, 
and
if $L'$ is a data constructor term, all arguments are reduced in parallel by (p-ii).
If $L'$ has the form $\Amb(M, N)$, 
two concurrent threads 
are invoked for the reductions of $M$ and $N$ in parallel, 
and the one reduced to a 
w.h.n.f.\ first is used. 
%
Fairness corresponds to the fact that the `speed' of each thread is positive
which means, in particular, that no thread can block another.
%
Note that $\newprintc$ is not used for the reductions of 
$M$ and $N$ in (s-ii), (s-iv), (s-v) and (s-viii).
This means that  $\newprintc$ is applied only to the outermost redex.
%
Also, (c-ii) is 
defined through $\ssp$, not $\newprintc$,  %$\newprintcl{S}$
and thus no thread creates new threads.
%
This ability to limit the bound of threads was not available
in an earlier version of this language~\cite{BergerCSL16}
(see also the discussion in Section~\ref{sub-related}).
%


\subsection{Computational adequacy:
  Matching denotational and operational semantics}
%% For a closed program $M$, 
We define 
${M}_{{D}} \in {D}$ by structural induction on programs:
%
%%  \mps{\HT{it was '$C$ is  a  dta constructor'}}
\begin{align*}
{C(M_1,\ldots,M_k)}_{D} &= C({M_1}_{D},\ldots, {M_k}_{D})
%& (C\in \mathrm{C_d})\\ 
%&  \hbox{\HT{($C$ a data constructor)}}\\
&  \hbox{($C\in\datacons$)}\\
{(\lambda a. M) }_{D} &= \val{\lambda a. M}   \\
{M}_{D} &= \bot  & \mbox{otherwise}
\end{align*}
Since clearly $M \newprintp N$ implies $M_{D} \sqsubseteq_{D} N_{D}$,
for every computation sequence $ M_0 \newprintp M_1 \newprintp  \ldots$,  
  the sequence $((M_i)_{D})_{i \in \NN}$ is increasing and therefore
  has a least upper bound in $D$. % $\sqcup S_E$.
%
Intuitively, $M_{D}$ is the part of $M$ that has been fully evaluated to a data.

%
\begin{thm}[Computational Adequacy: Soundness]
\label{thm:data}
For every computation  $M =  M_0 \newprintp M_1 \newprintp  \ldots$, 
$\sqcup_{i \in \NN} (M_i)_{D} \in \ddata(\val{M})$. 
%
\begin{proof}
In the proof we will use the principle of coinduction for the binary predicate 
%$d \in \ddata(a)$
$\ddata$ 
%on domain elements $d$ and $a$ 
which was defined coinductively in (\ref{e-data}). 
%that is, as the  largest predicate that satisfy the equation  (\ref{e-data}).
%  
In general, for a coinductive predicate
$Q(\vec x) \eqnu \Phi(Q)(\vec x)$ 
%for a predicate transformer $\Phi$, 
and any predicate $P$ of the same arity, one can prove
$P\subseteq Q$ by coinduction
%$\forall \vec x\ P(\vec x) \to Q(\vec x)$ 
by proving 
$P\subseteq \Phi(P)$.
%$\forall x\ P(x) \to \Phi(P)(x)$.  
This proof principle is formalized in IFP/CFP
(last rule in Table~\ref{table-proof-ifp} in Section~\ref{sec-cfp}). 

  Set $P(a, d) \eqdef d = \sqcup_{i \in \NN} (M_i)_D$ for some
  computation
    $M_1 \newprintp M_2 \newprintp\ldots$ with $a = \val{M_1}$.
     We show $P\subseteq\ddata$, that is, 
$P(a, d) \to d \in \ddata(a)$, 
by coinduction.
    Therefore, we have to show $P(a, d) \to \Phi(P)(a, d)$ where
   $\Phi(P)(a,d)$ obtained by replacing in the right hand side of 
   (\ref{e-data}), the predicate $\ddata$ by $P$.
%   the definition of $\ddata$.
  %%  If it holds, we have $P(d, a) \to \ddata(d, a)$.
   Assume $P(a,d)$, witnessed by the computation, that is, 
  fair reduction sequence 
  $M = M_0 \newprintp M_1 \newprintp \ldots$ with $a = \val{M}$
  and $d = \sqcup_{i \in \NN} (M_i)_{D}$.
   We have to show that at least one of the following six conditions holds:
  \begin{enumerate}
  \item[(1)] $a = \Amb(a', b') \land a' \ne \bot \land P(a',d)$
  \item[(2)] $a = \Amb(a', b') \land b' \ne \bot \land P(b',d)$
  \item[(3)] $a = \Amb(\bot, \bot) \land d = \bot$
  \item[(4)] $ a =  C(\vec{a'}) \land d = C(\vec{d'})\land\bigwedge_i P(a'_i,d'_i)$
 for some data constructor $C$. %$C \in \mathrm{C_d}$.
    \item[(5)] $a = \Fun(f)  \land d = a$
  \item[(6)] $a = d = \bot$
  \end{enumerate}
  %
  Any computation $M = M_0 \newprintp M_1 \newprintp \ldots$ belongs to one the following categories:
  
  Case a: All reductions $M_i \newprintp M_{i+1}$ are (p-i) derived from (c-i):
  That is, $M_0 \ssp M_1 \ssp \ldots$. In this case,  $d = \bot$ and (6) holds by Lemma \ref{lem:ssp} (2) and (4).
 
% 
  Case b: For some $n$, $M_i \ssp M_{i+1}$  ($i< n$) and
  $M_i \newprintc M_{i+1}$  ($n \leq i$) by (c-ii) and (c-ii'):
  In this case, $M_i = \Amb(L_i, R_i)$ for $i \geq n$.
  We have $L_i \ssp L_{i+1}$ and $R_i = R_{i+1}$ or 
  $L_i = L_{i+1}$ and $R_i \ssp R_{i+1}$.  
  By fairness, both happen infinitely often and therefore
  (3) holds by Lemma~\ref{lem:ssp}~(2) and~(4).
  
  
  Case c:
  $M_i \ssp M_{i+1}$ for $i< n$  and $M_i \newprintp M_{i+1}$ for $i \geq n$ by (p-iii):
  (5) holds by Lemma \ref{lem:ssp}(2).
  
  
  Case d:
  $M_i \ssp M_{i+1}$ for $i< n$ and $M_i \newprintp M_{i+1}$ for $i \geq n$ by (p-ii):
  $M_{i}$ has the form $C(N_{i,1},\ldots,N_{i,k})$ for $i \geq n$ 
  and $N_{n,j} \newprintp N_{n+1,j} \newprintp \ldots$ are fair reductions.  In addition, 
  $a = C(\val{N_{i,1}},\ldots,\val{N_{i,k}})$ and 
  $d = C(\sqcup_{i \in \NN} ({N_{i,1}})_D,\ldots, \sqcup_{i \in \NN} (N_{i,k})_D)$.  Therefore, (4) holds.
  
  Case e:
  $M_i \ssp M_{i+1}$ for $i< n$, $M_n = \Amb(L,R)$, 
  $M_{i} \newprintc M_{i+1}$ for $n \leq i< m$ by (c-ii) and (c-ii'),
  $M_{m} \newprintc M_{m+1}$ by (c-iii) or (c-iii'):
  $a = \Amb(a',b')$ with $a' = \val{L}$ and 
  $b' = \val{R}$. $M_m = \Amb(L',R')$.
  If (c-iii) is used, $M_{m+1} = L'$ with 
  $a' = \val{L} = \val{L'} \neq \bot$.
  Since the reduction sequence 
  $M_{m+1} \newprintp M_{m+2} \newprintp \ldots$ is fair again,
  $P(a',d)$ and hence (1) holds.  
  Similarly, (2) holds for the case (c-iii') is used.
    
\end{proof}
    \end{thm}

The converse 
%% of Theorem~\ref{thm:data} 
does not hold in general,  
i.e.\ 
%for some $M$,
$d \in \ddata(\val{M})$ does not necessarily imply
$d = \sqcup_{i \in \NN} ((M_i)_D)$  
for some computation of $M$.
%
For example, for 
%% the program 
$M \eqdef \rec\, \lambda\, a.\, \Amb(a,\bot)$
(for which $\val{M} = \val{\Amb(M,\bot)}$) one sees 
that $d \in \ddata(\val{M})$ 
for every $d \in D$ while $M \newprintp^* M$ and $M_{D} = \bot$.
%
But 
%% note that 
$M$ has the type $\tfix{\alpha}{\Am(\alpha)}$ which is not
regular (see Section~\ref{sub-prog}). 
For programs of a regular type, 
the converse of Theorem~\ref{thm:data} does hold. 

\begin{thm}[Computational Adequacy: Completeness]
\label{thm:dataconv}
%If $M$ has a regular type, then
If $M$ is a member of a regular type, then
for every $d \in \ddata(\val{M})$, there is a computation 
$M = M_0 \newprintp M_1 \newprintp \ldots$ with
$d = \sqcup_{i \in \NN} ((M_i)_{D})$.
%
\begin{proof}
  %
  First, we observe that every 
  regular type is semantically equal to  
  a type 
$\Am(\rho)$ or $\rho$ where $\rho$ is neither a fixed point type nor 
  of the form $\Am(\sigma)$.
  %of the form $\Am^k(\rho)$ where $\rho$ is neither a fixed point type nor 
  %of the form $\Am(\sigma)$.
  This follows from an easy modification of Lemma 7 in~\cite{IFP}.
  The key to the proof of the theorem is the following
  
  \begin{quote}
  \emph{Claim.}
    Let $e$ be a 
  %finite 
  compact
  element of $D$.
  If $M$ is a 
  %closed 
  program 
  with $M : \rho$ for some 
  %$\Am$-regular 
  regular
  %\UB{closed} 
  type $\rho$,
  $d \in \ddata(\val{M})$ and $e \sqsubseteq d$, then there exists 
  $M'$ such that 
  $M \newprintp^* M'$, $d \in \ddata(\val{M'})$, and 
  $e \sqsubseteq M'_{D} \sqsubseteq d$.
  \end{quote}
  
  \noindent
  \emph{Proof of the Claim.}
  %
  %Main 
  Induction on the rank of $e$ %(see Sect.~\ref{sec-ang})
  where the \emph{rank}, $\rk(a)\in\NN$, of a 
  compact element of $a\in D$ is defined as 
  $\rk(\bot) = \rk(\Fun(f)) = 0$ and 
  $\rk(C(\vec{a})) = 1+ \max (\rk(\vec{a}))$\footnote{Every compact element has a rank since otherwise it could be approximated from elements strictly below. Our definition of rank differs slightly from the one in \cite{IFP} where $\rk(\Fun(f))>0$.}. 
  %
    $\tval{\tau}{} = \tval{\Am^k(\rho)}{}$ 
  where $k \in\{0, 1\}$ and
  $\rho$ is neither a fixed point type nor of the form $\Am(\rho')$.
  %
  
  \emph{Case $e = \bot$}. Then the assertion holds with $M' = M$, 
  since clearly $M_{D} \sqsubseteq d$
  for all $d \in\ddata(\val{M})$ (induction on $M$). 
  
  \emph{Case $e = C(\vec{e'})$ with $C \ne \Amb$}. 
  Then $d = C(\vec{d'})$ with $d_i' \sqsupseteq e_i'$.
  
  If $k=0$, then $\tau$ is semantically equal to a type of the form 
  $\one$,  $\rho_1+ \rho_2$ or $\rho_1\times\rho_2$,
  and therefore $\val{M}$ has the form $C(\vec{a'})$. 
  By the Adequacy Lemma (Lemma~\ref{lem:ssp}~(4)), 
  $M \ssp^* C(\vec{M'})$ for some $\vec{M'}$
  and $d \in \ddata(\val{M}) = \ddata(C(\vec{\val{M'}}))$.
  Therefore, by the definition of $\ddata$, $d_i' \in \ddata(\val{M'_i})$.  
  Furthermore, by Lemma~\ref{lem:ssp}~(2), $C(\vec{M'})$ has 
  the same denotation as $M$ and therefore, each $M_i'$ has a denotation
  in some regular type (for example, if $\rho=\rho_1\times\rho_2$, then 
  $M_1':\rho_1$). 
  Since the ranks of the $e_i'$ are smaller than that of $e$, 
  by %the main 
  induction hypothesis, there exists $\vec{M''}$ such that 
  $M'_i \newprintp^* M''_i$, $d_i' \in \ddata(\val{M''_i})$ 
  and $e_i' \sqsubseteq ({M_i}'')_{D} \sqsubseteq d_i'$.
  Therefore, $C(\vec{M'}) \newprintp^* C(\vec{M''})$ by (p-ii),  
  $d \in \ddata(\val{C(\vec{M''})})$, and
  $e \sqsubseteq C(\vec{M''})_{D} \sqsubseteq d$.
  Since $M \newprintp C(\vec{M'})$, we are done.
  

  If $k = 1$, %$k > 0$, 
  then $\val{M}$ has the form $\Amb(a', b') $.
  Since $d \sqsupseteq e \ne \bot$, 
  %and $a'= b'=d = \bot$ \HT{or} % $d \ne \bot$, 
  $a' \ne \bot \land d \in \ddata(a')$
  or $b' \ne \bot \land d \in \ddata(b')$.
  %
  By the Adequacy Lemma, $M \ssp^* \Amb(N_1, N_2)$.
  If   $\defined{\val{N_1}} \land d \in \ddata(\val{N_1})$ then 
  $N_1 \ssp^* K$ for some w.h.n.f.\ $K$ and therefore
  $M \newprintc^* K$ by applying (c-i), (c-ii), and (c-iii),
  and thus $M \newprintp^* K$ by (p-i).
  Note that %$K : \Am^{k-1}(\rho)$ and
  $K : \Am^{0}(\rho)$ and
  $d \in \ddata(\val{K})$.  Therefore, %by the side induction hypothesis,
  there exists $K'$ such that $K \newprintp^* K'$,
  $d \in \ddata(\val{K'})$, and $e \sqsubseteq K'_{D} \sqsubseteq d$.
  Since $M \newprintp^* K'$, we have the result.
  
  \emph{Case $e =\Fun(f)$}. 
  %
  If $k=0$, then $\val{M} = \Fun(f)$ and therefore $d = \Fun(f)$.
  Furthermore, by the Adequacy Lemma, 
  $M \ssp^*M'$ for some $M'$ in w.h.n.f. Since $\val{M'} = \val{M} = \Fun(f)$,
  $M'$ is a $\lambda$-abstraction and hence $M'_{D} = \val{M'}$.
  It follows that $e = M'_{D} = d$.
  %
  If $k = 1$ %$k>0$ 
  the same argument as in the case $e = C(\vec{e'})$ applies. 
  %
  This completes the proof of the Claim.

  
  To prove the Theorem,  
  let $d\in\ddata(M)$, and 
let $d_0 \sqsubseteq d_1 \sqsubseteq \ldots$ 
  be an infinite sequence of 
  % \HT{finite} 
    compact
    approximations of
    $d$ such that $d = \sqcup_i d_i$.  
    We construct a sequence $(M_i)_{i\in \NN}$ 
    such that $d \in \ddata(\val{M_i})$ and $M_i$ has a regular type as follows.
    Let $M_0 = M$.  By applying the Claim to 
    $d_i$, $d$ and $M_i$, we have $M_{i+1}$ such that $M_i \newprintp^* M_{i+1}$ 
    (hence, clearly, $M_{i+1}$ has a regular type as well),
    $d \in \ddata(\val{M_{i+1}})$, and 
    $d_i \sqsubseteq (M_{i+1})_{D} \sqsubseteq d$.
    By concatenating the reduction sequences, we have an infinite sequence
    $M = N_0 \newprintp N_1 \newprintp \ldots$ such that 
   $d = \sqcup_{i \in \NN} ((N_i)_{D})$.
%
\end{proof}
\end{thm}
%
We say that a closed program $M$ is {\em productive} if every computation
$M = M_0 \newprintp M_1 \newprintp \ldots$ produces 
a deterministic w.h.n.f. (i.e., some $M_i$ is a deterministic w.h.n.f).
We consider 
%it
productiveness  
a counterpart of termination for a nondeterministic infinite computation.
%
By the first Adequacy Theorem and Lemma~\ref{lem:ddatabot}: 
%% we have: % the following. 
%
\begin{cor}\label{cor:ddatabot}
For a closed program $M$ of regular type, the following 
%% (1) to (3) 
are equivalent.
  \begin{enumerate}
%% \mps{\HT{productive vs. terminating. Which is better?}}
   \item[(1)] $M$ is productive.
   %weak head normal form;
   \item[(2)] Some computation $M = M_0 \newprintp M_1 \newprintp \ldots$ 
   produces a deterministic w.h.n.f.
   \item[(3)] $\val{M}$ is neither $\bot$ nor $\Amb(\bot,\bot)$.
%(which is equivalent to $ \{\bot\} \ne \ddata(\val{M})$, and also to $\bot \not \in \ddata(\val{M})$).
\end{enumerate}
\begin{proof}
  %
Clearly, every program has a fair $\newprintp$-reduction sequences. 
Therefore, 
%(2) implies (1). 
(1) implies (2). 
  %
  Next, assume 
%(1). 
(2). 
%
Then, by Theorem~\ref{thm:data}, $\ddata(\val{M})$ must contain a
  non-bottom element. By Lemma~\ref{lem:ddatabot}, (3) holds.
  %
  Finally, if (3) holds, then by Lemma~\ref{lem:ddatabot}, $\bot\not\in\ddata(\val{M})$.
  Hence, by Theorem~\ref{thm:data}, %Theorem~\ref{thm:dataconv}
  every $\newprintp$-reduction sequences 
  of $M$ reduces to a deterministic w.h.n.f.
  %
\end{proof}
  \end{cor}
%Recall that $a$ is defined iff $\ddata(a)$ does not contain $\bot$, 
%and $a$ is defined iff $\ddata(a)$ contains only $\bot$.
%
%It means that if $M$ has a productive sequence, then a productive sequence is always selected.
%% Note that 
The corollary 
does not hold without  the 
regularity
%typability 
condition.
For example,  $M = \Amb(\Amb(\Nil,\Nil), \Amb(\bot, \bot))$  can be reduced to $M_1 = \Amb(\bot, \bot)$ and then
repeats $M_1$ forever,  whereas it can also be reduced to $\Nil$.
%whereas it has a productive sequence to $\Nil$.
McCarthy's $\amb$ operator is bottom-avoiding
in that when it can terminate, it always terminates.
Corollary~\ref{cor:ddatabot}  guarantees a similar property for our 
globally angelic choice operator $\Amb$.



