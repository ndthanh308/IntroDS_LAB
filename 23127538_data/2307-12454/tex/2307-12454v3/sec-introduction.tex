
%
Nondeterministic bottom-avoiding choice is an important and useful idea. 
With the wide-spread use of hardware supporting parallel computation,
it 
can speed up practical computation and, at the same time,
relates 
to computation over mathematical structures like real 
numbers~\cite{Escardo96,Tsuiki02}.
On the other hand, it is not easy to apply 
theoretical tools like denotational semantics to nondeterministic bottom-avoiding choice~\cite{HughesO89,Levy07}, and guaranteeing 
correctness and totality of such programs 
is a difficult task.

To explain the subtleties of the problem, let us start with an example.
%
Suppose that $M$ and $N$ are partial programs that,  
under the (in general undecidable) conditions $A$ and $\neg A$, respectively, 
are guaranteed to terminate and produce values satisfying a specification $B$. 
Then, by executing $M$ and $N$ in parallel 
and taking the result 
returned
first, we should always obtain a result satisfying $B$. 
This kind of bottom-avoiding nondeterministic program
is known as \emph{McCarthy's amb (ambiguous) operator} \cite{McCarthy1963}, and 
we denote such a program by  $\Amb(M, N)$.
$\Amb$ is called the angelic choice operator and
is usually studied as one of the three 
nondeterministic choice operators (the other two are erratic choice and demonic choice).



If one tries to formalize this idea naively, one will face some 
obstacles.  
Let $\ire{M}{B}$ (``$M$ realizes $B$'') 
express 
that program $M$ satisfies specification $B$, and 
let $\Set(B)$ be the specification that 
is satisfied by concurrent programs 
of the form $\Amb(M, N)$ that  always 
terminate and produce 
a value satisfying $B$.  
Then, the above inference could be written as
\[
  \infer[\hbox{}]{
  \ire{\Amb(M, N)} \Set(B)
}{
A \to (\ire{M}{B})  \ \ \ \     \neg A \to (\ire{N}{B}) 
}
\]
%
However, this inference is not sound for the following reason.
Suppose that $A$ does not hold, that is, $\neg A$ holds. 
Then, the execution of $N$ will produce a
value satisfying $B$. But the execution of $M$ may terminate as well, and
with a data that does not satisfy $B$ since there is no condition on $M$
if $A$ does not hold.
Therefore,  if $M$ terminates first in the execution of $\Amb(M, N)$, 
we obtain a result that may not satisfy $B$.

To amend this problem, we add a new operator $\rt{A}{B}$ 
(pronounced ``$B$ restricted to $A$'')
and consider the rule
\begin{equation}\label{eq0}
  \infer[\hbox{}]{
  \ire{\Amb(M, N)} \Set(B)
}{
\ire{M}{(\rt{A}{B})}\ \ \ \  \ire{N}{(\rt{\neg A}{B})}}
\end{equation}

Intuitively, $\ire{M}{(\rt{A}{B})}$ means  two things:
(1) If $A$ holds, then $M$ terminates, and
(2) if 
$M$ terminates, then the result satisfies $B$,
even for the case $A$ does not hold.
As we will see in Section~\ref{sub-conc}, 
the above rule is derivable in classical logic
and can therefore be used to prove total correctness 
of Amb programs (Lemma~\ref{lem-restrict}).

In this paper, we go 
a step further and
introduce a logical system $\CFP$ whose formulas
can be interpreted as specifications of 
nondeterministic programs
although they do not talk about programs explicitly.
$\CFP$ is defined by adding the two logical operators $\rt{A}{B}$ and 
$\Set(B)$ to the system $\IFP$, 
a logic for program extraction~\cite{IFP} 
(see also \cite{Berger11,SeisenBerger12,BergerPetrovska18}). 
$\IFP$ supports the extraction of lazy functional programs 
from inductive/coinductive proofs in intuitionistic first-order logic.
It has a prototype implementation in Haskell,
called Prawf \cite{DBLP:conf/cie/0001PT20}.
A related approach
has been developed in the
 proof system Minlog~\cite{SchwichtenbergMinlog06,BergerMiyamotoSchwichtenbergSeisenberger11,SchwichtenbergWainer12}.
 
We show that from a $\CFP$ proof of a formula, both
a program and a proof that the program
satisfies the specification can be extracted
(Soundness theorem, Theorem \ref{thm-soundnessI}). 
For example, in $\CFP$ we have the rule 
 \begin{equation}\label{eq00}
   \infer[\hbox{(Conc-lem)}]{
   \Set(B)
 }{
 \rt{A}{B}\ \ \ \    \rt{\neg A}{B}}
  \end{equation}
which is realized by the program   $\lambda a. \lambda b. \Amb(a, b)$,
  and whose correctness is expressed by the rule (\ref{eq0}).
Programs extracted from $\CFP$ proofs can be  
executed in Haskell,
implementing $\Amb$
with  the concurrent Haskell package.



As an application,
we extract a nondeterministic 
program that converts 
infinite Gray code to signed digit representation, where 
infinite Gray code is a 
coding of real numbers by partial digit streams
that are allowed to contain a $\bot$, that is, a digit
whose computation does not terminate~\cite{Gianantonio99,Tsuiki02}. 
Partiality and multi-valuedness are common phenomena in computable analysis 
and exact real number computation~\cite{Weihrauch00,LUCKHARDT1977321}.
This case study connects these two aspects through a nondeterministic and
concurrent program whose correctness is guaranteed by a CFP proof. The extracted Haskell programs are listed in the appendix, and are also 
available in the repository~\cite{githubUB}.   




In this paper, we focus on the specific aspect of concurrent computation and its resulting nondeterminism discussed above: the situation where two processes simultaneously attempt to access the same memory cell. Other aspects of concurrency, such as communication, are not covered here.



Organization of the paper: 
In Section~\ref{sec-ang} and~\ref{sec-ops}
we present the denotational and operational semantics of a functional 
language with $\Amb$ and prove that they match 
(Theorem~\ref{thm:data} and~\ref{thm:dataconv}).
Section~\ref{sec-cfp} and~\ref{sec-pe} describe the formal system $\CFP$ 
and its realizability interpretation 
which our program extraction method is based on 
(Theorem~\ref{thm-soundnessI},~\ref{thm-soundnessII}, and~\ref{thm-pe}).
In Section~\ref{sec-gray} we extract
a concurrent program that converts 
representations
 of real numbers 
and study its behaviour in Section~\ref{sec-experiments}.
The concluding Section~\ref{sec-conclusion} summarizes the results, discusses related works, and
outlines further research directions.







