\section{Architecture of our Safety Island}
\label{sec:sais}


% Figure environment removed

{\color{black}Our goal is presenting a safety island with a number of specific characteristics as follows:
\begin{itemize}
\item Include features for monitoring and controlling the behavior of an HPC device, as well as capabilities to accurately diagnose the cause of any error so that the most effective remedy can be applied.
\item Be suitable for its realization as a chiplet, hence easing integration with COTS HPC devices, and minimizing integration challenges.
\item Be built on open source technologies as much as possible to ease its adoption and extension by the community.
\end{itemize}
}

This section presents our safety island, including key design and integration considerations for its effectiveness.


\subsection{Safety Features of our safety island}

The purpose of our safety island is providing HPC devices with appropriate capabilities to execute performance-demanding applications while preserving their safety requirements. As explained before, safety-related systems require a number of features that can be generally classified into the following categories.

\subsubsection{Controllability Features} 
Controllability features are needed to guarantee that execution conditions for safety-relevant applications are controlled to a sufficient extent (e.g., limiting mixed-criticality interference, guaranteeing some performance levels, etc.). 

\paragraph{Proactive Features}
This type of features includes the ability to restrict the operation of HPC components whenever needed by setting appropriate configurations (e.g., network-on-chip (NoC) policies, cache replacement policies, cache sharing policies, shared resource usage quotas, etc.) so that safety requirements can be implemented through the safety island without introducing disruptive changes in the HPC processor.

\paragraph{Reactive Features}
Alternatively, if some behavior cannot be avoided by means of appropriate configurations, monitoring capabilities are needed to detect misbehavior (e.g., abnormal error detection rates in caches, overutilization of some components, etc.), diagnose the cause, and take actions to mitigate such misbehavior (e.g., stalling the offending process for a while).


\subsubsection{Observability Features}
Observability features are critically important during both system validation and operation. During system validation, they allow collecting detailed information of the behavior of the overall system. The information can be from individual hardware and software components. This information can then be processed offline to detect any misbehavior. Such observability features typically decrease the need for longer test campaigns, since they ease obtaining the evidence; evidence whether some behavior occurs or not. In some circumstances, observability feature may be mandatory to detect certain behavior that is not observable otherwise.
Those features are expected not only to identify specific situations, but to provide enough information to ease diagnosis to mitigate the source of the unexpected situations.

Observability features are fundamental during operation since they can be linked to -- reactive -- controllability features, as indicated before, as well as to safety measures that require detailed diagnostics to guarantee safety without impacting other key metrics such as availability and performance.

The type of information to be observed and how it is collected is highly diverse and must be properly tailored to not incur excessive cost. For instance, one could trace all transactions across two components (e.g., across a shared cache and DRAM memory) or summarize them by counting the amount of data transferred over a period of time. The former may require tracking each individual address accessed along with some information about the transaction (e.g., whether it is a read or store operation, amount of data transferred, etc.), which requires huge storage but provides highly detailed information, whereas the latter provides much less information but only needs few counters to track the amount of data transferred potentially broken down across components originating the transactions (e.g., across cores, accelerators, etc.). 

Overall, it is key to enable the safety island with appropriate support to collect different types of traces, and either output them at high speed, or compress them on-the-fly to generate compressed logs for a ``post-mortem'' analysis. Information to be monitored includes abnormal performance behavior, activity in shared resources (e.g., NoCs, caches and memory controllers), etc. Also, programmable filters to monitor only specific subsets of information are highly convenient.


\subsubsection{Safety Measures}

Random hardware faults and sporadic abnormal performance conditions are generally unavoidable. The safety island must provide capabilities to monitor faults, diagnose the cause, tolerate some of them, and contain the impact of all of them so that software layers can easily and timely manage errors and preserve fault-free operation at all times.

Some safety measures can be implemented by mostly relying on controllability and observability features already described before, but some others may require additional support. For instance, hardware or software monitors may be needed so that, upon the detection of abnormal behavior in the HPC device, specific corrective actions are taken (e.g., resetting specific components, switching to a degraded operation mode, etc.). Since those monitors may have the highest integrity levels, they may require DMR or TMR support in the safety island. Similarly, error detection capabilities for the HPC device may require the safety island to orchestrate some form of diverse and redundant execution on the HPC device regardless of whether the HPC device has specific hardware support for that.





\subsection{Hardware Integration Considerations}


Integration of the safety-relevant features with the HPC device (aka as HPC island) to be mastered is a challenging concern. The higher the coupling between the safety island and the HPC island, the higher the efficiency of the safety island due to having higher controllability and observability, but the lower the modularity since mutual dependencies across the safety and HPC islands would increase. For instance, two extremes of the integration could be as follows:
\begin{itemize}
\item \textbf{Coupled integration}: the islands could be integrated connecting the safety island as a master to the different interconnects in the HPC island (e.g., all AMBA interconnects). This would grant detailed observability and controllability to the safety island, which would have direct information from the different internal interfaces, and could react almost immediately to any predefined event.
On the other hand, such integration would be highly device-specific, hence potentially requiring non-negligible modifications to tailor the safety island to a particular HPC device.
\item \textbf{Loose integration}: the safety island could be encapsulated into a chiplet with standard predefined interfaces agnostic of the particular characteristics of the HPC device to be mastered. This approach would favor portability and modularity, but would be detrimental for observability and controllability purposes since (i) some interfaces may not be directly observable, and (ii) access to the connected interfaces may have higher latency than in the coupled approach, hence increasing reaction time, which ultimately may inhibit the use of some safety measures requiring immediate actions (e.g., to avoid error propagation).
\end{itemize}

When integrating both islands, the safety island and the HPC island, it is critically important to understand what is reachable (and how) through the existing interfaces to program the safety island accordingly (e.g., monitoring modules, traffic injection modules). Note that, even if some parts of the chip are not directly reachable by the safety island, they may still be managed indirectly. For instance, one could inject traffic reaching specific devices attached to not directly reachable interconnects, and observe the latency to obtain a response to guess the amount of load in that interconnect.

{\color{black}
\subsubsection{Chiplets}
While integrating all features in a single chip die generally provides advantages in terms of power and performance, some issues are driving industry towards the use of chiplets instead. In particular, single-chip solutions hinder chip reuse, may lead to lower yield due to the increased number of transistors per chip, and provide diminishing returns in terms of performance as the chip size grows. 

Instead, chiplets provide a number of key advantages, particularly relevant for the safety island: (1) they allow for chip reuse, so the same safety island can be used for different HPC devices. (2) Designs can be specialized for efficiency reasons, hence not needing to build a single chip for all targets. (3) Heterogeneous technologies can be used across different chiplets, hence easing integration. (4) Due to being smaller and simpler devices than monolithic chip solutions, they ease testability. Finally, (5) their smaller size allows increasing yield.

Still, chiplets have to face some challenges that relate to using larger boards to accommodate multiple chiplets, increased latency for chiplet-to-chiplet communication, increased reliability concerns due to the increased number of soldered joints, thermal/mechanical constraints to place multiple chiplets together, and the lack of chiplet-to-chiplet communication standards, although the Universal Chiplet Interconnect Express (UCIe) has recently appeared to mitigate the latter.

\subsubsection{Physical and Logical Integration}
A number of integration aspects related to the physical location of the different chips and the communication interfaces emerge in chiplet-based solutions. For instance, UCIe provides a physical solution to manage the integration of multiple chiplets. However, the particular protocols to be used to communicate chiplets over such communication interface remain to be defined. 

Analogously, whenever multiple chiplets are deployed, the physical location of the different chiplets, including memories, must be carefully laid out to maximize performance, while minimizing power, area and reliability concerns. Also, it must be carefully analyzed which chiplets need to interact. For instance, it is unclear whether all or just a subset of the chiplets need to access main memory, whether it is better deploying memory controllers in all chiplets or concentrating memory access through a single chiplet, whether some specific memory technologies are more convenient than others when using chiplets. Overall, new integration-related challenges emerge when using chiplets. 

Aspects related to the power supply, power domains, and power monitoring must also be taken into account since the safety island is intended to be used for safety critical functionalities. In general, the safety island inherits similar requirements to those of any other safety-relevant microcontroller. Using other chiplets for other devices (e.g., for the HPC device) brings increased costs, as mentioned before, but may ease implementing some safety measures since physical segregation, in general, reduces the number of potential single-point faults.
}


\subsection{System Software Considerations}
A number of observability and controllability features in the safety island may require accessing specific modules in the HPC island such as, memory interfaces to inject traffic, or configuration registers to exercise control on the HPC device. However, existing Memory Management Units (MMUs) or Input/Output MMUs (IOMMUs) may exercise control on the permissions and privileges to access (and potentially modify) different components in the HPC island. Therefore, it becomes critically important that the safety island -- or the system software on its behalf -- is capable of properly configuring permissions and privileges (e.g., at boot time) so that it can perform its work during operation. 
Note that such boot and configuration process is not exempt of security risks, and, hence, is a delicate process that needs to follow appropriate rules for a secure boot and configuration.
Additionally, in order to retain flexibility, namely in regards to fault tolerance and containment, permissions and privileges should as well be configurable at runtime. However, such flexibility can equally incur security risks if the reconfiguration interface represents a single point of failure and can be directly manipulated by exploiting, e.g., a page table vulnerability.

Another software aspect relates to the fact that user level software with safety requirements may need to run on the safety island. For instance, control applications needing native DCLS only available in the safety island may require running on the cores of the safety island. Similarly, some parts of the applications needing to run on the HPC island may also need to run on the safety island. To guarantee a safe environment, virtualization becomes mandatory as well as an appropriate hypervisor or real-time operating system (RTOS) providing partitioning services to those applications, such as fentISS' XtratuM~\cite{xtratum}, SYSGO's PikeOS~\cite{PikeOS}, GMV-Portugal's Air~\cite{GomesOBDP}, Lynx Software Technologies' LynxSecure, Wind River's hypervisor, Green Hill's Integrity, Continental's OSEK VDX, and Erika Enterprise, to name a few. 

\subsection{System Safety Considerations}
The integration of the safety and HPC islands is not exempt of some safety considerations, mostly related to the hardware and software considerations above. A key safety consideration relates to the latency to retrieve information from the HPC island as well as to exercise control. Coupled integrations generally lead to lower latencies, which favor decreased safety risks, as opposed to loose integrations. 

The ability to observe and control the HPC island with low latency is key for a number of safety-related aspects such as fault containment and reaction times at system level. For instance, in the context of automotive safety-relevant systems, an FTTI is defined, as explained before. Exceeding that FTTI implies that hazards can occur potentially violating the safety goals of the system. Therefore, the safety island design and integration must be planned to adhere to safety considerations relevant at hardware, software and system level.


\subsection{Security Considerations}
\label{sec:seccons}

{\color{black}While the goal of the safety island is providing safety capabilities, it must realize some security support to avoid its improper use. Security aspects relevant for the safety island include authentication, permissions and secure boot.

The safety island must realize a secure boot process, in cooperation with software, to guarantee that software executed during booting, as well as drivers loaded, come from legitimate sources. Authentication is also key if any such software requires being updated with updates being initiated by external sources.

During operation, in order to monitor and even control the HPC device, appropriate permissions must be set in the configuration of the HPC device so that safety island actions are allowed. In that context, authentication becomes fundamental since analogous actions triggered by devices other than the safety island must not be allowed. 
Some technologies, such as Intelâ€™s CSME (Converged Security and Management Engine)~\cite{SAI} provide capabilities to authenticate and load firmware into relevant IPs. Such type of technology could be expanded towards use among chiplets, allowing for example the safety island to authenticate itself towards the cores in the HPC device.
}

\subsection{Extendability Considerations}


{\color{black}The use of a safety island, especially if conceived as a separate chiplet, brings opportunities in terms of extensions and updates. For instance, improved safety island designs can be deployed along with a given HPC device without needing to update the latter. Such improvements may come in the form of extensions to enable more efficient means to manage safety aspects (e.g., resorting to hardware support instead of software-only solutions), such as enhanced monitoring units, or more powerful cores in the safety island to perform specific services (e.g., implementing domain-specific ISA extensions in the safety island cores).
Such extensions can be also realized deploying an eFPGA in the safety island so that a firmware update suffices, hence avoiding physical changes.
}


