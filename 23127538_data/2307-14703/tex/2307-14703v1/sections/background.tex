\subsection{Software Product Lines}

A software product line represents a collection of software artifacts that share a common basis~\cite{clements2002software}. 
Their purpose is to describe the variability of configurable systems from which multiple differing products can be derived. 
One way to describe the configuration space of a product line is by using a \textit{feature model}~\cite{kang1990feature}. 
A feature model represents configuration options as \textit{features}, and it uses propositional logic to define constraints that describe how features can be combined to create valid configurations. 
We show a running example of a feature model representing a simplified version of a car in Fig.~\ref{fig:runningExampleFM}. 
The root feature \textit{car} represents the system's base and includes basic, non-configurable elements. 
All features below \textit{car} define variations of the base systems. 
The features \textit{body, engine} and \textit{gear} are mandatory features, meaning they must be selected when their parent is.
The features \textit{keyless\_entry} and \textit{power\_locks} are optional features.
The features \textit{engine} and \textit{gear} define additional children in specific group types. 
\textit{Electric} and \textit{gas} are combined to an \textit{or group}, and \textit{manual} and \textit{automatic} are combined to an \textit{alternative group}. 
An or group requires that at least one of the included features is selected, whereas an alternative group requires that exactly one of the children is selected. 
Thus, in our example, a car must have one engine type, but it is also valid to select \textit{electric} and \textit{gas} to create a hybrid car. 
However, it is not valid to configure a car with a \textit{manual} and \textit{automatic} transmission. 

The configuration space of the car model constitutes all feature combinations that fulfill the composition rules. 
Thus, a valid configuration is \textit{\{body, engine, gas, gear, manual\}}.
It is invalid because it does not include the mandatory \textit{body} feature.
During the life cycle of a software product line, its feature model is often analyzed to gain empirical or directive information, e.g. to search for unselectable features, create product samples for testing, or count the number of all valid configurations. 
Feature model analysis is automated by transforming the feature model into a propositional formula in conjunctive normal form (CNF). The CNFs are then analyzed with SAT-solver-based methods. For instance, unselectable features can be found by searching for features not contained in any valid configuration. 
Product samples can be created by randomly selecting combinations of features that satisfy the CNF, representing a valid product configuration.  
A minimal CNF that represents the configuration space of the \textit{car} example is the following:
%
%
\begin{align*}
(car) \land
(body) \land 
(engine) \land 
(gear)\\
\land~(\neg keyless\_entry \lor power\_locks) \land 
(electric \lor gas)\\
\land(manual \lor automatic) \land 
~(\neg manual \lor \neg automatic)
\end{align*}

% Figure environment removed

\subsection{Quantum Computing}
A quantum computer performs calculations on \textit{quantum bits (qubits)} that abstract the state of a quantum mechanical system.
Computations on a quantum computer can leverage quantum mechanical effects, such as superposition and entanglement,  
 to achieve computational advantages over classical computers.

The state of a qubit is described by a complex unit vector $\begin{bmatrix}  a & b \end{bmatrix}^\intercal \in \mathbb{C}^2$.
The \textit{standard/computational basis} of a quantum system consists of the two basis states  
$\ket{0} = 
\begin{bmatrix}
1 & 0 
\end{bmatrix}^\intercal$
and
$\ket{1} = 
\begin{bmatrix}
0 & 1 
\end{bmatrix}^\intercal$.
Any state of a qubit $\ket{\psi}$ can be written as a linear superposition of its two orthonormal basis states $\ket{\psi} = a\ket{0} + b\ket{1}$
where the factors $a$ and $b$ are the probability amplitudes and $|a|^{2}+|b|^{2}=1$ holds.
A geometric representation of a qubit is as a  vector on a Bloch Sphere (see Fig.~\ref{fig:qubitState} (l.)).

\usetikzlibrary{angles, quotes}
% Figure environment removed

A measurement collapses a qubit's state.
When measuring a qubit in state $\ket{\psi}$ (in standard basis):
\begin{itemize}
    \item with probability $|a|^2$ the outcome reads "$0$" and the state changes to $\ket{0}$.
    \item with probability $|b|^2$ the outcome reads "$1$" and the state changes to $\ket{1}$.
\end{itemize}
Relative phases between $a$ and $b$ are not measured but are responsible for interference effects.

To manipulate individual or multiple qubits, arbitrary unitary matrices/transformations $U$ can be applied.
Unitary transformations are reversible so that applying $U$ and its conjugate transpose $U^\dagger$ results in the identity matrix $I$: $UU^\dagger =I$, where $I$ denotes a square matrix with ones on the main diagonal and zeros elsewhere.
The quantum bit-flip operator/gate $X$ (also denoted as NOT and Pauli $X$) rotates a qubit's state by 180Â° around the $x$-axis of the Bloch Sphere (see Fig.~\ref{fig:qubitState} (r.)).
The $X$ gate behaves like a logical NOT for the computational basis states.
For a qubit in state $\ket{0}$, the $X$ gate flips its state to $\ket{1}$ and vice versa.
The single qubit Hadamard gate $H$ moves a qubit initialized at $\ket{0}$ into the \textit{equal superposition} state $\ket{+}=\frac{1}{\sqrt{2}}\ket{0} + \frac{1}{\sqrt{2}}\ket{1}$, which measures to "$0$" and "$1$" with equal probability of $\frac{1}{2}$. 
The polar basis of a quantum system consists of the two orthonormal basis states $\ket{+}$ and $\ket{-}=\frac{1}{\sqrt{2}}\ket{0} - \frac{1}{\sqrt{2}}\ket{1}$.

A multi-qubit system of $n$ qubits is a quantum system of dimension $d = 2^n$, e.g., with $n=2$ the system has four computational basis states $\ket{00}, \ket{01}, \ket{10}, \ket{11}$, and its state can be described as $\ket{\psi} = \psi_{00}\ket{00} + \psi_{01}\ket{01} + \psi_{10}\ket{10}+ \psi_{11}\ket{11}$.
If one has a two-qubit system with qubits in states $\ket{\alpha}$ and $\ket{\beta}$ the overall system's state can be described by a so-called product state $\ket{\psi} = \ket{\alpha}\otimes\ket{\beta}$. 
Qubits can be \textit{entangled} by which they correlate in a way that, when measured, the entangled qubits collapse to the same state $\ket{0}$ or $\ket{1}$.
Due to the entanglement, such an entangled state can not be written as a product state.
The controlled-$X$ gate $CX$ is a two-qubit gate that flips the second qubit (target) if and only if the first qubit (control) is in $\ket{1}$.
It is used to create entanglement.

\textit{Quantum circuits} are used to model the behavior of a quantum system over time.
Typically, a quantum circuit defines qubits, their initial states, the application of specific quantum gates, and the measurement of qubits.

In practice, quantum computers only can realize a small set of gates.
The gate set available in many quantum computers is universal, s.t. every other transformation $U$ can be constructed from the physically available gates.
A quantum computer also has a topology that defines the physical connections between qubits and thus restricts their possible interactions (e.g., only specific qubits can be entangled on a specific quantum computer).
A quantum circuit, thus, has to be transpiled to match a quantum computer's available gates as well as the computer's
topology.

The $X$ gate behaves like a logical NOT as described in the background.
Classical AND and OR are not reversible, but they can be simulated on a quantum computer by using an additional qubit that is initialized to $\ket{0}$ by default~\cite{2011-Williams-book}.
Such auxiliary qubits are called ancilla qubits and are required to perform these operations.
Williams~\cite{2011-Williams-book} showed how classical AND and OR with two inputs can be simulated on a quantum computer, which we extend to work on $n$ inputs.
Tab.~\ref{tab:transformation} shows how logical AND and OR can be realized on a quantum computer in the form of
an exemplary circuit fragment.
An AND operation as defined by $U_{and}$ applies a bit-flip ($X$ gate) on the target ancilla if all $n$ input qubits are in state $\ket{1}$. 
Thus, it can be realized using a multi-controlled-$X$ gate.
A multi-controlled-$X$ gate for $n=2$ is a Toffoli-Gate.
A quantum OR operation can be derived from AND and NOT operations similar to classical Boolean algebra.
First, every single qubit is flipped using $X$-gates, then the $U_{and}$ operation is applied, then all qubits except the target are flipped again using $X$-gates:
$U_{or} = X^{\otimes n} \, U_{and} \, (X^{\otimes n-1} \otimes I)$.

\newsavebox{\boxA}
\savebox{\boxA}{
\begin{tikzpicture}
        \node[scale=0.8] {
            \begin{quantikz}%[row sep=0.1cm]
            a & \gate{X} & \qw \neg a
        \end{quantikz}
    };
\end{tikzpicture}}

\newsavebox{\boxB}
\savebox{\boxB}{
\begin{tikzpicture}
    \node[scale=0.7] {
        \begin{quantikz}%[row sep=0.1cm]
        a\;  & \ctrl{1} & \qw \; a \\
        \vdots\; & \ctrl{1} \vqw{1} & \qw \;\vdots \\
        n\;  & \ctrl{1} \vqw{1} & \qw \; n \\
        \ket{0}\; & \targ{} & \; \qw a \land \dots \land n
        \end{quantikz}
    };
\end{tikzpicture}}

\newsavebox{\boxC}
\savebox{\boxC}{
\begin{tikzpicture}
    \node[scale=0.7] {
        \begin{quantikz}[row sep=0.2cm]
        a\; & \gate{X} & \gate[wires=4]{U_{and}} & \gate{X} & \qw \; a \\
        \vdots\; & \gate{X} & & \gate{X} & \qw \;\vdots \\
        n\; & \gate{X} & & \gate{X} & \qw \; n \\
        \ket{0} & \gate{X} &  & \qw & \; \qw a \lor \dots \lor n
        \end{quantikz}
    };
\end{tikzpicture}}

\setlength{\extrarowheight}{3pt}
\begin{table}[bt]
    \centering
    \caption{Logical AND and OR as quantum circuit fragments}
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{AND} & \textbf{OR} \\
        \hline
        \makecell[c]{\usebox\boxB} &
        \makecell[c]{\usebox\boxC}
        \\\hline
    \end{tabular}
    \label{tab:transformation}
\end{table}

\subsection{Grover's Algorithm}
\label{sec:grover}
We're using Grover's algorithm~\cite{1996-Grover-Search} for quantum search over unstructured solution sets to sample a configuration space uniformly random (see Section~\ref{sec:contribution}).
Let $f(x)$ be a black box function with an integer $x$ as input which can validate a solution ($f(x)=1$) for a specific search problem.
Given such a function $f(x)$ the algorithm finds a unique solution $m$ from the set of all solutions $M$~\cite{2016-Nielsen-QCandQI}.
The size of the overall search space $N$ is $2^n$ and the index of elements in the search space can be stored in $n$ bits classically~\cite{2016-Nielsen-QCandQI}.
With high probability, a solution is found using at most $O({\sqrt{N/M}})$ calls to $f(x)$ instead of $O(N/M)$ calls necessary classically~\cite{2016-Nielsen-QCandQI}.

Detailed algorithm analysis is conducted in~\cite{2016-Nielsen-QCandQI}, which we summarize in the following.
Onto $n$ qubits that are initial in $\ket{0}$ state, the Hadamard gate $H$ is applied to every qubit.
This results in the equal superposition state ${\ket{s}=\frac{1}{\sqrt{N}}\sum_{x=0}^{N-1}\ket{x}}$ over the search space $N$.
Then, a Grover iteration is applied $k=\mathcal{O}(\sqrt{N/M})$ times, where the number of iterations is denoted by $k$.

An iteration consists of the oracle operator $U_\omega$ first and the diffusion operator $U_s$ afterward.
$U_\omega$ marks the solutions by shifting their phases, as it can - by the nature of being an oracle - recognize the solutions of the problem.
The oracle is treated as a black box to generalize the algorithm, as the oracle encapsulates a problem-specific structure.
In contrast, the diffusion operator is defined generally as ${U_s = H^{\otimes n}(2\ket{0}\bra{0}-I)H^{\otimes n} = 2\ket{s}\bra{s}-I}$ and performs a reflection over $\ket{s}$ to amplify the amplitudes of the marked solutions.

% Geometric representation of Grover
% Figure environment removed

Fig.~\ref{fig:grover} shows the geometric interpretation of the first iteration of Grover's algorithm in the two-dimensional subspace spanned by \ket{\omega} and $\ket{s'}$.
$\ket{\omega}$ denotes the equal superposition over all $x$ that are solutions to the search problem (the 'winning' states), and $\ket{s'}$ denotes the equal superposition over all $x$ that are not the solution to the search problem (the 'losing' states).
The initial equal superposition state can be rewritten as $\ket{s} = \sqrt{\frac{N-M}{N}}\ket{s'}+\sqrt{\frac{M}{N}}\ket{\omega}$ in this subspace.
Geometrically, the oracle operator $U_\omega$ is a reflection of $\ket{s}$ over $\ket{s'}$.
Then the diffusion operator $U_s$ reflects $U_\omega\ket{s}$ over $\ket{s}$, resulting in an overall rotation of $\theta$ towards $\ket{\omega}$ per iteration.
If $M \leq \frac{N}{2}$ then $\sin{\frac{\theta}{2}}={\sqrt{\frac{M}{N}}}$ holds.
After $k$ iterations of the oracle and diffusion operators, a rotation of $2k\theta$ was applied to $\ket{s}$, and the amplitudes of the winning states are continuously amplified.
Finally, the $n$ qubits are measured to obtain a searched element with high probability.

The number of iterations that first yields a near-optimal solution (closest to $\ket{\omega}$) is denoted as $k_{best}\leq \left\lceil\frac{\pi}{4}\sqrt{\frac{N}{M}}\right\rceil$.
The quantum counting algorithm~\cite{1998-Brassard-QuantumCounting} is based on quantum phase estimation and Grover's algorithm and estimates the value of $\theta$, from which $k_{best}$ can be calculated.
Grover's algorithm with $k_{best}$ iterations results in a state that is closest to $\ket{\omega}$, 
so the probability amplitudes of all solution states are $\approx \frac{1}{\sqrt{M}}$ and the amplitudes of the other states are $\approx 0$.
Iterations of Grover's algorithm can not be applied partially, 
so $k_{best}$ has to be rounded up to the next integer (thus the ceiling operator).
This means that after applying Grover's algorithm with $k_{best}$ iterations,
still a small probability of measuring a wrong state remains (except for a small number of problem instances where $k_{best}$ is not rounded up).

A total of $log(N)$ gates are required to implement the diffusion operator $U_s$ so the overall complexity is $O(\sqrt{\frac{N}{M}}log(N))$ without the cost for the construction of the oracle $U_\omega$~\cite{2016-Nielsen-QCandQI}.
Grover's speedup is quadratic and not exponential but still considerable for large $N$.
Grover's algorithm was proven to be optimal in oracle calls in~\cite{1999-Zalka-GroverIsOptimal}.
