We investigate the current state of quantum computing for uniform random sampling of large configuration spaces and give predictions about future prospects. 
Due to the limitations of current quantum hardware and simulation of such, executing quantum-enabled uniform random sampling and comparing its empirical results to state-of-the-art classical random sampling algorithms will not lead to reasonable results.
Any instances of uniform random sampling problems that could be run on current quantum hardware are solved easily using classical algorithms, eliminating the need for quantum computations.
Hence, to judge the performance of quantum-enabled random sampling for relevant problem sizes, we perform a theoretical analysis.
As the computational complexity of Grover's search has already been determined to be $O(\sqrt{N})$, our algorithm conforms to this bound.
We consider three research questions about the feasibility, uniformity, and scale of our approach.
We describe the methodology to answer these questions, present the results and interpret them in a discussion.

\subsection{Research Questions}
We pose the following research questions for the evaluation of our approach: 
\subsubsection{Feasibility} 
Is it possible to construct quantum circuits that encode the valid configuration space and apply Grover's search algorithm to retrieve a valid configuration when measuring?
\subsubsection{Uniformity} 
If one measures the output multiple times to retrieve multiple configurations, how uniformly distributed are the obtained samples of the configuration space?
\subsubsection{Scalability} 
How do runtime and hardware requirements scale in relation to the size of the (valid) input configuration space?

\subsection{Methodology}

To answer our questions, we implemented the proposed method (see Section~\ref{sec:contribution}) that transforms a given feature model from a Boolean CNF into a quantum circuit. 
The method was implemented as a Jupyter Notebook using Qiskit.
It and the scripts created for this evaluation are available on GitHub\footnote{\url{https://github.com/KIT-TVA/grover-uniform-random-sampling}}.
This approach allows us to reason about feasibility and uniformity.
Feasibility can be evaluated by the fact that we are able to successfully implement and execute the proposed algorithm.
While, in principle, uniformity could be assessed by analyzing the measured outputs of the generated quantum circuits, either in a simulator or on real hardware, current limitations do not allow a meaningful empirical investigation:
Simulators are not capable of executing larger circuits with many qubits, and current NISQ quantum hardware inherently leads to errors.
While we cannot run or simulate the generated circuits, we are able to construct and reason about them without execution. Hence, we investigate circuits for the feature models of the BURST benchmarking suite~\cite{2021-Archer-BURST} as well as feature models provided by the software product line tool FeatureIDE~\cite{FeatureIDE}.
For the investigation of scalability, we observe quantum circuit metrics such as the number of qubits required (width) and the number of gates required (depth) for a specific configuration space.
This also allows us to estimate how capable current-generation quantum computers are of dealing with these problem instances.


\subsection{Results}

Tab.~\ref{tab:fmanalysis} shows the results of our circuit construction and analysis.
In the left half, we present metrics regarding the feature model, e.g., the number of features and the number of clauses when transformed to CNF.
The transformation from feature model to CNF is not part of our work but we noticed that the available DIMACS files are not optimized, e.g., some clauses are repeated, artificially bloating the size of the CNF.
We opted to not optimize the CNF formulas ourselves but take the input as is to be consistent with the real-world data.
%
%
\begin{table*}[tb]
    \caption{Results of the Evaluation for Different Feature Models}
    \begin{center}
    \begin{tabular}{|l|c|c|c|c||c|c|c|}
        \hline
        \multirow{3}{8em}{\textbf{Feature model}} & \multirow{3}{4em}{\textbf{\# of features}} & \multirow{3}{4em}{\textbf{\# of clauses}} & \multirow{3}{5em}{\textbf{\# of valid configurations}} & \multirow{3}{5em}{\textbf{\% valid configurations}} & \multirow{3}{4em}{\textbf{$k_{best}$}} &\multirow{3}{4em}{\textbf{Circuit width}}  & \multirow{3}{11em}{\textbf{Circuit depth transpiled for Statevector backend (IBM) for $k=1$}}\\
        & & & & & & & \\
        & & & & & & & \\ 
        \hline % depth is actually d*k-k+1 
        car & 10 & 17 & 1,80e+01 & 1,76\% & 5 & 28 & 162 \\
        sandwich & 19 & 27 & 2,81e+03 & 0,54\% & 10 & 47 & 322 \\
        bike & 54 & 127 & 1,12e+07 & 6,22e-10 & 31502 & 182 & 88 \\
        kconfig\_axTLS & 96 & 183 & 8,26e+11 & 1,04e-17 & 2,43e+08 & 280 & 218 \\
        kconfig\_uClibc & 313 & 1240 & 1,66e+40 & 9,95e-55 & 7,87418e+26 & 1554 & n/a \\
        kconfig\_Busybox\_1.18.0 & 854 & 1163 & 2,06e+201 & 1,72e-56 & 5,99576e+27 & 2018 & n/a \\
        kconfig\_EMBToolkit & 1179 & 5414 & 5,13e+96 & 6,24e-259 & 9,9316e+128 & 6594 & n/a \\
        \hline
    \end{tabular}
    \end{center}
    \label{tab:fmanalysis}
\end{table*}
%
The number of features and clauses directly contributes to the generated circuit width (column on the right).
Our approach requires one qubit per feature and one ancilla qubit per clause.
Additionally, one extra ancilla qubit is required for the conjunction of all clauses.
This means our circuit width is  $1+\#\mathit{features}+\#\mathit{clauses}$.

We show the circuit depth for one iteration ($k = 1$) for circuits transpiled for the IBM Statevector simulator as we are interested in
the total depth of a quantum circuit to reason about the possibility of running small examples on real quantum hardware. 
However, the circuit depth would increase further when transpiling for actual quantum hardware as not all qubits are connected and SWAP-gate sequences would have to be introduced to allow for the execution of a circuit.
%
To determine the total simulator circuit depth, it is required to know how many Grover iterations $k_{best}$ have to be performed.
As we have shown in Section~\ref{sec:grover} that $k_{best}$ depends on the number of valid entries in the search space, we determine the number of valid configurations for each feature model using the model counter GANAK~\cite{GANAK}.
Using this number and the fact that our search space is $2^{\#Features}$, we have all data needed to determine $k_{best}$.
The total simulator circuit depth can now be calculated by $k_{best} * (depth_{k=1}  - 1) + 1$.
Subtracting one from the circuit depth before multiplication is necessary as the given depth includes the superposition imposed by a one-deep set of Hadamard gates for initialization, which has to be executed only once.
For the car feature model, the total gate depth amounts to $806$. 
The other total depth values are computed analogously and are in the order of $k_{best}$. 

For each circuit, we also collect the ratio of the valid configuration space compared to the theoretical maximum size of the configuration space, which is exponential in the number of features, i.e., the percentage of valid configurations. 
This data point is collected because it allows us to reason about the runtime of Grover's algorithm for a specific problem class.


\subsection{Discussion}

Based on the results we collected, we now present answers to our research questions.

\subsubsection{Feasibility}
Our results show that it is possible to construct a quantum circuit based on Grover's search to randomly retrieve valid configurations from a configuration space. 
However, when executing or simulating circuits of even the smallest examples, we find that there will likely be incorrect or missing results due to the limitations of current NISQ-era quantum hardware.
However, in the future, when quantum hardware with a large number of error-free qubits and gates is available, the presented approach will be feasible for uniform random sampling. 

\subsubsection{Uniformity}
Assessing uniformity proves to be difficult for the quantum algorithm.
In theory, simulation with IBM Statevector perfectly (uniformly) amplifies the amplitudes of valid configurations while decreasing invalid states' amplitudes.
This would also be the case for a perfectly error-corrected quantum computer.
Yet, there remains the chance to measure an invalid configuration as the number of Grover iterations $k$ has to be rounded.
Rounding $k$ is required as we can not add fractions of our oracle-diffuser iterations to our circuit.
However, the equal superposition start vector $\ket{s}$ rarely requires an integer amount of reflections to get to $\ket{\omega}$ that encodes the valid solutions.\footnote{See the graphical explanation of Section~\ref{sec:grover} and Figure~\ref{fig:grover}}
Additional soundness checks have to be added to the presented algorithm to validate solutions and reject invalid configurations.
These should not come at any significant runtime costs as checking if an input satisfies a Boolean formula is computationally inexpensive.
Once these invalid configurations are rejected, we can expect a uniform random distribution over multiple measurements.
%
With current quantum hardware and simulators, these results can only be achieved for the smallest problem instances and according circuits as the hardware requirements of the simulators (especially system memory) grow exponentially.
With this in mind, currently, we are not able to empirically confirm the approach's uniformity.

\subsubsection{Investigation of Scalability}

The width of a quantum circuit generated by our approach scales linearly in the number of features and clauses of a given CNF.
The circuit's depth (quantum runtime) is bounded by the same magnitude as Grover's search algorithm, namely $O(\sqrt{\frac{2^n}{M}})$, where $n$ is the number of features and $M$ is the size of the configuration space (number of valid configurations).
While this is clearly better than listing all valid and invalid configurations ($2^n$), it still exceeds the capabilities of current quantum hardware.
The asymptotic scaling of classical uniform random sampling algorithms is not discussed in the literature, which makes comparison difficult.

We initially assumed that our practical domain turns out to be advantageous to Grover's search as we assumed the configuration space to take a rather large (approx. $~5\%$) part of all feature combinations.
This would result in a very small number of Grover iterations necessary. 
The results show that our intuition in that regard was wrong as the potential configuration space grows much faster than the valid configuration space for all models we investigated, as we can see in Tab.~\ref{tab:fmanalysis}.
Furthermore, if the percentage of valid configurations is high, randomly guessing configurations yields valid configurations with high probability.
This could be the basis of a probabilistic sampling algorithm that counts the occurrences of randomly obtained configurations and omits already encountered (to preserve uniformity) and invalid configurations without it impacting the expected runtime too much.
However, this still requires a source of true randomness.  

Lastly, regarding scale, we did not account for the classical cost of circuit construction.
In our experiments, we were not able to construct $k=1$ circuits with more than a few hundred qubits width in Qiskit due to the used Python runtime. 
Directly generating openQASM circuits as well as further optimizations of our code base could mitigate this. We plan to investigate this as future work.
