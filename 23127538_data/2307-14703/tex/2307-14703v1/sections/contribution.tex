This section shows our method to use Grover's search algorithm to sample a configuration space of a configurable system uniformly.
% Figure environment removed
% Figure environment removed
Fig.~\ref{fig:overview} provides an overview of our method.
The method starts with converting a feature model into a CNF~(1).
We create a uniform superposition~(2) of all configuration options on a quantum computer and then construct an oracle~(3) that knows about the validity of a given configuration, which represents the solution of a CNF. 
We combine the oracle with Grover's algorithm to amplify the solutions of the CNF and then perform a measurement~(4). 
The measurement randomly returns one possible solution of the CNF~(5), which is equal to randomly obtaining a valid configuration of the product line. 
After repeating this process multiple times, we derive multiple random configurations, representing a uniform random sample of the configuration space.

\subsection{Creating a Configuration Space Oracle}

We introduced quantum circuit fragments that are analogous to classical AND, OR, and NOT gates in our Background Section~\ref{sec:background} 
Using these three circuit fragments a quantum circuit for an entire CNF formula can be defined.
This circuit requires one qubit $q$ for each input variable in the CNF, one ancilla qubit $a$ for each clause in the CNF, and one output qubit $q_{tar}$.
First, each clause $c$ of the SAT formula is transformed into a circuit fragment by
applying $U_{or}$ controlled by each qubit $q$ present in the clause.
$U_{or}$ targets a separate $a_c$ and $X$-gates are applied before and after $U_{or}$ on $q$ if the variable is negated in $c$.
We denote the transformation of all separate clauses as $U_{clauses}$.
After applying $U_{clauses}$ once, one $U_{and}$ is applied controlled by all ancillas $a$ onto $q_{tar}$.
Finally, to uncompute the qubit states, the conjugate transpose ${U_{clauses}}^\dagger$ is applied.
This results in the feature model oracle $U_{FM}$.

$U_{FM}$ can predict if a variable assignment encoded into the input qubits is valid - specifically a valid configuration - on the target qubit ($q_{tar}=\ket{1}$ if the assignment is valid).
Furthermore, if the input qubits are initialized in uniform superposition over the whole configuration space, only valid configurations can be derived with a high probability using Grover's Algorithm.

\subsection{Applying Grover's Algorithm using the Oracle}
To use $U_{FM}$, which marks $q_{tar}$ with $\ket{0}$ or $\ket{1}$, it has to be transformed into a phase oracle that instead marks the phases of states.
Such a behavior can be achieved by a phase kickback onto $q_{tar}$.
For this, a sequence of $XH$ gates has to be added before $U_{FM}$ on $q_{tar}$.
After $U_{FM}$, the inverse sequence $HX$ has to be added as well.
This transforms $q_{tar}$ into the $\ket{-}$ state before applying $U_{FM}$ and reverses the transformation afterward.

Fig.~\ref{fig:satCircuit} displays an excerpt of the phase oracle $U_{FM'}$ for the running example:
For this problem instance with 10 variables and 8 clauses, the oracle has 19 qubits (10 input variable qubits + 8 ancilla qubits + 1 target qubit).
Fig.~\ref{fig:satCircuit} shows two wires representing variables the $manual(q_7)$ and $automatic(q_8)$ of the example CNF.
These variables are used in two clauses, which are transformed into $U_or$ and $X$ gates and connected to the ancilla qubits $a_7$ and $a_8$ respectively.
The qubit $q_tar$ for the results of the conjunction is initialized in the $\ket{-}$ state as discussed above.
After applying the conjunction ($U_{and}$) on all ancillas, the rest of the circuit is uncomputed so that only the phase information applied by $U_{and}$ remains.

The configuration space phase oracle $U_{FM'}$ is then used in Grover's Algorithm as oracle operator $U_\omega$ (see Section~\ref{sec:grover}).
The valid configurations are marked by $U_{FM'}$ and amplified by the diffusion operator $U_s$.
With this, the circuit construction is completed and can be deployed to simulators or quantum hardware.
