%!TEX root = ../../main.tex

\subsection{Optimal Label Subspaces}
\label{sec:optimal_subspaces}
Next we characterize the subset of distinct labels required to predict any label using our label model with respect to various types of metric spaces. 

We first consider label spaces whose metric is a tree graph---such metrics are, for example, related to performing hierarchical classification and weak supervision (where only partial labels are available). 
We consider a special type of tree called a phylogenetic tree, in which only the leaves can be designated as labels---phylogenetic trees are commonly used to relate the labels of image classification datasets. % such as ImageNet or CIFAR-100.
%
Afterwards we perform a similar analysis for grid graphs, which are important for label spaces that encode spatial information. 
Finally, we discuss the case in which no useful metric information is available, i.e., the complete graph.

Our goal in this section is to characterize the properties and size of $\{\lambda_i\}_{i=1}^K$ in each of these metric spaces such that we still have $\Pi({\bf\Lambda}) = \set{Y}$. 
%
We characterize `optimal' subsets of classes in each of the spaces under a certain notions of optimality.  
We provide several relevant definitions pertaining to this concept, starting with a notion of being able to predict any possible class using observed classes. 

\begin{definition}[Locus cover]
\label{def:loc_cover}
Given a set $\Lambda \subseteq \set{Y}$ for which we construct a tuple of its elements $\boldsymbol{\Lambda}$, if it holds that $\Pi(\boldsymbol{\Lambda}) = \set{Y}$, then $\Lambda$ is a locus cover. 
\end{definition}

Definition~\ref{def:loc_cover} captures the main idea of $\loki$---using some set of observed classes for which we can train classifiers, we would like to be able to predict additional unobserved classes using the geometry that relates the observed and unobserved classes. Namely, elements of $\Pi(\boldsymbol{\Lambda})$ are `reachable' using $\loki$. 
We refine this Definition to describe the trivial case that defaults to standard classification and the nontrivial case for which $\loki$ moves beyond standard classification. 

\begin{definition}[Trivial locus cover]
\label{def:trivial_loc_cover}
If $\Lambda = \set{Y}$, then $\Lambda$ is the trivial locus cover. 
\end{definition}

This Definition captures the notion of observing all of the classes in the label space. 
Here, all of the elements of $\set{Y}$ are trivially reachable using $\loki$. 
%Later, we show that the complete graph has only the trivial locus cover. 

\begin{definition}[Nontrivial locus cover]
\label{def:nontrivial_loc_cover}
A locus cover $\Lambda$ is nontrivial if $\Lambda \neq \set{Y}$. 
%$\Lambda$ is a nontrivial locus cover if $\Lambda$ is a locus cover with $\Lambda \neq \set{Y}$. 
\end{definition}

$\loki$ is more useful and interesting when faced with a nontrivial locus cover---under Definition~\ref{def:nontrivial_loc_cover}, we can use some subset of classes $\Lambda$ to predict any label in $\set{Y}$. 

\begin{definition}[Minimum locus cover]
\label{def:min_loc_cover}
Given a set $\Lambda \subseteq \set{Y}$, if $\Lambda$ is the smallest set that is still a locus cover, then it is a minimum locus cover. 
\end{definition}

In cases involving an extremely large number of classes, it is desirable to use $\loki$ on the smallest possible set of observed classes $\Lambda$ such that all labels in $\set{Y}$ can still be predicted. 
Definition~\ref{def:min_loc_cover} characterizes these situations---later, we obtain the minimum locus covers for all trees and grid graphs. 
It is worth noting that the minimum locus cover need not be unique for a fixed graph. 

\begin{definition}[Identifying locus cover]
\label{def:identifying_loc_cover}
Given a set $\Lambda \subseteq \set{Y}$, if $\Lambda$ is a locus cover where $\forall\, y \in \set{Y}, \, \exists\, \mathbf{w} \in \Delta^{|\Lambda|-1}$ such that $m_{\boldsymbol{\Lambda}}(\mathbf{w}) = \{ y \}$,
then $\Lambda$ is an identifying locus cover. 
\end{definition}

The Fréchet mean need not be unique---as an $\argmin$, it returns a set of minimizers. 
In certain metric spaces, the minimum locus cover can yield large sets of minimizers---this is undesirable, as it makes predicting a single class challenging. 
Definition~\ref{def:identifying_loc_cover} appeals to the idea of finding some set of classes for which the Fréchet mean \textit{always} returns a unique minimizer---this is desirable in practice, and in some cases, moreso than Definition~\ref{def:min_loc_cover}. 

\begin{definition}[Pairwise decomposable]
\label{def:pairwise_decomposable}
Given $\Lambda \subseteq \set{Y}$, $\Pi(\Lambda)$ is called pairwise decomposable when it holds that $\Pi(\Lambda) = \cup_{\lambda_1, \lambda_2 \in \Lambda} \Pi(\{\lambda_1, \lambda_2\}).$ 
\end{definition}

In many cases, the locus can be written in a more convenient form---the union of the locus of pairs of nodes. 
We refer to this definition as pairwise decomposability. 
Later, we shall see that pairwise decomposability is useful in computing the locus in polynomial time. 


\paragraph{Trees}
Many label spaces are endowed with a tree metric in practice: hierarchical classification, in which the label space includes both classes and superclasses, partial labeling problems in which internal nodes can represent the prediction of a set of classes, and the approximation of complex or intractable metrics using a minimum spanning tree. 
We show that for our purposes, trees have certain desirable properties that make them easy to use with $\loki$---namely that we can easily identify a locus cover that satisfies both Definition~\ref{def:min_loc_cover} and Definition~\ref{def:identifying_loc_cover}. 
Conveniently, we also show that any locus in any tree satisfies Definition~\ref{def:pairwise_decomposable}. 

We first note that the leaves of any tree yield the minimum locus cover. 
This is a convenient property---any label from any label space endowed with a tree metric can be predicted using $\loki$ using only classifiers trained using labels corresponding to the leaves of the metric space. 
This can be especially useful if the tree has long branches and few leaves. 
Additionally, for tree metric spaces, the minimum locus cover (Definition~\ref{def:min_loc_cover}) is also an identifying locus cover (Definition~\ref{def:identifying_loc_cover}). 
This follows from the construction of the weights in the proof of Theorem~\ref{thm:min_locus_trees} (shown in the Appendix) and the property that all paths in trees are unique. 
Finally, we note that any locus in any tree is pairwise decomposable---the proof of this is given in the Appendix (Lemma~\ref{lemma:tree_pairwise}). 
We will see later that this property yields an efficient algorithm for computing the locus. 

\paragraph{Phylogenetic Trees}
Image classification datasets often have a hierarchical tree structure, where only the leaves are actual classes, and internal nodes are designated as superclasses---examples include the ImageNet \cite{imagenet} and CIFAR-100 datasets \cite{cifar100}. 
Tree graphs in which only the leaf nodes are labeled are referred to as phylogenetic trees \cite{BILLERA2001733}. 
Often, these graphs are weighted, but unless otherwise mentioned, we assume that the graph is unweighted. 

For any arbitrary tree $T=(\set V, \set E)$, the set of labels induced by phylogenetic tree graph is $\set{Y} = \text{Leaves}(T)$. 
We provide a heuristic algorithm for obtaining locus covers for arbitrary phylogenetic trees in Algorithm~\ref{alg:phylo} (see Appendix). 
%The intuition of the algorithm design is that the endpoints of the longest paths, $\Gamma(y_i, y_j)$, are more likely to be a part of a small locus cover because shorter paths can leave lower subtrees unreachable. 
We prioritize adding endpoints of long paths to $\Lambda$, and continue adding nodes in this way until $\Pi(\Lambda)=\set{Y}$. 
Similarly to tree metric spaces, any phylogenetic tree metric space is pairwise decomposable.
We prove the correctness of Algorithm~\ref{alg:phylo} and pairwise decomposability of phylogenetic trees in the Appendix (Theorem~\ref{thm:algphylo} and Lemma~\ref{lemma:phylotree_pairwise}).
Later, we give algorithms for computing the set of nodes in an arbitrary locus in arbitrary graphs---if the locus is pairwise decomposable, the algorithm for doing so is efficient, and if not, it has time complexity exponential in $K$. 
Due to the pairwise decomposability of phylogenetic trees, this polynomial-time algorithm to compute $\Pi(\Lambda)$ applies. 
%As such, Algorithm~\ref{alg:phylo} has time complexity $O(K^4 D \max\{N|\mathcal{E}|, N^2 \log N\})$. 

\paragraph{Grid Graphs}
Classes often have a spatial relationship. 
For example, classification on maps or the discretization of a manifold both have spatial relationships---grid graphs are well suited to these types of spatial relationships. 
We obtain minimum locus covers for grid graphs satisfying Definition~\ref{def:min_loc_cover}, but we find that these are not generally identifying locus covers. 
On the other hand, we give an example of a simple identifying locus cover satisfying Definition~\ref{def:identifying_loc_cover}. 
Again, we find that grid graphs are in general pairwise decomposable and hence follow Definition~\ref{def:pairwise_decomposable}. 

We find that the pair of vertices on furthest opposite corners yields the minimum locus cover. 
While the set of vertices given by Theorem~\ref{thm:min_loc_grid} (found in the Appendix) satisfies Definition~\ref{def:min_loc_cover}, this set does not in general satisfy Definition~\ref{def:identifying_loc_cover}. 
This is because the path between any two vertices is not unique, so each minimum path of the same length between the pair of vertices can have an equivalent minimizer. 
On contrast, the following example set of vertices satisfies Definition~\ref{def:identifying_loc_cover} but it clearly does not satisfy Definition~\ref{def:min_loc_cover}.
\emph{Example}: Given a grid graph, the set of all corners is an identifying locus cover. 
On the other hand, the vertices given by Theorem~\ref{thm:min_loc_grid} can be useful for other purposes. 
Lemma~\ref{lemma:locus_grid_subspace} (provided in the Appendix) shows that subspaces of grid graphs can be formed by the loci of pairs of vertices in $\Lambda$. 
This in turn helps to show that loci in grid graphs are pairwise decomposable in general (see Lemma~\ref{lemma:grid_pairwise} in the Appendix). 


\paragraph{The Complete Graph}
The standard classification setting does not use relational information between classes. 
As before, we model this setting using the complete graph, and we show the expected result that in the absence of useful relational information, $\loki$ cannot help, and the problem once again becomes standard multiclass classification among observed classes. 
To do so, we show that there is no nontrivial locus cover for the complete graph (Theorem~\ref{thm:trivial_complete} in the Appendix). 

%Trivially, any locus on the complete graph is also pairwise decomposable. 
%It follows from Theorem~\ref{thm:trivial_complete} that 
%$$ \Pi(\Lambda) = \Lambda = \cup_{\lambda_i, \lambda_j \in \Lambda} \{\lambda_i, \lambda_j\} = \cup_{\lambda_i, \lambda_j \in \Lambda} \Pi(\{\lambda_i, \lambda_j\}). $$

