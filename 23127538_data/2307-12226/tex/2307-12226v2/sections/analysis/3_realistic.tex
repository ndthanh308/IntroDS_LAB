%!TEX root = ../../main.tex

\subsection{Label Subspaces in Practice}
While it is desirable for the set of observed classes to form a minimum or identifying locus cover, it is often not possible to choose the initial set of observed classes a priori---these are often random. 
In this section, we describe the more realistic cases in which a random set of classes are observed and an active learning-based strategy to choose the next observed class. 
The aim of our active learning approach is, instead of randomly selecting the next observed class, to actively select the next class so as to maximize the total size of the locus---i.e., the number of possible classes that can be output using $\loki$. 
Before maximizing the locus via active learning, we must first address a much more basic question: can we even efficiently compute the locus? 

\paragraph{Computing the Locus}
We provide algorithms for obtaining the set of all classes in the locus, given a set of classes $\Lambda$. 
We show that when the locus is pairwise decomposable (Definition~\ref{def:pairwise_decomposable}), we can compute the locus efficiently using a polynomial time algorithm. 
When the locus is not pairwise decomposable, we provide a general algorithm that has time complexity exponential in $|\Lambda|$---we are not aware of a more efficient algorithm. 
We note that any locus for every type of graph that we consider in Section~\ref{sec:optimal_subspaces} is pairwise decomposable, so our polynomial time algorithm applies. 
Algorithms~\ref{alg:locus_pairwise}~and~\ref{alg:locus_general} along with their time complexity analyses can be found in the Appendix. 

% Algorithm~\ref{alg:locus_pairwise} assumes that the locus is pairwise decomposable. 
% It operates by iterating over all pairs of observed classes, $\lambda_i, \lambda_j \in \Lambda$. Since the locus is pairwise decomposable, we can reduce the problem to computing the individual loci between each pair $\lambda_i, \lambda_j$---each of which can be computed efficiently by sweeping over the choices of weights $\mathbf{w} = [w_1, w_2]$ and computing the Fréchet mean for each configuration. 
% The time complexity of Algorithm~\ref{alg:locus_pairwise} is $O(K^2 D \max\{N|\mathcal{E}|, N^2 \log N\})$ where $\mathcal{E}$ is the number of edges in the graph.
% Algorithm~\ref{alg:locus_pairwise} and its time complexity analysis are provided in the Appendix. 

% Computing the locus when pairwise decomposability does not hold appears to be more challenging, and has time complexity that scales with the size of $\Lambda$. 
% Algorithm~\ref{alg:locus_general} is a brute-force approach to computing the locus, which operates by sweeping over all possible choices of weights $\mathbf{w} \in [0, 1]^{K}$ and computing the Fréchet mean for each configuration.
% The time complexity of this algorithm is $O(D^K)$. 
% While it might be possible to improve this algorithm by exploiting the fact that $\mathbf{w}$ can be constrained to the simplex without loss of generality and by exploiting symmetries, we believe that this will not lead to the exponential speedup necessary to obtain an efficient algorithm for computing a non-pairwise decomposable locus. 
% Algorithm~\ref{alg:locus_general} and its time complexity analysis can be found in the Appendix. 


\paragraph{Large Locus via Active Next-Class Selection}
\label{sec:active_selection}
We now turn to actively selecting the next class to observe in order to maximize the size of the locus. 
For this analysis, we focus on the active learning setting when the class structure is a tree graph, as tree graphs are generic enough to apply to a wide variety of cases---including approximating other graphs using the minimum spanning tree. 
Assume the initial set of $K$ observed classes are sampled at random from some distribution. 
We would like to actively select the $K+1$st class such that $|\Pi(\Lambda)|$ with $\Lambda = \{\lambda\}_{i=1}^{K+1}$ is as large as possible. 

\begin{theorem}
\label{thm:active_largest}
Let $T = (\mathcal{Y}, \mathcal{E})$ be a tree graph and let $\Lambda \subseteq \mathcal{Y}$ with $K = |\Lambda|$. 
Let $T'$ % = (\Pi(\Lambda), \{(v_1, v_2): v_1, v_2 \in \Pi(\Lambda) \text{ and } (v_1, v_2) \in \mathcal{E}\})$ 
be the subgraph of the locus $\Pi(\Lambda)$. 
The vertex $v \in \mathcal{Y} \setminus \Lambda$ that maximizes $|\Pi(\Lambda \cup \{v\})|$ is the solution to the following optimization problem:
$\argmax_{y \in \mathcal{Y} \setminus \Pi(\Lambda)} d(y, b)$ s.t. $b \in \partial_{\text{in}} T'$ and $\Gamma(y, b) \setminus \{b\} \subseteq \mathcal{Y} \setminus \Pi(\Lambda)$. 
% \begin{argmaxi*}|s|
% {y \in \mathcal{Y} \setminus \Pi(\Lambda)}{d(y, b)}
% {}{}
% \addConstraint{b \in \partial_{\text{in}} T'}
% \addConstraint{\Gamma(y, b) \setminus \{b\} \subseteq \mathcal{Y} \setminus \Pi(\Lambda)}, 
% \end{argmaxi*}
where $\partial_{\text{in}} T'$ is the inner boundary of $T'$ (all vertices in $T'$ that share an edge with vertices not in $T'$). 
\end{theorem}

This procedure can be computed in polynomial time---solving the optimization problem in Theorem~\ref{thm:active_largest} simply requires searching over pairs of vertices. 
Hence we have provided an efficient active learning-based strategy to maximize the size of the locus for trees. 

% \paragraph{Trees}
% \begin{lemma}
% Let $y \in \Pi(\Lambda)$ and let $y' \in \Pi(\Lambda)$, Then $\Gamma (y, y') = \Gamma(y, z) \bigcup \Gamma(z, y')$, where $\Gamma(y, z) \subseteq \Pi(\Lambda)$ and $\Gamma(z, y') \setminus{z}$ has no vertices in $\Pi(\Lambda)$
% \end{lemma}
% \begin{proof}
% Proof by contradiction. Assume there is a node $\lambda \in \Gamma(z, y')$ also in $\Pi(\Lambda)$. Any pair of leaves $l_1$ and $l_2$ have unique path. We can find the shortest distance from $\lambda$ to the point $z \in \Pi(\Lambda)$. If the shortest geometric distance is 1, we can expend $\Gamma(y, z)$ to $\Gamma(y, \lambda)$, which contradict our initial Definition. Therefore, there should exist $v \notin \Pi(\Lambda)$ satisfied $dist(v, \lambda) = 1$ along the unique path between $z$ and $\lambda$. Since $\lambda \in \Pi(\Lambda)$, there should have a path between another point inside $\Pi(\Lambda)$ and $\lambda$. Then, it is a cycle. 
% \end{proof}

% TODO not sure we need this
% \paragraph{Grid graphs}
% \begin{lemma}
% TODO @Nick (define the algorithm clearly, Kaylee don't know how to define it formally): Add the $\max\min \lambda$ can give us the maximum span.
% \end{lemma}
% \begin{proof}
% From the lemma, we need the point with the longest distance toward any point inside $\Pi(\Lambda)$
% \end{proof}
