\section{\nnef extension for multiple items}
% The final paper will describe the work that has been done for the extension of the semantics that enable the development of critical application for avionics embedding neural networks. 
% It is based on adding to \nnef primitive that enable to distribute and synchronize an original network over several items (HW or SW). The scheduling semantics will also be expressed using the semantics of colored \petri net.
\label{sec-nnef-ext}
The purpose of this section is to propose a manner to separate the specification of each item  so that any execution of the items respecting the specification  properly encode the global ML model.
To that extent, we propose first to extend the syntax
of \nnef to allow explicit parallelization and then to express the associated semantics with colored \petri nets.


\subsection{Extension for item splitting}
We first need to specify the item on which the description will be implemented. To that end,
we enrich the graph definition with the keyword \emph{graphitem}
to provide the logical id of the HW or SW item. 

\begin{mysyntax}[GraphItem]
  \begin{verbatim}
<graph-definition> ::= <graph-declaration> 
  <graph-declaration-item> <body>

<graph-declaration-item> ::= "graphitem" 
  <identifier> <identifier>"("<identifier-list>")" 
  "-$>$" "("<identifier-list>")"
\end{verbatim}
\end{mysyntax}

\begin{semantic}
  The first \emph{$<$identifier$>$} refers to the item id,
  the second \emph{$<$identifier$>$} is the name of the local node
  and
  elements of the \emph{$<$identifier-list$>$} will be input or output of the graphitem. 
The semantic of the \emph{$<$graph-declaration-item$>$}
is such that all instructions within the 
\emph{$<$body$>$} are executed by the item.
%We introduce the possibility to have input or output exchanged between different \emph{$<$graph-declaration-item$>$}.
\end{semantic}


%\subsection{Extension to allow synchronization between items}
We also need to \emph{exchange data} between several items and ensure that those exchanged data are available before computation.
To that end, we introduce a new type of variable, namely \emph{variablesync}.
This references a variable that could be read from or write to another \emph{graphitem}. We use a \emph{fragment} to define this new type.

\begin{mysyntax}[VariableSync]
\begin{verbatim}
fragment variablesync<? = scalar>
    (shape: integer[])  -> ( output: tensor<?> )
\end{verbatim}
\end{mysyntax}

\begin{semantic}
  Each \emph{variablesync} is a shared variable with a unique writer and possibly multiple readers.
  Writer is in charge to transmit the variable via the instruction \emph{send\_var}
  and each reader can access this data via \emph{get\_var} instruction.
\end{semantic}
    
We then define new \nnef instructions to send or get data between several \emph{graphitem}. 

\begin{mysyntax}[get_var]
\begin{verbatim}
fragment get_var<? = scalar>(source : graphitem,
    data  : variablesync) -> ( output: tensor<?> )
\end{verbatim}
\end{mysyntax}

\begin{semantic} \emph{get_var} appears in each reader description.
  The output of this instruction is a local
  variable that gets the content of the shared variable
  and which is available for the caller item.
\emph{Source} is the item that writes and provides the shared variable the name of which is given by
\emph{data}.
%The output is the name of the local tensor that will get the content of the share variable.
\end{semantic}

Similarly, the writer must define the instruction to send a shared variable to other items.
\begin{mysyntax}[send_var]
\begin{verbatim}
fragment send_var<? = scalar>
    (  dest  : graphitem[], data  : scalar) 
    -> ( output: variablesync )
\end{verbatim}
\end{mysyntax}

\begin{semantic} \emph{send\_var} appears in the writer description only.
  It takes as input the list of reader items and the name of the tensor that shall be sent.
  The output tensor is a global \emph{variablesync}
  that will support the \emph{synchronization}.
\end{semantic}

The rest of the \nnef syntax remains unchanged.


\subsection{Splitting an \nnef description into multi-item descriptions}
\label{subsec-split-nnef}
Initially, the DNN is described in a unique \nnef
description as shown in section \ref{sec-nnef}.
Such a description contains 3 types of instructions:
\begin{itemize}
\item definition of input tensor(s);
\item definition of fixed parameters;
\item variables computed by each layer.
\end{itemize}
A splitting consists in partitioning the last type of instructions among the items,
adding the adequate definition(s) of tensors / fixed parameters
and adding the adequate \emph{send_var} / \emph{get_var}.
The composition of item descriptions  shall respect the semantics
of the full \nnef description. 



\begin{example}
  \label{ex-multiple-nnef}
  \it
Let us consider the DNN of listing \ref{completeMLMD} with its associated \petri net (figure \ref{fig-net-complete}).
Let us assume that the DNN is allocated on 3 items such that $o_1$, $o_6$, $o_7$ and $out$ are computed on item 1;
  $o_2$, $o_3$ are computed on item 2 and  $o_4$, $o_5$ are computed on item 3.
Thus, the description on the items is given in Listing \ref{MLMID1}.

% Figure environment removed

% Figure environment removed

 

%\noindent
%\begin{minipage}{.42\linewidth}
%\end{minipage}\hfill
%\begin{minipage}{.42\linewidth}
%  \lstinputlisting[ caption=\nnef for ITEM2]
%  {../MLMID/MLMIDcoshort-2.txt}
%\end{minipage}

The union of the instructions of each item corresponds to the complete \nnef description with the additional \emph{variablesync}
and the communication instructions.
Locally in the item, the pointers to the input tensor and fixed parameters must also be declared.
\end{example}

% Figure environment removed

\subsection{\petri-based semantic}
We define the execution model semantics of  multi-item descriptions
using coloured \petri nets \cite{colorpetri}.
We associate a colour to each item where the colour is set to the tokens
and edges (on which the coloured tokens transit).

\begin{translation}
  Let assume there are $N$ items.
  We first apply the translation \ref{trans-nnef-petri} for each item leading to $N$
  independent \petri nets $(P_i,T_i,V_i)$, each with a unique and distinct colour.
For the new instruction, the translation is extended as follows:  
\begin{itemize}
\item a \emph{varsync} does not generate any place;
\item a \emph{get\_var} does not generate any transition;
\item a \emph{send\_var} produces a transition \emph{sync}
  with an incoming edge from the variable the content of which is transmitted.
\end{itemize}

The set of \nnef item descriptions generates a \petri net $(P,T,V)$
which is roughly speaking the union of the $N$ \petri nets $(P_i,T_i,V_i)$.
More precisely,
\begin{itemize}
\item any input tensor or fixed parameter that is duplicated in the \nnef files appears in the \petri net of the item.
  Those duplicated places are merged. Because we use the same naming convention,
  $P=\cup P_i$;
\item the initial tokens in the places are also merged leading to places with possibly multiple tokens and multiple colours;  
\item $T=\cup T_i \cup T'$ where $T'$ are the transitions connecting places of one item to other items thanks to the \emph{sync} transition. More precisely,
\begin{itemize}
\item for each writer, there are $k$ edges back from the \emph{sync} label where $k$ is the number of readers. The colour of the each arrow is the one of the reader and the number of tokens sent back corresponds to the number of time the shared variable appears in the reader item instructions;
\item for each reader, there is an edge from the writer place before \emph{sync} to each transition requiring the shared data;
\end{itemize}
  \item As before, when a coloured token is present in a place, it means that the associated variable is available for the item identified by the colour
and can be used by transition.
\end{itemize}
%A \emph{sync} is the only transition that can have different edges colour for inputs or outputs.
\end{translation}

\begin{example}
  \it
The \petri net associated to the example \ref{ex-multiple-nnef} is given in figure \ref{fig:sync}. We present the initial marking with colored tokens. Each color represents the state of one item. Compare to the figure \ref{fig:sem}, we express here the multi items semantics with synchronizations.
\end{example}

 % Figure environment removed
  
\begin{property}[Equivalence between \petri nets]
  The semantics of the multi-items behaviour is equivalent to the complete original ML model.
\end{property}


\begin{remark}
  It is important to explicitly describe the \emph{send_var} and \emph{get_var}
  either in the \nnef files but also in the \petri net
  because items are supposed to be independent
  and segregated.
  In particular, an item X is not allowed to access the memory space of an item Y and interfere with its execution.
 % Thus, the implementation must respect this requirement which is traced in the description files.
  This is classical in aeronautics, see Arinc 653 specification.
  The \xtratum hypervisor \cite{xtratum} is an example of \emph{time and space partitioning} hypervisor that provides communication with \emph{sampling} and \emph{queuing} ports (close to Arinc 653 requirements).
\end{remark}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXAMPLE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


