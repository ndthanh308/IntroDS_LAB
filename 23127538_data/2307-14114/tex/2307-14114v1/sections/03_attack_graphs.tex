% !TEX root = ../AttackGraphBasedRiskAnalysis.tex
% !TEX spellcheck = en_US
% !TEX encoding = UTF-8 Unicode

\section{Attack Graphs}\label{sec: attack graphs}

This article proposes the use of a \emph{DAG structure} for the development of the security modeling framework. 
DAGs consist of nodes, which are connected through directed edges that do not form any loops. 
The main DAG components are illustrated in Weiss's attack tree~\cite{weiss1991} shown in Figure~\ref{fig: attack tree weiss}.

% Figure environment removed

\subsection{Attack Graph Components}\label{sec: attack graph components}

This section summarises the main components of an Attack Graph.\\

\noindent
\textbf{Nodes}\\
\emph{Nodes} represent the attacker's goals. 
There are three different types of nodes: (1) Root Nodes, the set of which is defined as $\mathcal{R}$, (2) Leaf Nodes, the set of which is defined as $\mathcal{L}$, and (3) Inner Nodes, the set of which is defined as $\mathcal{I}$.
Finally, all nodes $\emph{n} \in \mathcal{N}$ form the set $\mathcal{N}$:

\begin{center}
$\mathcal{N} = \mathcal{R} \cup \mathcal{L} \cup \mathcal{I}$.
\end{center}

\noindent
\textbf{Edges}\\
\emph{Edges} indicate relations between nodes. 
Attack Graphs use directed edges, thereby enabling nodes to have \emph{predecessors} (also called \emph{parents} or \emph{ancestors}) and/or \emph{successors} (also called \emph{children}). 
The set of predecessors of a node $n \in \mathcal{N}$ is defined as $Pred_n$, and the set of successors of a node $n \in \mathcal{N}$ is defined as $Succ_n$. 
For example, for node $n$ := \enquote{Access System Console} in Figure~\ref{fig: attack tree weiss}, $Pred_n$ = \{\enquote{Obtain Admin. Privileges}\} and $Succ_n$ = \{\enquote{Enter Computer Center}, \enquote{Corrupt Operator}\}.\\

\noindent
\textbf{Root Nodes}\\
A node that has no predecessor is a Root Node $\emph{r} \in \mathcal{R}$. \emph{Root Nodes} indicate the main goal of the attack. 
For example, the Root Node in Figure~\ref{fig: attack tree weiss} is \enquote{Obtain Admin. Privileges}.\\

\noindent
\textbf{Leaf Nodes}\\
A node that has no successor is a Leaf Node $\emph{l} \in \mathcal{L}$. 
\emph{Leaf Nodes} indicate basic actions that can easily be understood and quantified. 
For example, three Leaf Nodes in Figure~\ref{fig: attack tree weiss} are \enquote{Break in to Comp. Center}, \enquote{Obtain Password File}, and \enquote{Corrupt Sys. Admin}.\\

\noindent
\textbf{Inner Nodes}\\
A node that has at least one predecessor and at least one successor is an Inner Node $\emph{i} \in \mathcal{I}$. 
On one hand, \emph{Inner Nodes} are specialized actions, goals, or sub-goals of their predecessor nodes. 
On the other hand, they are generalized actions or goals of their successor nodes. 
For example, two Inner Nodes in Figure~\ref{fig: attack tree weiss} are \enquote{Access System Console} and \enquote{Enter Computer Center}.\\

\noindent
\textbf{Node Attributes}\\
Nodes are refined into sub-goals until they represent basic actions. 
Basic actions can then be quantified by assigning \emph{attributes}, which are quantifiable properties, to nodes.
A set of node attributes is defined as $\mathcal{A}$. 
For every $\emph{a}_k \in \mathcal{A}$, there exists a value $\emph{v}_m \in \mathcal{V}_k $, where $\mathcal{V}_k$ is the finite set of acceptable values of the attribute $\emph{a}_k \in \mathcal{A}$. 
The process of assigning values to an attribute is defined by the function $g$:

\begin{center}
$g(\emph{a}_k) = \emph{v}_m$,
\end{center}

\noindent
where $\emph{a}_k \in \mathcal{A}$ is an attribute of a node $\emph{n} \in \mathcal{N} $, and $\emph{v}_m \in \mathcal{V}_k$ is a value of this attribute. 
The set $\mathcal{F}_g$ contains all functions $g$ that assign values to attributes.\\

% A set of attributes of a specific node $\emph{n}_i \in \mathcal{N}$ is defined as $\mathcal{A}_i \subseteq \mathcal{A}$. Hence, every node can be expressed as a tuple of itself, and tuples of its attributes and their values $\emph{n}_i := (\emph{n}_i, (\emph{a}_1, \emph{v}_1), (\emph{a}_2, \emph{v}_2), ..., (\emph{a}_j, \emph{v}_j))$ with $\emph{n}_i \in \mathcal{N}$, $\emph{a}_1, ..., \emph{a}_j \in \mathcal{A}_i$ and $\emph{v}_1 \in \mathcal{V}_1, \emph{v}_2 \in \mathcal{V}_2, ..., \emph{v}_j \in \mathcal{V}_j$.\\ % (\emph{n}_i, (a_i, v_i)\in\mathcal{A}\times\mathcal{V})=

\noindent
\textbf{Edge Attributes}\\
The relation between nodes can be quantified by assigning attributes to edges. 
A set of edge attributes is defined as $\mathcal{A}_\mathcal{E}$. Edge attributes cannot be assigned to nodes, and similarly, node attributes cannot be assigned to edges.
Therefore, $\mathcal{A}_\mathcal{E} \cap \mathcal{A} = \emptyset$.\\

\noindent
\textbf{Connectors}\\
\emph{Connectors} $\emph{c} \in \mathcal{C}$ indicate the refinements of nodes. 
Conjunctive refinements (AND) indicate that \emph{all} successor nodes need to be fulfilled to achieve the refined node's goal.
Disjunctive refinements (OR) indicate that \emph{at least one} successor node needs to be fulfilled to achieve the goal of the refined node.\\

% Other refinements can be e.g., XOR ($\oplus$) or k-out-of-n ($\binom{n}{k}$).

\noindent
\textbf{Aggregated Attributes}\\
By definition, a node $n \in \mathcal{N}$ and all successor nodes $Succ_n$ have the same set of attributes. 
Hence, the attribute values of node $n \in \mathcal{N}$ are determined by aggregating the attribute values of all of its successor nodes $Succ_n$. 

For example, let $n_2$ and $n_3$ be successor nodes of $n_1$, with $n_1$, $n_2$, $n_3 \in \mathcal{N}$.
Further, let $a_1$ be an attribute from the set $\mathcal{A}$.
Then, there is a set $\mathcal{V}_1$ with acceptable values for the attribute $a_1$ and all three nodes have this attribute
To determine the value for $a_1$ of node $n_1$, the values of $a_1$ of the nodes $n_2$ and $n_3$ are aggregated using a function $f$.
Whereas the result value needs to be in the set of acceptable values $\mathcal{V}_1$ for $a_1$.
%This aggregation can also be done over multiple differing attributes.
%For example, for an attribute $a_k \in \mathcal{A}$, there exists a set of values $\mathcal{V}_k := \{v_m, v_{m+1}, ..., v_{m+n}\}$. \todo{das ist mathematisch nicht korrekt dargestellt}
%Then, the attributes of the successor nodes $Succ_n$ = \{$n_i, n_{i+1}, ... \in \mathcal{N}$\} are assigned values from the set $\mathcal{V}_k$. 
%Finally, these values are aggregated to determine value $v \in \mathcal{V}_k$ of attribute $a_k$ of node $n$. 
%To compute value $v \in \mathcal{V}_k$, a function that takes values from the set $\mathcal{V}_k$ as input and returns value $v \in \mathcal{V}_k$ as output needs to be defined.

An attribute value can be typically computed using a function that returns (1) the \emph{maximum}, (2) the \emph{minimum}, (3) the \emph{sum}, or (4) the \emph{product} of a set of given attribute values. 
In this case, the set of attribute values $v_m \in \mathcal{V}_k$ needs to be arranged in a natural sort order, where $x_{min}$ is the smallest and $x_{max}$ is the largest value of the set. 
The following functions are commonly utilized for aggregating attributes. 
However, our framework is open to other functions as well.
In the following definitions, $a_1$ represents the attribute for node $n_1$, $a_2$ represents the attribute for node $n_2$, and so on.
However, all attributes $a_1$, $a_2, ...$ represent the same property, e.g., knowledge needed to perform this action.

\smallskip
\noindent
\textbf{Maximum.} The maximum function takes only the highest value:
\begin{center}
$f_{max}(g(a_1), g(a_{2}), ..., g(a_{k})) = \max\{ g(a_1), g(a_{2}), ..., g(a_{k})\}$.
\end{center}

\noindent
\textbf{Minimum.} The minimum function takes only the lowest value:
\begin{center}
$f_{min}(g(a_1), g(a_{2}), ..., g(a_{k})) = \min\{ g(a_1), g(a_{2}), ..., g(a_{k})\}$.
\end{center}

\noindent
\textbf{Sum.} The sum function adds the values:
\begin{center}
$f_{sum}(g(a_1), g(a_{2}), ..., g(a_{k})) = \min\{\sum\limits_{j = 1}^{k} g(a_j), x_{max}\}$.
\end{center}

\noindent
\textbf{Product.} The product function multiplies the values:
\begin{center}
$f_{prod}(g(a_1), g(a_{2}), ..., g(a_{k})) = \min\{\prod\limits_{j = 1}^{k} g(a_j), x_{max}\}$.
\end{center}

\subsection{Attack Graph Definition}\label{sec: attack graph definition}

We thus arrive at the following definition of an Attack Graph.\\

\noindent
\emph{An Attack Graph $\mathcal{G}$ is a directed acyclic graph (DAG) containing logical connectors $\mathcal{C}$ and depicting an attack scenario. 
The edges $\mathcal{E}$ are weighted, and the nodes $\mathcal{N}$ include attributes $\mathcal{A}$ that represent the difficulty of performing this attack step. Attributes have a predefined set of values $\mathcal{V}$. 
Finally, functions in the set $F_g$ assign the values to the attributes, and functions in the set $F_f$ aggregate values of successor nodes.}\\

\begin{center}
$\mathcal{G} = \{\mathcal{N},\mathcal{E}, \mathcal{C},\mathcal{A},\mathcal{V},\mathcal{F}_f,\mathcal{F}_g\}$
\end{center}