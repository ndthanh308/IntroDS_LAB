Our \hpc\ system consists of three parts: (1) a user interface which
allows the user to write a proof file, (2) a parser that performs some
basic well-formedness checks on a given proof file and (3) a proof
checking backend that validates a syntactically well formed proof for
correctness.

We provide two primary interfaces for \hpc: a Web-based editor and an
Eclipse plugin. The Web-based editor requires no setup on the user's
part but has fewer features and is slower than the Eclipse plugin,
since much of its functionality comes from making requests to a remote
server. The Eclipse plugin is faster and has more features, but
requires more effort to set up locally.
Figure~\ref{fig:eclipse-plugin-screenshot} shows a screenshot of our
Eclipse plugin. We discuss features of the user interface in more detail.

% Figure environment removed

In both the interfaces, the results of checking a proof are
communicated to the user in two ways: (1) by producing a simplified
list of the checks that is performed for each proof and their status,
with some additional details if the check failed, as is shown in the
``Checker Output'' panel on the top-right-hand side of
Figure~\ref{fig:eclipse-plugin-screenshot}, and (2) by marking
particular areas of the user's conjectures with
\textit{diagnostics}. An error diagnostic can be seen in
Figure~\ref{fig:eclipse-plugin-screenshot}, visualized by the red
underlining of part of the conjecture shown on the left-hand side of
the screenshot. Certain checks may give rise to lower-severity
diagnostics, like warnings or informational notes.

We spent significant time and effort in developing user-facing
messages that are easy to understand, useful and actionable. In fact,
this is the raison dâ€™etre for having Phase I. But we also owe much to
the years of usage that \hpc\ has accumulated and the experience we
have gained perfecting it.

The Eclipse plugin is equipped with several features to improve the
proof-editing experience. Parts of a proof, or even entire proofs, can
be folded (hidden) when desired to maximize the screen space available
for content of interest (using $\oplus$ and $\ominus$ buttons to the left of text
seen in the screenshot) which makes it easy to browse a large proof
file. An outline view is available that allows one to easily identify
and navigate to specific areas of a document. Certain keywords like
Conjecture, Proof, Def etc... are highlighted. Highlighting of matched
parentheses and basic code completion are provided. The Eclipse plugin
also provides links to online documentation describing the conjecture
format we use, and answers to frequently asked questions.

We use the Xtext system~\cite{xtext} to implement both the parser and
a portion of both the user interfaces. Xtext is a Java-based framework
for developing tooling for domain-specific languages. By providing a
grammar, Xtext generates not only a parser but also IDE features like
code completion, syntax highlighting and code folding. The default
behavior that Xtext provides can be modified by providing Java
code. We configure Xtext to generate both an Eclipse plugin and
supporting functionality for the CodeMirror Web-based editor. Phase 0
checks described in the previous section are implemented by the parser
that Xtext generates automatically from the grammar we provide, though
we augment its error-handling abilities to produce more helpful error
messages in certain conditions. Xtext provides the ability to define
arbitrary checks (called ``validators'') for a document written in a
DSL. These validators take in an abstract syntax tree (AST), process
it and mark different parts of the AST with various diagnostics as
needed. Xtext handles mapping these errors back to the text of the
document and rendering them to the user. To integrate our proof
checker backend with Xtext, we define a validator that encodes the
conjecture document in a form readable by our backend, runs the
backend in a subprocess, captures and parses the output from the
backend, and translates that output into Xtext diagnostics.

The backend is responsible for checking the correctness all of the
proofs contained in a document. It performs Phase I and Phase II
checks as described in the previous section and uses the ACL2s Systems
Programming methodology that we have
developed~\cite{walter-acl2-systems-programming}. That is, most of the
backend's code is written in Common Lisp and runs in a Common Lisp
environment that has ACL2 loaded. It interacts with ACL2 through a set
of interface functions, making it easier to identify which code
interacts with the theorem prover and reducing the risk of
accidentally modifying ACL2 internals, thereby making ACL2
unsound. This potential unsoundness is mitigated for our purposes as
\hpc\ produces ACL2s proofs that can be checked by running them
through an unmodified ACL2s instance.

The backend takes in a syntactically correct
proof document that consists of ACL2 expressions interleaved with
conjectures. We define data structures in Common Lisp that track
metadata attached to expressions or parts of a conjecture, which
informs us where certain diagnostics should appear. The proof document
is represented as a sequence of these data structures. In brief, when
given a proof document, the backend performs some setup, sequentially
evaluates each element of the proof document while collecting
diagnostics, and then reports the diagnostics in an XML document. This
XML data is captured and consumed by our Xtext validator and is
translated into Xtext diagnostics, which are visible to the user
through whichever frontend they are using.
