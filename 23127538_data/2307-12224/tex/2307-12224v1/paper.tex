
\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate,numberwithinsect]{lipics-v2021}
%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"
%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Calculational Proofs in ACL2s}

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

%\author{Jane {Open Access}}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional. Use additional curly braces to indicate the correct name splitting when the last name consists of multiple name parts.

\author{Andrew T. Walter}{Khoury, Northeastern University, Boston, USA
  \and \url{https://www.atwalter.com/}}{walter.a@northeastern.edu}{https://orcid.org/0000-0002-7588-263X}{}

\author{Ankit Kumar}{Khoury, Northeastern University, Boston,
  USA \and \url{https://ankitku.github.io}}{kumar.anki@northeastern.edu}{https://orcid.org/0000-0001-9587-2861}{}

\author{Panagiotis Manolios}{Khoury, Northeastern University, Boston,
  USA \and \url{https://www.ccs.neu.edu/home/pete/index.html}}{p.manolios@northeastern.edu}{https://orcid.org/0000-0003-0519-9699}{}

\authorrunning{A. T. Walter and A. Kumar and P. Manolios} % mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Andrew T. Walter and Ankit Kumar and Panagiotis Manolios} % mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

%\ccsdesc[100]{\textcolor{red}{Replace ccsdesc macro with valid one}} %TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm

\ccsdesc[500]{Theory of computation~Equational logic and rewriting}

\keywords{ACL2s, Theorem Proving, Education, Reasoning, Calculational Proofs} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{We sincerely thank Ken Baclawski, Raisa Bhuiyan,
  Harsh Chamarthi, Peter Dillinger, Robert Gold, Jason Hemann, Andrew
  Johnson, Alex Knauth, Michael Lin, Riccardo Pucella, Sanat Shajan,
  Olin Shivers, David Sprague, Atharva Shukla, Ravi Sundaram, Stavros
  Tripakis, Thomas Wahl, Josh Wallin, Kanming Xu and Michael Zappa for
  their help with developing and teaching with \hpc. We also thank all
  of the Teaching Assistants and students in CS2800, who are too
  numerous to list individually, who used and provided feedback on
  \hpc.}

\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{imports}
\begin{document}

\maketitle

%% \abstract{Learning how to write proofs is a crucial pedagogical objective of
%%   courses introducing reasoning to college students. Calculational proofs,
%%   consisting of a series of steps separated by justifications, are great for
%%   this purpose.  Dijkstra, in one of his manuscripts, notes that
%%   ``Calculational arguments are praised for their rigour, for their
%%   completeness, for their brevity, and lately for their amenability to
%%   mechanical verification...''. However, without a formal proof format and
%%   mechanical verification, it is difficult to differentiate between a
%%   calculational proof and a word salad. In this work, we present a
%%   calculational proof format, a corresponding proof checker called \hpc, an
%%   Eclipse IDE plugin for writing and checking calculational proofs and several
%%   formalized proofs including and imitating some of Dijkstra's proofs from his
%%   manuscripts. In recent years, students of our Logic and Computation class
%%   have used \hpc\ to automatically check their proofs and get helpful feedback
%%   for writing clear, rigourous, complete and correct proofs.}

\begin{abstract}
Teaching college students how to write rigorous proofs is a
  critical objective in courses that introduce formal reasoning. Over
  the course of several years, we have developed a
  mechanically-checkable style of calculational reasoning that we used
  to teach over a thousand freshman-level undergraduate students how
  to reason about computation in our ``Logic and Computation'' class
  at Northeastern University. We were inspired by Dijkstra, who
  advocated the use of calculational proofs, writing ``calculational
  proofs are almost always more effective than all informal
  alternatives, \ldots, the design of calculational proofs seems much
  more teachable than the elusive art of discovering an informal
  proof.'' Our calculational proof checker is integrated into ACL2s
  and is available as an Eclipse IDE plugin, via a Web interface, and
  as a stand-alone tool. It automatically checks proofs for
  correctness and provides useful feedback. We describe the
  architecture of the checker, its proof format, its underlying
  algorithms and provide examples using proofs from Dijkstra and from
  our undergraduate class. We also describe our experiences using the
  proof checker to teach undergraduates how to formally reason about
  computation.
\end{abstract}

\section{Introduction}

We present a calculational proof checker for ACL2s that was designed
to help undergraduate computer science students learn how to reason
about computation. In Spring of 2008, Manolios developed a course
entitled ``Logic and Computation,'' a required, freshman-level course
for computer science students whose goal was to introduce logic and
how it is used to reason about computation.  A major challenge in
teaching such a course is that students often cannot distinguish
between proofs and wishful thinking.  Therefore, we decided to use
ACL2s~\cite{dillinger-acl2-sedan,acl2s11} (an extension of
ACL2~\cite{acl2-web, acl2-car}), as it consists of a functional
programming language with formal semantics and an interactive theorem
prover.  The use of ACL2s allowed us to take advantage of the strong
intuition and extensive experience students have with programming to
discuss topics that include: programming language semantics, Boolean
algebra, writing specifications, equational reasoning, termination
analysis using measure functions, ordinal numbers, definitions,
algebraic data types, refinement, induction schemes, proof techniques
and formal proofs.

We used Dijkstra-inspired calculational proofs~\cite{dis90,ewds} from
the inception of the class and found them to be very effective
pedagogically. Our calculational proof format has gone through
continuous development, based on student feedback, our experiences
teaching the class, and experimentation with alternatives. For
example, an obvious approach that we tried (once) was to use the ACL2
proof builder, which allows one to take individual proof steps. Such a
capability is provided by almost all interactive theorem provers. We
discarded this idea because: (1) there was too much tool-specific
jargon, (2) students engaged in a lot of ``pointing,'' ``clicking''
and unstructured exploration, but not enough thinking, (3) students
found themselves with proof obligations that they could not easily
relate to the original conjecture, and (4) students did not learn
transferable skills. The calculational proof format we developed had
none of the above disadvantages and the following benefits: (1) it
includes a number of well-defined steps that are not ACL2s-specific
and help students structure proofs and avoid common pitfalls, (2) it
uses equational reasoning which leads to proofs that are easy to check
in a linear, local way, and (3) it is generally applicable to other
contexts requiring proofs.
%% Students of the Logic and Computation course at Northeastern
%% University are taught to use calculational proofs to reason about
%% programs. Some advantages of using calculational proofs are (1) The
%% process of proof writing is rigorous, since the whole proof needs to
%% be written without any assistance of autocompletion tools, (2) the
%% proof format does not resemble proofs of any particular proof
%% assistant, making the skills learned transferable (3) the proof format
%% resembles that of Dijkstra, however the context is
%% required to be clearly listed, separate from the proof, so as to make
%% justifications explicit and (4) Since the proof is a linear sequence
%% of steps, it is easy to spot errors in the proof.

After refining the proof format for a number of years, we developed a
proof checker, motivated by Manolios and Moore, who made the case for
mechanizing calculational proofs~\cite{man01}.  The main advantage of
mechanization is that students get immediate feedback and it
facilitates the automation of grading.  We deployed a Web version of
\hpc~(the Calculational Proof Checker) in Spring 2020, which accepts a
file containing function definitions, helper properties and
calculational proofs. It validates the proofs or identifies a list of
issues. It was later upgraded to check syntax in the browser itself,
so as to reduce load on the server. However, owing to its
server-client architecture, it required internet connectivity and
suffered from needlessly high response times, especially before
assignment submission deadlines. Hence, we recently developed an
Eclipse IDE plugin for writing and checking proofs locally. Finally,
for experts, there is a command-line version of \hpc\ that facilitates
scripting and supports enhanced debugging.  \hpc~is integrated with
the ACL2~Sedan (ACL2s) theorem
prover~\cite{dillinger-acl2-sedan,acl2s11}.  ACL2s is an extension of
the ACL2 theorem prover, whose authors were awarded the ACM Software
System Award in 2005~\cite{acl2-web, acl2-car, acl2-acs}.  ACL2s
extends ACL2 with an Eclipse IDE, a property-based modeling/analysis
framework, an advanced data definition framework
(\emph{Defdata})~\cite{defdata}, an automatic counterexample
generation framework
(\emph{cgen})~\cite{cgen,harsh-fmcad,disprovingTheorems}, and a
powerful termination/induction framework based on calling-context
graphs~\cite{ccg, ccg-cores, all-termination} and
ordinals~\cite{ManoliosVroon03, ManoliosVroon04, MV05}.  ACL2s
definitions and properties are ``typed'' and this helps students find
specification errors, as ACL2s performs a large number of analyses and
generates executable counterexamples highlighting errors.

Our contributions include: (1) Our \textbf{Calculational Proof
  Format}, which is designed for teaching, communicating, evaluating
and understanding proofs. It consists of a number of steps, such as
the identification and extraction of hypotheses. It supports
equational reasoning using a variety of relations. Our proof format
does not rely on keywords or syntax from any programming language,
making it applicable to a wide range of domains. Section~\ref{sec:ex}
provides a number of examples and an abstract grammar can be found in
Section~\ref{sec:format}.  (2) \textbf{\hpc}: Our proof checker is
based on ACL2s, which allows it to leverage the defdata
framework~\cite{defdata} to declare and reason about user defined data
types, the cgen framework for automatic counter-example generation for
invalid proof steps~\cite{cgen, harsh-fmcad, harsh-dissertation}, a
property based modeling/analysis framework and a vast library of
formalized results in the form of ACL2 books~\cite{books}. \hpc~proofs
can prove conjectures using ACL2s properties and vice-versa
recursively.  \hpc~comes with Eclipse IDE support, allowing for
locally writing and checking proofs.  The main algorithms of \hpc\ can
be found in Section~\ref{sec:algorithm} and the architecture of \hpc\
is described in Section~\ref{sec:architecture}.  It is also publicly
available.  (3) \textbf{Formalized and Validated Example Proofs}: We
have formalized, checked and made publicly available, several proofs
from Dijkstra's EWDs~\cite{ewds} and from the Logic and Computation class
at Northeastern University~\cite{repo}.


\section{Calculational Proof Examples with \hpc}
\label{sec:ex}
In this section, we show two calculational proof examples using
\hpc. The first example is from the Logic and Computation
class~\cite{lc} and the other is from EWD-1297~\cite{midfrac}.
Dijkstra's manuscripts are available online~\cite{ewds}.

\subsection{Sorting Homework Example}
A homework problem from our Logic and Computation class asks students
to prove the functional equivalence of quicksort and insertion sort.
This conjecture is written in ACL2s as follows.
\begin{lstlisting}[style=proofStyle,
  label=lst:isortqsortconjecture]
(property qsort=isort (x :tl)
  (== (qsort x) (isort x)))
\end{lstlisting}

% Figure environment removed

The ACL2s definitions of the sorting functions are shown in
Listing~\ref{lst:isortqsortdefs}.  Function definitions in ACL2s are
typed, \eg, \p{all}, \p{bool} and \p{tl} correspond to the ACL2s
universe, the Booleans and to the set of (true) lists, respectively.
The definitions should be self-explanatory and are accepted by ACL2s
without any other annotations or proofs.

Students are expected to prove \p{qsort=isort} with \hpc, using the
``professional method,'' a method taught in class that encourages the
use of custom notations and abbreviations, as shown in
Listing~\ref{lst:isortqsortdefs}.  The professional method allows one
to develop inductive proofs without committing to a particular
induction scheme; instead, an appropriate induction scheme is
discovered during the proof process, just like a pro.  Students are
encouraged to start with the most interesting part of a proof, which
in this case is the induction step. Students are then encouraged to
develop proofs in a top-down fashion so that they only prove lemmas
that actually turn out to be used in their main
proofs. Listing~\ref{lst:isortqsortdefs} includes the discovered
lemmas. 

Listing~\ref{lst:isortqsortproof} shows our \hpc\ proof of the
induction step, using the professional method. The proof is
constructed starting with \p{Proof} and trying to transform \p{(Q x)}
into \p{(I x)} by expanding the definition of \p{Q} (an abbreviation
for \p{qsort}), assuming that \p{x} is non-empty. Next, 
\p{Q}'s are converted to \p{I}'s by the magic of induction and then we
need a few lemmas to reason about properties of \p{I}. What remains is
to prove the discovered lemmas and to create a formal proof of the
induction step and the rest of the cases (which are not shown but are
in the supported materials). The induction scheme used is now obvious:
it is the induction scheme of \p{Q}, which is sound as \p{Q} was
automatically proven to terminate by ACL2s.  The stuff before the
\p{Proof} part is now rather routine, as students learn an algorithm
for generating induction schemes from function definitions that lead
to certain proof obligations (only the induction step is shown). The
\p{Exportation} step allows students to use only propositional logic
and simple type reasoning to transform the generated induction step
into a form that has as many hypotheses as possible and no
subexpressions of the form $\alpha \Rightarrow (\beta \Rightarrow
\gamma)$, as such expressions should be converted to $(\alpha \wedge
\beta) \Rightarrow \gamma$ (exportation). In the \p{Context}, each
hypothesis is given a name. Students are instructed to transform
induction hypotheses of the form $\alpha \Rightarrow \beta$ into
$\beta$ (so \p{C4}, \p{C5} get turned into \p{D4}, \p{D5}) in the
\p{Derived Context}, by establishing the hypotheses of each
implication and adding justification hints. They also can add any
other hypotheses they need in the \p{Proof} section. Steps in the
\p{Proof} section also require justifications, as shown.

Since \hpc\ is integrated with ACL2s, students use the counterexample
generation capabilities of ACL2s to automatically test their
discovered lemmas before proving them.  All properties in
Listing~\ref{lst:isortqsortdefs} were proved using \hpc, and their
proofs can be found in our repository~\cite{repo}.  Notice that in our
proof, we have applied lemmas \codify{isort-less} and
\codify{isort-notless}, with their corresponding instantiations,
simultaneously. Since both the applications are symmetric, and rewrite
different parts of the list, it helps to keep the proof short, yet
highlights the key steps of this proof. Proof steps can combine
several lemma applications in a single hint, as to keep the proof
short and human readable. We often also provide properties that are
proven in ACL2s directly and they can be used in the same way as
\hpc\ lemmas.

\subsection{EWD-1297}
Dijkstra describes a problem in EWD-1297~\cite{midfrac} which asks the
reader to construct a fraction whose value lies between two distinct
fractions $\frac{a}{b}$ and $\frac{c}{d}$. He restricts $a,b,c$ and
$d$ to be positive integers. He conjectured that $\frac{a+c}{b+d}$ is
a solution and gave a visual proof, as shown in
Figure~\ref{fig:dewd1297-visual}.
% Figure environment removed
However, he points out that the visual proof is ``shaky'' and leaves
out several details. For example, it depends on the loosely stated
fact that the diagonals of a parallelogram lie inside it, \ie, between
two adjacent sides. But the proof of this ``fact'' might depend on the
demonstradum itself! He then gives a calculational proof, standing by
his famous quote: ``A picture may be worth a thousand words, a formula
is worth a thousand pictures.''~\cite{pics}
% Figure environment removed

In Figure~\ref{fig:ewd1297}, we show a side-by-side comparison of
Dijkstra's calculational proof and the corresponding part of our
formalization of his proof. One difference is that we use Lemma
\codify{multiply-<-fractions}, with appropriate instantiations,
instead of his hints, as our proof is formal. Our full formalization
appears in our repository~\cite{repo}, which includes the proof of
EWD-1297-2, the second part of the argument. Dijkstra did not prove
it, saying that the proof was similar, which is true.  Finally, we
proved the full conjecture EWD-1297 just by referring to the
previously proved conjectures.

Dijkstra was a fan of generalizing mathematical
results~\cite{gen,pythagoras,gen1} and often made the point that
calculational proofs, by clearly identifying assumptions, facilitate
such generalizations.~\footnote{Based on Manolios' personal
interactions with Dijkstra in classes and ATAC.} ACL2s can also be used to support such
generalization efforts. In Figure~\ref{fig:ewd1297}, we have four
context items positing that the variables $a,b,c$ and $d$ are positive
integers. As a first attempt to generalize this conjecture, we replace
each \codify{posp} by \codify{rationalp}, expanding the domain of the
variables to the rational numbers. \hpc\ produces the following
message:
\begin{lstlisting}[style=proofStyle]
--- Checking that completed statement passes contract checking... FAIL
Counterexample found when testing guard obligation:
(OR (NOT (AND (RATIONALP A) (RATIONALP B) (RATIONALP C) (RATIONALP D)))
    (NOT (EQUAL (+ B D) 0)))
(((D 0) (C 12/7) (B 0) (A -1/2))
 ((D 0) (C 1/3) (B 0) (A 122/875)) 
 ((D 0) (C 1) (B 0) (A 244/599)))
\end{lstlisting}
Obviously, \codify{b}, \codify{d} and \codify{(+ b d)} can not be $0$
since they are used as denominators in our goal. So, we add hypotheses
\codify{(!= 0 b)}, \codify{(!= 0 d)} and \codify{(!= 0 (+ b d))}. This
generalized conjecture has, as you would expect, the same proofs,
except for the extra hypotheses in the context and in proof
justifications. On running \hpc\ on our updated proof, we more
counterexamples and we keep going until we wind up with a
generalization, at which point we can use ACL2s again to removed
implied hypothesis. This process terminates with the generalization
shown in Listing~\ref{lst:ewd-1297-gen}, which \hpc\ proves. Note that the
only hypothesis we needed is the first hint of Dijkstra's proof!  The
full formalization of the generalized conjecture appears with
supplemental material and artifacts here~\cite{repo}.

% Figure environment removed

We note that when using ACL2s without providing hints, none of the
conjectures (original or generalized) in EWD-1297 are proved
automatically. However, as shown in Listing~\ref{lst:ewd-1297-thm},
there is an ACL2s proof of the generalized theorem that requires just
one hint (disabling a rule).  Figuring out what rule to disable can be a
lot of work, since there are dozens of applicable rules and many other
classes of hints that are potentially useful.  This is a common
problem when performing arithmetic reasoning inside ACL2s and other
interactive theorem provers that attempt to automate such reasoning
using rewriting and tactics because such methods are not complete (due
to undecidability) and users may have to intervene and guide the
theorem prover. The more complex the strategies employed, the more
expertise is required to effectively steer the proof.
% A common pattern with arithmetic reasoning is that ACL2/ACL2s, which
% primarily use rewriting, tend to get stuck because existing rewrite
% rules, for the most part, simplify expressions and try to put them
% into some kind of normal form, but often you have key steps in
% arithmetic proofs that are not in normal form,\eg\ by complicating an
% expression to enable future simplifications.
%For such conjectures, calculational proofs can be useful, even for
%experts.
%% Consider what happens if someone
%% changes a library. The theorem prover may go off in a completely
%% different direction when trying to complete a proof. So one has to try
%% to figure out how to steer the theorem prover and with arithmetic and
%% normal forms, this can be painful. In the case of a calculational
%% proof, the proof may go through and if it doesn't one knows exactly
%% which steps failed, so they are not investigating a potentially
%% different proof.  Calculational proofs also provide a complete proof
%% that is easier to read, understand and modify than proof builder
%% proofs, which are just a list of instructions.
The proof of EWD-1297 suggested some rewrite rules that we added to
ACL2s. It was easier to use \hpc\ to prove those theorems than using
ACL2s or the proof builder.  Our experience has been that
calculational proofs are easier to modify or repair, since they are
designed for human comprehension.  In contrast, trying to figure out
how to steer the theorem prover, was like playing whack-a-mole: the
ACL2 arithmetic libraries are robust, so efforts to steer the theorem
prover by providing explicit hints are often defeated by the remaining
dozens of rules conspiring to generate similar unproductive proof
attempts.

\section{Calculational Proof Format}
\label{sec:format}
Figure~\ref{fig:grm} shows an approximation of our calculational proof
grammar sufficient to understand the rest of this paper, especially
the main algorithms. \hpc\ uses Xtext, as described in
Section~\ref{sec:architecture} and the full grammar is in our
repository~\cite{repo}.
% Figure environment removed

We designed our proof format with a focus on teaching and
communicating proofs. Each Conjecture is named, so that it can be
referenced later. If Exportation and/or Contract Completion are
necessary, they need to be explicitly stated. This helps in finding
context items one might have missed when writing down the statement of
the Conjecture. The Context and Derived Context are listed separately
from the proof, which makes it easy to identify the exact context item
being used as a hint for a particular step. The proof body is linear,
\ie, a sequence of steps separated by hints that makes it easy to
identify any source of error due to wrong lemma application, missing
or incorrect hints. The grammar does not depend on keywords from any
programming language or proof assistant which makes it highly
transferable for use in other domains.

\section{Conjecture Checking and Proof Generation}
\label{sec:algorithm}
\input{checking}

\section{System Architecture}
\label{sec:architecture}
\input{architecture}

\section{Our Experience Teaching With \hpc}
We have several years of experience using \hpc\ to teach students how
to write calculational proofs. The following features have proved to
be very useful. (1) \textbf{Mechanization:} students get immediate
feedback, allowing them to quickly learn how to distinguish proofs
from wishful thinking. (2) \textbf{Syntax Checking:} Students get
instantaneous syntax-related feedback. Due to this, the TAs almost
never have to deal with incorrect syntax in student submissions.  (3)
\textbf{Useful Feedback:} \hpc\ produces helpful feedback on proof
steps to help students correct any mistakes in their proof, \eg,
incorrect lemma instantiations, missing hints etc.  We continuously
improve the error messages and validation due to student feedback. (4)
\textbf{ACL2s Integration:} This allows us to provide lemmas for
certain assignments and allows students to test any lemmas and
specifications they write using the $\mathit{cgen}$ framework before
actually investing any effort in formal proofs.

The use of \hpc\ also improved the educational experience for
students, as the immediate feedback \hpc\ provides allows them to
transition more quickly from basic proof questions to proof strategy
considerations. For a small subset of students, who previously may not
have realized they needed help, \hpc\ helps them realize they need
help without having to wait for a grading cycle to get that feedback.

Despite these advantages, we did get feedback that the online version
of \hpc\ was sometimes too slow (taking several minutes) when checking
particularly long proofs. This can be attributed to the many
validation queries required to check proofs and overloaded
servers. Another request was to enable proof checking even when
students were not online.  Both of these requests are addressed by the
Eclipse plug in.


\section{Related Work}
\label{sec:rel}
Calculational proofs were popularized by Dijkstra~\cite{dis90},
Gasteren~\cite{vg90} and Gries~\cite{gri91} in the early 90s. This
style of proof was not new at the time. Dijkstra credits
Hoare~\cite{dream} and Feijen~\cite{feijen} for introducing him to
calculational proofs. Calculational proofs have since become popular
among computer scientists for their readability and mathematical
rigor. Lamport~\cite{lamport1995write} advocated structured proofs
using hierarchical numbering and proof constructs from TLA+. Robinson
and Staples proposed window inference~\cite{rswindow} as a more
flexible alternative to calculational proofs, as it allows selection
and transformation of subexpressions, while preserving
equivalence. Grundy described window inference in terms of a sequent
formulation of natural deduction and generalized it to allow for
general transformational proofs~\cite{grundy96trx}. Following this,
Back, Grundy and Wright proposed structured calculational
proofs~\cite{back97,grundy96} as a way to incorporate the nested
structure of natural deduction proofs~\cite{gen35,pra65} into
calculational proofs, thereby improving on both readability and
browsability.

At the turn of the twenty first century, Manolios and Moore argued for
mechanized checking of calculational proofs~\cite{man01}. Noting that
(1) Calculational proofs are amenable to mechanical
verification~\cite{mverif} and (2) proofs often follow from a
syntactic analysis of the formal statement of the
demonstradum~\cite{demo}, they challenged the calculational proof
community to build a program to check proofs in a sound manner. Today,
there exist several such programs. We will discuss them according to
the following criteria :\\
\textbf{Social aspects} refer to the ease of understanding,
communicating and teaching proofs. A calculational proof should
neither be bloated with, nor be restricted by programming language
specific syntax. It should focus solely on communicating the key ideas
(of a proof) as clearly as possible. Dijkstra favored having clear and
explicit justifications about the context which (1) conveys key proof
ideas and (2) avoids repetition of
subexpressions~\cite{notation}. Separating context from proof helps in
this regard, since context items can be listed explicitly and used in
justifications. We show later in the paper, how context items help in
coming up with generalized conjectures.\\
\textbf{Formal aspects} refer to the level of checking done by proof
checkers. Typically, proof checkers lie on a spectrum, ranging from no
checking whatsoever, to full checking of the validity of proofs,
usually with the help of an underlying theorem prover.\\
\textbf{Utilitarian aspects} refer to the utility of a proof checker
as a proof assistant. We believe that a proof checker should not only
be able to verify proofs, but also interactively help users with the
construction of proofs.\\
The Mizar~\cite{mizar92} (Multi-Sorted with Equality) system,
developed in the early 90s by Andrzej Trybulec and his group in
Bialystok, is an early effort to mechanize checking calculational
proofs. The Mizar language is formal, yet highly readable due to its
declarative nature and a rich syntax which allows for close
resemblance of proofs to mathematical vernacular. However the system
is not very interactive. It depends on light weight
automated-reasoning and single rule application to justify proof
steps. John Harrison added a ``Mizar Mode''~\cite{harrison-mizar} on
top of the HOL theorem prover providing a version of Mizar language
which is more interactive as well as a corresponding proof checker
which is more powerful. A similar approach was taken to implement Isar
for Isabelle~\cite{isar,mizarisar} and Mizar Light for HOL
Light~\cite{wiedijk2001mizar} to produce more interactive and formal
systems. Leino and Polikarpova~\cite{lepo13} extended Dafny (a SMT
solver based auto-active program verifier) with program-oriented
calculations (poC) to write structured calculational proofs. Program
derivation is a programming technique that derives programs from
specifications by means of formula manipulation, which is essentially
a calculational proof. Tesson et al.~\cite{tesson11} developed a set
of lightweight tactics to support program derivation in Coq.  Vazou et
al.~\cite{vazou2018theorem} use Liquid Haskell, a program verifier for
Haskell which uses refinement types, to calculate efficient
programs. However, all of these systems lack in social aspects in the
following ways (1) Context is not made explicit in the proof (2)
Relations allowed between proof steps are limited (Mizar and the
program derivation tools only support equalities while Mizar Mode for
HOL, Isar and Dafny have a fixed set of transitive relations).

On the other side of the spectrum of formal aspects lies
Mathedit~\cite{back07mathedit}, which allows writing structured calculational
proofs, with the ability to expand and contract subderivations. However,
derivation steps are checked only for syntactic and semantic requirements on
the derivation, which is not a formal verification of the correctness of the
proof itself.

There exist several notable tools that check proofs in a limited theory. Mendes
and Ferreira~\cite{mendes18} presented a proof of concept system that verifies
hand-written (from a pen-based input device) calculational proofs in
propositional logic, using Isabelle/HOL as the backend prover to check proof
steps. Kahl~\cite{kahl18} introduced the CalcCheck system to input, verify and
grade calculational proofs from the book ``A Logical Approach to Discrete
Math"~\cite{ladm93}. Carl et al. presented Diproche~\cite{diproche}, an
automated proof checker for proofs of elementary mathematical exercises written
in a controlled fragment of German, the ``Diproche languageâ€. Barwise's
Hyperproof system~\cite{barwise1994hyperproof} checked proofs combining
graphical and sentential information using a fixed set of logical rules.

Apart from proof checking, there is a large body of work in proof
visualization, including but not limited to Grundy's
ProofViews~\cite{grundy97} package for browsing a proof interactively
along its hierarchical structure, and the Omega
system~\cite{siekmann1999lomegaui} to visualize proofs interactively
using proof trees. However, we believe that proof visualizers have
limited applicability above and beyond pedagogy, whereas our work is
more applicable. To the best of our knowledge, \hpc~is the best
calculational proof checker in every aspect we discussed.

We end with previous work related to ACL2s, which is an extension of
ACL2. The ACL2s core libraries and installation instructions are part
of the ACL2 distribution~\cite{acl2s-web}. The Gitlab
group~\cite{acl2s-group} contains a collection of projects related to
ACL2s, including the scripts project which includes scripts for
standalone ACL2s implementations~\cite{acl2s-scripts}.  ACL2 and ACL2s
have been used in industry to formalize, analyze and reason about a
variety of complex industrial systems~\cite{hunt2017industrial}. ACL2s
examples include: (1) the formalization and automated analysis of
system requirements for safety-critical avionics systems, leading to
the ASSERT tool that has been used on numerous industrial
projects~\cite{requirements-2018, assert-2017}, (2) the validation of
conformance of hardware devices to standardized networking protocols
using hardware-in-the-loop fuzzing, which introduced the idea of
enumerative types with constraints, allowing us to solve data
synthesis problems beyond the reach of state-of-the-art solvers such
as Z3~\cite{enumerative-2022}, (3) the use of ACL2s to prove
refinement for optimized reactive systems, hardware and low-level
software~\cite{ manolios2019sks, manolios2015sks, manolios2015acl2,
  manolios2008refinement, Manolios2006AFF}, and (4) the development,
formalization and partial analysis of complete, executable formal
models for distributed gossip protocols, which were then used to find
flaws in applications (\eg, Ethereum) based on these
protocols~\cite{gossipsub-2022}. ACL2s supports the use of external
solvers and includes a systems programming capability that allows us
to use the core theorem prover as a key component in
formal-methods-enabled projects relating to gamified verification,
education, proof checking, interfacing with external theorem provers
and security~\cite{walter-acl2-systems-programming}.

% \section{Acknowledgments}
% We sincerely thank Ken Baclawski, Raisa Bhuiyan, Harsh Chamarthi,
% Peter Dillinger, Robert Gold, Jason Hemann, Andrew Johnson, Alex
% Knauth, Michael Lin, Riccardo Pucella, Sanat Shajan, Olin Shivers,
% David Sprague, Atharva Shukla, Ravi Sundaram, Stavros Tripakis, Thomas
% Wahl, Josh Wallin, Kanming Xu and Michael Zappa for their help with
% developing and teaching with \hpc. We also thank all of the Teaching
% Assistants and students in CS2800, who are too numerous to list
% individually, who used and provided feedback on \hpc.

\section{Conclusion and Future work}
\label{sec:conclusion}
\input{conclusion}

%%
%% Bibliography
%%

%% Please use bibtex, 

\newpage
\bibliography{refs}

\end{document}
