\section{Discussion}



\subsection{Observed Capabilities and Limitations} \label{sec:capabilities}

Our examination of \gpt's performance in the fields of design and manufacturing has underscored several crucial capabilities instrumental in supporting the design processes, in addition to pinpointing significant limitations. Next, we summarize these observations and discuss various methods to mitigate the identified limitations. 

\noindent \textbf{Capabilities:} \linebreak
\noindent \textbf{C.1 Extensive Knowledge Base in Design and Manufacturing:} \gpt boasts a comprehensive knowledge base in the realms of design and manufacturing. Its capabilities extend to solving a wide array of problems and automatically completing specifications, making it a versatile tool across various domains.

\noindent \textbf{C.2 Iteration Support:} \gpt incorporates an iterative approach to problem-solving. When feedback is provided on errors, it attempts to rectify them. This ability to adapt, although not always successful, is a valuable facet of an \gpt's performance.

\noindent \textbf{C.3 Modularity Support:} \gpt supports modular design, demonstrating the ability to reuse or adapt previous designs or solutions when explicitly instructed. While it does not inherently retain memory of past interactions, explicit instructions can help leverage its modular capabilities effectively.


\noindent \textbf{Limitations:} \linebreak
\noindent \textbf{L.1 Reasoning Challenges:} \gpt encounters difficulties with certain types of reasoning, particularly those involving analytical reasoning and computations. These limitations can manifest as notable challenges in the design and manufacturing domain, for instance, a general lack of spatial reasoning capabilities.

\noindent \textit{Potential Solutions:} Implementing well-crafted domain-specific languages (DSLs) can help address these challenges. DSLs, widely used in computer science, encapsulate recurring knowledge, rules, and valuable abstractions, thereby filling knowledge gaps. Alternatively, APIs that can perform the complex computations can be integrated. \gpt's proficiency in creating high-level abstractions can be utilized to generate inputs that be processed through APIs by computational solvers.

\noindent \textbf{L.2 Correctness and Verification:} \gpt often produces inaccurate results or justifications for its solutions and lacks the ability for self-verification.

\noindent \textit{Potential Solutions:} Apart from relying on human verification, automated verification can be accomplished by utilizing APIs that conduct checks and validations. By leveraging \gpt's iterative capabilities (C.2), we can create a feedback loop that continues until a satisfactory solution is obtained.

\noindent \textbf{L.3 Scalability:} As tasks become larger or more complex, \gpt's performance can deteriorate, often struggling to manage multiple tasks concurrently.

\noindent \textit{Potential Solutions:} One strategy is to partition larger tasks into multiple sub-tasks. For instance, rather than requesting it to evaluate multiple performance metrics simultaneously, it may be more effective to request them individually. When constructing more complex models, employing an incremental design process can prove beneficial. Components can be designed and verified separately before being assembled into the final model. \gpt's modularity support (C.3) can be used to facilitate the creation of complex models from a series of instructions.

\noindent \textbf{L.4 Iterative Editing:} When a design needs modifications, specifying those changes as a prompt will often lead to unsatisfactory behaviors. This is because the \gpt, upon receiving a change prompt, will regenerate the design, often overlooking elements specified in previous prompts. This situation poses challenges to design editing.

\noindent \textit{Potential Solutions:} Our solutions involved either feeding the prompts back in to create a full specification in a single prompt, though this also caused challenges due to the scalability limitations discussed above. The alternative was explicit modularization to enable parts to be designed and reused, though the latter was not possible in some cases.

\noindent \textbf{Dualism:}

\noindent \textbf{D.1 Context Information:} \gpt's performance improves significantly with the provision of context information. The more detailed the domain description, the better it performs. Furthermore, \gpt is adept at providing context for its actions, making it an asset in sequential workflows. This characteristic proves particularly beneficial when using \gpt's generated content in subsequent tasks, as these tasks can utilize the context included in the output from the initial task. However, it may also be harmful if the user does not provide enough context, or if the user would like to create an unusual design, but \gpt is unable to overcome the biases it associates with a particular domain.

\noindent \textbf{D.2 Unprompted Responses:} \gpt often infers aspects that are not specified in the prompt, either auto-completing specifications or finding ways to make decisions without enough information. While this is interesting in the design context in terms of allowing for partial specifications that can be auto-completed, it can sometimes be overly proactive, guiding the design in some aspects, which may limit creativity.



\section{Conclusions}


In conclusion, we find that \gpt possesses numerous capabilities that can be leveraged within the domain of design and manufacturing. This area, where creativity converges with practicality, presents exciting opportunities for advancements that can potentially bring about a significant shift in the way we ideate, prototype, and manufacture a broad range of products.

However, it is essential to recognize that substantial work remains to be done to fully support the integration of these tools within this field. A fundamental issue is that design for manufacturing involves a delicate balance between creativity and formal verification. Engineering design presents a paradox; it requires precision and exactness, yet thrives on an iterative and exploratory spirit. While our experiments have managed to circumvent limitations for formal reasoning through user guidance, DSL crafting, and APIs that call computations, there is still much to understand about how best to implement these strategies.

For instance, we hope that our analysis can stimulate new insights about DSL design. Historically, DSLs have been developed with human users in mind. However, when we shift our perspective to creating DSLs for an AI coder, new questions and possibilities emerge. What should these DSLs look like? We believe our analysis provides valuable insights into this concept, particularly within the design and manufacturing domain.

Similarly, in terms of API usage and framework development, we have observed a myriad of possibilities. Approaches range from dividing problems into parts that can be tackled by \gpt and others that are best solved by traditional methods, to iterative solutions, and even to a complete reframing of the problem by asking \gpt to generate problem-solving code. Each of these approaches carries potential advantages and disadvantages. So, what should an optimal framework look like? We hope our research will aid others in formulating an answer to this question.

In summary, we believe our analysis offers valuable insights into how LLMs like \gpt can be harnessed in the domain of design and manufacturing. While we have made substantial strides, the path to fully exploiting the potential of these tools in this domain remains open, rich with opportunities for further exploration and innovation.

% There are improvement for each of the components of the workflow

% \paragraph{Text-To-Design}

% \liane{moved to subsection of text-to-design section}

% \paragraph{Text-To-Design-Space}
% Address limits of parametric design.
% Address Limits of interpolation/extrapolation.
% Address Limits of grammars.

% \paragraph{Design-To-Manufacturing}
% Autocheck validity and correctness of the translation.
% Post-process the manufacturing to fix errors.

% \paragraph{Design-To-Performance}
% Add explicit simulations and interfaces for these simulation tools.
% Add API to specify these simulators.

% \paragraph{Performance-and-Design-Space To Design}
% Improve search tools.
% Integrate inverse methods with external optimizers/search.
% Add methods to explicitly specify constraints and objective function. 

% \paragraph{Output visualization}
% Integrate many data visualization tools so that the prompt output can be directly visualized.

