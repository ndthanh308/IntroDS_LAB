%% Text to Design: CAD with mating assemblies
% \team{Felix}

CSG and parametric CAD modeling paradigms are mainly used to design 3D parts which can be later on manufactured.
Putting these parts together into one functional object is usually done in an \textit{assembly} step.
In an assembly, specifying how two parts are connected, or \textit{mated}, comes down to defining (i) \emph{where} two parts are mated and (ii) \emph{what} the movement constraints are between two parts.
For example, to mate two lego bricks, we would define (i) the mate connector of the first brick on the top disk of one of its knobs, the mate connector of the second brick on the inner disk of its bottom tube and (ii) define the mate type as a sliding mate, allowing for a vertical translational degree of freedom (DOF). \todo{Lego mating figure}

In commercial CAD software, assemblies are defined via graphical interactions, allowing users to easily reason spatially and to correct their mate definitions thanks to real-time feedback.
GPT and other {\llm}s are purely text based, so they seem like a suboptimal choice for assembly. 
However, prior research has shown that \gpt has a good understanding over contextual and part relationships \cite{}, which could be useful for facilitating the mating process.

As for the parametric CAD modeling paradigms, we try to overcome the domain gap between the textual and the graphical domain by providing \gpt with a simplified DSL to express a minimal set of mating operations.
We define two operators: (i) an operator \lstinline{choose_planar_face(solid_name, plane_side)} which returns a mate connector based on the selected solid and its planar face and (ii) three mating operators \lstinline{mate}, \lstinline{mate_slider} and \lstinline{mate_revolute} which take as input two mate connectors and mate with either no DOF, one translational DOF and one rotational DOF, respectively.
\lstinline{mate_slider} and \lstinline{mate_revolute} additionally take the translation axis and the revolution axis as input argument.

For example, the program in Fig.\ref{fig:mate_stack_cuboids} (a) shows how to stack two cuboids on top of each other with this language.
Given our DSL definition, and this example program, \gpt can successfully stack three cuboids on top of each other, as is shown in Fig.\ref{fig:mate_stack_cuboids}(b) and (c). 
This simple example shows an important strength of \gpt, namely that it can learn from examples and is able to translate this to similar problems.
When assembling an object with a lot of parts and connectors, time-intensive manual labor is required to perform repeating patterns of mating operations \cite{automate}.
Leveraging {\llm}s which can reason about part relationships could prove to be a real time saver for designers.
\todo{}
In Fig.\ref{fig:mate_screws}, we see an example of a screw mating pattern which is performed once and which has to be repeated three more times in the remaining corners of the plate.
When asked to complete the assembly process, \gpt finishes the mating job successfully. 
It should be noted that the variables used in this example are explicitly descriptive.
\gpt performs less well when presented with no semantic context.
\\
\todo{}
\begin{itemize}
    \item explain slider mate example: place a drawer in a box
    \item failure case/limitation: 
    \item explain revolute mate example: door and hinge
    \item failure case/limitation:
\end{itemize}
Our mating DSL for \gpt shows potential benefits for real-world design scenarios, but also some limitations. 
It should be noted that the proposed DSL stays close to current graphical workflow.
Other DSLs could be better suited to interface with \gpt and maybe allow it to textually describe matings more naturally.
\\
