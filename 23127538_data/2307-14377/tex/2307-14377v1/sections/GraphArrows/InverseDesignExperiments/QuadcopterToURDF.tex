\paragraph{Converting \jscad to URDF} We start with the \jscad quadcopter design developed in Section \ref{sec:copter-text-to-design}. Because there is no straightforward equivalent of subtraction and union from \jscad in URDF, we omit the creation of the holes in the motor base and replace the union of motor base parts with placement of individual links while retaining the essence of the original design. We then take an object-oriented approach to having \gpt synthesize the equivalent URDF code. As seen in \ref{fig:tourdf_component}, we prompt \gpt to create a Component class whose instances store the geometry, mass, position, and orientation attributes of the corresponding \jscad primitives. Component instances also have distinct names to represent URDF links. We additionally prompt \gpt to generate helper functions for placing instances with different geometries in Fig. \ref{fig:tourdf_component}. This framework allows \gpt to generate a function that places components in terms of absolute coordinate positions and orientations and to replicate the Python equivalent of the \jscad, as shown in Fig. \ref{fig:tourdf_place}. 
% Each instance corresponds to a URDF, keeps track of the componentâ€™s name, mass, geometry, as well as absolute translation and rotation with respect to the origin.
% Figure environment removed

% Figure environment removed

However, one difficulty is that unlike CAD-like designs, formats for representing robots also require relations between components to be represented as joints in order to accurately simulate the robot dynamics. We prepare for this when synthesizing the component placement script by prompting GPT to store the components as a dictionary, which allows easy access to the components. We tackle the challenge of generating the quadcopter's joints by relying on \gpt's knowledge of the spatial relation between components in a quadcopter. After equipping the Component class with a function that sets the parent link, we use this interface to have \gpt synthesize a sequence of robot joints, as shown in Fig. \ref{fig:tourdf_relation}. We find that although \gpt understands certain substructures, such as the fact that the motor is placed on top of the motor base and the propeller is connected to the top of the motor, its initial definition results in an invalid URDF format, as both of the frame bars are root links. We thus explicitly prompt \gpt to choose one of the frame bars as the root link. 

Finally, \gpt is tasked with creating a full URDF file. Because the robot is represented with modular Component instances that contain all relevant information on individual links' mass and geometry as well as relations to parent links, it is relatively straightforward for \gpt to create helper functions that synthesize URDF links and joints. We note that creating a joint is a more involved task, since the link's absolute position and orientation must be converted to relative position and orientation to the parent link. It is necessary to explicitly prompt \gpt to use the appropriate rotation matrices in its calculation; otherwise, it does not appropriately account for how the parent link's rotation affects the child link's relative translation. Because we choose LQR as the robot's controller in simulation, we ask \gpt to compute the full assembly's mass and moment of inertia given the Python code it has generated thus far. It outputs reasonable Python code that computes the assembly's center of mass and uses the parallel axis theorem to combine the moment of inertia of the individual links.

% Figure environment removed

In summary, we find that explicitly prompting \gpt to provide suitable object-oriented representations, such as the Component class, and modularizing the code generation as much as possible, e.g. asking \gpt to synthesize helper functions, placing components, and defining parent-child relations separately are key techniques in successfully converting from \jscad to URDF.

