\paragraph{Deriving a LQR Controller for the Quadcopter.}  Multicopter control is an extensively studied problem, for which various algorithms have been proposed such as PID controllers, LQR controllers, and more complex alternatives. We aim to synthesize a LQR controller, as it is not only a popular choice in the literature but also guarantees optimal control when the multicopter dynamics and stable fixed point are known. In particular, we focus on controlling a quadcopter, which is an underactuated system with 6 degrees of freedom but only 4 independent actuators, resulting in nonlinear dynamics even without aerodynamical effects. However, LQR provides optimal control by linearizing the system around a stable fixed point, which then has a closed form solution. 

As LQR is widely used for control, the algorithm is easily accessible through the \lstinline{control} Python library that performs LQR with a single function call. As such, the main challenge in using LQR for quadcopter control is deriving its state space representation, the $A$ and $B$ matrices, used in the linear model of the system as shown in Equation \ref{eq:linear_model}. $x$ is a 12-dof state vector, including coordinate position, linear velocity, roll, yaw, pitch, and angular position. $u$ is the 4-dof control input, typically consisting of the upward thrust and the external torque applied in the xyz directions. Note that $x$ in \ref{eq:linear_model} is the difference between the current state and a user-specified target state. Similarly, $u$ is with respect to the target control input, where the torques are 0 and the thrust balances out the gravitational force acting on the qaudcopter. \gpt is then asked to provide a suitable fixed point at which the quadcopter is stable, and it does provide a correct response.

\begin{equation}
    \dot{x} = Ax + Bu
    \label{eq:linear_model}
\end{equation}

In order to verify \gpt's results, we ask \gpt to first synthesize the full kinematics model before using a a symbolic manipulation library, sympy, to compute the state space matrices. This forces \gpt to produce an interpretable dynamical model that a domain expert can verify, rather than directly outputting the $A$ and $B$ matrices. This proves to be essential as even though \gpt captures the high-level idea of assuming the quadcopter to be a rigid body and applying Newton-Euler equations to describe its acceleration and angular acceleration, it is unable to zero-shot provide the exact model of the system without user feedback. For instance, as shown in Fig. \ref{fig:quadcopter_lqr}, \gpt formulates the correct rotation matrix but does not apply it correctly to convert from inertial frame (control inputs) to the body frame (linear acceleration). Although \gpt can correct its error when given feedback, this type of error is difficult to catch without rigorously checking the correctness of \gpt's calculations and highlights the limitation that in some inverse design domains, a user cannot generate precise outputs from \gpt without the expert knowledge to perform verification. After this fix, the resulting code for deriving the $A$ and $B$ matrices is still incorrect as the simulated quadcopter sinks downward due to a sign error in the equations for acceleration. Similarly, generating the simulation loop in PyBullet requires several rounds of iteration on the initial code. Some of the mistakes are more obvious, such as incorrectly indexing into the control input vector when applying external force and torques, whereas others are more specific to PyBullet's API. For the former, we directly pointed out \gpt's mistake. In the latter case, we find that simply giving \gpt the error message and asking it to fix its code suffices for our problem. 

% \wojciech{explain how you fix it eventually.}

% Figure environment removed