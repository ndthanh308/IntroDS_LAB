% Figure environment removed

In this subsection, our objective is to design a functional indoor quadcopter capable of flight, hovering, and landing, using \gpt with minimal human intervention. The process involves sourcing parts, creating a 3D design incorporating the chosen parts, and ultimately, manufacturing, assembling and testing the quadcopter,
as depicted in Figure~\ref{fig:quadcopter-process}. % \wojciech{Add a figure and short discussion on how the workflow looks like for this exampl}

\subsubsection{Parts Sourcing}
Many real-world systems, like drones, are built from pre-existing components with various kinds of  specifications. Therefore, our first task is to utilize \gpt to select appropriate parts for our specific use case. This was successfully accomplished using \gpt. The detailed process is elaborated in Section~\ref{sec:part_sourcing}, and the selected parts are shown in Figure~\ref{fig:copter-assemble} (left).

\subsubsection{Text-to-Design}
\label{sec:copter-text-to-design}

% Figure environment removed

Upon identifying the components, we employ \gpt once more to generate a viable quadcopter design incorporating those parts. With minimal human intervention, we successfully crafted a geometric design for the quadcopter, as detailed in Section~\ref{sec:prefabbed-ele}. Now, we shift our focus to practical issues: 1) how parts are mounted onto the designed frame, and 2) whether the frame is manufacturable. Given that describing each part's geometric details is challenging and that \gpt doesn't fully comprehend how to design the frame for optimal physical balance, we provide \gpt with low-level instructions to guide adjustments to the current frame design rather than expecting it to independently modify the design.

First, we adjust the frame bar's cross-sectional size using \gpt to ensure it's 3D-printable and adequately robust. Then, we combine all boxes and cylinders that form the frame in the geometric design. To stabilize the battery placement, we semi-integrate it into the frame, and subtract it from the frame so the frame securely holds the battery. For the controller and signal receiver, which are much lighter and smaller than the battery, we simply glue them onto the battery, eliminating the need for additional accommodations.

Lastly, we mount the motors using screws for stability, requiring screw holes in the frame. To minimize human effort, we utilize \gpt to create holes in the frame. For each motor, we instruct \gpt to generate four cylinders representing the required holes, detailing the hole specifications via text according to the motor's specifications. Even though crafting mounting holes isn't trivial, we successfully produced the correct cylinders after a few prompts with \gpt. The cylinders are shown in dark gray in Figure~\ref{fig:quadcopter-man}(Left). Once the hole cylinders for one motor are ready, we let \gpt group and duplicate them using our \lstinline{place} function. \gpt managed to position the hole cylinders correctly but had issues with proper rotation, which we later manually corrected.

As seen, the hole cylinders overlap with the frame bar. Since we cannot change the frame bar's thickness due to the manufacturing concern, we manually adjusted the frame bar's tip thickness to prevent it from obstructing the holes. This was done manually, as it proved challenging to adequately convey the problem and solution to \gpt.

Our experiments also revealed a limitation: adjusting designs we completed earlier proves difficult. After extensive interaction with \gpt, referring back to previously discussed design elements becomes a challenge. Consequently, if any issues arise with earlier addressed parts, it becomes arduous to revisit them with \gpt and prompt modifications. Ideally, we should finalize each design without the need for future revisions, as adjustments later prove difficult. The final frame result is displayed in Figure~\ref{fig:quadcopter-man}(Right).

\subsubsection{Design-to-Manufacturing}
The only part that needs manufacturing is the frame. Once the frame is determined, we fabricate it using a 3D printer. Because the representation of the frame results from Boolean operations of boxes and cylinders, it is simple to directly convert them to .stl format which is widely recognized by the 3D printers. We used OpenJSCAD to do it. Once we have the .stl file, we manufacture the frame using Stratasys Fortus 400 since it has a sufficiently large build volume and it realizes precise, robust, and durable parts. We instruct the printer to use the least amount of infill possible in the print settings. By choosing a lower infill percentage, the printer will create a sparse or hollow internal structure rather than a solid one. This decision helps conserve material and reduce print time without significantly compromising the strength or weight of the copter's frame, given that it is not a load-bearing component. The resulting fabricated copter frame not only meets the required dimensions, but also balances the strength and weight, necessary for optimum flight performance. We visualize the printed frame in Figure~\ref{fig:copter-assemble} (middle).

% Figure environment removed

\subsubsection{Assembling and Real-World Verification}

With the 3D printed frame ready, we proceed to the assembly stage, integrating the pre-prepared components. Given that assembly considerations were incorporated into our \gpt-guided design process, the assembly of the quadcopter is straightforward. The battery is secured in the central frame slot using double-sided tape and wrappers. Similarly, the controller and receiver are placed atop the battery and secured with double-sided tape and wrappers. The four motors are attached using screws. All elements are affixed firmly and stably, resulting in a sturdy copter ready for flight, as shown in Figure~\ref{fig:copter-assemble} (right).

Once assembled, we conduct a series of tests. First, we administer an ascending test, directing the copter to lift off the ground and ascend to a specific altitude. This test gauges the combined thrust of the motors and the propellers' efficacy in converting the motors' rotary motion into lift. It also allows us to evaluate the copter's responsiveness to radio transmitter commands, the flight controller's interpretive capacity, and the copter's overall ascent stability. The motion is depicted in Figure~\ref{fig:copter-flight-test} (left).

Following ascent, we undertake a hovering test. During this phase, the copter is directed to maintain its altitude and position for a set period. Hovering demands continuous, simultaneous operation of all four motors to counter gravity. This test significantly illuminates the copter's capacity to achieve and maintain stable flight, a vital characteristic of any functioning copter. The hovering motion is demonstrated in Figure~\ref{fig:copter-flight-test} (mid).

Finally, we execute a descending test, instructing the copter to safely and gradually descend to the ground. This evaluates the copter's ability to control thrust reduction and the resulting downward motion, as well as the flight controller's capacity to interpret and carry out the descent command. It is also a crucial examination of the copter's landing abilities; a smooth, safe landing is essential to preserve the copter and its components. The descending motion is exhibited in Figure~\ref{fig:copter-flight-test} (right).

% Figure environment removed

\subsubsection{Text-to-Performance}
We also investigate how \gpt can help with measuring the performance of a given quadcopter design.
Given a current design iteration of the copter from Section~\ref{sec:perf_quadcopter}, \gpt is able to identify important trade-offs to optimize and subsequently implement optimization strategies to improve performance. One such trade-off \gpt identified is between weight and size, where smaller copters are generally able to stay afloat longer due to reduced weight and aerodynamic drag, while larger copters have more space to accommodate larger batteries which can provide more energy for longer flight times. Out of all the possible optimization methods to find the best combination of parameters that maximize flight time, speed, and distance while meeting constraints on weight and size, \gpt chose a very suitable numerical method of Particle Swarm Optimization (PSO) from the PySwarm library. Aside from being very efficient and simple to implement, PSO has a strong global search capability, which is beneficial when the optimal solution might be located in a large and complex space, and allows for real-time adjusting of the copter's weight and size based on performance data. \gpt has a strong grasp on the inherent trade-offs of such systems, and is capable of generating tailored ideas and feasible solutions to optimize performance.

We now turn to the details of using simulation to evaluate the quadcopter's performance. In the workflow of fabricating a functional robot, simulation is often used for both control and collecting performance metric statistics that can be used for optimization. Since our fabricated robot includes its own controller, we focus on using the robot's performance in simulation for design optimization. Our design space involves both a parameterized quadcopter whose frame bar lengths can vary but is otherwise constrained by the design created in Section \ref{sec:copter-text-to-design} and the controller design. While it is possible to ask \gpt to provide suggestions on the type of controller to apply, we choose to have \gpt generate a LQR controller, which is widely used for UAVs. We break down multicopter optimization into three steps: 1) Given the \jscad design of the quadcopter, convert the design into a format specific to modeling multibody systems, such as URDF, and the means of computing relevant physical properties that inform the controller design, such as the robot's mass. 2) Given the robot's physical properties, generate a LQR controller for simulation. 3) Given  a robot design in URDF, functions for extracting the design's relevant physical properties, and a controller, synthesize an algorithm to optimize the robot's design.
% \wojciech{When do you create design space. No mention,}

\input{sections/GraphArrows/InverseDesignExperiments/QuadcopterToURDF}
\input{sections/GraphArrows/InverseDesignExperiments/QuadcopterLQR}
\input{sections/GraphArrows/InverseDesignExperiments/QuadcopterOptimization}

The resulting quadcopter with optimized frame bar lengths is visualized in Fig. \ref{fig:quadcopter_render}.

% % Leader: Megan, Edward, Andy
% Finally, We also investigate how \gpt can help with measuring the performance of the quadcopter. We use \gpt to measure the quadcopter's performance through simulation. As described in Section~\ref{sec:quadcopter_sim}, this first involves converting a given \jscad design to a format amenable to simulating multibody robots, such as URDF. We then prompt \gpt to provide a LQR controller which takes in both the design in URDF format and relevant physical properties. We also describe in Section~\ref{sec:quadcopter_sim} how the quadcopter's design can be optimized through simulation. \liane{do you use these results for the fabricated example? right now feels a bit whiplash-y to go to from fab back to simulation with no tie-in for how/if the sim is applied to the real world example}

% Figure environment removed