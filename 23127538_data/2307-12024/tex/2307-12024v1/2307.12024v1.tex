\documentclass[twocolumn,preprintnumbers,amsmath,amssymb,superscriptaddress]{revtex4}


\bibliographystyle{apsrev4-1}
\usepackage{color}
\usepackage{blindtext}
\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{gensymb}
\usepackage{animate}
\usepackage{amsmath,mathtools}
\usepackage{array,booktabs}

\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{equation*}}
\def\eea{\end{equation*}}
\def\bna{\begin{eqnarray*}}
\def\ena{\end{eqnarray*}}
\def\bn{\begin{eqnarray}}
\def\en{\end{eqnarray}}
\def\bpm{\begin{pmatrix}}
\def\epm{\end{pmatrix}}

\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray*}}
\def\eea{\end{eqnarray*}}
\def\complex{\mathbb{C}}
\def\real{\mathbb{R}}
\def\natural{\mathbb{N}}
\def\integer{\mathbb{Z}}
\def\I{\mathbb{1}}
\def \lket {\left|}
\def \rket {\right\rangle}
\def \lbra {\left\langle}
\def \rbra {\right|}

\newcommand{\bra}[1]{\langle#1|}
\newcommand{\Bra}[1]{\left\langle#1\right|}
\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\Ket}[1]{\left|#1\right\rangle}
\newcommand{\braket}[1]{\langle#1\rangle}
\newcommand{\Braket}[1]{\left\langle#1\right\rangle}


\newcommand{\REV}[1]{{\color{red} #1}}

\begin{document}



\title{Efficient quantum compression for identically prepared states with arbitrary dimentional}

 \author{Zeyu Chen}
 \email{chenzeyu@zju.edu.cn}
 \affiliation{School of Mathematics Science, Zhejiang University,
Hangzhou 310058, P. R. China}

\author{Chunhe Xiong}
 \email{xiongchunhe@zju.edu.cn}
 \affiliation{School of Mathematics and Statistics, Central South University, Changsha 410083, PR~China}

\author{Kamil Khadiev}
\email{kamilhadi@gmail.com}
\affiliation{Institute of Computational Mathematics and Information Technologies, Kazan Federal University, Kremlyovskaya, 35, Kazan, Russia}

 \author{Junde Wu}
 \email{corresponding author: wjd@zju.edu.cn}
 \affiliation{School of Mathematics Science, Zhejiang University,
Hangzhou 310058, P. R. China}


\begin{abstract} In this paper, we present an efficient quantum compression method for identically prepared states with arbitrary dimentional.
\end{abstract}

\maketitle


\section{The Schur transform and related representation theory background}

The Schur transform relates to the decomposition of $n$ $d$-dimensional system $(\mathbb{C}^d)^{\otimes n}$, which is fundamental to our compression algorithm. We first recall the basics of representation theory before introducing the decomposition.

A representation of group $\mathcal{G}$ is a vector space $V$ together with homomorphism $\pi$ from $\mathcal{G}$ to GL$(V)$, the general linear group on $V$. We say a representation $(\pi,V)$ is finite-dimensional if $V$ is  finite-dimensional. In this paper, we will always consider complex finite dimensional representations and use the term representation to denote them, and we will denote a representation $(\pi,V)$ simply by the representation space $V$. For two vector spaces $V_1$ and $V_2$, define Hom$(V_1,V_2)$ be the set of homomorphisms from $V_1$ to $V_2$. If $V_1$ and $V_2$ are both representations of $\mathcal{G}$ with homomorphisms $\pi_1$ and $\pi_2$, then the canonical action $\pi$ of $\mathcal{G}$ on Hom$(V_1,V_2)$ is given with the following rules
\begin{align}
    \pi(g)(\varphi) = \pi_1(g) \circ \varphi \circ \pi_2(g)^{-1}
\end{align}
where $g\in \mathcal{G}$ and with $\varphi \in $ Hom$(V_1,V_2)$. If $V_1$ and $V_2$ are isomorphic as $\mathbb{C}[G]$-modules, then we say that the two representations $(\pi_1,V_1)$ and $(\pi_2,V_2)$ are equivalent and write $V_1\stackrel{\mathcal{G}}{\cong} V_2$. We say a representation $(\pi,V)$ is an irreducible representation (irrep) if $V$ has exactly $2$ $\pi$-invariant subspace $\{0\}$ and $V$. Let $\Lambda$ be the complete set of inequivalent irreps of $\mathcal{G}$, then for any reducible representation $(\pi,V)$ we have the following decomposition
\begin{align}
\pi(g) &\cong \bigoplus_{\lambda\in\Lambda}r_\lambda(g)\otimes I_{n_\lambda}\\
    V&\stackrel{\mathcal{G}}{\cong} \bigoplus_{\lambda\in\Lambda} V_\lambda \otimes \mathbb{C}^{n_\lambda}
\end{align} where $(r_\lambda,V_\lambda)$ are irreps and $n_\lambda$ is the multiplicity of the irrep $V_\lambda$ in $V$.

Consider the two natural representations of the permutation group on the space $(\mathbb{C}^d)^{\otimes n}$:

\begin{align}
\mathbf{P}(s)\left|i_1 i_2 \ldots i_n\right\rangle &=\left|i_{s^{-1}(1)} \ldots i_{s^{-1}(n)}\right\rangle \\
\mathbf{Q}(U)\left|i_1 \ldots i_n\right\rangle &=U^{\otimes n}\left|i_1 \ldots i_n\right\rangle
\end{align}
where $s\in S_n$ is a permutation of $n$ objects, $s(i)$ is the label describing the action of $s$ on label $i$, and $U(d)$ denote the group of $d\times d$ unitary matrices.

Schur Weyl duality provides a simple but wonderful characterization of the decomposition of the tensor space under the joint action of the group $U(d)$ and $S(n)$. Formally, it asserts that $\mathbf{P}$ and $\mathbf{Q}$ commute and the representation space $(\mathbb{C}^d)^{\otimes n}$ decomposes into sums of products of irreps, with multiplicity 0 or 1, of $S_n$ and $U(d)$, which are uniquely determined by a partition $ [\lambda] = [\lambda_1,\lambda_2,\ldots,\lambda_d]$ such that $ \lambda_1\geq \lambda_2\geq\ldots\geq\lambda_d\geq 0$ and $\Sigma_{i=1}^d \lambda_i = n$. That are
\begin{align}
\mathbf{Q}(U)\mathbf{P}(s)&\stackrel{\mathcal{U}(d) \times \mathcal{S}_n}{\cong} \bigoplus_{[\lambda] \in \mathcal{I}_{d, n}}\mathbf{q}_{[\lambda]}(U)\otimes \mathbf{p}_{[\lambda]}(s)\\
\left(\mathbb{C}^d\right)^{\otimes n} &\stackrel{\mathcal{U}(d) \times \mathcal{S}_n}{\cong} \bigoplus_{[\lambda] \in \mathcal{I}_{d, n}} \mathcal{Q}_{[\lambda]}^d \otimes \mathcal{P}_{[\lambda]}
\end{align}
where $\mathcal{I}_{d,n}$  denotes a set of partitions of the integer $n$ into $d$  summands $[\lambda]$ with the corresponding property $\lambda_1\geq \lambda_2\geq\ldots\geq\lambda_d\geq 0$. Equivalently, Schur-Weyl duality states that there exists a basis $\ket{{[\lambda]}}\ket{q_{[\lambda]}}\ket{p_{[\lambda]}}$(which we call the Schur basis) in which the n-fold tensor action of the unitary group $U(d)$ and the action of the permutation group $S_n$ are both block diagonal
\begin{align}
\mathbf{Q}(U)|[\lambda]\rangle\left|q_\lambda\right\rangle\left|p_{[\lambda]}\right\rangle&=|[\lambda]\rangle\left(\mathbf{q}_{[\lambda]}^d(U)\left|q_{[\lambda]}\right\rangle\right)\left|p_{[\lambda]}\right\rangle \\
\mathbf{P}(s)|[\lambda]\rangle\left|q_{[\lambda]}\right\rangle\left|p_{[\lambda]}\right\rangle&=|[\lambda]\rangle\left|q_{[\lambda]}\right\rangle\left(\mathbf{p}_{[\lambda]}(s)\left|p_{[\lambda]}\right\rangle\right)
\end{align}
We call the corresponding transform that maps the standard computational basis states $\ket{i_1,i_2,\dots,i_n}$ to the Schur basis \textit{Schur transform}. Actually, the Schur transform is a quantum circuit which performs a change of basis from a local qudit-level description of a system to a global symmetry-based representation. The reader can find more information about quantum circuit in \cite{nc2010}.

\subsection{The Construction of the Irreps $\mathcal{Q}_{[\lambda]}^d$ and $\mathcal{P}_{[\lambda]}$}

In this section we describe the construction of the irreps $\mathcal{Q}_{[\lambda]}^d$ and $\mathcal{P}_{[\lambda]}$. A general methodology for the construction of these irreps relies on the usage of \textit{Gelfand-Zetlin basis} or \textit{adapted basis}.

A basis of $\mathcal{Q}_{[\lambda]}^d$ is called the \textit{Gelfand-Zetlin basis}, while that of $\mathcal{P}_{[\lambda]}$ is called the \textit{Young-Yamanouchi basis}.

For the irreps of the $d$-dimensional unitary group $U(d)$, every irrep is characterized by a partition $[\lambda] \equiv [\lambda_{i,d}] \equiv [\lambda_{1,d},\lambda_{2,d},\ldots,\lambda_{d,d}]$  of $n$ non-negative integers obeying the relation $\lambda_{i,d}\geq \lambda_{i+1,d}$; conversely every partition with d integers corresponds to a unique irrep of $U(d)$. To characterize an orthonormal basis (physically, state vectors) of an irrep $[\lambda_{i,d}]$ one uses the \textit{Weyl branching law} for $U(d)$. This law asserts that under restriction of $U(d)$ to $U(d-1)$ the irrep $[\lambda_{i,d}]$ is isomorphic to direct sum of distinct irreps $[\lambda_{i,d-1}]$ of $U(d-1)$, where the non-negative integers $[\lambda_{i,d-1}]$ satisfy the \textit{betweenness conditions}:
\begin{align}
\lambda_{id}\geq\lambda_{i,d-1}\geq\lambda_{i+1,d}
\end{align}
If two partition s $[\lambda]$ and $[\mu]$ satisfy the above condition, then we say that $[\mu]$ \textit{interlaces} $[\lambda]$ and write $[\mu] \preceq [\lambda]$. It follows that a subgroup adapted basis of irrep $[\lambda_{i{\color{red},}d}]$ can be determined uniquely by $\{\lambda_{ij}\}$ of the chain of subgroups $U(1) \subset U(2) \subset \cdots \subset U(d)$, where the irreps of $U(1)$ are trivially one-dimentional.

An elegant notation corresponding to such a  subgroup adapted basis is the \textit{Gelfand pattern} $(\lambda)$, a triangular array of $\frac{d(d+1)}{2}$ non-negative integers $(\lambda) = $ $\{\lambda_{ij}\}$ arranged as


\begin{align}
\begin{small}
\begin{pmatrix}
\lambda_{1{\color{red},}d}& &\lambda_{2{\color{red},}d}& &\cdots& &\lambda_{d-1,d}& &\lambda_{d,d}\\
& \lambda_{1,d-1}& & \lambda_{2,d-1}& & \cdots& & \lambda_{d-1,d-1}&\\
& & & &\cdots& & & & \\
& & &\ \lambda_{1{\color{red},}2}& &\ \lambda_{2{\color{red},}2}& & &\\
& & & &\lambda_{1{\color{red},}1}& & & &\\
\end{pmatrix}
\end{small}
\end{align}


The Gelfand pattern $(\lambda)$ is also denoted by $\left(\begin{aligned}
[&\lambda]_d\\
(&\lambda)_{d-1}\\
\end{aligned}\right)$, where $[\lambda]_d$ is the partition denoting an irrep in $U(d)$.

For the irreps of the permutation group $S_n$, every irrep is characterized by a partition $[\lambda] = [\lambda_i]$ too, with $\sum \limits_{i{\color{red}=1}}^{d} \lambda_i = n$. The way to characterize a basis is somewhat similar. We use the branching rule again, asserting that under restriction of $S_n$ to $S_{n-1}$ the irrep $[\lambda]$ is isomorphic to direct sum of distinct irreps $[\mu]$ with $\sum \limits_{i} \mu_i = n-1$ and $\lambda_i -1 \leq \mu_i \leq \lambda_i$. For convenience we denote such relationship between $[\lambda]$ and $[\mu]$ as $[\mu] \in [\lambda]-\square$. It follows that a subgroup adapted basis of irrep $[\lambda]$ can be determined by $n$ partitions $\{[\lambda]_i\}_{i=1}^{n}$ satisfying $[\lambda]_n = [\lambda]$.



\section{Construction of the compression algorithm}

Since $\ket{\phi}^{\otimes n}$ is obviously a symmetric state(invariant under the action of $P_n$), according to Schur-Weyl duality, it has the following property:
\begin{align}
\ket{\phi}^{\otimes n} = \sum  C^{[\lambda]}_{q_{[\lambda]},p_{[\lambda]}} \ket{[\lambda}]\ket{q_{[\lambda]}}\ket{p_{[\lambda]}}
\end{align}where the sum is over all $\lambda$ such that
\begin{align}
\mathbf{p}_{[\lambda]} (s) \ket{p_{[\lambda]}} = \ket{p_{[\lambda]}}
\end{align}holds for every $s\in P_n$. From the construction of the irreps of $S_n$ [4,6], we know the corresponding irrep is the trivial representation removed with labeled by $[n]$. Thus, in order to give an efficient scheme of compression for identically prepared states, we can simply implement the Schur transform.

The direct implementation of Schur transform is difficult. By introducing the CG transform, we can give a scheme to perform the recursion step in the construction of the Schur transform.

Let $\mathcal{Q}_{[\mu]}^d$ and $\mathcal{Q}_{[\nu]}^d ([\mu] \in \mathcal{I}_{d,n}$  and $[\nu] \in \mathcal{I}_{d,m}$) be two irreps of the unitary group $U(d)$ acting on qudits. Note that the tensor product $\mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[\nu]}^d$ is also a representation of $U(d)$, then it can decompose into direct sum of irreps:
\begin{align}
\mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[\nu]}^d \stackrel{\mathcal{U}(d) }{\cong} \bigoplus_{[\lambda] \in \mathcal{I}_{d,n+m}} \mathcal{Q}_{[\lambda]}^d \otimes \mathcal{M}^{[\lambda]}_{[\mu] ,[\nu]}
\end{align}
where $\mathcal{M}^{[\lambda]}_{[\mu] ,[\nu]}$ is the multiplicity space associated to $[\mu] ,[\nu]$ and $[\lambda]$. Then{\color{red},} we call the transform implementing this isomorphism the \textit{Clebsch-Gorden (CG) transform}.

For our purpose, we specialize in the case of $[\nu] \equiv [1]$, for which the CG transform is much simpler than the general case:
\begin{align}
\mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[1]}^d \stackrel{\mathcal{U}(d) }{\cong} \bigoplus_{[\lambda] \in \mu + \square} \mathcal{Q}_{[\lambda]}^d
\end{align}where $[\mu] + \square$ denotes, similar to the above definition, the set of $[\lambda]$ such that $\sum \limits_{i}\lambda_i = n + 1$ and $\lambda_i -1 \leq \mu_i \leq \lambda_i$. We also denote $[\lambda] = [\mu] + e_j$ where $\lambda_j =  \mu_j + 1$, and $e_j$ is.

Explicitly, a CG transform $\mathbf{U}_{CG}^d$ is given as follows:
\begin{align}
\mathbf{U}^d_{CG} \ket{(\mu)}\ket{i} = \sum_{[\mu]+e_j\in [\mu]+ \square \atop (\lambda)\in \mathcal{Q}_{[\mu + e_j]}^{d}} C_{[\mu],i}^{[\lambda]} \ket{(\lambda)} \label{cg}
\end{align}
for some coefficients $C_{[\mu],i}^{[\lambda]}\in \mathbb{C}$, where $(\mu)$ is a vector in $\mathcal{Q}^d_{[\mu]}$ and $\ket{i}$ is a state in $\mathcal{Q}^d_{[1]}$.

We can construct the Schur transform by recursive implementation of CG transforms. Suppose we start with input $\ket{i_1,\ldots ,i_n} \in (\mathbb{C}^d)^{\otimes n} = (\mathcal{Q}_{[1]}^d)^{\otimes n}$, it suffices to decompose $(\mathcal{Q}_{[1]}^d)^{\otimes n}$ into $U(d)-$irreps since Schur-Weyl duality tells us that the multiplicity space of $U(d)-$irreps must be isomorphic to irreps of $S_n$. To perform the decomposition, we simply apply $n-1$ uses of CG transform, one at a time. We start by inputing $\ket{i_1}\in \mathcal{Q}_{[\mu]}^d = \mathcal{Q}_{[1]}^d$ and $\ket{i_2}\in\mathcal{Q}_{[1]}^d$ to obtain a superposition of $\ket{[1]} \ket{(\lambda)_2}$ (see eq.\eqref{cg}). Then, we apply an another CG transform to $\ket{(\lambda)_2}\ket{i_3}$ respectively, remaining $\ket{[\lambda]_1} = \ket{[1]}$ as part of output. After that, we obtain a superposition of $\ket{[\lambda]_2} \ket{(\lambda)_3}$ and we continue to apply the next CG transform. The procedure is repeated for $k = 1,\ldots , n-1$ and the result is a superposition of sequences of partitions $\ket{[\lambda]_k}$, and $\ket{(\lambda)_n}$.

Let us inspect our output $$C_{(\lambda)_n}^{[\lambda]_1,\ldots ,[\lambda]_{n-1}} \ket{[\lambda]_1,\ldots ,[\lambda]_{n-1}}\ket{(\lambda)_n}$$ for some coefficients $C_{(\lambda)_n}^{[\lambda]_1,\ldots ,[\lambda]_{n-1}} \in \mathbb{C} $. Recall the Schur basis $\ket{{[\lambda]}}\ket{q_{[\lambda]}}\ket{p_{[\lambda]}}$, we find that $\ket{[\lambda]} = \ket{[\lambda]_n}$, and $\ket{q_{[\lambda]}} = \ket{(\lambda)_n}$. Moreover, it is natural that $\ket{[\lambda]_{k+1}} = \ket{[\lambda]_k} + e_{j_k}$for some $j_k \in [d]$. Then $\ket{[\lambda]_1,\ldots ,[\lambda]_{n-1}}$, together with $\ket{[\lambda]_n}$, forms a basis vector in some $S_n$-irrep $\mathcal{P}_{[\lambda]}$. Thus we obtain our desired result.

At $d=1$, the CG transform is trivial, consisting of the map $i \rightarrow i+1 $ for $i \in \mathbb{Z}$. For the case of $d=2$, CG transform can be viewed as a map from the basis of tensor products of the basis vectors of the subsystems to the basis composed of eigenvectors of the composite spin operators, which can be explicitly and efficiently calculated using classical algorithm [7]. However, the general implementation of CG transform is difficult. To solve this problem, we give a recursive construction of CG transform. Our construction follows the work of [8], where the CG transform $\mathbf{U}^d_{CG}$ is expressed as a composite of CG transforms $\mathbf{U}^{d-1}_{CG}$ and the so-called \textit{reduced Wigner operators}.

A CG transform $\mathbf{U}^d_{CG}$ have the following decomposition:
\begin{align}
\mathbf{U}^d_{CG} \ket{(\mu)_n}\ket{i} = \sum_{j^\prime = 0,1,...,n} \Phi \circ \widetilde{\mathbf{U}}^{d-1}_{CG} \ket{(\mu)_{n}} \ket{i}
\end{align}
where $\widetilde{\mathbf{U}}^{d-1}_{CG}$ is an extension of the operator $\mathbf{U}^{d-1}_{CG}$ that maps $\ket{(\mu)_n}\ket{d}$ to $\ket{[\mu]_n }\ket{(\mu)_{n-1}}$, and $\Phi$ is so-called reduced Wigner transform that maps $\ket{[\mu]_n}\ket{[\mu]_{m-1}}$ to $\ket{(\lambda)_n} = \ket{[\mu]_n+e_j}\ket{[\mu] _{n-1}+e_{j^\prime}}$ ($\ket{[\mu] _{n-1}+e_{j^\prime}}$ is obtained from $\widetilde{\mathbf{U}}^{d-1}_{CG}$), And the coefficients of the operator can be calculated by the following formula:

\begin{equation}
\begin{split}
&\bra{[\mu]_n+e_j}\bra{[\mu] _{n-1}+e_{j^\prime}} \Phi  \ket{[\mu]_n}\ket{[\mu]_{n-1}}\\
&= \begin{cases}
S(j^\prime - j) \left[\frac{\prod \limits_{s \in [d-1]\backslash j^\prime}(\tilde{\mu}_{j,n}-\tilde{\mu}_{s,n-1})\prod\limits_{t \in [d]\backslash j}(\tilde{\mu}_{j^\prime,n-1}- \tilde{\mu}_{t,n}+1) }{\prod \limits_{s \in [d-1]\backslash j^\prime}(\tilde{\mu}_{j^\prime,n-1}-\tilde{\mu}_{s,n-1}+1) \prod\limits_{t \in [d]\backslash j}(\tilde{\mu}_{j,n}-\tilde{\mu}_{s,n})}\right]^{\frac{1}{2} }  \\
\quad\quad\quad\quad\quad\quad \quad\quad\quad\quad\quad\quad\quad\text { if } j^{\prime} \in\{1, \ldots, d-1\}, \\
S(d-j) \left[\frac{\prod_{s \in [d-1]} (\tilde{\mu}_{j,n}-\tilde{\mu}_{s,n-1})}{\prod_{t \in [d]\backslash j}(\tilde{\mu}_{j,n}-\tilde{\mu}_{s,n})}  \right]^{\frac{1}{2}}   \\
\quad\quad\quad\quad\quad\quad \quad\quad\quad\quad\quad\quad\quad\text { if } j^{\prime}=0 .
\end{cases}
\end{split}
\end{equation}
where $\tilde{\mu}_{ks}=\mu_{ks} + s - k$, $S(x) =1$ if $x > 0$ and $S(x)=-1$ otherwise.

Based on the above discussion, we put forward the following algorithm:
\vspace{9pt}

\noindent{\bf Algorithm 1: Compression} \\
{\bf Inputs:}\\(1) Classical registers $d$ and $n$. (2)  n copys of an identical qudits $\rho^{\otimes n}$ \\
{\bf Outputs:} \\A state $\sum_{i=1}^r x_i \ket{i}$, with $r=dim(\mathcal{Q}_{[n]}^{d})$.\\
{\bf Procedure:}\\
{\bf 1.} For $k=1,...,n-1$:\\
{\bf 2.}\quad Apply Clebsch-Gordan transform for the first $k+1$ qudits.\\
{\bf 3.} End.
\vspace{9pt}

Indeed, the algorithm uses the property of Schur-Wely duality to compress identically prepared states. Since the image of the state is symmetric, we can leave out $\ket{[\lambda]}$ and $\ket{p_{[\lambda]}}$ (see Eq. (6)) wherein $[\lambda] = [n]$ and $\mathcal{P}_{[\lambda]}$ is trivial. Then a good ordering fixes the basis of $\mathcal{Q}_{[1]}^{d}$ be the first $r$ basis of the total space.

Now we give the algorithm of the Clebsch-Gordan transform.
\vspace{9pt}

\noindent{\bf Algorithm 2: Clebsch-Gordan transform} \\
{\bf Inputs:}\\(1) Classical registers $d$. (2)  A state belonging to $\mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[1]}^d$, where $[\mu]\in \mathcal{I}_{d,n}$.\\
{\bf Outputs:} \\A state belonging to $\bigoplus_{[\lambda] \in \mu + \square} \mathcal{Q}_{[\lambda]}^d $.\\
{\bf Procedure:}\\
{\bf 1.} For a basis $\ket{(\mu)}\ket{i}\in \mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[1]}^d$, If $d=1$\\
{\bf 2.}\quad Output $\ket{(\lambda)}$ with $\ket{(\lambda)} = \ket{(\mu)} + e_1$ is a partition.\\
{\bf 3.} Else\\
{\bf 4.}\quad If $i < d$\\
{\bf 5.}\quad \quad Perform the $(d-1)$-dim CG transform on $\ket{(\mu)_{d-1}} \ket{i}$ and output the superposition of $\ket{(\lambda)_{n-1}} = \ket{\begin{bmatrix}
[\mu+e_{j^\prime}]_{n-1}  \\
(\mu)^{\prime}_{n-2}
\end{bmatrix}}$. Record $j^\prime$.\\
{\bf 6.}\quad Else (if $i=d$)\\
{\bf 7.}\quad \quad output $\ket{(\lambda)_{n-1}} = \ket{(\mu)_{n-1}}$ and record $j^\prime = 0$.\\
{\bf 8.}\quad Perform the operator $\Phi$ according to Eq. (20).\\
{\bf 9.} End.

\vspace{9pt}

\section{Analysis and modification}

Let ${\cal C}_{d,n}=\{(c_1,\dots,c_d): c_1+c_2+\cdots+c_d=n, 0\leq c_1,\dots,c_d\leq n\}$. Direct calculation yields
\begin{equation}
\begin{split}
\ket{\phi}^{\otimes n} = \sum\limits_{(c_1,\dots,c_d)\in {\cal C}}\ \prod\limits_{i=1}^{d}\alpha_i^{c_i} \\
\sum\limits_{s\in S_n} P(s)\left(\bigotimes\limits_{i=1,2,\dots,d}\ket{i-1}^{\otimes c_i}\right)
\end{split}
\end{equation}
where
\begin{equation}
\ket{\phi}=\alpha_1\ket{0}+\alpha_2\ket{1}+\cdots+\alpha_d\ket{d-1}{\color{red}.}
\end{equation}
Then, $$\ket{c_1;c_2;\cdots;c_d} = \sum\limits_{s\in S_n} P(s)\left(\bigotimes\limits_{i=1,2,\dots,d}\ket{i-1}^{\otimes c_i}\right)$$ is a basis of the subspace of all states $\ket{\phi^{\otimes n}}$ with $c_1+c_2+\cdots+c_d=n$ (these states are obviously independent).  The total number of $\ket{c_1;c_2;\cdots;c_d}$ is equal to the number of different Gelfand patterns of partition $[n]$, that is, the dimension of $\mathcal{Q}_{[n]}^d$. Actually, our algorithm transforms $\ket{c_1;c_2;\cdots;c_d}$ to $\ket{0},\ket{1},\dots,\ket{dim(\mathcal{Q}_{[n]}^d)-1}$. Thus the algorithm is optimal with respect to space. The dimension of this space can be obtained with techniques of  combinatorial mathematics, with result
\begin{equation}
    dim(\mathcal{Q}_{[n]}^d) =  \begin{pmatrix}
    n+d-1 \\
    d-1
    \end{pmatrix}
\end{equation}
Then, if $d$ is not too large (that is, $d$ can be regarded constant), then the space to memory the information of $\ket{\phi}^{\otimes n}$ is polynomial of $n$.

Defined $T_1(n,d)$ be the time complexity (in terms of numbers of local operations and C-NOT gates) of {\bf Algorithm 1} with $n$ states of dimension $d$. By its recursive construction, we have
\begin{equation}
    T_1(n,d) = \sum\limits_{i=2}^{n} T_{2}(i,d) \leq (n-1)T_{2}(n,d)
\end{equation}
where $T_{2}(n,d)$ is the time complexity of performing {\bf Algorithm 2} on dimension d and partition of $\leq n$. Then, we turn our attention to $T_{2}(n,d)$.

It is easy to verify that the implementation of {\bf Algorithm 2} requires exponential complexity since $\Phi$ is an $n\times n$ matrix. Then, we should make a little modification to the algorithm. Note that we compress $\ket{\phi}^{\otimes n}$ to a state in $\mathcal{Q}_{[n]}^d$, and by above discussion states in $\mathcal{Q}_{[k]}^d$ occur after CG transform only if the input state belongs to $\mathcal{Q}_{[\mu]}^d \otimes\mathcal{Q}_{[1]}^d$ where $[\mu] \in [\lambda]-\square$, that is, $[\mu] = [k-1]$. Thus, for the purpose of compression, we take no care about the action on states that is not in $\mathcal{Q}_{[k]}^d \otimes\mathcal{Q}_{[1]}^d$. Thus the implementation of $\Phi$ can be simplified as follows:

\vspace{9pt}
\noindent{\bf Algorithm 2'} \\
{\bf Inputs:}\\(1) Classical registers $d$. (2)  A state belonging to $\mathcal{Q}_{[k]}^d \otimes\mathcal{Q}_{[1]}^d$.\\
{\bf Outputs:} \\A state belonging to $\bigoplus_{[\lambda] \in [k] + \square} \mathcal{Q}_{[\lambda]}^d $.\\
{\bf Procedure:}\\
{\bf 1.} For a basis $\ket{(\mu)}\ket{i}\in \mathcal{Q}_{[k]}^d \otimes\mathcal{Q}_{[1]}^d$, If $d=1$\\
{\bf 2.}\quad Output $\ket{(\lambda)}$ with $\ket{(\lambda)} = \ket{(\mu)} + e_1$ is a partition.\\
{\bf 3.} Else\\
{\bf 4.}\quad If $i < d$\\
{\bf 5.}\quad \quad Perform the $(d-1)$-dim CG transform on $\ket{(\mu)_{d-1}} \ket{i}$ and output the superposition of $\ket{(\lambda)_{n-1}} = \ket{\begin{bmatrix}
[\mu+e_{j^\prime}]_{n-1}  \\
(\mu)^{\prime}_{n-2} \\
\end{bmatrix}}$. Record the coefficient if $j^\prime = 1$.\\
{\bf 6.}\quad Else (if $i=d$)\\
{\bf 7.}\quad \quad output $\ket{(\lambda)_{n-1}} = \ket{(\mu)_{n-1}}$ and record $j^\prime = 0$.\\
{\bf 8.}\quad Perform the operator $\Phi^\prime$ by calculating the elements with $j=1$ and $j^{\prime}= 0,1$, and supplement other elements to ensure that $\Phi^\prime$ is unitary.\\
{\bf 9.} End.
\vspace{9pt}

A little details of the algorithm should be clarified. The implementation of the algorithm uses classical computation as a subroutine. It is clear that the calculation of $\Phi^\prime$ as a unitary matrix is classical. The process of such calculation is as follows. Firstly, we calculate the elements with $j=1$ and $j^{\prime}= 0,1$, then we supply the matrix by direct calculation to ensure that image of a state vector is also a state vector. It needs constant arithmetic for every state. It is noteworthy that $(d-1)$-dimensional CG transform is not a subroutine of $d$-dimensional CG transform as a quantum algorithm due to the difference in the data structure. Thus we calculate the matrix of $(d-1)$-dim CG transform and matrix $\Phi^\prime$ on a classical computer, then we implement them on a quantum circuit to finish quantum CG transform.

According to the above discussion, the unitary gate of CG transform is of the dimension at most $(d-1)\cdot \begin{pmatrix}
    n+d-1 \\
    d-1
    \end{pmatrix} $, thus it can be implemented using a number of polynomial local operations and C-NOT gates. It follows from (24) that the complexity of the total algorithm is polynomial in $n$.


\section{Acknowledgments} This work is supported by National Natural Science Foundation of
China under Grant No. 61877054, 12031004,12271474, 12201555 and the Foreign Experts in Culture
and Education Foundation under Grant No. DL2022147005L. Kamil Khadiev thanks these
projects for supporting his visit.

\begin{thebibliography}{10}
\providecommand{\url}[1]{#1}
\csname url@samestyle\endcsname
\providecommand{\newblock}{\relax}
\providecommand{\bibinfo}[2]{#2}
\providecommand{\BIBentrySTDinterwordspacing}{\spaceskip=0pt\relax}
\providecommand{\BIBentryALTinterwordstretchfactor}{4}
\providecommand{\BIBentryALTinterwordspacing}{\spaceskip=\fontdimen2\font plus
\BIBentryALTinterwordstretchfactor\fontdimen3\font minus
  \fontdimen4\font\relax}
\providecommand{\BIBforeignlanguage}[2]{{%
\expandafter\ifx\csname l@#1\endcsname\relax
\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}%
\typeout{** loaded for the language `#1'. Using the pattern for}%
\typeout{** the default language instead.}%
\else
\language=\csname l@#1\endcsname
\fi
#2}}
\providecommand{\BIBdecl}{\relax}
\BIBdecl

\bibitem{plesch2010efficient}
M.~Plesch and V.~Bu{\v{z}}ek, ``Efficient compression of quantum information,''
  \emph{Physical Review A}, vol.~81, no.~3, p. 032317, 2010.

\bibitem{rozema2014quantum}
L.~A. Rozema, D.~H. Mahler, A.~Hayat, P.~S. Turner, and A.~M. Steinberg,
  ``Quantum data compression of a qubit ensemble,'' \emph{Physical review
  letters}, vol. 113, no.~16, p. 160504, 2014.

\bibitem{fulton2013representation}
W.~Fulton and J.~Harris, \emph{Representation theory: a first course}.\hskip
  1em plus 0.5em minus 0.4em\relax Springer Science \& Business Media, 2013,
  vol. 129.

\bibitem{ping2002group}
J.~Ping, F.~Wang, and J.-Q. Chen, \emph{Group representation theory for
  physicists}.\hskip 1em plus 0.5em minus 0.4em\relax World Scientific
  Publishing Company, 2002.

\bibitem{gelfand1950finite}
I.~M. Gelfand and M.~L. Tsetlin, ``Finite-dimensional representations of the
  group of unimodular matrices,'' in \emph{Dokl. Akad. Nauk SSSR}, vol.~71,
  no.~8, 1950, p. 825.

\bibitem{towber1983gordon}
J.~Towber, ``Gordon james and adalbert kerber, the representation theory of the
  symmetric group,'' 1983.

\bibitem{kirby2017practical}
W.~M. Kirby and F.~W. Strauch, ``A practical quantum algorithm for the schur
  transform,'' \emph{arXiv preprint arXiv:1709.07119}, 2017.

\bibitem{biedenharn1968pattern}
L.~Biedenharn and J.~Louck, ``A pattern calculus for tensor operators in the
  unitary groups,'' \emph{Communications in Mathematical Physics}, vol.~8,
  no.~2, pp. 89--131, 1968.

\bibitem{weyl1946classical}
H.~Weyl, \emph{The classical groups: their invariants and
  representations}.\hskip 1em plus 0.5em minus 0.4em\relax Princeton university
  press, 1946, no.~1.

\bibitem{goodman2000representations}
R.~Goodman and N.~R. Wallach, \emph{Representations and invariants of the
  classical groups}.\hskip 1em plus 0.5em minus 0.4em\relax Cambridge
  University Press, 2000.

\end{thebibliography}

\end{document}

