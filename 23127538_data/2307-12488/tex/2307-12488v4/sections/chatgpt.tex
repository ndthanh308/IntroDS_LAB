% \vspace{-0.5em}
\section{Qualitative Analysis on ChatGPT}
ChatGPT has the potential to perform source code level analysis and address security-related issues, such as vulnerability discovery and fixing~\cite{surameery2023use,cheshkov2023evaluation}.
A source code file in a program consists of a sequence of strings, which can be grouped into three categories: keyword, operator, (both are defined in the programming language specification) and developer-defined name.
Keywords are reserved words that have special meanings and can only be used for specific purposes.
For example, \texttt{for}, \texttt{if}, and \texttt{break} are widely known keywords in many programming languages.
They are used in a program to change the control flow.
The number of keywords is limited in a programming language.
% For instance, \texttt{C} programming language has 32 keywords and \texttt{Python} (version 3.7) has 35 keywords.
% Besides keywords, a programming language needs to define a set of operators, representing operations and actions.
% For example, arithmetic operators (\eg, \texttt{+}, \texttt{-}, and \texttt{*}) and logical operators (\eg, \texttt{and}, \texttt{or}, and \texttt{not}) are two of most important categories.
In addition, a developer can use any string to name a variable, structure, function, class, etc., as long as this string is not conflicted with reserved keywords and operators, and follows the programming language specification.

When writing code, due to the program logic, the developer has limited flexibility to choose keywords and operators.
Only some keywords (such as \texttt{for} and \texttt{while}) and operators (such as \texttt{++}, \texttt{+1}) are exchangeable.
That is, the program logic is fixed when using a set of keywords and operators in a program.
In contrast, the name of a variable, function, or class has no impact on the program logic.
To better explain what kind of features learned by ChatGPT, we have the following definition:
\begin{definition}[Literal Features and Logical Features]
Given a piece of code, the \textbf{literal features} are features of the literal meaning of the variable names, function names, and programmer-readable annotation. These features could be removed without changing the functionality of the code. The \textbf{logical features} are features that control the program logic. The keywords and operators defined by a programming language specification are logical features.
\end{definition}

In this section, we conduct case studies on the ChatGPT with a series of analytical tasks.
Specifically, we first assess ChatGPT's capability to comprehend source code.
Subsequently, we evaluate ChatGPT's proficiency in tackling specific security challenges and generalization ability.
% Finally, we test the generalization abilities

% \vspace{-0.5em}
\subsection{Code Semantic Inference}
Accurately analyzing source code not only requires the analyzer to comprehend the literal meaning of variable and function names but also to understand the underlying program logic.
Gaining a precise understanding of the logic poses several challenges to analytical tasks.
We have three questions to study: \ding{182}: whether GPT is able to understand program logic besides the literal meaning.
% \ding{183}: whether it is be capable of tracking the data flow of variables within the code.
\ding{183}: whether it possesses inter-procedural analysis abilities to comprehend code snippets that involve more than one function.

% To assess ChatGPT's performance on source code semantic inference, we conduct experiments where ChatGPT analyzes various code snippets and answers questions related to the program's logic.
To answer \ding{182}, ChatGPT is inquired about the functionality of a C/C++ implementation of the Bubble Sort algorithm and an obfuscated version. We replace the variable and function names with random strings. \autoref{code:bubble} is anonymized on the function name and variable names in case ChatGPT can infer the algorithm from the literal meaning of the names.
The analysis results from ChatGPT ({\bf \ref{appendix:Q1}}) show that ChatGPT accurately analyzed the program and correctly identified its type, which indicates that  GPT can understand program logic.
% This aimed to test whether ChatGPT could still accurately interpret the code's logic despite the lack of meaningful names as shown in Q2.
To answer \ding{183}, we proceeded to test ChatGPT's inter-procedural analysis capabilities by splitting the algorithm into three functions and prompting ChatGPT to infer the overall algorithm (({\bf \ref{appendix:Q2}})). This evaluation aimed to determine if ChatGPT could effectively understand the logic across multiple functions within the code.
%  we can confidently conclude that all details provided are accurate.

Our experiment demonstrates ChatGPT's capability to analyze the data flow across multiple functions, showing its potential for inter-procedural analysis.
This promising result suggests that ChatGPT can perform complex tasks involving the understanding and inference of program logic across different functions.

% \vspace{-0.5em}
\subsection{Vulnerabilities Analysis and Bug Fixing}

This section answers \ding{184} how effectively ChatGPT can analyze security bugs. 
We adopt a piece of code ({\bf \ref{appendix:Q3}}) that contains buffer overflow vulnerability and then task ChatGPT to find the vulnerabilities.
Then, we replace the \texttt{strcpy} function with a homemade string copy function ({\bf \ref{appendix:Q4}}) and challenge ChatGPT with modified code.

The analysis conducted by ChatGPT on the vulnerability in the code was impressively accurate, showing its potential to identify vulnerabilities in the source code effectively.
However, in an effort to explore its understanding of potential security risks, we posed another question:
\ding{185} Whether ChatGPT can exploit a vulnerability to launch an attack.

Through experiment ({\bf \ref{appendix:Q5}}), we observed that the exploit proposed by ChatGPT, although not directly usable to launch attacks, was conceptually correct.
This suggests that ChatGPT possesses the ability to assist attackers in generating potential exploits.

Then, we investigate \ding{186} whether ChatGPT can also provide solutions to fix the identified vulnerability.
Our evaluation ({\bf \ref{appendix:Q6}}) has demonstrated that the proposed patching effectively addresses the vulnerability in the code, providing an effective fix.
As a result, we believe that ChatGPT holds the potential to assist developers and security analysts in identifying and resolving vulnerabilities in programs.

Finally, we assess \ding{187} whether it can suggest protection schemes that thwart potential exploits by attackers.
By leveraging ChatGPT's analysis, we aim to explore its ability to propose robust security measures that can safeguard against known vulnerabilities and potential attack vectors.

In the experiment (({\bf \ref{appendix:Q7}})), the proposed protection scheme suggested by ChatGPT demonstrates a conceptually correct approach to detect buffer overflows through the use of a ``canary''.
However, upon closer inspection, we identified some implementation errors that may impact its effectiveness.
The placement of the canary at the beginning of the buffer, instead of at the end, renders it unable to detect buffer overflows that overwrite adjacent variables located at higher memory addresses.
Additionally, the revised code introduces the ``canary'' into the buffer without correspondingly increasing the buffer size, limiting its capacity to handle strings as long as the original implementation.

These issues raise concerns regarding ChatGPT's generalization ability.
While ChatGPT appears to understand the concept of using a ``canary'' for buffer overflow detection, it seems to struggle in correctly applying this knowledge to unseen code snippets.
This observation leads us to question whether ChatGPT has effectively learned the intricacies of canary-based detection schemes from its training corpus.%, yet lacks the capability to seamlessly apply this knowledge to novel scenarios.



\input{sections/smartcontract}

\input{sections/case-fuzzing}

\input{sections/generalization}

% \vspace{-0.5em}
\subsection{Observations}
This section presents a series of experiments and empirical analyses aimed at elucidating ChatGPT's capacity for solving security-oriented program analysis.
Firstly, it demonstrates that ChatGPT, along with other large language models, opens up a novel avenue for security-oriented source code analysis, proving to be an efficient method for learning high-level semantics from well-named source code. 
% In comparison to other language models like CodeBert and GraphCodeBert~\cite{feng2020codebert,guo2020graphcodebert,zhang2023features}, ChatGPT showcases superior performance in this domain. 
Even at the binary level, ChatGPT displays the ability to learn low-level semantics, including data flow propagation in assembly code and value sets post-calculation.
%This impressive learning capability paves a way for its potential application in security-oriented contexts.

Despite its strengths, there are certain limitations worth noting.
One limitation is that users and researchers should expect downgraded model performance when applying ChatGPT to analyze source code that lacks sufficient information in variable, function, or class names.
For instance, code generated from decompilation~\cite{katz2018using} or code that does not adhere to standard naming conventions~\cite{butler2015investigating} may yield lower accuracy based on questions {\bf \ref{appendix:Q14}} and {\bf \ref{appendix:Q15}}.
This points to the model's limited generalization ability, as it lacks a deep understanding of code semantics, logic, or context beyond the patterns and examples present in its training data.
Additionally, for very specific questions that involve implementation-level details, ChatGPT's proposed solutions may be conceptually correct at a high level but may not fully address the problem. 
% These limitations serve as areas for further investigation and improvement to enhance the model's performance in such scenarios.



% \subsection{Assemble Code Analysis}
% In this section, we investigate the ChatGPT's ability to perform the binary code analysis.
% We first test ChatGPT's ability on binary disassembling, and then ask questions about the semantic of the code.  


% \lstset{language=[x64]Assembler}

% \colorlet{shadecolor}{red!5}
% \begin{shaded*}
% \noindent{\bf Q14:} \textit{The disassemble code of \texttt{`c7 45 cc 0a 00 00 00 c7 45 c8 14 00 00 00 8b 75 cc 03 75 c8 89 75 c4'} in Intel 64 instruction set?}
%   { }
%   \end{shaded*}
% \vspace{-2.5em}
% \colorlet{shadecolor}{green!5}
% \begin{shaded*}
% \setlength{\parindent}{0em}
% {\footnotesize 
%   \noindent{\bf Reply from ChatGPT:} 
% \begin{lstlisting}[emph={},
% 	label=code:assem,captionpos=b, numbers=none, frame=none]
%     c7 45 cc 0a 00 00 00     mov     DWORD PTR [rbp-0x34], 0xa
%     c7 45 c8 14 00 00 00     mov     DWORD PTR [rbp-0x38], 0x14
%     8b 75 cc                 mov     esi, DWORD PTR [rbp-0x34]
%     03 75 c8                 add     esi, DWORD PTR [rbp-0x38]
%     89 75 c4                 mov     DWORD PTR [rbp-0x3c], esi
    
% \end{lstlisting}
% This is the disassembled code in Intel 64 instruction set:
% \begin{enumerate}
% \item \texttt{mov DWORD PTR [rbp-0x34], 0xa} ~\textendash~ Moves the immediate value \texttt{0xa} into the double-word (4 bytes) memory location at \texttt{[rbp-0x34]}.

% \item \texttt{mov DWORD PTR [rbp-0x38], 0x14} ~\textendash~ Moves the immediate value \texttt{0x14} into the double-word memory location at \texttt{[rbp-0x38]}.

% \item \texttt{mov esi, DWORD PTR [rbp-0x34]} ~\textendash~ Moves the double-word value from memory location \texttt{[rbp-0x34]} into the \texttt{esi} register.

% \item \texttt{add esi, DWORD PTR [rbp-0x38]} ~\textendash~ Adds the double-word value from memory location \texttt{[rbp-0x38]} to the \texttt{esi} register.

% \item \texttt{mov DWORD PTR [rbp-0x3c], esi} ~\textendash~ Moves the value in the esi register into the double-word memory location at \texttt{[rbp-0x3c]}.
% \end{enumerate}
%   }\end{shaded*} 

% % \noindent{\bf Q14:} \textit{The disassemble code of \texttt{`c7 45 cc 0a 00 00 00 c7 45 c8 14 00 00 00 8b 75 cc 03 75 c8 89 75 c4'} in Intel 64 instruction set?}

% % \begin{shaded*}
% %     \footnotesize
% % \noindent{\bf Reply from ChatGPT:} 
% % \begin{lstlisting}[emph={},
% % 	label=code:assem,captionpos=b, numbers=none, frame=none]
% %     c7 45 cc 0a 00 00 00     mov     DWORD PTR [rbp-0x34], 0xa
% %     c7 45 c8 14 00 00 00     mov     DWORD PTR [rbp-0x38], 0x14
% %     8b 75 cc                 mov     esi, DWORD PTR [rbp-0x34]
% %     03 75 c8                 add     esi, DWORD PTR [rbp-0x38]
% %     89 75 c4                 mov     DWORD PTR [rbp-0x3c], esi
    
% % \end{lstlisting}
% % This is the disassembled code in Intel 64 instruction set:
% % \begin{enumerate}
% % \item \texttt{mov DWORD PTR [rbp-0x34], 0xa} ~\textendash~ Moves the immediate value \texttt{0xa} into the double-word (4 bytes) memory location at \texttt{[rbp-0x34]}.

% % \item \texttt{mov DWORD PTR [rbp-0x38], 0x14} ~\textendash~ Moves the immediate value \texttt{0x14} into the double-word memory location at \texttt{[rbp-0x38]}.

% % \item \texttt{mov esi, DWORD PTR [rbp-0x34]} ~\textendash~ Moves the double-word value from memory location \texttt{[rbp-0x34]} into the \texttt{esi} register.

% % \item \texttt{add esi, DWORD PTR [rbp-0x38]} ~\textendash~ Adds the double-word value from memory location \texttt{[rbp-0x38]} to the \texttt{esi} register.

% % \item \texttt{mov DWORD PTR [rbp-0x3c], esi} ~\textendash~ Moves the value in the esi register into the double-word memory location at \texttt{[rbp-0x3c]}.
% % \end{enumerate}
% % \end{shaded*}

% As shown in Q14, ChatGPT can correctly disassemble Intel x64 binary code. 
% In the next question, we ask about the semantic information about this assemble code. 


% \colorlet{shadecolor}{red!5}
% \begin{shaded*}
% \noindent{\bf Q15:} \textit{
% After the execution of intel64 machine code \texttt{`c7 45 cc 0a 00 00 00 c7 45 c8 14 00 00 00 8b 75 cc 03 75 c8 89 75 c4'}. What is the value in register \texttt{`\%esi'}, memory \texttt{`rbp-0x34'} and memory \texttt{`rbp-0x3c'}?}
%   { }
%   \end{shaded*}
% \vspace{-2.5em}
% \colorlet{shadecolor}{green!5}
% \begin{shaded*}
% \setlength{\parindent}{0em}
% {\footnotesize 
%   \noindent{\bf Reply from ChatGPT:} 
% Let's simulate the execution of the provided Intel 64 machine code step by step to determine the values in register \texttt{\%esi}, memory location \texttt{rbp-0x34}, and memory location \texttt{rbp-0x3c} after the execution.

% Assuming that the initial values of the relevant registers and memory locations are 0, here's the execution:
% \begin{enumerate}
% \item \texttt{mov DWORD PTR [rbp-0x34], 0xa} ~\textendash~ Moves the immediate value \texttt{0xa} into the memory location \texttt{[rbp-0x34]}.

% Value at \texttt{[rbp-0x34]: 0x0000000a}
% \item \texttt{mov DWORD PTR [rbp-0x38], 0x14} ~\textendash~ Moves the immediate value \texttt{0x14} into the memory location [rbp-0x38].
% Value at \texttt{[rbp-0x38]: 0x00000014}
% \item \texttt{mov esi, DWORD PTR [rbp-0x34]} ~\textendash~ Moves the double-word value from memory location \texttt{[rbp-0x34]} into the \texttt{\%esi} register.

% Value in \texttt{\%esi: 0x0000000a}
% \item \texttt{add esi, DWORD PTR [rbp-0x38]} ~\textendash~ Adds the double-word value from memory location [rbp-0x38] to the \texttt{\%esi} register.

% Value in \texttt{\%esi: 0x0000001e (0x0a + 0x14 = 0x1e)}
% \item \texttt{mov DWORD PTR [rbp-0x3c], esi} ~\textendash~ Moves the value in the \texttt{\%esi} register into the memory location \texttt{[rbp-0x3c]}.

% Value at \texttt{[rbp-0x3c]: 0x0000001e}

% \end{enumerate}

% After the execution of the machine code, the final values are as follows:
% \begin{enumerate}
% \item Value in \texttt{\%esi: 0x0000001e}
% \item Value at \texttt{[rbp-0x34]: 0x0000000a}
% \item Value at \texttt{[rbp-0x3c]: 0x0000001e}
% \end{enumerate}
%   }\end{shaded*} 

% % \noindent{\bf Q15:} \textit{
% % After the execution of intel64 machine code \texttt{`c7 45 cc 0a 00 00 00 c7 45 c8 14 00 00 00 8b 75 cc 03 75 c8 89 75 c4'}. What is the value in register \texttt{`\%esi'}, memory \texttt{`rbp-0x34'} and memory \texttt{`rbp-0x3c'}?}

% % \begin{shaded*}
% % \footnotesize
% % \noindent{\bf Reply from ChatGPT:} 
% % Let's simulate the execution of the provided Intel 64 machine code step by step to determine the values in register \texttt{\%esi}, memory location \texttt{rbp-0x34}, and memory location \texttt{rbp-0x3c} after the execution.

% % Assuming that the initial values of the relevant registers and memory locations are 0, here's the execution:
% % \begin{enumerate}
% % \item \texttt{mov DWORD PTR [rbp-0x34], 0xa} ~\textendash~ Moves the immediate value \texttt{0xa} into the memory location \texttt{[rbp-0x34]}.

% % Value at \texttt{[rbp-0x34]: 0x0000000a}
% % \item \texttt{mov DWORD PTR [rbp-0x38], 0x14} ~\textendash~ Moves the immediate value \texttt{0x14} into the memory location [rbp-0x38].
% % Value at \texttt{[rbp-0x38]: 0x00000014}
% % \item \texttt{mov esi, DWORD PTR [rbp-0x34]} ~\textendash~ Moves the double-word value from memory location \texttt{[rbp-0x34]} into the \texttt{\%esi} register.

% % Value in \texttt{\%esi: 0x0000000a}
% % \item \texttt{add esi, DWORD PTR [rbp-0x38]} ~\textendash~ Adds the double-word value from memory location [rbp-0x38] to the \texttt{\%esi} register.

% % Value in \texttt{\%esi: 0x0000001e (0x0a + 0x14 = 0x1e)}
% % \item \texttt{mov DWORD PTR [rbp-0x3c], esi} ~\textendash~ Moves the value in the \texttt{\%esi} register into the memory location \texttt{[rbp-0x3c]}.

% % Value at \texttt{[rbp-0x3c]: 0x0000001e}

% % \end{enumerate}

% % After the execution of the machine code, the final values are as follows:
% % \begin{enumerate}
% % \item Value in \texttt{\%esi: 0x0000001e}
% % \item Value at \texttt{[rbp-0x34]: 0x0000000a}
% % \item Value at \texttt{[rbp-0x3c]: 0x0000001e}
% % \end{enumerate}

% % \end{shaded*}


% This example shows that ChatGPT can precisely analyze the semantic of assemble code and track the dataflow. 
% In next step, we compile the \autoref{code:bubble} into binary code, and let the ChatGPT to infer the type of algorithms.

% \colorlet{shadecolor}{red!5}
% \begin{shaded*}
% \noindent{\bf Q16:} \textit{Please infer the type of the algorithm based on the assemble code of Intel-64 instruction set.}  \end{shaded*}
% \vspace{-2.5em}
% \colorlet{shadecolor}{green!5}
% \begin{shaded*}
% \setlength{\parindent}{0em}
% {\footnotesize 
%   \noindent{\bf Reply from ChatGPT:} 
% Based on the provided x86-64 assembly code, it's not immediately clear what type of algorithm is being implemented. The code appears to be a sequence of instructions without high-level constructs (e.g., loops, conditionals) that would typically help identify a specific algorithm or pattern.

% The code seems to involve memory operations, arithmetic operations, and conditional jumps based on the comparisons (cmp) and jumps (je, jne, jg, jle, etc.). However, without additional context or a higher-level understanding of the code's purpose and the data being processed, it is challenging to determine the exact algorithm or function being implemented.

% To infer the type of algorithm accurately, it would be helpful to have more information about the surrounding code, input data, and the expected output. If you have any additional context or specific information about the code's purpose or functionality, please provide it, and I'll do my best to help you further.
%   }\end{shaded*} 


% % \noindent{\bf Q16:} \textit{Please infer the type of the algorithm based on the assemble code of Intel-64 instruction set.}
% % \begin{shaded*}
% %     \footnotesize
% %     \noindent{\bf Reply from ChatGPT:} 
% % Based on the provided x86-64 assembly code, it's not immediately clear what type of algorithm is being implemented. The code appears to be a sequence of instructions without high-level constructs (e.g., loops, conditionals) that would typically help identify a specific algorithm or pattern.

% % The code seems to involve memory operations, arithmetic operations, and conditional jumps based on the comparisons (cmp) and jumps (je, jne, jg, jle, etc.). However, without additional context or a higher-level understanding of the code's purpose and the data being processed, it is challenging to determine the exact algorithm or function being implemented.

% % To infer the type of algorithm accurately, it would be helpful to have more information about the surrounding code, input data, and the expected output. If you have any additional context or specific information about the code's purpose or functionality, please provide it, and I'll do my best to help you further.
% % \end{shaded*}


% The response from ChatGPT suggests that it lacks the capability to directly analyze high-level semantics from binary code.
% Additionally, we inquired about vulnerability analysis and patching related questions ({\bf Q5, Q6, and Q7}) using the same program but in its binary representation.
% Unfortunately, ChatGPT was unable to answer any of these questions successfully.

