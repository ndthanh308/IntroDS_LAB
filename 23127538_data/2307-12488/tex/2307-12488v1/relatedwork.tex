\section{Related Works}
% \subsection{Crypto Function Detection}
% \label{sec:crypto}
% Crypto primitives can provide confidentiality, integrity, and availability which could be used by ransomware for malicious purposes. Crypto function detection techniques generally use static, dynamic, or network traffic information. Because crypto-ransomware is so common, various static and dynamic approaches frequently seek to identify cryptographic functions based on a thorough comprehension of the target algorithm.
{\bf Crypto Function Detection.} Crypto function detection is usually achieved by using static \cite{braga2019understanding,lestringant2015automated} or dynamic \cite{de2017kali,akbanov2018static,calvet2012aligot,xu2017cryptographic,li2012cipherxray,li2018k} analysis.
Static analysis often involves analysis of the constant values\cite{braga2019understanding}, the instruction chains, the data flow isomorphism\cite{lestringant2015automated}, and the API interface. Static analysis methods are usually fast and easy to use, which help developers to locate the crypto functions efficiently. In contrast, dynamic analysis methods usually aim to detect crypto functions that are obfuscated and disguised. Dynamic analysis involves tracing, and the crypto functions are then detected from the traces. Common strategies include data flow analysis \cite{li2018k} (\eg, \texttt{DDG}, \texttt{DFG}), heuristic (\eg, avalanche effect) based analysis \cite{li2012cipherxray, de2017kali, akbanov2018static}, and code similarity evaluation with existing known crypto functions \cite{calvet2012aligot, li2018k, xu2017cryptographic}.
% Crypto Detector\footnote{https://github.com/Wind-River/crypto-detector} aims to find crypto function in the source code. It assumes that source code contains a lot of information related to encryption algorithms. For example, most of the developers would like to use standard encryption algorithm so that it usually contains "DES" string which denotes a particular kind of encryption algorithm. After scanning all of the code, it gives us an initial idea whether the source code contains encryption. The next step is to search the content of each file for API calls to encryption libraries including files, encryption data types, and other evidence that might assure the use of encryption libraries. However, this detection criterion can be effectively bypassed. A magic constant, for example, can be disguised as the sum of two numbers and computed at runtime and static analysis is not effective when there is no source code available.

% Due to the downside of static analysis, researchers leverage dynamic evaluation techniques. \cite{de2017kali, akbanov2018static} traces this system execution at practice stage and detects the input-output relationships among viable pairs of crypto key, enter buffers, and/or output buffers. While this approach is resilient to some of the strategies that may idiot static detections, itself has numerous weaknesses. The maximum excessive trouble is, even though they mentioned the assets of avalanche effect, we discover that the operation of matrix calculation could satisfy their demands but is not a crypto function which cause a lot of false positives.

% \cite{calvet2012aligot} proposed a tool called Aligot to identify cryptographic functions retrieving their parameters, in a way that is basically impartial of the real implementation. It is not resilient to control-flow obfuscation and data flow obfuscation due to the absence of easily identifiable static features in obfuscated code. In order to get better performance in obfuscated programs, \cite{xu2017cryptographic} comes up with a novel Bit-precise symbol execution to detect a snippet of code that is identical in a crypto function. This effectively lowers the false positive, but it instead suffers the problem of slow detection speed using symbolic execution which run several iterations on a lot of loops.

% CipherXRay\cite{li2012cipherxray} is a unique binary analysis tool that uses the avalanche effect of cryptographic functions to effectively discover and recover cryptographic operations and temporary secrets from the execution of presumably obfuscated binary executables. It does, however, imply that all input, output, and cryptographic keys be held in continuous memory buffers, which attackers may easily circumvent. By examining program execution traces, k-hunt\cite{li2018k} discovers improperly produced keys, insecurely negotiated keys, and recoverable keys.

%\subsection{Ransomware Mitigation}
% A crypto ransomware is certain to have crypto functions, but there is currently no existing work focusing on detecting or preventing ransomware using information from crypto functions itself. 
{\bf Ransomware Mitigation.} Most existing works mitigate the ransomware threats using following 5 types of strategies: file analysis \cite{mehnaz2018rwguard, kharaz2016unveil, scaife2016cryptolock, lee2019machine, baek2018ssd, gomez2018rlocker}, system info analysis \cite{chen2017automated, zavarsky2016experimental}, API analysis \cite{mehnaz2018rwguard, al2020pseudo, javaheri2018detection, qin2020api, kok2019prevention}, instruction sequence analysis \cite{baldwin2018leveraging, khan2020digital}, and network traffic analysis \cite{almashhadani2019multi, cabaj2016using}.

%File analysis focus on the victim files themselves. System info analysis and API analysis focus on the ransomware behavior related to the operating system. Instruction sequence analysis focus on the binary code of the ransomware. Network traffic analysis focus on the communication with the C\&C server.


%\subsection{Deep-learning-assisted Program Analysis}
% Deep learning are used to conduct program analysis at both source code level and binary level. At source code level, most researchers represent the program using one of the three ways: sequences, trees, and graphs.
{\bf Deep-learning-assisted Program Analysis.} At source code level, previous works using sequences representations \cite{cummins2017end, feng2020codebert, guo2020graphcodebert} usually treat the program snippets similar to natural language corpus, adopting models such as transformers and LSTM. There are also works which use tree representation \cite{dam2018deep} focus on Abstract Syntax Tree (AST) by adopting tree-based LSTM models. Works adopting graph representations \cite{allamanis2017learning, zhou2019devign,liu2020retrieval, cummins2021programl} usually construct a composed graph,
% (based on AST), 
flow graphs and/or dependency graphs, followed by applying a GNN to solve the program analysis tasks.

At binary level,
%Nowadays, there are a lot of approaches using machine learning such as Natural Language Processing (NLP)\cite{allamanis2013mining, cummins2017end} to analyze programs. However, soon researchers found that not only the structure of program is very important, but also the semantics representations. Some work considers the semantic representations based on Abstract Syntax Tree (AST). In \cite{dam2018deep}, nodes in the AST are annotated with type information, and Tree-Based LSTMs are used to anticipate program defects. 
there are works such as Asm2Vec\cite{ding2019asm2vec} and PalmTree\cite{li2021palmtree} using DL models to learn representations from assembly/binary code sequences.

% The second line of researchers utilize Control Flow Graph (CFG) and Data Flow Graph (DFG) to learn embeddings of programs with the adaption of GNN. \cite{cummins2021programl} combine CFG, and DFG, which provides a compiler-level program representation with a range of use cases, from specialized program analysis to downstream optimization tasks.

% Another line is based on LLVM-IR statement. In IR2Vec\cite{srikant2019ir2vec}, part-of-statements are carefully modeled as relations using a statement representation that is particular to the LLVM-IR. But it needs access to the specific data flow analysis in order to calculate the value of embedding. Ben-Nun\cite{ben2018neural} proposes a contextual Flow Graph (XFG) for IR which consists of CFG and DFG.
