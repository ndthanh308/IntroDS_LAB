% \section{Terminologies}
\vspace{-0.5em}
\section{Literal Features and Logic Features}

% A source code file in a program consists of a sequence of strings, which can be grouped into three categories: keyword, operator, (both are defined in the programming language specification) and developer-defined name.
% Keywords are reserved words that have special meanings and can only be used for specific purposes.
% For example, \texttt{for}, \texttt{if}, and \texttt{break} are widely known keywords in many programming languages.
% They are used in a program to change the control flow.
% The number of keywords is limited in a programming language.
% For instance, \texttt{C} programming language has 32 keywords and \texttt{Python} (version 3.7) has 35 keywords.
% Besides keywords, a programming language needs to define a set of operators, representing operations and actions.
% For example, arithmetic operators (\eg, \texttt{+}, \texttt{-}, and \texttt{*}) and logical operators (\eg, \texttt{and}, \texttt{or}, and \texttt{not}) are two of most important categories.
% In addition, a developer can use any string to name a variable, structure, function, class, etc., as long as this string is not conflicted with reserved keywords and operators, and follows the programming language specification.

% When writing code, due to the program logic, the developer has limited flexibility to choose keywords and operators.
% Only some keywords (such as \texttt{for} and \texttt{while}) and operators (such as \texttt{++}, \texttt{+1}) are exchangeable.
% That is, the program logic is fixed when using a set of keywords and operators in a program.
% In contrast, the name of a variable, function, or class has no impact on the program logic.

% \lstset{style=mycstyle}
% \begin{lstlisting}[language=C++,
% emph={bubble_sort, begin, end, pred, it_end, finished, next, it},
% label={code:goodname},caption={A piece of code with meaningful variable/function names.}, captionpos=b]{}
%     void bubble_sort(It begin, It end, Pred pred=Pred()){
%         if ( std::distance( begin, end ) <= 1 ){ return; }
%         auto it_end    = end;
%         bool finished  = false;
%         while ( !finished ){ //loop stop when no adjacent elements are not in required order. 
%             ...
%         }   
%     }
% \end{lstlisting}


% \begin{lstlisting}[language=C++,
% emph={var1, var2, var3, var4, var5, var6, fun1, fun2},
% label={code:badname},caption={The same code without meaningful variable/function names.}, captionpos=b]{}
%     void fun1(It var1, It var2, Pred fun2=Fun2()){
%         if ( std::distance( var1, var2 ) <= 1 ){ return; }
%         auto var3  = var2;
%         bool var4  = false;
%         while ( !var4 ){
%             ...
%         }   
%     }
% \end{lstlisting}

% % \textcolor{red}{(Where is this bubble sorting function from? C++ standard library? Can we add some comments, i.e., programmer-readable annotation?)}
% \autoref{code:goodname} and \autoref{code:badname} are two pieces of code with the same program logic~\textendash~\textit{bubble sorting}.
% \autoref{code:goodname} is an implementation from the Web, which has well-named functions and variables whereas \autoref{code:badname} is anonymized by us. 
% Through a quick glance, even a novice can easily conclude that \autoref{code:goodname} is a bubble-sort function based on the help from the literal meaning of the function name and the variable names.
% However, it needs more time for an experienced analyst to go through this function line by line to understand the purpose of \autoref{code:badname}. 
% Therefore, despite the exactly same program logic, \autoref{code:badname} is much more difficult to analyze.
% In summary, although the name of a variable, function, or class has no impact on the program logic, it could also help the analyst to understand the purpose of a program if the literal meaning of the name aligns with the program logic.

% From the above discussion, we give the definition of literal features and logical features:

\begin{definition}[Literal Features and Logical Features]
Given a piece of code, the \textbf{literal features} are features of the literal meaning of the variable names, function names and programmer-readable annotation. These feature could be removed without change the functionality of the code. The \textbf{logical features} are features that control the program logic. The keywords and operators defined by a programming language specification are logical features.
\end{definition}

%Based on this definition, we can draw the following conclusions from our experiments:%. Two kinds of code snippets are analyzed: 
Based on this definition, we have the following observations:
1) code snippets can be understood in two ways: \textit{literal analysis}, and \textit{logic analysis};  2) the literal analysis makes a conclusion based on the names of variables, functions, etc., which is easier to analyze but is not always reliable; 3) the logic analysis requires a high-level understanding of the code, which is more reliable but hard to analyze.


