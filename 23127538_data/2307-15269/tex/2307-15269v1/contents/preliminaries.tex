
This section provides an overview of some fundamental concepts we utilize to describe our protocol. In particular, we revisit the asynchronous DAG-based BFT protocol design and the UTXO Model, which is the cornerstone of our proposal.

\subsection{Typical Asynchronous BFT Protocol Setting}

A BFT protocol typically proceeds in rounds involving multiple time slots and message exchanges. There are two types of participants: nodes and workers. Nodes participate in reaching distributed consensus by exchanging proposals with other nodes, while workers collect entries and deliver transaction batches to nodes. Each node has a reliable method for broadcasting messages~\cite{Bracha_Toueg_1985} and a uniform random coin for reaching consensus~\cite{Castro_Liskov_2002}. Furthermore, we assume the network is asynchronous, where messages between participants can take up to $\netdelay$ time slots to be received where $\netdelay$ is an unknown value. Each node knows the total number of participants and their identities, including their verification keys.


\subsection{DAG-based Asynchronous BFT Protocols}
These protocols are round-based distributed processes consisting of the DAG-making phase and the decision-making phase, as in~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}. Each node receives a batch of transactions from workers and generates a proposal for consensus with other nodes. The architecture of a node is depicted in Figure~\ref{fig_NT}. In the later sections, we denote the Narwhal DAG as DAG.
% Figure environment removed

More concretely, workers of a node will pack clients' transactions as batches and broadcast them to workers of other nodes using a Gossip Protocol, such as the one described in \cite{Bortnikov_2008}. Upon receiving enough responses from other workers, the worker sends the batch Id (i.e., hash values of underlying transactions) to its node. 

During the DAG-making phase of round $r$, the node aggregates the batch Id to create a proposal $P$ and $2f+1$ proposals' Id from round $r-1$. The node will use $P$ as input to initiate a Byzantine Reliable Broadcast (RBC)~\cite{LLRM_1982} instance. After this RBC instance is complete, the node stores $P$ in its Narwhal Memory Pool~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}. 

In the DAG-making phase, a node engages in at least $2f+1$ RBC instances and therefore stores $2f+1$ proposals. For proposals that contain unknown batches, the Narwhal asks the worker to synchronize the missing batches before continuing the RBC instance. The $2f+1$ stored proposals will be linked to its proposal in the next round. Thus, all proposals within Narwhal are stored as a round-based DAG, with an edge extending from one proposal to its $2f+1$ ancestors.

The DAG-based consensus algorithm chooses a sub-DAG from the Narwhal during the decision-making phase to fully utilize the results of the DAG-making phase. The Tusk consensus~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022} randomly chooses one leader every two rounds from $N$ nodes, based on a universally random coin toss, for being the candidate of a previous round's leader. If more than $f+1$ proposals link the selected candidate's proposal $L$, the protocol commits the sub-DAG linked by $L$. By leveraging a deterministic stable traversal algorithm, this $L$ uniquely determines the order of proposals within its sub-DAG, thereby dictating the output of the consensus algorithm.

Via the RBC instances, all honest nodes are assured of sharing an identical DAG eventually. If a leader's proposal from round $r$ has been referenced by $f+1$ proposals in round $r+1$, then the leader's proposal will always be in the sub-DAG of the leader of round $r+2$. Conversely, if a leader proposal receives less than $f+1$ followers, it may not be committed as a leader. This characteristic ensures the consistency of leader order and inherently verifies that the traversal of a DAG is deterministic. For a more detailed discussion, we refer the reader to the full work~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}.

Figure~\ref{fig_DC} illustrates an example of DAG: the leader at round $r-2$ is the proposal 3-4, which does not have enough following blocks at round $r-1$. Thus, it cannot be committed as a leader (alert marked). The leader proposal at round $r$ is proposal 1-3, with two following proposals, which can commit all proposals in its sub-DAG (check-marked) through a deterministic traverse algorithm.

% Figure environment removed

 It is worth noticing that each node will have different views of the DAG at each round. For example, in Figure~\ref{fig_DC}, node 1 and node 3 have a different view at round $r$ \ie, the sub-DAG that leads by proposals 1-6 and 3-6. We use the term ``observation'' to denote that a proposal or transaction is in such a local view, \ie, at round $r$, node 1 observes proposal 0-4 while node 3 does not.

\subsection{The UTXO Model}

The state of a UTXO-based ledger is represented by the set of UTXO that are tuples of the form $(b, s)$ where $b \in \mathbb{N}$ is a number of coins and $s \in \{0,1\}^*$ is a script describing the conditions of spending the UTXOs coins. A transaction consists of (1) a set of inputs that are references to UTXOs present on the ledger as well as witness data $w \in \{0,1\}^*$ and (2) a list of outputs that are newly defined UTXOs. A transaction is valid if (1) for each input it holds that $s(w) = \mathsf{TRUE}$ where $w$ is the input's witness, $s$ is the referenced UTXO's script, and $\mathsf{TRUE}$ is the Boolean logic value (2) the transaction cannot \textit{overspend}, \ie, the sum of coins in a transaction's outputs have to be less or equal than the sum of coins in the UTXOs referenced in the transaction's inputs and (3) all UTXOs referenced in the inputs have to exist in the ledger's state. If a transaction is successfully committed on a ledger, all UTXOs referenced in its inputs are removed from the ledger's state, and all UTXOs in its outputs are added to the ledger's state. Two transactions are \textit{conflicting} if at least one UTXO is referenced in both transactions' inputs.


The model rationale is that the user needs to consume the old data object (the existing ``outputs'', \ie the old data object, are used as ``inputs'' in new transactions) and create new ones (\ie the new ``outputs'' to be used in future transactions) to update a data object. The ledger's state is the set of all transaction outputs that have not been consumed yet by any transaction, hence ``UTXO''. The UTXO Model provides two properties: (1) A transaction in the UTXO Model tightly combines the inputs and outputs to trace each output back to the original output, and (2) UTXO allows one user to spend multiple valid UTXOs simultaneously,~\ie in parallel, as long as all are valid.

The validation of a transaction lies in two checks:
\begin{itemize}
\item \textbf{1. External validity}: Verify that all inputs are not spent; 
\item \textbf{2. Internal validity}: Verify whether the transaction is well-formed, all scripts with their witnesses evaluate to $\mathsf{TRUE}$, and the transaction does not overspend.
\end{itemize}

The worker can perform an internal validity check on the transaction and the existing TXO of its inputs. However, achieving external validity requires information on all transactions committed before executing this transaction. The outcome of the external check is settled after determining the order of transactions. The key feature of our proposal uses the UTXO result's independence. Thus, once the external check is confirmed, the transaction can be committed before the consensus algorithm commits the proposal.


\subsection{Notation}
Table~\ref{tab_notation} list the notations we used in this work:
\begin{table}[h!]
\centering
\caption{Table for notations}
\label{tab_notation}
\begin{tabular}{||c|p{0.7\linewidth}||} 
 \hline
 term & Description\\ [0.5ex] 
 \hline
 Tx & Short for a transaction, A digital exchange of value or information on the blockchain.\\
 \hline
 TXO & Short for transaction output, the minimum unit of information on the blockchain. It can only be created by one transaction and consumed by another transaction. \\
 \hline
 UTXO & Short for unspent transaction output, the TXO that is not consumed by other transactions.\\
 \hline
 Batch & A wrap of transactions for a consensus algorithm. \\
 \hline
 Proposal & A wrap of batches and other metadata that is proposed by a node for making consensus in the consensus algorithm.\\
 \hline
 Node & Process that participants of the consensus algorithm for the blockchain.\\
 \hline
 Worker & Process that collects transactions sent by clients and wraps them as a batch for nodes\\
 \hline
 Leader &  Leader is a pair of node IDs and rounds, the output of the DAG-based consensus. We abuse this notation for the corresponding proposal\\
 \hline
 $N$ & Number of nodes participants in the consensus algorithm \\ 
 \hline
 $f$ & Number of maximum allowed byzantine nodes, usually satisfying $3f+1\geq N$ 
 \\
 \hline
\end{tabular}
\end{table}