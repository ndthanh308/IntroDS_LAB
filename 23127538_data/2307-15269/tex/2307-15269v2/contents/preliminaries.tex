
This section provides an overview of some fundamental concepts we utilize to describe our protocol. In particular, we revisit the asynchronous DAG-based BFT protocol design and the UTXO Model, which are the cornerstones of our proposal.

\subsection{Typical Asynchronous BFT Protocol Setting}

A BFT protocol typically proceeds in rounds involving multiple time slots and message exchanges. There are two types of participants: nodes and workers. Nodes participate in reaching distributed consensus by exchanging proposals with other nodes, while workers collect entries and deliver transaction batches to nodes. Each node has a reliable method for broadcasting messages~\cite{Bracha_Toueg_1985} and a uniform random coin for reaching consensus~\cite{Castro_Liskov_2002}. Furthermore, we assume the network is asynchronous, where messages between participants can take up to $\netdelay$ time slots to be received where $\netdelay$ is an unknown value. Each node knows the total number of participants and their identities, including their verification keys.


\subsection{DAG-based Asynchronous BFT Protocols}
These protocols are round-based distributed processes consisting of the DAG-making and decision-making phases, as in~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}. Each node receives a batch of transactions from workers and generates a proposal for consensus with other nodes. The architecture of a node is depicted in Figure~\ref{fig_NT}. In the later sections, we denote the Narwhal DAG as DAG.
% Figure environment removed

More concretely, workers of a node will pack clients' transactions as batches and broadcast them to workers of other nodes using a Gossip Protocol, such as the one described in \cite{Bortnikov_2008}. Upon receiving enough responses from other workers, the worker sends the batch ID (i.e., hash values of underlying transactions) to its node. 

During the DAG-making phase of round $r$, the node aggregates the batch ID to create a proposal $P$ and $2f+1$ proposals' ID from round $r-1$. The node will use $P$ as input to initiate a Byzantine Reliable Broadcast (RBC)~\cite{LLRM_1982} instance. After this RBC instance is complete, the node stores $P$ in its Narwhal Memory Pool~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}. 

In the DAG-making phase, a node engages in at least $2f+1$ RBC instances and, therefore, stores $2f+1$ proposals. For proposals that contain unknown batches, the Narwhal asks the worker to synchronize the missing batches before continuing the RBC instance. The $2f+1$ stored proposals will be linked to its proposal in the next round. Thus, all proposals within Narwhal are stored as a round-based DAG, with an edge extending from one proposal to its $2f+1$ ancestors.

The DAG-based consensus algorithm chooses a sub-DAG from the Narwhal during the decision-making phase to fully utilize the results of the DAG-making phase. The Tusk consensus~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022} randomly chooses one leader every two rounds from $N$ nodes, based on a universally random coin toss for being the candidate of a previous round's leader. If more than $f+1$ proposals link the selected candidate's proposal $L$, the protocol commits the sub-DAG linked by $L$. By leveraging a deterministic stable traversal algorithm, this $L$ uniquely determines the order of proposals within its sub-DAG, thereby dictating the output of the consensus algorithm.

Via the RBC instances, all honest nodes are assured of sharing an identical DAG eventually. If a leader's proposal from round $r$ has been referenced by $f+1$ proposals in round $r+1$, then the leader's proposal will always be in the sub-DAG of the leader of round $r+2$. Conversely, if a leader proposal receives less than $f+1$ followers, it may not be committed as a leader. This characteristic ensures the consistency of leader order and inherently verifies that the traversal of a DAG is deterministic. For a more detailed discussion, we refer the reader to the full work~\cite{Danezis_Kokoris-Kogias_Sonnino_Spiegelman_2022}.

Figure~\ref{fig_DC} illustrates an example of DAG: the leader at round $r-2$ is the proposal 3-4, which does not have enough following blocks at round $r-1$. Thus, it cannot be committed as a leader (alert marked). The leader proposal at round $r$ is proposal 1-6, with two following proposals, which can commit all proposals in its sub-DAG (check-marked) through a deterministic traverse algorithm.
\ \\
% Figure environment removed

 It is worth noticing that each node will have different views of the DAG at each round. For example, in Figure~\ref{fig_DC}, node one and node three have different views at round $r$ \ie, the sub-DAG that leads by proposals 1-6 and 3-6. We use the term ``observation'' to denote that a proposal or transaction is in such a local view, \ie, at round $r$, node 1 observes proposal 0-4 while node 3 does not.

\subsection{The UTXO Model}

The state of a UTXO-based ledger is represented by the set of UTXO that contain some data $\delta \in \{0,1\}^*$ as well as a script $s \in \{0,1\}^*$. A transaction $t$ consists of (1) a set of inputs that are references to UTXOs present on the ledger as well as witness data $w \in \{0,1\}^*$ and (2) a list of outputs that are newly defined UTXOs. Moreover, the ledger can define constraints on UTXO $\psi_u$ and constraints on transactions $\psi_t$~\cite{Chakravarty_Chapman_2020}. A transaction is considered \textit{internally valid} if (1) for each of its inputs $i$ holds that $s_i(w_i, \delta_i, t) \neq \bot$ where $w_i$ is the inputs witness data and $s_i, \delta_i$ are the referenced UTXOs script and data; (2) for each UTXO $u$ in its outputs holds that $\psi_u(u) \neq \bot$ and (3) that $\psi_t(t) \neq \bot$. A transaction is considered \textit{externally valid} if all UTXOs referenced by its inputs are in the ledger's current state. When a transaction is successfully committed to the ledger, all UTXOs referenced in its inputs are removed from the ledger's state, and all UTXOs in its outputs are added to the ledger's state. Two transactions are \textit{conflicting} if at least one UTXO is referenced in both transactions' inputs.

Verifying whether a transaction can be committed to the ledger relies only on verifying \textbf{(1) External validity} and \textbf{(2) Internal validity}~\cite{EC:DGKR18}. We note that internal validity does not depend on the ledger's global state and can be verified immediately upon transaction creation. Moreover, while external validity requires knowledge of the ledger's state, i.e., which UTXOs are present, it only relies on a small subset of the UTXOs present on the ledger. Thus, the external validity of a set of non-conflicting transactions can be computed in \textit{parallel}. This inherent parallelism of UTXO-based ledgers is an advantage to other ledger paradigms and is particularly interesting to this work. 

\subsection{Notation}
Table~\ref{tab_notation} lists the notations we used in this work:
\begin{table}[h!]
\centering
\caption{Table for notations}
\label{tab_notation}
\begin{tabular}{||c|p{0.7\linewidth}||} 
 \hline
 term & Description\\ [0.5ex] 
 \hline
 Tx & Short for a transaction, A digital exchange of value or information on the blockchain.\\
 \hline
 TXO & Short for transaction output, the minimum unit of information on the blockchain. It can only be created by one transaction and consumed by another transaction. \\
 \hline
 UTXO & Short for unspent transaction output, the TXO that is not consumed by other transactions.\\
 \hline
 Batch & A wrap of transactions for a consensus algorithm. \\
 \hline
 Proposal & A wrap of batches and other metadata that is proposed by a node for making consensus in the consensus algorithm.\\
 \hline
 Node & Process that participants of the consensus algorithm for the blockchain.\\
 \hline
 Worker & Process that collects transactions sent by clients and wraps them as a batch for nodes\\
 \hline
 Leader &  Leader is a pair of node IDs and rounds, the output of the DAG-based consensus. We abuse this notation for the corresponding proposal\\
 \hline
 $N$ & Number of nodes participants in the consensus algorithm \\ 
 \hline
 $f$ & number of maximum allowed byzantine nodes, usually satisfying $3f+1\geq N$ 
 \\
 \hline
\end{tabular}
\end{table}