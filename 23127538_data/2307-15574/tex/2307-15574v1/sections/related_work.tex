%------------------------------------------------------------------------------
\section{Related Work and Motivation}
\label{sec:related}
%------------------------------------------------------------------------------
\noindent\textbf{\bf Previous Work and Limitations. }
Flexibility in XR workload distribution is not currently supported despite %There have been
extensive prior research and commercial solutions to offload XR functionalities on remote servers.
Table~\ref{tab:previoustech} summarizes a number of the existing technologies and what they support to be offloaded.
For VR, graphics operations are usually offloaded for providing realistic experiences via high-quality rendering.
Some studies make use of the characteristics of linear perspective in 3D graphics and split the foreground and background rendering to reuse a hardly changing background~\cite{lai2019furion, meng2020coterie}.
For AR, full and partial offloading of perception modules and graphics rendering have been explored~\cite{schneider2017augmented, liu2019edge, george2020openrtist}.
However, their benefits can be effective only in specific deployment contexts with their static workload distributions.

\begin{table}[t]
  \caption{\label{tab:previoustech} The existing technologies' server-side workloads of their distributed architectures.}
  \resizebox{\linewidth}{!}{
    \begin{tabular}{|l|c|c|c|}
      \hhline{====}
      \diagbox[width=17em]{Technologies}{Server-side Workload}                                          & Full Offloading        & Perceptions           & Application Rendering \\ \hline
      \begin{tabular}[c]{@{}l@{}} Marvel~\cite{chen2018marvel}         \end{tabular}                    &                        & \ding{51}             &                       \\
      \begin{tabular}[c]{@{}l@{}} Glimpse~\cite{chen2015glimpse}       \end{tabular}                    &                        & \ding{51}             &                       \\
      \begin{tabular}[c]{@{}l@{}} OpenRiST~\cite{george2020openrtist}  \end{tabular}                    & \ding{51}              &                       &                       \\
      \begin{tabular}[c]{@{}l@{}} ISAR~\cite{isar}      \end{tabular}                                   & \ding{51}              &                       &                       \\
      \begin{tabular}[c]{@{}l@{}} Furion~\cite{lai2019furion}       \end{tabular}                       &                        &                       & \ding{51}             \\
      \begin{tabular}[c]{@{}l@{}} Liu \emph{et al.}~\cite{liu2019edge} \end{tabular}                    &                        & \ding{51}             &                       \\
      \begin{tabular}[c]{@{}l@{}} Liu \emph{et al.}~\cite{liu2018cutting}      \end{tabular}            &                        &                       & \ding{51}             \\
      \begin{tabular}[c]{@{}l@{}} FireFly~\cite{liu2020firefly}       \end{tabular}                     &                        &                       & \ding{51}             \\
      \begin{tabular}[c]{@{}l@{}} Azure Custom Vision~\cite{azcustomvision}       \end{tabular}         &                        & \ding{51}             &                       \\
      \begin{tabular}[c]{@{}l@{}} Azure Remote Rendering~\cite{azremoterendering}       \end{tabular}   &                        &                       & \ding{51}             \\
      \begin{tabular}[c]{@{}l@{}} Nvidia CloudXRâ„¢~\cite{cloudxr}               \end{tabular}            &                        &                       & \ding{51}             \\
      \begin{tabular}[c]{@{}l@{}} Schneider \emph{et al.}~\cite{schneider2017augmented}   \end{tabular} & \ding{51}              &                       &                       \\
      \begin{tabular}[c]{@{}l@{}} Zhang \emph{et al.}~\cite{zhang2019rendering}    \end{tabular}        &                        &                       & \ding{51}             \\
      \hhline{====}
    \end{tabular}
  }
\end{table}

Flexibility is necessary because the complexities of XR workloads are not the same for each use case, \eg, AR or VR, and vary based on concrete algorithms and applications.
Figure~\ref{fig:workloads} shows the normalized execution time for the three different AR and VR applications used later in our evaluation.
They are chosen to represent XR use cases with different complexities, which incorporate different algorithms and application frameworks (more detail in \S\ref{sec:exampleapplications} and Figure~\ref{fig:examplefig}).
They run on NVIDIA Jetson AGX~\cite{jetsonagx} with 15W and 30W power modes, which corresponds to the client device in our testbed in \S\ref{sec:evaltestbed}.
These results show each use case has different complexities for its functionalities, and that the dominant functionality -- rendering or perception (or both) -- depends on the workload and the device capacity, making flexibility in offloading an important consideration in distributed XR.

% Figure environment removed

There have been prior works on flexible offloading to a remote server, but they have limited applicability for XR.
MAUI~\cite{cuervo2010maui} proposed fine-grained function offloading with the common language runtime (CLR) of the~.NET framework.
By having CLR on the client and server and requiring developers to specify offloadable functions in application codes, the functions are executed flexibly between the client and server.
CloneCloud~\cite{chun2011clonecloud} and ThinkAir~\cite{kosta2012thinkair} leveraged OS supports to migrate the execution context of threads running application functions to the server's virtual machines (VM);
the server VM provides an environment identical to the client, and the thread execution becomes migratable.

Although these techniques offer some flexibility, their benefit for distributed XR is limited.
In their design approach, devices interact with offloaded functions via client-server interfaces, and the application execution flow is preserved.
Since XR applications require the processing of multimedia data across multiple functionalities, this can introduce multiple network round trips and compromise the benefits of reduced processing time due to offloading.
In addition, preserving the execution flow limits the opportunities to achieve task parallelism.
ThinkAir~\cite{kosta2012thinkair} provides parallelism by cloning VMs, but allows only for data parallelism.
Lastly, since these systems run the application codes on a server with the same environment as the client, they
cannot benefit from 
hardware resources only available on the server.


Offloading XR functionalities requires additional operations such as data compression and network transmissions.
When distributing XR workloads, both overheads from those auxiliary operations and the costs of the XR functionalities should be considered.
Flexibility in reconfiguration thus requires not just techniques which provide transparent function offload, but also systems support to properly configure and deploy the auxiliary functionality.

\noindent\textbf{\bf Motivation for \sys. }
These observations motivate us to build \sys\ based on the stream processing (SP) design.
SP structures an application as a pipeline of components and provides modularity and task parallelism to the application.
A pipeline component (a compute kernel) is the implementation of a functionality.
Kernels are pipelined via data communication ports and executed in parallel with dataflow.
The ports are used to transmit the input and output between the connected kernels.
This modularity makes SP extensible to distributed stream processing (DSP) in a straightforward manner; kernels can be connected via remote communication ports.
Additionally, SP provides an advantage in heterogeneous server environments~\cite{roger2019combining} since kernels can be specialized to utilize available heterogeneous resources such as hardware accelerators.
