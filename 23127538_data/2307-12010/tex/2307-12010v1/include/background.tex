\section{Background}\label{sec:background}
In this section, we describe the face recognition algorithm and introduce the encoding method for a given matrix. Then we present some cryptographic primitives we use.

\subsection{Face Recognition}
In a face recognition system, each face image is represented by a feature vector, we say a face vector.
%there is a database $\boldsymbol{\mathsf{A}} = \{\boldsymbol{a}_0, \boldsymbol{a}_1,...,\boldsymbol{a}_{m-1}\} \in \mathbb{Z}_t^{m\times d}$ extracted from the face images of the enrolled entities, which contains $m$ features and each feature is represented with an $d$-dimensional vector.{Do you mean the database contains m images and each image is represented with a d-dim features? Is the database static, or we can add or delete the database dynamically?}. \notejbai{We suppose we can add but not delete since the database in our scenario is uploaded by DPs before the verifier queries.} 
The extraction algorithm usually consists of face detection, alignment, normalization, and feature extraction, which is out of the scope of this work. 
We assume the face vector of each image is ready to use. 
In fact, the face vector extracted from the facial images of the same person could be slightly different. 
Thus, for face recognition, we should compare the similarity between two face vectors rather than check the equality. 
%A verifier with an extracted facial vector $\boldsymbol{b} \in \mathbb{Z}^{d}$ wishes to query whether the vector exists in the database. 
A simple method is to use either the Euclidean distance~\cite{danielsson1980euclidean} or the cosine similarity~\cite{singhal2001modern} to measure the similarity between two face vectors. 
In this paper, we employ cosine similarity. 
Specifically, given two vectors $\tilde{\boldsymbol{a}}=(\tilde{a}^0, ..., \tilde{a}^{d-1}) \in \mathbb{Z}^{d}$ and $\tilde{\boldsymbol{b}} =(\tilde{b}^0, ..., \tilde{b}^{d-1})\in \mathbb{Z}^{d}$, their cosine similarity is $d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}})  =\frac{\sum_{i=0}^{d-1} {{\tilde{a}}^i {\tilde{b}}^i}}{\sqrt{\sum_{i=0}^{d-1} {{(\tilde{a}^i)}^2}} \sqrt{\sum_{i=0}^{d-1} {(\tilde{b}^i)^2}}}$.
%
% \begin{equation}\label{equation:originaldistance}
% d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}}) 
% =\frac{\sum_{i=0}^{d-1} {{\tilde{a}}^i {\tilde{b}}^i}}{\sqrt{\sum_{i=0}^{d-1} {{(\tilde{a}^i)}^2}} \sqrt{\sum_{i=0}^{d-1} {(\tilde{b}^i)^2}}}.
% \end{equation}
%
By setting $a^i=\frac{\tilde{a}^i}{\lVert \tilde{\boldsymbol{a}} \rVert}$ and $b^i=\frac{\tilde{b}^i}{\lVert \tilde{\boldsymbol{b}} \rVert}$, which are the normalization representations, we can convert it to $d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}}) 
=\sum_{i=0}^{d-1} {a}^i b^i$. 
% \begin{equation}\label{equation:distance}
% d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}}) 
% =\sum_{i=0}^{d-1} {a}^i b^i
% \end{equation}
By doing so, $d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}})$ can be considered as the inner product of vector $\boldsymbol{a}=(a^0$, ..., $a^{d-1})$ and $\boldsymbol{b}=(b^0, ..., b^{d-1})$. %, where $\boldsymbol{a}=\frac{\tilde{\boldsymbol{a}}}{\lVert \tilde{\boldsymbol{a}}\rVert}$ and $\boldsymbol{b}=\frac{\tilde{\boldsymbol{b}}}{\lVert \tilde{\boldsymbol{b}}\rVert}$ and 
Note that $a^i$ and $b^i$ can be pre-computed offline. 
A larger value of $d(\tilde{\boldsymbol{a}},\tilde{\boldsymbol{b}})$ means higher similarity between $\tilde{\boldsymbol{a}}$ and $\tilde{\boldsymbol{b}}$, and if it is greater than a threshold value, we say $\tilde{\boldsymbol{a}}$ and $\tilde{\boldsymbol{b}}$ matches with each other, \ie, they represent the same person. In the following of this paper, all the face vectors are normalization representations. 
%When a verifier wants to query for a face vector $\tilde{\boldsymbol{b}}$, he also generates its normalization representation as  and sends its corresponding ciphertext to CS. This conversion helps the CS to get rid of expensive division computation over homomorphic encryption~\cite{veugen2014encrypted} in Equation \ref{equation:originaldistance}, thus CS is only required to perform homomorphic multiplication as in Equation \ref{equation:distance}, which is cheaper. Up to here, we transfer the computation of cosine similarity between two vectors to a dot product given the pre-computed normalization representations. In the following, we will discuss how to efficiently compute a dot product between two vectors when there are multiple vectors.



% \rewrite{
% \begin{definition}[Security Definition]
% \label{Def:security}
% 	Let $\Pi$ be a two-party protocol for computing a functionality $f$. We say that $\Pi$ securely computes $f$ in the presence of semi-honest adversaries if there exists a probabilistic polynomial-time simulator $\mathcal{S}$ such that for every polynomial-size input $\mathcal{E} = \{ \mathcal{E}_{\lambda}\}$, the view of real word $REAL_{\Pi,\mathcal{A},\mathcal{E}}(\lambda)$ and the view of ideal world $IDEAL_{f,\mathcal{S},\mathcal{E}}(\lambda)$ is computationally distinguishable. 
%  \end{definition}
% \begin{align*}
%     REAL_{\Pi,\mathcal{A},\mathcal{E}}(\lambda) \overset{c}{\equiv} IDEAL_{f,\mathcal{S},\mathcal{E}}(\lambda).
% \end{align*}

% }

\subsection{Encoding Method} 
Given a set of encrypted face vectors, computing the cosine similarity one by one is time-consuming. A promising method is computing that in parallel. 
The encoding method from Cheetah~\cite{huang2022cheetah} achieves the best paralleling performance. In the following, we briefly describe the encoding method in Cheetah~\cite{huang2022cheetah}.

%\notescui{why don't we perform A*b over encrypted version directly? Which can also be processed in parallel, right? What's the advantage of computing psi(A)*psi(b) compare with A*B? Is that because for using BFV the plaintext must be a polynomial?} \notejbai{Answer: We want to perform A*b over the encrypted version directly. It can work by one-by-one computation but with high computation overhead. So the challenge is how we encrypt the matrix while ensuring the correctness of computation. It seems it only can be achieved by using HE. The point is the plaintext of BFV is a polynomial with N slots. For example, we can use one polynomial to represent one face vector. We also can use one polynomial to represent multiple $N-d/d$ face vectors if we give a suitable encoding method.}

% We follow the same encoding strategy from Cheetah~\cite{huang2022cheetah}, which we do not claim novelty. }
Given a matrix $\boldsymbol{\mathsf{A}}= \{\boldsymbol{a}_0, \boldsymbol{a}_1,...,\boldsymbol{a}_{\tilde{m}-1}\} \in \mathbb{Z}^{\tilde{m} \times d}$ with $\tilde{m}$ rows and $d$ columns, where $\boldsymbol{a}_i=(a_i^0, ..., a_i^{d-1})$ and $0 \leq i \leq \tilde{m}-1$, it can be represented into a polynomial as 
\begin{footnotesize}
\begin{align*}
\pi(\boldsymbol{\mathsf{A}}) &= a_0^{d-1}X^0+a_0^{d-2}X^1+\cdots+a_0^0X^{d-1}\\
&+a_1^{d-1}X^{d}+a_1^{d-2}X^{d+1}+\cdots + a_1^0X^{2d-1} + \\
&\cdots\\
&+a_{\tilde{m}-1}^{d-1}X^{(\tilde{m}-1)d}+a_{\tilde{m}-1}^{d-2}X^{(\tilde{m}-1)d+1}+\cdots+ a_{\tilde{m}-1}^0X^{\tilde{m}d-1}.
\end{align*}
\end{footnotesize}

\noindent Given another polynomial
$\pi(\boldsymbol{b}) = b^0X^0+b^1X^1+\cdots+b^{d-1}X^{d-1}$, we can get polynomial $\pi(\boldsymbol{\mathsf{d}})$ by computing  $\pi(\boldsymbol{\mathsf{d}}) \leftarrow \pi(\boldsymbol{\mathsf{A}})*\pi(\boldsymbol{b})$, where $*$ denotes polynomial multiplication. It is notable that the coefficient of degree $X^{(i+1)d-1}$, where $i \in [0,\tilde{m}-1]$ in polynomial $\pi(\boldsymbol{\mathsf{d}})$ forms the dot product result of the $i$-th row vector from $\boldsymbol{\mathsf{A}}$ and the vector $\boldsymbol{b}$. 
% \notejbai{In our design, each row in the matrix $\boldsymbol{\mathsf{A}}$ represents a face vector. That is, before encrypting and uploading the face vectors to CS, DP encodes them into a matrix $\boldsymbol{\mathsf{A}}$ and then transforms it into the polynomial $\pi(\boldsymbol{\mathsf{A}})$. We call this process encoding. Then DP encrypts this polynomial using BFV as $ct_i$ and sends it to CS. The verifier encrypts the queried face vector $\boldsymbol{b}$ as $ct$ and sends it to CS. The cosine similarity is computed by multiplying these two ciphertexts $ct_i$ and $ct$, whose underlying plaintext polynomial is exactly $\pi(\boldsymbol{\mathsf{W}})$.}
The correctness comes from the fact that the elements order of each vector in matrix $\boldsymbol{\mathsf{A}}$ is revised when it is encoded into a polynomial. 
%For simplicity, we give a toy example of a small matrix $\boldsymbol{\mathsf{A}} \in \mathbb{Z}^{2\times 3}$ multiplies with a vector $\boldsymbol{b} \in \mathbb{Z}^{2}$ as shown in Fig \ref{fig:toyexample}. 
We refer readers to Cheetah~\cite{huang2022cheetah} to see the detailed proof of correctness. 

% \notescui{What are the benefits of using such encoding method? Or why is it necessary?}


\subsection{Homomorphic Encryption}
HE~\cite{acar2018survey} allows us to compute over encrypted data where the result is indeed the encrypted version of the operations on the plaintext. In this work, we use a lattice-based HE: ring learning with errors~(RLWE)-based HE called BFV~\cite{fan2012somewhat}. We briefly describe the construction of BFV scheme. See~\cite{fan2012somewhat} for a detailed formal description and security definition.

% \noindent \textbf{Homomorphic addition.}
% Given two RLWE-based ciphertexts $c = RLWE_{pk}(m)$ and $c' = RLWE_{pk}(m')$, then $c_{add} = c\boxplus c' = RLWE_{pk}(m+m')$.

% \noindent \textbf{Homomorphic multiplication.}
% Given two RLWE-based ciphertexts $c = RLWE_{pk}(m)$ and $c' = RLWE_{pk}(m')$, then $c_{mul} = c \boxtimes c' = RLWE_{pk}(m \times m')$.

\noindent \textit{BFV Scheme}. 
The plaintext space of BFV scheme is taken from $R_t = \mathbb{Z}_t/(x^N+1)$ which represents polynomials with degree less than $N$ where $N$ is a power of 2, with the coefficients modulo $t$. Similarly, the ciphertext is defined in a ring $R_q$ with the coefficients modulo $q$. We use symbols $\boxplus$ and $\boxtimes$ to represent homomorphic addition and homomorphic multiplication, respectively. The BFV scheme consists of the following algorithms:
\begin{itemize}
    \item  $(pk,sk) \leftarrow$ KeyGen($1^\lambda$): On input the security parameter $\lambda$, it generates a pair of keys $(pk,sk)$.
    % $(sk,pk,rlk) \leftarrow$ KeyGen($1^\lambda$): On input the security parameter $\lambda$, it generates a pair of keys $(sk,pk)$ and additionally generates a relinearization key $rlk$ for homomorphic multiplication.
    \item  $ct \leftarrow$ Encrypt($pk,\boldsymbol{m}$): On input the public key $pk$ and the plaintext $\boldsymbol{m}$, it outputs the ciphertext $ct$. 
    \item  $\boldsymbol{m} \leftarrow$ Decrypt($sk,ct$): On input the secret key $sk$ and the ciphertext $ct$, it outputs a plaintext $\boldsymbol{m}$.
    \item Eval($ct_i,ct_j$): Given two ciphertexts $ct_i$ and $ct_j$, output a ciphertext corresponding to the following operation.
        \begin{itemize}
        \item[-] Eval.Add($ct_i$,$ct_j$): Output $ct \leftarrow ct_i \boxplus ct_j$. 
        \item[-] Eval.Mul($ct_i$,$ct_j$): Output $ct \leftarrow ct_i \boxtimes ct_j$. 
        \end{itemize}
    % \item Eval($ct_1,\cdots,ct_k$): given ciphertexts $ct_1,\cdots,ct_k$, output a ciphertext according to operation.
        % \begin{itemize}
        % \item[-] Eval.Add($ct_i$,$ct_j$): On input two ciphertexts $ct_i$ and $ct_j$, it outputs $ct \leftarrow ct_i \boxplus ct_j$. 
        % \item[-] Eval.Mul($ct_i$,$ct_j$): On input two ciphertexts $ct_i$ and $ct_j$, it outputs $ct \leftarrow ct_i \boxtimes ct_j$. 
        % \end{itemize}
\end{itemize}


% The notations $\lceil x \rceil$, $\lfloor x \rfloor$ and $\lfloor x \rceil$ denote rounding up, down and to the nearest integer, respectively.

% \noindent \textbf{BFV Scheme~\cite{fan2012somewhat}.}
% The plaintext message space of BFV scheme is taken from $R_t = \mathbb{Z}_t/(x^N+1)$ which represents polynomials with degree less than $N$ where $N=2^n$ with the coefficients modulo $t$. Similarly, the ciphertext is defined in a ring $R_q$ with the coefficients modulo $q$. 
% The notations $\lceil x \rceil$, $\lfloor x \rfloor$ and $\lfloor x \rceil$ denote rounding up, down and to the nearest integer, respectively. 
% The BFV scheme consists of the following algorithms:

% \begin{itemize}
%     % \item Setup: 
%     \item KeyGen($1^\lambda$): Sample $\boldsymbol{s} \leftarrow \chi$ and set $\boldsymbol{sk} = \boldsymbol{s}$, sample $\boldsymbol{a} \leftarrow R_q, \boldsymbol{e} \leftarrow \chi$ and set $pk = (\boldsymbol{pk[0]},\boldsymbol{pk[1]})$ where $\boldsymbol{pk[0]} = [-(\boldsymbol{a} \cdot \boldsymbol{s}+\boldsymbol{e})]_q$ and $\boldsymbol{pk[1]}=\boldsymbol{a}$, Sample $\boldsymbol{a_i} \leftarrow R_q, \boldsymbol{e_i} \leftarrow \chi$ and output the relinearization key $$\boldsymbol{rlk} = [([-(\boldsymbol{a_i} \cdot \boldsymbol{sk}) + \zeta^i \cdot \boldsymbol{sk}^2]_q, \boldsymbol{a_i}):i \in [0,\cdot \cdot \cdot, l])]$$
%     where $\zeta$ is the chosen base and $l = \lfloor log_{\zeta}(q)\rfloor$.
%     \item Encrypt($pk,\boldsymbol{m}$): Given $\boldsymbol{pk}$ and $\boldsymbol{m} \leftarrow R_t$, sample $\boldsymbol{u},\boldsymbol{e_0},\boldsymbol{e_1} \leftarrow \chi$, output the ciphertext $ct = (\boldsymbol{ct[0]},\boldsymbol{ct[1]})$ where $\boldsymbol{ct[0]}= [\boldsymbol{pk[0]} \cdot \boldsymbol{u} + \boldsymbol{e_0} +\Delta \cdot \boldsymbol{m}]_q$ and $\boldsymbol{ct[1]}=[\boldsymbol{pk[1]} \cdot \boldsymbol{u} + \boldsymbol{e_1}]_q$.
%     \item Decrypt($\boldsymbol{sk},\boldsymbol{ct}$): Given $\boldsymbol{sk}$ and $\boldsymbol{ct}$, compute $$[\lfloor \frac{t \cdot [\boldsymbol{ct[0]}+\boldsymbol{ct[1]} \cdot \boldsymbol{s}]_q}{q}\rceil]_t.$$
%     \item Eval($\boldsymbol{ct_1},\cdot \cdot \cdot, \boldsymbol{ct_k}$): Given a set of ciphertexts $\boldsymbol{ct_1},\cdot \cdot \cdot, \boldsymbol{ct_k}$, output a ciphertext according to operation.
%     \begin{itemize}
%         \item[-] Eval.Add($\boldsymbol{ct_1}, \boldsymbol{ct_2}$): Return $$([\boldsymbol{ct_1[0]}+\boldsymbol{ct_2[0]}]_q,\boldsymbol{[ct_1[1]}+\boldsymbol{ct_2[1]}]_q)$$
%         \item[-] Eval.Mul($\boldsymbol{ct_1}, \boldsymbol{ct_2}$,$\boldsymbol{rlk}$): Compute 
%         $$
%         \boldsymbol{c_0} = [\lfloor \frac{t \cdot (\boldsymbol{ct_1[0]} \cdot \boldsymbol{ct_2[0])}}{q}\rceil]_q
%         $$
%         $$
%         \boldsymbol{c_1} = [\lfloor \frac{t \cdot (\boldsymbol{ct_1[0]} \cdot \boldsymbol{ct_2[1] + \boldsymbol{ct_1[1]} \cdot \boldsymbol{ct_2[0]})}}{q}\rceil]_q
%         $$
%         $$
%         \boldsymbol{c_2} = [\lfloor \frac{t \cdot (\boldsymbol{ct_1[1]} \cdot \boldsymbol{ct_2[1])}}{q}\rceil]_q
%         $$
%         and write $\boldsymbol{c_2}$ in base $\zeta$ as $\boldsymbol{c_2} = \sum_{i=0}^l\boldsymbol{c_2}^{(i)}\zeta^i$,
%         set
%         $$
%         \boldsymbol{ct[0]}'=[\boldsymbol{c_0}+\sum_{i=0}^l rlk[i][0] \cdot \boldsymbol{c_2}^{(i)}]_q
%         $$
%         and 
%         $$
%         \boldsymbol{ct[1]}'=[\boldsymbol{c_1}+\sum_{i=0}^l rlk[i][1] \cdot \boldsymbol{c_2}^{(i)}]_q
%         $$
%         and return $(\boldsymbol{ct[0]}',\boldsymbol{ct[1]}')$.
%     \end{itemize}
% \end{itemize}
\subsection{Key-switching}
Key-switching enables the data encrypted by one set of encryption keys to be re-encrypted by another without decrypting the data. BFV scheme~\cite{fan2012somewhat} naturally supports the key-switching operation.
%if the party can get the key-switching key corresponding to the former and new encryption keys. 
The key-switching process consists of two algorithms:
\begin{itemize}
    \item $k_{A\rightarrow B} \leftarrow $ SwKeyGen($sk_A, sk_B$): On input two BFV secret keys $sk_A, sk_B$, it outputs a key-switching key $k_{A\rightarrow B}$.
    \item $ct_B \leftarrow$ Switching($ct_A,k_{A\rightarrow B}$): On input a key-switching key $k_{A\rightarrow B}$ and a ciphertext $ct_A$ encrypted by a public key $pk_A$ associated with $sk_A$, it outputs a ciphertext $ct_B$ encrypted by a public key $pk_B$ associated with $sk_B$.
\end{itemize}
More details about the key-switching technique can be found in~\cite{kim2021revisiting}.



% % Figure environment removed




\subsection{Secret Sharing} 
For an $l$-bit value $x \in \mathbb{Z}_{2^l}$, we use $\boolshare{x}^A$ to denote $x$ is arithmetically shared between parties $P_0$ and $P_1$ where $P_0$ holds $x_0^A$ and $P_1$ holds $x_1^A$ such that $x = x_0^A + x_1^A$ with $x_0^A$, $x_0^A \in \mathbb{Z}_{2^l}$. Similarly, $\boolshare{x}^B$ denotes a boolean share of $x$ where $x = x_0^B \oplus x_1^B$ with $x_0^B$, $x_0^B \in \mathbb{Z}_{2^l}$. Note that each share itself does not reveal any information about $x$. In some cases, we need the conversion between different sharing formats. 
We use the $\textbf{B2A}$ technique to convert $x$ from its boolean sharing $\boolshare{x}^B$ to its arithmetic sharing $\boolshare{x}^A$, which we represent as $(x_0^A, x_1^A) \leftarrow$ B2A$(x_0^B,x_1^B)$.
The detailed $\textbf{B2A}$ conversion can be referred to~\cite{demmler2015aby}. 
If $\boldsymbol{x}$ is a vector, then $\boldsymbol{x} = \boldsymbol{x}^A_0 + \boldsymbol{x}^A_1$ means each element in the vector is additionally shared between two parties. In our design, the cloud server (CS) plays the role of $P_0$, and the verifier plays the role of $P_1$.

\subsection{Secure Comparison} 
Secure comparison, also known as Millionaire's problem~\cite{yao1986generate}, compares two integers held by two parties. The inputs contain $x$ from one party and $y$ from another party, and the output bit 1 or 0 is shared between the two parties. Cryptflow2~\cite{rathee2020cryptflow2} proposes an efficient comparison protocol based on the observation: assume $x=x_1||x_0$ and $y=y_1||y_0$, we must have $x<y$ either when $x_1=y_1$ and $x_0<y_0$ or when $x_1<y_1$, \ie, $\bold{1}\{x<y\}=(\bold{1}\{x_1=y_1\}\wedge \bold{1}\{x_0<y_0\}) \oplus \bold{1}\{x_1<y_1\}$\footnote{$\bold{1}\{condition\}$ and $\bold{0}\{condition\}$ mean the condition is true and false, respectively.}. By separating the binary represented values into small parts, the queried Oblivious Transfer (OT)~\cite{ishai2003extending} is also small, optimizing the communication cost.
% The total communication for comparing two values in $\{0,1\}^l$ is less than $\lambda+14l$ where $\lambda$ is a security parameter and the rounds is log$l$. 
Recently, Cheetah~\cite{huang2022cheetah} provides further optimization by replacing the underlying secure AND implementation with Random OT (ROT)~\cite{ishai2003extending} generated Beaver Triples~\cite{beaver1992efficient}. For simplicity, we represent secure comparison as $(b_0,b_1)\leftarrow$ SC$_{lt}(x,y)$ which means one party inputs $x$ and another party inputs $y$ and outputs $b=1$ if $x<y$ and $b=0$ otherwise, where $b = b_0 \oplus b_1$. For more details about the state-of-the-art secure comparison, please refer to ~\cite{huang2022cheetah,rathee2020cryptflow2}. 
