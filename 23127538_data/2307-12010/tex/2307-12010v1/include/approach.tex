\section{CryptoMask Details} \label{sec:approach}
This section describes the enrollment and evaluation processes of CryptoMask in detail. 

%In a real scenario, the encrypted data stored on CS is received from a group of DPs and this process is called~\textit{enrolment}. A verifier queries the database about the existence of a given face image by performing a secure face recognition~\textit{evaluation} with CS. In this paper, we intend to make the enrolment and evaluation processes efficient and ensure the participants learn only what they are allowed to learn. 

\subsection{Our Encoding Method}
BFV scheme~\cite{fan2012somewhat} is designed to work on a polynomial ring $R_t = \mathbb{Z}_t/(x^N+1)$ with degree $N$. 
The observation is that the number of slots in a polynomial (\eg, 4096) is far more than the dimension of a face vector (\eg, $d=128$). Thus, we can employ one polynomial to represent multiple face vectors as done in Cheetah~\cite{huang2022cheetah}. 
In our design, each row in the matrix $\boldsymbol{\mathsf{A}}$ represents a face vector. That is, before encrypting and uploading the face vectors to CS, DP encodes them into a matrix $\boldsymbol{\mathsf{A}}$ and then transforms it into the polynomial $\pi(\boldsymbol{\mathsf{A}})$. 
% We call this process encoding. 
Then DP encrypts this polynomial using BFV as $ct_i$ and sends it to CS. The verifier encrypts the queried face vector $\boldsymbol{b}$ as $ct$ and sends it to CS. The cosine similarity is computed by multiplying these two ciphertexts $ct_i$ and $ct$, whose underlying plaintext polynomial is exactly $\pi(\boldsymbol{\mathsf{d}})$.
As mentioned, the plaintext space of BFV scheme is taken from $R_t = \mathbb{Z}_t/(x^N+1)$, which means the maximum degree of a plaintext polynomial is $N$. The direct method is we fill all the coefficients slots in the plaintext polynomial when considering encoding our face vectors database. However, this might result in a loss of valid similarity.
The reason is that the valid value in the product will be dropped~(module reduced to a position with a degree less than $N$) if its associated degree is greater than $N$, which means we will get the wrong distance between the last face vector in the matrix and the queried image. Our idea is to leave the last $d$ positions in the polynomial $\pi(\boldsymbol{\mathsf{A}})$ for “buffer” use and set their coefficients as 0. Thus, all valid values will be presented as coefficients with degrees less than $N$.
That is, if the degree of a plaintext polynomial is $N$, we only encode its lower $N-d$ coefficients and leave the higher $d$ coefficients as zeros. A similar strategy applies to the queried face vector.
% The reason is that this polynomial will be multiplied by another polynomial whose lower $d$ coefficients represent the queried face image, and higher $N-d$ coefficients are set to zeros.
Using this encoding method, the concrete number of ciphertext for $m$ face vectors with dimension $d$ will be $\lceil \frac{md^2}{N-d} \rceil$.

%\notescui{Give an example or formal formula to make it more clear}
%\notejbai{It is hard to present here as an example. The reviewer asks example for the relationship between polynomial and matrix. he said "I agree that by such encoding of the vectors in the database as well as the query vector, by two polynomials, we can multiply the two polynomials and then a SUBSET of the coefficients in the product polynomial will reveal the dot product of the query vector with each of the database vectors. But that is an example of too much work left for the reader – the authors must write clearly what they meant."}



% \begin{algorithm}[tb]
%     \caption{Secure enrolment}
%     \label{alg:enrolment}
%     \textbf{Input}: An indicator $ind$ and the last ciphertext $ct_{la}$ from CS; $n_u$ $d$-dimensional face vectors $\boldsymbol{\mathsf{V}} = \{\boldsymbol{a}_0,\cdots, \boldsymbol{a}_{n_u-1}\} \in \mathbb{Z}^{n_u\times d}$ and public key $pk$ from DP.\\
%     \textbf{Parameter}: $\delta =  \lceil \frac{N-d}{d} \rceil$ where $N$ is the plaintext polynomial degree.\\
%     \textbf{Output}: CS adds the encrypted face vectors to the database.
    
%     \begin{algorithmic}[1] %[1] enables line numbers
%         \STATE DP informs CS to add new face vectors. CS sends the indicator $ind$ to DP.
		
% 		\STATE DP takes $\delta-ind$ face vectors and organizes them into a matrix $\boldsymbol{\mathsf{A}} \in \mathbb{Z}^{\delta \times d}$ by padding $ind$ zero vectors before these real samples. Then DP represents the matrix into a polynomial as $\pi(\boldsymbol{\mathsf{A}})$ and gets $ct_0 \leftarrow$  Encrypt$(pk,\pi(\boldsymbol{\mathsf{A}}))$.
		
% 		\STATE DP separates the remaining vectors into $e\delta$ vectors and remains $f$ vectors where $f < \delta$ and $n_u = \delta -ind + e \delta + f$. Then DP constructs $e$ matrices using $e\delta$ face vectors and encrypts them using BFV Encrypt() as $\{ct_1,\cdots, ct_e\}$.
		
% 		\STATE DP pads $\delta -f$ zero vectors to the remaining vectors and encrypts as $ct_{e+1}$ using encoding method. Then DP sets the indicator as $ind = \delta -f$.
		
% 		\STATE DP uploads $\{ct_0,\cdots,ct_{e+1} \}$ and indicator $ind$ to CS.
		
% 		\STATE After receiving the ciphertexts, CS first updates the indicator $ind$ and saves $\{ct_1,\cdots,ct_{e+1} \}$. Then CS updates $ct_{la}$ by performing Eval.Add($ct_{la},ct_0$). 
%     \end{algorithmic}
% \end{algorithm}

\begin{algorithm}[tb]
    \footnotesize
    \caption{Secure enrolment}
    \label{alg:enrolment}
    \textbf{Input}: An indicator $ind$ and the last ciphertext $ct_{la}$ from CS; $n_u$ $d$-dimensional face vectors $\boldsymbol{\mathsf{V}} = \{\boldsymbol{a}_0,\cdots, \boldsymbol{a}_{n_u-1}\} \in \mathbb{Z}^{n_u\times d}$ and public key $pk$ from DP.\\
    \textbf{Parameter}: $\delta =  \lceil \frac{N-d}{d} \rceil$ where $N$ is the plaintext polynomial degree.\\
    \textbf{Output}: CS adds the encrypted face vectors to the database.
    
    \begin{algorithmic}[1] %[1] enables line numbers
        \STATE DP informs CS to add new face vectors. CS sends $ind$ to DP.
		
		\STATE DP takes $\delta-ind$ face vectors and organizes them into a matrix $\boldsymbol{\mathsf{A}}_0 \in \mathbb{Z}^{\delta \times d}$ by padding $ind$ zero vectors before these real samples. Then DP represents $\boldsymbol{\mathsf{A}}_0$ as $\pi(\boldsymbol{\mathsf{A}}_0)$ and gets $ct_0 \leftarrow$  Encrypt$(pk,\pi(\boldsymbol{\mathsf{A}}_0))$.
		
		\STATE DP separates the remaining vectors into $e\delta$ vectors and remains $f$ vectors where $f < \delta$ and $n_u = \delta -ind + e \delta + f$. 
        \STATE DP constructs $e$ polynomials $\pi(\boldsymbol{\mathsf{A}}_1), \cdots, \pi(\boldsymbol{\mathsf{A}}_e)$ using $e\delta$ face vectors and performs $ct_i \leftarrow$ Encrypt$ (pk,\pi(\boldsymbol{\mathsf{A}}_i))$ for each $i \in [1,e]$.
		
		\STATE DP pads $\delta -f$ zero vectors to the remaining $f$ vectors and gets $\pi(\boldsymbol{\mathsf{A}}_{e+1})$. Then DP encrypts it as $ct_{e+1} \leftarrow$ Encrypt$(pk,\pi(\boldsymbol{\mathsf{A}}_{e+1}))$ and sets $ind \leftarrow \delta -f$.

		\STATE DP uploads $\{ct_0,\cdots,ct_{e+1} \}$ and $ind$ to CS.
		
		\STATE After receiving the ciphertexts, CS first updates $ind$ and saves $\{ct_1,\cdots,ct_{e+1} \}$. Then CS performs $ct_{la} \leftarrow$ Eval.Add($ct_{la},ct_0$). 
    \end{algorithmic}
    % \vspace{-2mm}
\end{algorithm}



% \begin{algorithm}[tb]
% \footnotesize
%     \caption{Secure distance computation}
%     \label{alg:distance computation}
%     \textbf{Input}: An encrypted database $\{ct_0,\cdots,ct_{s-1}\}$, where each $ct_i$ is the ciphertext of a $\delta \times d$ matrix $\boldsymbol{\mathsf{A}} = \{\boldsymbol{a}_0, \boldsymbol{a}_1,\cdots,\boldsymbol{a}_{\delta-1}\} \in \mathbb{Z}^{\delta \times d}$ with $m=s\delta$; A key-switching key $k_{sw}$ from CS; A queried face vector $\boldsymbol{b} \in \mathbb{Z}^d$ from verifier.\\
%     \textbf{Parameter}: $\delta =  \lceil \frac{N-d}{d} \rceil$ where $N$ is the plaintext polynomial degree.\\
%     \textbf{Output}: CS gets the secret share $\boldsymbol{\mathbf{d}}^A_0$ and the verifier gets the secret share $\boldsymbol{\mathbf{d}}^A_1$ where $\boldsymbol{\mathbf{d}}$ is an $m$-length vector of computed distances.
    
%         \STATE The verifier encodes and encrypts the queried face vector $\boldsymbol{b}$ by $pk$ as $ct$ and sends it to CS.

%         \STATE CS and the verifier generate two empty vectors $\boldsymbol{\mathbf{d}}^A_0$ and $\boldsymbol{\mathbf{d}}^A_1$, respectively.
		
% 		\FOR{$i \in [0,s-1]$}
% 		    \STATE CS computes $ct_i' \leftarrow$ Eval.Mul($ct$, $ct_i$). 
		    
% 		    \STATE CS randomly generates a plaintext polynomial $\boldsymbol{r}$ with degree $N$. 
		    
% 		    \STATE CS extracts its $(kd-1)$-th coefficients from $\boldsymbol{r}$ and sets $\boldsymbol{\mathbf{d}}^A_0 [i\delta+k-1] \leftarrow -r_{kd-1}$ where $k \in [1,\delta]$.
		    
% 		    \STATE CS computes $ct_i'' \leftarrow$ Eval.Add($\boldsymbol{r}$, $ct_i'$).
% 		\ENDFOR
		
% 		\STATE CS employs \textbf{Key-switching} using key $k_{sw}$ to transfer the ciphertext $\{ct_0'',\cdots, ct_{s-1}''\}$ encrypted by $pk$ to the ciphertext encrypted by verifier's public key $pk_v$. The new ciphertext set is denoted as $\{c_0',\cdots, c_{s-1}'\}$.

% 		\STATE CS sends $\{c_0',\cdots, c_{s-1}'\}$ to the verifier and keeps $\boldsymbol{\mathbf{d}}^A_0 [i]$ where $i \in [0,m-1]$.
		
% 		\STATE After receiving ciphertexts from CS, the verifier first decrypts the ciphertexts $\{c_0',\cdots,c_{s-1}'\}$ using BFV Decrypt() with its private key $sk_v$ as input and gets plaintext polynomials as $\{\boldsymbol{p}_0,\cdots,\boldsymbol{p}_{s-1}\}$ where $\boldsymbol{p}_i = a_0X^0 + \cdots+ a_{N-1}X^{N-1}$.
		
% 		\FOR{$i \in [0,s-1]$}
% 		    \STATE The verifier extracts the $(kd-1)$-th coefficients $a_{(kd-1)}$ from polynomial $\boldsymbol{p}_i$ and sets $\boldsymbol{\mathbf{d}}^A_1 [i\delta+k-1] \leftarrow a_{kd-1}$ where $k \in [1,\delta]$.
%         \ENDFOR
        
%     \end{algorithmic}
% \end{algorithm}


\begin{algorithm}[tb]
\footnotesize
    \caption{Secure distance computation}
    \label{alg:distance computation}
    \textbf{Input}: An encrypted database $\{ct_0,\cdots,ct_{s-1}\}$, where each $ct_i$ is the ciphertext of a $\delta \times d$ matrix $\boldsymbol{\mathsf{A}} = \{\boldsymbol{a}_0, \boldsymbol{a}_1,\cdots,\boldsymbol{a}_{\delta-1}\} \in \mathbb{Z}^{\delta \times d}$ with $m=s\delta$; A queried face vector $\boldsymbol{b} \in \mathbb{Z}^d$ from verifier.\\
    \textbf{Parameter}: $\delta =  \lceil \frac{N-d}{d} \rceil$ where $N$ is the plaintext polynomial degree.\\
    \textbf{Output}: CS gets the secret share $\boldsymbol{\mathbf{d}}^A_0$ and the verifier gets the secret share $\boldsymbol{\mathbf{d}}^A_1$ where $\boldsymbol{\mathbf{d}} = \boldsymbol{\mathbf{d}}^A_0 + \boldsymbol{\mathbf{d}}^A_1$ is an $m$-length vector of computed distances.
    
    \begin{algorithmic}[1] %[1] enables line numbers

        \STATE The verifier sends a ``setup" signal to KG. Then KG generates a key-switching key $k_{sw} \leftarrow $ SwKeyGen($sk, sk_v$) and sends it to CS.
    
        \STATE The verifier encodes and encrypts $\boldsymbol{b}$ as $ct \leftarrow$ Encrypt$(pk,\pi(\boldsymbol{b}))$ and sends $ct$ to CS.

        \STATE CS and the verifier generate two empty vectors $\boldsymbol{\mathbf{d}}^A_0$ and $\boldsymbol{\mathbf{d}}^A_1$, respectively.
		
		\FOR{$i \in [0,s-1]$}
		    \STATE CS computes $ct_i' \leftarrow$ Eval.Mul($ct$, $ct_i$). 
		    
		    \STATE CS randomly generates a plaintext polynomial $\boldsymbol{r}_i = r_0X^0 + \cdots+ r_{N-1}X^{N-1}$. 
		    
		    \STATE CS extracts its the $(kd-1)$-th coefficients from $\boldsymbol{r}_i$ and sets $\boldsymbol{\mathbf{d}}^A_0 [i\delta+k-1] \leftarrow -r_{kd-1}$ where $k \in [1,\delta]$.
		    
		    \STATE CS computes $ct_i'' \leftarrow$ Eval.Add($\boldsymbol{r}_i$, $ct_i'$).

            \STATE CS performs $c_i' \leftarrow$Switching$(k_{sw},ct_i'')$.
            
		\ENDFOR
	

		\STATE CS sends $\{c_0',\cdots, c_{s-1}'\}$ to the verifier and keeps $\boldsymbol{\mathbf{d}}^A_0 [i]$ where $i \in [0,m-1]$.

        % \STATE After receiving ciphertexts from CS, the verifier performs $\boldsymbol{p}_i \leftarrow$ Decrypt$(sk_v, ct_i')$ for each $i \in[0,s-1]$, where $\boldsymbol{p}_i = a_0X^0 + \cdots+ a_{N-1}X^{N-1}$.
		
		\FOR{$i \in [0,s-1]$}

            \STATE The verifier performs $\boldsymbol{p}_i \leftarrow$ Decrypt$(sk_v, ct_i')$ for each $i \in[0,s-1]$, where $\boldsymbol{p}_i = a_0X^0 + \cdots+ a_{N-1}X^{N-1}$.
            
		    \STATE The verifier extracts the $(kd-1)$-th coefficients $a_{(kd-1)}$ from polynomial $\boldsymbol{p}_i$ and sets $\boldsymbol{\mathbf{d}}^A_1 [i\delta+k-1] \leftarrow a_{kd-1}$ where $k \in [1,\delta]$.
        \ENDFOR
        
    \end{algorithmic}
\end{algorithm}

% \vspace{-5mm}
\begin{algorithm}[tb]
\footnotesize
    \caption{Secure result-revealing}
    \label{alg:result-revealing}
    \textbf{Input}: The secret share of distance vector $\boldsymbol{\mathbf{d}}^A_0$ from CS; The secret share of distance vector $\boldsymbol{\mathbf{d}}^A_1$ and a threshold $ts$ from verifier.\\
    % \textbf{Parameter}: $\delta =  N/d -1$ where $N$ is the plaintext polynomial degree and $d$ is the face vector dimension.\\
    \textbf{Output}: The verifier learns whether its face image exists in the database.
    
    \begin{algorithmic}[1] %[1] enables line numbers
        
        \FOR{$i \in [0,m-1]$}

        \STATE The verifier updates $\boldsymbol{\mathbf{d}}^A_1 [i] \leftarrow ts-\boldsymbol{\mathbf{d}}^A_1 [i]$.
        
        \STATE CS and verifier jointly run $(b^B_0[i],b^B_1[i]) \leftarrow$ SC$_{lt} (\boldsymbol{\mathbf{d}}^A_1 [i],\boldsymbol{\mathbf{d}}^A_0 [i])$.

        \STATE CS and verifier jointly perform $(b^A_0[i], b^A_1[i]) \leftarrow$ B2A$(b^B_0[i],b^B_1[i])$. 

        % \STATE The verifier and CS perform a $\textbf{B2A}$ conversion to get an arithmetic sharing of $b[i]$. In the end, CS receives $b^A_0[i]$ and the verifier receives $b^A_1[i]$ where $b[i] \leftarrow b^A_0[i] + b^A_1[i]$.

        \ENDFOR
        
        \STATE CS computes $b_0 = \sum^{m-1}_{i=0}b^A_0[i]$ and verifier computes $b_1 = \sum^{m-1}_{i=0}b^A_1[i]$. 
        
        \STATE CS and verifier jointly perform $(\mu_0,\mu_1) \leftarrow$ SC$_{lt} (-b_0, b_1)$.
        

        \STATE CS sends $\mu_0$ to the verifier. The verifier computes $\mu \leftarrow \mu_0 \oplus \mu_1$ and learns its face image is in the database by $\mu=1$. Otherwise, it learns its face image is not in the database by $\mu=0$.
    \end{algorithmic}
\end{algorithm}


% To better describe our work, we first propose several building blocks that form our protocol and then put them all together. 
\subsection{Enrolment Process}
% We consider the scenario where the feature images in the database coming from different DPs. When the system is first set up, a key generator will generate a pair of BFV keys $(pk,sk)$ and publishes $pk$ to all DPs and CS. 
% The key generator will also generates the relinearisation key $rlk$ and sends it to CS. 

Based on our encoding method, we improve enrollment efficiency by reducing the number of ciphertexts uploaded by DPs. Specifically, we use one plaintext polynomial with degree $N$ to represent $\lceil \frac{N-d}{d} \rceil$ face vectors, which results in only one homomorphic ciphertext. 
Thus, DP only needs to upload a single homomorphic ciphertext for $\lceil \frac{N-d}{d} \rceil$ images to CS while the state-of-the-arts~\cite{boddeti2018secure} and~\cite{engelsma2022hers} require $\lceil \frac{N-d}{d} \rceil$ and $d$ ciphertext, respectively. This encoding strategy is also beneficial to CS for saving storage overhead compared with work~\cite{boddeti2018secure}, \cite{engelsma2022hers}. The reason is that our designed encoding method allows CS to merge its last stored ciphertext with a new one that comes from another DP.

The details of the enrollment process are given in Algorithm~\ref{alg:enrolment}. We suppose CS already stored some encrypted face vectors under the public key $pk$ and a DP then wants to add $n_u$ $d$-dimensional face vectors $\boldsymbol{\mathsf{V}} = \{\boldsymbol{a}_0,\cdots,\boldsymbol{a}_{n_u-1}\}$ to CS. CS maintains an indicator $ind$, which tells DP the start vacant position in the last stored ciphertext. Rather than directly encrypting these vectors and sending them to CS, DP first encodes the data based on our proposed encoding method and then performs BFV encryption over the encoded data. When receiving the indicator $ind$ from CS, DP divides its vectors into three parts. The first part contains $\delta-ind$ vectors where $\delta =  \lceil \frac{N-d}{d} \rceil$ represents the maximum number of face vectors that can be encoded into a polynomial. Since CS is allowed to merge the last ciphertext with a newly come one, DP organizes the first $\delta-ind$ vectors into a matrix $\boldsymbol{\mathsf{A}}_0 \in \mathbb{Z}^{\delta \times d}$ by padding $ind$ zero vectors before these real samples. This matrix is encrypted as $ct_0$. When CS receives $ct_0$, it can merge it to its last stored ciphertext $ct_{la}$ by simply performing a homomorphic addition Eval.Add($ct_{la},ct_0$). The second part contains $e \delta$ vectors, and the last part contains $f$ vectors where $f < \delta$ and $n_u = \delta -ind + e \delta + f$. DP encrypts matrices $\boldsymbol{\mathsf{A}}_1, \cdots, \boldsymbol{\mathsf{A}}_e$ in the second part separately using BFV and sends them to CS. Unlike the first part, for the last part, DP first pads $\delta -f$ zero vectors to the remaining vectors, then encrypts it as $ct_{e+1}$ and sends it to CS. In the last, DP updates the indicator $ind = \delta -f$ and sends it to CS for further use. 
% Algorithm~\ref{alg:enrolment} describes the secure enrolment process of DP.

\subsection{Evaluation Process}
The evaluation process happens between a verifier and a CS. Specifically, as shown in Algorithm~\ref{alg:distance computation}, given a face vector, the verifier first encodes it into a polynomial. Then the verifier encrypts the polynomial using the public key $pk$ and sends it to CS. CS gets a key-switching key $k_{sw}$ from KG after KG receives a ``setup" signal from the verifier. After receiving the encrypted query $ct$ from the verifier, CS first runs local homomorphic multiplication between each ciphertext $ct_i$ stored in CS and $ct$, where $i \in [0,s-1]$. Rather than directly sending the computed results to the verifier, CS masks each of them using a randomly selected plaintext polynomial $\boldsymbol{r}_i$. CS can easily extract the $(kd-1)$-th coefficients $r_{kd-1}$ from $\boldsymbol{r}_i$ where $k \in [1, \delta]$ and keeps its additive inverse into $\boldsymbol{\mathbf{d}}^A_0[i\delta+k-1]$, which is one of the secret parts of computed distances. To enable the verifier to perform decryption by itself, CS transfers each ciphertext encrypted by $pk$ to $pk_v$ by a key-switching technique before sending them to the verifier. With the masked distances, CS does not require performing RLWE to LWE extraction function, a key design in~\cite{huang2022cheetah}. The extraction function is considered time-consuming as it is performed over homomorphic ciphertext~\cite{chen2021efficient}. In our design, the verifier can extract the coefficients by itself after decrypting the RLWE ciphertext. Doing this saves the homomorphic extraction overhead on the CS side. Besides, we also reduce the required communication for $\lceil \frac{N-d}{d}\rceil$ face vectors from $\lceil \frac{N-d}{d}\rceil(N+1)q$ to $2Nq$ where $q$ denotes the ciphertext coefficients modulo. After decrypting all the received ciphertext, the verifier similarly extracts coefficients from obtained polynomial and saves them into $\boldsymbol{\mathbf{d}}^A_1$, which is another part of secret-shared computed distances.

Then CS runs a secure result-revealing protocol with the verifier as shown in Algorithm~\ref{alg:result-revealing}. For each shared distance, CS and the verifier jointly run a secure comparison to compute $\boldsymbol{\mathbf{d}}^A_1 [i] < \boldsymbol{\mathbf{d}}^A_0 [i]$, where $\boldsymbol{\mathbf{d}}^A_1 [i] \leftarrow ts - \boldsymbol{\mathbf{d}}^A_1 [i]$ is from the verifier and $\boldsymbol{\mathbf{d}}^A_0 [i]$ is from CS. Clearly, the result represents the less than comparison between the given threshold $ts$ and the distance $\boldsymbol{\mathbf{d}}[i]$. However, the comparison result is in binary format, so we cannot directly aggregate all results. Thus, we need a \textbf{B2A} conversion $(b^A_0[i], b^A_1[i]) \leftarrow$ B2A$(b^B_0[i],b^B_1[i])$. After that, CS can compute $b_0 = \sum^{m-1}_{i=0}b^A_0[i]$ and the verifier computes $b_1 = \sum^{m-1}_{i=0}b^A_1[i]$. To obtain the queried result, CS and verifier jointly perform $(\mu_0,\mu_1) \leftarrow$ SC$_{lt} (-b_0, b_1)$ and CS sends $\mu_0$ to the verifier. In the end, the verifier learns whether the queried face image exists in the database by computing $\mu \leftarrow \mu_0 \oplus \mu_1$.  
% Before presenting our private face recognition, we first give some building blocks which construct our protocol.

\subsection{Security Analysis}
The security of CryptoMask follows from the semantic security of HE and the security of MPC. The complexity and security analysis can be found in Appendix~\ref{sec:security}. 

% \notescui{Get part of them back} \notejbai{we do not have space. Papers should not exceed 16 pages in LNCS style, including the bibliography, but excluding well-marked appendices (no more than 18 pages in total).}



%\subsection{CryptoMask}
%We put all pieces together to obtain CryptoMask. A DP who wants to add more face vectors to the database can perform Algorithm~\ref{alg:enrolment} with CS. Then a verifier checks the existence of a face image by running Algorithm~\ref{alg:distance computation} and~\ref{alg:result-revealing} with CS. 

% Due to the page limits, we refer readers to the full version of this paper for detailed security analysis.

% The private face recognition starts from the verifier encrypts the encoded queried face vector and sends the ciphertext $ct$ to CS. CS multiplies verifier's ciphertext $ct$ with each element in $\{ct_1,\cdots,ct_n\}$ by employing homomorphic multiplication. It is notable some coefficients that are not desired by the verifier contains some extra information about the combination relationship. To prevent this leakage, we use a randomly selected polynomial $\boldsymbol{r}$ as a mask and adds it to the multiplication result. CS stores the $kv-1$-th coefficients where $k \in [1,\delta]$ as $x[iv-v-1+k] \leftarrow -r_{kd-1}$ from the randomly generated polynomial. Before sending the masked ciphertext to the verifier, CS transforms all ciphertexts encrypted the public key $pk$ to ciphertexts encrypted by the verifier's public key $pk_v$ using key $k_w$. This key-switching enables the face database on CS can be provided by different DPs and the verifier can use her own key pairs to decrypt the result without others help. 

% After receiving the ciphertext from CS, the verifier decrypts using his private key $sk_v$ and gets the plaintext as $\{p_1,\cdots,p_n\}$. For each plaintext $p_i$, the verifier extracts corresponding coefficients $a_{kd-1}$ whose index is $kd-1$ where $k \in [1,v]$. The verifier uses $t$ to minus all extracted coefficients and we set the computed result as $y[i], i \in [0,m-1]$. To compare each distance with the threshold, CS and the verifier jointly run the secure comparison protocol with input $x[i]$ from CS and $y[i]$ from the verifier where $i \in [0,m-1]$. 

\subsection{Optimizations}\label{subsec::optimization}
We present some optimizations to improve the efficiency of CryptoMask. 
% These optimizations can also be applied to other biometric recognition system.

\noindent \textbf{Reducing Computation Overhead.}
In Algorithm~\ref{alg:distance computation}, CS should run a key-switching before sending the masked distance ciphertext to the verifier, which is time-consuming. We can put this key-switching when the verifier first sets up. Rather than sending the face vector encrypted by $pk$, the verifier encrypts it using its public key $pk_v$. Then all computations in CS are over the encrypted data over $pk_v$. However, this is a trade-off since it will save computation overhead but increase CS's storage. 



\noindent \textbf{Reducing Communication Overhead.}
We employ the ciphertext compression technique from SEAL library~\cite{sealcrypto}, compressing the original ciphertext into around two-thirds of the original size. Notably, this ciphertext compression can only be used for data to be decrypted because it will cause a decryption error if the data is computed over compressed ciphertext. Clearly, CryptoMask can benefit from the compression technique.
% while~\cite{engelsma2022hers} cannot because it requires to do rotation over encrypted data. It is clear that protocol~\cite{boddeti2018secure} suffers from linear communication complexity thus, although it can benefit from the above optimization, but the improvement is very limited. 
Another ciphertext size reduction of CryptoMask is gained from Cheetah~\cite{huang2022cheetah}. The observation is that CS only needs to send high-end bits of two parts of ciphertext to the verifier. In this way, we save around $16\%-25\%$ communication with a negligible decryption failing chance~(\ie, $< 2^{-38}$). For a more detailed analysis, see~\cite{huang2022cheetah}. 
% We additionally optimize the comparison communication by using parallel technique.


% The third optimization is that although the matrix computation in CryptoMask is similar to Cheetah~\cite{huang2022cheetah}, we do not need to perform RLWE to LWE extraction function which is a key design in their protocol. In our protocol, the verifier can extract the coefficients by herself after decrypting RLWE ciphertext. By doing this, we can reduce the required ciphertext for $N/d-1$ face vectors from $(N/d-1)(N+1)q$ to $2Nq$. 


