\section{Overview of Our Approach} \label{sec:overview}
This section describes the system model and threat model and overviews CryptoMask.

% \vspace{-5mm}
\subsection{System Model}
% Figure environment removed
% \vspace{-5mm}

% In CryptoMask, we consider the encrypted facial vectors stored on CS are received from a group of data providers who can be universities in practice. The verifier plays the role of a student who wants to get verified with his/her face image.
In CryptoMask, we consider the scenario where the database is stored on a cloud server, and the corresponding face vectors are received from a group of data providers. 
% A verifier wants to check if a given face image is verified by checking if it matches an image in the database.
A verifier wants to check if a given face image matches an image in the database.
Our system consists of four types of entities: a trusted \textbf{Key Generator~(KG)} who generates keys for other entities for privacy-preserving purposes. A group of \textbf{Data Providers~(DPs)} who upload extracted face vectors to a cloud server, a \textbf{Cloud Server (CS)} who stores the database of face vectors,
and a \textbf{Verifier} who checks if a given face vector is in the database, as shown in Fig.~\ref{fig:system}.
% and a \textbf{Verifier} who searches face image from the database as shown in Fig.~\ref{fig:system}.

\noindent \textbf{KG.} KG generates a pair of HE public/private keys $(pk,sk)$ and distributes $pk$ to other entities. KG also generates another pair of public/private keys $(pk_v,sk_v)$ and sends them to the verifier. When KG receives a “setup" request from the verifier, it computes a key-switching key $k_{sw}$ based on $sk$ and $sk_v$ and sends it to CS.

\noindent \textbf{DPs.} In our system, DPs can upload images (represented by face vectors) to CS. To keep their data private, DPs encrypt the face vectors using the public key $pk$ before uploading them to CS. We call this process \textit{enrolment}. 
%, and we provide a novel enrolment mechanism based on our special encoding method. 
%In reality, the DPs could be a group of universities that have a large amount of students' face images.

\noindent \textbf{CS.} CS stores the encrypted face vectors. 
% It can be the cloud CS~(\eg~Google, Amazon, etc.). 
It performs face recognition protocol with the verifier without learning anything about the queried face information or the result. 
%In reality, CS could be maintained by an education management organization.
% In reality, CS might play the role of an education management organization.

\noindent \textbf{Verifier.} 
The verifier has a face image and intends to check if the image is in the database by performing a privacy-preserving face recognition protocol with CS. We call this process \textit{evaluation}.
% The verifier encrypts her image vector and sends it to CS. Then the verifier performs a secure distance computation and a secure result-revealing process with CS. 
It learns the image exists in the database if the check result is one.
% In reality, the verifier might be a student who wants to know her/his student certification by checking if her/his face image exists in the database.
For example, a verifier can be a service provider who receives or collects a face image from a user after the user's consent. The verifier then wants to check whether the user is a verified user in order to provide subsequent service. 

% \subsection{System Security and Definition}
\subsection{Threat Model}
% According to the power of the adversary, in general, there are two types of classical adversary models. One is semi-honest model where the adversary follows the protocol honestly but may try to learn some unallowed information 
% %from the protocol transcript 
% \textcolor{blue}{by passively observing the communication}. Another one is the malicious model where the adversary can run arbitrary polynomial-time attack strategies. In this paper, we only focus on the semi-honest model.
% % where the corrupted party will follow the protocol specification. 
% In addition, we suppose KG is fully trusted and will never conclude with any other entities. We leave malicious security as important future work. The security definition is defined as follows:
Similar to previous work, such as \cite{boddeti2018secure} and~\cite{engelsma2022hers}, we assume the CS and the verifier are honest-but-curious~(semi-honest). 
That is, they will follow the protocol honestly but may try to infer as much information as possible. We also assume CS and the verifier will never collude with each other. It is reasonable in practice because CS (\eg, education management organization) is motivated to maintain its reputation and is not likely to take the risk of colluding with the verifier. The KG is a fully trusted party. 


\subsection{Overview of \sys}

% \noindent \textbf{Distance Representation.}
% In this paper, we employ cosine similarity to measure the distance score. Given two vectors $\boldsymbol{a'} \in \mathbb{Z}^{d}$ and $\boldsymbol{b'} \in \mathbb{Z}^{d}$, the distance between them can be computed according to cosine similarity as
% \begin{equation}\label{equation:originaldistance}
% d(\boldsymbol{a'},\boldsymbol{b'}) 
% =\frac{\boldsymbol{a'} \boldsymbol{b'}}{\lVert \boldsymbol{a'}\rVert \lVert \boldsymbol{b'}\rVert}
% =\frac{\sum_{i=1}^d {{a'}_i {b'}_i}}{\sqrt{\sum_{i=1}^d {{a'}_i^2}} \sqrt{\sum_{i=1}^d {{b'}_i^2}}}.
% \end{equation}
% Although most components of Equation (\ref{equation:originaldistance}) can be pre-computed before sending to CS, directly computing division still yields huge computation overhead when working over homomorphic encryption~\cite{veugen2014encrypted}. In our paper, we avoid expensive division computation by measuring the dissimilarity score between $\boldsymbol{a'}$ and $\boldsymbol{b'}$, which is similar to~\cite{boddeti2018secure}, shown as 
% \begin{equation}\label{equation:distance}
% dis(\boldsymbol{a'},\boldsymbol{b'}) 
% = 1 - \frac{\boldsymbol{a'}^T\boldsymbol{b'}}{\lVert \boldsymbol{a'}\rVert \lVert \boldsymbol{b'}\rVert} 
% = 1 - \boldsymbol{a}^T\boldsymbol{b}
% = 1 - \sum_{i=1}^{d} a_i b_i 
% \end{equation}
% where $\boldsymbol{a}=\frac{\boldsymbol{a'}}{\lVert \boldsymbol{a'}\rVert}$ is the normalization representation. The score computation in the modified version only contains $d$ multiplications and $d$ additions. In CryptoMask, the DPs pre-compute $\boldsymbol{a}=\frac{\boldsymbol{a'}}{\lVert \boldsymbol{a'}\rVert}$ for each face vector $\boldsymbol{a'}$ and sends the encrypted $\boldsymbol{a}$ to CS.

% A trivial way to perform face recognition securely is encrypting each feature vector with HE and computing the cosine similarity between the query and each vector in the database. 
% Assume the database contains $m$ feature vectors and each vector contains $d$ features. It results in $md$ times homomorphic multiplication computation, which is significantly expensive. 
% Moreover, it leaks sensitive information to the verifier, such as the computed distance vectors $\boldsymbol{\mathsf{d}}$, which violates the security of database. The previous work proposed in~\cite{boddeti2018secure,engelsma2022hers,erkin2009privacy,pradel2021privacy} have the same issue. 
% In this paper, we propose \sys, a much more efficient and secure privacy-preserving face recognition protocol that has reduced overhead and information leakage. 
% In particular, we design a novel encoding method to improve performance and a secure result-revealing protocol to minimize information leakage. 



Encrypting each face vector with HE and computing the cosine similarity between the query and each vector in the database is a straightforward but expensive way to perform face recognition securely. With $m$ face vectors and $d$ features per vector, this method requires $md$ homomorphic multiplications, which can be significantly time-consuming. Additionally, this approach poses a privacy risk by leaking sensitive information, such as the computed distance vectors $\boldsymbol{\mathsf{d}}$. 
Previous works, such as those proposed in~\cite{boddeti2018secure,engelsma2022hers,erkin2009privacy,pradel2021privacy}, also suffer from the same issue. 
To tackle all the issues above, we introduce \sys. In particular, we design a novel encoding method to enhance performance and a secure result-revealing protocol to minimize information leakage.
% In this paper, we introduce \sys, an efficient and secure privacy-preserving face recognition protocol that minimizes overhead and information leakage. We achieve this by designing a novel encoding method to enhance performance and a secure result-revealing protocol to minimize information leakage.


To reduce both the communication and computation overhead, our main idea is to encrypt face vectors in batches and compute the cosine similarity between the query and a batch of face vectors, rather than one by one. 
Specifically, during the enrollment process, given a batch of face vectors, DP encodes them into one BFV ciphertext $ct_i$ and sends it to CS. 
When the verifier queries for an image, CS performs only one homomorphic multiplication between each BFV ciphertext $ct_i$ and the encrypted query. The resulting ciphertext contains the cosine similarity between batched face vectors and the queried face vector. 
To determine if the queried image matches any image stored in the CS, the next step is to compare the cosine similarity with the threshold. 
%Most existing works~\cite{boddeti2018secure,engelsma2022hers} 
Directly revealing the cosine similarity results to the verifier or the CS exposes sensitive information. For example, they can learn how many face images in the database are similar to the given one. 
To avoid such leakage, CryptoMask runs a secure result-revealing protocol between CS and the verifier, which only reveals whether the queried face image exists in the database to the verifier. 

To further enhance the performance of \sys, we can adopt a paralleling technique to compute the cosine similarity between the query and batched face vectors.
As done in work~\cite{boddeti2018secure}~\cite{engelsma2022hers}, the homomorphic multiplication performed during the evaluation can be processed in parallel with the SIMD technique. 
However, this technique requires a prime plaintext modulus\cite{huang2022cheetah}, implying that the homomorphic encryption must be performed in $\mathbb{Z}_p$ with $p$ as prime. In our secure result-revealing protocol, the secure comparison is a non-linear function, and~\cite{rathee2020cryptflow2} has shown that OT-based protocols on the ring $\mathbb{Z}_{2^l}$ perform 40\%-60\% better than on the prime field $\mathbb{Z}_p$ in bandwidth consumption, with almost no cost for modulo reduction.
Hence, in this work, rather than employing SIMD, we opt for the parallelization technique from~\cite{huang2022cheetah} to compute homomorphic multiplication in parallel. This technique enables us to work exclusively in the ring domain $\mathbb{Z}_{2^l}$ and brings another efficiency improvement by avoiding expensive rotation, the key operation for SMID-based work.
Furthermore, while~\cite{huang2022cheetah} necessitates an extraction algorithm (RLWE-based ciphertext to LWE-based ciphertext) for useful information extraction from the resulting ciphertext, we avoid it by masking the resulting ciphertext and sending it back to the verifier, which is more efficient.


\subsection{Data Representation}
The coefficients of the BFV plaintext polynomial must be integers. To achieve this, we need to encode our real-valued representation $\boldsymbol{\mathsf{A}} \in \mathbb{R}^{m\times d}$ as an integer-valued representation, which we denote by $\boldsymbol{\mathsf{A}} \in \mathbb{Z}^{m\times d}$. For the remainder of the paper, we use $\boldsymbol{\mathsf{A}}$ to refer to the matrix where all elements are integers. We scale the real-valued features into integers using a specified precision. This scaling method results in a loss of precision during computation. In our experiments, we evaluate the level of precision loss by setting different precision scales, and report the results in Table~\ref{Table::Accuracy} in Appendix~\ref{appendix:accuracy}.

% However, these two previous fail to protect 

% \notejbai{\refscui{Our main idea is to encode multiple face vectors into a high-degree polynomial. Doing so allows us to perform only one BFV encryption to encrypt multiple face vectors}{Each DP can encrypt a set of images into one piece of ciphertext, which is a polynomial. The CS stores a number of polynomials and evaluates the query with each polynomial one by one? Or the CS can combine all the polynomials into one and just perform the evaluation once? The image set encrypted by DPs must contain a fixed number of images? or they can contain any number of images? }. \{Each DP can encrypt a set of images into one piece of ciphertext, which is a polynomial. The CS stores a number of polynomials and evaluates the query with each polynomial one by one. The image set encrypted by DPs must contain a fixed number of images, but less than N-d/d.\} Then we only need to perform one homomorphic multiplication for all face vectors encoded in the polynomial. In the following, we describe how to encode a set of face vectors into a polynomial.}


\iffalse

\notejbai{Note that BFV scheme~\cite{fan2012somewhat} is designed to work on a polynomial ring $R_t = \mathbb{Z}[x]_t/f(x)_t$ with degree $N$. 
The observation is that the number of slots in a polynomial (\eg, 4096) is far more than the dimension of a face vector (\eg 128). Thus, we can easily employ one polynomial to represent multiple face vectors. However, the challenge is how to encode the face vectors into a polynomial while maintaining the correctness of computation over two of these polynomials (usually, two BFV ciphertexts).
We follow the same encoding strategy from Cheetah~\cite{huang2022cheetah}, which we do not claim novelty. }
In specific, given a matrix $\boldsymbol{\mathsf{A}}= \{\boldsymbol{a}_0, \boldsymbol{a}_1,...,\boldsymbol{a}_{m-1}\} \in \mathbb{Z}^{m \times d}$, where $\boldsymbol{a}_i=(a_i^0, ..., a_i^{d-1})$ and $0 \leq i \leq m-1$, we represent it into a polynomial as 
% \begin{gather*}
% \pi(\boldsymbol{\mathsf{A}}^{m\times d}) = a_0^{d-1}X^0+a_0^{d-2}X^1+\cdot \cdot \cdot+a_0^0X^{d-1}\\
% +a_1^{d-1}X^{d}+a_1^{d-2}X^{d+1}+\cdot \cdot \cdot + a_1^0X^{2d-1} \\
% +\cdot \cdot \cdot + \\
% +a_{m-1}^{d-1}X^{(m-1)d}+a_{m-1}^{d-2}X^{(m-1)d+1}+\cdot \cdot \cdot+ a_{m-1}^0X^{md-1}.
% \end{gather*}
\begin{align*}
&\pi(\boldsymbol{\mathsf{A}}) = a_0^{d-1}X^0+a_0^{d-2}X^1+\cdots+a_0^0X^{d-1}\\
&+a_1^{d-1}X^{d}+a_1^{d-2}X^{d+1}+\cdots + a_1^0X^{2d-1} + \\
&\cdots\\
&+a_{m-1}^{d-1}X^{(m-1)d}+a_{m-1}^{d-2}X^{(m-1)d+1}+\cdots+ a_{m-1}^0X^{md-1}.
\end{align*}

% \noindent Given another polynomial
% $\pi(\boldsymbol{b}) = b^0X^0+b^1X^1+\cdots+b^{d-1}X^{d-1}$
% % $\pi(\boldsymbol{b}) = b^{d-1}X^0+b^{d-2}X^1+\cdot \cdot \cdot+b^0X^{d-1}$
% constructed from a vector $\boldsymbol{b} \in \mathbb{Z}^{d}$, we can easily obtain a vector $\boldsymbol{\mathsf{d}} \in \mathbb{Z}^{m}$ by multiplying these two polynomials as $\pi(\boldsymbol{b})*\pi(\boldsymbol{\mathsf{A}})$. 
% Each element in $\boldsymbol{\mathsf{d}}$ is the result of each row vector from $\boldsymbol{\mathsf{A}}$ dot products the vector $\boldsymbol{b}$. 
\noindent Given another polynomial
$\pi(\boldsymbol{b}) = b^0X^0+b^1X^1+\cdots+b^{d-1}X^{d-1}$, we can easily get another polynomial $\pi(\boldsymbol{\mathsf{W}})$ by multiplying above two polynomials as $\pi(\boldsymbol{\mathsf{A}})*\pi(\boldsymbol{b})$. It is notable that the coefficient of degree $X^{(i+1)d-1}$ where $i \in [0,m-1]$ in polynomial $\pi(\boldsymbol{\mathsf{W}})$ forms the dot product result of the $i$-th row vector from $\boldsymbol{\mathsf{A}}$ and the vector $\boldsymbol{b}$. 
\notejbai{In our design, each row in the matrix $\boldsymbol{\mathsf{A}}$ represents a face vector. That is, before encrypting and uploading the face vectors to CS, DP encodes them into a matrix $\boldsymbol{\mathsf{A}}$ and then transforms it into the polynomial $\pi(\boldsymbol{\mathsf{A}})$. We call this process encoding. Then DP encrypts this polynomial using BFV as $ct_i$ and sends it to CS. The verifier encrypts the queried face vector $\boldsymbol{b}$ as $ct$ and sends it to CS. The cosine similarity is computed by multiplying these two ciphertexts $ct_i$ and $ct$, whose underlying plaintext polynomial is exactly $\pi(\boldsymbol{\mathsf{W}})$.}
The correctness comes from the fact that we revise the elements order of each vector in matrix $\boldsymbol{\mathsf{A}}$ when we encode it into a polynomial. 
For simplicity, we give a toy example of a small matrix $\boldsymbol{\mathsf{A}} \in \mathbb{Z}^{2\times 3}$ multiplies with a vector $\boldsymbol{b} \in \mathbb{Z}^{2}$ as shown in Fig \ref{fig:toyexample}. We refer readers to Cheetah~\cite{huang2022cheetah} to see the detailed proof of correctness.



% Figure environment removed

\notescui{From the above, we can see the relationship between polynomial multiplication (pi(A)*pi(b)) with matrix multiplication (A*b). But what's the relationship between A*b and the cosine similarity? and What's the relationship between pi(A)*pi(b) with cosine similarity, \ie equation (1)?}

% \sout{The above method may work in theory, but it will be unworkable if we directly fill all the coefficients in a plaintext polynomial when considering encoding our face images database}. 
% However, computing $\pi(\boldsymbol{b})*\pi(\boldsymbol{\mathsf{A}})$ directly cannot correctly measure the similarity between the query vector and each image. 
As mentioned, the plaintext space of BFV scheme is taken from $R_t = \mathbb{Z}_t/(x^N+1)$, which means the maximum degree of a plaintext polynomial is $N$. The direct method is we fill all the coefficients slots in the plaintext polynomial when considering encoding our face images database. However, this might result in a loss of valid similarity.
The reason is that the valid value in the product will be dropped~(module reduced to a position with a degree less than $N$) if its associated degree is greater than $N$, which means we will get the wrong distances for some records. Our idea is to leave the last $d$ positions in the polynomial $\pi(\boldsymbol{\mathsf{A}})$ for “buffer” use and set their coefficients as 0. Thus, all valid values will be presented as coefficients with degrees less than $N$.
That is, if the degree of a plaintext polynomial is $N$, we only encode its lower $N-d$ coefficients and leave the higher $d$ coefficients as zeros. A similar strategy applies to the queried face vector.
% The reason is that this polynomial will be multiplied by another polynomial whose lower $d$ coefficients represent the queried face image, and higher $N-d$ coefficients are set to zeros.
Using this encoding method, the concrete number of ciphertext for $m$ face images with dimension $d$ will be $\lceil \frac{m}{N-d} \rceil$.
\notescui{Justify how this idea affects the similarity check between two images}

% \noindent \textbf{Concrete Encoding Method.} We now give a concrete encoding method which saves a significant number of ciphertexts stored in CS compared with~\cite{boddeti2018secure}. We notice it is unworkable if we fill all the coefficients for a plaintext polynomial with the given database. It is because this polynomial will be multiplied by another polynomial which represents the queried face image. The valid value in the multiplication result will be dropped~(module reduced to a position with a degree less than $N$) when its original degree is greater than $N$, which means we will get the wrong distances for some records. To solve this problem, our idea is to leave the last $d$ positions for “buffer” use and set their coefficients as 0. Thus, all valid values will be presented as coefficients with degrees less than $N$. Using this encoding method, the concrete number of ciphertext for $m$ face images with dimension $d$ will be $\lceil \frac{m}{N-d} \rceil$.

\noindent \textbf{Data Representation.}
The coefficients of BFV plaintext polynomial should be only integers; thus, we need to encode our real-valued representation $\boldsymbol{\mathsf{A}} \in \mathbb{R}^{m\times d}$ into an integer-valued representation. We reuse the symbol $\boldsymbol{\mathsf{A}}$ and represent the integer matrix as $\boldsymbol{\mathsf{A}} \in \mathbb{Z}^{m\times d}$. In the rest of the paper, $\boldsymbol{\mathsf{A}}$ means all the elements in the matrix are integers. To achieve this, we scale the real-valued feature into integers with a given precision. It is clear that this scaling method will result in a precision loss in computation. In our experiments, we measure the level of precision lost by setting different precision scales, shown in Table.~\ref{Table::Accuracy}.

% \noindent \textbf{Data Encryption.}
% Given an encoded matrix $\pi(\boldsymbol{\mathsf{A}})$ and an encoded queried face vector $\pi(\boldsymbol{b})$, we encrypt it as $ct_i$ and $ct$, respectively, using BFV encryption.


\subsection{Technique Overview}
In a real scenario, the encrypted data stored on CS is received from a group of DPs 
and this process is called~\textit{enrolment}. 
A verifier queries the database by performing a secure face recognition~\textit{evaluation} with CS. 
In this paper, we intend to make the enrolment and evaluation processes efficient and ensure the participants learn only what they are allowed to learn.

As for the enrollment process, we aim to reduce communication as much as possible while maintaining the uploaded data private. The previous work proposed in~\cite{pradel2021privacy} encrypted each image one by one, which results in $m$ homomorphic ciphertexts in communication, where $m$ is the images contained in the database. We improve enrollment efficiency by reducing the number of ciphertexts uploaded by DPs. Specifically, we introduce a new encoding strategy by exploiting the properties of HE. 
With this, we can use one plaintext polynomial with degree $N$ to represent $\lceil \frac{N-d}{d} \rceil$ face vectors, which results in only one homomorphic ciphertext. 
Thus, DP only needs to upload a single homomorphic ciphertext for $\lceil \frac{N-d}{d} \rceil$ images to CS while the state-of-the-arts~\cite{boddeti2018secure} and~\cite{engelsma2022hers} require $\lceil \frac{N-d}{d} \rceil$ and $d$ ciphertext, respectively. This encoding strategy is also beneficial to CS for saving storage overhead compared with work~\cite{engelsma2022hers}. The reason is that our designed encoding method allows CS to merge its last stored ciphertext with a newly come one from other DPs.
% Notably, our method also enables the CS to perform simple homomorphic addition even though the images are from different DPs while the work~\cite{engelsma2022hers} . 




%We answer the second question by improving the computation efficiency and reducing the communication cost. 
As for the evaluation process, \notejbai{todo}
% we aim to avoid expensive homomorphic operations such as homomorphic rotation.  

% we employ efficient matrix multiplication to 


% Owing to our designed encoding strategy, given two ciphertexts $ct_i$ and $ct$


% that can eliminate the costly \refscui{rotations}{No context for rotations}. Specifically, we can eliminate \refscui{SIMD technique}{Justify why this technique is costly. As far as know, this technique is a type of parallel processing, which is efficient}, which are costly in the literature.



% and we only need to compute homomorphic multiplication. 

% It is important to note that our new encoding method combined with the new inner product approach also enables us to reduce about $u$ required homomorphic multiplication. 

Most existing works~\cite{boddeti2018secure,engelsma2022hers} directly expose the distance between the query and each record in the database to the verifier. This definitely threats the security of the face images in the database.
For example, the verifier can learn how many face images in the database are similar to the given one.
% For example, the verifier can infer the images in the database by continuously searching similar images several times. 
In CryptoMask, rather than revealing distances to the verifier, we run a secure result-revealing protocol between CS and the verifier. In the end, the verifier can only learn whether the queried face image exists in the database. 
% We additionally optimize the comparison communication by using parallel technique. 

\fi