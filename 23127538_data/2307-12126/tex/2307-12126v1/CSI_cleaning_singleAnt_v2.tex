%\documentclass[conference]{IEEEtran}
\documentclass[lettersize,journal]{IEEEtran}
%\documentclass[12pt, draftclsnofoot, onecolumn]{IEEEtran}
\IEEEoverridecommandlockouts
%
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  \usepackage{epstopdf}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi

\usepackage[hyphens]{url}
%\usepackage{setspace}
%\usepackage{amsmath}
\usepackage[cmex10]{amsmath}
\usepackage{bbm}
% Package for math equations
\usepackage{amssymb}
% Package for color
%\usepackage[usenames,dvipsnames]{color}
%\usepackage[table]{xcolor}
\usepackage{xcolor,colortbl}
\usepackage{tablefootnote}
% Packages for inserting figures.
\usepackage{graphicx}
\usepackage{float}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage{wrapfig}
%\usepackage[caption=false]{subfig}
%\usepackage{subfig}
\usepackage{algorithmic}
\usepackage[algoruled, linesnumbered]{algorithm2e} %added by Sandipan for algorithm writing
\usepackage{mathrsfs}
%\usepackage{natbib}
\usepackage{cite}
%\usepackage{hyperref}
%\usepackage{caption}
\usepackage{array}
\usepackage{mdwmath}
\usepackage{mdwtab}
\usepackage{fixltx2e}
%\usepackage{stfloats} %DO NOT USE THIS EVER !
\usepackage{amsthm}
%\usepackage[margin=0.7in]{geometry}
\usepackage{tikz}
\allowdisplaybreaks
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{remark}{Remark}
\DeclareMathOperator*{\argmax}{argmax}
\DeclareMathOperator*{\argmin}{argmin}

%\linespread{0.995}
% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/required/tools/


%\usepackage{mdwmath}
%\usepackage{mdwtab}
% Also highly recommended is Mark Wooding's extremely powerful MDW tools,
% especially mdwmath.sty and mdwtab.sty which are used to format equations
% and tables, respectively. The MDWtools set is already installed on most
% LaTeX systems. The lastest version and documentation is available at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/mdwtools/


% *** SUBFIGURE PACKAGES ***
%\usepackage[tight,footnotesize]{subfigure}
% subfigure.sty was written by Steven Douglas Cochran. This package makes it
% easy to put subfigures in your figures. e.g., "Figure 1a and 1b". For IEEE
% work, it is a good idea to load it with the tight package option to reduce
% the amount of white space around the subfigures. subfigure.sty is already
% installed on most LaTeX systems. The latest version and documentation can
% be obtained at:
% http://www.ctan.org/tex-archive/obsolete/macros/latex/contrib/subfigure/
% subfigure.sty has been superceeded by subfig.sty.



%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}
% subfig.sty, also written by Steven Douglas Cochran, is the modern
% replacement for subfigure.sty. However, subfig.sty requires and
% automatically loads Axel Sommerfeldt's caption.sty which will override
% IEEEtran.cls handling of captions and this will result in nonIEEE style
% figure/table captions. To prevent this problem, be sure and preload
% caption.sty with its "caption=false" package option. This is will preserve
% IEEEtran.cls handing of captions. Version 1.3 (2005/06/28) and later 
% (recommended due to many improvements over 1.2) of subfig.sty supports
% the caption=false option directly:
%\usepackage[caption=false,font=footnotesize]{subfig}
%
% The latest version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/subfig/
% The latest version and documentation of caption.sty can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/caption/

% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure. The latest version and documentation can be found at:
% http://www.ctan.org/tex-archive/macros/latex/base/

%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/sttools/
% Documentation is contained in the stfloats.sty comments as well as in the
% presfull.pdf file. Do not use the stfloats baselinefloat ability as IEEE
% does not allow \baselineskip to stretch. Authors submitting work to the
% IEEE should note that IEEE rarely uses double column equations and
% that authors should try to avoid such use. Do not be tempted to use the
% cuted.sty or midfloat.sty packages (also by Sigitas Tolusis) as IEEE does
% not format its papers in such ways.

% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version can be obtained at:
% http://www.ctan.org/tex-archive/macros/latex/contrib/misc/
% Read the url.sty source comments for usage information. Basically,
% \url{my_url_here}.

% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{International Conference on Communications}


\begin{document}
%
% paper title
% can use linebreaks \\ within to get better formatting as desired
\title{Optimal preprocessing of WiFi CSI for sensing applications}
%\title{On optimal cleaning of CSI for wireless sensing using commodity WiFi}
%\author{Vishnu V. Ratnam}
\author{Vishnu V. Ratnam, \IEEEmembership{Senior Member,~IEEE}, Hao Chen, \IEEEmembership{Member,~IEEE}, Hao Hsuan Chang, \IEEEmembership{Member,~IEEE}, \\ Abhishek Sehgal, \IEEEmembership{Member,~IEEE}, Jianzhong (Charlie) Zhang, \IEEEmembership{Fellow,~IEEE}
%\IEEEauthorblockA{Standards and Mobility Innovation Lab,
%Samsung Research America\\
%Plano, Texas, USA. 
%Email: vishnu.r@samsung.com}}
\thanks{All authors are with the Standards and Mobility Innovation Lab, Samsung Research America, Plano, Texas, USA. Email: vishnu.r@samsung.com}}
% make the title area
\maketitle


\begin{abstract}
Due to its ubiquitous and contact-free nature, the use of WiFi infrastructure for performing sensing tasks has tremendous potential. However, the channel state information (CSI) measured by a WiFi receiver suffers from errors in both its gain and phase, which can significantly hinder sensing tasks. By analyzing these errors from different WiFi receivers, a mathematical model for these gain and phase errors is developed in this work. Based on these models, several theoretically justified preprocessing algorithms for correcting such errors at a receiver and, thus, obtaining clean CSI are presented. Simulation results show that at typical system parameters, the developed algorithms for cleaning CSI can reduce noise by $40$\% and $200$\%, respectively, compared to baseline methods for gain correction and phase correction, without significantly impacting computational cost. The superiority of the proposed methods is also validated in a real-world test bed for respiration rate monitoring (an exemplary sensing task), where they improve the estimation signal-to-noise ratio by $20$\% compared to baseline methods.
\end{abstract}

%\IEEEpeerreviewmaketitle
\begin{IEEEkeywords}
WiFi sensing, Wireless sensing, CSI preprocessing, Respiration rate estimation, Smart home.
\end{IEEEkeywords}

\section{Introduction} \label{sec_intro}
With the advent of the internet of things and the ubiquitous availability of WiFi infrastructure (access points and stations), WiFi-based wireless sensing has become a very hot and upcoming topic \cite{Jiang2018, Ma2019}. In wireless sensing, a transmitter (TX) periodically transmits a known signal, and the receiver (RX) uses the received signal to track temporal variations in the channel and, correspondingly, in the ambient environment. This has many applications including presence detection, exercise monitoring, people counting, intruder alarm, respiration rate detection, sleep monitoring, etc. \cite{Fang2018, Charlton2018, Regev2021, Natarajan2021}. %Several wireless sensing solutions have been proposed in literature, that either involve use of dedicated/specialized hardware or re-use existing wireless infrastructure that is deployed for other applications. Due to the ubiquitous availability of WiFi infrastructure (access points and stations), WiFi-based sensing has received significant interest, and is also the focus of this work \cite{Jiang2018, Ma2019}.
%Wireless sensing can broadly be classified into two classes: (i) synchronized TX-RX (ii) un-synchronized TX-RX. In methods of class (i), the TX transmitting the signal and the RX estimating the channel have near-perfect time/frequency synchronization, such as in the case of a mono-static RADAR. However, use of such specialized RADAR equipment, requires an additional deployment of a RADAR systems and may impose additional cost burdens especially in house-hold scenarios. As a practical alternative, few recent works have explored works of class (ii) which utilize existing wireless architecture for performing breathing rate detection, where time/frequency synchronization between TX and RX may not exist. A popular example is the use of the ubiquitous WiFi infrastructure (access points and stations). In this work, we focus on such WiFi based wireless sensing.
%

A typical difficulty of WiFi devices is that the TX and RX do not have timing and carrier synchronization, due to which the channel estimate at the RX, referred to as channel state information (CSI), suffers from random phase errors. In addition, the impact of variable gain circuits in the RX causes random amplitude fluctuations in the channel estimate at the RX. Since these gain and phase errors are not easily separable from the variations in the ``true" channel (which captures the variations in the environment relevant to sensing), wireless sensing using WiFi devices is very challenging. Prior works have devised several approaches to tackle these errors:
\subsubsection{To account for gain errors} two types of solutions have been proposed: (i) Use of CSI metrics that are robust to gain errors; and (ii) explicitly estimating the gain error to recover the clean CSI. Among methods of type (i), \cite{Patwari2014, Abdelnasser2015} proposed to use only the received signal strength indicator (RSSI) at an RX, corresponding to signals transmitted from a WiFi TX, to perform sensing. In \cite{Liu2014, Liu2015}, a Hampel filter-based outlier removal and interpolation were used to remove the impact of the gain error. In \cite{Chen2018}, the received CSI is normalized to get rid of the gain error. In \cite{Wang2017b} only the phase information of CSI is used for estimation. A Savitzky Golay filter is used in \cite{Zeng2018, Dou2021} to reduce the impact of gain variations on CSI. In \cite{Liu2021}, a DBSCAN-based clustering algorithm is proposed to identify and filter CSI values belonging to different discrete gain levels. Among methods of type (ii), \cite{Niu2021} proposes a method to use side information such as RSSI and gain coefficient information to estimate the CSI gain. However, this method requires prior calibration of the WiFi chip to learn the mapping. 
%
\subsubsection{To account for phase errors} two types of solutions have been used: (i) Use of CSI metrics that are robust to phase errors and (ii) explicitly estimating the phase errors to recover clean CSI. Among methods of type (i), \cite{Patwari2014, Abdelnasser2015} proposed using only the received signal strength at an RX, corresponding to signals transmitted from a WiFi TX, to perform sensing. In \cite{Liu2014, Liu2015}, only the WiFi CSI amplitude from different sub-carriers is utilized for sensing. Using the principle that the phase errors affect the CSI at all receive antennas similarly, \cite{Wang2017b} used only the phase difference in the channel CSI at two receive antennas for performing sensing. Using the same principle, \cite{Zeng2019} used the ratio of the CSI observed at two antennas to perform sensing. In \cite{Zeng2018}, a combination of the CSI amplitude and the CSI phase difference between two receive antennas is jointly utilized for sensing. In \cite{Chen2018}, both the amplitude and phase of channel CSI were fully exploited, wherein a time reversal resonating strength metric is computed for the channel CSI, which is then used for sensing. In \cite{Xie2019}, the power delay profile corresponding to the CSI is used for sensing after estimating and removing the phase errors due to timing offset. Among methods of type (ii), \cite{Dou2021} proposed a least-squares method for estimating and correcting the CSI phase errors. %In \textcolor{red}{[Hao-Hsuan]} a moving average filter is applied to the CSI before the least-squares operation, to improve the signal-to-noise ratio (SNR) before the estimation. 
%
For either of gain or phase error correction, note that methods of type (i) do not utilize the full information encoded in CSI and typically use some non-linear metrics of CSI, which can make the sensing operation complicated. Many of these methods also have restrictions, such as requiring at least two receiving antennas. In comparison, methods of type (ii) maintain a linear relationship with the input CSI and can potentially exploit the full information encoded in both the amplitude and phase of CSI. However, the existing methods of type (ii) are heuristic, do not exploit the structure present in the CSI. Furthermore, although the performance of these multiple methods has been studied for some specific sensing tasks, a comparative study of how well they can replicate the clean CSI has not been undertaken. 

In this work, we develop a mathematical model for the time-varying true channel, and also for the RX-induced gain error and the synchronization-based phase errors between the TX and RX, which are validated by experiments. Based on these models, we derive multiple theoretically justified methods of type (ii) to estimate and remove the CSI gain and phase errors. Subsequently, we perform a detailed performance comparison of the different gain and phase correction methods for replicating the true CSI and improving the accuracy of an exemplary sensing task. The contributions of this work are as follows:
\begin{itemize}
\item We propose a detailed mathematical WiFi CSI model that takes into consideration RX gain error and synchronization-induced phase error. 
\item Leveraging the distribution of the gain error, we propose several preprocessing algorithms to estimate and remove the gain error in the CSI, including a maximum-likelihood (ML) estimator. 
\item We propose several preprocessing algorithms to remove the phase error present in WiFi CSI, which offer different trade-offs between accuracy and computational complexity. Also among them is a conditionally optimal ML estimator. 
\item We validate the models for the gain error and synchronization-induced phase error using CSI measurements from two real-world WiFi test beds.
\item We perform a detailed performance evaluation of the proposed algorithms for gain and phase error estimation on simulated CSI data under varying scenarios. 
\item Finally, we study the performance of these CSI preprocessing algorithms in a real-world test bed for an exemplary sensing problem, viz., estimating the respiration rate of a stationary subject. 
\end{itemize}

The organization of the paper is as follows: the system model is discussed in Section \ref{sec_chan_model}; the modeling of the CSI gain errors  and the estimation and removal of gain errors are discussed in \ref{sec_gain_correct}; the modeling of the CSI phase errors  and the estimation and removal of phase errors are discussed in \ref{sec_CPE_timing_correct}; the evaluation results on both simulated data and real-world data are provided in Section \ref{sec_eval_results}; and the conclusions are summarized in Section \ref{sec_conclusions}.

\textbf{Notation:} scalars are represented by light-case letters; sets by light-case calligraphic or double bold letters; and functions by scripted letters. Additionally, ${\rm j} = \sqrt{-1}$, ${a}^{*}$ is the complex conjugate of a complex scalar $a$, $\angle a$ represents the phase angle of a complex scalar $a$, $\lfloor a \rfloor$ is the floor function on a real scalar $a$, $| a |$ is the magnitude of a complex scalar $a$ and $\mathrm{Re}\{a\}$ is the real component of a complex scalar $a$. Additionally, $\mathrm{mod}\{a, b\}$ is the modulus function that gives the remainder after dividing $a$ by $b$, $\mathbb{P}(\cdot)$ represents the probability density function, $\mathrm{Uni}[a,b]$ represents a uniform distribution in the range $[a, b]$, $\mathcal{CN}(\mu, \sigma^2)$ represents a circularly-symmetric complex Gaussian distribution with mean $\mu$ and variance $\sigma^2$. Finally, $\mathbb{Z}$ is the set of integers, $\mathbb{R}$ is the set of real numbers, and $\mathbb{C}$ is the set of complex numbers. 

\section{System model} \label{sec_chan_model}
We consider a system setup that has a stationary, single-antenna WiFi access point as the TX and a stationary, single-antenna WiFi station as the RX, as shown in Fig.~\ref{Fig_sytem_illustrate}.\footnote{The results can easily be extended to multiple antennas by repeating the proposed preprocessing methods for CSI from each TX-RX antenna pair.} To enable sensing of any variations in the environment, the TX transmits a sequence of $P$ WiFi channel state information (CSI) acquisition frames\footnote{Such a frame can be, for example, a null data packets \cite{IEEEWiFi2020}.}, indexed as $\mathcal{P} = \{p \in \mathbb{Z} | 0 \leq p < P\}$, that are transmitted periodically at an interval of $T_{\rm rep}$ seconds each. The header and the payload of these CSI frames are encoded using orthogonal frequency division multiplexing (OFDM) over $K$ sub-carriers indexed as: $\mathcal{K} = \{k \in \mathbb{Z} |0 \leq k \leq K\}$ with a symbol duration of $T_{\rm s}$, and are transmitted at a carrier frequency $f_{\rm c}$. For ease of analysis, we assume that the TX oscillator frequency $f_{\rm c}$ doesn't drift significantly across the $P$ CSI frames. We assume that the header of the CSI acquisition frame consists of one legacy short training field (L-STF) and one legacy long training field (L-LTF), each of size one OFDM symbol \cite{IEEEWiFi2020}, as depicted in Fig.~\ref{Fig_sytem_illustrate}. Each transmitted CSI frame passes through a time-varying channel before reaching the RX. 
%
% Figure environment removed

Let ${h}_{p,k}$ be the frequency-domain channel (that captures the variation to be sensed) between the TX and RX on sub-carrier $k$ for CSI frame $p$. Since the TX and RX are stationary, we model ${h}_{p,k}$ as:
\begin{eqnarray} \label{eqn_channel_resp}
{h}_{p,k} \triangleq {b}_{k} + {d}_{p,k}, 
\end{eqnarray}
where ${b}_{k}$ captures the static component of the channel (i.e., component independent of $p$) corresponding to the line-of-sight path, MPCs that are reflected from walls and static objects, etc., and ${d}_{p,k}$ is the dynamic component of the channel that changes with $p$ and captures the channel variations to be sensed. 
%
For ease of analysis and to keep the model applicable to a variety of sensing applications, we do not impose any structure on the static component, except that $\angle[ \sum_{k} {b}_{k} {b}_{k+1}^{*}]=0$, $\sum_k {|{b}_{k}|}^2 \big/ K = \gamma$ (without loss of generality), where $0 \leq \gamma \leq 1$ is a parameter determining the fraction of channel power in the static component. Similarly, we do not impose any limitation on the Doppler spectrum for the dynamic component ${d}_{p,k}$, and model it as ${d}_{p,k} \sim \mathcal{CN}(0, 1-\gamma)$, with it being independent and identically distributed (i.i.d.) for each $k \in \mathcal{K}$ and $p \in \mathcal{P}$.\footnote{In the simulations, we shall however also consider cases where ${d}_{p,k}$ is sparse in the Doppler domains.} For the theoretical derivations, we shall assume a strongly static channel, i.e., $\gamma \approx 1$ in \eqref{eqn_channel_resp}. 
%
%For ease of analysis and to keep the model applicable to a variety of sensing applications, we neither impose any structure on the static component nor impose any limitation on the Doppler spectrum for the dynamic component ${d}_{p,k}$. Correspondingly, we assume $\sum_k {|{b}_{k}|}^2 \big/ K = \gamma$ (without loss of generality), and we model ${d}_{p,k} \sim \mathcal{CN}(0, 1-\gamma)$ as i.i.d. for each $k \in \mathcal{K}$ and $p \in \mathcal{P}$, where $\gamma$ is a design parameter determining the fraction of channel power in the static component.\footnote{In the simulations, we shall however also consider cases where ${d}_{p,k}$ is sparse in the Doppler domains.} For the theoretical derivations, we shall assume a strongly static channel, i.e., $\gamma \approx 1$ in \eqref{eqn_channel_resp}. 
%Note that \eqref{eqn_Hk_variation_model1} assumes that the channel is i.i.d. for each antenna pair $(m,n)$, which is reasonable when $M,N$ are small compared to the number of channel scatterers. In addition, for analytical tractability, we assume $\boldsymbol{\mathcal{D}}_{p,k}, \boldsymbol{\mathcal{B}}_{k}$ are uncorrelated across $k$ in \eqref{eqn_Hk_variation_model1}. 

At the RX, the received signal for CSI frame $p$ is amplified, mixed with a local oscillator signal to convert to base-band, 
%passed through a low-noise amplifier (LNA), an automatic gain control (AGC) circuit \cite{Lee2007, Cheng2014}, 
and then sampled using a dedicated analog-to-digital converter (ADC). Note that to ensure the input to the ADC is operating with the right dynamic range, the RX circuit provides a variable gain $g_{p}$. The sampled signal from the ADC is then used to perform symbol start time detection and carrier frequency offset compensation before performing OFDM demodulation. For each CSI acquisition frame $p$, the RX estimates the symbol start time using the L-STF \cite{Schmidl1997, Nasir2016}, and we assume that the estimated symbol start time can have an error ${\tau}_p$. Similarly, the RX performs carrier frequency-offset compensation using the L-STF and L-LTF symbols \cite{Sourour2004}. We assume the carrier frequency-offset compensation to be accurate enough to only result in a residual common phase error (CPE) \cite{Petrovic2007, Ratnam2020} $\widetilde{\psi}_p$. Finally, after the compensation, OFDM demodulation of the frame is performed. The OFDM demodulation output for the L-LTF symbol is used to estimate the frequency domain channel ${h}_{p,k}$, referred to as channel state information (CSI) on sub-carrier $k$. For any $p \in \mathcal{P}, k \in \mathcal{K}$, this CSI can be modeled as:
\begin{eqnarray} \label{eqn_H_k_est}
\widetilde{{h}}_{p,k} &=& g_{p} {h}_{p,k} e^{-{\rm j} 2 \pi f_k \tau_p} e^{-{\rm j} {\psi}_p}, 
\end{eqnarray}
where we define ${\psi}_p \triangleq \mathrm{mod}[ \widetilde{\psi}_p + 2 \pi f_{\rm c} {\tau}_p  , 2 \pi]$ and shall call it CPE for convenience, and $f_k = k/T_{\rm s}$ is the frequency offset of sub-carrier $k$ from the carrier frequency.
%
Note that, for ease of notation, we do not consider the impact of additive channel noise in \eqref{eqn_H_k_est}. This is without loss of generality because any channel noise can be captured into the dynamic channel component term ${d}_{p,k}$. 
%
Also note that for $>20$ MHz transmission, the L-LTF for each $20$MHz segment is rotated by a different phase by the TX as defined by the standard \cite{IEEEWiFi2020}. Here, without loss of generality, we assume that the corresponding de-rotation has been performed by the RX.
%
To help visualize the errors in \eqref{eqn_H_k_est}, we plot the CSI power $\sum_k |\widetilde{h}_{p,k}|/K$ and $\angle \widetilde{h}_{p,k}$ for an exemplary real-world static scenario in Fig.~\ref{Fig_impaired_CSI_illustrate}.
%
% Figure environment removed
%
%
In \eqref{eqn_H_k_est}, the gain, timing, and CPE $g_{p}, {\tau}_p, {\psi}_p$ distort the gain and phase of the channel response, which can affect the performance of any sensing algorithm. Therefore, the aim of the paper is to obtain good estimates $\widehat{g}_{p}, \widehat{\tau}_p, \widehat{\psi}_p$ of ${g}_{p}, {\tau}_p, {\psi}_p$, respectively, so that a close approximation to the true channel in \eqref{eqn_channel_resp} can be recovered as:
\begin{eqnarray} \label{eqn_Hk_synchronized}
\widehat{{h}}_{p,k} = \widetilde{{h}}_{p,k} e^{{\rm j} 2 \pi f_k \widehat{\tau}_p} e^{{\rm j} \widehat{\psi}_p} \big/  \widehat{g}_{p}.
\end{eqnarray}
We assume a batch processing framework, where the RX first accumulates the CSI for $P$ CSI acquisition frames $\{\widetilde{{h}}_{p,k} | k \in \mathcal{K}, p \in \mathcal{P}\}$, and then uses them to estimate $\widehat{g}_{p}, \widehat{\tau}_p, \widehat{\psi}_p$ for all $p \in \mathcal{P}$. 

\section{Estimation of gain errors} \label{sec_gain_correct}
The aim of this section is to obtain an estimate of the gain term $\widehat{g}_{p}$ for each $p \in \mathcal{P}$, and thus generate the gain-corrected CSI:  
\begin{eqnarray} \label{eqn_CSI_gain_comp}
\bar{{h}}_{p,k} \triangleq \widetilde{{h}}_{p,k} \big/ \widehat{g}_{p},
\end{eqnarray}
for each $k \in \mathcal{K}$, for further processing. 

\subsection{Distribution of gain error} \label{subsec_AGC_gain_dist}
When receiving a CSI frame $p$, the receiver gain $g_{p}$ is a combination of the large-scale gain, which adjusts at a slow-time scale, and an automatic gain control (AGC) gain, which updates at a fast-time scale. Let these two gains in decibel (dB) scale be defined as  $g^{(1)}_{p}$ and  $g^{(2)}_{p}$, respectively, i.e., 
\begin{eqnarray} \label{eqn_gain_model}
20 \times \log_{10} \big( g_{p} \big) =  g^{(1)}_{p} + g^{(2)}_{p}
\end{eqnarray}
We assume these gains to follow the following model:
\begin{itemize}
\item The large-scale gain is a slowly varying random process with a Doppler frequency less than $0.1$ Hz and arises due to change in the gain of low-noise amplifier \cite{Lee2007, Cheng2014}, drift in TX oscillator frequency $f_{\rm c}$, etc.
%\item The LNA gain changes linearly in the decibel scale, i.e., $g^{(1)}_{p,m} = p \lambda_{1,m} + \lambda_{2,m}$, where $\lambda_{1,m}, \lambda_{2,m} \in \mathbb{R}$ are unknown constants.
\item The AGC gain is due to the automatic gain control circuit, which for each $p$ picks a value from a discrete grid, i.e., $g^{(2)}_{p} \in \mathcal{G}$ \cite{Jang_VTC2010, ART001948424}. We make the worst case assumption that $g^{(2)}_{p}$ is independently distributed for each $p$ with a uniform prior over elements of $\mathcal{G}$. 
%\item The AGC gain lies a uniform grid in the decibel scale, i.e., $g^{(2)}_{p,m} = z_p \lambda_{3,m}$, where $z_p \in \mathbb{Z}$ is some integer, and $0.1 \leq \lambda_{3,m} \leq 1$ is an unknown constant. We make the worst case assumption that $z_p$ is equally likely to be any integer value for each $p \in \mathcal{P}$.
\end{itemize}
Note that the impact of $g^{(1)}_{p}, g^{(2)}_{p}$ is clearly visible in the CSI power in Fig.~\ref{Fig_impaired_CSI_illustrate}. These modeling assumptions are further validated using real-world data in Section \ref{subsec_CSI_gain_phase_err_dist}. %It is well known that the AGC increases in discrete steps in the decibel scale \cite{Jang_VTC2010, ART001948424}, and therefore $\mathcal{G}_{m}$ can be inferred from the receiver AGC data-sheet. However, for generality, here we also handle the case where $\mathcal{G}_m$ can be unknown.
%
%% Figure environment removed
%
%Since the purpose of AGC gain is to maintain the signal in a desired dynamic range, the provided gain is inversely proportional to measured signal power of the L-STF, as:
%\begin{eqnarray}
%g_{p,m} = \mathscr{F} \left({\left[\sum_k {|{[\mathbf{h}_{p,m,k}]}_{1}|}^2 + n_{p,m}\right]}^{-1}\right)
%\end{eqnarray}
%where $\mathscr{F}(\cdot)$ is some WiFi chip-specific mapping function, $\sum_k {|{[\mathbf{h}_{p,m,k}]}_1|}^2$ quantifies the actual signal power of the STF and $n_{p,m}$ is a random error term that can be due to interference, ambient noise, etc., at RX antenna $m$. 
%
%In addition, the AGC gain in typical WiFi receivers can only attain a value from a discrete set $\mathcal{G}$, i.e., $\mathscr{F}:\mathbb{R} \rightarrow \mathcal{G}$. However, this discrete set can be non-uniformly spaced and is assumed to be unknown. 

\subsection{Baseline methods} \label{subsec_gain_baseline_algos}
As a baseline, we consider two methods used in prior art. One popular method \cite{Chen2018, Wang2017b}  is to assume all variation in the CSI power comes from the gain error, i.e.,
\begin{eqnarray} \label{eqn_baseline_normPower}
\widehat{g}_{p} = {\left[\frac{1}{K} \sum_{k \in \mathcal{K}} {|\widetilde{{h}}_{p,k}|}^2 \right]}^{1/2}
\end{eqnarray}
Note that while this gets rid of the gain error, it removes most of the information about the sensing signal encoded in the CSI amplitude. For example, as shown in \cite{Zeng2018}, sometimes all of the sensing signal is captured only inside the CSI power.

As another baseline, we consider an extension of the clustering based approach proposed in \cite{Liu2021}. In this approach for each CSI frame $p \in \mathcal{P}$ we compute the pre-compensated CSI powers as:
\begin{eqnarray} \label{eqn_gamma_define}
\widetilde{\Gamma}_{p} \triangleq 10 \times \log_{10} \left[ \frac{1}{K} \sum_{k \in \mathcal{K}} {|\widetilde{{h}}_{p,k}|}^2 \right]
\end{eqnarray}
We then run the DBSCAN clustering algorithm \cite{DBScan} on $\{\widetilde{\Gamma}_{p} | p \in \mathcal{P}\}$ to cluster the $P$ samples into different AGC gain levels. For each identified cluster, the mean value of $\widetilde{\Gamma}_{p}$ is used to estimate the gain term for that cluster as: 
\begin{eqnarray} \label{eqn_baseline_DBscan}
\widehat{g}_{p} = {10}^{\sum_{q \in \mathcal{P}_p}\widetilde{\Gamma}_{q} \big/\big( 20 |\mathcal{P}_p|\big)},
\end{eqnarray}
where $\mathcal{P}_p$ is set of all frames $q \in \mathcal{P}$ that are assigned to same cluster as $p$ in DBSCAN. Since AGC gain steps are usually larger than $0.2$ dB, we can set parameters $\epsilon = 0.15$ and $\textrm{min-points} = 1$ in DBSCAN. %For outlier samples, we can just use \eqref{eqn_gamma_define}. 
One issue with such clustering is that it can perform quite poorly when the large-scale gain has a drift. Additionally, the clustering doesn't exploit the structure present in ${g}^{(2)}_{p}$ thus limiting the performance. Finally, clustering is computationally expensive requiring significant computation time (see Section \ref{subsec_eval_simulated}).

%An example illustration of using this suggested method to identify AGC gain clusters and their median gain values is depicted in Fig.~\ref{Fig_AGC_cluster_illustrate}. 

\subsection{Gain estimation for arbitrary $\mathcal{G}$} \label{subsec_gain_arbitraryG}
Here we assume that $\mathcal{G}$ can be an arbitrary but finite, discrete set. Let us define the CSI power for the true channel as:
\begin{eqnarray} \label{eqn_gamma_true_define}
{\Gamma}_{p} \triangleq 10 \times \log_{10} \left[ \frac{1}{K} \sum_{k \in \mathcal{K}} {|{{h}}_{p,k}|}^2 \right].
\end{eqnarray}
We then have the following observation:
\begin{lemma} \label{remark1}
When $\gamma \approx 1$, the true channel gain ${\Gamma}_{p}$ is i.i.d. Gaussian distributed for each $p \in \mathcal{P}$ with a zero mean and a small variance of $\sigma_{\Gamma}^2 = 100 (1 - \gamma^2)\big/K$. %$\sigma_{\Gamma}^2 = 2 \gamma (1-\gamma)$.
\end{lemma}
%
\begin{proof}
See Appendix \ref{appdix1p5}.
\end{proof}
%
Let us also define the uncompensated channel power increments as:
\begin{eqnarray} \label{eqn_delta_gamma_defn}
\Delta \widetilde{\Gamma}_{p} \triangleq \widetilde{\Gamma}_{p} - \widetilde{\Gamma}_{p-1},
\end{eqnarray}
where we use $\widetilde{\Gamma}_{-1}=\widetilde{\Gamma}_{0}$. Using \eqref{eqn_H_k_est}, \eqref{eqn_gain_model}, \eqref{eqn_gamma_define} and \eqref{eqn_gamma_true_define}, we have: 
\begin{eqnarray}
\widetilde{\Gamma}_{p} &=& {\Gamma}_{p} + g^{(1)}_{p} + g^{(2)}_{p} \label{eqn_tilde_gamma_approx} \\
\Rightarrow \Delta \widetilde{\Gamma}_{p} & \approx & {\Gamma}_{p} - {\Gamma}_{p-1} + g^{(2)}_{p} - g^{(2)}_{p-1} , \nonumber
\end{eqnarray}
which is independent of the large-scale gain $g^{(1)}_{p}$ due to its low bandwidth. Using Lemma \ref{remark1}, we can then infer that $\Delta \widetilde{\Gamma}_{p}$ is an estimate of $g^{(2)}_{p} - g^{(2)}_{p-1}$ with an additive zero-mean Gaussian noise. Since $g^{(2)}_{p}$ comes from a finite discrete set $\mathcal{G}$, as a first step we run DBSCAN algorithm on $\{ \Delta \widetilde{\Gamma}_{p} | 1 \leq p < P \}$ to cluster AGC gain increments. Note that unlike \eqref{eqn_baseline_DBscan}, the clustering here is resilient to the large-scale gain variations. For each $p \in \mathcal{P}$ we can then estimate the AGC gain for frame $p$ sequentially as: 
\begin{eqnarray} \label{eqn_proposed_DBscan}
\widehat{g}^{(2)}_{p} = \widehat{g}^{(2)}_{p-1} + \sum_{q \in \mathcal{P}_p} \Delta \widetilde{\Gamma}_{q} \big/ |\mathcal{P}_p|,
\end{eqnarray}
where we use $\widehat{g}^{(2)}_{-1}=0$ and $\mathcal{P}_p$ is set of all frames $q \in \mathcal{P}$ that are assigned to same cluster as $p$ in DBSCAN. The large-scale gain (along with any accumulated error in \eqref{eqn_proposed_DBscan}) is then estimated using a low-pass filter as:
\begin{eqnarray} \label{eqn_proposed_DBscan2}
\widehat{g}^{(1)}_{p} = \textrm{LPF}_{\text{0.1 Hz}}\{ \widetilde{\Gamma}_{p} - \widehat{g}^{(2)}_{p}\},
\end{eqnarray}
where $\textrm{LPF}_{\text{0.1 Hz}}$ is a low-pass filter with cut-off frequency $0.1$ Hz. Finally $\widehat{g}_{p}$ is computed, as summarized in Algorithm \ref{Algo5}. 
%
\begin{algorithm}
\label{Algo5}
\caption{Gain estimation with arbitrary $\mathcal{G}$}
\begin{algorithmic} 
\STATE Given: $\widetilde{\Gamma}_{p}$ for $p \in \mathcal{P}$
\STATE Compute $\Delta \widetilde{\Gamma}_{p} = \widetilde{\Gamma}_{p} - \widetilde{\Gamma}_{p-1}$ for each $p \in \mathcal{P}$.
\STATE Run DBSCAN on $\{ \Delta \widetilde{\Gamma}_{p} | 1 \leq p < P \}$ with $\epsilon = 0.2$ and $\textrm{min-points} = 1$.
\FOR{$p \in \mathcal{P}$}
\STATE Compute $\widehat{g}^{(2)}_{p}$ from \eqref{eqn_proposed_DBscan}.
\ENDFOR
\STATE Compute $\widehat{g}^{(1)}_{p}$ from \eqref{eqn_proposed_DBscan2} for all $p \in \mathcal{P}$.
\STATE //We use a moving average filter for $\mathrm{LPF}_{\text{0.1 Hz}}$ with one-sided width $6/T_{\rm rep}$.
\STATE Return $\big\{\widehat{g}_{p} = {10}^{(\widehat{g}^{(1)}_{p}+\widehat{g}^{(2)}_{p})/20} \big| p \in \mathcal{P} \big\}$.
\end{algorithmic}
\end{algorithm}
%

\subsection{Gain estimation for uniformly-spaced $\mathcal{G}$} \label{subsec_gain_uniformG}
In this section, we assume a specific structure on the AGC gain set as: $\mathcal{G} = \{z \lambda | z \in \mathbb{Z}\}$, i.e., the AGC gain ${g}^{(2)}_{p}$ is always in multiples of an unknown constant $\lambda$. This causes the following observation:
\begin{lemma} \label{remark2}
All information in $\widetilde{\Gamma}_{p}$ about ${\Gamma}_{p}$ is captured within: $\mathrm{mod}\{ \widetilde{\Gamma}_{p}, \lambda \}$, and equivalently, within 
\begin{eqnarray} \label{eqn_defn_Xi_tilde}
\widetilde{\Xi}_{p} \triangleq \exp\left\{ 2 \pi {\rm j} \widetilde{\Gamma}_{p} \big/ \lambda \right\}.
\end{eqnarray}
\end{lemma}
%
\begin{proof}
See Appendix \ref{appdix1p5}.
\end{proof}
%Similar to DBSCAN, the proposed method also uses the pre-compensated CSI powers $\{ \widetilde{\Gamma}_{p,m} | p \in \mathcal{P}\}$ for performing the estimation of $\{ \widehat{g}_{p,m} | p \in \mathcal{P} \}$. But unlike DBSCAN it optimally utilizes the structure of the gain errors. 
%
For convenience, let us assume that the value of the AGC gain step size $\lambda$ is known. A search over different hypothesis of $\lambda$ is performed, as explained later in the section. For a given value of $\lambda$, the proposed method first finds the best estimate of large-scale gain $g^{(1)}_{p}$ and then estimates the gains $\{ \widehat{g}_{p} | p \in \mathcal{P} \}$.

\subsubsection{Estimation of large-scale gain $g^{(1)}_{p}$} 
Using Lemma \ref{remark2}, note that we can expand:
\begin{eqnarray}
\widetilde{\Xi}_{p} = \exp\left\{ {\rm j} 2 \pi \big[{\Gamma}_{p} + g^{(1)}_{p} \big] \big/ \lambda \right\}
\end{eqnarray}
Since ${\Gamma}_{p}$ is zero-mean Gaussian distributed with a small variance (from Lemma \ref{remark1}), it follows that $\Xi_{p}$ undergoes a slow ($\leq 0.1$ Hz) rotation in the complex plane with $p$ due to $g^{(1)}_{p}$. Correspondingly, $g^{(1)}_{p}$ can be estimated by low-pass filtering as shown in Algorithm \ref{Algo3}. For the rest of the section we shall assume $\widehat{g}^{(1)}_{p} \approx g^{(1)}_{p}$, for convenience.
%
\begin{algorithm}
\caption{Estimation of $g^{(1)}_{p}$} \label{Algo3}
\begin{algorithmic} 
\STATE Given: $\widetilde{\Xi}_{p}$ for $p \in \mathcal{P}$.
\STATE Compute $\bar{\Xi}_{p} = \mathrm{LPF}_{\text{0.1 Hz}}\{ \widetilde{\Xi}_{p} \}$.
\STATE //We use a moving average filter for $\mathrm{LPF}_{\text{0.1 Hz}}$ with one-sided width $6/T_{\rm rep}$.
%\STATE //Here $\mathrm{LPF}$ is any low pass filter to isolate LNA gain e.g. moving average filter.
\STATE Return $\widehat{g}^{(1)}_{p} = \mathscr{U} \big[ \angle \bar{\Xi}_{p} \big] \lambda / 2\pi$ for $p \in \mathcal{P}$.
\STATE // Here $\mathscr{U}(\cdot)$ is the phase unwrapping function that for each $p \in \mathcal{P}$ adds integer shifts of $2 \pi$ to an argument to ensure that $|\angle\bar{\Xi}_{p} - \angle\bar{\Xi}_{p-1}| \leq \pi$.
\end{algorithmic}
\end{algorithm}
%

\subsubsection{Estimation of $\widehat{g}_{p}$ for each $p$} 
Given estimate $\widehat{g}^{(1)}_{p}$ from Algorithm \ref{Algo3} is accurate, we obtain from \eqref{eqn_tilde_gamma_approx}:
\begin{eqnarray}
\widetilde{\Gamma}_{p} - \widehat{g}^{(1)}_{p} \approx \Gamma_{p} + {g}^{(2)}_{p}. \nonumber 
%  = \Gamma_{p} + z_p \lambda
\end{eqnarray}
Since $\Gamma_{p}$ is zero-mean Gaussian distributed, and ${g}^{(2)}_{p} = z_p \lambda$ for some $z_p \in \mathbb{Z}$, it can be readily shown that the ML estimate of ${g}^{(2)}_{p}$ is: 
\begin{eqnarray} \label{eqn_gamma_hat}
\widehat{g}^{(2)}_{p} = \lambda \bigg( \bigg\lfloor \frac{ \widetilde{\Gamma}_{p} - \widehat{g}^{(1)}_{p} }{\lambda} + \frac{1}{2} \bigg\rfloor - \frac{1}{2} \bigg). 
\end{eqnarray}
and therefore the ML estimate of the CSI power is: 
\begin{eqnarray} \label{eqn_hat_Gama}
\widehat{\Gamma}_{p} = \widetilde{\Gamma}_{p} - \widehat{g}^{(1)}_{p} - \widehat{g}^{(2)}_{p} .
\end{eqnarray}
%\begin{eqnarray} \label{eqn_hat_g}
%\widehat{g}_{p} = {10}^{\big( \widehat{g}^{(1)}_{p} + \widehat{g}^{(2)}_{p} \big) \big/ 20}
%\end{eqnarray}
% 
% Figure environment removed
%
The distribution of $\widehat{\Gamma}_{p}$ and its relation to ${\Gamma}_{p}$ is illustrated in Fig.~\ref{Fig_gamma_distortion}. We have the following observations on this ML estimate $\widehat{\Gamma}_{p}$:
\begin{lemma} \label{remark3}
If estimate $\widehat{g}^{(1)}_p$ is accurate and $P \gg 1$, the then ${\Gamma}_{p}$ has a wrapped Gaussian distribution and its variance can be estimated from $\widetilde{\Gamma}_{p}$ as:
\begin{eqnarray} \label{eqn_sigma_est}
\widehat{\sigma}_{\Gamma}^2 = - \frac{\lambda^2}{2 \pi^2} \log \bigg| \frac{1}{P} \sum_{p \in \mathcal{P}}  \exp \Big\{ {\rm j} 2 \pi \widehat{\Gamma}_{p} / \lambda \Big\} \bigg|
\end{eqnarray}
\end{lemma}
\begin{proof}
See Appendix \ref{appdix1p5}
\end{proof}
%
\begin{lemma} \label{remark4}
If estimate $\widehat{g}^{(1)}_p$ is accurate, the distortion between ${\Gamma}_{p}$ and $\widehat{\Gamma}_{p}$ is given by ${\lambda}^2 \mathscr{D} \big( \lambda \big/ \sigma_{\Gamma} \big)$ where:
\begin{eqnarray} \label{eqn_distortion}
\mathscr{D}( x ) = \sum_{z \in \mathbb{Z}} \bigg[ Q \bigg( \Big(z-\frac{1}{2}\Big) x \bigg) - Q \bigg( \Big(z+\frac{1}{2} \Big) x \bigg) \bigg] {z}^2
\end{eqnarray}
where $Q(\cdot)$ is the Q-function for standard Gaussian.
\end{lemma}
\begin{proof}
See Appendix \ref{appdix1p5}.
\end{proof}

\subsubsection{Estimation of $\lambda$}
The last step of the algorithm is to select the best hypothesis of $\lambda$ if its value is unknown apriori. For this, we can perform a line-search over a feasible set, where the goal is to find a candidate $\lambda$ that (i) minimizes the model fitting error, captured by $\widehat{\sigma}_{\Gamma}^2$ in Lemma \ref{remark3} and (ii) keeps the distortion caused by the model low, captured by Lemma \ref{remark4}. Correspondingly we can select $\lambda$ that minimizes:
$$ \widehat{\sigma}_{\Gamma}^2 + {\lambda}^2 \mathscr{D}\big( \lambda \big/ \widehat{\sigma}_{\Gamma} \big) . $$
\begin{remark}
Intuitively, $\widehat{\sigma}_{\Gamma}^2$ captures the error in `model fitting' which will be smaller for a smaller $\lambda$ (due to more AGC gain levels). To counter act that, the distortion terms acts like a regularizer that incentivizes larger choices of $\lambda$. 
\end{remark}
The overall set of steps in the proposed algorithm are summarized in Algorithm \ref{Algo4}.
%
\begin{algorithm}
\label{Algo4}
\caption{Gain estimation with uniform $\mathcal{G}$}
\begin{algorithmic} 
\STATE Given: $\widetilde{\Gamma}_{p}$ for $p \in \mathcal{P}$
\STATE $\lambda_{\rm max} = 1.5 \big( \max_p\{\widetilde{\Gamma}_{p}\} - \min_p\{\widetilde{\Gamma}_{p}\} \big)$
\FOR{$\lambda = (0.05:0.05:1)\times \lambda_{\rm max}$}
\STATE // Can be computed in parallel to improve speed.
\STATE Compute $\widetilde{\Xi}_{p}$ from \eqref{eqn_defn_Xi_tilde} for $p \in \mathcal{P}$.
\STATE Run Algorithm \ref{Algo3} to obtain $\widehat{g}^{(1)}_{p}$.
\STATE Compute $\widehat{g}^{(2)}_p, \widehat{\Gamma}_{p}$ from \eqref{eqn_gamma_hat} and \eqref{eqn_hat_Gama} for $p \in \mathcal{P}$.
\IF{$\sum_p {(\widehat{\Gamma}_{p})}^2 \big/ P \leq \lambda^2/24$}
\STATE Compute $\widehat{\sigma}_{\Gamma}$ from \eqref{eqn_sigma_est}.
\STATE Compute $\mathscr{D} \big( \lambda \big/ \widehat{\sigma}_{\Gamma} \big)$ from \eqref{eqn_distortion}.
\STATE // $\mathscr{D}(\cdot)$ can be pre-computed and stored in a look up table to improve speed.
\STATE Compute $\mathrm{Obj} (\lambda) = \widehat{\sigma}_{\Gamma}^2 + {\lambda}^2 \mathscr{D} \big( \lambda \big/ \widehat{\sigma}_{\Gamma} \big)$.
\ELSE
\STATE $\mathrm{Obj} (\lambda_{m}) = \infty$.
\STATE // Skip $\lambda$ where variance is too close to uniform distribution. Eqn. \eqref{eqn_sigma_est} is inaccurate in such cases.
\ENDIF
\ENDFOR
\STATE For $\lambda$ with minimum value of $\mathrm{Obj}(\lambda)$, return $\big\{\widehat{g}_{p} = {10}^{(\widehat{g}^{(1)}_p+\widehat{g}^{(2)}_p)/20} \big| p \in \mathcal{P} \big\}$.
\end{algorithmic}
\end{algorithm}
%

\section{Estimation of timing error and CPE} \label{sec_CPE_timing_correct}
In this section, the gain corrected CSI $\bar{{h}}_{p,k}$ shall be used for estimating the values of ${\tau}_p, {\psi}_p$. For the analysis in this section, we assume that these gain estimates are accurate, and thus from \eqref{eqn_H_k_est} we have:
\begin{eqnarray} \label{eqn_Hk_gain_synchronized}
\bar{{h}}_{p,k} = {{h}}_{p,k} e^{-{\rm j} 2 \pi f_k {\tau}_p} e^{-{\rm j} {\psi}_p}.
\end{eqnarray}

\subsection{Distribution of timing error and CPE} \label{subsec_timing_CFO_dist}
The timing error ${\tau}_{p}$ can arise from two sources: (i) the sampling time granularity of the ADC at the RX and (ii) the error in the symbol start time estimated using the L-STF of the CSI frame, and it is fundamentally limited by the inverse of the OFDM system bandwidth, viz., $T_{\rm s}/K$. Therefore it is safe to model the timing error as $\tau_{p} \sim \textrm{Uni}(- \kappa T_{\rm s}/K, \kappa T_{\rm s}/K)$, where $\kappa$ is a system parameter that depends on the accuracy of the RX timing compensation (typically $\kappa < 20$). Furthermore, since synchronization is performed independently for each CSI frame, the timing error ${\tau}_{p}$ is also independently distributed for each $p \in \mathcal{P}$.

For CPE, note that ${\psi}_p = \mathrm{mod} \big[ \widetilde{\psi}_p + 2 \pi {f}_{\rm c} \tau_p, 2 \pi \big]$, and $\widetilde{\psi}_p$ is the difference in the carrier phase between the TX and RX at time $p T_{\rm rep}$. Considering typical values of $f_{\rm c} = 5$ GHz and $T_{\rm rep} = 50$ms, this corresponds to $2.5\times {10}^8$ cycles of the carrier between two CSI frames. Preventing oscillator drift over so many cycles between the RX and TX, is nearly impossible. Thus, it is reasonable to assume that $\widetilde{\psi}_p$, and consequently also ${\psi}_p$, is independent for each $p \in \mathcal{P}$ and is uniformly distributed, i.e., $\psi_p \sim \mathrm{Uni}[-\pi, \pi]$. Note that this also explains the experimental observations made in \cite{Liu2014} about the (un-corrected) channel phase, and the behavior of $\angle \widetilde{h}_{p,k}$ in Fig.~\ref{Fig_impaired_CSI_illustrate}. Further experimental validation of these models is performed later in Section \ref{subsec_CSI_gain_phase_err_dist}. 
%

\subsection{Baseline methods}
As a baseline, we consider two methods from prior art. First, is the heuristic method for the correction of the timing error and CPE $\widehat{\tau_p}, \widehat{\psi}_p$ that was proposed in \cite{Dou2021}:
\begin{align}
\widehat{\tau}_p, \widehat{\psi}_{p} = \argmin_{\tau, \psi} \bigg\{ \sum_{k \in \mathcal{K}} {\Big( 2\pi f_{k} \tau + \psi - \mathscr{U}\{\angle \bar{{h}}_{p,k} \} \Big)}^2 \bigg\} ,  \label{eqn_CPE_timing_baseline1} 
\end{align}
where $\mathscr{U}(\cdot)$ is the phase unwrapping function that for each $k \in \mathcal{K}$ adds integer shifts of $2 \pi$ to an argument to ensure that $|\angle \bar{{h}}_{p,k} - \angle \bar{{h}}_{p,k-1}| \leq \pi$. Note that this method does not exploit the temporal correlation of the channel. In fact, it can be shown to be an approximation of one of our proposed solutions below. 
%
A second heuristic method to estimate ${\tau}_p$ was proposed in the IEEE 802.11az standard \cite{IEEE_11az}, that exploits the frequency domain, coherence of the channel as:
\begin{subequations} \label{eqn_CPE_timing_baseline2} 
\begin{eqnarray}
\widehat{\tau}_p = \frac{T_{\rm s}}{2 \pi} \angle \bigg[ \sum_{k=0}^{K-2} \bar{{h}}_{p,k} \bar{{h}}_{p,k+1}^{*} \bigg], \label{eqn_CPE_baseline2_tau} 
\end{eqnarray}
where $T_{\rm s}$ is the OFDM symbol duration. This method can be extended to obtain the phase estimate as:
\begin{eqnarray}
\widehat{\psi}_{p} = - \angle \bigg[ \sum_{k \in \mathcal{K}} \bar{h}_{p,k} e^{{\rm j} 2 \pi f_k \widehat{\tau}_p}\bigg] . \label{eqn_CPE_baseline2_psi}
\end{eqnarray}
\end{subequations}
It can be shown that \eqref{eqn_CPE_baseline2_tau} is reasonably accurate when $\gamma \approx 1$ and \eqref{eqn_CPE_baseline2_psi} is accurate when additionally the channel has a strong LoS path. However, this method also does not exploit the temporal correlation of the channel and hence is sub-optimal.

\subsection{Method 1: Estimation in strongly LoS channels} \label{subsec_timing_CFO_est_0}
Here we consider estimation of $\tau_p, \psi_p$ under the assumption that the channel has a strong LoS component, where $\gamma \approx 1$ and the static channel component is dominated by a strong frequency-flat path. 
%Under these conditions, we have the following remark:
%\begin{remark}
%Under the aforementioned conditions, the estimates $\bar{\tau}_p, \bar{\psi}_p$ of $\tau_p, \psi_p$ from \eqref{eqn_CPE_timing_baseline2} are accurate and an estimate for the static component $b_k$ is obtained as:
%\begin{eqnarray} \label{eqn_b_hat_est_LoS}
%\bar{b}_k &=& \sum_{p\in \mathcal{P}} \bar{h}_{p,k} e^{{\rm j}(f_k \bar{\tau}_p + \bar{\psi}_p)} \big/ P 
%\end{eqnarray}
%\end{remark}
%\begin{proof}
%See Appendix \ref{appdix0}.
%\end{proof}
Under these conditions, using \emph{coarse} estimates $\bar{\tau}_p, \bar{\psi}_p$ from \eqref{eqn_CPE_timing_baseline2}, an estimate of the static channel component can be obtained as:
\begin{eqnarray} \label{eqn_b_hat_est_LoS}
\bar{b}_k &=& \sum_{p\in \mathcal{P}} \bar{h}_{p,k} e^{{\rm j}(2 \pi f_k \bar{\tau}_p + \bar{\psi}_p)} \big/ P 
\end{eqnarray}
Note that $\bar{b}_k$ in \eqref{eqn_b_hat_est_LoS} is averaged over the $P$ CSI frames and hence is expected to be less noisy than estimates $\bar{\tau}_p, \bar{\psi}_p$. 
%Here we consider estimation of $\tau_p, \psi_p$ under the assumption that the channel has a strong LoS component, where $\gamma \approx 1$ and the static channel component is frequency-flat, i.e., $\angle {b}_{k_1} \approx \angle {b}_{k_2}$ for all $k_1,k_2 \in \mathcal{K}$. In the sensing task since we are not interested in the absolute phase of CSI but only in its relative variation with $p$, it is reasonable to assume that $\angle {b}_{k} \approx 0$. For these assumptions, from \eqref{eqn_channel_resp} and \eqref{eqn_H_k_est}, we can estimate the static component of the channel as:
%\begin{align} \label{eqn_b_LoS_est}
%\bar{{b}}_k & \triangleq {\Bigg[ \frac{1}{P}\sum_{p \in \mathcal{P}} {|\bar{{h}}_{p,k}|}^2 \Bigg]}^{1/2}. 
%\end{align}
Assuming the estimate $\bar{b}_k$ is accurate for all $k \in \mathcal{K}$, from \eqref{eqn_Hk_gain_synchronized} the ML estimate of $\{{\tau}_p, {\psi}_p | p \in \mathcal{P} \}$ can further be obtained as:
\begin{eqnarray} \label{eqn_timing_err_est_method1}
\widehat{\tau}_p, \widehat{\psi}_p = \argmin_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \bigg\{ \sum_{k \in \mathcal{K}} {\Big|\bar{{h}}_{p,k} e^{{\rm j} (2 \pi f_k \tau + \psi)} - \bar{b}_k \Big|}^2 \bigg\} \nonumber \\
\equiv \argmax_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \bigg\{ \sum_{k \in \mathcal{K}} \mathrm{Re} \Big\{ e^{-{\rm j} (2 \pi f_k \tau + \psi)} {\bar{{h}}_{p,k}}^{*} \bar{{b}}_k \Big\} \bigg\}.
\end{eqnarray}
To further simplify the complexity of the line-search in \eqref{eqn_timing_err_est_method1}, we also have the following result:
\begin{lemma} \label{Th_method1_estimation_simpl}
In the strongly LoS scenario where ${b}_{k} = \bar{b}_k$ and $\gamma \approx 1$, the solutions to \eqref{eqn_timing_err_est_method1} are also the solutions of the weighted least-squares problem:
\begin{flalign}
& \widehat{\tau}_p, \widehat{\psi}_p = \argmin_{\tau, \psi} \bigg\{ \sum_{k \in \bar{\mathcal{K}}} \big|\omega_{p,k} \big| & \nonumber \\
& \qquad \qquad \qquad \Big[ 2\pi f_{k} (\tau-\bar{\tau}_p) + \psi - \mathscr{U} \big( \angle \omega_{p,k} \big) \Big]^2 \bigg\}, \!\!\!\!\! & \label{eqn_CPE_timing_simpl_method1} 
\end{flalign}
where $\omega_{p,k} = \bar{{{h}}}_{p,k}^{*} \bar{b}_{k} e^{-{\rm j} 2 \pi f_k \bar{\tau}_p} $, $\bar{\mathcal{K}} \triangleq \{k \in \mathcal{K} \big| |\bar{b}_k| > 0\}$, $\bar{\tau}_p$ is the estimate from \eqref{eqn_CPE_baseline2_tau}, $\widetilde{\mathscr{U}}(\cdot)$ is a `robust' phase unwrapping function computed as: 
\begin{flalign}
& \widetilde{\mathscr{U}} \big(\angle \omega_{p,k} \big) = \mathrm{mod}\bigg\{ \angle \omega_{p,k} - \mathscr{U} \bigg( \sum_{\ell \in \mathcal{L}(k)} \omega_{p,\ell} \bigg) + \pi, 2 \pi \bigg\} & \nonumber \\
& \qquad \qquad \qquad  - \pi + \mathscr{U} \bigg( \sum_{\ell \in \mathcal{L}(k)} \omega_{p,\ell} \bigg), &
\end{flalign}
and $\mathcal{L}(k)$ is a set that includes $k$, its $3$ preceding, and $3$ succeeding indices in sorted set $\bar{\mathcal{K}}$.
%ensure that phase-difference from preceding $4$ sub-carriers from $\bar{\mathcal{K}}$ satisfies 
%$$ \Big| \mathscr{U} \big(\angle \omega_{p,k} \big) - \mathscr{U}\Big( \angle \big( \sum_{k_1\in \mathcal{N}(k)} \omega_{p,k_1} \big) \Big) \Big| \leq \pi , $$
%and $\mathcal{N}(k) = \{k_1 \in \bar{\mathcal{K}} | \}$
\end{lemma}
\begin{proof}
See Appendix \ref{appdix0}.
\end{proof}
Note that the solution to the weighted least-squares problem can be found in closed-form, unlike \eqref{eqn_timing_err_est_method1}, thus reducing complexity. Using \eqref{eqn_timing_err_est_method1} or \eqref{eqn_CPE_timing_simpl_method1}, we propose a CPE and timing offset estimation approach for each CSI frame $p \in \mathcal{P}$, as shown in Algorithm \ref{Algo0}. 
\begin{remark}
Note that the baseline method \eqref{eqn_CPE_timing_baseline1} is an approximation of \eqref{eqn_CPE_timing_simpl_method1} obtained by setting $|{b}_k|= 1$ and $\bar{\tau}_p = 0$ and using conventional phase-unwrapping.
\end{remark}
%where $\mathcal{K}_{0} \subset \mathcal{K}$ is the subset of $\lfloor 0.8K \rfloor$ sub-carriers with the highest values of ${\|\widehat{{\mathbf{b}}}_k\|}^2$. 
%
\begin{algorithm}
\label{Algo0}
\caption{Strong LoS estimation of $\widehat{\tau}_p, \widehat{\psi}_p$}
\begin{algorithmic} 
\STATE Given: $\bar{{{h}}}_{p,k}$ for $p \in \mathcal{P}, k \in \mathcal{K}$
\FOR{$p \in \mathcal{P}$}
\STATE Compute $\bar{\tau}_p, \bar{\psi}_p$ from \eqref{eqn_CPE_timing_baseline2}.
\STATE{// Can be computed in parallel to improve speed.}
\ENDFOR
\FOR{$k \in \mathcal{K}$}
\STATE Compute $\bar{b}_k$ from \eqref{eqn_b_hat_est_LoS}.
\STATE{// Can be computed in parallel to improve speed.}
\ENDFOR
\FOR{$p \in \mathcal{P}$}
\STATE Calculate and save $\widehat{\tau}_p, \widehat{\psi}_p$ from \eqref{eqn_timing_err_est_method1} or \eqref{eqn_CPE_timing_simpl_method1}.
\STATE{// Can be computed in parallel to improve speed.}
\STATE{// For \eqref{eqn_CPE_timing_simpl_method1} we use $\bar{\mathcal{K}} = \{k \in \mathcal{K} {\big| |\bar{b}_k|}^2 > 0.1 \}$}
\ENDFOR 

\end{algorithmic}
\end{algorithm}
%

\subsection{Method 2: Estimation in strongly static channels} \label{subsec_timing_CFO_est}
In this method, we do not assume the channel response to be frequency flat, although we still assume $\gamma \approx 1$. Unfortunately, the joint ML estimation of $\{{\tau}_p, {\psi}_p | p \in \mathcal{P} \}$ is too computationally cumbersome. Therefore, we shall consider a greedy, causal estimation approach where ${\tau}_p, {\psi}_p$ for each $p \in \mathcal{P}$ are estimated using prior estimates of ${\psi}_q, \tau_q$ for all the past CSI frames $q \in \mathcal{Q}_p$ where $\mathcal{Q}_p \triangleq \{q \in \mathcal{P} | q < p\}$. For convenience, let us define $\widehat{\tau}_q, \widehat{\psi}_q$ as the estimates of ${\tau}_q, {\psi}_q$, respectively, for each $q \in \mathcal{Q}_p$. We then have the following result:
\begin{lemma} \label{Th_ML_estimation}
For any $p \in \mathcal{P}$, if the estimates $\widehat{\tau}_q, \widehat{\psi}_q$ are error-free for $q \in \mathcal{Q}_p$, i.e., if $\widehat{\tau}_q = {\tau}_q, \widehat{\psi}_q = {\psi}_q$, then the conditional ML estimates of $\tau_p, {\psi}_p$ are the solutions of:
\begin{subequations} \label{eqn_synch_error_est}
\begin{eqnarray}
\widehat{\tau_p} &=& \argmax_{|\tau| \leq \frac{\kappa T_{\rm s}}{K}} \bigg| \sum_{k \in \mathcal{K}} \sum_{q \in \mathcal{Q}_p} e^{-{\rm j} 2 \pi f_k \tau} {\bar{{{h}}}_{p,k}}^{*} \widehat{{{h}}}_{q,k} \bigg| \label{eqn_timing_err_est} \\
\widehat{\psi}_p &=& {\rm angle} \bigg\{ \sum_{k \in \mathcal{K}} \sum_{q \in \mathcal{Q}_p} e^{-{\rm j} 2 \pi f_k \widehat{\tau_p}} {\bar{{{h}}}_{p,k}}^{*} \widehat{{{h}}}_{q,k} \bigg\}, \label{eqn_CPE_est}
\end{eqnarray}
where $\widehat{{{h}}}_{q,k}$ is as defined in \eqref{eqn_Hk_synchronized}.
\end{subequations}
\end{lemma}
\begin{proof}
See Appendix \ref{appdix0}
\end{proof}
To further simplify the complexity of the line-search in \eqref{eqn_timing_err_est}, we also have the following lemma:
\begin{lemma} \label{Th_ML_estimation_simpl}
In the quasi-static channel scenario where $\gamma \approx 1$ if for any $p \in \mathcal{P}$ the conditions of Lemma \ref{Th_ML_estimation} are satisfied, then the conditional ML estimates of $\tau_p, {\psi}_p$ are the solutions of the weighted least-squares problem:
\begin{flalign}
& \widehat{\tau_p}, \widehat{\psi}_p = \argmin_{\tau, \psi} \bigg\{ \sum_{k \in \bar{\mathcal{K}}} |\omega_{p,k}| & \nonumber \\
& \qquad \qquad \qquad {\Big[ \big(2\pi f_{k} (\tau - \bar{\tau}_p) + \psi - \widetilde{\mathscr{U}} \big( \angle \omega_{p,k} \big) \Big]}^2 \bigg\}, \!\!\!\! & \label{eqn_CPE_timing_simpl} 
\end{flalign}
where $\omega_{p,k} = {\bar{{{h}}}_{p,k}}^{*} \big( \sum_{q \in \mathcal{Q}_p} \widehat{{{h}}}_{q,k} \big) e^{-{\rm j} 2 \pi f_{k} \bar{\tau}_p}$, $\widehat{{{h}}}_{q,k}$ is as defined in \eqref{eqn_Hk_synchronized} and $\bar{\mathcal{K}}, \bar{\tau}_p, \widetilde{\mathscr{U}}(\cdot)$ are as defined in Lemma \ref{Th_method1_estimation_simpl}.
\end{lemma}
\begin{proof}
Proof is similar to Lemma \ref{Th_method1_estimation_simpl}.
\end{proof}
%
Note that the solution to the weighted least-squares problem can be found in closed-form, thus avoiding the search complexity of \eqref{eqn_timing_err_est}. 
%A further reduction in complexity can be obtained by ignoring the weights as:
%\begin{eqnarray}
%\widehat{\tau_p}, \widehat{\psi}_p = \argmin_{\tau, \psi} \bigg\{ \sum_{k \in \mathcal{K}} {\Big( \big(2\pi f_{k} \tau + \psi - \mathscr{U}[\angle \omega_{p,k}] \Big)}^2 \bigg\}. \label{eqn_CPE_timing_simpl_2} 
%\end{eqnarray}
Using \eqref{eqn_synch_error_est} or \eqref{eqn_CPE_timing_simpl}, we propose a CPE and timing offset estimation approach for each CSI frame $p \in \mathcal{P}$, as shown in Algorithm \ref{Algo1}. Since the number of past samples $q < p$ is small for small values of $p$, we use the approach in Algorithm \ref{Algo0} for $p < P/10$ to minimize error accumulation. 
\begin{remark}
Intuitively, the algorithm works sequentially such that when dealing with the estimation for frame $p$, CPE and timing errors for all the chronologically preceding CSI frames have already been estimated. The algorithm then searches over the possible phase and timing error corrections for frame $p$ to find the one that ensures the highest correlation of the corrected CSI $\widehat{{{h}}}_{p,k}$ to its preceding corrected CSIs $\widehat{{{h}}}_{q,k}$.
\end{remark}
%
\begin{algorithm}
\label{Algo1}
\caption{Forward-pass for $\widehat{\tau}_p, \widehat{\psi}_p$}
\begin{algorithmic} 
\STATE Given: $\bar{{{h}}}_{p,k}$ for $p \in \mathcal{P}, k \in \mathcal{K}$
\FOR{$p \in \mathcal{P}$}
\STATE Compute $\bar{\tau}_p, \bar{\psi}_p$ from \eqref{eqn_CPE_timing_baseline2}.
\STATE{// Can be computed in parallel to improve speed.}
\ENDFOR
\FOR{$k \in \mathcal{K}$}
\STATE Compute $\bar{b}_k$ from \eqref{eqn_b_hat_est_LoS}.
\STATE{// Can be computed in parallel to improve speed.}
\ENDFOR
\FOR{$p=0:1:\lfloor P/10 \rfloor$}
\STATE Calculate and save $\widehat{\tau}_p, \widehat{\psi}_p$ from  \eqref{eqn_CPE_timing_simpl_method1}.
\STATE Calculate $\widehat{{{h}}}_{p,k}$ from \eqref{eqn_Hk_synchronized}.
%\STATE{Calculate and save $\widehat{\tau_p}, \widehat{\psi}_p$ from Algorithm \ref{Algo0} with \eqref{eqn_CPE_timing_simpl_method1}.}
\ENDFOR
\FOR{$p=(\lfloor P/10 \rfloor+1):1:(P-1)$}
\STATE Define $\mathcal{Q}_p = \big\{ q \in \mathcal{P} \big| q < p \big\}$
%\ENDIF
\STATE Calculate and save $\widehat{\tau}_p, \widehat{\psi}_p$ from \eqref{eqn_synch_error_est} or \eqref{eqn_CPE_timing_simpl}.% or \eqref{eqn_CPE_timing_simpl_2}.
\STATE Calculate $\widehat{{{h}}}_{p,k}$ from \eqref{eqn_Hk_synchronized}.
%\IF{$p == P-1$}
%\STATE Calculate and save $\widehat{\boldsymbol{\mathcal{B}}}_{k}$ from \eqref{eqn_chan_static_est}
%\ENDIF
\ENDFOR 
\STATE{// For \eqref{eqn_CPE_timing_simpl_method1} and \eqref{eqn_CPE_timing_simpl} we use $\bar{\mathcal{K}} = \{k \in \mathcal{K} \big| {|\bar{b}_k|}^2 > 0.1 \}$}
\end{algorithmic}
\end{algorithm}
%
Note that one lacuna of Algorithm \ref{Algo1} is that the estimation at CSI frame $p$ in \eqref{eqn_synch_error_est} only relies on the preceding CSI frames $q < p$. This can cause large errors for the first few CSI frames since there isn't sufficient history, and thus we had to resort to Algorithm \ref{Algo0} for $p < P/10$. To further improve the estimates obtained with Algorithm \ref{Algo1}, an (optional)  backward-pass can also be used as shown in Algorithm \ref{Algo2}, where we redefine $\mathcal{Q}_p = \{q \in \mathcal{P} | q > p\}$ to use the future CSI frames to estimate the CPE and timing offset of the current CSI frame.
%
\begin{algorithm}
\label{Algo2}
\caption{Backward-pass for $\widehat{\tau}_p, \widehat{\psi}_p$}
\begin{algorithmic} 
\STATE Obtain $\widehat{\tau}_p, \widehat{\psi}_p$ for $p \in \mathcal{P}$ from Algorithm \ref{Algo1} with \eqref{eqn_synch_error_est} or \eqref{eqn_CPE_timing_simpl}.% or \eqref{eqn_CPE_timing_simpl_2}.
\FOR{$p=\lfloor P/2 \rfloor:(-1):0$}
\STATE Redefine $\mathcal{Q}_p = \{q \in \mathcal{P} | q > P/2\}$
\STATE Re-calculate and save $\widehat{\tau}_p, \widehat{\psi}_p$ from \eqref{eqn_synch_error_est} or \eqref{eqn_CPE_timing_simpl}.% or \eqref{eqn_CPE_timing_simpl_2}.
%\IF{$p == 0$}
%\STATE Re-calculate and save $\widehat{\boldsymbol{\mathcal{B}}}_{k}$ from \eqref{eqn_chan_static_est}
%\ENDIF
\ENDFOR
\STATE{// For \eqref{eqn_CPE_timing_simpl} we use $\bar{\mathcal{K}} = \{k \in \mathcal{K} \big| {|\bar{b}_k|}^2 > 0.1 \}$}
\end{algorithmic}
\end{algorithm}
%
Finally, using either Algorithm \ref{Algo0} or Algorithm \ref{Algo1} or using both Algorithms \ref{Algo1} and \ref{Algo2}, we obtain the CPE and timing error estimates: $\widehat{\tau}_p, \widehat{\psi}_p$ for all $p \in \mathcal{P}, k \in \mathcal{K}$ and compute the corrected CSI $\widehat{{{h}}}_{p,k}$ as in  \eqref{eqn_Hk_synchronized} for performing the sensing operations. 
%\begin{eqnarray} \label{eqn_Hk_synchronized}
%\widehat{\boldsymbol{\mathcal{H}}}_k(p T_{\rm rep}) \triangleq  \overline{\boldsymbol{\mathcal{H}}}_k(p T_{\rm rep}) e^{-{\rm j} [2 \pi f_k \widehat{\Delta \tau_p} - \widehat{\psi}_p]}
%\end{eqnarray}
%In next section, we shall focus on minimizing the impact of the interference from other MPCs and the channel noise on the desired channel response corresponding to $\ell = 0$.
%
%% Figure environment removed

\section{Evaluation Results} \label{sec_eval_results}
For evaluations, we use stationary WiFi TX and RX operating on a $20$MHz channel at $f_{\rm c} = 5.2$GHz (channel $40$ of the $5$ GHz ISM band). The transmission is via OFDM modulation with a symbol duration $T_{\rm s} = 3.2 \mu$s, cyclic prefix duration $T_{\rm cp}=0.8\mu$s and either $K=64$ sub-carriers (for IEEE 802.11ac CSI) or $K=256$ sub-carriers (for 802.11ax CSI). For the evaluations, we use both a combination of simulated CSI data and real-world CSI data, as explained below. 

%For the RX, we use another Intel AX 210 WiFi device with $N=2$ receive antennas. 
%For collecting the CSI at the RX, we use the ACK frames transmitted by the TX (in response to null data packet frames sent by the RX) that are transmitted at a $T_{\rm rep} = 50$ms periodicity. Although the CSI cleaning can also be performed after each CSI sample is acquired, here we consider batch processing where CSI cleaning is performed after every $1$ sec, while using a CSI frame window of $P=$
%$P=200$ CSI frames (corresponding to a $10$ sec interval) are accumulated and processed together. Unless explicitly stated, the parameters used for the simulated CSI is same as the aforementioned values. 

\subsection{Distribution of gain and phase errors} \label{subsec_CSI_gain_phase_err_dist}
We first present an analysis of CSI gain and phase errors in a real-world WiFi system under a fully static channel. For this, we use a single-antenna TX that transmits NDP frames every $T_{\rm rep}=50$ms to an RX. We consider two types of RXs: (i) an Intel AX 210 WiFi module and (ii) a Google Nexus 6 phone with a BCM4358 WiFi chip, each with two antennas. 

First, we present a sample measurement of the uncompensated CSI powers $\Gamma_{p}$ (see \eqref{eqn_gamma_define}) for the two RXs in Figs. \ref{Fig_gain_intel} and \ref{Fig_gain_nexus}. For same measurement, we also plot the incremental CSI power  $\Delta \widetilde{\Gamma}_{p}$ (see \eqref{eqn_delta_gamma_defn}) in Figs.~\ref{Fig_gainDiff_intel} and \ref{Fig_gainDiff_nexus}. As can be seen from the results, the clusters in $\Delta \widetilde{\Gamma}_{p}$ are much more prominent than $\widetilde{\Gamma}_{p}$. This is due to the large-scale gain (see Section \ref{subsec_AGC_gain_dist}). Secondly, we also observe from Fig.~\ref{Fig_gainDiff_intel} that the AGC gain indeed increases in multiples of a step size $\lambda$ (as exploited in Section \ref{subsec_gain_uniformG}). %Finally, we also observe from Fig.~\ref{Fig_gainDiff_nexus} that the AGC step size can be different for each RX antenna. 
%
% Figure environment removed
%

Since it is hard to know the ground truth values phase errors of $\tau_p, \psi_p$ between a TX and RX, here we evaluate the distribution of $\widehat{\tau}_p, \widehat{\psi}_p$ obtained using Algorithm \ref{Algo2}, with \eqref{eqn_CPE_timing_simpl}.\footnote{The results have also been found to be similar when using the other phase error estimation algorithms.} To ensure the estimates are accurate, i.e., $ \widehat{\tau}_p \approx \tau_p, \widehat{\psi}_p \approx \psi_p$, the measurements are made in a high signal-to-noise ratio (SNR), strongly LoS channel. The marginal distributions of $\widehat{\tau}_p$ and $\widehat{\psi}_p$ are depicted in Figs.~\ref{Fig_timing_pdf} and \ref{Fig_phase_pdf}, which verifies that the assumption of uniform marginal distributions for $\widehat{\tau}_p$ and ${\psi}_p$ is reasonably accurate. The cross-covariance coefficients of $\widehat{\tau}_p, \widehat{\psi}_p$ for two CSI frames $p$ and $p-a$ are depicted in Figs.~\ref{Fig_timing_crosscov} and ~\ref{Fig_phase_crosscov}, as a function of $a$. As can be seen from the results, the timing and phase errors for two CSI frames are uncorrelated for $T_{\rm rep} \geq 50$ms, which justifies the modeling used in Section \ref{subsec_timing_CFO_dist}.
%
% Figure environment removed
%

\subsection{Estimation performance in simulated channels} \label{subsec_eval_simulated}
Since knowing the true values of $g_p, \tau_p, \psi_p$ between a TX and RX is difficult in a real-world setting, we compare the performance of the different algorithms over $2000$ realizations of simulated channels. For the simulations, we use $T_{\rm rep} = 100$ms, $\mathcal{P} = \{0,1,...,299\}$ and $\mathcal{K} = \{0,1,...,255\}$. In each realization, $h_{p,k}$ is generated using \eqref{eqn_channel_resp}, where the static component $b_{k}$ is generated using the 802.11ax Model-C channel model, and for the dynamic component we consider 2 cases: 
\begin{enumerate}
\item[(i)] $d_{p,k} \sim \mathcal{CN}(0, 1-\gamma)$ is i.i.d. for each $p,k$. 
\item[(ii)] $d_{p,k} = \alpha_p e^{-{\rm j} 2 \pi f_k (\tau+\tau_0)}$, where $\tau \sim \mathrm{Uni}[0,300ns)$, $\tau_0$ is delay of LoS path in $b_{k}$ and $\alpha_p$ is a complex Gaussian process of variance $1-\gamma$ with the Doppler power spectrum having a non-zero support on $[0.5, 1]$ Hz. 
\end{enumerate}
%
Among impairments, for the large-scale gain, we use $g^{(1)}_p$ as a real Gaussian process with standard deviation $0.2$ dB and a Doppler power spectrum with non-zero support on $[0, 0.1]$ Hz. For AGC gain, we use $g^{(2)}_p \in \{-0.5, 0, 0.5\}$ with probabilities of $\{0.2, 0.6, 0.2\}$, respectively. For phase errors, we model $\tau_p, \psi_p$ to be i.i.d. for each $p \in \mathcal{P}$ with marginal distributions $\tau_p \sim \mathrm{Uni}[0, {10}^{-7})$ and $\psi_p \sim \mathrm{Uni}[-\pi,\pi)$.
%
For quantifying the performance of the algorithms, we define the correlation coefficient between $d_{p,k}$ and the dynamic component of cleaned CSI $\widehat{h}_{p,k}$ as:
\begin{eqnarray}
\chi \triangleq \frac{{\Big| \sum_{p \in \mathcal{P}} \sum_{k \in \mathcal{K}} {\big(\widehat{h}_{p,k} - \widehat{b}_k \big)}^{*} d_{p,k} e^{{\rm j} 2 \pi f_k \tau} \Big|}^2}{(1-\gamma) K P{\Big(\sum_{p \in \mathcal{P}} \sum_{k \in \mathcal{K}} {\big|\widehat{h}_{p,k} - \widehat{b}_k \big|}^2 \Big)} } ,
\end{eqnarray}
%SNR metric for reconstructing $d_{p,k}$ from $\widehat{h}_{p,k}$ as:
%\begin{eqnarray}
%\textrm{SNR} = {\left[ \frac{(1-\gamma) K P{\Big(\sum_{p \in \mathcal{P}} \sum_{k \in \mathcal{K}} {\big|\widehat{h}_{p,k} - \widehat{b}_k \big|}^2 \Big)} }{{\Big| \sum_{p \in \mathcal{P}} \sum_{k \in \mathcal{K}} {\big(\widehat{h}_{p,k} - \widehat{b}_k \big)}^{*} d_{p,k} \Big|}^2} - 1\right]}^{-1},
%\end{eqnarray}
where $\widehat{b}_k \triangleq \sum_{p \in \mathcal{P}} \widehat{h}_{p,k} / P$ is the static component of cleaned CSI and $$\tau = \max_{\tau} \bigg| \sum_k b_k \widehat{b}_k^{*} e^{{\rm j} 2 \pi f_k \tau} \bigg|,$$ is the timing offset between the true CSI and cleaned CSI. Note that $\chi^2/(1-\chi^2)$ is representative of the SNR in estimating $d_{p,k}$ from cleaned CSI $\widehat{h}_{p,k}$.

The post-cleaning SNR for different gain error correction methods under ideal phase error compensation, i.e., $\widehat{\tau}_p = \tau_p$ and $\widehat{\psi}_p = \psi_p$ is depicted in Fig.~\ref{Fig_compareGainAlgos_vs_gamma} and their computation time is tabulated in Table~\ref{Table_compute_time}. %As can be seen, the proposed method Algorithm \ref{Algo4} outperforms all other methods for $\gamma \leq 0.95$. %Note that for $d_{p,k}$ of type (i), baseline algorithm \eqref{eqn_baseline_normPower} also yields good $\chi$, which is because there is negligible variation in CSI power $\Gamma_p$ due to the desired signal $d_{p,k}$. 
As can be seen, at $\gamma=0.9$, Algorithm \ref{Algo4} outperforms both baseline methods by $\geq 100$\% (for ${d}_{p,k}$ of type (i)) and by $40$\% (for ${d}_{p,k}$ of type (ii)). However, for $\gamma > 0.95$, we observe that \eqref{eqn_baseline_normPower} yields the best performance. This is because although the estimation of $g^{(2)}_p$ is accurate, the residual error in estimating $g^{(1)}_p$ in Algorithm \ref{Algo4} dominates over the sensing signal for $\gamma > 0.95$. Under such conditions, completely ignoring CSI power variations (as done by \eqref{eqn_baseline_normPower}) yields the best performance.\footnote{The exact transition point $\gamma = 0.95$ is of course subjective, and increases as we include additive channel noise to \eqref{eqn_H_k_est}.}
%${d}_{p,k}$ becomes so weak that the noise in CSI power dominates over the sensing signal, and so ignoring the CSI power variation, i.e., \eqref{eqn_baseline_normPower} yields the best performance. 
%The reason for the dip in its performance for $\gamma > 0.95$ is due to the use of a simple moving average filter in Algorithm \ref{Algo4} that can't fully filter out $g^{(1)}_p$. 
We also observe that Algorithm \ref{Algo4} also has a slightly lower computation time than \eqref{eqn_baseline_DBscan} and Algorithm \ref{Algo5}, since its complexity only scales linearly with $P$, as shown in Table \ref{Table_compute_time}. 
%
% Figure environment removed
%

The post-cleaning SNR of different phase error correction methods under ideal gain error compensation, i.e., $\widehat{g}_p = g_p$ is depicted in Fig.~\ref{Fig_comparePhaseAlgos_vs_gamma} and their computation time is tabulated in Table~\ref{Table_compute_time}. As can be seen from the results, all the proposed algorithms outperform the baseline methods \eqref{eqn_CPE_timing_baseline1} and \eqref{eqn_CPE_timing_baseline2}. Among the proposed algorithms, the ML estimators \eqref{eqn_timing_err_est_method1} and \eqref{eqn_synch_error_est} yield the best performance\footnote{The dip in their performance for $\gamma \geq 0.95$ is due to finite search resolution for $\tau$ in \eqref{eqn_timing_err_est_method1} and \eqref{eqn_synch_error_est}.},
but they are too computationally cumbersome as shown in Table~\ref{Table_compute_time}. Taking into consideration both performance and computation speed, we conclude that Algorithm \ref{Algo0} with \eqref{eqn_CPE_timing_simpl_method1} or Algorithm \ref{Algo1} with \eqref{eqn_CPE_timing_simpl} yield the best trade-off between performance and computation time. In fact at $\gamma = 0.9$, their performance is at par with the ML estimators, and they outperform both baselines by $> 1000$\% (for ${d}_{p,k}$ of type (i)) and $> 200$\% (for ${d}_{p,k}$ of type (ii)), respectively.
%
% Figure environment removed
%
%
\begin{table}[h!]
\centering
\caption{Computation time (in msec) per batch of $P=300$ CSI frames and computation complexity for the proposed methods.} \label{Table_compute_time}
\renewcommand{\arraystretch}{1.5} % Default value: 1
\begin{tabular}{| l | c | c |} 
 \hline 
Methods & Mean Time (ms) & Computation Complexity\tablefootnote{For computation complexity, we use $I$ to indicate number of iterations where applicable.} \\
\hline
Baseline: \eqref{eqn_baseline_normPower} & \color[rgb]{0,0,1} $4.27$ & $\mathrm{O}(PK)$\\
\hline
Baseline: \eqref{eqn_baseline_DBscan} & \color[rgb]{0.1,0,0.9} $12.65$ & $\mathrm{O}(PK + P \log P)$ \\
\hline
Algorithm \ref{Algo5} & \color[rgb]{0.1,0,0.9} $13.75$ & $\mathrm{O}(PK + P \log P)$\\
\hline
Algorithm \ref{Algo4} & \color[rgb]{0.1,0,0.9} $10.98$ & $\mathrm{O}(PK + P I)$ \\
\hline
Baseline: \eqref{eqn_CPE_timing_baseline1} & \color[rgb]{0.2,0,0.8} $24.7$ & $\mathrm{O}(PK)$ \\
\hline
Baseline: \eqref{eqn_CPE_timing_baseline2} & \color[rgb]{0.1,0,0.9} $9.0$ & $\mathrm{O}(PK)$ \\
\hline
Algorithm \ref{Algo0} + \eqref{eqn_timing_err_est_method1} & \color[rgb]{0.7,0,0.3} $443.6$ & $\mathrm{O}(PKI)$ \\
\hline
Algorithm \ref{Algo0} + \eqref{eqn_CPE_timing_simpl_method1} & \color[rgb]{0.3,0,0.7} $40.6$ & $\mathrm{O}(PK)$ \\
\hline
Algorithm \ref{Algo1} + \eqref{eqn_synch_error_est} & \color[rgb]{0.7,0,0.3} $450.5$ & $\mathrm{O}(PKI)$ \\
\hline
Algorithm \ref{Algo1} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0.3,0,0.7} $44.5$ & $\mathrm{O}(PK)$ \\
\hline
Algorithm \ref{Algo2} + \eqref{eqn_synch_error_est} & \color[rgb]{0.9,0,0.1} $669.2$ & $\mathrm{O}(PKI)$ \\
\hline
Algorithm \ref{Algo2} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0.4,0,0.6} $61.0$ & $\mathrm{O}(PK)$ \\
\hline
\end{tabular}
\end{table}
%

\subsection{Application to respiration rate estimation} \label{subsec_eval_real}
%
% Figure environment removed
%
In this section, we validate the performance of the proposed CSI preprocessing algorithms in a real-world sensing application of respiration rate monitoring. In this experiment, a stationary WiFi TX and RX are setup in a room along with a subject whose respiration rate has to be monitored. The dimensions of the room are $7{\rm m} \times 4 {\rm m}$, and an illustration of the setup is depicted in Fig.~\ref{Fig_respiration_setup}. The TX transmits WiFi packets (beacons) on channel $155$ of the $5$ GHz ISM band with $20$ MHz bandwidth and $K=64$ sub-carriers at intervals of $T_{\rm rep} = 100$ms. In each measurement episode $(i)$, $P=500$ CSI samples are collected (i.e., $50$ secs). In total, $75$ such episodes are considered, spanning different configurations of TX, RX, and subject locations. In each episode, the obtained CSI $\{\widetilde{h}_{p,k} | p \in \mathcal{P}, k \in \mathcal{K} \}$ is preprocessed using one of the gain and phase correction methods to obtain $\{\widehat{h}_{p,k} | p \in \mathcal{P}, k \in \mathcal{K} \}$ and then the Doppler power spectrum is estimated as:
\begin{eqnarray} \label{eqn_doppler_pow_metric}
\mathscr{H}(\nu) = \sum_{k \in \mathcal{K}} {\bigg| \sum_{p \in \mathcal{P}} \widehat{h}_{p,k} e^{-{\rm j} 2 \pi \nu p T_{\rm rep}} \bigg|}^2 , 
\end{eqnarray}
for $\nu = \{0.1:0.02:0.5\}$ Hz. For each episode $(i)$, the estimation SNR is computed as: 
\begin{eqnarray}
\mathrm{SNR}(i) = \Bigg( \sum_{|\nu - \nu_0| \leq 0.02} \mathscr{H}(\nu) \Bigg) \Bigg/ \Bigg( \sum_{|\nu - \nu_0| > 0.02} \mathscr{H}(\nu) \Bigg) , \nonumber
\end{eqnarray}
where $\nu_{0}$ is the ground-truth respiration rate (in Hz) of the subject as measured with a force belt. The median SNR across the $75$ episodes for different combinations of gain and phase compensation methods is tabulated in Table~\ref{Table_breathing}. 
%%
%\begin{table}[h!]
%\centering
%\caption{Breathing rate SNR under different CSI preprocessing methods.} \label{Table_breathing}
%\renewcommand{\arraystretch}{1.5} % Default value: 1
%\begin{tabular}{| c | c | c | c | c |} 
%\hline 
%\textbf{Mean SNR} & \multicolumn{4}{ c |}{ Gain correction methods $\rightarrow$ } \\
%\hline 
%Phase method $\downarrow$ & Eqn.\eqref{eqn_baseline_normPower} & Eqn.\eqref{eqn_baseline_DBscan} & Algo.\ref{Algo5} & Algo.\ref{Algo4} \\
%\hline
%Eqn.\eqref{eqn_CPE_timing_baseline1} & \color[rgb]{0.6,0,0.4} $0.777$ & \color[rgb]{0.8,0,0.2} $0.673$ & \color[rgb]{0.8,0,0.2} $0.661$ & \color[rgb]{0.8,0,0.2} $0.698$ \\
%\hline
%Eqn.\eqref{eqn_CPE_timing_baseline2} & \color[rgb]{0.4,0,0.6} $0.833$ & \color[rgb]{0.6,0,0.4} $0.791$ & \color[rgb]{0.6,0,0.4} $0.786$ & \color[rgb]{0.3,0,0.7} $0.8$ \\
%\hline
%Algo.\ref{Algo0} + \eqref{eqn_timing_err_est_method1} & \color[rgb]{0.2,0,0.8} $0.922$ & \color[rgb]{0.6,0,0.4} $0.788$ & \color[rgb]{0.6,0,0.4} $0.77$ & \color[rgb]{0.3,0,0.7} $0.822$ \\
%\hline
%Algo.\ref{Algo0} + \eqref{eqn_CPE_timing_simpl_method1} & \color[rgb]{0,0,1} $0.925$ & \color[rgb]{0.6,0,0.4} $0.789$ & \color[rgb]{0.6,0,0.4} $0.772$ & \color[rgb]{0.3,0,0.7} $0.823$ \\
%\hline
%Algo.\ref{Algo1} + \eqref{eqn_synch_error_est} & \color[rgb]{0.2,0,0.8} $0.922$ & \color[rgb]{0.6,0,0.4} $0.788$ & \color[rgb]{0.6,0,0.4} $0.771$ & \color[rgb]{0.3,0,0.7} $0.822$ \\
%\hline
%Algo.\ref{Algo1} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0,0,1} $0.925$ & \color[rgb]{0.6,0,0.4} $0.789$ & \color[rgb]{0.6,0,0.4} $0.772$ & \color[rgb]{0.3,0,0.7} $0.834$ \\ 
%\hline
%Algo.\ref{Algo2} + \eqref{eqn_synch_error_est} & \color[rgb]{0.2,0,0.8} $0.922$ & \color[rgb]{0.6,0,0.4} $0.788$ & \color[rgb]{0.6,0,0.4} $0.77$ & \color[rgb]{0.3,0,0.7} $0.822$ \\
%\hline
%Algo.\ref{Algo2} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0,0,1} $0.925$ & \color[rgb]{0.6,0,0.4} $0.789$ & \color[rgb]{0.6,0,0.4} $0.772$ & \color[rgb]{0.4,0,0.6} $0.823$ \\
%\hline
%\end{tabular}
%\end{table}
%%
%%
\begin{table}[h!]
\centering
\caption{Breathing rate SNR under different CSI preprocessing methods.} \label{Table_breathing}
\renewcommand{\arraystretch}{1.5} % Default value: 1
\begin{tabular}{| c | c | c | c | c |} 
\hline 
\textbf{Median SNR} & \multicolumn{4}{ c |}{ Gain correction methods $\rightarrow$ } \\
\hline 
Phase method $\downarrow$ & Eqn.\eqref{eqn_baseline_normPower} & Eqn.\eqref{eqn_baseline_DBscan} & Algo.\ref{Algo5} & Algo.\ref{Algo4} \\
\hline
Eqn.\eqref{eqn_CPE_timing_baseline1} & \color[rgb]{0.9,0,0.1} $0.591$ & \color[rgb]{0.8,0,0.2} $0.611$ & \color[rgb]{0.8,0,0.2} $0.614$ & \color[rgb]{0.8,0,0.2} $0.615$ \\
\hline
Eqn.\eqref{eqn_CPE_timing_baseline2} & \color[rgb]{0.6,0,0.4} $0.663$ & \color[rgb]{0.7,0,0.3} $0.633$ & \color[rgb]{0.8,0,0.2} $0.616$ & \color[rgb]{0.6,0,0.4} $0.634$ \\
\hline
Algo.\ref{Algo0} + \eqref{eqn_timing_err_est_method1} & \color[rgb]{0.2,0,0.8} $0.795$ & \color[rgb]{0.6,0,0.4} $0.674$ & \color[rgb]{0.6,0,0.4} $0.651$ & \color[rgb]{0.3,0,0.7} $0.737$ \\
\hline
Algo.\ref{Algo0} + \eqref{eqn_CPE_timing_simpl_method1} & \color[rgb]{0,0,1} $0.799$ & \color[rgb]{0.6,0,0.4} $0.675$ & \color[rgb]{0.6,0,0.4} $0.652$ & \color[rgb]{0.3,0,0.7} $0.739$ \\
\hline
Algo.\ref{Algo1} + \eqref{eqn_synch_error_est} & \color[rgb]{0.2,0,0.8} $0.795$ & \color[rgb]{0.6,0,0.4} $0.674$ & \color[rgb]{0.6,0,0.4} $0.651$ & \color[rgb]{0.3,0,0.7} $0.738$ \\
\hline
Algo.\ref{Algo1} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0,0,1} $0.799$ & \color[rgb]{0.6,0,0.4} $0.675$ & \color[rgb]{0.6,0,0.4} $0.652$ & \color[rgb]{0.3,0,0.7} $0.739$ \\ 
\hline
Algo.\ref{Algo2} + \eqref{eqn_synch_error_est} & \color[rgb]{0.2,0,0.8} $0.795$ & \color[rgb]{0.6,0,0.4} $0.674$ & \color[rgb]{0.6,0,0.4} $0.651$ & \color[rgb]{0.3,0,0.7} $0.737$ \\
\hline
Algo.\ref{Algo2} + \eqref{eqn_CPE_timing_simpl} & \color[rgb]{0,0,1} $0.799$ & \color[rgb]{0.6,0,0.4} $0.675$ & \color[rgb]{0.6,0,0.4} $0.652$ & \color[rgb]{0.3,0,0.7} $0.739$ \\
\hline
\end{tabular}
\end{table}
%
As can be seen from the results, the proposed phase-correction methods beat both the baseline methods by $> 20$\% in median SNR. However, for gain correction, we see that the baseline method \eqref{eqn_baseline_normPower} yields the best performance, followed by our proposed method in Algorithm \ref{Algo4}. The superior performance of \eqref{eqn_baseline_normPower} is because for this exemplary sensing task we have $\gamma > 0.99$ where, as also observed in Section \ref{subsec_eval_simulated}, ignoring CSI power variation yields the best performance. Thus, these observations are well aligned with our simulation results. 
%for poor performance of gain correction is: (i) very little bit of the respiration signal is encoded in the CSI power and hence CSI power mainly contributes noise, (ii) Eqn.\eqref{eqn_doppler_pow_metric} is not an optimal metric for estimating $\nu_0$, and (iii) respiration rate estimation is not exactly aligned with the goal of the paper, i.e., recovering the actual sensing signal.

\section{Conclusion} \label{sec_conclusions}
This paper develops a mathematical model for the gain and phase errors in WiFi CSI and proposes several algorithms for resolving the gain and phase errors. The analysis of the real-world data shows that the gain errors can be treated as the combination of a slow-changing large-scale gain and a fast-changing AGC gain that attains a value from a discrete uniform grid. It is shown that for the true channel, the CSI power is approximately Gaussian distributed in the dB scale, and its ML estimate from the observed CSI is wrapped Gaussian distributed, due to the ambiguity introduced by the AGC gain. This can be leveraged to remove the gain errors, as shown in Algorithm \ref{Algo4}. 
%
The analysis of real-world data also shows that the CSI phase errors for packets spaced $\geq 50$ms apart are independently distributed. It is also shown that the conditional ML estimation of the phase errors can be simplified to a linear weighted least-squares estimation problem under certain simplifying assumptions. 
%
Simulations under standard-compliant channel models show that when the sensing signal is not i.i.d., cleaning the CSI is more difficult, and hence, choosing a good preprocessing algorithm is important. Results also show that the proposed theoretically justified gain-correction and phase-correction algorithms, achieve $40$\% and $200$\% higher estimation SNR, respectively, compared to baseline methods at $\gamma=0.9$, without significantly increasing computation complexity. We also conclude that when the sensing signal is very weak, i.e., $\gamma > 0.95$, ignoring the gain variation yields the best performance.
%
The proposed algorithms are also applied in a real-world test bed for performing respiration rate monitoring using CSI. The results show that the proposed phase-correction methods can indeed improve the estimation SNR by $20$\% compared to baseline methods, while for gain-correction, the method in \eqref{eqn_baseline_normPower} works best (since we have $\gamma > 0.99$ in this test).

\begin{appendices}
\section{} \label{appdix1p5}
\begin{proof}[Proof of Lemma \ref{remark1}]
From \eqref{eqn_channel_resp}, note that:
\begin{eqnarray}
\beta_p \triangleq \frac{2}{(1-\gamma)} \sum_{k \in \mathcal{K}} {| {b}_{k} + {d}_{p,k} |}^2,
\end{eqnarray}
is a standard, non-central Chi-squared distributed random variable with a non-centrality parameter of $\frac{2 K \gamma}{(1-\gamma)}$ and $2K$ degrees of freedom, and is independent for each $p$. Correspondingly, its mean and variance are:
\begin{eqnarray}
\mu_{\beta} = \frac{2K}{1-\gamma}, \ \sigma_{\beta}^2 = 4K \frac{1 + \gamma}{1-\gamma}. \nonumber
\end{eqnarray}
In other words, variance of $(1-\gamma) \beta_p \rightarrow 0$ as $\gamma \rightarrow 1$. Correspondingly from \eqref{eqn_gamma_true_define} we have:
\begin{eqnarray}
\Gamma_p &=& 10 \times \log_{10} \big[(1-\gamma) \beta_p \big/ 2K \big] \nonumber \\
&\approx & \frac{5 [ (1-\gamma) \beta_p - 2K]}{K} \nonumber \\
&=&  10\sqrt{\frac{1 - \gamma^2}{K}}\frac{(\beta_p - \mu_{\beta})}{\sigma_{\beta}} \label{eqn_gamma_temp} 
\end{eqnarray}
where the second step follows by using a first-order Taylor expansion about $\beta_p = \mu_p$, which is accurate for $\gamma \approx 1$. It is well known that either as $2K \rightarrow \infty$ or $2 K \gamma \big/ (1-\gamma) \rightarrow \infty$, $(\beta_p - \mu_{\beta})/\sigma_{\beta} \rightarrow \mathcal{N}(0,1)$ \cite{Muirhead1982}. In our case since number of sub-carriers $K \gg 1$ and also $\gamma \approx 1$, both conditions for convergence of $\beta_p$ are satisfied and hence from \eqref{eqn_gamma_temp} we have that $\Gamma_p$ is approximately Gaussian distributed with a mean of $0$ and a small variance $100 (1 - \gamma^2)\big/K$.
% Correspondingly using Taylor expansion:
%When $\gamma \approx 1$ we have using \eqref{eqn_channel_resp}:
%\begin{eqnarray}
%\Gamma_{p} &=& 10 \log_{10} \left[ \frac{1}{K} \sum_{k \in \mathcal{K}} {| {b}_{k} + {d}_{p,k} |}^2 \right] \nonumber \\
%& \stackrel{(1)}{\approx} & \log_{10} \bigg[ \sum_{k \in \mathcal{K}} \Big( {| {b}_{k}|}^2 \big/{K} + (1-\gamma) \Big) \bigg] \nonumber \\
%&& + \frac{ \sum_{k \in \mathcal{K}} \big[ {| {d}_{p,k}|}^2 - (1-\gamma) + 2 \mathrm{Re}\left\{ {b}_{k}^{*} {d}_{p,k} \right\} \big] }{ \sum_{k \in \mathcal{K}} \big( { | {b}_{k}|}^2 + K(1-\gamma) \big)}, \nonumber \\
%& \stackrel{(2)}{=} & \sum_{k \in \mathcal{K}} {| {d}_{p,k}|}^2 - K(1-\gamma) 2 \mathrm{Re}\left\{ {b}_{k}^{*} {d}_{p,k} \right\} \big/ K \\
%\label{eqn_gamma_gaussian_dist}
%\end{eqnarray}
%where $\stackrel{(1)}{\approx}$ is obtained by performing a Taylor expansion and $\stackrel{(2)}{\approx}$ follows from the distribution of ${b}_{k}, {d}_{p,k}$ (see Section \ref{sec_chan_model}). Finally, computing the mean and variance of \eqref{eqn_gamma_gaussian_dist} we obtain Lemma \ref{remark1}.
\end{proof}

\begin{proof}[Proof of Lemma \ref{remark2}]
Note that from \eqref{eqn_H_k_est}, \eqref{eqn_gamma_define}, \eqref{eqn_gamma_true_define} and the AGC gain model, we can write: 
\begin{eqnarray}
\widetilde{\Gamma}_{p} = {\Gamma}_{p} + g^{(1)}_{p} + z_p \lambda. \nonumber
\end{eqnarray}
Since $z_p$ can be any integer with a uniform prior, we have 
$$\mathbb{P} \big( \widetilde{\Gamma}_{p} = g \big| {\Gamma}_{p} \big) = \mathbb{P} \big(\widetilde{\Gamma}_{p} = g + \lambda \big| {\Gamma}_{p} \big), $$
and the result follows.
\end{proof}

\begin{proof}[Proof of Lemma \ref{remark3}]
Using \eqref{eqn_H_k_est}, \eqref{eqn_gamma_define} and \eqref{eqn_gamma_true_define} in \eqref{eqn_gamma_hat} we can obtain:
\begin{equation} \label{eqn_gamma_hat_simplify}
\widehat{\Gamma}_{p} = \lambda \big \lfloor {\Gamma}_{p} \big/ \lambda \big\rfloor .
\end{equation}
Since ${\Gamma}_{p}$ is zero mean, Gaussian distributed (from Lemma \ref{remark1}), it follows that $\widehat{\Gamma}_{p}$ is wrapped Gaussian distributed (see Fig.~\ref{Fig_gamma_distortion}). Correspondingly, using the properties of wrapped Gaussian distribution \cite{mardia1999directional}, it follows that $\mathbb{E} \{ \widehat{\Gamma}_{p} \} = e^{-\sigma_{\Gamma}^2/2}$. Finally using the sample mean estimate of $\mathbb{E} \{ \widehat{\Gamma}_{p} \}$, the result follows.
\end{proof}

\begin{proof}[Proof of Lemma \ref{remark4}]
The distortion between ${\Gamma}_{p}, \widehat{\Gamma}_{p}$ is given by:
\begin{multline*}
\int_{-\infty}^{\infty} \mathbb{P} \big( {\Gamma}_{p} = g \big) {\Big( \widehat{\Gamma}_{p} - {\Gamma}_{p} \Big)}^2 {\rm d} g \\
= \sum_{z \in \mathbb{Z}} \int_{-\frac{\lambda}{2}}^{\frac{\lambda}{2}} \mathbb{P} \big( {\Gamma}_{p} = g + z \lambda \big) {\big( z \lambda \big)}^2 {\rm d} g , \nonumber
\end{multline*} 
which follows from \eqref{eqn_gamma_hat_simplify}. Finally, since ${\Gamma}_{p}$ is Gaussian distributed with a variance of $ \sigma_{\Gamma}^2$ from Lemma \ref{remark1}, the result follows.
\end{proof}

\section{} \label{appdix0}
%\begin{proof}[Proof of remark \ref{remark5}]
%Note that for a strong LoS channel we can rewrite \eqref{eqn_channel_resp} as: $h_{p,k} = b + \bar{d}_{p,k}$, where $b > 0$ is the frequency-flat response for LoS path\footnote{Since we only care about relative phase and time errors across the CSI from the $P$ frames, assuming $b > 0$ is without loss of generality.}, and $\bar{d}_{p,k}$ is the augmented dynamic component that also include static components from non LoS paths. Then using \eqref{eqn_Hk_gain_synchronized} we can write:
%\begin{flalign}
%& \qquad \bar{h}_{p,k} \bar{h}_{p,k}^{*} = \Big[ {b}^2  + \bar{d}_{p,k} \bar{d}^{*}_{p,k+1} + b \bar{d}_{p,k+1}^{*} + b \bar{d}_{p,k} \Big] e^{{\rm j} \frac{2 \pi \tau}{T_{\rm s}}} & \nonumber \\
%& \Rightarrow \sum_{k=1}^{K-1} \bar{h}_{p,k} \bar{h}_{p,k}^{*} \approx (K-1) {b}^2 e^{{\rm j} \frac{2 \pi \tau}{T_{\rm s}}}, & \label{eqn_remark5_tau}
%\end{flalign}
%where the last step follows by using the fact that for dominant LoS channel and $\gamma \approx 1$, $b \gg |\bar{d}_{p,k}|$. Thus a good estimate $\bar{\tau}_p$ of $\tau_p$ can be obtained from \eqref{eqn_CPE_baseline2_tau}. Assuming this estimate $\bar{\tau}_p$ is accurate, we further have that:
%\begin{eqnarray}
%\bar{h}_{p,k} e^{{\rm j} 2 \pi f_k \bar{\tau}_p} & \approx & b e^{-{\rm j } \psi_p} + \bar{d}_{p,k} e^{{\rm j } \psi_p} \nonumber \\
%\Rightarrow \sum_{k=1}^{K-1} \bar{h}_{p,k} e^{{\rm j} 2 \pi f_k \bar{\tau}_p} & \approx & (K-1) b e^{-{\rm j } \psi_p}. \label{eqn_remark5_psi}
%\end{eqnarray}
%Finally, assuming \eqref{eqn_remark5_tau} and \eqref{eqn_remark5_psi} are accurate, the static component of the channel (including non LoS paths) can be found from \eqref{eqn_channel_resp} as:
%\begin{eqnarray}
%\widehat{b}_k &=& \sum_{k \in \mathcal{K}} \bar{h}_{p,k} e^{{\rm j} (2 \pi f_k \bar{\tau}_p + \bar{\psi}_p)} \big/ K \label{eqn_remark5_b_hat}
%\end{eqnarray}
%Using \eqref{eqn_remark5_tau}, \eqref{eqn_remark5_psi} and \eqref{eqn_remark5_b_hat} the remark follows.
%\end{proof}
%
\begin{proof}[Proof of Lemma \ref{Th_method1_estimation_simpl}]
When $\gamma \approx 1$, from \eqref{eqn_channel_resp}, we have that: $\bar{{{h}}}_{p,k} \approx {{h}}_{p,k} \approx {b}_{k}$ for all $p \in \mathcal{P}$. Additionally, in strongly LoS channels we have $b_k \approx b_{k+a}$ for $|a| \leq 2$, i.e., channel has a high coherence bandwidth. Therefore, using \eqref{eqn_Hk_gain_synchronized}, we can write:
\begin{eqnarray}
\sum_{k=1}^{K-1} \bar{h}_{p,k} \bar{h}_{p,k+1}^{*} \approx \sum_{k=1}^{K-1} {|b_{k}|}^2  e^{{\rm j} \frac{{\rm j} 2 \pi \tau}{T_{\rm s}}}, \label{eqn_remark5_tau_support}
\end{eqnarray}
where we neglected the other terms which vanish as $\gamma \rightarrow 1$. Thus, from \eqref{eqn_remark5_tau_support}, we conclude that \eqref{eqn_CPE_baseline2_tau} can provide a good initial estimate $\bar{\tau}_p$ of $\tau_p$, i.e., $|\tau_p - \bar{\tau}_p|$ is small. Correspondingly we can write:
\begin{eqnarray} \label{eqn_slow_phase_variation}
\bar{h}^{*}_{p,k} \bar{b}_k e^{- {\rm j} 2 \pi f_k \bar{\tau}_p} \approx {|b_k|}^2 e^{{\rm j} (2 \pi f_k (\tau_p-\bar{\tau}_p) + \psi_p)}.
\end{eqnarray}
In other words, the magnitude and phase angle of $\bar{h}^{*}_{p,k} \bar{b}_k e^{- {\rm j} 2 \pi f_k \bar{\tau}_p}$ has a very slow variation with $k$, which shall be exploited below. Note that, we can simplify \eqref{eqn_timing_err_est_method1} as:
\begin{flalign} \label{eqn_timing_err_est_method11}
& \widehat{\tau}_p, \widehat{\psi}_p = \argmax_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \!\! \bigg\{ & \nonumber \\
& \qquad \qquad \sum_{k \in \bar{\mathcal{K}}} \mathrm{Re} \Big\{ e^{-{\rm j} \big(2 \pi f_k \tau + \psi - \angle [ {\bar{{{h}}}_{p,k}}^{*} \bar{b}_k ]\big)} \Big\} \Big| {\bar{{{h}}}_{p,k}}^{*} \bar{b}_k \Big| \bigg\}, \!\!\!\!\! &
\end{flalign}
where $\bar{\mathcal{K}} = \{k \in \mathcal{K} \big| | \bar{b}_k | > 0 \}$. Let us define:
\begin{flalign} \label{eqn_phase_err_defn}
& \bar{\varphi}_{p,k}(\tau, \psi) \triangleq 2 \pi f_k (\tau - \bar{\tau}_p) + \psi - \widetilde{\mathscr{U}}\big[ \angle  \big( {\bar{{{h}}}_{p,k}}^{*} \bar{b}_k e^{- {\rm j} 2 \pi f_k \bar{\tau}_p} \big) \big] & \end{flalign}
where $\widetilde{\mathscr{U}}(\cdot)$ is as defined in the lemma statement. Applying this to \eqref{eqn_timing_err_est_method11}, we get:
\begin{flalign}
& \widehat{\tau}_p, \widehat{\psi}_p = \argmax_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \bigg\{ \sum_{k \in \bar{\mathcal{K}}} \cos \big[ \bar{\varphi}_{p,k}(\tau, \psi) \big] \Big| {\bar{{{h}}}_{p,k}}^{*} \bar{b}_k \Big| \bigg\} \!\!\!\!\! & \label{eqn_ML_est_6}
\end{flalign}
%
When $\gamma \approx 1$, from \eqref{eqn_channel_resp}, we additionally have that at the true CPE and timing offsets: $\bar{{{h}}}_{p,k} e^{{\rm j} (2 \pi f_k {\tau}_q + \psi_q)} \approx {{{b}}}_{k}$ for all $p \in \mathcal{P}$. Correspondingly for any $k \in \bar{\mathcal{K}}$, we have that $\cos(\bar{\varphi}_{p,k}({\tau}_p, \psi_p)) \approx 1$. Since $({\tau}_p, \psi_p)$ is a feasible solution to \eqref{eqn_ML_est_6}, it follows that $\cos[\bar{\varphi}_{p,k}(\widehat{\tau}_p, \widehat{\psi}_p)] \approx 1$ is also true at the optimal solution $(\widehat{\tau}_p, \widehat{\psi}_p)$ to \eqref{eqn_ML_est_6}. In other words, there exists an integer $z_p \in \mathbb{Z}$ such that for all $k \in \bar{\mathcal{K}}$, $\bar{\varphi}_{p,k}(\widehat{\tau}_p, \widehat{\psi}_p) \approx 2 \pi z_p$. Note that we use the same integer $z_p$ for all sub-carriers $k \in \bar{\mathcal{K}}$ since $\bar{\varphi}_{p,k}(\tau, \psi)$ varies smoothly with $k$ (see \eqref{eqn_slow_phase_variation}) and a transition between two different integers for would violate $\cos[\bar{\varphi}_{p,k}(\widehat{\tau}_p, \widehat{\psi}_p)] \approx 1$ for at least some sub-carriers $k \in \bar{\mathcal{K}}$. Thus, since $|\bar{\varphi}_{p,k}(\tau, \psi) - 2 \pi z_p| \ll 1$ at the optimal solution to \eqref{eqn_ML_est_6}, we can reduce \eqref{eqn_ML_est_6} to: 
\begin{flalign} \label{eqn_ML_est_7}
& \argmax_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \bigg\{ \sum_{k \in \bar{\mathcal{K}}} \bigg[1 - \frac{{\big(\bar{\varphi}_{p,k}(\tau, \psi) - 2 \pi z_p\big)}^2}{2} \bigg] \big| {\bar{{{h}}}_{p,k}}^{*} \bar{b}_k \big| \bigg\} . &
\end{flalign}
where we use the fact that for any real $x$:
\begin{eqnarray}
\cos(x) \approx 1 - x^2/2 \ \text{if $|x| \ll 1$} \nonumber \\
\cos(x) \geq 1 - x^2/2 \ \text{otherwise} \nonumber
\end{eqnarray}
Applying \eqref{eqn_phase_err_defn} to \eqref{eqn_ML_est_7} and, without loss of generality, absorbing the $2 \pi z_p$ into $\psi$, \eqref{eqn_CPE_timing_simpl_method1} follows.
\end{proof}


\begin{proof}[Proof of Lemma \ref{Th_ML_estimation}]
For given prior information: $$\star = \{\bar{{{h}}}_{q,k}, \widehat{\tau}_q, \widehat{\psi}_q | q \in \mathcal{Q}_p\}$$ such that $\widehat{\tau}_q = {\tau}_q, \widehat{\psi}_q = {\psi}_p$, we are interested to find the ML estimates:
\begin{flalign} \label{eqn_ML_est_0}
& \widehat{\tau}_p, \widehat{\psi}_p = \argmax_{\tau, \psi} \bigg\{ \max_{\{{b}_{k} | k \in \mathcal{K}\}} \bigg[ \mathbb{P}({\psi}_p = \psi) \mathbb{P}({\tau}_p = \tau) & \nonumber \\
& \qquad \prod_{k \in \mathcal{K}} \bigg[  \mathbb{P} \big( \bar{{{h}}}_{p,k} \big| {\psi}_p = \psi, {\tau}_p = \tau, {{b}}_{k}, \star \big) & \nonumber \\
& \qquad  \Big( \prod_{q \in \mathcal{Q}_p} \mathbb{P} \big( \bar{{{h}}}_{q,k} \big| {{{b}}}_{k}, \star \big) \Big) \mathbb{P}({{b}}_{k}) \bigg] \bigg\}, &
\end{flalign}
where we use the fact that ${{{d}}}_{p,k}$ are independent for each $k$ in \eqref{eqn_channel_resp}. Noting that ${\tau}_p \sim {\rm Uni}(-\frac{\kappa T_{\rm s}}{K}, \frac{\kappa T_{\rm s}}{K})$, ${\psi}_p \sim {\rm Uni}(-\pi, \pi)$ (see Section \ref{subsec_timing_CFO_dist}), ${{{d}}}_{p,k} e^{-{\rm j} {\psi}_p} e^{-{\rm j} 2 \pi f_k \tau_p}$ are i.i.d. complex Gaussian vectors for each $p \in \mathcal{P}$ and $b_k$ has a uniform prior (see \eqref{eqn_channel_resp} and \eqref{eqn_H_k_est}), we can rewrite the right hand side of \eqref{eqn_ML_est_0} as:
\begin{flalign}
& \argmax_{ |\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \Bigg\{ \max_{\sum_k {|{b}_k|}^2 = \gamma K} \prod_{k \in \mathcal{K}} \Bigg[  & \nonumber \\
& \qquad \exp \bigg\{ \frac{- {\big| {b}_{k} e^{-{\rm j} [2 \pi f_k \tau + \psi]} - \bar{{{h}}}_{p,k} \big|}^2}{ 1- \gamma } \bigg\} & \nonumber \\
& \qquad \prod_{q \in \mathcal{Q}_p} \exp \bigg\{ \frac{-{\big| {b}_{k} e^{-{\rm j} [2 \pi f_k \widehat{\tau}_{q} + \widehat{\psi}_{q}]} - \bar{{{h}}}_{q,k} \big|}^2}{ 1- \gamma } \bigg\} \Bigg] \Bigg\} & 
\end{flalign}
Taking the logarithm on both sides, we can can further reduce the optimization problem to:
\begin{flalign} \label{eqn_ML_est_1}
& \argmin_{ |\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \bigg\{ \min_{\sum_k {|b_k|}^2 = K \gamma} \bigg[ \sum_{k \in \mathcal{K}} \bigg( {\big| {b}_{k} e^{-{\rm j} [2 \pi f_k \tau + \psi]} - \bar{{{h}}}_{p,k} \big|}^2 & \nonumber \\
& \quad + \sum_{q \in \mathcal{Q}_p} {\big| {b}_{k} e^{-{\rm j} [2 \pi f_k \widehat{\tau}_{q} + \widehat{\psi}_{q}]} - \bar{{{h}}}_{q,k}  \big|}^2 \bigg) \bigg] \bigg\} \!\!\!\!\!\!\!\!\!\! &
\end{flalign}
The conditional optimal solution of ${b}_{k}$ in \eqref{eqn_ML_est_1} for given $\tau, \psi$ is given by:
\begin{eqnarray} \label{eqn_ML_est_4}
{b}_{k} = A \bigg[ \bar{{{h}}}_{p,k} e^{{\rm j} (2 \pi f_k \tau + \psi)} + \sum_{q \in \mathcal{Q}_p} \widehat{{{h}}}_{q,k} \bigg],
\end{eqnarray}
where we use \eqref{eqn_Hk_synchronized} and  $A$ is such that $\sum_k {|b_k|}^2 = \gamma K$. Substituting \eqref{eqn_ML_est_4} back into \eqref{eqn_ML_est_1} and removing the terms that are independent of $\tau, \psi$ from the objective function, \eqref{eqn_ML_est_1} can be reduced to:
\begin{flalign} \label{eqn_ML_est_5}
& \argmin_{|\tau | \leq \frac{\kappa T_{\rm s}}{K}, |\psi| < \pi} \Bigg\{ & \nonumber \\
& \qquad \quad \sum_{k \in \mathcal{K}} - \mathrm{Re} \bigg\{ e^{-{\rm j} (2 \pi f_k \tau + \psi)} {\bar{{{h}}}_{p,k}}^{*} \Big( \sum_{q \in \mathcal{Q}_p} \widehat{{{h}}}_{q,k} \Big) \bigg\} \Bigg\} \!\!\!\! &
\end{flalign}
Finally re-arranging the terms of \eqref{eqn_ML_est_5} we arrive at \eqref{eqn_timing_err_est} and \eqref{eqn_CPE_est}.
\end{proof}

\end{appendices}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% conference papers do not normally have an appendix

% use section* for acknowledgement
%\section*{Acknowledgment}
%The authors would like to thank...





% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://www.ctan.org/tex-archive/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)

\bibliographystyle{ieeetr}
\bibliography{references}

% that's all folks
\end{document}


