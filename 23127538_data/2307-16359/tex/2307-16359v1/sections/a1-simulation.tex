The computer code implementing Algorithm 1 is written in \texttt{Python3} \cite{van_rossum_python_1995}.
Where possible, libraries with underlying \texttt{C++} implementations are used to speed up mathematical calculations.
Networks are generated and manipulated with the graph theory library \texttt{Graph-tool} \cite{peixoto_graph-tool_2014}, which has a \texttt{C++} backend.
The \texttt{NumPy} library \cite{harris_array_2020} is used for numerical calculations, with vectorization applied to various loops to take advantage of its fast linear algebra functionality.
At each timestep, $x_i(t,\theta)$ is stored as a matrix, where each agent occupies a row, and each column holds discretized $\theta$ values. 
The likelihood broadcast to all agents by element-wise matrix multiplication synchronously via Eq.\ \eqref{eq:updatefirsthalf}. 
The interaction between agents is symmetric ($A_{ij} = A_{ji}$). 
Eq.\ \eqref{eq:xiprimed} is implemented via element-wise matrix subtraction, which calculates all interactions synchronously. 
Eq.\ \eqref{eq:undatesecondhalf} applies a mask to the $\Delta x' (t+1/2, \theta)$ matrix to obtain $x_i(t+1,\theta)$. 
Batched simulations are run in parallel on 10 threads. 
A single complete simulation with $n=100$ and $T=10^4$ typically takes 0.7 seconds on a 2021 MacBook Pro (Apple M1 Max, 32GB RAM, 3.2 GHz clock speed, 10 cores).