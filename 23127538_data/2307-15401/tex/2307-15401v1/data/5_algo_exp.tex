\subsection{Algorithm}
    
    There are several well-known algorithms available to address \eqref{spp}, including Dijkstra's algorithm, Floyd-Warshall algorithm, and Bellman-Ford algorithm \cite{sapundzhi2018optimization}. These algorithms are designed to identify the shortest or most efficient path between two points in a weighted directed graph. For ease of reference, we shall now present a description of Dijkstra's Algorithm with reference to \cite{cormen2009introduction, Szczepanski2021} below. In \autoref{alg: dijkstra}, the vertex set is denoted by $Q$, and the array $dist$ contains the current distances from the starting point $s$ to other vertices, where $dist[v]$ represents the current distance from $s$ to vertex $u$. The array $prev$ contains pointers to the previous-hop nodes on the shortest path from $s$ to the given vertex, or equivalently, it is the next hop on the path from the given vertex to the source. The variable $alt$ denotes the length of the path from the root node to the neighbour node $v$ if it were to go through $u$. If this path is shorter than the current shortest path recorded for $v$, the current path would be replaced with this $alt$ path.
    
    \begin{algorithm}
        \caption{Dijkstra's Algorithm}
        \label{alg: dijkstra}
        \begin{algorithmic}
            \renewcommand{\algorithmicrequire}{\textbf{Input:}}
            \renewcommand{\algorithmicensure}{\textbf{Output:}}
            \REQUIRE $G=(V,E,W)$, a weighted directed graph, and $s, d \in V$, the starting point $s$ and destination point $d$
            \ENSURE  $p$, the shortest path for \eqref{spp}
            \FORALL{vertex $v$ in graph $G$}
                \STATE $dist[v] \gets infinite$
                \STATE $prev[v] \gets undefined$
                \STATE Add vertex $v$ to vertex set $Q$
            \ENDFOR
            \STATE $dist[s] \gets 0$
            \WHILE{$Q$ is not empty}
                \STATE $u \gets \underset{i}{\operatorname{argmin}}\{dist[i]\,|\,\forall i \in Q\} $
                \STATE Remove $u$ from $Q$
                \FORALL{neighbour $v$ of $u \in Q$}
                    \STATE $alt \gets dist[u] + w(u,v)$
                    \IF{$alt<dist[v]$}
                        \STATE $dist[v] \gets alt$
                        \STATE $prev[v] \gets u$
                    \ENDIF
                \ENDFOR
            \ENDWHILE
            \STATE Set $p$ as the shortest path to $d$ using $prev$ array
        \end{algorithmic}
    \end{algorithm}

\subsection{Dataset}
    
    This section describes the \texttt{AirView{\_}Dublin{\_}City} (\texttt{ADC}) dataset which is recently released and the preprocessing steps followed to address challenges faced during the data collection stage. Additionally, we provide insights and visualizations of the resulting dataset.
    
    % \begin{enumerate}
    %     \item Describe the air quality dataset([]). Done.
    %     \item Explain why we used the Road Segment table instead of the measurements table.  Done.
    %     \item Describe how this dataset is linked to OSM Dataset.  Done.
    %     \item Data preprocessing on the Road Segment table.  Done.
    %     \item Include some visualizations.  Done.
    % \end{enumerate}

    \textbf{Google Project Air View Data - Dublin City (May 2021 - August 2022):}
    This dataset was collected by Google and Dublin City Council as part of Project Air View Dublin. Google's first electric Street View car, equipped with Aclima’s mobile air sensing platform, drove through the roads of Dublin City measuring street-by-street air quality. The data collection process predominantly took place from Monday to Friday between 9:00 am and 5:00 pm from May 2021 to August 2022. Consequently, the dataset represents typical daytime weekday air quality. The sensors on the car measured pollution on each street and highway at 1-second intervals while driving with the flow of traffic at normal speeds. The pollutants included in the dataset are Carbon Monoxide (CO), Carbon Dioxide (CO2), Nitrogen Dioxide (NO2), NO (nitric oxide), Ozone (O3), and Particulate Matter PM2.5 (including size-resolved particle counts from 0.3 - 2.5 \textmu m). The following two versions of the dataset are publicly available\footnote{\url{https://data.smartdublin.ie/dataset/google-airview-data-dublin-city}}:
    
    \begin{outline}
        \1 \texttt{Airview{\_}Dublin{\_}City{\_}Measurements} (\texttt{ADC-M}) is the 1-second intervals data captured during the period.
        \1 \texttt{AirView{\_}Dublin{\_}City{\_}RoadData} (\texttt{ADC-R}) is the 1-second data points aggregated in approximately 50m road segments.
    \end{outline}

    In this work, the \texttt{ADC-R} was used because it groups the individual points/measurements from \texttt{ADC-M} into segments. To report the concentration of each pollutant per segment, first, they get the mean of the number of measurements on this road segment, then count the number of drive passes on this road segment. Finally, for each pollutant, they report the concentration (median of drive pass mean) in µg/m3. \texttt{ADC-R} also contains the OSM{\_}IDs segments to associate this dataset with the \texttt{OpenStreetMap} (\texttt{OSM}) dataset. The OSM{\_}IDs nodes were extracted and fed into the optimization algorithm. 

\subsection{Data Cleaning \& Prepossessing}

    In this work, the \texttt{ADC-R} dataset was used as mentioned previously. Even though this dataset is an aggregation of the raw data \texttt{ADC-M} and was already processed by Google, this work required the following pre-processing:
    
    \begin{outline}
        \1 Data interpolation for missing and negative values: the dataset includes NaNs and negative values, which may arise from sensor malfunctions or miscalibrations, potentially impacting the optimization algorithm. To address this issue, a linear interpolation method was applied to each pollutant column. Initially, the dataset was sorted by OSMID, and all negative values were replaced with NaNs. Subsequently, a linear interpolation was performed using the Python Pandas library, enabling the estimation of missing values and the smoothing of the dataset.

        \1 Cross-referencing of the \texttt{OSM} and \texttt{ADC-R} datasets: the optimisation algorithm utilizes the nodes and segments from the \texttt{OSM} dataset to determine the greener path. To establish a link between these two datasets, the OSM\_IDs are used as a reference. It is important to note that the vehicle used to collect the Google Air Quality dataset did not traverse all streets and roads in Dublin, resulting in measurements being available only for specific segments. To assign these measurements to the corresponding segments in the \texttt{OSM} dataset, the following process was conducted: 
        
            \2 Delimiting the area of interest: the focus was on the central region of Dublin. In order to cover the areas frequented by shared bikes, we define the area of interest based on the map of NOW dublinbikes\footnote{\url{https://www.dublinbikes.ie/en/mapping}} and all segments and nodes within the coordinates [-6.230852, 53.359967, -6.310015, 53.330091] (as shown in \autoref{fig: snapshot_dublin}) were extracted.
    
            \2 Matching process: by utilising the OSM\_ID column, a matching process was performed between the road dataset and the \texttt{OSM}. Segments existing in both datasets were selected and their corresponding pollutant measurements were merged. This resulted in the creation of a final dataset with the following format: [osm\_id, NO2\_ugm3, NO\_ugm3, CO2\_mgm3, CO\_mgm3, O3\_ugm3, PM25\_ugm3]. This final dataset serves as the input for the optimization algorithm.
            
        \1 Finally, in order to address the issue of missing data on particular segments, a clustering algorithm is employed to identify the nearest neighbours from those segments. In particular, the position of a road segment is represented by its edge points, encompassing two endpoints and, if present, all inflexion points. Subsequently, the BallTree algorithm is applied to select the $n$ closest neighbours for each target, which refers to the edge point in a road segment with missing data, within our dataset. The attributes of the target are then determined by calculating the mean value of its neighbours' attributes, thereby enabling the missing data to be filled in based on geographic relevance. The histogram depicted in \autoref{fig: neighbour hist} provides a visualisation of the distances between measurements and various segments. Considering the observed distribution of distances, the selection of 3, 5, or 10 neighbours is made.
        
    \end{outline}

    % Figure environment removed

    % Figure environment removed

    The data before and after cleaning and preprocessing is visually depicted on the map in \autoref{fig: data filling result}. The orange boundary corresponds to the area shown in \autoref{fig: snapshot_dublin}. The red and blue routes on the map represent the roads with and without missing values respectively. 

    % Figure environment removed

\subsection{Green Route Planning}

    Our experiments were designed to assess the impact of our algorithm on the selection of green routes in various real-world scenarios. To achieve this, we generated and compared the shortest routes with the greenest routes under different setups, as outlined below:
    
    \begin{enumerate}
         
    
    
        \item In the first setup, we considered all pollutants and assigned them equal weights. We conducted the experiments with a thousand randomly selected origin-destination pairs on the map, focusing primarily on walking and private micromobility modes such as private bicycles and e-bikes. Thus, we denote this setup as ``\textbf{Private Device}''.
        
        \item In the second setup, we again considered all pollutants and assigned them equal weights. However, this time we conducted the experiments with ten origin-destination pairs, selecting GPS coordinates from the map of NOW dublinbikes. This setup specifically targeted transportation systems with shared devices, such as shared bicycles and shared e-bikes, and we call this setup ``\textbf{Shared Device}''.

        \item In the third setup, we examined the individual influence of different pollutants. We conducted the experiments with one origin-destination pair selected on the map, varying the weights assigned to different pollutants. For example, we assigned a weight of 1 to one pollutant, such as CO, and a weight of 0 to the other pollutants. This allowed us to obtain green routes that focused solely on reducing the specific pollutant. This setup aimed to evaluate the performance of our optimization algorithm under different pollutant weightings. This setup is named ``\textbf{Single Pollutant}''.
        
    \end{enumerate}

    By conducting these experiments, we aimed to gain insights into the performance and effectiveness of our optimization algorithm in different real-world scenarios and pollutant weightings. The results and relevant discussions are included in \autoref{sec: res_dis}.