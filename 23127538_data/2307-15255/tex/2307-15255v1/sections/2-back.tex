\section{Background and Related Work}
\label{sec:back}

This section presents the background and related work in Bloom join (Section~\ref{sec:back-bloom}) and the Yannakakis algorithm (Section~\ref{sec:back-yannakakis}). 
%We will use query 5 in TPC-H~\cite{} (Figure~\ref{fig:q5}) as a running example in this and following sections. 
%\yxy{Maybe we do not need the example in Section 2. If so, move it to Section 3.}


\subsection{Bloom join}
\label{sec:back-bloom}

A Bloom filter~\cite{bloom1970space} is a compact probabilistic data structure that determines whether an element exists in a set. A Bloom filter has no false negative but may have false positives. In a Bloom join of two tables, a Bloom filter is constructed on one table (typically the smaller one) using the join key. The filter is then sent and applied to each row in the other table; if a row does not pass the filter, it matches no row in the first table and should not participate in the join. Since testing a Bloom filter is generally faster than performing a join, Bloom join can speedup query processing, especially when the join is selective. Modern OLAP DBMSs (e.g., Oracle~\cite{oracle-bf}, Redshift~\cite{redshift-bf}, Snowflake~\cite{snowflake-bf}, Databricks~\cite{databricks-bf}) widely adopt Bloom filters to accelerate join execution.
% \yxy{mention it is widely implemented in practice?}

Most existing Bloom join algorithms can be applied to only a single join operation. This means the predicate on one table can only be used to pre-filter rows in the other table it joins with; namely, the predicate is transferred in one-hop and one-direction. Some prior work~\cite{lip17} has extended the idea to datasets with star schema, allowing all dimension tables to transfer local predicates to the fact table, which outperformed the baseline Bloom join. However, these solutions do not generalize to more complex query plans.

\subsection{Yannakakis algorithm}
\label{sec:back-yannakakis}

The Yannakakis algorithm~\cite{Yannakakis1981} is a classic algorithm that can pre-filter out all rows from tables that do not appear in the final join result, thereby achieving the theoretically maximum filtering selectivity. The algorithm applies to \textit{acyclic} join queries. The acyclicity is more formally termed as \textit{$\alpha$-acyclicity}~\cite{Yannakakis1981}. The algorithm is proven to run in $O(N + \mathsf{OUT})$ time, where $N$ is the size of input relations and $\mathsf{OUT}$ is the query output size. Thus, the Yannakakis algorithm is known to be {\em instance optimal} since %in that for a given query instance, 
$N + \mathsf{OUT}$ is the unavoidable time cost of reading the input and enumerating the output for a query.
%
The algorithm starts by choosing a rooted join tree arbitrarily, and then proceeds with a {\em semi-join phase} and a {\em join phase}. 

\vspace{0.05in}
\noindent
\textbf{Semi-join phase.} The semi-join phase contains %can be further divided into 
two passes: the {\em forward pass} and the {\em backward pass}. The forward pass traverses the join tree in a bottom-up fashion. At each vertex, we filter the table by a sequence of semi-joins with its children. A {\em semi-join} of two tables $R$ and $S$ is defined as $R \ltimes S = \Pi_{\mathsf{attr}(R)} (R \bowtie S)$, which effectively removes all tuples in $R$ that do not join with any tuple in $S$. The forward pass stops when the root node is reached. Similarly, the backward pass traverses the join tree in a top-down fashion. At each vertex, the table is filtered by a semi-join with its parent. The backward pass stops when all leaf nodes are reached. It is proven that both passes can be executed in $O(N)$ time and all tuples that will not contribute to the output are removed.

\vspace{0.05in}
\noindent
\textbf{Join phase.} The join phase can join the filtered tables in any order. It is proven that regardless of the chosen join order, the join phase can be executed in $O(\mathsf{OUT})$ time.


As a reflection, the semi-join phase filters all redundant tuples and the join phase executes the join with automatic robustness: it can join the tables in any order without any intermediate table size blow-up over the output size. The algorithm was later extended by Joglekar et al.~\cite{Joglekar2016} to handle aggregations on top of join queries.

% - Mention data-induced predicates (Hangdong: its VLDB talk https://www.youtube.com/watch?v=XrtYA1UadGs )

% Q: do we need a related work section or discuss related work in this section? 

