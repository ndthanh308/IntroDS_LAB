\section{Introduction}
\label{sec:intro}

Joins constitute a substantial portion of query execution time. 
One effective principle for enhancing join performance is to minimize join input sizes by pre-filtering rows that will not appear in the join result. 
Predicate pushdown %~\cite{netezza, exadata, pushdowndb} 
exemplifies this principle by applying local predicates on a table before executing any join operation. 

%Numerous optimizations have been develop to optimize the performance of joins. \textit{Predicate pushdown} is a technique that can effectively reduce the sizes of tables that participate in the join operations by pre-filtering rows that will not appear in the join result. 

The Bloom join~\cite{ramesh2009optimizing} extends this principle beyond a single table. In the Bloom join, a Bloom filter is constructed using the join key in one table, and sent to the other table to filter out rows that do not pass the filter---these rows do not match any keys in the first table and will not participate in the join. 
The Bloom join can effectively reduce the join input sizes thereby reducing the query runtime. However, existing Bloom join solutions can perform such pre-filtering only within a single join operation. 

In this paper, we further generalize the pre-filtering principle %in Bloom join 
across multiple joins. Namely, we use predicates on individual tables to pre-filter multiple other tables in the query, further reducing the join input sizes. % tables that participate joins. 
We call this new technique \textit{\textbf{predicate transfer}}. 
A predicate on one table $T_1$ can be transferred (e.g., in the form of a Bloom filter) to a table $T_2$ that joins with $T_1$. $T_2$ can apply the predicate and further transfer it to table $T_3$ that joins with $T_2$  (but $T_1$ does not necessarily join with $T_3$). The transfer process can propagate further such that the original predicate can filter multiple other tables (e.g, $T_2$, $T_3$, etc.).
The conventional Bloom join is a special case of the more generalized predicate transfer---a Bloom join is a one-hop predicate transfer. 

The idea of predicate transfer is inspired by the seminal paper~\cite{Yannakakis1981} by 
%that proposes the 
Yannakakis. For an acyclic query
% \paris{this is technically not correct; there are acyclic queries with join graphs that have cycles} 
that equi-joins multiple tables, the Yannakakis algorithm achieves the theoretically maximum pre-filtering selectivity by adding % avoids any redundant intermediate tuples by 
an additional semi-join phase prior to the actual joins, which filters a table by semi-joining it with other tables. % that join with it and then the reduced table acts as a filter in the semi-joins that follow. The semi-join phase keeps 
The process filters one table at a time following the tree structure of the query until every predicate is spread across all joining tables. % of the join. 

For all its theoretical elegance, the Yannakakis algorithm has not yet made its way into modern database engines. One main obstacle is the costly hash table probes and memory consumption %of intermediate tables 
in the semi-join phase. Predicate transfer aims to address these practical limitations. It significantly reduces the overhead of semi-joins by passing succinct data structures like Bloom filters. Although predicate transfer no longer achieves the theoretically maximum filtering selectivity, it achieves much higher performance overall. 
% to trade off expensive hash table probes in DRAM for more efficient filter probes in the CPU cache. 

% \yxy{describe the Yannakakis algorithm from a high level. Also emphasize that predicate transfer makes Yannakanis algorithm practical.}

In the rest of the paper, we first describe the background and related work of predicate transfer in Section~\ref{sec:back}, with a focus on the Bloom join and Yannakakis algorithm. We then describe the design space of predicate transfer in detail, and our current heuristics in different design dimensions in Section~\ref{sec:pred}. We report preliminary performance evaluations on TPC-H~\cite{tpch} in Section~\ref{sec:eval}, which shows that predicate transfer can outperform Bloom join by 3.1$\times$ (up to $40\times$) and the Yannakakis algorithm by 3.7$\times$. %, and up to 40$\times$ on queries with complex joins. 
Finally, Section~\ref{sec:conclusion} concludes the paper and discusses future work. 


