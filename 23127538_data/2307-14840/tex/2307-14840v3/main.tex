\documentclass[a4paper,onecolumn,accepted=2024-10-22]{quantumarticle}
\pdfoutput=1

\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amsfonts,amssymb,mathrsfs,thmtools,thm-restate}
\usepackage{bbm}
% \usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{graphicx}
\graphicspath{ {./images/} }
% \usepackage{cleveref}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{cuted}
\usepackage{tikz}
\usepackage{authblk}
\usepackage{mdframed}
\usepackage{hyperref}
\usetikzlibrary{quantikz}
%\usepMackage[braket,qm]{qcircuit}
\usepackage[bibencoding=auto,style=alphabetic,defernumbers=true,backend=biber,giveninits=true,doi=true,isbn=false,url=false]{biblatex}
\addbibresource{main_final_quantum.bib}


\usepackage{geometry}
\geometry{
a4paper,
total={150mm,227mm},
}

\mdfsetup{%
middlelinewidth=2pt,
backgroundcolor=orange!10,
roundcorner=10pt
}


% \newcommand{\TODO}[1]{\textcolor{orange}{TODO: #1}}
 %\newcommand{\marten}[1]{\textcolor{cyan}{Marten: #1}}
 %\newcommand{\niels}[1]{\textcolor{blue}{Niels: #1}}
% \newcommand{\bruno}[1]{{\color{red} Bruno: #1}}
 %\newcommand{\harry}[1]{{\color{teal} Harry: #1}}
%\newcommand{\new}[1]{\textcolor{purple}{New: #1}}
% \newcommand{\remove}[1]{\textcolor{red}{Remove: #1}}

%\newcommand{\TODO}[1]{}
\newcommand{\marten}[1]{}
\newcommand{\niels}[1]{}
\newcommand{\bruno}[1]{}
\newcommand{\harry}[1]{}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newcounter{mycount}
% definition of the command
\newcommand\myprob[3]{%
  \stepcounter{mycount}
  \par
  \vspace{1em}
  \par\noindent\rule{\textwidth}{0.4pt}
  \vspace{0.5em}
  \indent Problem\ \themycount . #1\\
  \indent {\bfseries Input}: #2\\
  \indent {\bfseries Output}: #3
  \vspace{0.5em}
  \par\noindent\rule{\textwidth}{0.4pt}
  \vspace{1em}\par
}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{example}[theorem]{Example}

\theoremstyle{plain}
\newtheorem{remark}[theorem]{Remark}

\DeclareMathOperator\supp{supp}
\DeclareMathOperator\BQP{\mathsf{BQP}}
\DeclareMathOperator\NC{\mathsf{NC}}
\DeclareMathOperator\AC{\mathsf{AC}}
\DeclareMathOperator\TC{\mathsf{TC}}
\DeclareMathOperator\QNC{\mathsf{QNC}}
\DeclareMathOperator\QTC{\mathsf{QTC}}
\DeclareMathOperator\LAQCC{\mathsf{LAQCC}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\kb}[1]{\ket{#1}\bra{#1}}
\newcommand{\mathO}{\mathcal{O}}

\title{State preparation by shallow circuits using feed forward}

\author[1]{Harry Buhrman}
\author[1]{Marten Folkertsma}
\author[2]{Bruno Loff}
\author[1,3]{Niels M. P. Neumann}
\date{}%September 23, 2022}

\affil[1]{QuSoft, CWI \& University of Amsterdam, Amsterdam, the Netherlands}
\affil[2]{LASIGE \& Department of Mathematics, University of Lisbon}
\affil[3]{The Netherlands Organisation for Applied Scientific Research (TNO), Delft, the Netherlands}


\begin{document}
\maketitle
\begin{abstract}
Fault tolerant quantum computers repetitively apply a four-step procedure: 
First, perform a few one and two-qubit quantum gates. 
Second, perform a syndrome measurement on a subset of the qubits. 
Third, perform fast classical computations to establish if and where errors occurred. 
And, fourth, correct the errors with a correction step. 
The next iteration applies the same procedure with new one and two-qubit gates. 
Even though current error-rates prohibit this procedure to work and fault tolerant quantum computing remains a distant goal, the same procedure can already prove useful today. 
In this work we make use of this four-step scheme not to carry out fault-tolerant computations, but to enhance short, {\em constant}-depth, quantum circuits that perform 1 qubit gates and {\em nearest-neighbor} 2 qubit gates.

We introduce a new computational model called \emph{Local Alternating Quantum Classical Computations} ($\LAQCC$). 
In this model, qubits are placed in a grid and they can only interact with their direct neighbors; the quantum circuits are of constant depth with intermediate measurements; a classical controller can perform log-depth computations on these intermediate measurement outcomes and control future quantum operations based on the outcome.
This model fits naturally between quantum algorithms in the NISQ era and full-fledged fault-tolerant quantum computation. 
We first prove that any Clifford circuit has an equivalent $\LAQCC$ circuit, and that any $\LAQCC$ circuit can be simulated by a $\QNC^1$ circuit. 
Next, we conjecture the non-simulatability of $\LAQCC$ by showing that $\LAQCC$ contains the class of Instantaneous Quantum Polynomial-time circuits.
We also show that any $\LAQCC$ circuit with polynomial-sized quantum circuits and unbounded classical computations is contained in the class of quantum circuits equipped with post-selection gates with respect to the task of state preparation.
We continue by presenting $\LAQCC$ implementations of different subroutines, including OR-gates, quantum Fourier transforms and Threshold gates. 
These subroutines prove vital in constructing three state preparation routines in the main part of this work. 
Preparing a uniform superposition uses constant-depth arithmetic gates, combined with an exact Grover implementation by Long. 
For the $W$-state, we employ a compress-uncompress method to switch between a binary and one-hot encoding. 
This method extends to the more generalized Dicke-states, the superposition of $n$-bit strings of Hamming weight $k$, for $k=\mathO(\sqrt{n})$, but fails for higher $k$ due to the birthday paradox. 
We extend this protocol to a protocol that prepares many-body scar states, highly excited states with low entanglement and longer coherence times than states with the same energy density. 
We present a circuit for preparing Dicke-states for larger $k$ requiring log-depth circuits that maps between the factoradic number system and the combinatorial number system. 
%This paper concludes with a first exploration of the computational limits of $\LAQCC$ by showing its inclusion in the class of quantum circuits equipped with post-selection gates with respect to the task of state preparation. 
%This inclusion even holds if we allow for polynomial-deep quantum circuits, unbounded classical computations and a polynomial number of alternations between the two. 


%In order to achieve fault-tolerant quantum computation, we need to repeat the following sequence of four steps after we have initialized the quantum device. 
%First, we perform 1 or 2 qubit quantum gates (in parallel if possible). Second, we do a syndrome measurement on a subset of the qubits. Third, we perform a fast classical computation to establish which errors have occurred (if any). And, fourth, depending on the errors, we apply a correction step. 
%Then the procedure repeats with the next sequence of gates. 
%These four steps are essential to accomplish fault-tolerant quantum computing. 

%In order for these four steps to succeed, we need the error rate of the  gates to be below a certain threshold. Unfortunately, the error rates of current quantum hardware are still too high and do not meet this requirement. On the other hand, current quantum hardware platforms are designed with these four steps in mind.  In this work we make use of this four-step scheme not to carry out fault-tolerant computations, but to enhance short, {\em constant}-depth, quantum circuits that perform 1 qubit gates and {\em nearest-neighbor} 2 qubit gates. 
%To explore how this can be useful, we study a computational model which we call \emph{Local Alternating Quantum Classical Computations} ($\LAQCC$). 
%In this model, qubits are placed in a grid and they can only interact with their direct neighbors; the quantum circuits are of constant depth with intermediate measurements; a classical controller can perform log-depth computations on these intermediate measurement outcomes and control future quantum operations based on the outcome.
%This model fits naturally between quantum algorithms in the NISQ era and full fledged fault-tolerant quantum computation. 

%We show how an $\LAQCC$ circuit can create long-ranged interactions, which constant-depth quantum circuits cannot achieve, and use it to construct a range of useful multi-qubit operations. 
%With these gates, we create three new state preparation protocols for a uniform superposition over an arbitrary number of states, $W$-states and Dicke states, the generalization of $W$-states. Furthermore, we show that this type of model contains circuits which are unlikely to be classically simulatable, as well as bound the power of this model by showing an inclusion into $\QNC^1$

%We conclude by studying the power of intermediate classical calculations, by defining a more powerful version of $\LAQCC$. 
%This version has quantum circuits of with  polynomial size and uses {\em unbounded} classical computations. 
%We use ideas from Kolmogorov complexity to show that this new class is bounded in capabilities and that post-selecting on measurement outcomes is more powerful. 
\end{abstract}

\input{introduction.tex}
\input{preliminaries.tex}
\input{model.tex}

\section{State preparation in \texorpdfstring{$\LAQCC$}{LAQCC}}\label{sec:state_prep_in_LAQCC}
In this section we consider what quantum states we can prepare using an $\LAQCC$ circuit beyond the stabilizer states and Clifford circuits discussed in the previous section. 
Specifically, as mentioned in the introduction, we consider quantum states that are widely used, in other quantum algorithms, for bench marking purposes and within physics. 
First, we show how to create a uniform superposition of computational basis states up to size $q$, where $q$ is not a power of $2$, a state that is often used as initial state in other algorithms (including the following other state preparation protocols presented in this work). 
We then use this procedure to create $W$-states, the uniform superposition over all $n$-bitstrings of Hamming-weight $1$, using a compress-uncompress method. 
This compress-uncompress method generalizes to preparing Dicke-$(n,k)$ states for $k=\mathO(\sqrt{n})$, uniform superpositions over all $n$-bitstrings of Hamming-weight $k=\mathO(\sqrt{n})$. 
Dicke states find many applications, and especially the compress-uncompress approach might prove useful for entanglement distillation protocols.
Preparing general Dicke-$(n,k)$ states requires a novel method to map between two integer representation systems, the factoradic representation and the combinatorial number representation. 
Finally, we present a state preparation protocol for quantum many-body scar states, states often used in physics, based on the Dicke-$(n,k)$ state preparation protocol for $k=\mathO(\sqrt{n})$

\input{Uniform_superposition.tex}
\input{W_states.tex}
\input{Dicke_states.tex}

%\input{complexity_results.tex}

\section*{Acknowledgements}
We want to thank Jonas Helsen, Joris Kattem{\"o}lle, Ido Niesen, Kareljan Schoutens, Florian Speelman, Dyon van Vreumingen and Jordi Weggemans for insight full discussions. 
%Furthermore, we would like to thank Chris Cade for suggesting to look at the oracle from~\cite{AaronsonKuperberg:2007} for separating $\LAQCC^*$ and $\mathsf{Post}$-$\BQP$ and Georgios Styliaris for first mentioning how to parallelize Clifford ladder circuits. 
Furthermore, we would like to thank Georgios Styliaris for first mentioning how to parallelize Clifford ladder circuits. 
HB and MF were supported by the Dutch Ministry of Economic Affairs and Climate Policy (EZK), as part of the Quantum Delta NL programme. 
\iffalse
NN was supported by the quantum application project of TNO. 
This work was supported by the Dutch Research Council (NWO/OCW), as part of the Quantum Software Consortium programme (project number 024.003.037).
\fi


\printbibliography


\appendix

\input{appendix.tex}

\end{document}
