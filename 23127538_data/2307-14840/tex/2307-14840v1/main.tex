\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amsthm,amsfonts,amssymb,mathrsfs,thmtools,thm-restate}
\usepackage{bbm}
% \usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{graphicx}
\graphicspath{ {./images/} }
% \usepackage{cleveref}
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{cuted}
\usepackage{tikz}
\usepackage{authblk}
\usepackage{mdframed}
\usetikzlibrary{quantikz}
%\usepackage[braket,qm]{qcircuit}
% \usepackage[bibencoding=auto,style=alphabetic,defernumbers=true,backend=biber,giveninits=true,doi=false,isbn=false,url=false]{biblatex}
% \addbibresource{main.bib}


\usepackage{geometry}
\geometry{
a4paper,
total={150mm,227mm},
}

\mdfsetup{%
middlelinewidth=2pt,
backgroundcolor=orange!10,
roundcorner=10pt
}


% \newcommand{\TODO}[1]{\textcolor{orange}{TODO: #1}}
% \newcommand{\marten}[1]{\textcolor{cyan}{Marten: #1}}
% \newcommand{\niels}[1]{\textcolor{blue}{Niels: #1}}
% \newcommand{\bruno}[1]{{\color{red} Bruno: #1}}
% \newcommand{\harry}[1]{{\color{teal} Harry: #1}}
% \newcommand{\new}[1]{\textcolor{purple}{New: #1}}
% \newcommand{\remove}[1]{\textcolor{red}{Remove: #1}}

\newcommand{\TODO}[1]{}
\newcommand{\marten}[1]{}
\newcommand{\niels}[1]{}
\newcommand{\bruno}[1]{}
\newcommand{\harry}[1]{}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newcounter{mycount}
% definition of the command
\newcommand\myprob[3]{%
  \stepcounter{mycount}
  \par
  \vspace{1em}
  \par\noindent\rule{\textwidth}{0.4pt}
  \vspace{0.5em}
  \indent Problem\ \themycount . #1\\
  \indent {\bfseries Input}: #2\\
  \indent {\bfseries Output}: #3
  \vspace{0.5em}
  \par\noindent\rule{\textwidth}{0.4pt}
  \vspace{1em}\par
}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{example}[theorem]{Example}

\theoremstyle{plain}
\newtheorem{remark}[theorem]{Remark}

\DeclareMathOperator\supp{supp}
\DeclareMathOperator\BQP{\mathsf{BQP}}
\DeclareMathOperator\NC{\mathsf{NC}}
\DeclareMathOperator\AC{\mathsf{AC}}
\DeclareMathOperator\TC{\mathsf{TC}}
\DeclareMathOperator\QNC{\mathsf{QNC}}
\DeclareMathOperator\QTC{\mathsf{QTC}}
\DeclareMathOperator\LAQCC{\mathsf{LAQCC}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\newcommand{\kb}[1]{\ket{#1}\bra{#1}}
\newcommand{\mathO}{\mathcal{O}}

\title{State preparation by shallow circuits using feed forward}
\author[1]{Harry Buhrman}

\author[1]{Marten Folkertsma}

\author[2]{Bruno Loff}

\author[1,3]{Niels M. P. Neumann}
\date{}%September 23, 2022}

\affil[1]{QuSoft, CWI \& University of Amsterdam, Amsterdam, the Netherlands}
\affil[2]{LASIGE \& Department of Mathematics, University of Lisbon}
\affil[3]{The Netherlands Organisation for Applied Scientific Research (TNO), Delft, the Netherlands}
\begin{document}
\maketitle
\begin{abstract}
In order to achieve fault-tolerant quantum computation, we need to repeat the following sequence of four steps after we have initialized the quantum device. 
First, we perform 1 or 2 qubit quantum gates (in parallel if possible). Second, we do a syndrome measurement on a subset of the qubits. Third, we perform a fast classical computation to establish which errors have occurred (if any). And, fourth, depending on the errors, we apply a correction step. 
Then the procedure repeats with the next sequence of gates. 
These four steps are essential to accomplish fault-tolerant quantum computing. 

In order for these four steps to succeed, we need the error rate of the  gates to be below a certain threshold. Unfortunately, the error rates of current quantum hardware are still too high and do not meet this requirement. On the other hand, current quantum hardware platforms are designed with these four steps in mind.  In this work we make use of this four-step scheme not to carry out fault-tolerant computations, but to enhance short, {\em constant}-depth, quantum circuits that perform 1 qubit gates and {\em nearest-neighbor} 2 qubit gates. 
To explore how this can be useful, we study a computational model which we call \emph{Local Alternating Quantum Classical Computations} ($\LAQCC$). 
In this model, qubits are placed in a grid and they can only interact with their direct neighbors; the quantum circuits are of constant depth with intermediate measurements; a classical controller can perform log-depth computations on these intermediate measurement outcomes and control future quantum operations based on the outcome.
This model fits naturally between quantum algorithms in the NISQ era and full fledged fault-tolerant quantum computation. 

We show how an $\LAQCC$ circuit can create long-ranged interactions, which constant-depth quantum circuits cannot achieve, and use it to construct a range of useful multi-qubit operations. 
With these gates, we create three new state preparation protocols for a uniform superposition over an arbitrary number of states, $W$-states and Dicke states, the generalization of $W$-states. Furthermore, we show that this type of model contains circuits which are unlikely to be classically simulatable, as well as bound the power of this model by showing an inclusion into $\QNC^1$

%We conclude by studying the power of intermediate classical calculations, by defining a more powerful version of $\LAQCC$. 
%This version has quantum circuits of with  polynomial size and uses {\em unbounded} classical computations. 
%We use ideas from Kolmogorov complexity to show that this new class is bounded in capabilities and that post-selecting on measurement outcomes is more powerful. 
\end{abstract}

\input{introduction.tex}
\input{preliminaries.tex}
\input{model.tex}

\section{State preparation in $\LAQCC$}\label{sec:state_prep_in_LAQCC}
In this section we consider what quantum states we can prepare using an $\LAQCC$ circuit beyond the stabilizer states and Clifford circuits discussed in the previous section. 
First, we show how to create a uniform superposition of computational basis states up to size $q$, where $q$ is not a power of $2$. 
We then use this procedure to create $W$-states, the uniform superposition over all $n$-bitstrings of Hamming-weight $1$, and their generalization Dicke-$(n,k)$ states, the uniform superposition over all $n$-bitstrings of Hamming-weight $k$. 

\input{Uniform_superposition.tex}
\input{W_states.tex}
\input{Dicke_states.tex}

\input{complexity_results.tex}

\section*{Acknowledgements}
We want to thank Jonas Helsen, Joris Kattem{\"o}lle, Ido Niesen, Kareljan Schoutens, Florian Speelman, Dyon van Vreumingen and Jordi Weggemans for insight full discussions. 
%Furthermore, we would like to thank Chris Cade for suggesting to look at the oracle from~\cite{AaronsonKuperberg:2007} for separating $\LAQCC^*$ and $\mathsf{Post}$-$\BQP$ and Georgios Styliaris for first mentioning how to parallelize Clifford ladder circuits. 
Furthermore, we would like to thank Georgios Styliaris for first mentioning how to parallelize Clifford ladder circuits. 
HB and MF were supported by the Dutch Ministry of Economic Affairs and Climate Policy (EZK), as part of the Quantum Delta NL programme. 
NN was supported by the quantum application project of TNO. 
This work was supported by the Dutch Research Council (NWO/OCW), as part of the Quantum Software Consortium programme (project number 024.003.037).

\bibliography{main.bib}
\bibliographystyle{plain}
% \printbibliography


\appendix

\input{appendix.tex}

\end{document}
