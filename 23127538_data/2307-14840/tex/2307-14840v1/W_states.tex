\subsection{$W$-state in $\LAQCC$}
\label{sec:W_state_in_LAQCC}
In this section we consider the $W_n$-state and how to prepare this state in $\LAQCC$. 
The $W_n$-state is a uniform superposition over all $n$-qubit states with a single qubit in the $\ket{1}$-state and all others in the $\ket{0}$-state:
$$\ket{W_n}  = \frac{1}{\sqrt{n}}\sum_i \ket{e_i},$$
where $\ket{e_i}$ is the state with a one on the $i$-th position and zeroes elsewhere. 

A first observation is that the $W$-state can be seen as a one-hot encoding of a uniform superposition over $n$ elements. 
We can label the $n$ states with non-zero amplitude of the $W$-state with an index. More precisly, we want to find circuits that implement the following map:
\begin{align}
\label{eqn:i_to_ei}
    \ket{i}\ket{0}\mapsto \ket{0}\ket{e_i},
\end{align}
with $i$ an index and $e_i$ the one-hot encoding of $i$.
This index -- which equals the position of the $1$ -- compresses the representation from $n$ to $\log(n)$ bits. 
This compression naturally defines two operations: 
\begin{align}
\text{\textbf{Uncompress}: }& \ket{i}_{\log(n)}\ket{0}_{n} \mapsto \ket{i}_{\log(n)}\ket{e_i}_{n}, \\
\text{\textbf{Compress}: }& \ket{i}_{\log(n)}\ket{e_i}_{n} \mapsto \ket{0}_{\log(n)}\ket{e_i}_{n}.
\end{align}
Implementing both and combining them implements Mapping~\ref{eqn:i_to_ei} giving an efficient $W$-state preparation protocol. 

The \textbf{Compress} and \textbf{Uncompress} operations map between a one-hot and binary represenation of an integer $i$. We call the registers containing the binary representation index registers, and the register containing the one-hot representation the system register. The index registers serve as ancilla qubits and the $W$-state is prepared in the system register. 

\begin{lemma}
\label{lem:uncompress}
There exists an $\LAQCC$ circuit for any $n$ implementing \textbf{Uncompress}, more specifically implementing the map: $\frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}\ket{0}_n \mapsto \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}\ket{e_i}_n$. This circuit uses $\mathO(n \log(n))$ qubits placed in a grid pattern of size $n\times (\log(n))$. 
\end{lemma}
\begin{proof}
One column of the grid of length $n$ consists of system qubits placed in a line.
Adjacent to this line are $\log(n)$ index qubits. 
The left grid in Figure~\ref{fig:W_state_uncompress} shows the initial layout. 
The same figure also shows the steps to prepare the $W$-state in the system qubits. 
\begin{align*}
\frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}\ket{0}_{\log(n)}^{\otimes n-1}\ket{0}_n & \xrightarrow{(1)} \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}^{\otimes n}\ket{0}_n \\
    								   & \xrightarrow{(2)} \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}^{\otimes n}\ket{e_i}_n \\
     								   & \xrightarrow{(3)} \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}\ket{0}^{\otimes n-1}\ket{e_i}_n 
\end{align*}
Step (1) uses fanout-gates to create a fully entangled state between the different index registers.
Step (2) applies $\text{Equal}_i$ gates in parallel from each index register to its corresponding system qubit to create the state $\ket{e_i}$ in the system register. 
Step (3) uses fanout-gates to disentangle and reset the index registers. 
Combined the \textbf{Uncompress} operations maps  $\frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}\ket{0}_{\log(n)}^{\otimes n-1}\ket{0}_n \mapsto \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}\ket{0}^{\otimes n-1}\ket{e_i}_n$ as required.
\end{proof}
% Figure environment removed

\begin{lemma}
\label{lem:compress}
There exists an $\LAQCC$ circuit for any $n$ implementing \textbf{Compress}, more specifically implementing the map: $\frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}_{\log(n)}\ket{e_i}_n \mapsto \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{0}\ket{e_i}_n$. This circuit uses $\mathO(n \log(n))$ qubits placed in a grid pattern of size $n\times (\log(n))$. 
\end{lemma}
\begin{proof}
To implement \textbf{Compress}, the index registers are uncomputed using parallel $CNOT$-operations, controlled by the system register. 
These controlled gates commute for different indices in the system register and hence by Lemma~\ref{lem:unitar_parallelization} a parallel circuit for the uncomputation exists. The \textbf{Compress} operation, also shown in Figure~\ref{fig:W_state_compress}, consists of the operations:
\begin{align*}
\frac{1}{\sqrt{n}}\sum_{i = 0}^{n}\ket{i}_{\log(n)}\ket{0}_{\log(n)}^{\otimes n - 1}\ket{e_i}_n & \xrightarrow{(1)} \frac{1}{n}\sum_{i, j = 0}^{n}(-1)^{i \cdot j}\ket{j}_{\log(n)}\ket{0}_{\log(n)}^{\otimes n - 1}\ket{e_i}_n \\
    & \xrightarrow{(2)} \frac{1}{n}\sum_{i, j = 0}^{n}(-1)^{i \cdot j}\ket{j}_{\log(n)}^{\otimes n}\ket{e_i}_n \\
    & \xrightarrow{(3)} \frac{1}{n}\sum_{i, j = 0}^{n}\ket{j}_{\log(n)}^{\otimes n}\ket{e_i}_n \\
    & \xrightarrow{(4)} \frac{1}{n}\sum_{i, j = 0}^{n}\ket{j}_{\log(n)}\ket{0}_{\log(n)}^{\otimes n-1}\ket{e_i}_n \\
    & \xrightarrow{(5)} \frac{1}{\sqrt{n}}\sum_{i =0 }^{n}\ket{0}_{\log(n)}^{\otimes n}\ket{e_i}_n 
\end{align*}
Step (1) applies Hadamard gates to the first index register, changing from the computational to the Hadamard basis, in which the $NOT$-operation is diagonal;
Step (2) uses fanout-gates to create a fully entangled state in the index registers;
Step (3) applies controlled-$Z$ gates, controlled by the system qubit $i$ and with targets the qubits in the $i$-th index register corresponding to the ones in the binary representation of $i$;
Step (4) disentangles the index registers using fanout-gates; 
and, Step (5) applies Hadamard gates to clean the index register.

The controlled-$Z$ gates in Step (3) apply phases that precisely cancel the phases already present, which disentangles the index registers from the system register. 
\end{proof}
% Figure environment removed

\begin{theorem}
\label{thm:W_state}
There exists a circuit in $\LAQCC$ that prepares the $\ket{W_n}$ state. This circuit requires $\mathO(n\log(n)$ qubits placed in a grid of size size $n\times (\log(n))$.
\end{theorem}

\begin{proof}
The circuit combines the circuits of Theorem~\ref{thm:uniform_superposition_mod_q}, Lemma~\ref{lem:uncompress} and Lemma~\ref{lem:compress}.
It consists of three steps:
\begin{align*}
\ket{0}^{\otimes n}_{\log(n)}\ket{0}_n &\xrightarrow[]{(1)} \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}\ket{0}^{\otimes n-1}\ket{0}\\
        &\xrightarrow[]{(2)} \frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{i}\ket{0}^{\otimes n-1}\ket{e_i} \\
        &\xrightarrow[]{(3)}\frac{1}{\sqrt{n}}\sum_{i =0 }^{n}\ket{0}^{\otimes n}\ket{e_i} 
\end{align*}
Step one prepares the uniform superposition over indices, this can be done either by applying a layer of Hadamard gates, if $n$ is a power of $2$, requiring $\mathO(log(n))$ qubits,  or using Theorem~\ref{thm:uniform_superposition_mod_q} if $n$ is not a power of $2$ requiring $\mathO(log(n)^2)$ qubits.; Step (2) is by Lemma~\ref{lem:uncompress} and requires $\mathO(n\log(n))$ qubits; and, Step(3) is by Lemma~\ref{lem:compress} and requires $\mathO(n\log(n))$ qubits. 
\end{proof}



