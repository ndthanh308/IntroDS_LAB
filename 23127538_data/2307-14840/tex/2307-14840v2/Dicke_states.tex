\subsection{Dicke states for small $k$}
\label{sec:dicke:small_k}
In this section we generalize our method of preparing the $\ket{W}$-state in Theorem~\ref{thm:W_state} to a more general set of states, Dicke states. 
A Dicke-$(n,k)$ state is the uniform superposition over bitstrings of Hamming weight $k$ and length $n$ (which we again assume to be a power of $2$ for simplicity): 
\begin{align}
    \ket{D_k^n} = \binom{n}{k}^{-1/2}\sum_{x \in \{0,1\}^n: |x| = k} \ket{x}.
\end{align}
For $k=1$, this state is precisely the $W$-state. 
There exists an efficient deterministic method to prepare a $\ket{D_k^n}$ state that requires a circuit of width $\mathO(n)$ and depth $\mathO(n)$, independent of $k$~\cite{bartschi2019deterministic}. 
This methods starts from the $\ket{1}^{\otimes k}\ket{0}^{\otimes k - n}$ state and relies on a recursive formula for the Dicke state
\begin{align*}
    \ket{D_k^n} = \alpha_{k,n} \ket{D_k^{n-1}}\otimes \ket{0} + \beta_{k,n} \ket{D_{k-1}^{n-1}}\otimes \ket{1}.
\end{align*}
This relation implies a protocol that is inherently sequential, which is unsuited for an $\LAQCC$ implementation. 

Instead, we present an $\LAQCC$ approach similar to the $W$-state preparation protocol. 
We apply the \textbf{Uncompress} operation of the $W$-state in parallel to put $k$ ones into the bitstring. 
This method allows for the preparation of Dicke states with $k=\mathO(\sqrt{n})$, using $\mathO(n^2 \log(n)^3)$ qubits. The bound on $k$ comes from the fact that using the \textbf{Uncompress} operation in parallel might cause overlaps to where the $1$'s are put into the system register. Having two ones in the same system qubit in effect negates the \textbf{Uncompress} operation. 
Following the lines of the birthday paradox, we find that overlaps between different indices happen not that often for $k = \mathO(\sqrt{n})$.
Lemma~\ref{lem:grover_constant_fraction} allows us to boost the amplitudes and make the protocol deterministic.

Again, consider two groups of qubits: Index registers with $\log(n)$ qubits each; 
and, system registers of $n$ qubits each. 
Contrary to the $W$-state, the Dicke state requires multiple system registers during the preparation. 
The state is prepared in only one system register. 
Denote the index registers with subscripts $i_1$ up to $i_k$ and the system registers with $s_1$ up to $s_n$. 
For clarity, these indices may be omitted if it is clear from the context. 

The algorithm consists of four steps:
\begin{enumerate}
    \item \textbf{Filling}: $\ket{0}_{i_1}\dots\ket{0}_{i_k}\ket{0}_{s_1} \rightarrow \frac{1}{n^{k/2}}\sum_{j_1, \dots, j_k = 0}^{n-1} \ket{j_1}_{i_1} \dots \ket{j_k}_{i_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k} }_{s_1}$
    \item \textbf{Filtering}: $\rightarrow \sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}$
    \item \textbf{Ordering}: $\rightarrow \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}$
    \item \textbf{Cleaning}: $\rightarrow \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{0} \dots \ket{0}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}$
\end{enumerate}
Note that after \textbf{Filling} there is a multiplicity in states. First, \textbf{Filtering} removes those states in which different indices $j_l$ are the same, resulting in an incorrect state in the $s_1$ register. 
Second, \textbf{Ordering} removes the multiplicity from having multiple permutations of the index registers creating the same state in the $s_1$ register, by forcing a choice of ordering on the indices.
These two steps give a unique pairing between index registers and system registers allowing the operation \textbf{Cleaning}.

We will now proof that these four steps are achievable in $\LAQCC$ and explicitly visualize the corresponding circuits for $n=4$ and $k=2$. 

\begin{lemma}
\label{lem:Dicke_filling}
An $\LAQCC$ circuits exists that implements \textbf{Filling}:
$$\ket{0}_{i_1}\dots\ket{0}_{i_k}\ket{0}_{s_1} \rightarrow \frac{1}{n^{k/2}}\sum_{j_1, \dots, j_k = 0}^{n-1} \ket{j_1}_{i_1} \dots \ket{j_k}_{i_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k} }_{s_1}.$$ 
This circuit uses $\mathO(k n\log(n))$ qubits.
\end{lemma}
\begin{proof}
To achieve a circuit implementing \textbf{Filling} we use \textbf{Uncompress} from Lemma~\ref{lem:uncompress} $k$ times in parallel.
Note that two \textbf{Uncompress} operations commute, hence by Lemma~\ref{lem:unitar_parallelization} $k$ \textbf{Uncompress} operations can be implemented in parallel.
Each of these parallel operations requires an index register, a system register and $\mathO(n\log(n))$ extra ancilla qubits.

The corresponding circuit consists of five steps: 
\begin{align*}
\ket{0}_{i_1} \dots \ket{0}_{i_k} \ket{0}_{s_1}\dots\ket{0}_{s_k} &\xrightarrow{(1)} \frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \frac{1}{\sqrt{2^n}}\sum_{l=0}^{2^n - 1}\ket{l}_{s_1} \ket{0}_{s_2} \dots \ket{0}_{s_k}
\\
&\xrightarrow{(2)} \frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \frac{1}{\sqrt{2^n}}\sum_{l=0}^{2^n - 1}\ket{l}_{s_1} \ket{l}_{s_2} \dots \ket{l}_{s_k}
\\
&\xrightarrow{(3)}\frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \frac{1}{\sqrt{2^n}}\sum_{l=0}^{2^n - 1}(-1)^{(2^{j_1} + \dots + 2^{j_k}) \cdot l}\ket{l}_{s_1} \ket{l}_{s_2} \dots \ket{l}_{s_k}
\\
&\xrightarrow{(4)} \frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \frac{1}{\sqrt{2^n}}\sum_{l=0}^{2^n - 1}(-1)^{(2^{j_1} + \dots + 2^{j_k}) \cdot l}\ket{l}_{s_1} \ket{0}_{s_2} \dots \ket{0}_{s_k}
\\ 
&\xrightarrow{(5)} \frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1} \ket{0}_{s_2} \dots \ket{0}_{s_k}
\end{align*}
Step (1) brings all index registers in a uniform superposition of size $n$, use Theorem~\ref{thm:uniform_superposition_mod_q} if required, and one system register in a uniform superposition size $2^n$; 
Step (2) uses fan-out gates to create entangled copies of the system register; 
Step (3) applies a phase flip between every pair of index and system register using \textbf{Uncompress} of Lemma~\ref{lem:uncompress}, except instead of applying not gates to the system registers, apply phase gates;
Step (4) uses fan-out gates to disentangle and uncompute all but one of the system registers; 
Step (5) applies Hadamard gates on the system register to obtain the one-hot representation of the index registers. 
Step(3), the step that requires most qubits, requires $\mathO(n \log(n))$ qubits for every pair of index and system register, of which there are $k$, resulting in the requirement of $\mathO(kn \log(n))$ qubits. 
\end{proof}

Figure~\ref{fig:Dicke_2_state} shows these five steps graphically. 
Ancilla qubits are omitted for clarity. 
Note that some of the $j_i$ in the index registers may intersect. 
The next Filtering step takes care of that.
% Figure environment removed

\begin{lemma}
\label{lem:Dicke_filtering}
An $\LAQCC$ circuit exists that implements \textbf{Filtering}:
$$\frac{1}{n^{k/2}}\sum_{j_1, \dots, j_k = 0}^{n-1} \ket{j_1}_{i_1} \dots \ket{j_k}_{i_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k} }_{s_1} 
\rightarrow \sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.$$
\end{lemma}
\begin{proof}
First note that the state produced by the \textbf{Filling} step,
$$\frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1} ,$$
contains states in which some of the indices $j_l$ overlap. Let $\ket{\psi} = \sum_{j_1 \neq \dots \neq j_k } \ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}$, be the state in which none of the indices overlap, the desired output state. Then we can write
$$\frac{1}{n^{k/2}}\sum_{j_1\dots j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1} = \alpha \ket{\psi} + \beta \ket{\psi^{\perp}},$$
with $\ket{\psi^\perp}$ containing the states in which at least two of the indices $j_l$ ovelap. Note that $\braket{\psi}{\psi^\bot} = 0$, so $\alpha$ can be exactly calculated by counting the number of quantum states with distinct $j_i$'s, which gives $|\alpha|^2 = \frac{n!}{(n-k)! n^k}$.
Lemma~\ref{lem:birthday_paradox} gives a lower bound on $|\alpha|^2$: 
$$|\alpha|^2 = \frac{n!}{(n-k)! n^k} > e^{\frac{-2k^2}{n}},$$
which is at least constant for $k = \mathO(\sqrt{n})$. 

The state $\ket{\psi^{\bot}}$ is a superposition of states in which the system register state has Hamming weight less than $k$, because at least two of the $j_i$'s are the same causing a cancellation in the system register. We can use this to create a unitary $U_{flag}$ that flags $\ket{\psi^{\bot}}$. We implement this in two steps:
\begin{align*}
&\frac{1}{n^{k/2}}\sum_{j_1,\dots, j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1}\ket{0}_{\log(k)}\ket{0} \\
&\xrightarrow[]{(1)} \frac{1}{n^{k/2}}\sum_{j_1,\dots, j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1}\ket{|e_{j_1} \oplus \dots \oplus e_{j_k}|}\ket{0}\\
&\xrightarrow[]{(2)} \frac{1}{n^{k/2}}\sum_{j_1,\dots, j_k = 0}^{n-1}\ket{j_1}\dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}_{s_1}\ket{0}\ket{\mathbbm{1}_{|e_{j_1} \oplus \dots \oplus e_{j_k}|=k}} \\
& = \alpha\ket{\psi}\ket{1} + \beta \ket{\psi^{\bot}}\ket{0}
\end{align*}
Where $|x|$ denotes the Hamming weight of bitstring $x$.
Step (1) follows from a Hamming-weight gate (see Table~\ref{tab:QFT_Hammingweight_Threshold}), which requires $\mathO(n \log(n))$ qubits; Step (2) follows from applying an Exact$_k$ gate, requiring $\mathO(\log(n)^2)$ qubits. This same step also uncomputes the Hamming-weight gate of the first step.

Lemma~\ref{lem:grover_constant_fraction} now allows us to amplify $\alpha$ to $1$ using the oracle $U_{flag}$. This produces the state
$$\sqrt{\frac{(n-k)!}{(n)!}}\sum_{j_1 \neq \dots \neq j_k} \ket{j_1} \dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}},$$
using $\mathO(k n\log(n))$ qubits.
\end{proof}

To uncompute the index registers, we have to know which one in the system register corresponds to which index register, as any permutation of the index registers results in the same state in the system register. 
The \textbf{Ordering} step imposes an ordering on the index registers, thereby removing the redundancy in the ordering. 

\begin{lemma}
\label{lem:dicke_ordering}
An $\LAQCC$ circuit exists that implements \textbf{Ordering}:
$$\sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}} \rightarrow  \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.$$
This circuit uses $\mathO(k^2 \log(n)^2)$ qubits.
\end{lemma}
\begin{proof}
The first step of the $\LAQCC$ circuit that implements \textbf{Ordering} is to evaluate a Greaterthan-gate on all pairs of index registers, which requires $k$ copies of each index register. We require $k$ extra qubits per index register to store the outcome of the Greaterthan-gates. 
The copies of the index registers are created by doing a fan-out gate. Note that the distribution of the index registers should be set up in such a way that every possible pair can be compared by a Greaterthan-gate. 
\begin{align*}
    & \sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k} \ket{j_1}^{\otimes k} \ket{0}^{\otimes k} \dots \ket{j_k}^{\otimes k} \ket{0}^{\otimes k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}} \xrightarrow[]{(1)} \\
    & \sqrt{\frac{(n-k)!}{n!}} \sum_{j_1 \neq \dots \neq j_k} 
    \big[\ket{j_1}^{\otimes k}  \ket{\mathbbm{1}_{j_1 > j_2}} \dots \ket{\mathbbm{1}_{j_1 > j_k}}\big]
    \dots \big[ \ket{j_k}^{\otimes k}  \ket{\mathbbm{1}_{j_k > j_1}} \dots \ket{\mathbbm{1}_{j_k > j_{k-1}}}\big] 
    \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.
\end{align*}
Each $\mathbbm{1}_{j_k > j_{k'}}$ is an indicator variable that evaluates to one if and only if $j_k > j_{k'}$. This step requires $\mathO(k^2\log(n)^2)$ qubits.

Next, we compute and measure the Hamming weight of the ancilla qubits $\ket{\mathbbm{1}_{j_1 > j_2}} \dots \ket{\mathbbm{1}_{j_1 > j_k}}$, using the Hamming-weight gate. 
We measure the calculated Hamming weights. 
As all index registers were distinct before measuring, these measurements directly impose an ordering on the index registers. 

\begin{align*}
&\xrightarrow[]{(\mathrm{Hamming weight})}\sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k} \big[\ket{j_1} \ket{\mathbbm{1}_{j_1 > j_2} + \dots + \mathbbm{1}_{j_1 > j_k}}\big] \\
& \qquad\qquad\qquad\qquad\quad \dots \big[ \ket{j_k} \ket{\mathbbm{1}_{j_k > j_1} + \dots + \mathbbm{1}_{j_k > j_{k-1}}}\big] \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}\\
&\xrightarrow[]{(measure)} \binom{n}{k}^{-1/2} \sum_{j_1 < \dots < j_k} \big[\ket{j_1} \ket{0}\big] \dots \big[ \ket{j_k} \ket{k}\big] \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}
\end{align*}
This step costs $\mathO(k^2 \log(k))$ qubits.
Assume without loss of generality that the measurement outcomes impose the ordering ${j_1 < \dots < j_k}$. 
Otherwise, a permutation of the index registers achieves the same ordering, using the Permutation gate from Table~\ref{tab:Fanout_Perm}. 

Uncomputing the Hamming weights and the Greaterthan-gates gives the state 
$$\binom{n}{k}^{-1/2} \sum_{j_1 < \dots < j_k} \big[\ket{j_1} \dots \ket{j_k} \big] \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.$$
\end{proof}

The \textbf{Cleaning} step cleans the index registers for the Dicke state in a similar fashion as in the \textbf{Compress} method in the $W$-state protocol. 
In the cleaning process, we have to take the added ordering of the index registers into account. 
Suppose the $l$-th qubit of the system register is a $1$.
If this is the first $1$ in the system register, it belongs to index register $j_1$, and if it is the $m$-th $1$ it belongs to index register $j_m$. 
Computing the Hamming weight of the first $l-1$ qubits gives precisely this information.
Combined, this shows that if the $l$-th qubit is a $1$ and the Hamming weight of the first $l-1$ qubits equals $m$, then the $l$-th qubit should uncompute the $m+1$-th index register $j_{m+1}$. 

\begin{lemma}
\label{lem:dicke_cleaning}
An $\LAQCC$ circuit exists that implements \textbf{Cleaning}:
$$\frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}} \rightarrow \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{0} \dots \ket{0}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.$$
This circuit uses $\mathO(n^2 \log(n))$ qubits.
\end{lemma}
\begin{proof}
The first step, as described above, is to acquire the Hamming weight from all the substrings of the system register. This requires $n$ copies of the system register as well as a $\log(k)$-qubit register to store the Hamming weight value. The copies follow from the fanout-gate.
\begin{align*}
    &\binom{n}{k}^{-1/2} \sum_{j_1 < \dots < j_k} \ket{j_1} \dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}\ket{0}_n^{\otimes n - 1}\ket{0}_{\log(n)}^{\otimes n}\xrightarrow{(1)} \\ 
    &\binom{n}{k}^{-1/2} \sum_{j_1 < \dots < j_k} \ket{j_1} \dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}^{\otimes n}\ket{0}_{\log(n)}^{\otimes n} \xrightarrow{(2)}\\
    &\binom{n}{k}^{-1/2} \sum_{j_1 < \dots < j_k} \ket{j_1} \dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}}^{\otimes n}\bigotimes_{l=0}^{n-1}\ket{|(e_{j_1} \oplus \dots \oplus e_{j_k})_{[l,n]}|},
\end{align*}
where $|(e_{j_1} \oplus \dots \oplus e_{j_k})_{[l,n]}|$ denotes the Hamming weight of the substring consisting of qubits $l$ up until $n$ of the system register.
Step (1) copies the system qubits using fan-out gates; 
Step (2) computes the Hamming weight of all the qubits $1$ up until $j-1$ using the Hammingweight-gate shown in Table~\ref{tab:QFT_Hammingweight_Threshold};
Step (3) cleans the copies of the system register by applying fan-out. 
This step is omitted from the equations, but is included in the graphical explanation of the circuit, shown in Figure~\ref{fig:Hammingweight} for $n=4$.
Note that at the end of the calculation, it is convenient to teleport the Hamming weight registers next to the system register. There are now $n$ new registers containing the information of the Hamming weight, we will refer to them as the Hamming weight registers.
This step requires $\mathO(n^2 \log(n))$ qubits. 
% Figure environment removed

The last step that remains is to clean the $k$ index registers. Cleaning the $k$ index registers follows similar steps as the \textbf{Compress} method in the $W$-state protocol, with the added Hamming-weight information taken into account. This step requires $k$ copies of the system registers well as $k$ copies of the Hamming-weight registers. Every index register is paired with one copy of the system register and a copy of the $n$ Hamming-weight registers.
Cleaning the $j$-th register consists of five steps, similar to the \textbf{Compress} method of the $W$-state:
Step (1) applies Hadamard gates to bring the index register to phase space, in which $CNOT$-gates are diagonalized;
Step (2) copies the index register;
Step (3) uses the information in the Hamming-weight and system register to apply the phases to the correct index register qubits;
Step (4) cleans the index register copies;
and, Step (5) applies Hadamard gates to reset the index register qubits to the $\ket{0}$ state

Figure~\ref{fig:compress_dicke} shows the steps taken to clean a single index register $j$. 
The black dots represent the qubits in the system register and the upper row of blue dots represent the qubits in index register $j$.  The pink squares represent the ancilla Hamming weight register, where each square represents a group of $\log(k)$ qubits. This step requires $\mathO(n k \log(k)\log(n))$ qubits. At the end of the \textbf{Cleaning} operation the state is as desired:
$$
 \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{0} \dots \ket{0}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}.
$$
The \textbf{Cleaning} step requires $\mathO(n^2 \log(n))$ qubits.
\end{proof}

% Figure environment removed

\begin{theorem}
\label{thm:dicke_cnst_depth}
For any $n$ and $k = \mathO(\sqrt{n})$ there exists an $\LAQCC$ circuit preparing the Dicke-$(n,k)$ state, $\ket{D^n_k}$, using $\mathO(n^2\log(n))$ qubits.
\end{theorem}

\begin{proof}
The circuit combines the circuits resulting from Lemmas~\ref{lem:Dicke_filling}, \ref{lem:Dicke_filtering}, \ref{lem:dicke_ordering} and \ref{lem:dicke_cleaning}.
It consists of four steps:
\begin{align*}
\ket{0}_{i_1}\dots\ket{0}_{i_k}\ket{0}_{s_1} &\xrightarrow{(1)} \frac{1}{n^{k/2}}\sum_{j_1, \dots, j_k = 0}^{n-1} \ket{j_1}_{i_1} \dots \ket{j_k}_{i_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k} }_{s_1}\\
&\xrightarrow{(2)} \sqrt{\frac{(n-k)!}{n!}}\sum_{j_1 \neq \dots \neq j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}\\
&\xrightarrow{(3)} \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{j_1} \dots \ket{j_k}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}\\
&\xrightarrow{(4)} \frac{1}{\sqrt{\binom{n}{k}}}\sum_{j_1 < \dots < j_k}^{n-1} \ket{0} \dots \ket{0}\ket{e_{j_1} \oplus \dots \oplus e_{j_k}}
\end{align*}
Step (1) implements \textbf{Filling} using Lemma~\ref{lem:Dicke_filling} requiring $\mathO(k n \log(n))$ qubits; 
Step (2) implements \textbf{Filtering} using Lemma~\ref{lem:Dicke_filtering} requiring $\mathO(k n \log(n))$ qubits;
Step (3) implements \textbf{Ordering} using Lemma~\ref{lem:dicke_ordering} requiring $\mathO(k^2\log(n)^2)$ qubits; 
Step (4) implements \textbf{Cleaning} using Lemma~\ref{lem:dicke_cleaning} requiring $\mathO(n^2\log(n))$ qubits. After every step ancilla qubits are cleaned, so that they can be reused. As $k=\mathO(\sqrt{n})$ the largest amount of qubits required for a step is Step (4) requiring $\mathO(n^2\log(n))$ qubits.
\end{proof}
\citeauthor{bartschi2022deterministic_short_depth} posed a conjecture on the optimal depth of quantum circuits that prepare the Dicke-$(n,k)$ state. They give an algorithm for generating Dicke-$(n,k)$ states in depth $\mathO(k \log(\frac{n}{k}))$, given all-to-all connectivity, and conjecture that this scaling is optimal when $k$ is constant. Our result shows that there is a $\LAQCC$ implementation in this regime, when one has access to intermediate measurements and feed forward. This does not disprove their conjecture. However the circuits shown here are also accessible in $\QNC^1$ by Lemma~\ref{lem:LAQCC_QNC1}, giving ``pure" quantum circuits with depth $\mathO(\log(n))$ for $k = \mathO(\sqrt{n})$ and achieving better scaling when $k = \omega(1)$. 

\subsection{Dicke states for all $k$ using log-depth quantum circuits}
\label{sec:Dicke_in_LAQCC_LOG}
The previous section gave a constant-depth protocol to prepare the Dicke-$(n,k)$ state for $k=\mathO(\sqrt{n})$. 
We developed a different method for creating Dicke-$(n,k)$ states which requires logarithmic (in $n$) quantum depth to prepare Dicke-$(n,k)$, but works for arbitrary $k$. We first define what we mean with logarithmic quantum depth:
\begin{notation}
We let $\LAQCC\text{-}\mathsf{LOG}$ refer to the instance $\LAQCC(\QNC^0,\NC^1, \mathO(\log(n)))$, similar to $\LAQCC$ except that we allow for a logarithmic number of alterations between quantum and classical calculations. This results in a circuit of logarithmic quantum depth.
\end{notation}
In this section we show a $\LAQCC\text{-}\mathsf{LOG}$ circuit that creates the Dicke-$(n,k)$ state.

One way of studying the creation of Dicke states is by looking at efficient algorithms that convert numbers from one representation to another. 
An example of this is the \textbf{Uncompress}-\textbf{Compress} method in the $W$-state protocol, that converts numbers from a binary representation to a one-hot representation. 
Dicke states are a generalization of the $W$-state, hence the one-hot representation no longer suffices for preparing the state. 
Instead, we use a construction based on number conversion between the combinatorial representation and the factoradic representation.
Below we introduce both representations and present quantum circuits that map between the two. Theorem~\ref{thm:Dicke:Log_depth} proves that a $\LAQCC\text{-}\mathsf{LOG}$ circuit can prepare the Dicke-$(n,k)$ state for any $k$. 

\subsubsection{Combinatorial number system}
An interesting result showed that any integer $m\ge 0$ can be written as a sum of $k$ binomial coefficients~\cite{Beckenbach:1964}. 
For fixed $k$, this is even unique as the next lemma shows.
\begin{lemma}[\cite{Beckenbach:1964}]
\label{lem:comb_numbers}
For all integers $m\geq 0$ and $k \geq 1$, there exists a unique decreasing sequence of integers $c_k, c_{k-1},\dots, c_1$ with $c_j > c_{j-1}$ and $c_1 \geq 0$ such that 
$$m = \binom{c_k}{k}  + \binom{c_{k-1}}{k-1} \dots \binom{c_1}{1} = \sum_{i=1}^k \binom{c_i}{i}.$$
\end{lemma}

This lemma allows for the definition of the combinatorial number representation:
\begin{definition}
Let $k \in \mathbb{N}$ be a constant. Any integer $m \in \mathbb{N}$ can be represent by a unique string of numbers $(c_k, c_{k-1} \dots, c_1)$, such that $c_k > c_{k-1} \dots >  c_1 \geq 0$ and $c_k \leq m$. 
This string is given by the unique decreasing sequence of Lemma~\ref{lem:comb_numbers}. 
We call this string the \emph{index representation} denoted by $m^{indx(k)}$.

The bit string of $k$ ones at indices $(c_k,\dots, c_1)$ is the $m$-th bit string with $k$ ones in the lexicographical order. 
This bit string is called the \emph{combinatatorial representation}.
We denote the $m$-th bit string with $k$ ones as $m^{comb(k)}$.
\end{definition}

The $W$-state protocol used the conversion between the binary representation of a number $m$ and its combinatorial representation $m^{comb(1)}$.
A generalized number conversion is precisely the protocol needed to prepare Dicke states. 

A sketch of the protocol would be as follows: 
given positive integers $k$ and $n$:
Create a superposition state 
$${\binom{n}{k}}^{-\frac{1}{2}}\sum_{i=0}^{\binom{n}{k} - 1}\ket{i}\ket{0};$$
Use number conversion to go from label $i$ to $i^{comb(k)}$
$${\binom{n}{k}}^{-\frac{1}{2}}\sum_{i=0}^{\binom{n}{k} - 1}\ket{i}\ket{i^{comb(k)}};$$
Use number conversion from $i^{comb(k)}$ to $i$ to clean up the label register
$${\binom{n}{k}}^{-\frac{1}{2}}\sum_{i=0}^{\binom{n}{k} - 1}\ket{0}\ket{i^{comb(k)}} = \ket{D^n_k}.$$


The conversion map from the combinatorial representation to the binary representation is given by Lemma~\ref{lem:comb_numbers}. 
This calculation requires iterative multiplication and addition, both of which are in $\TC^0$, hence this calculation is in $\TC^0$. 

The converse mapping, from binary to combinatorial representation for given $k$, can be achieved by a greedy iterative algorithm:
On input $m$, find the biggest $c_k$ such that $m \geq \binom{c_k}{k}$ and subtract this from $m$: $\tilde{m} = m - \binom{c_k}{k}$. 
This gives $c_k$ and a residual $\tilde{m}$. 
Repeat this process for $\tilde{m}$: 
Find the largest $c_{j}$ such that $\tilde{m}\geq \binom{c_j}{j}$ and update residual $\tilde{m} = \tilde{m} - \binom{c_j}{j}$, until all $c_j$ are found. 

This greedy algorithm is inherently linear in $k$ as it requires all previously found $\{c_i\}_{i=j}^k$ to find $c_{j-1}$. 
Hence, it is not immediately obvious if and how to achieve this mapping in constant or even logarithmic depth. 

\subsubsection{Mapping between factoradic representation and combinatorial number system}
A number representation closely related to the combinatorial number representation is the \textit{factoradic representation}. 
This number system uses factorials instead of binomials to represent numbers. 

\begin{definition} 
\label{def:factoradics}
A sequence $y = (y_{n-1}, y_{n-2}, \dots, y_0)$ of integers, such that $j \geq y_j \geq 0$ is called a \textit{factoradic}, or more explicitly an \textit{$n$-factoradic}. 
The elements of an $n$-factoradic is called an \textit{$n$-digit}.
An $n$-factoradic $y$ can represent a number $m$ between $0$ and $n!-1$, in the following way
\begin{align}
\label{eqn:fact_to_int}
m = \sum_j^{n} y_j \cdot j!.
\end{align}
For a given $m \in \{0, \ldots, n!-1\}$, we call the $n$-factoradic $y$ obeying the equality above, the \emph{factoradic representation of $m$}.  
Denote $\text{Fact}(n)$ as the set of all $n$-factoradics.
\end{definition}

The following lemma shows that Equation~\ref{eqn:fact_to_int} is a bijection, showing that the factoradic representation is unique.

\begin{lemma}
\label{factoradic_summation}
For $k \geq 0$ it holds that:
$$\sum_{i=0}^k i \cdot i!= (k + 1)! - 1.$$ 
\end{lemma}
\begin{proof}
Proof by induction.\\
\textbf{BASE STEP}: Let $k$ be $0$:
$$0\cdot 0! = 1! - 1$$
\textbf{INDUCTION STEP}: Assume the lemma holds for some $j$, then
$$\sum_{i=0}^{j+1} i \cdot i! = (j+1) \cdot (j+1)! + \sum_{i = 0}^{j} i \cdot i = (j+1) \cdot (j+1)! + (j+1)! - 1 = (j+2)! - 1,$$
which completes the proof.
\end{proof}
This identity allows for using factorials as a base for a number system.
The next lemma gives a log-space algorithm to convert a factoradic representation to its combinatorial representation. 
\begin{lemma}
\label{lem:fac_to_comb}
There is a logspace algorithm $\mathcal{A}$ that, given $k \in \{0, \ldots, n\}$, and a uniformly random $n$-factoradic, outputs a uniformly random $n$-bit string of Hamming weight $k$.
\end{lemma}
\begin{proof}
The algorithm $\mathcal{A}$ is given $k$ and an $n$-factoradic $y = (y_{n-1}, \dots, y_0)$. It will then output an $n$-bit string $y^{comb(k)} = y^{comb(k)}_{n-1} \dots y^{comb(k)}_0 \in \{0,1\}^n$ of Hamming weight $k$, one bit at a time, from left to right, according to the following rule. Let $H_{>n-j} = \sum_{i=n-j+1}^{n-1} y^{comb(k)}_i$ be the Hamming weight of the bits produced before we reach bit $n-j$. Then $y^{comb(k)}_{n-j}$ is given by:
\begin{align}
\label{eqn:fac_to_comb}
    (\mathcal{A} (y))_{n-j} = y^{comb(k)}_{n-j} = \begin{cases} 1 & \text{if } y_{n-j} < k - H_{>n-j} \\
    0 & \text{otherwise}
    \end{cases}.
\end{align}
This conversion requires comparing an $n$-digit with a constant and the Hamming weight of a bitstring.
The only information that $\mathcal A$ needs to remember, as it goes from bit $n-j+1$ to bit $n-j$ , is the Hamming weight $H_{>n-j}$ of the bits it produced so far, and this can be stored in logarithmic space. 

Now note that the number of factoradic $n$-digit strings that map to the same combinatorial bit string is always $k!(n-k)!$:
Let $y^{comb(k)} \in \{0,1\}^n$ have Hamming weight $k$. 
For any bit position $y^{comb(k)}_{n-j}$, there are $n - j + 1 - (k - H_{>n-j})$ possible choices for the $n$-digit $y_{n-j} \in \{0, \ldots, n-j\}$ that set $y^{comb(k)}_{n-j} = 0$. 
For the leftmost index $n-j$ such that $y^{comb(k)}_{n-j} = 0$, it holds that $H_{>n-j} = j-1$, and then there are $n-k$ possible $n$-digits $y_{n-j}$ that set $y^{comb(k)}_{n-j} = 0$. 
Then, for the second index $n-j$ such that $y^{comb(k)}_{n-j} = 0$ it holds that $H_{>n-j} = j - 2$, hence there are $n - k - 1$ possible $n$-digits $y_{n-j}$ causing $y^{comb(k)}_{n-j} = 0$. And so forth. 
This results in $(n-k)!$ different possible choices for the $(n-k)$-many $n$-digits where $y^{comb(k)}=0$. 

Similarly, for the leftmost position $n-j$ where $y^{comb(k)}_{n-j} = 1$, there are $k$ possible choices for the $n$-digit $y_{n-j}$ that cause $y^{comb(k)}_{n-j} = 1$. 
The second leftmost position $n-j$ gives $k-1$ possible choices, and so forth, for a total of $k!$ possible settings of the $k$-many $n$-digits where $y^{comb(k)}=0$.

Combined, we conclude that, for every $n$-bit string $y^{comb(k)} \in \{0,1\}^n$ of Hamming weight $k$, there are exactly (the same number of) $k!(n-k)!$ $n$-factoradics $y$ such that $\mathcal A(y) = y^{comb(k)}$.
Hence, a uniformly random $n$-factoradic is mapped by $\mathcal A$ to a uniformly random $n$-bit string of Hamming weight $k$, as claimed.
\end{proof}

This lemma gives a logspace algorithm to convert a uniformly random $n$-factoradic to a uniformly random $n$-bit string of Hamming weight $k$, for any $k$.
It is well known that logspace is contained in $\TC^1$, allowing this calculation to be performed in parallel log-depth when one has access to threshold gates~\cite{Johnson:1990}. As we saw in Section~\ref{sec:gates_created_in_LAQCC}, we can compute a threshold gate in $\LAQCC$. Hence, an $\LAQCC\text{-}\mathsf{LOG}$ can perform any $\TC^1$ calculation. We conclude:

\begin{corollary}\label{cor:fac_to_comb}
The following map can be implemented in $\LAQCC\text{-}\mathsf{LOG}$.
\[
\frac{1}{\sqrt{n!}} \sum_{y \in \text{Fact}(n)} \ket{y}\ket{0} \xrightarrow{} \frac{1}{\sqrt{n!}} \sum_{y \in \text{Fact}(n)} \ket{y}\ket{\mathcal A (y)}.
\]
\end{corollary}
 

\noindent In the next lemma, we show that a $\TC^0$ circuit can implement the inverse of $\mathcal A$. 
\begin{lemma}
\label{lem:comb_to_fac}
There exists a $\TC^0$ algorithm which, when given an $n$-bit string $y^{comb(k)}$ of Hamming weight $k$, a uniformly-random $k$-factoradic, and a uniformly-random $(n-k)$-factoradic, outputs a uniformly random $n$-factoradic $y$ among those such that $\mathcal A(y) = y^{comb(k)}$.
\end{lemma}

\begin{proof}
The conversion can be done in parallel, generating an $n$-digit for every bit in $y^{comb(k)} = y_{n-1} \dots y_0\in\{0,1\}^n$. Recall that we are given as input a uniformly-random $k$-factoradic $O_{k-1}, \dots, O_0$ and a uniformly-random $(n-k)$-factoradic $Z_{n-k-1}, \dots, Z_0$.

For every bit position $n-j$, for $1 \le j \le n$, calculate the Hamming weight of the bits from $n-j+1$ to $n-1$: $H_{>n-j} = \sum_{i=j+1}^{n-1} y^{comb(k)}_i$. Recall that iterated addition is in $\TC^0$~\cite{vollmer1999introduction}.

If $y^{comb(k)}_{n-j} = 1$, set $y_{n-j} = O_{k - H_{> n-j}}$. This gives a uniform random $n$-digit between $0$ and $k - H_{> n-j} - 1$. If $y^{comb(k)}_{n-j} = 0$, set $y_{n-j} = k - H_{> n-j} + Z_{n-k-H_{>n-j}}$. 
Note that this gives a uniform random $n$-digit between $k - H_{>n-j}$ and $n - j$. 
By construction, it now follows that $\mathcal A(y) = y^{comb(k)}$. 
Computing each $n$-digit in this way requires summation and indexing, both of which are in $\AC^0 \subseteq \TC^0$~\cite{vollmer1999introduction}.
\end{proof}

\begin{remark}\label{rem:comb_to_fac}
The above algorithm establishes a bijection $(y^{comb(k)}, Z, O) \leftrightarrow y$  between triples $(y^{comb(k)}, Z, O)$ with $y^{comb(k)} \in \{0,1\}^n$ of Hamming weight $k$, $Z \in \text{Fact}(n-k)$ and $O\in\text{Fact}(k)$ and $n$-factoradics $y \in \text{Fact}(n)$. Let $(\mathcal A(y), \mathcal Z(y), \mathcal O(y))$ be the image of an $n$-factoradic $y$ under this bijection. The previous lemma shows that one can compute $y$ from $(y^{comb(k)}, Z, O)$ in $\TC^0$. 
It is not hard to see that the map $(\mathcal A(y), y) \mapsto (\mathcal A(y), y, \mathcal Z(y), \mathcal O(y))$ is also in $\TC^0$. Indeed, to find $\mathcal Z(y)$ and $\mathcal O(y)$, we need only invert the two defining equalities $y_{n-j} = O_{k - H_{> n-j}}$ and $y_{n-j} = k - H_{> n-j} + Z_{n-k-H_{>n-j}}$.
\end{remark}

\begin{corollary}\label{cor:comb_to_fac}
The following map can be implemented in $\LAQCC$.
\[
\begin{pmatrix}n \\ k\end{pmatrix}^{-\frac{1}{2}}\sum_{y^{comb(k)}} \ket{0} \ket{y^{comb(k)}} \xrightarrow{} \frac{1}{\sqrt{n!}} \sum_{y \in \text{Fact}(n)} \ket{y}\ket{\mathcal A (y)}
\]
where $y^{comb(k)}$ ranges over all $n$-bit strings of Hamming weight $k$.
\end{corollary}

\begin{proof}
The transformation consists of three steps: 
\begin{align*}
& \binom{n}{k}^{-\frac{1}{2}}\sum_{y^{comb(k)}} \ket{y^{comb(k)}} \ket{0}\ket{0}\ket{0}\\
\xrightarrow{(1)} \;\; &\binom{n}{k}^{-\frac{1}{2}}\sum_{y^{comb(k)}} \ket{y^{comb(k)}} \left(\bigotimes_{j = 0}^{n-k-1} \sum_{i = 0}^{j} \ket{i}\right)\left(\bigotimes_{j = 0}^{k-1} \sum_{i = 0}^{j} \ket{i}\right)\ket{0}\\
= \;\; & \frac{1}{\sqrt{n!}} \sum_{y^{comb(k)}} \ket{y^{comb(k)}} \left(\sum_{Z\in\text{Fact}(n-k)} \ket{Z}\right)\left(\sum_{O\in\text{Fact}(k)} \ket{O}\right)\ket{0}\\
\xrightarrow{(2)}\;\; & \frac{1}{\sqrt{n!}} \sum_{y\in\text{Fact}(n)} \ket{\mathcal A(y)} \ket{\hat Z(y)}\ket{\hat O(y)}\ket{y}\\
\xrightarrow{(3)}\;\; & \frac{1}{\sqrt{n!}} \sum_{y\in\text{Fact}(n)} \ket{\mathcal A(y)} \ket{0}\ket{0}\ket{y}
\end{align*}
Step (1) prepares a uniform superposition over all $n$-factoradics using Theorem~\ref{thm:uniform_superposition_mod_q}. 
Step (2)  is Lemma~\ref{lem:comb_to_fac}, and Step (3) follows from Remark~\ref{rem:comb_to_fac}.
In the above steps we implicitly used that the inverse of the used $\LAQCC$ operations are also $\LAQCC$ operations. 
Even though it is unclear if this inverse-property holds in general, it does hold for the considered $\LAQCC$ operations. 
The measurement steps, which might not be reversible, in this algorithm are used to implement fan-out gates.
The inverse of a fan-out gate is the fan-out gate itself and hence is contained in $\LAQCC$.
\end{proof}

\begin{theorem}
\label{thm:Dicke:Log_depth}
There exists a $\LAQCC\text{-}\mathsf{LOG}$-circuit for preparing Dicke-$(n,k)$ states, for any positive integers $n$ and $k \le n$, it uses $\mathO(\text{poly}(n))$ qubits. 
\end{theorem}
\begin{proof}
The circuit combines the circuits resulting from Lemma~\ref{lem:fac_to_comb} and Lemma~\ref{lem:comb_to_fac}. 

It consists of three steps: 
\begin{align*}
\ket{0}^{\otimes n \log(n)}\ket{0}^{\otimes n} &\xrightarrow{(1)} \frac{1}{\sqrt{n!}}\left(\bigotimes_{j = 0}^{n-1} \sum_{i = 0}^{j} \ket{i}\right)\ket{0}^{\otimes n} = \sum_{y \in \text{Fact}(n)} \ket{y}\ket{0} \\
&\xrightarrow{(2)} \frac{1}{\sqrt{n!}} \sum_{y \in \text{Fact}(n)} \ket{y}\ket{\mathcal A (y)}\\
&\xrightarrow{(3)} \begin{pmatrix}n \\ k\end{pmatrix}^{-\frac{1}{2}}\sum_{y \in \text{Fact}(n)} \ket{0}\ket{\mathcal A (y)} = \ket{D^n_k}.
\end{align*}
Step (1) prepares a uniform superposition over all $n$-factoradics using Theorem~\ref{thm:uniform_superposition_mod_q};
Step (2) is by Corollary \ref{cor:fac_to_comb};
and, Step (3) reverses the algorithm of Corollary \ref{cor:comb_to_fac}.
\end{proof}

\subsection{Quantum many-body scar states}
\label{sec:many_body_scar}
There is a particular set of states in many-body physics called, many-body scar states, which are highly excited states that exhibit atypically low entanglement~\cite{turner2018weak}. These states exhibit long coherence times relative to other states at the same energy density and seem to avoid thermalization and thereby they do not follow the eigenstate thermalization hypothesis.
This makes studying the lifetime of quantum many body scar states under perturbations particularly interesting.
Studying this lifetime is quite challenging, as even though scarred eigenstates often have modest entanglement and therefore have efficient matrix product state representations, perturbations typically couple them to states nearby in energy which typically have volume-law scaling entanglement, making classical simulations difficult.

A overview paper by \citeauthor{Gustafson:2023} studied methods of preparing quantum many-body scar states on quantum computers, with the goal to simulate time dynamics directly on the quantum system~\cite{Gustafson:2023}. 
They found several approaches for generating quantum many-body scars for a particular model, which require polynomial depth. They look at quantum many-body scar states of the $n$-qubit spin-1/2 Hamiltonian of~\cite{iadecola2020quantum}:
\[
    H = \lambda \sum_{i = 2}^{n - 1} (X_i - Z_{i - 1} X_i Z_{i +1}) + \Delta \sum_{i = 1}^n Z_i + J \sum_{i = 1}^{n-1} Z_i Z_{i + 1}
\]

The quantum many-body scar states of $n$-qubits are given by:
\[
\ket{S_k} = \frac{1}{k! \sqrt{\mathcal N(n,k)}}(Q^\dagger)^k \ket{\Omega},
\]
where $\mathcal N(n,k) = \binom{n - k - 1}{k}$, $\ket{\Omega} = \ket{0}^{\otimes n}$ and $k = 0, \dots, n/2 - 1$. The raising operator $Q^\dagger$ is given by:
\[
 Q^\dagger = \sum_{i = 2}^{n-1} (-1)^i P_{i-1} \sigma^+_{i} P_{i +1}, 
\]
with $P_j = \ket{0}\bra{0}$ and $\sigma^+_j = X_j + Y_j$.
They show that up to local $Z$ gates these states are very closely related to Dicke states:
\[
    \prod_{\text{i odd}} Z_i \ket{S_k} = \ket{0} \otimes P_{fib} \ket{D^n_k}\otimes \ket{0},
\]
where $P_{fib}$ is known as the Fibonacci constraint, which is a projector that removes all states where there are two ones next to each other:
\[
P_{fib} = I - \sum_{i = 1}^{n-1} \ket{11}\bra{11}_{i,i+1}.
\]
The goal of this section is to show that these states, for $k = \mathO(\sqrt{n})$ are accessible in $\LAQCC$. First note that by Theorem~\ref{thm:dicke_cnst_depth} there exists a $\LAQCC$ protocol to generate $\ket{D_k^n}$ up to $k = \mathO(\sqrt{n})$.
We will show that there is a $\LAQCC$ protocol that applies $P_{fib}$ to these $\ket{D^n_k}$ states. The first step will be to show that there exists a unitary accessible in $\LAQCC$ that flags the correct state.

\begin{lemma}
\label{lem:Ufib}
There exists a unitary $U_{fib}$, accessible in $\LAQCC$, that flags all the states that obey the Fibonacci constraint, more precisely:
\[
    U_{fib} \ket{D_k^n}\ket{0} = \alpha P_{fib}\ket{D_k^n}\ket{0} + \beta (I - P_{fib})\ket{D_k^n}\ket{1}
\]
\end{lemma}
\begin{proof}
Add $n$ extra qubits prepared in $\ket{0}$, one for every sequential pair of qubits. 
For all $i\in\{1,\hdots,n-1\}$, apply a Toffoli gate with control qubits $i$ and $i + 1$ and target qubits the $i$-th auxillary qubit. 
The second step is to apply the $OR_{n}$ gate on the $n$ auxillary qubits.
The $n$-th auxillary qubit is also used as the output qubit. 
Clean the extra qubits by again applying Toffoli gates. These steps are accessible in $\LAQCC$ therefore implements the flag unitary with an $\LAQCC$ protocol.
\end{proof}

The second step is to show that $\alpha$ is bounded by a constant in the case that $k = \mathO(\sqrt{n})$, this is shown using the following two lemma's.

\begin{lemma}

The total number of bitstrings of length $n$ with $k$ ones, such that no two ones are adjacent is given by:
\[
    \binom{n - k}{k} + \binom{n - k - 1}{k - 1}
\]
\end{lemma}

\begin{proof}
We can count the number of possible bitstrings, after first noticing that every $1$ must be followed by a $0$, unless the last bit is a $1$. 
As a result, we have two situations, in the first, we can consider all possible rearrangements $n-k$ elements, consisting of $k$ pairs `$10$' and $n-2k$ ones. 
This gives $\binom{n-k}{k}$ possible bitstrings. 
In the second situation, the last bit is $1$. 
This leave $k-1$ pairs `$10$' in a total of $n-k-1$ elements. 
With the same reasoning, this gives $\binom{n-k-1}{k-1}$ possible bitstrings. 
Summing the two situations proves the lemma. 
\end{proof}

We now consider the relative fraction of this type of bitstrings among all possible bitstrings with Hamming-weight $k$. 
\begin{lemma}
\label{lem:fraction_good_strings}
Let $k = c\sqrt{n}$ for some constant $c>0$. 
Then the following inequality holds
\[
\frac{\binom{n - k}{k} + \binom{n - k - 1}{k - 1}}{\binom{n}{k}} \geq \exp\big(-c^2\big)
\]
\end{lemma}

\begin{proof}
We have
\[
\frac{\binom{n - k}{k} + \binom{n - k - 1}{k - 1}}{\binom{n}{k}} > \frac{\binom{n - k}{k}}{\binom{n}{k}} = \frac{(n-k)! / k!(n-2k)!)}{n!/ k!(n-k!)} = \frac{(n-k)!^2}{n!(n-2k)!}.
\]
Expanding the factorials and only consider the terms that do not cancel, we obtain
\[
\frac{(n-k)!}{n!} \frac{(n-k)!}{(n-2k)!} = \frac{(n-k)(n- k - 1)\dots (n- (2k - 1))}{n (n-1)\dots (n - (k-1))}.
\]
Both the numerator and denominator have $K$ terms, which we can pair. 
next we note that $\tfrac{a}{b} > \tfrac{a-1}{b-1}$ whenever $b>a$ (and $b\not\in\{0,1\}$). 
Using this idea, we obtain the following expression:
\[
\frac{n-k}{n}\frac{n-k-1}{n-1}\dots \frac{n-(2k-1)}{n-(k-1)} > (\frac{n-k}{n})^k = (1 - \frac{k}{n})^k.
\]
Now using that $k = c \sqrt{n}$, we have
\[
\left(1 - \frac{c \sqrt{n}}{n}\right)^{c\sqrt{n}}  = \left(\left(1-\frac{c}{\sqrt{n}}\right)^{\frac{\sqrt{n}}{c}}\right)^{c^2} > \exp\big(-c^2\big),
\]
which is a constant.
\end{proof}

This allows us construct the state $\ket{S_k}$ using the steps for the Dicke-state preparation together with Lemma~\ref{lem:grover_constant_fraction}. 
Note that Lemma~\ref{lem:grover_constant_fraction} requires us to implement both $U$ and $U^{\dagger}$, where $U$ implements the initial superposition.
The \textbf{Ordering}-step (Lemma~\ref{lem:dicke_ordering}) does however use measurements, which stops us makes implementing the inverse of the circuit hard. 
Still, we can work around this, by applying Lemma~\ref{lem:grover_constant_fraction} between the \textbf{Filtering} and \textbf{Ordering} step:
\begin{theorem}
For any $n$ and $k = \mathO(\sqrt{n})$ there exists a $\LAQCC$ circuit preparing the many-body scar state $\ket{S_k}$, using $\mathO(n^2\log(n))$ qubits.
\end{theorem}
\begin{proof}
We follow the same steps as for the Dicke-state preparation (see Theorem~\ref{thm:dicke_cnst_depth}). 
After the second \textbf{Filtering} step however, we apply use the unitary $U_{fib}$ together with Lemma~\ref{lem:grover_constant_fraction} to filter out all states with subsequent ones in the state. 
Note that by Lemma~\ref{lem:fraction_good_strings}, the number of states with no consecutive ones is a constant fraction of the total number of strings of Hamming-weight~$k$. 

Furthermore, the state after the Filtering step,
\begin{equation*}
    \sqrt{\frac{(n-k)!}{(n)!}}\sum_{j_1 \neq \dots \neq j_k} \ket{j_1} \dots \ket{j_k} \ket{e_{j_1} \oplus \dots \oplus e_{j_k}},
\end{equation*}
is still entangled with the index registers. In effect there are many copies of the Dicke-$(n,k)$ state in on the system register, each with a diferent ordering of the index registers, however this does not affect the fraction of states with no consecutive ones compared to the states with consecutive ones. 
Next, the \textbf{Ordering} and \textbf{Cleaning} step of the protocol work similarly on the resulting state and will give the state $\ket{S_k}$.
\end{proof}
