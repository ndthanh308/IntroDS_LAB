\section{Introduction}
Current quantum hardware is unable to carry out universal quantum computations due to the buildup of errors that occur during the computation. 
The magnitude of the individual error is currently above the value that the Threshold Theorem requires in order to kick-start quantum error correction and fault-tolerant quantum computation~\cite[Section 10.6]{nielsen_chuang_2010}. 
Although the experimentally achieved fidelity rates are promising and the error bounds are inching closer to the required threshold, we will have to work for the foreseeable future with quantum hardware with errors that build-up during the computation.  This implies that we can only do a limited number of steps before the output of the computation has become completely uncorrelated with the intended one.

For fault-tolerant quantum computing, we repeat four steps: 
1) We apply a number of single and two-qubit quantum gates, in parallel whenever possible; 
2) We perform a syndrome measurement on a subset of the qubits; 
3) We perform fast classical computations to determine which errors have occurred and how to correct them; 
and, 4) We apply correction terms based on the classical computations.
We then repeat these four steps with a next sequence of gates. 
These four steps are essential to fault-tolerant quantum computing. 


The starting point of this work is to use the four steps outlined above, not to carry out error correction and fault-tolerant computation, but to enhance short, constant-depth, {\em uncorrected} quantum circuits that perform single qubit gates and {\em nearest-neighbor} two qubit gates. 
Since in the long run we will have to implement error-correction and fault-tolerant computation anyhow, and this is done by such a four-step process, why not make other use of this architecture? Moreover, on some of the quantum hardware platforms, these operations are already in place.
Embracing this idea we naturally arrive at the question: what is the computational power of \textit{low-depth} quantum-classical circuits organized as in the four steps outlined above? 
We thus investigate circuits that execute a small, ideally constant, number of stages, where at each stage we may apply, in parallel, single qubit gates and {\em nearest-neighbor} two qubit gates, followed by measurements, followed by low-depth classical computations of which the outcome can control quantum gates in later stages. 
It is not clear, at first, whether such circuits, especially with constant depth, can do anything remotely useful. 
But we will see that this is indeed the case: many quantum computations can be done by such circuits in constant depth. 
By parallelizing quantum computations in this way, we improve the overall computational capabilities of these circuits, as we do not incur errors on qubits that are idle, simply because qubits are not idle for a very long time. 
Furthermore, reducing the depth of quantum circuits, at the cost of increasing width, allows the circuit to be run faster even if errors occur.

The first usage of such a four-step layout, not to do error correction, but to perform computations, can be found in the paradigm of measurement-based quantum computing~\cite{gottesman1999demonstrating,raussendorf2001one,jozsa2006introduction,clark2007generalised}: 
A universal form of quantum computing where a quantum state is prepared and operations are performed by measuring qubits in different bases, depending on previous measurements and intermediate measurements.

\citeauthor{PhamSvore2013} were the first to formalize the four-step protocol for performing computations~\cite{PhamSvore2013}. They included specific hardware topologies by considering two-dimensional graphs for imposing constraints on qubit interactions. In their model, they develop circuits for particularly useful multi-qubit gates, including specifying costs in the width, number of qubits, depth, number of concurrent time steps, size, and total number of non-Identity operations.
As a result, they find an algorithm that factors integers in polylogarithmic depth.
\citeauthor{Browne:2011} showed that the main tool in the work by \citeauthor{PhamSvore2013}, the fan-out gate, can also be replaced by additional log-depth classical computations in the measurement-based quantum computing setting~\cite{Browne:2011}.

More recently, \citeauthor{Cirac:2021} introduced a scheme to implement unitary operations involving quantum circuits combined with Local Operations and Classical Communication ($\mathsf{LOCC}$) channels: $\mathsf{LOCC}$-assisted quantum circuits~\cite{Cirac:2021}. Similarly to the four-step scheme we just described, they allow for a short depth circuit to be run on the qubits, followed by one round of $\mathsf{LOCC}$, in which ancilla qubits are measured and local unitaries are applied based on the measurement outcomes. They show that in this model any 1D transitionally invariant matrix-product state (MPS) with fixed bond dimension is in the same phase of matter as the trivial state. Similar ideas can be found in~\cite{TVV_NonAbelianTopologicalOrder_2022, tantivasadakarn2021long}.

In this work, we introduce a new model, called \textit{Local Alternating Quantum-Classical Computations} ($\LAQCC$). In this model we alternate between running quantum circuits (constrained by locality), ending in the measurement of a subset of qubits, and fast classical computations based on the measurement results. The outcome of the classical computations are then used to control future quantum circuits. We allow for flexibility in this model, by giving different constraints to the power of both the quantum circuits and the classical circuits as well as the number of alternations between them. 
Most attention will be given to $\LAQCC$ containing quantum circuits of constant depth, classical circuits of logarithmic depth and at most a constant number of alternations between them. 
Any circuit constructed in this model is considered to be of constant depth. 
We restrict ourselves to logarithmic depth classical computations, as this is the first natural and non-trivial extension beyond constant-depth classical computations. 
Constant-depth classical computations do however also have an equivalent constant-depth quantum implementation.

The definition of $\LAQCC$ sharpens the original definition of \citeauthor{PhamSvore2013} by adding constraints to the intermediate classical computations. This allows us to bound the power of $\LAQCC$ from above. 

The main result of \citeauthor{Cirac:2021}, that 1D translational invariant MPS with fixed bond dimension can be prepared by $\mathsf{LOCC}$-assisted circuits, relies on local symmetries of the MPS. These symmetries allow them to prepare local states (on a constant number of qubits) and glue them together by doing one round of the appropriate entangling measurement and corrections, after which they run a round of local unitaries to get the desired result. This general scheme for preparing states that exhibit an MPS description with the appropriate local symmetries requires only geometrically local unitaries and one round of measurement and corrections an therefore is accessible in $\LAQCC$. Studying different local symmetries, known as Symmetry Protected Topological (SPT) phases of matter, to find measurement-based constant depth circuits for states is a broad ongoing field of research~\cite{TVV_NonAbelianTopologicalOrder_2022, tantivasadakarn2021long, smith2023deterministic}. 
All these schemes have a $\LAQCC$ implementation.

%$\LAQCC$-circuits also exist for general schemes of preparing local states, based on the local tensors, and gluing them together using one round of entangled measurement and corrections, based on the local symmetry. 
%The main result of \citeauthor{Cirac:2021}, that 1D translational invariant MPS with fixed bond dimension can be prepared by $\mathsf{LOCC}$-assisted circuits, relies heavily on local symmetries of the MPS and as a result also has an equivalent $\LAQCC$ implementation. 
%The corrections applied after the measurement round are local unitaries depending on the local symmetries of the MPS. 

 

%This general scheme of preparing local states, based on the local tensors, and gluing it together by doing one round of entangled measurement and corrections, based on the local symmetry, is accessible in $\LAQCC$.
Note however that \citeauthor{Cirac:2021} also suggest a circuit for the $W$-state.
This circuit uses sequentially and dependent measurement-based corrections of the ancilla qubits. 
These dependent measurements translate to sequential alternations between the quantum and classical circuits and therefore increase the total depth to linear depth, exceeding the constant-depth constraints imposed by $\LAQCC$-circuits. 

We study the power of the $\LAQCC$ model with respect to state preparation, showing that even with only constant quantum-depth and logarithmic classical depth it remains possible to prepare states with long-range entanglement.
Another surprising result is that it is unlikely that $\LAQCC$ circuits are classically simulatable. We show that any instantaneous quantum polynomial-time (IQP) circuit~\cite{Bremner2010,Shepherd2009} has an $\LAQCC$ implementation.
Classical simulation of IQP circuits implies the collapse of the polynomial hierarchy to the third level, which is not believed to be true~\cite{Bremner2017}. Therefore, we expect that $\LAQCC$ circuits are unlikely to be classically simulatable. We bound the power of $\LAQCC$ by showing that it is contained in $\QNC^1$, the class of polynomial-size, log-depth circuits.

Next, we also study the power that intermediate classical calculations can add to quantum computations, by considering a new model that alternates between polynomially many polynomial-depth quantum circuits and unbounded classical computations
We study this model by doing a complexity theoretical analysis, where we draw inspiration from the notions of complexity given by \citeauthor{RosenthalYuen:2022}, \citeauthor{MetgerYuen:2023}, and \citeauthor{Aaronson:2004}.
All three complexity notions are based on the notion of state preparation, instead of more traditional definition of complexity such as the decidability of a computational problem. 
The first two consider classes based on sequences of quantum states preparable by a polynomial-sized quantum circuit, where the circuits are uniformly generated by a computational class, for instance, the class $\mathsf{PSPACE}$, which results in the complexity class $\mathsf{StatePSPACE}$~\cite{RosenthalYuen:2022,MetgerYuen:2023}.
The third notion considers a relative complexity, where the complexity is measured between two given states, and is measured by the number of gates, from a given gate-set, required to transform one state in another state~\cite{Aaronson:2004}. 
For our definition of state preparation complexity, we drop the uniformity constraint from~\cite{RosenthalYuen:2022,MetgerYuen:2023} and define a class as $\mathsf{StateX}$, which refers to states preparable by circuits of type $\mathsf{X}$. 
As an example, if $\mathsf{X} = \QNC^0$, this results in the class $\mathsf{StateQNC^0}$, which is the set of states preparable from the $\ket{0}^n$ state by poly-size constant-depth circuits. 
This notion is similar to the relative complexity from~\cite{Aaronson:2004}, where one state is the  $\ket{0}^n$ state and instead of counting the number of gates we consider the set of states preparable by a fixed number of gates. Using this notion of complexity we show that any state preparable by an $\LAQCC^*$ circuit is also preparable by a $\mathsf{PostQPoly}$ circuit, the class of circuits of polynomial depth with an additional post-selection gate. 

All Clifford circuits have a constant-depth $\LAQCC$ implementation, implying that any stabilizer state can be implemented by a constant-depth $\LAQCC$ circuit, see Section~\ref{sec:clifford_circuits} for a proof of this statement. 
Efficient circuits for stabilizer states have been known already through measurement-based quantum computing. Therefore this paper focuses on the preparation of non-stabilizer states, and as a surprising result we find novel constant-depth protocols for four very natural classes of non-stabilizer states.
Despite the extensive research into these four classes of non-stabilizer states and the many applications of them, no efficient constant- or low-depth state preparation protocols are known yet. We specifically consider these four classes as they are all often used as initial states in other algorithms.

The first state is a uniform superposition over an arbitrary number of states. 
This state finds applications in many quantum algorithms, as they often start with a uniform superposition over multiple states. 
This superposition is often achieved by applying Hadamard gates to every qubit due to its simplicity to prepare. 
Yet, the analysis of many algorithms, such as Shor's algorithm~\cite{Shor:1997}, would benefit from a different initial superposition. 
The circuit to prepare the uniform superposition over an arbitrary number of states uses an exact version of Grover search as a subroutine, that turns a probabilistic circuit, with a known constant probability of success, into a deterministic circuit. 
We use the circuit for preparing a uniform superposition over an arbitrary number of states as a subroutine in the next two quantum state preparation protocols. 

The second state is the $W$-state, the uniform superposition over all computational basis states of Hamming-weight~$1$, a natural long-ranged entangled state that displays a fundamentally nonequivalent type of entanglement from the Greenberger–Horne–Zeilinger state~\cite{WState:2000}, for which $\LAQCC$-type constant-depth circuits were previously known~\cite{PhamSvore2013, Cirac:2021}. 
The $W$-state is often used as benchmark for new quantum hardware~\cite{Haffner2005,Neeley2010,GarciaPerez:2021}. 
A novel way to prepare the $W$-state therefore gives a new way to benchmark different quantum devices with each other. 
A circuit for preparing the $W$-state was given in~\cite{Cirac:2021}, but this implementation requires sequentially alternating measurements followed by local unitaries, which in the $\LAQCC$ model is not considered to be of constant depth. 
We improve this protocol by giving an $\LAQCC$ implementation of the $W$-state, based on a compress-uncompress method that links the one-hot and binary encoding of integers.

The third state considered is the Dicke state, a generalization of the $W$-state, a superposition over all computational basis states with Hamming-weight $k$~\cite{Dicke:1954}. 
Dicke states have relevance in various practical settings.
For instance, for quantum game theory~\cite{zdemir2007}, quantum storage~\cite{Bacon_Compress:2006,Plesch:2010}, quantum error correction~\cite{ouyang2014permutation}, quantum metrology~\cite{toth2012multipartite}, and quantum networking~\cite{prevedel2009experimental}. 
Dicke states have been used as a starting state for variational optimization algorithms, most notably Quantum Alternating Operator Ansatz (QAOA)~\cite{Hadfield2019}, to find solutions to problems such as Maximum k-vertex Cover~\cite{Brandhofer2022,cook2020quantum}.
The ground states of physical Hamiltonians describing one-dimensional chains tend to show a resemblance to Dicke states such as states resulting from the Bethe ansatz, making them an ideal starting state when investigating the ground state behavior of these Hamiltonians~\cite{TDL_BetheAnsatzDerivation:2010,B_ExcitedStateQuantumPhaseTransitions:2013,DickeTransitions:2021}. 
For instance, the algorithm by \citeauthor{van2021preparing}, who give an algorithm to prepare the Bethe ansatz eigenstates of the spin-1/2 XXZ spin chain, starts by first preparing a Dicke state~\cite{van2021preparing}. 
A Dicke-state preparation protocol based on the compress-uncompress methodology used in the $W$-state furthermore finds applications in entanglement distillation, where the entanglement of a large state is concentrated on only a few qubits. 
Efficient deterministic circuits for preparing Dicke states have been proposed by \citeauthor{bartschi2019deterministic}~\cite{bartschi2019deterministic, bartschi2022deterministic_short_depth}. 
They provide a quantum circuit of depth $\mathO(k \log(\frac{n}{k}))$, allowing arbitrary connectivity, to prepare a Dicke state, which they conjecture to be optimal when $k$ is constant. 
In this work, we provide a constant-depth $\LAQCC$ circuit below their conjectured bound already for constant $k$. 
However, this does not directly disprove their conjecture, as we allow for intermediate measurements and classical computations. 
More significantly, we even construct constant-depth $\LAQCC$ circuits for $k = \mathO(\sqrt{n})$ greatly improving their bound.
This construction extends the compress-uncompress method for the $W$-state combined with additional subroutines. 

We continue with a log-depth state preparation protocol for the Dicke-state for arbitrary $k$. 
This protocol implements an efficient transformation between the factoradic number representation and the combinatorial number representation of a positive integer. 
The combinatorial number representation relates directly to the Dicke state. 
The provided efficient transformation between number representation systems might be of independent interest. 

We conclude by modifying our protocol for preparing a Dicke-state to a protocol that prepares quantum many-body scar states in constant-depth. 
These states have low entanglement and longer coherence times than states with similar energy density.
These characteristics make many-body scar states interesting to analyze and relevant within physics.
Many-body scar states appear for instance in the AKLT model~\cite{AKLT:1987,MRBAR:2018,MRB:2018} and different spin models~\cite{SI:2019,MOBFR:2020}.
Known methods for preparing these states have polynomial-depth~\cite{Gustafson:2023}, whereas our circuit has constant depth. 

% We conclude by studying the power that intermediate classical calculations can add to quantum computations. 
% In this study, we define a new model that relaxes constant-depth quantum circuits to polynomial depth quantum circuits, log-depth classical calculations to unbounded classical computations and a constant number of alternations to a polynomial number of alternations. 
% We call this model $\LAQCC^*$. 
% We study this model by doing a complexity theoretical analysis, where we draw inspiration from the notions of complexity given by \citeauthor{RosenthalYuen:2022}, \citeauthor{MetgerYuen:2023}, and \citeauthor{Aaronson:2004}.
% All three complexity notions are based on the notion of state preparation, instead of more traditional definition of complexity such as the decidability of a computational problem. 
% The first two consider classes based on sequences of quantum states preparable by a polynomial-sized quantum circuit, where the circuits are uniformly generated by a computational class, for instance, the class $\mathsf{PSPACE}$, which results in the complexity class $\mathsf{StatePSPACE}$~\cite{RosenthalYuen:2022,MetgerYuen:2023}.
% The third notion considers a relative complexity, where the complexity is measured between two given states, and is measured by the number of gates, from a given gate-set, required to transform one state in another state~\cite{Aaronson:2004}. 
% For our definition of state preparation complexity, we drop the uniformity constraint from~\cite{RosenthalYuen:2022,MetgerYuen:2023} and define a class as $\mathsf{StateX}$, which refers to states preparable by circuits of type $\mathsf{X}$. 
% As an example, if $\mathsf{X} = \QNC^0$, this results in the class $\mathsf{StateQNC^0}$, which is the set of states preparable from the $\ket{0}^n$ state by poly-size constant-depth circuits. 
% This notion is similar to the relative complexity from~\cite{Aaronson:2004}, where one state is the  $\ket{0}^n$ state and instead of counting the number of gates we consider the set of states preparable by a fixed number of gates. Using this notion of complexity we show that any state preparable by an $\LAQCC^*$ circuit is also preparable by a $\mathsf{PostQPoly}$ circuit, the class of circuits of polynomial depth with an additional post-selection gate. 

\paragraph{Summary of results}
\begin{itemize}
    \item We give a new definition of a computational model that captures the power of the four step process: applying a constant number of layers of one- and two-qubit gates; performing a syndrome measurement; perform a fast classical computation determining corrections; apply corrections. We call this model \emph{Local Alternating Quantum Classical Computations}, or $\LAQCC$ for short. In this model we bound the allowed quantum operations, intermediate classical calculations, and number of rounds separately. In Section~\ref{sec:LAQCC_model} we define this model and give a list of operations based on results from literature contained in this computational model. In some of these operations we explicitly use that we allow for multiple, but at most constant, rounds  of corrections.
    \item  We show show that there exist $\LAQCC$ circuits that can not be weakly simulated in Section~\ref{sec:IQP_in_LAQCC}. We further show that for every $\LAQCC$ circuit there exists a $\QNC^1$ circuit simulating it perfectly, in Section~\ref{sec:LAQCC_in_QNC1}.
    \item We introduce a new type computational complexity for preparing states and show that the extension of $\LAQCC$ where we allow a polynomial number of rounds and unbounded classical computation, is contained in $\mathsf{PostQPoly}$, the class of polynomial circuits with post-selection, in Section~\ref{sec:Complexity results}.
    \item We show a protocol to prepare the uniform superposition state of size $q$ in $\LAQCC$ using $\mathO(\ceil{\log_2(q)}^2)$ qubits in Section~\ref{sec:superposition_modulo_q}. 
    \item We show a protocol to prepare the $W_n$ state in $\LAQCC$ using $\mathO(n\log(n))$ qubits in Section~\ref{sec:W_state_in_LAQCC}.
    \item We show two ways of preparing the Dicke-$(n,k)$ state. The first method is in $\LAQCC$, works up to $k = \mathO(\sqrt{n})$, uses $\mathO(n^2\log(n))$ qubits, and is found in Section~\ref{sec:dicke:small_k}. The second method is in $\LAQCC\text{-}\mathsf{LOG}$ (an extension of $\LAQCC$ allowing for logarithmic number of alterations instead of constant), works for any $k$, uses $\mathO(\text{poly}(n))$ qubits, and is found in Section~\ref{sec:Dicke_in_LAQCC_LOG}. 
    \item We extend on our $\LAQCC$ method of generating Dicke-$(n,k)$ states for $k = \mathO(\sqrt{n})$ and show a protocol to generate many-body scar states for a particular Hamiltonian in $\LAQCC$ (Section~\ref{sec:many_body_scar}). 
\end{itemize}
Summarized in a table, we provide the following state generation protocols:
\begin{table}[htb]
\centering
\begin{tabular}{l|l|l|l}
\textbf{State description} & \textbf{Width} & \textbf{Depth} & \textbf{Implementation}\\
\hline 
Uniform superposition mod $q$: $\frac{1}{\sqrt{q}} \sum_{i = 0}^{q-1}\ket{i}$ & $\mathO(\ceil{\log^2 q})$ & $\mathO(1)$ & Section~\ref{sec:superposition_modulo_q}\\

$W$-state: $\frac{1}{\sqrt{n}}\sum_{i = 0}^{n-1}\ket{e_i}$ & $\mathO(n \log n)$ & $\mathO(1)$ & Section~\ref{sec:W_state_in_LAQCC}\\

Dicke-$(n,k)$, $k = \mathO(\sqrt{n})$: $\binom{n}{k}^{-1/2}\sum_{x \in \{0,1\}^n: |x| = k} \ket{x}$ &  $\mathO(n^2\log n)$ & $\mathO(1)$ 
&Section~\ref{sec:dicke:small_k}\\

Dicke-$(n,k)$: $\binom{n}{k}^{-1/2}\sum_{x \in \{0,1\}^n: |x| = k} \ket{x}$ & $\mathO(\text{poly}(n))$ & $\mathO(\log n)$ &Section~\ref{sec:Dicke_in_LAQCC_LOG}\\

QMBS: $\ket{S_k} = \frac{1}{k! \sqrt{\mathcal N(n,k)}}(Q^\dagger)^k \ket{\Omega}$ &  $\mathO(n^2\log n)$ & $\mathO(1)$  &  Section~\ref{sec:many_body_scar}
\end{tabular}
\caption{Summary of state preparation protocols given in this paper.}
\label{tab:sate_prep}
\end{table}
In the entry for the quantum many-body scar state $Q$ denotes the raising operator and $\mathcal N(n,k)=\binom{n-k-1}{k}$. 
Section~\ref{sec:many_body_scar} will provide more details on the variables and the implementation. 

\paragraph{Organization of the paper}
\noindent We first introduce relevant preliminaries in Section~\ref{sec:preliminaries}. 
In Section~\ref{sec:LAQCC_model} we formally define the class of Local Alternating Quantum-Classical Computations ($\LAQCC$). We also show that any Clifford circuit can be implemented in constant depth $\LAQCC$ (a result based on a result from measurement-based quantum computing~\cite{jozsa2006introduction}). 
This result allows us to give many useful multi-qubit gates and routines in Section~\ref{sec:gates_created_in_LAQCC}. 
Beyond that we show that constant depth $\LAQCC$ circuits are contained in $\QNC^1$ and that any $\mathsf{IQP}$ circuit has an $\LAQCC$ implementation.
We conclude this section with an analysis of a more powerful instantiation of $\LAQCC$ and show an inclusion with respect to the class $\mathsf{PostQPoly}$, which is the class of circuits of polynomial depth with one additional post-selection gate. 
In Section~\ref{sec:state_prep_in_LAQCC} we give $\LAQCC$ circuit implementations for preparing the uniform superposition over an arbitrary number of states, the $W$-state and the Dicke state up to $k = \mathO(\sqrt{n})$. We furthermore give a log-depth circuit implementation for preparing the Dicke state for any $k$. We conclude by showing a $\LAQCC$ circuit for generating many body scar states of a particular type of Hamiltonian.

