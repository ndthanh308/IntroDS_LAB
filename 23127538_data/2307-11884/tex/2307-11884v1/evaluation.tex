\section{Evaluation}
\label{sec:eval}



We evaluate SEIF over four open-source designs to study its viability 
as a means for accounting for information flows within a hardware design. The evaluation
addresses the following questions: 1) Can SEIF recognize and eliminate paths
through the IF graph that are unrealizeable in practice? 
2) Can SEIF find paths through the design, 
along with the sequence of inputs to realize the path, that corresponds to paths through the IF graph?
3) Can SEIF be meaningfully applied to security relevant signals in hardware
designs to give experts 
feedback on the security of the design or new areas to explore?

\subsection{Dataset and Experimental Setup}

We collected four open-source Verilog designs for evaluation. The designs are:
\begin{enumerate}
	\item OR1200, a 5-stage RISC processor core~\cite{or1200};
	\item openMSP430, a synthesizable 16-bit microcontroller core~\cite{msp430};
	\item the AKER Acess Control Wrapper (ACW)  \cite{restuccia2021aker}; and
	\item an AES implementation from TrustHub \cite{TrustHub1} \cite{TrustHub2}.
\end{enumerate}

The experiments are performed on a machine with an Intel Xeon E5-2620 V3 12-core
CPU (2.40GHz, a dual-socket server) and 62G of available RAM. 

%% In the following sections we For each design we provide some performance metrics, statistics to answer the research questions above, and security analysis
%% focused on the specific security critical signals or properties of interest.

\subsection{Accounting for Paths in the IF Graph}
\label{sec:eval-acctingpaths}
We first examine SEIF's ability to account for paths in the IF graph,
either by finding paths through the design that correspond to the IF path, or by
eliminating the IF path as infeasible. In these experiments we look at the OR1200, MPS430, and ACW
designs, which are the largest of the four.

We identified 20 security-critical signals in the OR1200 to use in our experiments that appear in
security properties of the OR1200 collected from the security literature \cite{hicks2015specs} \cite{bilzor2011security} \cite{zhang2017scifinder} \cite{zhang2020transys} \cite{trippel2020ICAS}. We selected 10 sources to analyze in the MSP430 by finding signals roughly analogous to those in the security properties for the OR1200.   
For the ACW, we chose 20 main internal signals to look at that appear in the security properties manually and automatically generated by \cite{restuccia2022framework} \cite{Deutschbein2022JCEN} and map to several known CWEs. 

For each source signal there can be tens of thousands of IF paths. (See the numbers in Tables~\ref{lst:security-analysis-msp430}
and~\ref{lst:security-analysis}, discussed in Section~\ref{sec:security-analysis}.) For the efficacy
and performance evaluations in this and the next two sections, we analyze a subset
of the total paths. For each source signal of interest, we randomly selected 300
paths from the IF graph for analysis. For the security analysis case study
(Section~\ref{sec:security-analysis}), we analyze all paths from a given source.



%\subsection{Accounting for Information Flows}

%% For the OR1200 and ACW, we first identify security critical sources, and then we choose 300 random paths to perform the information flow analysis. The numbers in the table
%% represent the average taken over all sources. 
Figure~\ref{fig:accounting} summarizes SEIF's ability to account for the IF
paths.
For 86\% to 90\% IF paths on average, SEIF either finds the corresponding path through the
design or eliminates the IF path as infeasible or not representing a true flow
of information. The majority of accounted-for IF paths, 58\% to 77\% on 
average in the three designs, are true paths in the design, indicating that the
static analysis done to build the IF graph is a decent approximation of
information flow through the design. We further break down these
numbers to show the percentage of the found IF paths for which SEIF returns a
design path that starts at the reset state vs. a design path that starts at some
intermediate state. Paths that start at the reset state are better for the
engineer as they can be immediately replayed from the known reset state.

% Figure environment removed

\subsection{Evaluation of Search Strategies}
In the following we evaluate the four search strategies discussed in
Section~\ref{sec:strategies}. Figure~\ref{fig:findflows-percent} reports, for
each design, the percentage of IF paths found by each of the four search
strategies. These are paths for which SEIF found a corresponding path through
the design. As expected, the heuristic
guided search outperforms the other strategies in all three designs, improving
over the baselines by 26\% on average and over bounded stalling with
backtracking by 11\% on average. We note that baseline 2, which does
not include stalling, is the least successful at finding corresponding paths in
the design. This highlights the value of SEIF: many IF paths give an incomplete
picture of a path through the design and include points where the design must advance to
a new state before the IF path can continue. Without SEIF, it would be up to the engineers to
figure out how and whether to advance the design state.
% Figure environment removed

Figures~\ref{fig:findflows-time} and \ref{fig:findflows-cc} report on the
performance of the four search strategies, both in terms of average time taken to
find a corresponding design path and average number of clock
cycles through the design for the found path. Again, the
heuristic guided search outperforms the other strategies, completing the search
for each IF path in 3-6 seconds.
% Figure environment removed

% Figure environment removed

Figure~\ref{fig:backtracking-freq} shows that the amount of backtracking that is
required is lowered when we incorporate bounded stalling. Adding the heuristic
improves the efficacy of stalling and therefore decreases backtracking even further.

% Figure environment removed

%% how well SEIF performs with the four  heuristic-guided search strategy 
%% Figures \ref{fig:findflows-percent}, \ref{fig:findflows-time},
%% \ref{fig:findflows-cc}, \ref{fig:backtracking-freq} and  \ref{fig:accounting}
%% summarize our the methodology's ability to find information flows. For 300
%% randomly selected paths for each of the security critical sources, we
%% attempted to verify the information flow path. We report the average \% of
%% flows found, clock cycles necessary to find the flow and time taken. This was
%% repeated for each of the 4 search strategies/heuristics.

To better understand how SEIF is finding flows over time, we explore all
IF paths from a single source signal, the program counter, in
the MSP430. We track how many IF paths are found in the design after 1 clock
cycle of search, 2 clock cycles of search, etc. The experiment was done with
heuristic-guided stalling turned on. Figure~\ref{fig:flows-overtime}
shows the results. There were a total of 19060 IF paths, and SEIF
found design paths for 89.93\% of them. The complete search took 16 clock
cycles, however, most of the paths were found withing the first 8 clock
cycles. The experiment took 3.5 days to run.



% Figure environment removed
  
  \subsubsection{Determining the Stall Bound} 
For all the experiments in the previous sections, the number of stalls per IF
path segment was set to be 
5, 5, and 4 for baseline 1, bounded stalling with backtracking and the UNSAT core heuristic, respectively. 
(As a reminder, baseline 2 is backtracking only, with no stalling).
We determined these numbers empirically by selecting at random 5 of the
security-critical source signals from the OR1200, and for each of these source
signals selecting at random 300 paths to evaluate, and then running the experiments with an
increasing number of stalls allowed until we saw the number of IF paths found
begin to flatten out. Finding the bound for the heuristic-guided stalling
strategy is shown in Figure \ref{fig:stalling-unsat-graph}. The graphs
for the other three search strategies are in the appendix. 

%% Figure environment removed

%% Figure environment removed


% Figure environment removed

  
\subsection{Eliminating Information Flows Paths}
We examine how IF paths that do not correspond to information-flow paths
through the design are falsified in Figure~\ref{fig:falsified}. The experiment used the 300
randomly chosen paths for the 20 security-critical signals in the OR1200. The
largest percentage of eliminated paths are found statically before symbolic
execution begins. This is good news, as that is the cheapest and quickest phase
of the analysis. There is a non-trivial portion, 5\% to 7\%, that are eliminated because they do not represent
true flows of information through the design. SEIF's use of symbolic execution
allows for this precise analysis, which taint tracking may not be able to
provide.


% Figure environment removed

  

%% \cks{Maybe this is totally redundant information with
%%   Figure~\ref{fig:accounting}. Cut?}
%% In Figure \ref{fig:replay}, we report the average number of information flows we still find to be viable after our pruning passes
%% and how many we find to be repayable from the reset state in the OR1200. 

%% % Figure environment removed

  
\subsection{Case Study: Security Property Verification}
\label{sec:security-analysis}
When starting with a property, such as is often done in security verification
tasks, SEIF goes beyond producing a single counterexample. In traditional,
assertion-based formal methods, once the formal or bit-level engine produces the first counterexample, it takes manual manipulation of the property 
or environment to generate subsequent violating traces.
SEIF is able find multiple realizable traces through the design that exhibit the vulnerable behavior and 
can guide the security engineer to other areas of the design they may be interested in exploring. 

We demonstrate the approach for two security-critical properties from the TrustHub
Security Property/Rule Database~\cite{TrustHub1, TrustHub2}, one for the MSP430
and one for an AES implementation. The MSP430 property asserts that the program counterâ€™s value should not be readable
 from the debug access port during normal operation. %% This is a case where information, or a security asset, should 
 %% not be transmitted across certain module boundaries under certain conditions.
The AES property verifies that the secret key material is not accessible to any
 unprivileged internal data registers \cite{zhang2021sidechannel}. 

SEIF generates all the paths from the source of interest to the security-critical sink automatically. 
 In order to produce the violating paths,
 SEIF adds a constraint to the solver specifying the desired precondition. 
 If we find a candidate violation
of the security property, we ensure it is replayable from the reset state of the
design. The results for the MSP430 and AES are presented in
Tables~\ref{lst:security-analysis-msp430} and \ref{lst:security-analysis}, respectively.

%Our methodology would allow a security engineer to quickly enumerate the ports in the frontend module where the program counter originated, and the debug module, and find information flow paths between any of the source/sink pairs, beyond the original two that we identified in the property. 


%We can symbolically execute any one of these paths, and if we successfully find the flow, then we can send the path condition to the solver and it will generate the constraints we need to realize that path concretely. However, this set of paths is a superset of the paths that actually violate the property, during this exploration phase we were not taking into account this precondition -- ``during normal operation.'' The solution is to add an additional constraint to our solver before finding that concrete input trace specifying the desired precondition. 

 \begin{table}[htb]
  \small
  \centering
  \begin{tabular}{rr}
  \toprule
  Metric & Result \\ 
  \midrule
      Total IF paths from source:      & 19060       \\
      Total sinks reachable from source:  & 41   \\
      Total IF paths violating security property: & 58 \\
      Avg. time to produce a counterexample (s): & 0.678 \\ 
      Avg. no of clock cycles explored:  & 8.13 \\
      Total realizable paths violating security property: & 46 \\
      \bottomrule
        \end{tabular}
  \caption{Security Property Verification: Program Counter in MSP430}
  \label{lst:security-analysis-msp430}
  \end{table}

  \begin{table}[htb]
  \small
  \centering
  \begin{tabular}{rr}
  \toprule
  Metric & Result \\ 
  \midrule
      Total IF paths from source:      & 61639       \\
      Total sinks reachable from source:  & 39   \\
      Total IF paths from source violating security property: & 57 \\
      Avg. time to produce a counterexample (s): & 0.505 \\ 
      Avg. no of clock cycles explored:  & 4.102 \\
      Total realizable paths violating security property: & 25 \\
      \bottomrule
        \end{tabular}
  \caption{Security Property Verification: Secret Key in AES Implementation}
  \label{lst:security-analysis}
  \end{table}

%% \subsection{Comparison to Current State of the Art}
%% Currently, the state of the art in any hardware security verification task is property-based.
%% This approach limits any methodology's usage to experts that a) know the design well enough to write 
%% high-quality security properties or b) limits the reach of the verification activity to whatever is specified
%% by the particular property. Our methodology represents a new area in the design space and addresses these two concerns. 

%% %In addition to being property-based, the state of the art in information flow analysis is done by commercial tools, where the
%% %the methodology is quite manual. For example, with these property-based tools, like Cadence JasperGold SPV, once you find a path or information flow,
%% %it is not immediately apparent how to tell if there exist more paths, or how many more. Our methodology can quickly find the next counterexample involving a source/sink pair
%% %by testing the next candidate paths, whereas JasperGold would require the engineer to manually edit a property or change bits in conditions.

%% In Section \ref{sec:security-analysis} we discuss how our methodology can be used to find security relevant flows that were also found by JasperGold SPV. However, the waveforms produced by JasperGold only produce single counterexamples, not a set of candidate paths. In terms of a performance evaluation, we have access to JasperGold SPV, but their software license unfortunately prevents head-to-head comparisons in published research.

%% EISec extracts a model from symbolic execution in order to exhaustively check security properties of hardware designs \cite{fowze2022eisec}. This is a property-based approach that enumerates vulnerable states in a model of the hardware design in order to find violations. While they analyze several lightweight cryptographic modules and a RISC controller, no data is available on the size of these modules or how long the tool takes to run. 

%% Knox is framework for verifying the security of hardware designs \cite{athalye2022knox}. They are concerned with the verification of software running on hardware, and they use the Notary \cite{athalye2019notary} toolchain to convert C and Verilog to models compatible with the Rosette symbolic execution engine \cite{torlak2014rosette}.  The authors report runtimes of 217 minutes, 78 minutes and 52 minutes to verify designs that contain 2860, 3260 and 331 lines of code, respectively. This does not include the time needed by the user / designer to manually write the proof artifacts or construct the specifications. 

%% Work by Cherupalli et al. uses symbolic simulation to verify information flows in binaries running on hardware \cite{cherupalli2017software}. They run a set of 
%% symbolic gate-level information flow tracking benchmarks with the MSP430. \kar{I don't understand what's happening in this paper / how to make sense of the results}

%The introduction puts this work
%against~\cite{athalye2022knox,fowze2022eisec,cherupalli2017software,athalye2019notary}. The
%evaluation should mention those papers. \kar{done}


 % \begin{table*}[htb]
 % \small
 % \centering
  %\begin{tabular}{p{1.2in}rrrr}
  %  \toprule
  %  Configuration &  \multicolumn{1}{c}{Total paths before pruning} & \multicolumn{1}{c}{Total paths after} & \multicolumn{1}{c}{Replayable paths} \\
   % \midrule
  %Baseline 1 & 300 & 197.94 & 177.12 \\
  %Baseline 2 &  300 & 178.30  &  152.34 \\
  %Stalling w/ Backtracking & 300 &  217.02 & 212.12 \\
  %Stalling with Heuristic & 300 & 239.33 & 231.21 \\
  %  \bottomrule
  %\end{tabular}
  %\caption{Replayability of Paths in the OR1200}
  %\label{lst:replay}
  %\end{table*}
  

%\subsection{Open Titan}
%\cks{If Andy et al. used their static IF analysis to find the
  %error in RndCnstKey in OpenTitan, perhaps we could show how much easier that
 %analysis would be with all the FP flows eliminated.}

%In Andy's DAC submission, they look at the OTP controller. Finding paths from
%OTP to AES core. All paths found are realizable. Tainting memory of OTP memory
%and all keys in the crypto modules. The hyperflow graph has 11,579 vertices
%(wires, registers, variables) and 32,084 edges (potential IF flows). 27,218
%explicit and 4,866 implicit. Simulating the entire OpenTitan. Using OTP
%controller ``smoke test''. There were two outputs that appear to be connected to
%RNDCNSTKEY in the hyperflowgraph, but for which the testbench did not show the
%path. This is another use of SE. Even though no false positives in this
%hyperflow graph (or at least none of the paths of interest that they looked at
%had FPs) there are some paths that couldn't be found through standard
%testbenching and had to be manually analyzed. SE could find them.

%Andy found 2 half-paths that each made 26 hops out of a total of 78 edges. Can
%we find the rest of the path?\\
%source port: rnd\_cnst\_key\\
%destination ports: /ot\_top/u\_otp\_ctrl/intr\_otp\_error\_o\\
%/ot\_top/u\_otp\_ctrl/intr\_otp\_operation\_done\_o

%As demonstrated in the sections above, we can take a complex
%design, look at all possible paths and rule out some paths and find a good
%proportion of realizable ones. Demonstrate useful to security with use cases:
%esigns and properties. Technique allows us to do a security task -- IF analysis
%--at a scale that other tools have not been able to achieve before. IF analysis is done by
%commercial tools but is very manual.



%Look at signals of architectural significance to make it easier to interpret the
%results. E.g., key register to output port, want to know confidentiality is not broken.

%\subsection{Evaluation Questions (Notes from Meeting with Intel)}
%Talk about the paths found to be unrealizable
%\begin{itemize}
%\item What did they look like?
%\item What was the condition that turned out to be unrealized?
%\item What was the structure of the path/code that leads to IF path, but is
%  not an actual path through the design? At the syntactic level.
%\item At a high level -- what are the structural design aspects that led to
%  falsified paths? Do there exist design patterns that lead to falsified paths?
%\end{itemize}


%How many SMT queries are we talking about?
%\begin{itemize}
%item if 5k paths are eliminated, did it take 5k queries?
%\item does one early UNSAT result enable eliminating lots of down-path
%  branches
%\item there may be room to improve here -- if one path is falsified, then others
%  with the same prefix are also falsified.
%\end{itemize}


%\subsection{Evaluation Cases (Notes from 4/5 meeting)}
%\begin{itemize}
%\item Baseline1: continue, stall in truth-table ordering with no backtracking
%\item Baseline2: never stall, always backtrack (this can exhaustively complete)
%\item Bounded stalling with backtracking: still using truth table ordering. when stuck, stall up to 5 clock cycles and then backtrack
%\item Stalling w/heuristic: when stuck, stall up to 5 clock cycles with happy faces%
%and then backtrack. At the first sad face, backtrack. This is bounded stalling but
%with an early exit to backtracking, according to the heuristic.
%\end{itemize}

%Search is DFS

%Evaluation to do
%\begin{itemize}
% \item  randomly choose 300 paths to work with when figuring out a good bound
%\item increasing bound in baseline1 case to find a good bound. keep increasing bound
%until the percentage of flows accounted for no longer improves
%\item implement Baseline2
%\item find a good bound to use with bounded stalling with backtracking.
%\item find a good bound to use with heuristic-guided stalling with backtracking.
%\end{itemize}


%For paths we find:
% show it is realizable on FPGA
%For paths we don't find:
% what does cadence say?
%For unrealizable paths:
% Can we confirm results with Cadence?
