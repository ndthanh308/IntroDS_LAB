\section{Implementation}

We implemented SEIF using the Sylvia symbolic execution
engine~\cite{ryan2023countering} and using hyperflow
graphs~\cite{meza2023hyperflowgraph} as our IF graph engine.\footnote{We
contacted the authors of the hyperflow graph paper and they gave us closed-box
access to the tool, providing the static analysis for the designs we gave
them. The
authors of the Sylvia symbolic execution engine gave us source-code access to
their tool.} Both Sylvia and
the hyperflow graph toolchain were built using python3. Sylvia
implements the Verilog semantics according to the 
IEEE 1364-2005 semantics using pyVerilog and the Z3 solver for SMT solving. SEIF
also uses Z3 for preprocessing and path removal.

When considering information flow paths that span multiple modules, enumerating all possible 
paths for even a single source/sink pair becomes too
expensive. We manage this complexity by following the divide-and-conquer
approach of Ryan et al.~\cite{ryan2023countering}.
SEIF first finds the partial IF paths within a module, and then uses the segment
conditions to find the next module to explore. SEIF uses the SMT solver to ensure that the path fragments can be stitched back together to form a valid information flow path from source to sink. 
This approach reduces repeated work within
a module when exploring paths across multiple modules.


