\section{Introduction}
%% This paper presents \textit{SEIF} (pronounced ``safe''), a toolflow that combines static analysis with symbolic execution
%%  for verifying information flow paths in hardware designs. SEIF begins with a static model of the information flows
%%  through a design and is able to produce realizable and semantically accurate information flow paths. This is made
%%  possible by an augmented symbolic execution engine with heuristics that steer the search towards paths
%%  necessary to complete the flow. The search space would otherwise be intractable.
%%  SEIF is able to produce counterexamples when given a security property, in addition 
%%  to providing all of the replayable information flow paths that exhibit the vulnerable behavior.
 
%% Analyzing information flow is important for security
Analyzing how information flows through a hardware design is critical
to verifying the security of the design~\cite{tiwari2009complete,tiwari2009execution,jin2012proof,li2011caisson,li2014sapper,zhang2015secverilog, bidmeshki2015vericoq, hu2016detecting,kong2017using,ardeshiricham2017register,ardeshiricham2017clepsydra,deng2017secchisel,bidmeshki2017information,boraten2018securing,pilato2018tainthls,zagieboylo2019using,pieper2020dynamic}.
Unwanted flows of information to
or from a signal in the design can violate desired security policies in the form of
 access authorization
violations~\cite{restuccia2021aker,restuccia2022framework}, memory leakage
vulnerabilities~\cite{cherupalli2017software,fadiheh2023exhaustive}, %% \cks{smthg for Isadora
  %% paper~\cite{Deutschbein2021Isadora,Deutschbein2022JCEN}, Chapter in
  %% txtbk~\cite{sturton2022handbook}, Kastner's survey paper on IF Verification~\cite{??}},
and possible privilege escalation vulnerabilities~\cite{wu2022exert}.
Recent work has shown that symbolic execution
is a powerful tool for analyzing how information flows through a hardware
design~\cite{athalye2022knox,fowze2022eisec,cherupalli2017software}. Symbolic analysis is
precise and enables
tracking both direct and indirect flows of information through each path of
execution without instrumenting the design with added tracking logic. 



%% Current practice for detecting and
%% understanding these flows uses simulation-based testing~\cite{smth}, static
%% analysis~\cite{smth}, or most recently, symbolic execution~\cite{smth}.

%% Still not a solved problem
Unfortunately, symbolic execution infamously suffers from the path explosion
problem. The number of paths through a design grows exponentially with the
number of branch points in the design. Hardware designs have the added
complexity of reasoning about paths over multiple clock cycles in order to
realize complete flows of information from an input port (source) signal to an output
port (sink) signal. Current solutions to the path explosion problem have been to consider
small, but security critical designs~\cite{athalye2022knox,fowze2022eisec}, or to constrain the hardware design
space by analyzing how information flows for a particular software program~\cite{cherupalli2017software,athalye2019notary}.

%% Static analysis plus symbolic execution is the answer!
We take a different approach. We start with static analysis, using an existing
tool~\cite{meza2023hyperflowgraph} to
build a graph that over-approximates how information flows
through a design. Such a graph is useful for designers, allowing them to explore
their design and find possible illegal or insecure flows.  %% We show that
%% by using the information in this graph to guide the symbolic execution engine, we
%% can fully explore how information flows from an input port signal of interest through
%% a design for a sufficient number of clock cycles for the flow to reach all possible
%% output ports. The approach can scale to full CPU designs. (In our experiments this is typically \cks{XX-XX} clock cycles for
%% an open-source CPU~\ref{evaluation}.)
For our purposes, the graph provides useful information that can be used to guide
symbolic execution: a sequence of landmark points in
the hardware design that execution must reach in order to
realize a given path of information flow. Using these landmarks as a guide, we use symbolic
execution to improve the graph's efficacy: finding a realizable path through the
design state, along with the inputs needed to take that path, corresponding to a
path in the graph; recognizing and eliminating from the graph paths which are
unrealizable in execution; and recognizing and eliminating from the graph paths
which are realizable, but do not represent a true flow of information.


%% some paths as unrealizable, and for the paths remaining, develop
%% heuristics that steer
%% symbolic execution toward paths more likely to result in the desired information flow.

%% But the graph does not tell us which paths
%% of execution to take in order to get to each subsequent in landmark when we are looking
%% at a path made up of a sequence of many information flows. It also doesn't tell us 
%% how long (how many clock cycles of execution) it will take to get there, or whether it is even
%% possible to get to the next landmark at all from current one. To answer these
%% questions we use develop and implement search heuristics based on SMT solving into a symbolic execution
%% engine. \cks{This is a
%%   reachability problem. Piecewise reachability? Stepwise reachability?}
%%  %stalling, unsat core?, backtracking.

This paper presents \textit{SEIF} (pronounced ``safe''), a toolflow that
combines symbolic execution with static analysis in the form of the information
flow graph. SEIF takes as input the statically built
information flow (IF) graph and the source signals of interest in the design.
Three
outcomes are possible: 1. SEIF finds that the path is unrealizable or does not
represent a true flow of information, and requires no
further scrutiny from the security engineer, 2. SEIF returns a sequence of input
values that will drive the design along the IF-graph path to realize the flow of
information, or 3. the complexity of the search space
leaves the IF-graph path unaccounted for.

To find that a path is unrealizable or does not represent a true flow of
information, SEIF uses two mechanisms: a check for mutually contradictory constraints and symbolic
analysis. If the first mechanism reports that a path is unrealizable then it is, regardless of the
number of clock cycles the design is allowed to run. If the second mechanism
reports that a path is unrealizable, then it is within the clock cycle bound used
by SEIF. In our experiments, this was the case for 5-7\% of the paths. 

To find and return a sequence of input values that will drive execution along an
IF-graph path, SEIF uses symbolic execution guided by the IF graph and
heuristics we develop. The returned
sequence of input values will drive execution along the IF-graph path, either
starting from the design's reset state or from an intermediate state. In our
evaluation (Section~\ref{sec:eval}) we differentiate these two cases.

%%  However, as is always the
%% theoretical limit, this analysis cannot be both sound and complete. The analysis
%% is bounded in the number of clock cycles explored and may report that a path was
%% not found within the given bound. 

%% % start talking about how our methodology is exploratory / not property -based
%% Current practice in hardware security verification is property
%% driven~\cite{hu2016towards}, which requires a security engineer to develop a set
%% of properties for use with the verification engine. This often involves manual
%% review of the design and of CWEs, and can yield many properties for a relatively small design~\cite{restuccia2022framework}.
%% A new trend in hardware security is to build a map of the design that supports the designer in their understanding
%% of security-critical information flows~\cite{Deutschbein2021Isadora,Deutschbein2022JCEN}.
%% Our methodology is in keeping with this new trend and allows users
%% to perform more exploratory analyses.


%% \cks{I'm commenting out for now, but it could go in the eval section potentially}
%% \kar{rough}
%% When verifying a specific security property, a commercial tool like JasperGold SPV will provide a single counterexample.
%% It takes a large amount of manual effort to generate subsequent counterexamples using a bit-level formal tool like JasperGold SPV
%% because it involves asserting additional preconditions and constraints over your property.
%% Our approach can provide the user with all of the candidate violating flow paths automatically.
%% Once we find a security-critical flow, we can continue exploring further by identifying the sinks reachable from that source.
%% This could potentially uncover things not specified in the original property (if there was one)



%\cks{From conversation with Kaki:} Symbolic execution is inherently a tool for
%security validation (of hardware designs) -- cite a bunch of examples -- and we
%can do it at scale (for this one particular problem of finding information flow
%paths. this is a type of reachability analysis?) -- evaluation must show that we
%can scale in ways that prior work could not and for security problems that are
%of interest to the community (e.g., b/c they show up in prior security testing,
%model checking, SE work) Can we tackle larger designs than prior SE work could?
%Can we find paths that other approaches (e.g., testing-based, tortuga, cadence)
%could not?

%and use symbolic
%execution to eliminate false positives, provide concrete testbenches for the
%paths that remain, and provide metrics of the elasticity/malleability of the
%remaining paths, which can be helpful when determining how dangerous a path may
%be in practice and prioritizing patches. We introduce new techniques based on SMT
%solving to recognize and eliminate
%impossible paths of flow early, and we develop heuristics to guide the search
%toward paths more likely to exhibit the searched-for flows. With these
%techniques, and using the results from static analysis as a guide, the
%approach can scale to full SoCs/NoCs.

%% The gist of our approach
%% Use static analysis to build a possible path of information flow. Divide each
%% path into clock cycle boundaries. Use symbolic execution to explore the design
%% to find a 1-clock-cycle path matching the path fragment. Unsat core evaluation
%% guides the search and eliminates impossible paths quickly.

%% The contribution
In this paper, we develop SEIF, an algorithm and tool to search for and eliminate
false paths of information flow from a static analysis of a hardware
design and then to further explicate the paths that remain. We show that by
using the static analysis as a guide, we can guide symbolic execution toward more probable paths and eliminate impossible paths
early. Our contributions are:
\begin{itemize}
\item Define \emph{SEIF}, an augmented symbolic execution methodology for information flow
  analysis. %% Develop the use of symbolic execution with unsat core
  %% evaluation to efficiently remove false positive paths from a static information
  %% flow analysis and enable more dynamic security analysis
\item Implement the methodology and search heuristics on top of the symbolic execution engine discussed in \cite{ryan2023countering}.
\item Evaluate the augmented symbolic execution strategy on four open-source designs.
\end{itemize}

%\cks{Some possible additional ways to frame work}
%1. Tools like Cadence SPV work one path at a time. We can help understand how many
%paths exist. We also can provide timing/clock-cycle information that could be
%useful for patches/mitigations to make sure the patch isn't introducing race
%conditions. It may also be helpful in developing patches to be able to say this
%is the minimum number of clock cycles an IF-path can take and this
%is the earliest clock cycle in which a segment of the IF path can occur.
%2. As a metric to help understand how dangerous an undesirable path is. If there
%exist many paths through the design that realize the same IF-path, this is a
%more dangerous IF-path b/c the attacker is less constrained in coming up with
%the relevant inputs.
%3. If the design can stall (stutter w/r.t. the IF-path) this is more dangerous
%b/c it is easier to provide attack inputs that realize the IF-path. The attacker
%can still launch a successful attack even if they cannot control the input on
%every clock cycle. This is slightly different than the analysis we do in our
%search strategy when determining if the search *must* stall. Essentially, These
%metrics are a measure of the ``window of attack'' available to the attacker. It
%could be good to evaluate these on the OpenTitan design b/c Andy found that all
%IF-paths found in the OTP-to-AES core they analyzed were realizable. I.e., we
%won't find any false positives.


%\kar{My notes with ideas about framing/eval}
%1.If we have more paths realizing the same iflow path, this could potentially indicate the flow 
%is more dangerous. Right now Sylvia stops when it finds the first path realizing a flow,
%but in the eval this is one number we might want to show -- how many Sylvia paths realize the same iflow path.
% 2. Timing. Design can run for many cycles without impacting flow (information staying in registers)
% This information can be exploited later.. this is potentially more dangerous, too. Look at this in eval.
% Idea of "window of attack" / ease of attack mitigation (I dont think I remember what the second is)
% 3. potentially producing heatmap/visualization of realizable paths.. we can produce observations that
% many flows may be going into one sink/signal --> do we trust this thing? are we ok with this? would give 
% us groups of signals for further analysis/to look into
% 4. our tool gives multiple paths (potentially) which is helpful for the designer whereas a tool like SPV just gives one,
% can find others using SMT, but this is tedious and takes longer
% We can describe our tool as providing security-related metrics.
 
% Andy leaves the FP in the graph, but used test benches and manually weed them out/identify later --> this is is another angle where we come in,
% getting rid of this manual process.


%% \url{https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9155136}~\cite{micinski2020abstracting}. Static analysis of SW using abstract interpretation for information flow analysis. 
%% static analysis of information flow in SW, used to make dynamic information flow
%% analysis more efficient by removing unnecessary runtime checks. Too
%% tangential to this work. 

%%  \cks{from NSF proposal:}
%% Determining how information flows through the design is fundamental to understanding the hardware's security~\cite{tiwari2009complete, tiwari2009execution, jin2012proof, ferraiuolo2017verification, li2011caisson, li2014sapper, zhang2015secverilog, bidmeshki2015vericoq, hu2016detecting, kong2017using,  ardeshiricham2017register, ardeshiricham2017clepsydra, deng2017secchisel, bidmeshki2017information, boraten2018securing, pilato2018tainthls, zagieboylo2019using, pieper2020dynamic}.
