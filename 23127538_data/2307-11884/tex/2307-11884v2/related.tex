\section{Related Work}


%knox
%defines a new variant of refinement: information preserving refinement although
%difference btwn this and refinement is unclear. 
%Ruling out side
%channels is different than fully understanding how information
%%ows. User must write the specification (correctly -- this defines
%correctness), refinement relation, physical implementation (of course -- .v
%file), driver, hints to the symbolic execution, emulator, and proof
%script. Functional specification and driver are trusted. Implementation is the
%thing to verify. Hints, Relation, Emulator, and Proof Script are the proof
%artifacts and verified by the framework, but are difficult to get right, i.e., a
%failed verification doesn't help the developer fix these proof artifacts to get
%ti right.  Our tool
%could help. A different use-case (smaller, well specified designs like HSMs) and
%therefore different requirements and goals. Still, we expect our tool could help
%designers make use of a tool like Knox, providing information that informs the
%formal specification, refinement relation, and proof script that a designer must
%write to use Knox.
%Use of guided symbolic execution: Uses symbolic execution in a model-checking
%sort of way, but this part is unclear. Uses Rosette and Racket. Human provides
%hints to when states can be concretized, path condition can be weakened, terms
%can be rewritten, terms can be replaced with a fresh variable
%(over-approximate), etc. to manage the search space explosion.


%upec
%Unique Program Execution Checking (UPEC) is a formal method to detect
%vulnerabilities to covert channels in a hardware design, and can find transient
%execution
%attacks~\cite{fadiheh2023exhaustive}. However, much
%of the approach is manual, involving writing a list of constraints. Our tool can
%complement this approach by using analysis of the hyperflow graph to generate
%constraints. UPEC also has broader applications in in detecting functional
%design bugs which cause confidentiality violations~\cite{muller2021formal}.
%From the UPEC thesis~\cite{mohammad2022unique}:
%UPEC is primarily about how to formulate properties? The properties are then
%checked using Interval Property Checking. Interval Properties -- a class of
%properties that can be stated as an implication in which the antecedent and
%consequent are described over a finite time interval. These are proven using
%proof by induction (why aren't these just called inductive
%properties?? nm, slightly different. not a base case and inductive step, rather
%an implication that is proven to hold over an overapprox of the design). Starting from a fully symbolic state, and checking that the
%property holds for given time interval, proves the property for the whole
%design. One weakness, is that many true properties may not be provable by this
%%overapproximation method. A CEX, may not be a true counterexample of the design
%starting from a reset state. How to tell the difference?


%\cks{From John's talk: https://software.imdea.org/~ab/Publications/tlad.pdf}

%\cite{Kozyri2022expressing} Monograph (SoK) on Information Flow properties. We can
%refer to this for the textbook definition of our properties. Look at for
%references for information flow definitions, hyperproperties.


\paragraph{\textbf{Symbolic Execution of HW Designs for Information Flow Analysis}}
EISec uses netlist-level
symbolic execution to verify information-flow safety and
quantify confusion and diffusion in cryptographic
modules~\cite{fowze2022eisec}. Our work improves upon EISec by
allowing analysis at the RT-level and enabling verification of a wider class of
information-flow properties. Other tools
use symbolic simulation
(e.g.,~\cite{torlak2014rosette}) %, either in combination with manual
%refinement proofs~\cite{athalye2022knox} or information flow
%tracking~\cite{cherupalli2017software}
to verify particular binaries running on the
hardware~\cite{athalye2022knox,cherupalli2017software}.



%% Work by Cherupalli et al.
%% uses gate-level symbolic simulation in conjunction with software-based information flow tracking flow system to eliminate vulnerabilities in hardware \cite{cherupalli2017software}

%\cite{cherupalli2017software}
%Gate-level symbolic simulation (not SW-style symbolic execution) for finding information flow vulnerabilities in HW/SW -- an IoT processor running the
%particular IoT application. Has comprehensive list
%of references for how information flow analysis (mostly taint tracking, but not
%all) is used to assess security and privacy of systems (mostly
%software). ``symbolic gate-level simulation of the application binary on the
%netlist''. Key information flow policy assessed is memory leakage (tainted to
%untainted output). Evaluation on openMSP430. 

\paragraph{\textbf{Symbolic Execution of SW for Information Flow Analysis}}
%\cks{I think all three use self-composition for SE of IF?}
The software community was perhaps the first to leverage symbolic execution to
verify information flow. The approach has been used in combination with taint
tracking~\cite{cha2012mayhem}, to find and mitigate side
channels~\cite{bao2021symbolic,wang2017cached,wang2019identifying,brotzman2019casym},
and to identify programs that are
vulnerable to transient execution attacks~\cite{guarnier2020spectector}.

%% These techniques have also used in the Mayhem engine, which
%% uses taint tracking to guide execution towards vulnerabilities in binaries~\cite{cha2012mayhem}, as well as in CacheD to discover cache-based timing side channels in production software~\cite{wang2017cached,wang2019identifying}. Spectector~\cite{guarnier2020spectector} uses the symbolic execution to analyze 
%% the flow of information in software. Their goal is to find programs that leak information under 
%% a speculative execution model. Our work carries similar ideas into the hardware domain.
%% CaSym is a cache-aware software symbolic execution engine for side channel detection and mitigation \cite{brotzman2019casym}.

\paragraph{\textbf{Symbolic Execution of SW or HW to Find Exploitable Flaws}}
There is a long history of using symbolic execution in software to find
exploitable security flaws
(e.g,~\cite{avgerinos2011automatic,avgerinos2014automatic,renzelmann2012symdrive}). 
In hardware, symbolic execution has been used to find violations of and exploits
for security-critical assertions~\cite{zhang2018end} and to find and trigger
trojans in the Verilog RTL~\cite{Shen2018SymbolicEB}. As
with SEIF, the main challenge is guiding search through the tree to find the
salient paths.

%% Work on Automatic Exploit Generation~\cite{avgerinos2011automatic,avgerinos2014automatic} has explored preconditioned symbolic execution, which restricts exploration to only likely-exploitable regions of the state space.
%% Our technique shares ideas/philosophy with preconditioned symbolic execution. In
%% PSE, the input space is limited to prune the search tree. In contrast, we add constraints that allow continued information flow, which guides the search through the tree.

%% SymDrive~\cite{renzelmann2012symdrive} is a tool which uses symbolic execution to find bugs in software drivers and allows developers to guide symbolic execution down particular paths.  Coppelia~\cite{zhang2018end} describes a technique for performing backwards symbolic execution to find security violations and generate exploits for hardware. There has also been work using symbolic execution to generate test cases to trigger trojans in Verilog RTL \cite{Shen2018SymbolicEB}.


\paragraph{\textbf{Information Flow Tracking in HW}}
The state of the art for information flow analysis in hardware is information flow
tracking (IFT), which
instruments a design with tracking logic~\cite{tiwari2009complete}. Many tools
operate at the netlist level, although some operate at
the RTL level~\cite{ardeshiricham2017register}. IFT has also been used in analog
designs~\cite{bidmeshki2017information}, and tools exist to synthesize
designs that incorporate 
tracking logic~\cite{pilato2018tainthls,pieper2020dynamic}.
IFT can be used to check
hyperproperties and has been used to verify the safety and security of many different systems~\cite{clarkson2010hyperproperties,Kozyri2022expressing}\cite{tiwari2009execution,boraten2018securing}\cite{meza2022safety}\cite{restuccia2022framework,restuccia2021aker}\cite{ardeshiricham2017clepsydra}
\cite{hu2016detecting}\cite{jin2012proof}. IFT has also been
used to automatically generate information flow properties for use with formal
verification engines~\cite{Deutschbein2021Isadora,Deutschbein2022JCEN}. We used
these properties in our evaluation. 

%and has been used to
%enforce non-interference~\cite{tiwari2009execution,boraten2018securing},
%verify safety of communication protocols~\cite{meza2022safety}, reason about
%access control violations~\cite{restuccia2022framework,restuccia2021aker},
%detect timing flows in hardware~\cite{ardeshiricham2017clepsydra}, find hardware
%trojans~\cite{hu2016detecting}, and to
%ensure data secrecy and hardware trust~\cite{jin2012proof}.


%% \cks{Kaki, any chance we use
%%   any of these properties in our analysis? If so, I'd change the last sentence
%% to say that.}
\paragraph{\textbf{Formal Analysis for Information Flow}}
Proof-checking approaches have been used for detecting
security vulnerabilities in hardware designs \cite{fadiheh2023exhaustive} \cite{kong2017using}.
These approaches are often less automated, more time
intensive, and tackle smaller designs, for stronger results that are both sound and complete.
 VeriCoq translated Verilog to Coq for proof-carrying designs \cite{bidmeshki2015vericoq}. Another approach is
to use self-composition, or program products, to verify information-flow properties~\cite{eilers2021product}.
Security extensions in the hardware description language can enforce 
information flow policies at the language level~\cite{ferraiuolo2017secverilog, deng2017secchisel, li2011caisson, li2014sapper,zhang2015secverilog, ardeshiricham2019verisketch}.

%Full, formal verification of information flow is fundamentally different than
%the SEIF approach and makes different trade-offs. These approaches are often less automated, more time
%intensive, and tackle smaller designs, for stronger results that are both
%sound and complete.

%These platforms require extensive manual
%effort, and SEIF could potentially be used to ease the manual
%burden.


%%Prior work has also formally verified information-flow properties via program products~\cite{eilers2021product}.

%% Leaving out as not quite in scope (and we're short on space)
%% There has also been work on providing architecture support of information flow tagging and labeling, in SAFE!\cite{amorim2014verified} which aims to prove non-interference and an ISA for a RISC-V processor that uses the labels to eliminate or mitigate timing channels \cite{zagieboylo2019using}.
%% malicious flows of information where policy violations can be detected.

%% Specific applications include Clepsydra, which detects timing flows in hardware~\cite{ardeshiricham2017clepsydra}, and flow tracking in analog designs~\cite{bidmeshki2017information}. 

%This is mentioned in the intro and I don't know what to do with it here.
%% EXERT is an information flow analysis framework, implemented at the
%% gate-level, that uses SAT solving to produce test benches to trigger trojans
%% and find possible privilege escalation vulnerabilites. \cite{wu2022exert}.

%% GLIFT is a ga
%% te-level framework information flow framework that has been used to find hardware trojans \cite{hu2016detecting}.


%% \subsection{Not Organized Yet}

%% Model Checking for Information Flow (temporal logic for
%% hyperproperties)~\cite{clarkson2014temporal}

  
%Isadora is a tool which automates generation of hardware information flow properties, by combining flow tracking with specification mining \cite{Deutschbein2021Isadora,Deutschbein2022JCEN}. This provides a complementary lens through which to view our work. Properties of interest generated by Isadora can be used to focus our analysis on interesting parts of the hyperflow graph, while our tool can highlight specific flows and counter-examples to properties Isadora discovers.

%Assertion verification for confidentiality in HW~\cite{kong2017using}. \cks{Need
%  to read -- not sure if that is an accurate representation} \kar{i put it in the first section, i think it's proof checking?, seems similar to UPEC}
  
%Non-interference for NOCs~\cite{boraten2018securing}. \cks{Read for designs and
%  properties. Looks at NOCs.}
  
%A key contribution of spectector is the definition of speculative
%non-interference. Spectector uses symbolic execution of SW to find programs that
%violate this notion of non-interference -- programs for which speculatively executed (and
%mispredicted) branches in the CPU core can lead to information flow to the
%attacker that would not flow to the attacker in the absence of speculative
%execution. Spectector uses symbolic execution to analyze the flow of
%information (in SW, rather than in HW), but has some key differences. First, the
%goal is different, Spectector is looking for SW programs that can leak
%information under a speculative execution model, but not otherwise; our work is
%looking for (or proving the absence of) particular flows of information within a
%hardware design from a source signal to a sink signal or port. In many ways the
%methodology is similar; both use symbolic execution to build descriptions of
%information flow through the design (or program). Spectector compares flows in both speculative and non-speculative
%execution models and uses an SMT solver to compare the two cases; this work
%assesses individual flows that follow a particular path and uses an SMT solver
%to find corresponding test-cases.

%Learch paper~\cite{?} HW verification w/NN~\cite{?}. Recent work is using ML and
%in particular NN to guide symbolic execution of hardware designs and to build
%test-cases for use with simulation-based verification engines. Neither are in
%the context of information flow. It is possible to define features and coverage
%metrics from the IFG-guided symbolic execution engine and leverage these deep
%learning techniques.

%\cks{moved from elsewhere}
%A non-interference property is a hyperproperty, and is typically stated as a
%2-safety property: \cks{write out
%  property}~\cite{clarkson2010hyperproperties,Kozyri2022expressing}. 
%\kar{i'm commenting this out b/c i don't think we need it in the related work}  
%Model
%checking approaches the problem by stating it as a 2-safety problem and using
%self-composition to verify the property. \cks{flesh this out a bit.} Model
%checking can prove non-interference in some cases~\cite{sthg} and demonstrate
%non-interference up to a bounded number of clock cycles in other
%cases~\cite{sthg}. An alternative approach is to use information flow tracking~\cite{denning}. Input
%signals of interest are labeled with their security level or intended use and a
%flow relation defining how labels propagate through the system is
%defined. Gate-level~\cite{GLIFT} and RTL level information flow tracking~\cite{sthg} adds tracking logic
%to a design, and at the end of execution (or simulation), one can inspect the
%labels of the output signals to determine whether information has flown from a
%labeled input to an output. Information flow tracking can find flows of
%information quickly, even over many clock cycles, but it is a dynamic analysis
%technique and can only find information flows for the particular traces seen
%during simulation. Information flow tracking can also fail to take into account
%semantic notions of flow leading to false positive reports of influence from $x$
%to $y$ where there are none. See section~\ref{sec:sthg} for further discussion
%of this issue.

% i am commented this out because i think we address it else where?
%\cks{How do the flows we identify compare to those of gate-level taint
%  tracking~\cite{}, non-interference~\cite{goguen1982}, observational non-interference~\cite{}?
%I think we can provide enforcement of observational non-interference and be more
%precise in our enforcement (fewer false positives)
%than gate-level taint tracking. Gate level taint-tracking will not detect the
%reconvergent no-flow (we will), will not detect the $y <= x XOR x$~\cite{oberg2010theoretical,hu2011theoretical} no-flow, we
%will, will not detect the $if (x XOR x)$ no flow, and neither do we.}

