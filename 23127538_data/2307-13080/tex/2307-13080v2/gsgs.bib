% Encoding: UTF-8

@InProceedings{Goswami2022,
  author    = {Goswami, Pritam and Sharma, Avisek and Ghosh, Satakshi and Sau, Buddhadeb},
  title     = {Time Optimal Gathering of Myopic Robots on an Infinite Triangular Grid},
  booktitle = {Stabilization, Safety, and Security of Distributed Systems},
  year      = {2022},
  editor    = {Devismes, St{\'e}phane and Petit, Franck and Altisen, Karine and Di Luna, Giuseppe Antonio and Fernandez Anta, Antonio},
  pages     = {270--284},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {This work deals with the problem of gathering n oblivious mobile entities, called robots, at a point (not known beforehand) placed on an infinite triangular grid. The robots are considered to be myopic, i.e., robots have limited visibility. Earlier works of gathering mostly considered the robots either on a plane or on a circle or on a rectangular grid under both full and limited visibility. In the triangular grid, there are two works to the best of our knowledge. The first one is by Cicerone et al. [ICDCN'2021] on arbitrary pattern formation where full visibility is considered. The other one by Shibata et al. [IPDPS(W)'2021] which considers seven robots with 2-hop visibility that form a hexagon with one robot in the center of the hexagon in a collision-less environment under a fully synchronous scheduler.},
  isbn      = {978-3-031-21017-4},
}

@InProceedings{Garg2020,
  author    = {Vijay K. Garg},
  title     = {Predicate Detection to Solve Combinatorial Optimization Problems},
  booktitle = {{SPAA} '20: 32nd {ACM} Symposium on Parallelism in Algorithms and Architectures, Virtual Event, USA, July 15-17, 2020},
  year      = {2020},
  editor    = {Christian Scheideler and Michael Spear},
  pages     = {235--245},
  publisher = {{ACM}},
  bibsource = {dblp computer science bibliography, https://dblp.org},
  biburl    = {https://dblp.org/rec/conf/spaa/Garg20.bib},
  doi       = {10.1145/3350755.3400235},
  timestamp = {Sun, 12 Jul 2020 18:55:45 +0200},
  url       = {https://doi.org/10.1145/3350755.3400235},
}

@InProceedings{Garg2022,
  author    = {Garg, Vijay},
  title     = {A Lattice Linear Predicate Parallel Algorithm for the Dynamic Programming Problems},
  booktitle = {23rd International Conference on Distributed Computing and Networking},
  year      = {2022},
  series    = {ICDCN 2022},
  pages     = {72–76},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {It has been shown that the parallel Lattice Linear Predicate (LLP) algorithm solves many combinatorial optimization problems such as the shortest path problem, the stable marriage problem and the market clearing price problem. In this paper, we give the parallel LLP algorithm for many dynamic programming problems. In particular, we show that the LLP algorithm solves the longest subsequence problem, the optimal binary search tree problem, and the knapsack problem. Furthermore, the algorithm can be used to solve the constrained versions of these problems so long as the constraints are lattice linear. The parallel LLP algorithm works correctly in a distributed system setting where a processor may use an older value of a variable stored at a different processor.},
  doi       = {10.1145/3491003.3491019},
  isbn      = {9781450395601},
  keywords  = {optimization problems, predicate detection, distributive lattices},
  location  = {Delhi, AA, India},
  numpages  = {5},
  url       = {https://doi.org/10.1145/3491003.3491019},
}

@InProceedings{Garg2021,
  author    = {Garg, Vijay K.},
  title     = {A Lattice Linear Predicate Parallel Algorithm for the Housing Market Problem},
  booktitle = {Stabilization, Safety, and Security of Distributed Systems},
  year      = {2021},
  editor    = {Johnen, Colette and Schiller, Elad Michael and Schmid, Stefan},
  pages     = {108--122},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {It has been shown that Lattice Linear Predicate (LLP) algorithm solves many combinatorial optimization problems such as the shortest path problem, the stable marriage problem and the market clearing price problem. In this paper, we give an LLP algorithm for the Housing Market problem. The Housing Market problem is a one-sided matching problem with n agents and n houses. Each agent has an initial allocation of a house and a totally ordered preference list of houses. The goal is to find a matching between agents and houses such that no strict subset of agents can improve their outcome by exchanging houses with each other rather than going with the matching. Gale's celebrated Top Trading Cycle algorithm to find the matching requires {\$}{\$}O(n^2){\$}{\$}O(n2)time. Our parallel algorithm has expected time complexity {\$}{\$}O(n {\backslash}log ^2 n){\$}{\$}O(nlog2n)with and expected work complexity of {\$}{\$}O(n^2 {\backslash}log n){\$}{\$}O(n2logn).},
  isbn      = {978-3-030-91081-5},
}

@InProceedings{Gupta2021,
  author    = {Gupta, Arya Tanmay and Kulkarni, Sandeep S.},
  title     = {Extending Lattice Linearity for Self-stabilizing Algorithms},
  booktitle = {Stabilization, Safety, and Security of Distributed Systems},
  year      = {2021},
  editor    = {Johnen, Colette and Schiller, Elad Michael and Schmid, Stefan},
  pages     = {365--379},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {In this article, we focus on extending the notion of lattice linearity to self-stabilizing programs. Lattice linearity allows a node to execute its actions with old information about the state of other nodes and still preserve correctness. It increases the concurrency of the program execution by eliminating the need for synchronization among its nodes.},
  isbn      = {978-3-030-91081-5},
}

@InProceedings{Gupta2022,
  author    = {Gupta, Arya Tanmay and Kulkarni, Sandeep S.},
  title     = {Brief Announcement: Fully Lattice Linear Algorithms},
  booktitle = {Stabilization, Safety, and Security of Distributed Systems: 24th International Symposium, SSS 2022, Clermont-Ferrand, France, November 15–17, 2022, Proceedings},
  year      = {2022},
  pages     = {341–345},
  address   = {Berlin, Heidelberg},
  publisher = {Springer-Verlag},
  abstract  = {This paper focuses on analyzing and differentiating between lattice linear problems and lattice linear algorithms. It introduces a new class of algorithms called (fully) lattice linear algorithms, that induce a partial order among all states and form multiple lattices. An initial state locks the system into one of these lattices. We present a lattice linear self-stabilizing algorithm for minimal dominating set.},
  doi       = {10.1007/978-3-031-21017-4_24},
  isbn      = {978-3-031-21016-7},
  keywords  = {Lattice linear problems, Lattice linear algorithms, Minimal dominating set, Convergence time, Self-stabilization},
  location  = {Clermont-Ferrand, France},
  numpages  = {5},
  url       = {https://doi.org/10.1007/978-3-031-21017-4_24},
}

@InProceedings{Cicerone2021,
  author    = {Cicerone, Serafino and Di Fonso, Alessia and Di Stefano, Gabriele and Navarra, Alfredo},
  title     = {Arbitrary Pattern Formation on Infinite Regular Tessellation Graphs},
  booktitle = {Proceedings of the 22nd International Conference on Distributed Computing and Networking},
  year      = {2021},
  series    = {ICDCN '21},
  pages     = {56–65},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {Given a set R of robots, each one located at a different vertex of an infinite regular tessellation graph, we aim to explore the Arbitrary Pattern Formation (APF) problem. Given a multiset F of grid vertices such that |R| = |F|, APF asks for a distributed algorithm that moves robots so as to reach a configuration similar to F. Similarity means that robots must be disposed as F regardless of translations, rotations, reflections. So far, as possible discretization of the Euclidean plane only the standard square grid has been considered in the context of the classical Look-Compute-Move model. However, it is natural to consider the other regular tessellation graphs, that are triangular and hexagonal grids. For any regular tessellation graph, we provide a resolution algorithm for APF when the initial configuration is asymmetric.},
  doi       = {10.1145/3427796.3427833},
  isbn      = {9781450389334},
  keywords  = {Graphs, Mobile and collaborative systems, Asynchrony, Self-organization, Pattern formation, Distributed algorithms},
  location  = {Nara, Japan},
  numpages  = {10},
  url       = {https://doi.org/10.1145/3427796.3427833},
}

@Article{Poudel2021,
  author         = {Poudel, Pavan and Sharma, Gokarna},
  title          = {Time-Optimal Gathering under Limited Visibility with One-Axis Agreement},
  journal        = {Information},
  year           = {2021},
  volume         = {12},
  number         = {11},
  issn           = {2078-2489},
  abstract       = {We consider the distributed setting of N autonomous mobile robots that operate in Look-Compute-Move (LCM) cycles following the well-celebrated classic oblivious robots model. We study the fundamental problem of gathering N autonomous robots on a plane, which requires all robots to meet at a single point (or to position within a small area) that is not known beforehand. We consider limited visibility under which robots are only able to see other robots up to a constant Euclidean distance and focus on the time complexity of gathering by robots under limited visibility. There exists an O(DG) time algorithm for this problem in the fully synchronous setting, assuming that the robots agree on one coordinate axis (say north), where DG is the diameter of the visibility graph of the initial configuration. In this article, we provide the first O(DE) time algorithm for this problem in the asynchronous setting under the same assumption of robots’ agreement with one coordinate axis, where DE is the Euclidean distance between farthest-pair of robots in the initial configuration. The runtime of our algorithm is a significant improvement since for any initial configuration of N≥1 robots, DE≤DG, and there exist initial configurations for which DG can be quadratic on DE, i.e., DG=Θ(DE2). Moreover, our algorithm is asymptotically time-optimal since the trivial time lower bound for this problem is Ω(DE).},
  article-number = {448},
  doi            = {10.3390/info12110448},
  url            = {https://www.mdpi.com/2078-2489/12/11/448},
}

@Article{DAngelo2016,
  author   = {Gianlorenzo D'Angelo and Gabriele {Di Stefano} and Ralf Klasing and Alfredo Navarra},
  title    = {Gathering of robots on anonymous grids and trees without multiplicity detection},
  journal  = {Theoretical Computer Science},
  year     = {2016},
  volume   = {610},
  pages    = {158-168},
  issn     = {0304-3975},
  note     = {Structural Information and Communication Complexity},
  abstract = {The paper studies the gathering problem on grid and tree networks. A team of robots placed at different nodes of the input graph, has to meet at some node and remain there. Robots operate in Look–Compute–Move cycles; in one cycle, a robot perceives the current configuration in terms of occupied nodes (Look), decides whether to move toward one of its neighbors (Compute), and in the positive case makes the computed move instantaneously (Move). Cycles are performed asynchronously for each robot. The problem has been deeply studied for the case of ring networks. However, the known techniques used on rings cannot be directly extended to grids and trees. Moreover, on rings, another assumption concerning the so-called multiplicity detection capability was required in order to accomplish the gathering task. That is, a robot is able to detect during its Look operation whether a node is empty, or occupied by one robot, or occupied by an undefined number of robots greater than one. In this paper, we provide a full characterization about gatherable configurations for grids and trees. In particular, we show that on these topologies, the multiplicity detection is not required. Very interestingly, sometimes the problem appears trivial, as it is for the case of grids with both odd sides, while sometimes the involved techniques require new insights with respect to the well-studied ring case. Moreover, our results reveal the importance of structures like grids and trees that allow to overcome the multiplicity detection with respect to the ring case.},
  doi      = {https://doi.org/10.1016/j.tcs.2014.06.045},
  keywords = {Distributed computing, Gathering, Oblivious asynchronous robots, Anonymous networks, Grids and trees, Look–Compute–Move},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397514005131},
}

@InProceedings{Shibata2021,
  author    = {Shibata, Masahiro and Ohyabu, Masaki and Sudo, Yuichi and Nakamura, Junya and Kim, Yonghwan and Katayama, Yoshiaki},
  title     = {Gathering of seven autonomous mobile robots on triangular grids},
  booktitle = {2021 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW)},
  year      = {2021},
  pages     = {566-575},
  doi       = {10.1109/IPDPSW52791.2021.00090},
}

@Article{Flocchini2005,
  author   = {Paola Flocchini and Giuseppe Prencipe and Nicola Santoro and Peter Widmayer},
  title    = {Gathering of asynchronous robots with limited visibility},
  journal  = {Theoretical Computer Science},
  year     = {2005},
  volume   = {337},
  number   = {1},
  pages    = {147-168},
  issn     = {0304-3975},
  abstract = {In this paper we study the problem of gathering a collection of identical oblivious mobile robots in the same location of the plane. Previous investigations have focused mostly on the unlimited visibility setting, where each robot can always see all the others regardless of their distance. In the more difficult and realistic setting where the robots have limited visibility, the existing algorithmic results are only for convergence (towards a common point, without ever reaching it) and only for semi-synchronous environments, where robots’ movements are assumed to be performed instantaneously. In contrast, we study this problem in a totally asynchronous setting, where robots’ actions, computations, and movements require a finite but otherwise unpredictable amount of time. We present a protocol that allows anonymous oblivious robots with limited visibility to gather in the same location in finite time, provided they have orientation (i.e., agreement on a coordinate system). Our result indicates that, with respect to gathering, orientation is at least as powerful as instantaneous movements.},
  doi      = {https://doi.org/10.1016/j.tcs.2005.01.001},
  keywords = {Mobile robots, Distributed computing, Asynchrony, Point formation, RendezVous, Orientation, Cooperation and control},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397505000149},
}

@InProceedings{Augustine2018,
  author    = {Augustine, John and Moses, William K.},
  title     = {Dispersion of Mobile Robots: A Study of Memory-Time Trade-Offs},
  booktitle = {Proceedings of the 19th International Conference on Distributed Computing and Networking},
  year      = {2018},
  series    = {ICDCN '18},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {We introduce a new problem in the domain of mobile robots, which we term dispersion. In this problem, n robots are placed in an n node graph arbitrarily and must coordinate with each other to reach a final configuration such that exactly one robot is at each node. We study this problem through the lenses of minimizing the memory required by each robot and of minimizing the number of rounds required to achieve dispersion.Dispersion is of interest due to its relationship to the problems of scattering on a graph, exploration using mobile robots, and load balancing on a graph. Additionally, dispersion has an immediate real world application due to its relationship to the problem of recharging electric cars, as each car can be considered a robot and recharging stations and the roads connecting them nodes and edges of a graph respectively. Since recharging is a costly affair relative to traveling, we want to distribute these cars amongst the various available recharge points where communication should be limited to car-to-car interactions.We provide lower bounds on both the memory required for robots to achieve dispersion and the minimum running time to achieve dispersion on any type of graph. We then analyze the trade-offs between time and memory for various types of graphs. We provide time optimal and memory optimal algorithms for several types of graphs and show the power of a little memory in terms of running time.},
  articleno = {1},
  doi       = {10.1145/3154273.3154293},
  isbn      = {9781450363723},
  keywords  = {Collective robot exploration, Distributed algorithms, Deterministic algorithms, Dispersion, Load balancing, Graph algorithms, Scattering, Mobile robots, Uniform deployment},
  location  = {Varanasi, India},
  numpages  = {10},
  url       = {https://doi.org/10.1145/3154273.3154293},
}

@Article{Bose2020,
  author   = {Kaustav Bose and Ranendu Adhikary and Manash Kumar Kundu and Buddhadeb Sau},
  title    = {Arbitrary pattern formation on infinite grid by asynchronous oblivious robots},
  journal  = {Theoretical Computer Science},
  year     = {2020},
  volume   = {815},
  pages    = {213-227},
  issn     = {0304-3975},
  abstract = {The Arbitrary Pattern Formation problem asks to design a distributed algorithm that allows a set of autonomous mobile robots to form any specific but arbitrary geometric pattern given as input. The problem has been extensively studied in the literature in continuous domains. This paper investigates a discrete version of the problem where the robots are operating on a two dimensional infinite grid. The robots are assumed to be autonomous, identical, anonymous and oblivious. They operate in Look-Compute-Move cycles under a fully asynchronous scheduler. The robots do not have access to any common global coordinate system. However, the grid allows the robots to have a partial agreement on coordinate system as they can align the axes of their local coordinate systems along the grid lines. In this setting, we have shown that a set of robots can form any pattern, if their starting configuration is asymmetric.},
  doi      = {https://doi.org/10.1016/j.tcs.2020.02.016},
  keywords = {Distributed algorithm, Autonomous robot, Arbitrary pattern formation, Grid, Asynchronous, Look-compute-move cycle},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397520301006},
}

@InProceedings{Bhagat2015,
  author    = {Bhagat, Subhash and Gan Chaudhuri, Sruti and Mukhopadhyaya, Krishnendu},
  title     = {Fault-Tolerant Gathering of Asynchronous Oblivious Mobile Robots under One-Axis Agreement},
  booktitle = {WALCOM: Algorithms and Computation},
  year      = {2015},
  editor    = {Rahman, M. Sohel and Tomita, Etsuji},
  pages     = {149--160},
  address   = {Cham},
  publisher = {Springer International Publishing},
  abstract  = {In this paper, we have studied one of the fundamental coordination problems for multi robot system, namely gathering, for n{\thinspace}≥{\thinspace}2 asynchronous, oblivious mobile robots in the presence of f{\thinspace}<{\thinspace}n faulty robots. Earlier works have reported that, in general, to solve gathering problem for asynchronous robots, many assumptions are required, like multiplicity detection or total agreement in coordinate axis or constant amount of memory bits. However, in this paper we have proved that gathering of asynchronous robots is possible with less number of such assumptions and even in the presence of any number of faulty robots. In our case, the robots only agree on the direction and orientation of any one axis.},
  isbn      = {978-3-319-15612-5},
}

@Article{Klasing2010,
  author   = {Ralf Klasing and Adrian Kosowski and Alfredo Navarra},
  title    = {Taking advantage of symmetries: Gathering of many asynchronous oblivious robots on a ring},
  journal  = {Theoretical Computer Science},
  year     = {2010},
  volume   = {411},
  number   = {34},
  pages    = {3235-3246},
  issn     = {0304-3975},
  abstract = {One of the recently considered models of robot-based computing makes use of identical, memoryless mobile units placed in nodes of an anonymous graph. The robots operate in Look–Compute–Move cycles; in one cycle, a robot takes a snapshot of the current configuration (Look), takes a decision whether to stay idle or to move to one of the nodes adjacent to its current position (Compute), and in the latter case makes an instantaneous move to this neighbor (Move). Cycles are performed asynchronously for each robot. In such a restricted scenario, we study the influence of symmetries of the robot configuration on the feasibility of certain computational tasks. More precisely, we deal with the problem of gathering all robots at one node of the graph, and propose a solution based on a symmetry-preserving strategy. When the considered graph is an undirected ring and the number of robots is sufficiently large (more than 18), such an approach is proved to solve the problem for all starting situations, as long as gathering is feasible. In this way we also close the open problem of characterizing symmetric situations on the ring which admit a gathering [R. Klasing, E. Markou, A. Pelc: Gathering asynchronous oblivious mobile robots in a ring, Theoret. Comput. Sci. 390 (1) (2008) 27–39]. The proposed symmetry-preserving approach, which is complementary to symmetry-breaking techniques found in related work, appears to be new and may have further applications in robot-based computing.},
  doi      = {https://doi.org/10.1016/j.tcs.2010.05.020},
  keywords = {Asynchronous system, Mobile robots, Oblivious robots, Gathering problem, Ring},
  url      = {https://www.sciencedirect.com/science/article/pii/S0304397510003129},
}

% HERE

@InProceedings{Michael2002,
  author    = {Michael, Maged M.},
  title     = {High Performance Dynamic Lock-Free Hash Tables and List-Based Sets},
  booktitle = {Proceedings of the Fourteenth Annual ACM Symposium on Parallel Algorithms and Architectures},
  year      = {2002},
  series    = {SPAA '02},
  pages     = {73–82},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {Lock-free (non-blocking) shared data structures promise more robust performance and reliability than conventional lock-based implementations. However, all prior lock-free algorithms for sets and hash tables suffer from serious drawbacks that prevent or limit their use in practice. These drawbacks include size inflexibility, dependence on atomic primitives not supported on any current processor architecture, and dependence on highly-inefficient or blocking memory management techniques.Building on the results of prior researchers, this paper presents the first CAS-based lock-free list-based set algorithm that is compatible with all lock-free memory management methods. We use it as a building block of an algorithm for lock-free hash tables. In addition to being lock-free, the new algorithm is dynamic, linearizable, and space-efficient.Our experimental results show that the new algorithm outperforms the best known lock-free as well as lock-based hash table implementations by significant margins, and indicate that it is the algorithm of choice for implementing shared hash tables.},
  doi       = {10.1145/564870.564881},
  isbn      = {1581135297},
  location  = {Winnipeg, Manitoba, Canada},
  numpages  = {10},
  url       = {https://doi.org/10.1145/564870.564881},
}

@InProceedings{Hendler2004,
  author    = {Hendler, Danny and Shavit, Nir and Yerushalmi, Lena},
  title     = {A Scalable Lock-Free Stack Algorithm},
  booktitle = {Proceedings of the Sixteenth Annual ACM Symposium on Parallelism in Algorithms and Architectures},
  year      = {2004},
  series    = {SPAA '04},
  pages     = {206–215},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {The literature describes two high performance concurrent stack algorithms based on combining funnels and elimination trees. Unfortunately, the funnels are linearizable but blocking, and the elimination trees are non-blocking but not linearizable. Neither is used in practice since they perform well only at exceptionally high loads. The literature also describes a simple lock-free linearizable stack algorithm that works at low loads but does not scale as the load increases. The question of designing a stack algorithm that is non-blocking, linearizable, and scales well throughout the concurrency range, has thus remained open.This paper presents such a concurrent stack algorithm. It is based on the following simple observation: that a single elimination array used as a backoff scheme for a simple lock-free stack is lock-free, linearizable, and scalable. As our empirical results show, the resulting elimination-backoff stack performs as well as the simple stack at low loads, and increasingly outperforms all other methods (lock-based and non-blocking) as concurrency increases. We believe its simplicity and scalability make it a viable practical alternative to existing constructions for implementing concurrent stacks.},
  doi       = {10.1145/1007912.1007944},
  isbn      = {1581138407},
  location  = {Barcelona, Spain},
  numpages  = {10},
  url       = {https://doi.org/10.1145/1007912.1007944},
}

@InProceedings{Valois1995,
  author    = {Valois, John D.},
  title     = {Lock-Free Linked Lists Using Compare-and-Swap},
  booktitle = {Proceedings of the Fourteenth Annual ACM Symposium on Principles of Distributed Computing},
  year      = {1995},
  series    = {PODC '95},
  pages     = {214–222},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/224964.224988},
  isbn      = {0897917103},
  location  = {Ottowa, Ontario, Canada},
  numpages  = {9},
  url       = {https://doi.org/10.1145/224964.224988},
}

@InProceedings{Natarajan2014,
  author    = {Natarajan, Aravind and Mittal, Neeraj},
  title     = {Fast Concurrent Lock-Free Binary Search Trees},
  booktitle = {Proceedings of the 19th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming},
  year      = {2014},
  series    = {PPoPP '14},
  pages     = {317–328},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {We present a new lock-free algorithm for concurrent manipulation of a binary search tree in an asynchronous shared memory system that supports search, insert and delete operations. In addition to read and write instructions, our algorithm uses (single-word) compare-and-swap (CAS) and bit-test-and-set (SETB) atomic instructions, both of which are commonly supported by many modern processors including Intel~64 and AMD64.In contrast to existing lock-free algorithms for a binary search tree, our algorithm is based on marking edges rather than nodes. As a result, when compared to other lock-free algorithms, modify (insert and delete) operations in our algorithm work on a smaller portion of the tree, thereby reducing conflicts, and execute fewer atomic instructions (one for insert and three for delete). Our experiments indicate that our lock-free algorithm significantly outperforms all other algorithms for a concurrent binary search tree in many cases, especially when contention is high, by as much as 100\%.},
  doi       = {10.1145/2555243.2555256},
  isbn      = {9781450326568},
  keywords  = {lock-free algorithm, binary search tree, concurrent data structure},
  location  = {Orlando, Florida, USA},
  numpages  = {12},
  url       = {https://doi.org/10.1145/2555243.2555256},
}

@InProceedings{Shavit1997,
  author    = {Shavit, Nir and Upfal, Eli and Zemach, Asaph},
  title     = {A Wait-Free Sorting Algorithm},
  booktitle = {Proceedings of the Sixteenth Annual ACM Symposium on Principles of Distributed Computing},
  year      = {1997},
  series    = {PODC '97},
  pages     = {121–128},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/259380.259432},
  isbn      = {0897919521},
  location  = {Santa Barbara, California, USA},
  numpages  = {8},
  url       = {https://doi.org/10.1145/259380.259432},
}

@Article{Attiya1994,
  author     = {Attiya, Hagit and Lynch, Nancy and Shavit, Nir},
  title      = {Are Wait-Free Algorithms Fast?},
  journal    = {J. ACM},
  year       = {1994},
  volume     = {41},
  number     = {4},
  pages      = {725–763},
  month      = {jul},
  issn       = {0004-5411},
  abstract   = {The time complexity of wait-free algorithms in “normal” executions, where no failures occur and processes operate at approximately the same speed, is considered. A lower bound of log n on the time complexity of any wait-free algorithm that achieves approximate agreement among n processes is proved. In contrast, there exists a non-wait-free algorithm that solves this problem in constant time. This implies an Ω(log n) time separation between the wait-free and non-wait-free computation models. On the positive side, we present an O(log n) time wait-free approximate agreement algorithm; the complexity of this algorithm is within a small constant of the lower bound.},
  address    = {New York, NY, USA},
  doi        = {10.1145/179812.179902},
  issue_date = {July 1994},
  keywords   = {approximate agreement, fault-tolerance, wait-free},
  numpages   = {39},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/179812.179902},
}

@Article{Alistarh2016,
  author     = {Alistarh, Dan and Censor-Hillel, Keren and Shavit, Nir},
  title      = {Are Lock-Free Concurrent Algorithms Practically Wait-Free?},
  journal    = {J. ACM},
  year       = {2016},
  volume     = {63},
  number     = {4},
  month      = {sep},
  issn       = {0004-5411},
  abstract   = {Lock-free concurrent algorithms guarantee that some concurrent operation will always make progress in a finite number of steps. Yet programmers prefer to treat concurrent code as if it were wait-free, guaranteeing that all operations always make progress. Unfortunately, designing wait-free algorithms is generally a very complex task, and the resulting algorithms are not always efficient. Although obtaining efficient wait-free algorithms has been a long-time goal for the theory community, most nonblocking commercial code is only lock-free.This article suggests a simple solution to this problem. We show that for a large class of lock-free algorithms, under scheduling conditions that approximate those found in commercial hardware architectures, lock-free algorithms behave as if they are wait-free. In other words, programmers can continue to design simple lock-free algorithms instead of complex wait-free ones, and in practice, they will get wait-free progress.Our main contribution is a new way of analyzing a general class of lock-free algorithms under a stochastic scheduler. Our analysis relates the individual performance of processes to the global performance of the system using Markov chain lifting between a complex per-process chain and a simpler system progress chain. We show that lock-free algorithms are not only wait-free with probability 1 but that in fact a general subset of lock-free algorithms can be closely bounded in terms of the average number of steps required until an operation completes.To the best of our knowledge, this is the first attempt to analyze progress conditions, typically stated in relation to a worst-case adversary, in a stochastic model capturing their expected asymptotic behavior.},
  address    = {New York, NY, USA},
  articleno  = {31},
  doi        = {10.1145/2903136},
  issue_date = {November 2016},
  keywords   = {lock-free algorithms, schedulers, wait-free algorithms, shared memory, progress properties, Distributed computing},
  numpages   = {20},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/2903136},
}

@InProceedings{Afek1995,
  author    = {Afek, Yehuda and Dauber, Dalia and Touitou, Dan},
  title     = {Wait-Free Made Fast},
  booktitle = {Proceedings of the Twenty-Seventh Annual ACM Symposium on Theory of Computing},
  year      = {1995},
  series    = {STOC '95},
  pages     = {538–547},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  doi       = {10.1145/225058.225271},
  isbn      = {0897917189},
  location  = {Las Vegas, Nevada, USA},
  numpages  = {10},
  url       = {https://doi.org/10.1145/225058.225271},
}

@Article{Dwork1997,
  author     = {Dwork, Cynthia and Herlihy, Maurice and Waarts, Orli},
  title      = {Contention in Shared Memory Algorithms},
  journal    = {J. ACM},
  year       = {1997},
  volume     = {44},
  number     = {6},
  pages      = {779–805},
  month      = {nov},
  issn       = {0004-5411},
  abstract   = {Most complexity measures for concurrent algorithms for asynchronous shared-memory architectures focus on process steps and memory consumption. In practice, however, performance of multiprocessor algorithms is heavily influenced by contention, the extent to which processess access the same location at the same time. Nevertheless, even though contention is one of the principal considerations affecting the performance of real algorithms on real multiprocessors, there are no formal tools for analyzing the contention of asynchronous shared-memory algorithms.This paper introduces the first formal complexity model for contention in shared-memory multiprocessors. We focus on the standard multiprocessor architecture in which n asynchronous processes communicate by applying read, write, and read-modify-write operations to a shared memory. To illustrate the utility of our model, we use it to derive two kinds of results: (1) lower bounds on contention for well-known basic problems such as agreement and mutual exclusion, and (2) trade-offs between the length of the critical path (maximal number of accesses to shared variables performed by a single process in executing the algorithm) and contention for these algorithms. Furthermore, we give the first formal contention analysis of a variety of counting networks, a class of concurrent data structures inplementing shared counters. Experiments indicate that certain counting networks outperform conventional single-variable counters at high levels of contention. Our analysis provides the first formal model explaining this phenomenon.},
  address    = {New York, NY, USA},
  doi        = {10.1145/268999.269000},
  issue_date = {Nov. 1997},
  keywords   = {mutual exclusion, counting networks, contention},
  numpages   = {27},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/268999.269000},
}

@InProceedings{Kim2005,
  author    = {Kim, J. and Das, A.},
  title     = {HCF: a starvation-free practical algorithm for maximizing throughput in input-queued switches},
  booktitle = {HPSR. 2005 Workshop on High Performance Switching and Routing, 2005.},
  year      = {2005},
  pages     = {68-72},
  doi       = {10.1109/HPSR.2005.1503196},
}

@InProceedings{Attiya2010,
  author    = {Attiya, Hagit and Gramoli, Vincent and Milani, Alessia},
  title     = {A Provably Starvation-Free Distributed Directory Protocol},
  booktitle = {Stabilization, Safety, and Security of Distributed Systems},
  year      = {2010},
  editor    = {Dolev, Shlomi and Cobb, Jorge and Fischer, Michael and Yung, Moti},
  pages     = {405--419},
  address   = {Berlin, Heidelberg},
  publisher = {Springer Berlin Heidelberg},
  abstract  = {This paper presents Combine, a distributed directory protocol for shared objects, designed for large-scale distributed systems. Directory protocols support move requests, allowing to write the object locally, as well as lookup requests, providing a read-only copy of the object. They have been used in distributed shared memory implementations and in data-flow implementations of distributed software transactional memory in large-scale systems.},
  isbn      = {978-3-642-16023-3},
}

@Article{Hesselink2013,
  author    = {Hesselink, Wim H. and IJbema, Mark},
  title     = {Starvation-free mutual exclusion with semaphores},
  journal   = {Formal Aspects of Computing},
  year      = {2013},
  volume    = {25},
  number    = {6},
  pages     = {947–969},
  month     = nov,
  issn      = {1433-299X},
  doi       = {10.1007/s00165-011-0219-y},
  publisher = {Association for Computing Machinery (ACM)},
  url       = {http://dx.doi.org/10.1007/s00165-011-0219-y},
}

@Article{Morris1979,
  author   = {Joseph M. Morris},
  title    = {A starvation-free solution to the mutual exclusion problem},
  journal  = {Information Processing Letters},
  year     = {1979},
  volume   = {8},
  number   = {2},
  pages    = {76-80},
  issn     = {0020-0190},
  doi      = {https://doi.org/10.1016/0020-0190(79)90147-9},
  keywords = {Mutual exclusion, semaphore operations, split binary semaphore, critical section, individual starvation},
  url      = {https://www.sciencedirect.com/science/article/pii/0020019079901479},
}

@InProceedings{Martin1997,
  author    = {Martin, A.J. and Lines, A. and Manohar, R. and Nystrom, M. and Penzes, P. and Southworth, R. and Cummings, U. and Tak Kwan Lee},
  title     = {The design of an asynchronous MIPS R3000 microprocessor},
  booktitle = {Proceedings Seventeenth Conference on Advanced Research in VLSI},
  year      = {1997},
  pages     = {164-181},
  doi       = {10.1109/ARVLSI.1997.634853},
}

@Article{Udding1986,
  author   = {Jan Tijmen Udding},
  title    = {Absence of individual starvation using weak semaphores},
  journal  = {Information Processing Letters},
  year     = {1986},
  volume   = {23},
  number   = {3},
  pages    = {159-162},
  issn     = {0020-0190},
  doi      = {https://doi.org/10.1016/0020-0190(86)90117-1},
  keywords = {Multi-programming, operating systems, analysis of algorithms},
  url      = {https://www.sciencedirect.com/science/article/pii/0020019086901171},
}

@Article{Lejeune2015,
  author   = {Jonathan Lejeune and Luciana Arantes and Julien Sopena and Pierre Sens},
  title    = {A fair starvation-free prioritized mutual exclusion algorithm for distributed systems},
  journal  = {Journal of Parallel and Distributed Computing},
  year     = {2015},
  volume   = {83},
  pages    = {13-29},
  issn     = {0743-7315},
  abstract = {Several distributed mutual exclusion algorithms define the order in which requests are satisfied based on the priorities assigned to requests. These algorithms are very useful for real-time applications ones or those where priority is associated to a quality of service requirement. However, priority based strategies may result in starvation problems where high priority requests forever prevent low priority ones to be satisfied. To overcome this problem, many priority-based algorithms propose to gradually increase the priority of pending requests. The drawback of such an approach is that it can violate priority-based order of requests leading to priority inversion. Therefore, aiming at minimizing the number of priority violations without introducing starvation, we have added some heuristics in Kanrar–Chaki priority-based token-oriented algorithm in order to slow down the frequency with which priority of pending requests is increased. Performance evaluation results confirm the effectiveness of our approach when compared to both the original Kanrar–Chaki and Chang’s priority-based algorithms.},
  doi      = {https://doi.org/10.1016/j.jpdc.2015.04.002},
  keywords = {Distributed system, Mutual exclusion, Priority, Algorithm},
  url      = {https://www.sciencedirect.com/science/article/pii/S0743731515000659},
}

@Article{Kanrar2010,
  author    = {Kanrar, Sukendu and Chaki, Nabendu},
  title     = {FAPP: A New Fairness Algorithm for Priority Process Mutual Exclusion in Distributed Systems},
  journal   = {Journal of Networks},
  year      = {2010},
  volume    = {5},
  number    = {1},
  month     = jan,
  issn      = {1796-2056},
  doi       = {10.4304/jnw.5.1.11-18},
  publisher = {Academy Publisher},
  url       = {http://dx.doi.org/10.4304/jnw.5.1.11-18},
}

@Article{Chang1994,
  author  = {Chang, Ye-In},
  title   = {Design of mutual exclusion algorithms for real-time distributed systems},
  journal = {J. Inf. Sci. Eng.},
  year    = {1994},
  volume  = {11},
  number  = {4},
  pages   = {527--548},
}

@InProceedings{Georgakopoulos1991,
  author    = {Georgakopoulos, D. and Rusinkiewicz, M. and Sheth, A.},
  title     = {On serializability of multidatabase transactions through forced local conflicts},
  booktitle = {Proceedings. Seventh International Conference on Data Engineering},
  year      = {1991},
  publisher = {IEEE Comput. Soc. Press},
  doi       = {10.1109/icde.1991.131479},
  url       = {http://dx.doi.org/10.1109/ICDE.1991.131479},
}

@InProceedings{Fle1982,
  author    = {Fle, M. P. and Roucairol, G.},
  title     = {On Serializability of Iterated Transactions},
  booktitle = {Proceedings of the First ACM SIGACT-SIGOPS Symposium on Principles of Distributed Computing},
  year      = {1982},
  series    = {PODC '82},
  pages     = {194–200},
  address   = {New York, NY, USA},
  publisher = {Association for Computing Machinery},
  abstract  = {In the literature on serializability (see [1]), a transaction is considered to be a finite sequence of operations. As a step towards the handling of more complex evolutions of processes, we assume in this paper that the sequence of operations performed by a transaction may be infinitely often repeated as for instance, might behave a pre-existing service process in an operating system. (Remark that the classical “critical section” problem can be viewed as a particular case of the serializability problem). Therefore, a behaviour of a system of transactions will be understood herein as an infinite behaviour.The equivalence which is generally used is such that two behaviours are said equivalent if the relative ordering of so-called conflicting operations is the same in both behaviours ; this notion of conflict being deduced from the way operations of different transactions access to shared data. If we call correct a behaviour which is equivalent in that sense to a sequential behaviour, we shall say (section 3) that a system of transactions is maximally concurrent if its set of possible behaviours is the set of correct ones. In section 4, we characterize a maximally concurrent system by a property of the prefixes of its behaviours. This property extends a result from Papadimitriou [6] and allows us to point out that the classical “two phases locking” synchronization algorithm [2] does not guaranty maximal concurrency. This property will also be used in section 5 in order to show that the language of the prefixes of behaviours of a maximally concurrent system is a regular language (main result). It means that the serializability of iterated transactions can be finitely controlled. In section 6, we consider the problem of fair serializability. We describe a synchronization algorithm allowing only those behaviours which are correct and fair (every transaction is performed infinitely often). In that case, this algorithm needs an unbounded amount of memory. The use of this algorithm is illustrated in order to provide a starvation-free synchronization to the well-known five philosophers problem.},
  doi       = {10.1145/800220.806697},
  isbn      = {0897910818},
  location  = {Ottawa, Canada},
  numpages  = {7},
  url       = {https://doi.org/10.1145/800220.806697},
}

@Article{Papadimitriou1979,
  author     = {Papadimitriou, Christos H.},
  title      = {The Serializability of Concurrent Database Updates},
  journal    = {J. ACM},
  year       = {1979},
  volume     = {26},
  number     = {4},
  pages      = {631–653},
  month      = {oct},
  issn       = {0004-5411},
  address    = {New York, NY, USA},
  doi        = {10.1145/322154.322158},
  issue_date = {Oct. 1979},
  numpages   = {23},
  publisher  = {Association for Computing Machinery},
  url        = {https://doi.org/10.1145/322154.322158},
}

@Article{Busi2001,
  author   = {Nadia Busi and Gianluigi Zavattaro},
  title    = {On the Serializability of Transactions in JavaSpaces},
  journal  = {Electronic Notes in Theoretical Computer Science},
  year     = {2001},
  volume   = {54},
  pages    = {92-105},
  issn     = {1571-0661},
  note     = {ConCoord: International Workshop on Concurrency and Coordination (Workshop associated to the 13th Lipari School)},
  abstract = {JavaSpaces is a coordination infrastructure inspired by the shared dataspace model: processes interact by introducing, consuming, and testing for the presence/absence of data in a common repository. Besides these traditional operations, an event based coordination mechanism is considered which allows for the notification of the introduction of new instances of data in the repository. JavaSpaces also supports transactions: multiple coordination operations can be grouped into a bundle that acts as a single atomic operation. In this paper we adopt serializability as a criterion to evaluate the correctness of the JavaSpaces transaction semantics: we prove that serializability is satisfied only if we restrict to output, input, and read operations. On the other hand, in the presence of either test for absence or event notification, serializability is not satisfied; we propose an alternative semantics and we prove that it supports serializability.},
  doi      = {https://doi.org/10.1016/S1571-0661(04)00238-5},
  url      = {https://www.sciencedirect.com/science/article/pii/S1571066104002385},
}

@InProceedings{Li2012,
  author    = {Li, Cheng and Porto, Daniel and Clement, Allen and Gehrke, Johannes and Pregui\c{c}a, Nuno and Rodrigues, Rodrigo},
  title     = {Making Geo-Replicated Systems Fast as Possible, Consistent When Necessary},
  booktitle = {Proceedings of the 10th USENIX Conference on Operating Systems Design and Implementation},
  year      = {2012},
  series    = {OSDI'12},
  pages     = {265–278},
  address   = {USA},
  publisher = {USENIX Association},
  abstract  = {Online services distribute and replicate state across geographically diverse data centers and direct user requests to the closest or least loaded site. While effectively ensuring low latency responses, this approach is at odds with maintaining cross-site consistency. We make three contributions to address this tension. First, we propose RedBlue consistency, which enables blue operations to be fast (and eventually consistent) while the remaining red operations are strongly consistent (and slow). Second, to make use of fast operation whenever possible and only resort to strong consistency when needed, we identify conditions delineating when operations can be blue and must be red. Third, we introduce a method that increases the space of potential blue operations by breaking them into separate generator and shadow phases. We built a coordination infrastructure called Gemini that offers RedBlue consistency, and we report on our experience modifying the TPC-W and RUBiS benchmarks and an online social network to use Gemini. Our experimental results show that RedBlue consistency provides substantial performance gains without sacrificing consistency.},
  isbn      = {9781931971966},
  location  = {Hollywood, CA, USA},
  numpages  = {14},
}

@Article{Castaneda2018,
  author    = {Castañeda, Armando and Rajsbaum, Sergio and Roy, Matthieu},
  title     = {Convergence and covering on graphs for wait-free robots},
  journal   = {Journal of the Brazilian Computer Society},
  year      = {2018},
  volume    = {24},
  number    = {1},
  month     = jan,
  issn      = {1678-4804},
  doi       = {10.1186/s13173-017-0065-8},
  publisher = {Sociedade Brasileira de Computacao - SB},
  url       = {http://dx.doi.org/10.1186/s13173-017-0065-8},
}

@InProceedings{Gupta2023,
  author    = {Arya Tanmay Gupta and Sandeep S Kulkarni},
  title     = {Inducing Lattices in Non-Lattice-Linear Problems},
  booktitle = {42nd International Symposium on Reliable Distributed Systems},
  year      = {2023},
  editor    = {Mohammed Erradi and Rachid Guerraoui},
  publisher = {IEEE},
}

@article{Gupta2023a,
  author        = {Arya Tanmay Gupta and Sandeep S Kulkarni},
  title         = {Lattice Linearity in Assembling Myopic Robots on an Infinite Triangular Grid},
  year          = {2023},
  archiveprefix = {arXiv},
  journal       = {CoRR/2307.13080},
  primaryclass  = {cs.DC},
}

@Comment{jabref-meta: databaseType:bibtex;}
