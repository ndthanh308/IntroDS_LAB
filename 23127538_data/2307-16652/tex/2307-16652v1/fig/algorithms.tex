\section{PaLD Algorithms Design.}
\label{sec:alg-design}

In order to compute the cohesion of all pairs of points, we can again use the law of total probability to partition $c_{xz}$ across all points $y\in {\cal S}$:
\begin{equation*}
    c_{xz} = \sum_{y\in \SSS} \Pr\left[Y = y \; \tAnd \; Z = z \; \tAnd \; d_{Zx} < d_{ZY} \right].
\end{equation*}
Using the law of conditional probability, this becomes
\begin{multline*}
     c_{xz} = \sum_{y\in \SSS} \Pr\left[d_{zx} < d_{zy} \; | \; Y = y, Z = z \right] \\
     \cdot \Pr\left[Z=z \; | \; Y = y\right] \cdot \Pr\left[Y=y\right]
\end{multline*}
which implies
\begin{equation}
\label{eq:fxz}
c_{xz} = \sum_{y\in \SSS} \indic{d_{xz} \leq d_{yz}} \cdot \frac{\indic{d_{xz}\leq d_{xy}}}{u_{xy}} \cdot \frac{1}{n-1}
 = \frac{1}{n-1} \sum_{y\in \SSS} g_{xyz},
\end{equation}
where $\indic{}$ is the indicator function and we have defined
\begin{equation}
\label{eq:gxyz}
    g_{xyz} = \indic{d_{xz} \leq d_{yz}} \cdot \indic{d_{xz}\leq d_{xy}} \, / \, u_{xy}.
\end{equation}

The task is then to compute $g_{xyz}$ for all $x,y,z\in\SSS$, a total of $n^3$ values.
However, only approximately 1/3rd of the $g_{xyz}$ values are nonzero because, given three points with unique pairwise distance values, only one pair has the minimum distance.
For example, given points $x,y,z\in\SSS$, if $x$ and $y$ are the closest pair, then $g_{xzy}$ and $g_{yzx}$ are nonzero, but $g_{xyz}=g_{yxz}=g_{zxy}=g_{zyz}=0$.
To compute the nonzero values $g_{xzy}$ and $g_{yzx}$, we need the values $u_{xz}$ and $u_{yz}$.
The size of any given local focus can be computed as $u_{xy} = \sum_{z\in\SSS} \indic{d_{xz} \leq d_{xy} \,\Or d_{yz} \leq d_{xy}}.$

We consider two algorithmic approaches to computing the local focus sizes and the final cohesion matrix that take advantage of the symmetry.
The first approach, which we call the \emph{pairwise algorithm}, considers all $\binom{n}{2}$ pairs of points, and for each pair, first determines the size of its local focus and then computes contributions to the cohesion matrix from all points within the local focus.
The second approach, which we call the \emph{triplet algorithm}, considers all $\binom{n}{3}$ triplets of points, and for each triplet, determines which of the two local foci the triplet contributes to and then (in a second pass) determines which of the two cohesion matrix entries the triplet contributes to.
We analyze and compare the two algorithms in \cref{sec:analysis}.

\subsection{Pairwise Algorithm.}

The entry-wise pairwise algorithm is given as \cref{alg:pairwise}.
The idea is to perform the computations for each pair of points $x$ and $y$.
To compute $g_{xyz}$ for each third point $z$, we first must compute the size of the local focus, $u_{xy}$.
This requires a pass over all $n$ points with two comparisons and a possible integer increment.
A second pass over all $n$ points determines, for points in the local focus, which of the points $x$ or $y$ the third point supports, and the cohesion matrix is updated accordingly.
Note that only one local focus size need be stored at any one time, requiring minimal temporary memory.

\begin{algorithm}[t]
\footnotesize
    \caption{Pairwise Sequential Algorithm}
    \label{alg:pairwise}
    \begin{algorithmic}[1]
    \Require $D \in \mathbb{R}^{n \times n},$~Distance Matrix
    \Ensure $C \in \mathbb{R}^{n \times n},$~Cohesion Matrix
    \For{$x = 1$ \tTo  $n - 1$}
        \For{$y = x + 1$ \tTo $n$}
            % \State{// Compute size of local focus for $x,y$ pair}
            \State{$u_{xy} = 0$}
            \For{$z = 1$ \tTo $n$}
                \If{$d_{xz} < d_{xy}$ \Or $d_{yz} < d_{xy}$}
                    \State{$u_{xy} = u_{xy}+1$}
                \EndIf
            \EndFor
    % \State{// Update cohesion matrix for $x,y$ pair}
        \For{$z = 1$ \tTo $n$}
            \If{$d_{xz} < d_{xy}$ \Or $d_{yz} < d_{xy}$}
                \If{$d_{xz} < d_{yz}$}
                    \State{$c_{xz} = c_{xz} + 1/u_{xy}$}
                \Else
                    \State{$c_{yz} = c_{yz} + 1/u_{xy}$}
                \EndIf
            \EndIf

        \EndFor
        \EndFor
    \EndFor
\end{algorithmic}
\end{algorithm}

To improve the cache locality, we block the algorithm as follows: instead of considering only one pair of points, we consider two sets of points $\mathcal{X}$ and $\mathcal{Y}$ and consider all the pairs $(x,y)\in \mathcal{X} \times \mathcal{Y}$.
In this way, we obtain locality on the distance matrix block $D_{\mathcal{X},\mathcal{Y}}$ and a temporary block of local focus sizes $U_{\mathcal{X},\mathcal{Y}}$.

As in the entry-wise algorithm, the blocked algorithm makes two passes over all $n$ third points.
The first pass computes $U_{\mathcal{X},\mathcal{Y}}$, a local focus size block, and the second pass makes updates to the cohesion matrix.

% Figure environment removed

\Cref{fig:pairwise_dependency} shows the dependencies among the distance, local focus, and cohesion matrices for the blocked ($b = 4$) pairwise algorithm.
The red blocks correspond to the entries of the distance matrix that are read and re-used while processing the pair of blocks $\mathcal{X}$ and $\mathcal{Y}$ (the pattern is the same in both passes, though $D_{\mathcal{X},\mathcal{Y}}$ remains in fast memory through both passes.
The orange blocks represent entries of the local focus matrix which are computed in fast memory during the first pass and used during the second pass.
The green blocks of the cohesion matrix are re-used during the second pass before being written back to slow memory.
The blue blocks represent dependencies between entries of $D, U,$ and $C$ for one entry-wise iteration.


\subsection{Triplet Algorithm.}

The entry-wise triplet algorithm is given as \cref{alg:triplet}.
In \Cref{alg:pairwise}, if a third point $z$ is in the local focus of $x$ and $y$ and is closer to $x$, then only the support of $z$ for $x$ is recorded in $C$ ($c_{xz}$ is updated).
If $z$ is closer to $x$ in a focus with $y$, then $x$ is closer to $z$ in its focus with $y$.
The idea of the triplet algorithm is to minimize the number of distance comparisons.
By performing all the updates for each triplet of points, we can avoid redundant comparisons.
However, this method requires that the local focus sizes are pre-computed for all pairs of points within the triplet, so it requires more temporary memory.
\begin{algorithm}[t]
\footnotesize
    \caption{Triplet Sequential Algorithm.}
    \label{alg:triplet}
    \begin{algorithmic}[1]
    \Require $D \in \mathbb{R}^{n \times n}$ Distance Matrix
    \Ensure $C \in \mathbb{R}^{n \times n}$ Cohesion Matrix
        % \State{// Compute matrix of local focus sizes $U$}
        \State{Initialize $U = \texttt{triu}(2*\texttt{ones}(n),1)$ }
        \For{$x = 1$ \tTo $n-1$}
            \For{$y = x + 1$ \tTo $n$}
                \For{$z = y + 1$ \tTo $n$}
                    \If{$d_{xy} < d_{xz}$ \tAnd $d_{xy} < d_{yz}$}
                        \State{// $x,y$ is closest pair}
                        \State $u_{xz} = u_{xz} + 1$
                        \State $u_{yz} = u_{yz} + 1$
                    \ElsIf{$ d_{xz} < d_{yz}$}
                        \State{// $x,z$ is closest pair}
                        \State $u_{xy} = u_{xy} + 1$
                        \State $u_{yz} = u_{yz} + 1$
                    \Else
                        \State{// $y,z$ is closest pair}
                        \State $u_{xy} = u_{xy} + 1$
                        \State $u_{xz} = u_{xz} + 1$
                    \EndIf
                \EndFor
            \EndFor
        \EndFor
        % \State{// Compute cohesion matrix $C$}
        \For{$x = 1$ \tTo $n-1$}
            \For{$y = x + 1$ \tTo $n$}
                \For{$z = y + 1$ \tTo $n$}
                    \If{$d_{xy} < d_{xz} $ \tAnd $ d_{xy} < d_{yz}$}
                        % \State{// $x,y$ is closest pair}
                        \State $c_{xy} = c_{xy} + 1/u_{xz}$
                        \State $c_{yx} = c_{yx} + 1/u_{yz}$
                    \ElsIf{$ d_{xz} < d_{yz}$}
                        % \State{// $x,z$ is closest pair}
                        \State $c_{xz} = c_{xz} + 1/u_{xy}$
                        \State $c_{zx} = c_{zx} + 1/u_{yz}$
                    \Else
                        % \State{// $y,z$ is closest pair}
                        \State $c_{yz} = c_{yz} + 1/u_{xy}$
                        \State $c_{zy} = c_{zy} + 1/u_{xz}$
                    \EndIf
                \EndFor
            \EndFor
        \EndFor
\end{algorithmic}
\end{algorithm}

We can also block the triplet algorithm to obtain better cache locality.
Instead of a single triplet of points, we consider three blocks $\mathcal{X},\mathcal{Y},\mathcal{Z}$ and all triplets $(x,y,z)\in \mathcal{X} \times \mathcal{Y} \times \mathcal{Z}$.
We obtain locality on cache blocks of all three matrices: distance, local focus, and cohesion.
Note that a first pass is required to compute the local focus matrix in its entirety, and then blocks of the local focus matrix are read from slow memory during the second pass as needed.

% Figure environment removed

\Cref{fig:triplet_dependency} illustrates the dependencies among the distance, local focus, and cohesion matrices for the (blocked) triplet algorithm.
In the first pass, the blocked triplet algorithm reads $3$ blocks from the distance matrix, corresponding to the triplet pairs: $(x,y), (x,z), (y,z)$, and writes to the corresponding $3$ blocks of the local focus matrix.
Note that the distance and local focus matrices are symmetric so only the upper triangular parts are required.
The cohesion matrix is not symmetric, thus in the second pass $6$ blocks must be updated by performing distance comparisons (by reading $D_{\mathcal{X},\mathcal{Y}}, D_{\mathcal{X},\mathcal{Z}}, D_{\mathcal{Y},\mathcal{Z}}$) and utilizing entries of the local focus matrix (by reading $U_{\mathcal{X},\mathcal{Y}}, U_{\mathcal{X},\mathcal{Z}}, U_{\mathcal{Y},\mathcal{Z}}$).

