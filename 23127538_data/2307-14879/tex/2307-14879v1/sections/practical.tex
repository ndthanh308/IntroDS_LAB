%!TEX root = ../main.tex

\section{Technical Considerations}
\label{sec:tech}
After we described the theoretical design in \Cref{sec:theory}, it is crucial to consider the technical challenges of \sysname to satisfy requirements \hyperref[req3:compatible]{R.3} and \hyperref[req4:minreq]{R.4}.
Therefore, this section will discuss key practical aspects to implement our theoretical design.
Note, we focus on available techniques or techniques currently in deployment, i.e., we will not address recent research approaches, as these might take many more years until ready for deployment.
Our focus is on techniques usable in a practical deployment now or in the near future.

\subsection{Wireless Communication Technology}
\label{sec:tech:lpwan}
As \sysname relies on a local network between gateways, this section discusses possible options for wireless communication technologies.
Fortunately, due to the prevalence of the Internet of Things (IoT), there have been many proposals and advancements in recent years to enable remote IoT devices to connect directly to the Internet or via a mesh network.
We will leverage these advancements for \sysname.

\setlength{\tabcolsep}{3.6pt}
\begin{table}[t]
    \centering
    \caption{Overview of long-range radio transmission technologies applicable to \sysname.}
    \label{tbl:lpwans}
    \begin{tabular}{llllc}
        \toprule
        Name & \parbox{\widthof{Maximum}}{Maximum\\Data\\Rate} & \parbox{\widthof{Range}}{Range\\(urban)} & \parbox{\widthof{Range}}{Range\\(rural)} & \parbox{\widthof{Unlicensed}}{Unlicensed\\Frequency\\Bands} \\ 
        \midrule

        \vspace{0.5em}
        LoRa Sub-GHz~\cite{foubert2020long} & \parbox{\widthof{50\,kbps (FSK)}}{27\,kbps\\50\,kbps (FSK)} &  5\,km & 15\,km & \ding{51} \\ \vspace{0.5em}
        LoRa 2.4\,GHz & \parbox{\widthof{1\,Mbps (FLRC)}}{250\,kbps\\1\,Mbps (FLRC)} & 1\,km & n/a & \ding{51} \\ \vspace{0.5em}
        LTE-M Cat-M1~\cite{ltem-aws} & \parbox{\widthof{4\,Mbps (Cat-M2)}}{1\,Mbps\\4\,Mbps (Cat-M2)} & 1\,km & 10\,km & \ding{55} \\ 
        NB-IoT Cat-NB2~\cite{mekki2019comparative} & 200\,kbps & 1\,km & 10\,km & \ding{55} \\
        DASH7~\cite{foubert2020long} & 166\,kbps & 5\,km & n/a & \ding{51} \\
        Weightless-W~\cite{foubert2020long} & 10\,Mbps & 5\,km & n/a & \ding{55} \\
        \bottomrule
    \end{tabular}
    \vspace{\tblvsp}
\end{table}
\setlength{\tabcolsep}{6pt}

\Cref{tbl:lpwans} shows an overview of the technologies we considered.
Note, this table is not comprehensive of all available technologies, as we carefully selected technologies we deem applicable to \sysname.
For example, while Sigfox is a mature wireless technology already deployed in many regions around the world, it only supports 100\,bps data rates~\cite{mekki2019comparative}, which is too slow to be meaningfully used to connect to traditional Internet services (violating requirement~\hyperref[req3:compatible]{R.3}).

One may also consider repurposing existing infrastructure, such as the cellular network for mobile Internet.
However, in a conflict, existing infrastructure (e.g., cell towers) is unreliable or may not be functional at all, making satellite Internet necessary in the first place.
In addition, repurposing this infrastructure for a disaster network is not feasible as cellular networks do not have mesh network capabilities and access to the hardware is limited.

For the \emph{Maximum Data Rate}, we also considered alternatives, like the Fast Long Range Communication (FLRC) for Lora 2.4\,GHz, which uses demodulation and error correction techniques for a significantly improved data rate~\cite{lora24chip}.
Further, the last column of \Cref{tbl:lpwans} shows if the respective technology uses unlicensed frequency bands.
For example, Lora supports a variety of different sub-GHz bands, which are publicly usable in the respective region, e.g., North America allocates different bands than Europe~\cite{mekki2019comparative}.
While the other technologies use licensed bands, we expect that legal restrictions play a lesser role in the settings applicable to \sysname or may even be officially lifted. 

\subsection{MTU Size Mismatch}
\label{sec:tech:mtu}
One technical hurdle with a significant practical impact is the Maximum Transmission Unit (MTU), which defines the maximum amount of bytes sent in a single network layer transaction.
Considering our scenario targeting the Internet, typically the MTU of Ethernet is used (1500\,bytes).
The hurdle arises when using a wireless communication technology, which only supports a smaller MTU.
For example, LoRa restricts the MTU to 255\,bytes, which leads to problems with Internet servers expecting a large MTU, such as extra negotiation steps for smaller messages and spurious retransmissions.
For example, in our preliminary tests using a small MTU, we saw significant delays with TLS handshakes, even to a point in which some servers simply declined the session entirely.
Another downside of a small MTU is the overhead of the headers, such as the IP and TCP protocols.
With a small MTU, the headers consume a significant share of the bandwidth.

Therefore, a mechanism is required to split Ethernet MTUs received by the client to fit them into, e.g., multiple LoRa frames for forwarding them over the local network.
These kinds of operations are usually implemented by the Operative System's (OS) kernel. An example of LPWAN is IEEE 802.15.4 (\textit{Low-rate Wireless Personal Area Network})~\cite{ieee_802_15_4} over IPv6, documented as 6LoWPAN in RFC 8930~\cite{6LoWPAN_RFC}, which specifies how to forward 6LoWPAN fragments over a multi-hop network.
The implementation is already available in the Linux Kernel~\cite{6LoWPAN_kernel} for IEEE 802.15.4 compliant devices.
This could benefit \sysname greatly, as it was demonstrated that a proper fragmentation strategy can lead to significant performance improvements~\cite{bruniaux2021defragmenting}.
Yet, not all wireless technologies fit this standard.
For example, there are discrete definitions of header compression and segmentation for LoRa in RFC 9011~\cite{LoRaWAN_compr_frag_RFC}; yet, there are no implementations so far. 

\subsection{Slow TCP Connections}
\label{sec:tech:tcp}

The Transmission Control Protocol (TCP) and how servers handle TCP sessions are usually optimized for fast and reliable connections nowadays, as this is the most common scenario. 
However, for \sysname this is not the case. 
Indeed, in our case, the connections are slow and potentially lossy, leading to problems with many TCP deployments.
The most relevant one is the way retransmissions are handled, as typical deployments are optimized to maximize data rates for fast connections.
One aspect is the Retransmit Timeout (RTO), which is typically set quite low, such that the server can react quickly to network congestion, which is also identified with timeouts.
If the acknowledgement for a packet is not received by the server in time, to optimize data rates for typical connections, the server will quickly do a retransmission.
This results in many duplicate, and thus, unnecessary retransmissions with slow connections called \emph{spurious} retransmissions, quickly saturating the connection.
Another problem to consider is the loss of packets, especially when using one of the wireless communication technologies (cf. \Cref{sec:tech:lpwan}).
For example, today's TCP deployments bundle the transmission of multiple resources over a single connection to achieve a form of concurrency.
However, when a packet is lost for one resource, this delays all of the resources, resulting in even more retransmissions.

Unfortunately, the most effective TCP settings to avoid these issues are controlled by the endpoints, such as retransmission timeouts or the used congestion control algorithm.
Thus, in \sysname, we cannot change these settings, as we can only influence the gateways.
An exception to this is the \texttt{txqueuelen} property for each network interface in Linux.
Settings this to very low values (e.g., 1) prevents the client to send many packets in a short time, which will exacerbate the mentioned retransmission problems.
Another setting to consider is setting TCP's window size, influencing how much data is bundled for each acknowledgment.
Setting this to a low value further helps to avoid retransmission problems.

Another approach to counteract these problems is optimizations for the used wireless communication technologies in a multi-hop setup.
A local retransmission scheme may be used among the gateways, essentially dealing with packet losses on the local gateway network level.
There are different strategies for such local retransmissions~\cite{she2009analytical}.
Handling retransmissions locally would circumvent many of the issues with TCP packet losses.

Furthermore, a more sustainable solution is being deployed at the time of writing and will likely be widely available in the near future.
QUIC~\cite{RFC9000} is a network protocol introduced by Google as a more performant and flexible alternative to TCP. 
Among other functionalities, it leverages UDP with merged handshakes, custom congestion controls, loss detection, and retransmission algorithms~\cite{RFC9002}.
This allows QUIC to handle slow connections with high latency with much better performance than TCP.
For example, Google published a large-scale performance study on QUIC, which showed that QUIC can improve latency by over 30\% compared to TCP with large round-trip-times in a common Internet scenario~\cite{langley2017quic}.
Thus, QUIC would likely have a significant performance impact for our purposes.

Practically speaking, QUIC is already a reality, as many companies are already adopting it.
For example, the company Meta already deployed it for most of its applications~\cite{metaquic}.

\subsection{Changing Routing Paths}
\label{sec:tech:routes}

As described in \Cref{sec:theory}, \sysname needs to reroute packets through different nodes. Typically, TCP sessions stay alive until the end of the communication and it is not possible to dynamically change the stream's endpoints, i.e., the source or destination IP. 
However, changing the output gateway implies a change in the endpoint IP; thus, we need to adopt a strategy for establishing a new endpoint.

A possible way for achieving this goal is using the Reset (RST) flag in the TCP header.
When this flag is set, the receiver will close the TCP session immediately. 
The use of the RST flag is also used for malicious applications, such as the so-called ``TCP Reset Attack" ~\cite{watson2004slipping}.
Here an attacker forges TCP packets with a set RST flag in order to maliciously interrupt or disturb the Internet connection. 
However, for our purposes, the origin gateway can leverage the RST flag to stop a TCP session and force the endpoints (i.e., the client and the Internet server) to start a new session with a different endpoint, i.e., another output gateway selected by the origin.
Indeed, for \sysname, this comes with the additional overhead of establishing a new TCP session regularly.
Thus, when using this approach the \timeout parameter should not be set too low.

However, this is exactly what the Multipath TCP (MPTCP) protocol sets out to do in a more elegant way.
The protocol was originally documented in 2013 by RFC 6824 ~\cite{RFC_multipath_tcp_original} and later updated with RFC 8684 ~\cite{RFC_multipath_tcp}.
This protocol allows a single TCP session to take different routing paths and use different endpoints without interruption.
As widespread support is relevant, MPTCP is already implemented in the Linux Kernel ~\cite{multipath_tcp_kernel} and, e.g., Apple's iOS uses it to be able to quickly switch between a WiFi and cellular connection~\cite{appleMPTCP}.

Another elegant way is provided by the aforementioned QUIC protocol.
While there is also a multipath extension for it in the making~\cite{quicmultipath}, similar to MPTCP, the original QUIC protocol already supports \emph{Connection Migration}~\cite{RFC9000}.
Here, each session is assigned a connection ID, which allows the connection to survive endpoint address changes.

Furthermore, depending on the used underlying protocols for the local network, e.g., IPv4 or LoRaWAN, the client needs additional protection.
Namely, the output gateway should execute a Network Address Translation (NAT) on the connection, translating its own address to the origin.
Otherwise, the address of the origin gateway may leak, and thus, potentially reveal the client's geographic position.

\subsection{Node Discovery}
\label{sec:tech:discovery}

The local gateway network acts as a mesh network, and thus, needs protocols for discovering nodes and establishing routing tables for later network message routing.
For our purposes, a link state routing protocol works well.
While there are many different approaches to these types of protocols, we expect the local gateway network to only observe a limited degree of dynamics, as opposed to, e.g., a mobile ad-hoc network.
The latter typically requires more advanced techniques for routing and node discovery.
Thus, the Optimized Link State Routing Protocol, defined in RFC 3626~\cite{RFC_link_state_routing_v1}, or its successor~\cite{RFC_link_state_routing_v2} is sufficient for our approach.
Here, neighbors exchange information about their neighbors to build simple routing tables, which show the shortest path to any node in the network.

Further, there are also protocols to dynamically optimize the radio settings between nodes.
For example, there is the \emph{Adaptive Data Rate} optimization between LoRa nodes~\cite{kufakunesu2020survey}.
These protocols may be used to further optimize the data rate for the local gateway network.

\subsection{Leakage in Presence of Malicious Nodes}
\label{sec:tech:malicious}
In the mesh and wireless sensor network research area for location privacy (we give an overview of them in \Cref{sec:rw}), there are approaches additionally considering defenses against compromised nodes~\cite{conti2013providing}.
Many approaches like \emph{Network Coding} and \emph{In network location anonymization} are designed to protect against an attacker with a \emph{global} view, which is infeasible in our discussed scenario (cf. \Cref{sec:adv_model}).
These approaches introduce many new requirements and overheads, making them inapplicable for our scenario.
However, approaches considering a \emph{local} adversary are not applicable due to their assumptions.
One type of approach assumes a hierarchical structure among the nodes in the network, in which certain nodes are trusted and cannot be compromised~\cite{el2010hyberloc,el2009hidden,kazatzopoulos2006ihide}.
Due to the nature of our targeted scenario, assuming only some gateways to be trusted is not practical in \sysname.
A different approach is to use end-to-end encryption between source and destination, such that a potentially compromised intermediary node cannot know the endpoints of a message~\cite{sheu2008anonymous}.
However, this requires that all possible endpoint pairs have pre-shared keys deployed, which is infeasible in our scenario.
Another approach can only hide the destination of the connection, not the source~\cite{hong2005effective}.
Yet, protecting the source, i.e., the origin gateway, is the main goal of \sysname.
A different approach protects against compromised nodes, yet relies on the assumption that intermediary nodes cannot be too close to the source~\cite{lightfoot2010preserving}.
We deem this assumption too strict to be practical for \sysname.

The main concern for \sysname regarding compromises is malicious intermediary gateways, which can extract the origin gateway and thus target the client.
Onion routing~\cite{reed1998anonymous} is an effective method to hide the origin gateway from compromised intermediaries. 
No intermediary hop can know its position in the path, as a packet's amount of onion shells is unknown. This is due to \sysname randomly choosing a path length between 0 and \maxhops.
Additionally, onion routing can also be used in wireless networks~\cite{el2018preserving}, where, when mapped to our approach, no node (except for the first and last) is able to learn the source of a message.