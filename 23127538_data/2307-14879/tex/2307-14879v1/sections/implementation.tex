%!TEX root = ../main.tex

\section{Prototype Implementation}
\label{sec:impl}
To demonstrate \sysname, we describe the implementation of our Proof of Concept in this section.
While we have shown advanced techniques in \Cref{sec:tech}, many of them lack either proper wide-ranging support or applicable implementations.
At this point in time, we consider the integration of these techniques as a significant engineering effort and out of scope for this research work.
Note, however, there is potential to significantly improve the practical performance of \sysname.
We will give justifications for the choice of the respective techniques in the following.

\paragraph{\emph{Scenario}}
For our prototype, we deployed five off-the-shelf consumer devices.
For the Internet connection, we deployed a Starlink dish~\cite{starlinkspecs} on the roof of our building.
We used three gateways deployed as Raspberry Pi 3 Model B+~\cite{rpi3b} (called \emph{RaspberryPi1}, \emph{RaspberryPi2} and \emph{RaspberryPi3}), equipped with a sub-GHz Lora SX1262 868M shield~\cite{lorashield}.
Finally, we used a simple Android phone as the client.
\emph{RaspberryPi3} acts as a proper gateway, as it is connected to the Starlink router, which is connected to the dish.
All Raspberry Pis are interconnected via Lora and provide a WiFi access point for the client to connect.
\Cref{fig:setup} shows the client connected to the origin's secure WiFi access point as well as the output gateway of our test setup.

% Figure environment removed

We have chosen to use sub-GHz Lora due to its use of unlicensed frequency bands.
Another aspect was the availability of development kits that include proper integration for both hardware (e.g., connection to our Raspberries) and software (e.g., driver).
Note, we have also evaluated using the Lora 2.4\,GHz shield SX1280Z3DSFGW1~\cite{lora24kit}; yet, we found that the provided implementation by the manufacturer\footnote{\url{https://github.com/Lora-net/gateway_2g4_hal}} is impractical, as it has limitations that severely limit the effective data rates, even below the Lora sub-GHz shield mentioned above.
For example, the implementation demands a 50\,ms sleep after each packet is sent, meaning a 1500\,bytes MTU split into 7 Lora packets already implies a 350\,ms delay before considering the actual transmission time.

\paragraph{\emph{Implementation}}
To send IP packets over LoRa, we utilize the open source software \texttt{tncattach}\footnote{\url{https://github.com/markqvist/tncattach}} which creates and sets up network interfaces to translate IP to LoRa and back. Unfortunately, the implementation has no support for packet fragmentation and reassembly, and therefore, only utilizes the maximum LoRa packet size (236\,bytes excluding header overhead), leading to the problem discussed in \Cref{sec:tech:mtu}. 
To speed up the translation (and avoid package retransmissions) between Ethernet (typical MTU of 1500\,bytes) and LoRa, we added simple fragmentation support to \texttt{tncattach}.
The more advanced techniques for fragmentation and header compression implemented in the Linux kernel~\cite{6LoWPAN_kernel} are not applicable to LoRa, and the LoRa-specific specification~\cite{LoRaWAN_compr_frag_RFC} has no implementation.

In terms of routing, we pre-deploy our routing tables for simplicity, as opposed to implementing an advanced protocol, as described in \Cref{sec:tech:routes}.
For example, \emph{RaspberryPi1} sets up a Wi-Fi Access Point with its own subnet and forwards all packages to the LoRa interface using another subnet utilizing NAT. \emph{RaspberryPi2} receives these packets and forwards them to \emph{RaspberryPi3}. \emph{RaspberryPi3} is then forwarding them to the Starlink router connected via Ethernet, utilizing NAT again. By providing every device its own static IP address, the operating system takes over tasks such as device discovery and routing.

As the origin gateway, \emph{RaspberryPi1} is in charge of setting up routes for the client's traffic to keep track of the duration of each link. As described in \Cref{sec:tech:routes}, we chose to break TCP connections using a Reset Attack.
We utilized \texttt{scapy}\footnote{\url{https://scapy.net/}} to listen to TCP packets traveling on \emph{RaspberryPi1's} interfaces. As the WiFi Access Point utilizes DHCP, a list of connected devices is known, including the connection time; thus, we can listen to established TCP connections of these devices using a packet filter. If a connection is kept alive for too long (i.e., longer than \timeout), the origin gateway creates a TCP packet with a set RST flag and injects it into the packet flow in both directions, killing the connection. Afterwards, the origin can establish a new route for this client.

Further, to counteract the TCP retransmission problems outlined in \Cref{sec:tech:tcp}, we set the \texttt{txqueuelen} to 1 and TCP's TX buffer to exactly one packet.
This mitigated many spurious retransmissions created because of delayed ACKs.
