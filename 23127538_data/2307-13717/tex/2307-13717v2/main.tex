\documentclass[10pt,conference]{IEEEtran}
%\documentclass[10pt,journal]{IEEEtran}
\IEEEoverridecommandlockouts


\usepackage[english]{babel}
%math
%\usepackage{geometry}
\usepackage{amsmath,amsfonts,stmaryrd}
\usepackage{amssymb}
%\usepackage{xcolor}
\usepackage{extarrows}
\usepackage{todonotes}
\usepackage{bm}
\usepackage{caption}
\usepackage{paralist}
\usepackage{float}
%\usepackage{times}
\usepackage{url}
%\usepackage{natbib}
%\usepackage[subtle]{savetrees}
%\usepackage[moderate]{savetrees}
%\usepackage[extreme]{savetrees}
\usepackage{booktabs} % For formal tables

%tikz -------------------------------------
\usepackage{tikz}
\usetikzlibrary{shapes}
\newcommand{\f}{ \draw[->,>=latex]}
\usetikzlibrary{decorations.markings}
\usepackage{tkz-base,tkz-fct}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
%------------------------------------------

%cryptocode
\usepackage{cryptocode}

%list
\usepackage{enumitem}

%sout
\usepackage[normalem]{ulem}

%todo
%\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%\let\svtodo\todo\renewcommand\todo[1]{\svtodo[inline]{#1}}

% %for dashed line in tabular
% \usepackage{arydshln}
% \usepackage{pifont}
% \usepackage{verbatim}
\usepackage{hyperref}
\usepackage{multirow}
% \usepackage{chngpage}
% \usepackage{lipsum}
% \usepackage{booktabs}

\usepackage{tabularx}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}


% Type macros:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\party}[1]{\ensuremath{\mathit{#1}}}  % Parties are just in math font
\newcommand{\poracle}[2]{\ensuremath{\pi_{\myuser{#1}}^{\myuser{#2}}}} % Party oracles. Lower index for party, upper index for session number

\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\binset}[1]{\ensuremath{\{0,1\}^{#1} }}
\newcommand{\mystate}[2]{\ensuremath{\msg{st}_{\mathsf{#1}}^{#2}}} % Party oracles. Lower index for session number, upper index for party (type)

\newcommand{\myphase}{\ensuremath{\mathsf{phase}}}

\newcommand{\msg}[1]{\ensuremath{\mathsf{#1}}} % Protocol messages are in SF
\providecommand{\primitive}[1]{\ensuremath{\textnormal{#1}}} % primitives are in normal font

\newcommand{\alg}[1]{\ensuremath{\mathtt{a{#1}}}} % algorithms are in TT
\newcommand{\oracle}[1]{\ensuremath{\mathsf{o{#1}}}}

\newcommand{\makett}[1]{\ensuremath{\mathtt{{#1}}}} % algorithms are in TT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Parties:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myparty}{\party{P}}

\newcommand{\myuser}[1]{\party{#1}}
\newcommand{\mysu}{\party{\hat{S}}}


\newcommand{\myalice}{\party{A}}
\newcommand{\mybob}{\party{B}}
\newcommand{\myA}{\myalice}
\newcommand{\myB}{\mybob}

\newcommand{\id}{\ensuremath{\mathsf{ID}}}
\newcommand{\myid}[1]{\ensuremath{{\myuser{#1}}}}
\newcommand{\idp}{\ensuremath{{P} }}
\newcommand{\idq}{\ensuremath{{Q} }}
\newcommand{\elechat}{\ensuremath{\poracle{P}{Q}}}
\newcommand{\aux}{\ensuremath{\mathsf {AD}}}


\newcommand{\myP}{\ensuremath{\party{P}}}
\newcommand{\myQ}{\ensuremath{\party{Q}}}
\newcommand{\myR}{\ensuremath{{\party{R}[s]}}}
\newcommand{\myS}{\ensuremath{{\party{S}[s]}}}

\newcommand{\PARTIES}{\set{P}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Attributes:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\mystage}{\ensuremath{\mathsf{stages}}}
\newcommand{\pstage}[2]{\ensuremath{\poracle{#1}{#2}.\mystage}}

\newcommand{\ptau}[2]{\ensuremath{\poracle{#1}{#2}.T}}
\newcommand{\annosent}{\ensuremath{\mathsf{SentM}}}
\newcommand{\annorec}{\ensuremath{\mathsf{RecM}}}

\newcommand{\ptaurec}[2]{\ensuremath{\ptau{#1}{#2}_{\annorec}}}
\newcommand{\ptausent}[2]{\ensuremath{\ptau{#1}{#2}_{\annosent}}}
\newcommand{\pastptau}[3]{\ensuremath{\ptau{#1}{#2}[#3]}}


\newcommand{\freshbit}[2]{\ensuremath{\poracle{#1}{#2}.\phi}}
\newcommand{\statusbit}[2]{\ensuremath{\poracle{#1}{#2}.{\sf status}}}

\newcommand{\bitreject}{\ensuremath{0}}
\newcommand{\bitaccept}{\ensuremath{1}}
\newcommand{\bitindec}{\ensuremath{\bot}}
\newcommand{\testbit}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{b}[#3]}}
\newcommand{\authbit}[2]{\ensuremath{\poracle{#1}{#2}.\alpha}}
\newcommand{\prole}[2]{\ensuremath{\poracle{#1}{#2}.\msg{role}}}
\newcommand{\roleinit}{\ensuremath{\texttt{Initiator}}}
\newcommand{\roleresp}{\ensuremath{\texttt{Responder}}}
\newcommand{\myrole}{\textnormal{\ensuremath{\texttt{role}}}}

\newcommand{\pastauthbit}[3]{\ensuremath{\poracle{#1}{#2}.\alpha[#3]}}

\newcommand{\pid}{\ensuremath{\mathsf{pid}}}
\newcommand{\sid}{\ensuremath{\mathsf{sid}}}

\newcommand{\psid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{sid}}}
\newcommand{\ppid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{pid}}}

\newcommand{\pastpstate}[3]{\ensuremath{\poracle{#1}{#2}.[#3]}}

\newcommand{\nbparties}{\ensuremath{\mathsf{n}_\PARTIES}}

\newcommand{\qtype}{\ensuremath{\mathsf{q.type}}}
\newcommand{\qinput}{\ensuremath{\mathsf{q.input}}}
\newcommand{\qresp}{\ensuremath{\mathsf{q.rsp}}}

\newcommand{\prchp}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{rchpk}[#3]}} % the public rch key of stage #3 for #1
\newcommand{\pfrec}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{rec}}}



%=====================================
% SAID
%=======================================

\newcommand{\said}{\textsf{SAID}}
\newcommand{\imam}{\textsf{iMAM}}
\newcommand{\SAIDmsk}{\ensuremath{\msg{msk}}}
\newcommand{\SAIDrchk}{\ensuremath{\mathsf{rchk}}}
\newcommand{\SAIDrchpk}{\ensuremath{\mathsf{rchpk}}}
\newcommand{\SAIDmsg}{\ensuremath{\mathsf{M}}}
\newcommand{\SAIDct}{\ensuremath{\mathsf{C}}}
\newcommand{\KDC}{\ensuremath{{KDC}}}


%=====================================
% SCEKE
%=======================================

\newcommand{\sceke}{\textsf{SCEKE}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Keys:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\sk}{\msg{sk}}
\newcommand{\pk}{\msg{pk}}
\newcommand{\ks}{\msg{K}}
\newcommand{\ipk}[1]{\ensuremath{\mathsf{ipk}_{\myuser{#1}}}}
\newcommand{\prek}[1]{\ensuremath{\mathsf{prek}_{\myuser{#1}}}}
\newcommand{\prepk}[1]{\ensuremath{\mathsf{prepk}_{\myuser{#1}}}}
\newcommand{\ephpk}[1]{\ensuremath{\mathsf{ephpk}_{\myuser{#1}}}}
\newcommand{\ephk}[1]{\ensuremath{\mathsf{ephk}_{\myuser{#1}}}}

\newcommand{\epk}[1]{\ensuremath{\mathsf{Epk}_{\myuser{#1}}}}
\newcommand{\esk}[1]{\ensuremath{\mathsf{ek}_{\myuser{#1}}}}


\newcommand{\ik}[1]{\ensuremath{\mathsf{ik}_{\myuser{#1}}}}
\newcommand{\presk}[1]{\ensuremath{\mathsf{presk}_{\myuser{#1}}}}
\newcommand{\ephsk}[2]{\ensuremath{\mathsf{ephsk}_{\myuser{#1}}^{#2}}}

\newcommand{\sidsk}[2]{\ensuremath{\mathsf{sidsk}_{\myuser{#1}}^{#2}}}
\newcommand{\sidpk}[2]{\ensuremath{\mathsf{sidpk}_{\myuser{#1}}^{#2}}}


\newcommand{\sidcsk}[2]{\ensuremath{\myuser{#1}.X\sid}}
\newcommand{\sidcsgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.X\textsf{stage}}}
\newcommand{\sidssgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.\mathtt{1}\textsf{stage}}}


\newcommand{\currentck}[2]{\ensuremath{\poracle{#1}{#2}.\msg{bk}}}
\providecommand{\currentmk}[2]{\ensuremath{ \poracle{#1}{#2}.k[s]}}
\providecommand{\currentrk}[2]{\ensuremath{ \poracle{#1}{#2}.\rk{s}}}

\newcommand{\pastck}[3]{\ensuremath{\poracle{#1}{#2}.\msg{ck}[{#3}]}}

\newcommand{\msgk}[3]{\ensuremath{\myuser{#1}.\mathsf{k}^{{#2},{#3}}}}

\newcommand{\msk}{\ensuremath{\msg{msk}}}
%\newcommand{\msk}{\ensuremath{\msg{msk}}}
\newcommand{\mpk}{\ensuremath{\msg{mpk}}}


\newcommand{\rchk}[2]{\ensuremath{\mathsf{rchk}_{\myuser{#1}}^{#2}}}
\newcommand{\rchpk}[2]{\ensuremath{\mathsf{Rchpk}_{\myuser{#1}}^{#2}}}
%super ratchet keys
\newcommand{\RCHK}[2]{\ensuremath{\mathsf{t}^{\myuser{#1}}_{#2}}}
\newcommand{\RCHPK}[2]{\ensuremath{\mathsf{T}^{\myuser{#1}}_{#2}}}

\newcommand{\skm}[1]{\ensuremath{\mathsf{SKM}_{\myuser{#1}}}}
\newcommand{\pkm}[1]{\ensuremath{\mathsf{PKM}_{\myuser{#1}}}}

\newcommand{\ski}[1]{sk_{#1}}
\newcommand{\pki}[1]{pk_{#1}}

\newcommand{\rk}[1]{\ensuremath{\mathsf{rk}_{#1}}}
\newcommand{\ck}[2]{\ensuremath{\mathsf{ck}_{\myuser{#1}}^{#2}}}
\newcommand{\tagk}[1]{\ensuremath{\mathsf{tag}^{#1}}}
\newcommand{\mk}[2]{\ensuremath{\mathsf{mk}_{\myuser{#1}}^{#2}}}

\newcommand{\expo}[2]{\ensuremath{\mathsf{(#1)}^{#2}}}

%key space
\newcommand{\kspace}{\ensuremath{\mathcal{K}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Protocol messages//variables:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\pastlist}{\set{D}}
%\newcommand{\rand}{\stackrel{{}_{\$}}{\leftarrow}}
\newcommand{\rand}{\ensuremath{\xleftarrow{\$}}}
\newcommand{\atrandom}{\ensuremath{{\leftarrow}_{\text{R}}}}
\newcommand{\expogroup}{\ensuremath{\mathbb{Z}_\myprime}}
\newcommand{\dhgroup}{\ensuremath{\mathbb{G}_\myprime}}

\newcommand{\ms}[1]{\ensuremath{\msg{ms}_{\myuser{#1}}}}
\newcommand{\ltstate}[1]{\ensuremath{\mathsf{lt.st}_{#1}}}
\newcommand{\ephstatek}{\ensuremath{\mathsf{var}}}
\newcommand{\keytypes}{\ensuremath{\mathsf{ktypes}}}
\newcommand{\keyset}{\ensuremath{\mathsf{key.set}}}
\newcommand{\ephstateK}{\mathcal{V}}
\newcommand{\ephstate}[2]{\ensuremath{\poracle{#1}{#2}.\ephstatek}}
\newcommand{\myad}{\ensuremath{\msg{AD}}}

\newcommand{\pastephstate}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{keys}[#3]}}

\newcommand{\pubstate}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{pub.st}}}

\newcommand{\emptystring}{\ensuremath{\varepsilon}}

\newcommand{\KDF}[1]{\ensuremath{{\mathsf{KDF}}_{#1}}}
\newcommand{\HKDF}[1]{\ensuremath{{\mathsf{HKDF}}_{#1}}}
\newcommand{\HMAC}{\ensuremath{\mathsf{HMAC}}}

\newcommand\extracteval[1]{\mathsf{HKDF}.\makett{Ext}(#1)}
\newcommand\expandeval[1]{\mathsf{HKDF}.\makett{XP}(#1)}
\newcommand{\pair}[1]{\ensuremath{e(#1)}}

\newcommand{\trsc}[3]{\poracle{#1}{#2}.Tr[#3]} % transcript for a stage #3, on user #1's side for the convo with #2


%=====================================
% Algorithms
%-=====================================

\newcommand{\fivegp}{\textsf{5GAKE}$_{3}$}
\newcommand{\myprimitive}{\texttt{SCEKE}}
\newcommand{\xnplus}{\texttt{XN}$^{+}$}

\newcommand{\algStart}{\ensuremath{\alg{Start}}}% CRISTINA
\newcommand{\algSend}{\ensuremath{\alg{Send}}}% CRISTINA
\newcommand{\algRKGen}{\ensuremath{\alg{RGen}}}
\newcommand{\algKGen}{\ensuremath{\alg{KeyGen}}}
\newcommand{\algSetup}{\ensuremath{\alg{Setup}}}
\newcommand{\protUReg}{\ensuremath{\Pi_{\mathtt{UReg}}}}
\newcommand{\protStart}{\ensuremath{\Pi_{\mathtt{Start}}}}


\newcommand{\algReceive}{\ensuremath{\alg{Receive}}}
\newcommand{\algextract}{\ensuremath{\makett{Extr}}}

\newcommand{\algttSetup}{\ensuremath{\makett{Setup}}}
\newcommand{\algSIGN}{\ensuremath{\makett{SIGN}}}
\newcommand{\algsign}{\ensuremath{\makett{Sign}}}
\newcommand{\algverify}{\ensuremath{\makett{Vrfy}}}
\newcommand{\algenc}[1]{\ensuremath{\makett{Enc}\left(#1\right)}}
\newcommand{\algdec}[1]{\ensuremath{\makett{Dec}\left(#1\right)}}
\newcommand{\algprf}{\ensuremath{\makett{PRF}}}
\newcommand{\algae}{\ensuremath{\makett{AE}}}
\newcommand{\algaead}{\ensuremath{\makett{AEAD}}}
\newcommand{\algaeadenc}{\ensuremath{\algaead \ensuremath{\makett{.Enc}}}}
\newcommand{\algaeaddec}{\ensuremath{\algaead \ensuremath{\makett{.Dec}}}}

\newcommand{\algmess}{\ensuremath{\makett{Message}}}
\newcommand{\algnonce}{\ensuremath{\makett{Nonce}}}
\newcommand{\algheader}{\ensuremath{\makett{Header}}}

\newcommand{\algmac}{\ensuremath{\makett{MAC}}}

\newcommand{\algaegen}{\ensuremath{\makett{Gen}}}
\newcommand{\algaeinit}{\ensuremath{\makett{AE.Init}}}
\newcommand{\algaedec}{\ensuremath{\makett{AE.Dec}}}
\newcommand{\algaeenc}{\ensuremath{\makett{AE.Enc}}}
\newcommand{\algaestE}{\ensuremath{\mathsf{st}_{\mathsf{E}}}}
\newcommand{\algaestD}{\ensuremath{\mathsf{st}_{\mathsf{D}}}}
\newcommand{\insync}{\ensuremath{\operatorname{\mathsf{in-sync}}}}

\newcommand{\algmain}{\ensuremath{\alg{Main.Exp}}}

\newcommand{\oEnc}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDec}{\ensuremath{\oracle{ADec}}}
\newcommand{\oRDec}{\ensuremath{\oracle{RoR.ADec}}}
\newcommand{\oMess}{\ensuremath{\oracle{Messaging}}}
\newcommand{\oSign}{\ensuremath{\oracle{Sign}}}

\newcommand{\algcommit}{\ensuremath{\makett{Commit}}}
\newcommand{\algmaul}{\ensuremath{\makett{Maul}}}
\newcommand{\algrerand}{\ensuremath{\makett{ReRand}}}
\newcommand{\algopen}{\ensuremath{\makett{Open}}}

\newcommand{\mylist}[1]{\ensuremath{\mathcal{L}_{\mathsf{#1}}}}
\newcommand{\revlist}{\mylist{rev}}
\newcommand{\potlist}{\mylist{maybe}}
\newcommand{\corrlist}{\mylist{corr}}
\newcommand{\tmlist}{\mylist{tm}}
\newcommand{\mallist}{\mylist{mal}}
\newcommand{\lorlist}{\mylist{LoR}}
\newcommand{\cipherlist}{\mylist{ctxt}}
\newcommand{\userlist}{\mylist{usr}}
\newcommand{\sessionlist}{\mylist{\pi}}
\newcommand{\qlist}{\mylist{sign}}
\newcommand{\enclist}{\mylist{enc}}
\newcommand{\qulist}{\mylist{query}}

\newcommand{\shu}[3]{\ensuremath{\mathsf{SHU}(\poracle{#1}{#2},{#3})}} % to know if Send was given honest AD
\newcommand{\rhu}[3]{\ensuremath{\mathsf{RHU}(\poracle{#1}{#2},{#3})}} % to know if Receive was given honest AD


\providecommand{\addtolist}{\ensuremath{\hookleftarrow}}

\providecommand{\successor}[1]{\ensuremath{ {\sf next}(#1)}}
\providecommand{\rdec}{\ensuremath{m}}
\providecommand{\renc}{\ensuremath{c}}
\providecommand{\achoice}{\ensuremath{\beta}}

\providecommand{\forgery}[1]{\ensuremath{{#1}^*}}

\newcommand{\myrelation}{\mathcal{R}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Oracles:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\oUReg}{\ensuremath{\oracle{UReg}}}
\newcommand{\oInit}{\ensuremath{\oracle{Start}}}
\newcommand{\oSend}{\ensuremath{\oracle{Send}}}
\newcommand{\oReceive}{\ensuremath{\oracle{Receive}}}
\newcommand{\oReveal}{\ensuremath{\oracle{Reveal}}}
\newcommand{\oRevealCS}{\ensuremath{\oracle{Reveal.XStage}}}
\newcommand{\oRevealSS}{\ensuremath{\oracle{Reveal.\mathtt{1}Stage}}}
\newcommand{\oCorrupt}{\ensuremath{\oracle{Reveal.XSid}}}
\newcommand{\oEncrypt}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDecrypt}{\ensuremath{\oracle{ADec}}}
\newcommand{\oHSM}{\ensuremath{\oracle{AccessSK}}}
\newcommand{\oracleSet}{\ensuremath{\mathcal{O}}}
\newcommand{\oRevMed}{\ensuremath{\oracle{RevMedKey}}}

\newcommand{\oTest}{\ensuremath{\oracle{Test}}}
\newcommand{\ROM}{\ensuremath{\mathcal{RO}}}

\newcommand{\danger}[1]{\mathsf{Danger(#1)}}
\newcommand{\actdan}[1]{\mathsf{Act.Dan(#1)}}
\newcommand{\hijack}[1]{\mathsf{Hijack(#1)}}
\newcommand{\leak}[1]{\mathsf{Leak(#1)}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Adversaries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\adv}{\ensuremath{\mathcal{A}}}
\newcommand{\adversary}{\ensuremath{\mathcal{A}}}
\newcommand{\challenger}{\ensuremath{\mathcal{C}}}
\newcommand{\bdv}{\ensuremath{\mathcal{B}}}
\newcommand{\cdv}{\ensuremath{\mathcal{C}}}
\newcommand{\ddv}{\ensuremath{\mathcal{D}}}
\newcommand{\edv}{\ensuremath{\mathcal{E}}}
\newcommand{\fdv}{\ensuremath{\mathcal{F}}}
\newcommand{\gdv}{\ensuremath{\mathcal{G}}}
\newcommand{\idv}{\ensuremath{\mathcal{I}}}

\providecommand{\advstate}[1]{\ensuremath{\mathsf{state}_{#1}}}

\newcommand{\simulator}{\ensuremath{\mathsf{Sim}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Advantages & security properties
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\secpar}{\ensuremath{1^\lambda}}
\newcommand{\spar}{\ensuremath{\mathsf{s\param}}}
\newcommand{\ppar}{\ensuremath{\mathsf{p\param}}}
\newcommand{\param}{\ensuremath{\mathsf{param}}}

\newcommand{\myprot}{\ensuremath{\Pi}}

%\newcommand{\proto}[2]{\ensuremath{\mathsf{\Pi^{\myuser{#1}}_{\myuser{#2}}}}}

\newcommand{\scprop}{\ensuremath{\mathsf{SC}}}
\newcommand{\sacce}{\ensuremath{\mathsf{SACCE}}}
\newcommand{\acce}{\ensuremath{\mathsf{ACCE}}}
\newcommand{\ake}{\ensuremath{\mathsf{AKE}}}
\newcommand{\sake}{\ensuremath{\mathsf{S\text{-}AKE}}}

\newcommand{\expgame}[1]{\ensuremath{\mathsf{Exp}_\myprot^{#1}(\lambda ,\adv)}}
\newcommand{\pcsakegame}{\ensuremath{\expgame{\mathsf{PCS\text{-}AKE}}}}
\newcommand{\ooogame}{\ensuremath{\expgame{\mathsf{MLR}}}}



\newcommand{\pfsgame}{\ensuremath{\expgame{\mathsf{AKE}}}}
\newcommand{\exfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\pfsexfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\eufcmagame}{\ensuremath{\expgame{\mathsf{EUF-CMA}}}}
\newcommand{\kdfgame}{\ensuremath{\expgame{\mathsf{KDF}}}}
\newcommand{\lhaegame}{\ensuremath{\expgame{\mathsf{LHAE}}}}
\newcommand{\aeadgame}{\ensuremath{\expgame{\mathsf{AEAD}}}}

\newcommand{\akefwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}S\text{-}AKE}}}}}
\newcommand{\pfsfwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}AKE}}}}}


\newcommand{\eaprop}{\ensuremath{\mathsf{EA}}}
\newcommand{\accprop}{\ensuremath{\mathsf{Acc}}}
\newcommand{\csoundprop}{\ensuremath{\mathsf{CSound}}}

\newcommand{\csound}{\ensuremath{\mathsf{CSound}}}

\newcommand{\nbparty}{\ensuremath{\mathsf{n_P}}}
\newcommand{\nbstages}{\ensuremath{\mathsf{n_S}}}
\newcommand{\nbinstances}{\ensuremath{\mathsf{n_\pi}}}
\newcommand{\nbmedkeys}{\ensuremath{\mathsf{n_{\prek{}}}}}


\newcommand{\Prob}{\mathbb{P}}

\newcommand{\gadvantage}[1]{\ensuremath{\mathsf{Adv}_{#1}}}
\newcommand{\padvantage}[3]{\ensuremath{\mathsf{Adv}^{#3}_{#2}({#1})}}
\newcommand{\advsc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\scprop}}}
\newcommand{\advea}[1]{\ensuremath{\padvantage{#1}{\myprot}{\eaprop}}}
\newcommand{\advacc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\accprop}}}
\newcommand{\advcsound}[1]{\ensuremath{\padvantage{#1}{\myprot}{\csoundprop}}}
%\newcommand{\advsake}[1]{\ensuremath{\padvantage{#1}{\myprot}}}
\newcommand{\advunf}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{Unf}}}}
\newcommand{\advprop}[1]{\ensuremath{\padvantage{#1}{\myprot}{\mathsf{prop}}}}

\newcommand{\advake}[1]{\ensuremath{\padvantage{#1}{\Psi}{\mathsf{AKE}}}}

\newcommand{\advpcs}[1]{\ensuremath{\padvantage{#1}{\Pi}{\mathsf{PCS-AKE}}}}


\newcommand{\advcres}[1]{\ensuremath{\padvantage{#1}{H}{\mathsf{C.Res}}}}
\newcommand{\adveufcma}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{EUF-CMA}}}}

\newcommand{\advgdh}[1]{\ensuremath{\padvantage{#1}{\mathsf{}}{\mathsf{GDH}}}}


\newcommand{\advlhae}[1]{\ensuremath{\padvantage{#1}{\mathsf{\algaead}}{\mathsf{LHAE}}}}

\newcommand{\advsacce}[2]{\ensuremath{\padvantage{#1}{#2}{\sacce}}}
\newcommand{\advacce}[2]{\ensuremath{\padvantage{#1}{#2}{\acce}}}

\newcommand{\advpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{AKE}}}}
\newcommand{\advsake}[2]{\ensuremath{\padvantage{#1}{#2}{\sake}}}


\newcommand{\advexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}
\newcommand{\advpfsexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}


\newcommand{\advfwpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW\text{-}PFS}}}}
\newcommand{\advfwsake}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW}\text{-}\sake}}}
\newcommand{\advAKE}[2]{\ensuremath{\padvantage{#1}{#2}{\ake}}}
\newcommand{\advae}[1]{\ensuremath{\padvantage{#1}{\mathsf{AE}}{\mathsf{stLHAE}}}}
\newcommand{\advaead}[1]{\ensuremath{\padvantage{#1}{\mathsf{Enc,Dec}}{\mathsf{AEAD}}}}

\newcommand{\clock}{\ensuremath{\mathsf{clock}}}
\newcommand{\game}[1]{\ensuremath{\mathbb{G}\mathsf{ame}_{#1}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pname}{A Comprehensive Analysis on the Leakage of Fuzzy Matchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Layout and style:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\myparagraph}[1]{\vspace{2mm} \noindent \textbf{#1.}}
\newcommand{\mysubpar}[1]{\noindent \hspace{1mm} \textbf{\underline{#1.}} \hspace{1mm}}
\newcommand{\gamehop}[1]{\ensuremath{\mathbb{G}_{#1}} \vspace{1mm}}
\newcommand{\accro}{\ensuremath{\mathsf{3(S)ACCE}}}
\newcommand{\nth}[1]{\ensuremath{{#1}\textnormal{-th}}}

\newcommand{\exec}{\ensuremath{\leftarrow}}

\newcommand{\ie}{\emph{i.e.}, }
\newcommand{\eg}{\emph{e.g.}, }
\newcommand{\etal}{\emph{et al.}}

\newcommand{\Gr}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\Zp}{\mathbb{Z}_p}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\mymax}[2]{\ensuremath{\textsc{MAX}\big[#1, #2\big]}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% proocol's variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\alghash}{\ensuremath{\makett{H}}}
\newcommand{\randomness}{\ensuremath{r}}
\newcommand{\gtor}{\ensuremath{h}}
\newcommand{\generator}{\ensuremath{g}}
\newcommand{\idsign}{\ensuremath{\alg{ID}\algsign}}
\newcommand{\idverify}{\ensuremath{\alg{ID}\algverify}}
\newcommand{\abort}{\ensuremath{\msg{abort}}}
\newcommand{\concat}{\ensuremath{||}}
\newcommand{\ibe}{\ensuremath{\makett{IBE}}}



\newcommand{\ibs}{\ensuremath{\mathsf{IBSig}}}
\newcommand{\ibsSetup}{\ensuremath{\alg{IBS.Setup}}}
\newcommand{\ibsExtract}{\ensuremath{\alg{IBS.Extract}}}
\newcommand{\ibsSign}{\ensuremath{\alg{IBS.Sign}}}
\newcommand{\ibsVf}{\ensuremath{\alg{IBS.Vfy}}}

\newcommand{\ibsparams}{\ensuremath{\mathsf{IBS.ppar}}}
\newcommand{\ibsmpk}{\ensuremath{\mathsf{IBS.mpk}}}
\newcommand{\ibsmsk}{\ensuremath{\mathsf{IBS.msk}}}

\newcommand{\ibssk}{\ensuremath{\mathsf{IBS.sk}}}
\newcommand{\ibsusk}[1]{\ensuremath{\ibssk_{\myid{#1}}}}

\newcommand{\idmpk}{\ensuremath{\mathsf{ID.mpk}}}
\newcommand{\idmsk}{\ensuremath{\mathsf{ID.msk}}}
\newcommand{\idsk}[1]{\ensuremath{\mathsf{ID.sk}_{#1}}}
\newcommand{\mytag}[1]{\ensuremath{\mathsf{tag}^{#1}}}

\newcommand{\meta}{\ensuremath{\mathsf{meta}}}





\newcommand{\idenc}{\ensuremath{\makett{ID}\algenc}}
\newcommand{\signature}{\ensuremath{\mathsf{sgn}}}
\newcommand{\AD}{\textnormal{AD}}
\newcommand{\M}{M}
\newcommand{\dhoutput}{\ensuremath{\Delta}}
\newcommand{\dhout}[1]{\ensuremath{\mathsf{DH}^{#1}}}
% signature on stage x,y
\newcommand{\sig}[1]{\ensuremath{\sigma_{#1}}}
%%%%%%%%%%%%%%
%% ENVIRONMENTS %%
%%%%%%%%%%%%%%
\newtheorem{definition}{Definition}      %commented for LNCS
\newtheorem{theorem}{Theorem}      %commented for LNCS
\newtheorem{proof}{Proof}

%scale (equation)
\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% 5G-AKA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\aka}{\ensuremath{\mathsf{AKA}}}
\newcommand{\topc}{\ensuremath{\mathsf{Top}_C}}
\newcommand{\UE}{\party{UE}}
\newcommand{\HN}{\party{HN}}
\newcommand{\SN}{\party{SN}}
\newcommand{\gNB}{\party{gNB}}
\newcommand{\core}{\party{Core}}

\newcommand{\USIM}{\ensuremath{\mathsf{USIM}}}
\newcommand{\TMSI}{\ensuremath{\mathsf{TMSI}}}
\newcommand{\SUPI}{\ensuremath{\mathsf{SUPI}}}
\newcommand{\SUCI}{\ensuremath{\mathsf{SUCI}}}
\newcommand{\GUTI}{\ensuremath{\mathsf{GUTI}}}
\newcommand{\AG}{Assign-\ensuremath{\mathsf{GUTI}}}
\newcommand{\IMSI}{\ensuremath{\mathsf{IMSI}}}
\newcommand{\SQNU}{\ensuremath{\mathsf{SQN_U}}}
\newcommand{\SQNN}{\ensuremath{\mathsf{SQN_H}}}
\newcommand{\SQNs}{\ensuremath{\mathsf{SQN_s}}}
\newcommand{\pubenc}[2]{\ensuremath{\{#1\}^{#2}_\pk}}

\newcommand{\mycard}{\ensuremath{\mathsf{U}}}
%\newcommand{\sk}{\ensuremath{\mathsf{sk}}}
\newcommand{\sksub}[1]{\ensuremath{\sk_{#1}}}
\newcommand{\skop}{\ensuremath{\sk_\mathsf{op}}}
\newcommand{\sqn}[1]{\ensuremath{\mathsf{SQN_{#1}}}}
\newcommand{\myop}{\ensuremath{\mathsf{H}}}
\newcommand{\av}{\ensuremath{\mathsf{AV}}}
\newcommand{\autn}{\ensuremath{\mathsf{Autn}}}
\newcommand{\res}{\ensuremath{\mathsf{Res}}}
\newcommand{\akey}{\ensuremath{\mathsf{AK}}}
\newcommand{\myterm}{\ensuremath{\mathsf{T}}}
\newcommand{\Mac}{\ensuremath{\mathsf{Mac}}}
\newcommand{\Macsn}{\ensuremath{\Mac_{\mathsf{\myterm}}}}
\newcommand{\MAC}{\ensuremath{\mathsf{MAC}}}
\newcommand{\ckey}{\ensuremath{\mathsf{CK}}}
\newcommand{\ikey}{\ensuremath{\mathsf{IK}}}
\newcommand{\Macns}{\ensuremath{\Mac_{\mathsf{\mycard}}}}
\newcommand{\amf}{\ensuremath{\mathsf{AMF}}}
\newcommand{\RAND}[1]{\ensuremath{\mathsf{R}_{#1}}}
\newcommand{\nametl}{\ensuremath{\mathsf{VLR}}}
\newcommand{\namebackend}{\ensuremath{\mathsf{HLR}}}
\newcommand{\lai}{\ensuremath{\mathsf{LAI}}}
\newcommand{\uid}{\ensuremath{\mathsf{UID}}}
\newcommand{\func}[1]{\ensuremath{#1}}
\newcommand{\funcF}[1]{\ensuremath{\func{\mathcal{F}}_{#1}}}
\newcommand{\funcFstar}[1]{\ensuremath{\funcF{#1}^*}}


\newcommand{\xor}{\ensuremath{\oplus}}

\newcommand{\stack}{\emph{5G-SCEKE}}
\newcommand{\stackplus}{\emph{5G-SCEKE$^{+}$}}



%=================================================
% Comments :
%=================================================
%\usepackage{pifont}
\newlength{\strutdepth}%
\settodepth{\strutdepth}{\strutbox}%
\newcommand{\mycomment}[3]{%
    \noindent{\bfseries
        \color{#2}{#1}\color{black}}%
    \strut\vadjust{\kern-\strutdepth%
        \vtop to \strutdepth{%
            \baselineskip\strutdepth%
            \vss\llap{{\large\color{#2}#3\quad\color{black}}}\null%
        }%
    }%
}

\newcommand{\axel}[1]{\mycomment{#1}{magenta}{Axel}}
\newcommand{\kev}[1]{\mycomment{#1}{blue}{Kevin}}
\newcommand{\pascal}[1]{\mycomment{#1}{olive}{Pascal}}
\newcommand{\leo}[1]{\mycomment{#1}{orange}{Leo}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tikz:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\link}{ \draw[<->,>=latex]}
\newcommand{\att}{ \draw[-latex,dashed,ultra thick]}

\newcommand*{\QEDB}{\null\nobreak\hfill\ensuremath{\square}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% modifications:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\removetext}[1]{{\color{red}{\sout{#1}}}}
\newcommand{\addtext}[1]{{\color{teal}{#1}}}
\newcommand{\replacetext}[2]{\removetext{#1} \addtext{#2}}

\newcommand{\serveur}[0]{\ensuremath{\mathcal{S}}}
\newcommand{\client}[0]{\ensuremath{\mathcal{C}}}
\newcommand{\pwd}[0]{\ensuremath{\mathsf{pwd}}}

\newcommand{\databio}[0]{\ensuremath{\mathsf{bio}}}
\newcommand{\helpvalue}[0]{\ensuremath{\mathcal{\nu}}}
\newcommand{\pubclient}[0]{\ensuremath{\mathsf{P_u}}}
\newcommand{\privclient}[0]{\ensuremath{\mathsf{p_u}}}

\newcommand{\pubserv}[0]{\ensuremath{\mathsf{P_s}}}
\newcommand{\privserv}[0]{\ensuremath{\mathsf{p_s}}}

\newcommand{\keyserv}[0]{\ensuremath{\mathsf{k_s}}}

\newcommand{\rw}[0]{\ensuremath{\mathsf{rw}}}
\newcommand{\hash}[1]{\ensuremath{\mathcal{H}\left(#1\right)}}
\newcommand{\authenv}[1]{\ensuremath{\mathsf{AuthEnv}\left(#1\right)}}
\newcommand{\authenvrw}[1]{\ensuremath{\mathsf{AuthEnv}_{\rw}\left(#1\right)}}
\newcommand{\aec}[0]{\ensuremath{\mathsf{c}}}
\newcommand{\cval}[0]{\ensuremath{\alpha}}
\newcommand{\sval}[0]{\ensuremath{\beta}}


\newcommand{\algen}[2]{\ensuremath{\makett{Enc}_{#1}\left(#2\right)}}

\newcommand{\algencbio}[1]{\ensuremath{\makett{Enc}_{\databio}\left(#1\right)}}
\newcommand{\algdecbio}[1]{\ensuremath{\makett{Dec}_{\databio}\left(#1\right)}}


\newcommand{\Fq}[0]{\ensuremath{\mathbb{F}_q}}
\newcommand{\Fqn}[0]{\ensuremath{\mathbb{F}_q^n}}
\newcommand{\Fdn}[0]{\ensuremath{\mathbb{F}_2^n}}
\newtheorem{theo}{Theorem}[section]
\newtheorem{rem}{Remark}[subsection]
\newtheorem{ex}{Example}[subsection]

\newcounter{protocol}
\newenvironment{protocol}[1]
{\par\addvspace{\topsep}
    \noindent
    \tabularx{\linewidth}{@{} X @{}}
    \hline
    \refstepcounter{protocol}\textbf{Protocol \theprotocol} #1 \\
    \hline}
{\\
    \hline
    \endtabularx
    \par\addvspace{\topsep}}

\newcommand{\sbline}{\\[.5\normalbaselineskip]}% small blank line



\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{\pname
    %\thanks{This study was partially supported by the French ANR project ANR.}
}

\author{\IEEEauthorblockN{DURBET Axel}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne,} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
axel.durbet@uca.fr}
\and
\IEEEauthorblockN{GROLLEMUND Paul-Marie}
\IEEEauthorblockA{\textit{LMBP, Université Clermont Auvergne,}\\
\textit{CNRS, UMR 6620,}\\
\textit{Aubière, France}\\
paul\_marie.grollemund@uca.fr}
\and
\IEEEauthorblockN{THIRY-ATIGHEHCHI Kevin}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne, 
} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
kevin.atighehchi@uca.fr}
%\linebreakand
}

\maketitle


\begin{abstract}
    % The present paper presents a comprehensive analysis of potential information leakage in distance evaluation, with a specific emphasis on threshold-based obfuscated distance (\textit{i.e.} Fuzzy Matcher). It includes detailed descriptions of various situations related to potential information leakage and specific attention is given to their consequences on security. Generic attacks corresponding to each scenario are outlined, and their complexities are assessed. The main contribution of this work lies in providing an upper bound on the security of a fuzzy matcher in scenarios where there is additional information leakage from the matcher, providing a straightforward understanding of the maximum level of achievable security and its potential implications for data privacy and security.
    % The main contribution of this work lies in establishing an upper bound on the security of a fuzzy matcher when additional information is leaked from the matcher while providing a clear understanding of the maximum security level reachable and its potential implications for data privacy and security.
    This paper provides a comprehensive analysis of information leakage during distance evaluation, with an emphasis on threshold-based obfuscated distance (\textit{i.e.}, Fuzzy Matcher). Leakage can occur due to a malware infection or the use of a weakly privacy-preserving matcher, exemplified by side channel attacks or partially obfuscated designs. We provide an exhaustive catalog of information leakage scenarios as well as their impacts on the security concerning data privacy. Each of the scenarios leads to generic attacks whose impacts are expressed in terms of computational costs, hence allowing the establishment of upper bounds on the security level.
    % This analysis provides an in-depth understanding of the maximum level of security achievable for data privacy in all the defined scenario.
    
    
\end{abstract}

%\tableofcontents
\begin{IEEEkeywords}
Obfuscated Distance, Fuzzy Matcher, Hamming Distance, $L_1$ Distance, Attack Complexity, Information Leakage, Biometrics, Coupon Collector Problem
\end{IEEEkeywords}


\section{Introduction}\label{intro}


% The obfuscated distance function is still little explored in cryptology, and articles mentioning it are recent and rare. An obfuscated distance is a function that allows two or more parties to compute the distance between two inputs such that the only information to learn by each party is the distance. Those functions can be used several times with different modalities. One of the properties of the obfuscated distance is the privacy of the inputs.
In cryptology, the investigation of obfuscated distance functions is still limited, and articles discussing this topic are relatively recent and scarce. An obfuscated distance function facilitates the computation of the distance between two hidden inputs by multiple parties, wherein each party gains knowledge solely of the distance while preserving the privacy of the actual inputs. These functions can be iteratively applied with various features, and one of their fundamental properties is the preservation of input privacy.
% A way to achieve an obfuscated distance function is to use a homomorphic function~\cite{yasuda2017secure,huang2011faster,rane2010privacy} that allows computations to be performed directly on encrypted data without the need for decryption, thereby preserving the privacy of sensitive information; 

A first approach to design an obfuscated distance function involves employing homomorphic cryptography~\cite{yasuda2017secure,huang2011faster,rane2010privacy}, which enables computations to be directly applied on encrypted data without requiring decryption, thereby ensuring the confidentiality of sensitive information;
Garbled circuit~\cite{huang2011faster,bellare2012foundations,yao1986generate} is a cryptographic primitive based on symmetric encryption and oblivious transfer which is used to privately evaluate a function on encrypted inputs without revealing the inputs or the function's logic to the evaluator.
%Functional Encryption~\cite{agrawal2012functional,abdalla2016better} that enables selective access control to specific functions on encrypted data, empowering fine-grained privacy and security in various applications; 
Functional Encryption~\cite{agrawal2012functional,abdalla2016better,Okamoto2012,DATTA201716IPFE,TOMIDA20202019CIP0003IPFE} enables the implementation of specific functions on encrypted data, providing privacy and enhanced security across a wide range of applications such as the distance evaluation;
% Oblivious transfer~\cite{kiraz2015security,bringer2013shade,bringer2014gshade} which allows secure multiparty computation while preserving the privacy; 
Oblivious transfer~\cite{kiraz2015security,bringer2013shade,bringer2014gshade} enables secure multiparty computation while ensuring input privacy by allowing data exchange without revealing the content; 
or others mathematical methods based on computational assumptions~\cite{Galbraith2019PFH,KARABINA2016NTT,fleischhacker2021robust,fleischhacker2022property}. 
The obfuscated distance is also employed for biometric applications, aiming at protecting the client's privacy while maintaining the effectiveness of the biometric identification process.
% The obfuscated distance is used for biometric purposes in order to preserve the privacy of a client. 
% Those primitives can also be used to build a threshold-based obfuscated distance, as in error-correcting code~\cite{huffman2010fundamentals} which detects and corrects errors that may occur during the transmission or storage of digital data, ensuring reliable and accurate data retrieval; 
These cryptographic primitives can also be designed by relying on a threshold-based obfuscated distance, related to error-correcting codes~\cite{huffman2010fundamentals}, which are designed to detect and correct errors that may arise during digital data transmission or storage, thereby ensuring reliable and precise data retrieval;
% secure sketches and fuzzy extractors~\cite{fuller2020computational,dodis2007fuzzy,wen2018robustly,dodis2008fuzzy,cheon2018reusable} that extracts a stable and reusable cryptographic key from noisy or biometric data, enabling secure authentication while accommodating small variations in the input data; 
Secure sketches and fuzzy extractors~\cite{fuller2020computational,dodis2007fuzzy,wen2018robustly,dodis2008fuzzy,cheon2018reusable} are cryptographic schemes able of extracting a consistent and reusable cryptographic key from noisy or biometric data, facilitating secure authentication while accommodating minor variations in the input data;
% or fuzzy vaults~\cite{juels2006fuzzy} securely stores and retrieves secret information by leveraging error-correcting codes and biometric data, providing robust protection against unauthorized access and preserving data integrity.
Fuzzy vaults~\cite{juels2006fuzzy} are cryptographic designs that securely store and retrieve secret information by utilizing error-correcting codes and a noisy input (\textit{e.g.} biometric data), ensuring strong protection against unauthorized access and maintaining data integrity.
% All those constructions are based on or are Fuzzy Matcher, which is a subclass of evasive function~\cite{barak2014obfuscation}. Evasive functions are a class of functions for which it is computationally infeasible for any efficient algorithm to compute their output with high probability on most inputs.
% Most of the authors focus on fuzzy matching for Hamming distance. In this paper, we went a step further and consider our vector in $\mathbb{Z}_q^n$ for the $L_1$ distance however, our result also applies to the Hamming distance. 

All the previous functions and primitives are either founded on or encompass Fuzzy Matcher, which belongs to a subclass of evasive functions. Evasive functions~\cite{Galbraith2019PFH,barak2014obfuscation} are related to a class of functions that represent significant computational challenges for any efficient algorithm attempting to compute their output with high probability on most inputs. 
While many authors focus on fuzzy matching for the Hamming distance, this paper directly tackles the case of vectors in $\mathbb{Z}_q^n$ for the $L_1$ distance. Furthermore, notice that our findings can be extended to the Hamming distance as well.
% The theoretical security of each of these constructions is well known and well described in their respective papers, as is the difficulty an attacker would have in retrieving the initially hidden data. However, with the increasing number of side-channel attacks~\cite{HomoLeak}, implementation errors or construction flaws~\cite{carpovLeak}, the given security bounds are being hazed. One possible scenario is a partial leakage of distance calculation information. So, despite all its properties, an obfuscated distance by construction may leak some information. Information leakage refers to the inadvertent disclosure of sensitive data or details that were not intended to be revealed during the execution of the function. Such inadvertent disclosures can pose significant security and privacy risks, especially in scenarios where the function is utilized in sensitive applications, such as cryptographic protocols or data privacy frameworks (\textit{e.g.} biometric systems). 
% It is crucial to comprehend the implications of information leakage in this context. Hence, in this paper, we emphasize on the impact of leaking extra information on the complexity to retrieve hidden data. 
The theoretical security of each considered function and primitive is extensively investigated and well-documented in their respective papers, including the evaluation of the difficulty for an attacker to retrieve the initially hidden input. However, the growing prevalence of side-channel attacks~\cite{HomoLeak,hashemi2023time}, implementation errors, or construction flaws~\cite{carpovLeak} has raised uncertainties about the provided security bounds. One possible concern is the partial leakage of distance calculation information, which could lead to unintended information disclosure during the execution of the function. Such inadvertent disclosures involve significant security and privacy risks, especially in sensitive applications like cryptographic protocols or data privacy frameworks (\textit{e.g.}, biometric systems).

Understanding the implications of information leakage is a milestone in this scientific literature. Hence, this paper focuses on assessing the impact of such information leakage and on the complexity of retrieving hidden data. By investigating this issue, we aim at enhancing knowledge of the impact on the security of obfuscated distance designs and to improve the overall understanding of information leakage risks in cryptographic systems.

Taking the examples of biometric authentication (that requires testing a predicate about a distance) or password authentication (that requires testing a predicate of equality), attacks of interest can be divided into two categories:
\begin{itemize}
\item \textit{Offline exhaustive search attacks} correspond to attacks where a
leaked but protected database is given to the attacker, but the cryptographic obfuscation mechanism used for the verification of a protected fresh vector (biometric template), or the verification of a protected (hashed) password, is not supposed to leak any information beyond its admissibility.
\item \textit{Online exhaustive search attacks} correspond to attacks where an attacker is enforced to interact with the authentication server to deduce information about the target vector.  Such attacks may require malware infection on the server, in order for the attacker to retrieve additional leakage from the matcher, \textit{i.e.}, beyond the minimal information leakage (`yes' or `no').
\end{itemize}

\paragraph*{Related Works} 
% Pagnin \textit{et al.}~\cite{pagnin2014leakage} show that in the case of a threshold-based obfuscated distance, it is possible to exploit the result of the matcher to retrieve the hidden vector. This can be related to the zero leakage scenario, where only the output of the matcher is given to the attacker. They show how to perform this attack as well as its complexity. Our work is the same as we consider the same tools, however, we take into account that several extra information may be leaked by the matcher. To the best of our knowledge, this is the only papers that address the subject.
% Pagnin \textit{et al.}~\cite{pagnin2014leakage} show that in the case of a threshold-based obfuscated distance, it is possible to exploit the result of the matcher to retrieve the hidden vector. This can be related to the zero leakage scenario where only the output of the matcher is given to the attacker. They show how to perform this attack as well as its complexity. Our work is the same as we consider the same tools however, we take into account that several extra information may be leaked by the matcher. Ligier \textit{et. al.}~\cite{ligier2017information}. To the best of our knowledge, these are the only papers that address the subject.
Pagnin \textit{et al.}~\cite{pagnin2014leakage} demonstrated that in the context of a Fuzzy Matcher, the result of the matcher can be exploited to retrieve the hidden vector. Their work takes place in the minimal leakage, wherein only the matcher's binary output is given to the attacker. They explained the execution of this attack and assessed its complexity. Our work shares a similar focus, as similar tools are also examined. However, we extend the analysis by taking into account the possibility of multiple additional information leaks thanks to the matching operation. 
Similar to the aforementioned work, the proposed attacks aim at recovering the original data, which, in the context of biometrics, corresponds to compromising the privacy of the biometric data. This type of attack is considered the most devastating for such systems, as evidenced by Simoens \textit{et al.}~\cite{Simoens2012AFF}.
To the best of our knowledge, this is the sole paper that comprehensively investigates this subject.


\paragraph*{Contributions}
% In this paper, we delve into a comprehensive analysis of the potential sources of information leakage associated with distance evaluation and more particularly with threshold-based obfuscated distance. These scenarios are described, as well as their implications for security loss. To do so, we highlight generic attacks for each of these scenarios, as well as their complexities.
% In this paper, we delve into a comprehensive analysis of the potential sources of information leakage associated with distance evaluation and, more particularly, with threshold-based obfuscated distance. These scenarios are thoroughly described, along with their implications for security. To achieve this, we systematically outline generic attacks corresponding to each of these scenarios and assess their complexities. Hence, we contribute to the field of information security by offering valuable insights into the complexities of leaking threshold-based obfuscated distance evaluation.
We present a deep analysis of potential information leakage in distance evaluation, with a specific focus on threshold-based obfuscated distance. The paper thoroughly describes various scenarios where information leakage may occur and examines their implications for security. To achieve this, we systematically outline generic attacks corresponding to each scenario and assess their complexities.
Our contribution is to provide insights into the finer points of information leakage in threshold-based obfuscated distance, thus advancing the field of information security. The discussed scenarios give rise to new attacks as well as a range of attacks that complete the work of Pagnin \textit{et al.}:
\begin{enumerate}
\item Accumulation attacks that capture potential attacks from an \textit{honest-but-curious} server when a client authenticates to it. These attacks assume the use of privacy-preserving cryptographic primitives for evaluating the distance between two hidden vectors. Specifically, as an example, we assume the use of a cryptographic obfuscator of the distance function.
\item % A range of attacks that capture data breaches when an obfuscated database is leaked, or when a malicious client launches an \textit{online exhaustive search attack}.
Attacks launched by malicious clients exploiting various information leakage from the matcher in the context of a leaked (but obfuscated) database, or by interacting with the server during an \textit{online exhaustive search attack}. As a summary of our main contributions, the complexity type of our attacks is summarized in Table~\ref{summary_table} along with the scenarios considered.
\end{enumerate}


% Please add the following required packages to your document preamble:
% \usepackage{booktabs}
% \usepackage{multirow}
\begin{table*}[]
\centering
\begin{tabular}{@{}ccccl@{}}
\toprule
Complexity type         & Threshold related      & Leakage                             & Need genuine client & Theorem \\ \midrule
\multirow{7}{*}{Exp.}   & Above                  & Position                            & $\times$            &   Theorem~\ref{th-above-leak-pos}      \\\cmidrule{2-5}
                        & \multirow{4}{*}{Below} & Distance                            & $\times$            &   Theorem~\ref{th-below-leak-dist}      \\
                        &                        & Position                            & $\times$            &   Theorem~\ref{th-below-leak-pos}      \\
                        &                        & Distance and positions              & $\times$            &   Theorem~\ref{th-below-leak-dist-and-pos}      \\
                        & Below                  & Distance, positions and values      & $\times$            &   Theorem~\ref{th-below-leak-dist-pos-and-val}      \\\cmidrule{2-5}
                        & \multirow{2}{*}{Both}  & Positions                           & $\times$            &   Theorem~\ref{th-both-pos-leak}      \\
                        &                        & Minimal                             & $\times$            &   Theorem~\ref{th-both-minimal}      \\ \midrule
\multirow{5}{*}{Lin.}   & \multirow{2}{*}{Above} & Distance                            & $\times$            &   Theorem~\ref{th-above-leak-dist}      \\
                        &                        & Distance and position               & $\times$            &   Theorem~\ref{th-above-leak-dist-and-pos}      \\\cmidrule{2-5}
                        & Below                  & Positions and values (accumulation) & $\checkmark$        &   Theorem~\ref{th-acc}      \\ \cmidrule{2-5}
                        & \multirow{2}{*}{Both}  & Distance                            & $\times$            &   Theorem~\ref{th-both-dist-leak}      \\
                        &                        & Distance and positions              & $\times$            &   Theorem~\ref{th-both-dist-and-pos-leak}      \\\midrule
                       
\multirow{2}{*}{Const.} & Above                  & Distance, position, and values       & $\times$            &   Theorem~\ref{th-above-leak-dist-pos-and-val}    \\
                        & Both                   & Distance, positions and values      & $\times$            &   Theorem~\ref{th-both-dist-pos-and-val-leak}      \\  \bottomrule
\end{tabular}
\caption{\label{summary_table} Summary of the different leakages and their corresponding exploit complexities.}
\end{table*}

\paragraph*{Outline}
% The following outline describes the organization of our paper, presenting a clear structure that encompasses the paper framework, different scenarios, the attacks, and some concluding remarks of our obfuscated distance leakage study. Section~\ref{Bg} is dedicated to the definitions used all along the paper on the studied function \texttt{Match}. Then, Section~\ref{Notation} introduces the notations and the oracle used. The main contributions of the paper are in Section~\ref{Leak_type} and Section~\ref{attacks}. The first above-mentioned describes all the leakages scenarios that are studied in this paper. The contents of this section are summarized in Table~\ref{Leak_scenario_table}. The second one relates all the attacks for these scenarios, as well as their complexities. These complexities are then summarized in Table~\ref{Leak_table}. Section~\ref{Conclu} closes the paper by synthesizing all the results of the paper and bringing a new point of view on this work and future perspectives.
%The structure of the paper encompasses the framework, various scenarios, attacks, and concluding remarks of our study on obfuscated distance leakage. 
% Section~\ref{prel} first presents the foundational definitions utilized throughout the paper, specifically focusing on the matcher. 
% Some notations and terminologies are also introduced, and a typology of leakages is provided. This exhaustive description of all the leakage scenarios provides an analysis of the information that may leak.
% The primary contributions of the paper are outlined in Section~\ref{attacks}, 
% where Table~\ref{Leak_scenario_table} provides a concise summary of the scenarios. 
%A concise summary of these scenarios is presented in
%In this section, we also provide a new attack paradigm yielding the accumulation attack as well as the analysis.
Section~\ref{prel} initially presents the fundamental definitions required to read the paper, with a particular emphasis on the matcher. We also introduce certain notations and terminologies, and provide a classification of leakages. This comprehensive description of all leakage scenarios allows for an analysis of potential information leaks. The key contributions of the paper are highlighted in Section~\ref{attacks}, where Table~\ref{Leak_scenario_table} offers a succinct overview of the scenarios.
In the subsection~\ref{AccuAtt:section}, we describe a novel attack paradigm that encompasses the accumulation attack, along with a complete analysis of its complexity.
In contrast, the subsections~\ref{below}, \ref{above}, \ref{both} deepen detailing various attacks corresponding to the identified scenarios, alongside an assessment of their complexities. A succinct summary of these complexities is provided in Table~\ref{Leak_table}.
%Section~\ref{Conclu} concludes the paper, consolidating all the obtained results and presenting novel perspectives on our work, as well as potential directions for future research.


\section{Preliminaries}
\label{prel}
% \begin{definition}[Obfuscated distance scheme]
%     Let $(\Zq,d)$ a metric space equipped with the distance $d:\Zq^n \times \Zq^n \xrightarrow{} \R_{\ge 0}$. Then, $\Delta$ is an obfuscated distance scheme is a pair of algorithm Store and Distance which 
% \end{definition}
%
% In this section, the (Obfuscated) Matcher is defined as a function utilized to verify the proximity of two hidden inputs. The notations to be used throughout the paper are then introduced to facilitate the analysis. In the end, the list of all information leakage scenarios considered is presented.
In this section, the (Obfuscated) Matcher is introduced as a function utilized for verifying the proximity of two hidden inputs. Secondly, the notations used throughout the analysis are presented. Then, a list of all the considered information leakage scenarios is presented.


\subsection{(Obfuscated) Matcher}
\label{Bg}
Let $\Zq^n$ be a metric space equipped with the distance $d$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. 
%To define a fuzzy matcher, the notion of evasive function must be recalled.
%
% \begin{definition}[Evasive Function]
%     An evasive function family is a collection of functions $F$ such that for every inputs $x$, a random function from $F$ outputs 
% \end{definition}
A private matching scheme $\Xi$ is a pair of an algorithm \texttt{Hide} and a \texttt{Match} which respectively allow hiding a data $x\in \Zq^n$ and check if a newly provided data $y\in \Zq^n$ is such that $d(x,y) \leq \epsilon$. 

\begin{definition}[Hide]
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, a space $\mathbb{K}$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $x\in\Zq^n$,
    \begin{eqnarray*}
        \Xi.\texttt{Hide}: &  \Zq^n & \xrightarrow{} \mathbb{K} \\
        & x & \xrightarrow{} X
    \end{eqnarray*}
    Such that $\Xi.\texttt{Hide}$ can be computed by a polynomial time algorithm (PPT), but any polynomial time randomized algorithm $\mathcal{A}$ that attempts to compute a pseudo-inverse for $\Xi.\texttt{Hide}$ succeeds with negligible probability.
    % act like a one way function
    % the knowledge of $X$ does not gives any informations on $x$.
\end{definition}

Once $x$ has been hidden by the function $\Xi.\texttt{Hide}$, it is possible to check if a vector $y$ is close to $x$ with respect to $\epsilon$. In other words, $\Xi.\texttt{Match}$ indicates if $y\in B_\epsilon(x)$, where $B_\epsilon(x) = \lbrace y \in \Zq^n \,| d(x,y)\leq \epsilon \rbrace$ is the ball of radius $\epsilon$ and centered in $x$. 

\begin{definition}[Match]
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, $x\in \Zq^n$, $\mathbb{K}$ be $\Xi.\texttt{Match}(\Zq^n)$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $Y\in\mathbb{K}$ the output of $\Xi.\texttt{Hide}(y)$ and $X$ the output of $\Xi.\texttt{Hide}(x)$, 
    \begin{eqnarray*}
        \Xi.\texttt{Match}: &  \mathbb{K} \times \mathbb{K} & \xrightarrow{} \lbrace 0, 1 \rbrace \\
        & Y, X  & \xrightarrow{} \begin{cases}
        0 & \text{ if } d(x,y)\leq \epsilon, \\
        1 & \text{ otherwise}, \\ 
        \end{cases}
    \end{eqnarray*}
    such that $\Xi.\texttt{Match}$ is a deterministic polynomial time algorithm that succeeds with probability $1$.
\end{definition}

\begin{rem}
    Both $\Xi.\texttt{Match}$ inputs are hidden by the function $\Xi.\texttt{Hide}$.
\end{rem}

% The $\Xi.\texttt{Match}$ function may leak some information and the possibles leakages scenarios are described later in the paper.
% For the sake of simplicity, in the following, we consider that a vector $y\in\mathbb{Z}_q^n$ can be used directly with $\Xi.\texttt{Match}$ and the pre-transformation $\Xi.\texttt{Hide}(y)$ can be omitted. 
To simplify, we assume that a vector $y \in \mathbb{Z}_q^n$ can be directly used with $\Xi.\texttt{Match}$, \textit{i.e.}, pre-transformation $\Xi.\texttt{Hide}(y)$ is omitted when it is not necessary.
The $\Xi.\texttt{Match}$ function has the possibility to disclose certain information, and its possible leakage scenarios are described in the following sections.

\subsection{Notations and Attacker Models}
\label{Notation}

%\subsection{Notations and Attacker Model}
In the following, we consider the metric space $\Zq^n$ (the set of vectors of size $n$ with value in $\llbracket 0, q-1 \rrbracket$) equipped with the distance $d$. 
% $\sigma_{x,\epsilon}$ denote the threshold oracle, which takes as input $y\in\Zq^n$ and return $0$ if the distance between $y$ and $x\in\Zq^n$ a committed vector is below the threshold $\varepsilon$ and $1$ otherwise. For the sake of clarity, the threshold $\epsilon$ is omitted when the context is clear.
%$\mathbb{K}$ denotes $\Xi.\texttt{Match}(\Zq^n)$, \textit{i.e.} the image of $\Zq^n$ by the function $\Xi.\texttt{Match}$. 
Let us define the oracle $\sigma_{x,\epsilon}$ that models the role of $\Xi.\texttt{Match}$, to which the attacker is given access. 
%The oracle $\mathcal{O}_{x,\epsilon}$ return a hided vector $Y\in\mathbb{K}$ such that $\sigma_{x,\epsilon}(Y)$ return $0$. 
For the sake of simplicity, the threshold $\epsilon$ and the hidden vector $x$ are omitted when the context is explicit.

In this framework, the goal of the attacker is to retrieve the hidden data $x\in\Zq^n$ from the transformation $\Xi.\texttt{Hide}(x)$. To do so, she is performing queries to the oracle $\sigma_{x,\epsilon}$ as well as the function $\Xi.\texttt{Hide}$.
Moreover, as regards the accumulation attack scenario, the attacker has access to the oracle  $\mathcal{O}_{x,\epsilon}$ which returns $\Xi.\texttt{Hide}(y)$ with $d(x,y)\leq \varepsilon$. Hence, $\mathcal{O}$ returns a new hidden vector from the genuine client during its authentication in the system.
%Moreover, in the leakage below the threshold scenario, the attacker can have access to the oracle $\mathcal{O}_{x,\epsilon}$ to illustrate an attacker which has access to a genuine client for an authentication scheme.
% The different types of information leakage expose the system to different generic attacks.
% These attacks range from the Exhaustive Search Attack to the Center Search Attack. 
%\todo{Paragraphe introductif de la section}
% A matching scheme $\Xi$ as defined in Section~\ref{Bg} can leak some information. 
% To quantify this leakage, we consider the following scenarios. 
% In the following, we consider that $\Xi.\texttt{Match}$ leaks extra information in addition to its answer $0$ or $1$.  In this section, several scenarios to model these information leaks are defined.
A matching scheme $\Xi$, as defined in Section~\ref{Bg}, can leak some information and we consider that $\Xi.\texttt{Match}$ leaks extra information beyond its binary output ($0$ or $1$). The section comprises two subsections. The first one enumerates the types of information leaks related to a matching scheme and defines the associated scenarios. The second subsection focuses on the various attacks employed to exploit the leaked information. 
%Hence, we present an in-depth analysis of how the leaked information is exploited, and the methodologies utilized (see proofs) to perform these attacks. 
By examining these aspects, we aim at enhancing the understanding of the real security of a matching scheme under different leakage scenarios.


\subsection{Typology of Information Leakage}
\label{Leak_type}
% There are three main scenarios. The first one is a leakage of information below the threshold. The second one is the leakage above the threshold. The last one is when the information leaks below and above the threshold. Among these global scenarios, there are several sub-settings. The first one is the absence of leakage, \textit{i.e.} $\Xi.\texttt{Match}$ returns only $0$ or $1$. 
% Then, the following leak can be declined for above the threshold, below or both. 
% Then, we have the knowledge of the distance $d$, the position of the error only, the distance $d$ and the position of the error, and the distance $d$ and the position of the error as well as the value of each error. Table~\ref{Leak_table} summarizes all those possibilities. 
\noindent
There are three main categories of leakage: 
% The first one involves information leakage below the threshold $\varepsilon$. The second relates to information leakage above $\varepsilon$. The last covers situations where information leaks both below and above the threshold. 
\begin{enumerate}
    \item Information leakage below the threshold. 
    \item Information leakage above the threshold. 
    \item Information leakage both below and above the threshold. 
\end{enumerate}
Among these scenarios, several sub-settings can be identified.
The first sub-setting corresponds to the absence of any leakage, resulting in $\Xi.\texttt{Match}$ yielding only binary outcomes ($0$ or $1$). Then, the following sub-settings are examined: 
\begin{enumerate}
    \item Knowledge of the distance $d$. 
    \item Knowledge of the positions of the errors only.
    \item Knowledge of both the distance $d$ and the positions of the errors.
    \item Knowledge of both the distance and the positions and their corresponding values.
\end{enumerate} 
All these scenarios and sub-settings are summarized in Table~\ref{Leak_table}.

\begin{table}[h]
    \begin{center}
        \begin{tabular}{@{}ll@{}}
            \toprule
            \multicolumn{1}{l}{Threshold}    & \multicolumn{1}{l}{Extra Information} \\ \toprule
            \multirow{5}{*}{Above}           &  No extra leakage                               \\
                                             & Distance    \\
                                             & Position                              \\
                                             & Distance and position                 \\
                                             & Distance, position, and value         \\
                                                                                         \midrule
            \multirow{5}{*}{Below}           & No extra leakage                               \\
                                             & Distance    \\
                                             & Position                              \\
                                             & Distance and, position                \\
                                             & Distance, position, and value         \\
                                                                                         \midrule
            \multirow{5}{*}{Above and Below} & No extra leakage                               \\
                                             & Distance    \\
                                             & Position                              \\
                                             & Distance and position                 \\
                                             & Distance, position, and value         \\
                                                                                         \bottomrule
        \end{tabular}
        \caption{\label{Leak_scenario_table} Summary of distance leakages.}
    \end{center}
\end{table}

\section{Attacks exploiting Leaking Distance}
\label{attacks}

\subsection{Leakage Exploit Attacks}

%Having defined the different types of leakage, we now present the attacks. 
Several attacks are related to the different types of aforementioned leakage scenarios. 
The first attack is the exhaustive search, which tests all possible vectors until the right one is found.

\begin{definition}[Exhaustive Search or Brute-Force Search]
    \label{ExaustiveSearch}
    This attack is a very general problem-solving technique that consists in testing all possibilities until the problem statement is verified. The complexity of this attack is $O(q^n)$ queries to~$\sigma$.
\end{definition}

Then, by considering some extra information, it is possible to perform a hill-climbing attack~\cite{lasry2018methodology}. The aim is to find the solution by iteratively improving a potential solution. 

\begin{definition}[Hill-climbing attack]
    \label{HillClimAtt}
    The hill-climbing attack is based on a mathematical optimization technique. It begins with an arbitrary solution, then it attempts to improve the solution by applying some slight variations. If the modified solution improves the score obtained with the target function, the previous process is repeated with the new solution until the attack succeeds. The complexity of this attack is in $O(nq)$.
\end{definition}

% Using $\sigma$ and obliviously testing someone else vector which can produce a vector close to $x$ under certain circumstances can lead to the total discovery of $x$.
By employing the oracles $\sigma$ and $\mathcal{O}$ under specific conditions, the attacker recovers the complete information of $x$ by accumulating some knowledge about $x$ at each query. However, the accumulation attack only applies to special cases, which are examined in more detail in Section~\ref{AccuAtt:section}.
\begin{definition}[Accumulation Attack]
    \label{AccuAtt}
    The accumulation attack is a passive attack where the attacker recovers a certain amount of information at each interaction.
    By accumulating this information, the entropy of the target is getting smaller until its entropy goes to zero.
    In the end, the attacker has a complete knowledge of the target.
\end{definition}


In~\cite{pagnin2014leakage}, the authors show that from any closed vector $y$ of $x$, \textit{i.e.}, $d(x,y)\leq \varepsilon$, it is possible to retrieve the center $x$ of the ball using~$\sigma$. 
\begin{definition}[Center Search Attack~\cite{pagnin2014leakage,Simoens2012AFF}]
    \label{CentSearAtt}
    This attack aims at finding $x$ the center of the acceptance ball $B_\epsilon(x)$. The starting point of the attack is to find a point $b'$ on the edge of the ball, and then converge to its center. The complexity of this attack is $O(nm)$ where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
\end{definition}


% Note that the Center Search Attack is not always possible. In the case where the threshold, \textit{i.e.} the radius of the ball, is too large compared to the space, the attack does not work. %the number of points that can be reached by leaving the ball to get closer is too small. 
% However, with the normal use of a distance-matching system, where $\varepsilon$ is a small fraction of $n$, this should not happen. 
We refer the reader to the work of Pagnin \textit{et al.}~\cite{pagnin2014leakage} for more details.


\subsection{Accumulation Attack}
\label{AccuAtt:section}

To model this attack, we consider that $\sigma$ leaks information on the positions and values of errors. Assume that the errors in $y$ given by $\mathcal{O}$ are uniformly distributed. 
\begin{theorem}\label{th-acc}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors and their values below the threshold, an attacker can retrieve $x$ in $O\left(\sum_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{n-j}{n}\right)^{-1}\right)$ queries to to both $\mathcal{O}_{x,\varepsilon}$ and~$\sigma_{x,\varepsilon}$.
\end{theorem}

The complexity of this attack relies on the coupon collector's problem. This problem is a well-known problem of probability theory, where one seeks to determine the expected number of trials needed to collect a complete set of distinct items from a large pool with replacement. This problem has received considerable attention in the literature, with notable studies conducted by Ferrante \textit{et al.}~\cite{ferrante2012note,CoupnCollector} and Flajolet \textit{et al.}~\cite{flajolet1992birthday}.

In order to support Definition~\ref{AccuAtt} and gives the ideas for the proof of Theorem~\ref{th-acc}, the subsequent example serves to illustrate the design of an Accumulation Attack.
\begin{ex}
    \label{ExampleAccuAtt}
    Assume a setting with a metric space $\mathbb{Z}_2^n$ equipped with the Hamming distance. A client seeks to authenticate to an \textit{honest-but-curious} server that uses a scheme leaking $d_H(x,y)$ and the corresponding errors if $d_H(x,y) \leq \epsilon$.
    As the client is legitimate, \textit{i.e.}, $d_H(x,y) \leq \epsilon$, the server recovers the value of at most $\epsilon$ erroneous bits. If the server is lucky, in $n/\epsilon$ steps, the data of the client is compromised. The server needs to collect all the bits of the client, turning this problem into a Coupon Collector problem. According to Ferrante \textit{et al.}~\cite{ferrante2012note,CoupnCollector} and assuming that errors uniformly occur in vector coordinates, the server retrieves the biometric data after an expected number of $N$ authentications with
    \begin{align*}
        \sum\limits_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{n-j}{n}\right)^{-1} & \ge N \\
        \sum\limits_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{\binom{n-j}{\epsilon}}{\binom{n}{\epsilon}}\right)^{-1} & \leq N.
    \end{align*}
    
    For example, let assume $x = (0,0,1,1,0,1,0)$, $\varepsilon = 3$. The server set $z = (?,?,?,?,?,?,?)$. Session~1: The client authenticates with $y = (1,1,0,1,0,1,0)$. In this case, $d_H(x,y) = 3 \leq \varepsilon$. The server gets the value of the erroneous bits of the client and updates $z = (0,0,1,?,?,?,?)$. Session~2: the client authenticates with $y = (0,0,0,0,1,1,0)$. In this case, $d_H(x,y) = 3 \leq \varepsilon$, and the server gets the value of the erroneous bits of the client and updates $z = (0,0,1,1,0,?,?)$. Finally, the server has a vector inside the ball. Hence, she is able to perform an impersonation attack because the entropy of $z$ is smaller than the threshold, or she can perform the Center Search Attack~\ref{CentSearAtt}. Moreover, by trying some extra steps, she will retrieve the very last bits.
\end{ex}
%
% To model this attack, let $\mathcal{O}_{x,\varepsilon}$ be the oracle that returns a $Y=\Xi.\texttt{Hide}(y)$ with $y$ such that $d(x,y)\leq\varepsilon$. 
\begin{proof}
Using the same argument as in the example, the vector $x$ is recovered in $O\left(\sum_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{n-j}{n}\right)^{-1}\right)$ queries to both $\mathcal{O}_{x,\varepsilon}$ and~$\sigma_{x,\varepsilon}$.\\
$\blacksquare$
\end{proof}

\subsection{Attacks complexities for a leakage above the threshold}
\label{above}

% In this section, we consider the first scenario, which is the leakage above the threshold. In other words, given a vector $x$ hided, the submission of $y$ such that $d(x,y)>\varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge.
In this section, the first scenario is considered, which involves leakage above the threshold $\varepsilon$. In other words, when a hidden vector $x$ is used, the submission of another vector $y$ such that $d(x,y) > \varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge.

\paragraph{The distance is leaked}
%The first case is when the distance is given to the attacker as the extra gain of knowledge. In this case, the attacker can perform a hill-climbing attack till he gets a vector $y$ which is at distance exactly $\varepsilon$ of her target $x$. This part of the attack can be performed in $nq-\varepsilon$ steps. Then, she cannot continue the hill-climbing attack, as she falls below the threshold and does not gain any extra information. However, she can now perform the center search attack in $nm$ steps with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
%Hence, the complexity of the attack to recover $x$ in this case is in $O(n(q+m)-\varepsilon)$.
The first case happens when the distance is provided to the attacker as the extra gain of knowledge. 
\begin{theorem}\label{th-above-leak-dist}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance above the threshold, an attacker can retrieve $x$ in $O(n(q+m)-\varepsilon)$ queries to $\sigma_{x,\varepsilon}$, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.       
\end{theorem}
\begin{proof}
In this situation, a hill-climbing attack can be executed by the attacker until a vector $y$ is obtained, precisely at a distance of $\varepsilon$ from their target $x$. This stage of the attack can be completed within $nq-\varepsilon$ steps. Subsequently, the hill-climbing attack cannot be continued since it falls below the threshold, yielding no further extra information. However, the attacker can now proceed with the center search attack, which requires $nm$ steps, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
%
As a result, the complexity of the attack aimed at recovering $x$, in this case, is in $O(n(q+m)-\varepsilon)$.\\
$\blacksquare$
\end{proof}

\paragraph{The positions are leaked}
% In this case, the extra information given to the attacker is the position of the error, but she ignored the value of each error. Thus, she has to perform an exhaustive search on those erroneous coordinate to get under the threshold. It is reasonable to assume that this part is done in  $q^{n(1-1/q)}$ steps. Indeed, given two random vectors $x,y\in \mathbb{Z}_q^n$, the expectation of the number of coordinate which are different is given by $n(1-1/q)$. Then she can now perform the center search attack in $nm$ steps with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
% Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n(1-1/q)}+nm)$.
In this case, the error positions are the extra information provided to the attacker, while the value of each error remains secret. 
\begin{theorem}\label{th-above-leak-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the error positions above the threshold, an attacker can retrieve $x$ in average in $O(q^{n(1-1/q)-\varepsilon}+nm)$ (resp. in the worst case in $O(q^{n-\varepsilon}+nm)$) where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
An exhaustive search on the erroneous coordinates must be performed by the attacker to down below the threshold. It is reasonable to assume that this part can be accomplished in $q^{n(1-1/q)-\varepsilon}$ steps. Given two random vectors $x$ and $y$ from $\mathbb{Z}_q^n$, the expected number of coordinates that differ between them is approximately $n(1-1/q)$. This approximation highlights the difference with the case of an exhaustive search. Indeed, if we simply look at it asymptotically, there is no difference between both.
%
Subsequently, the attacker can perform the center search attack in $nm$ steps, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$. Hence, the overall complexity of the attack in this scenario is in $O(q^{n(1-1/q)}+nm)$. The worst case is equivalent to the case above.\\
$\blacksquare$
\end{proof}

\paragraph{The distance and the position are leaked}
%
% In this case, the distance and the position of the errors are given to the attacker when she tried a vector above the threshold. Hence, her hill-climbing attack must be performed in the erroneous coordinates. This part can be done in $nq(1-1/q)-\varepsilon$ steps using the same argument as the above section.
% Then she can now perform the center search attack in $nm$ steps with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
% Hence, the complexity of the attack to recover $x$ in this case is in $O(n(q+m-1)-\varepsilon)$.
%
In this case, when the attacker queries a vector above the threshold, she is provided with both the distance and the error positions. 
\begin{theorem}\label{th-above-leak-dist-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance and the positions of the errors above the threshold, an attacker can retrieve $x$ in average in $O(n(q+m-1)-\varepsilon)$ (resp. in the worst case in $O(n(q+m)-\varepsilon)$) where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
Her hill-climbing attack must be executed on the erroneous coordinates. This stage can be achieved average in $nq(1-1/q)-\varepsilon$ steps (resp. in the worst case in $nq-\varepsilon$), using the same argument as the above section.
In the next stage, the attacker can run the center search attack in $nm$ steps, with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$. The overall complexity is in average $O(n(q+m-1)-\varepsilon)$ (resp. in the worst case $O(n(q+m)-\varepsilon)$).
\\$\blacksquare$
\end{proof}

\paragraph{The distance, the position, and the value are leaked}
%
%In this last case, the distance, the position of the errors and the value of each error is leaked. In this case, we are facing an error-correcting mechanism that allows the correction above the threshold. It is clear that the attacker recover $x$ in $1$ step. Hence, this attack is in $O(1)$.
%
In this last case, the distance, the error positions and values are leaked.
\begin{theorem}\label{th-above-leak-dist-pos-and-val}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the positions of the errors, and their values above the threshold, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
In this case, the query answer is an error-correcting code, hence yielding a complexity of $O(1)$.
\\
$\blacksquare$
\end{proof}

\subsection{Attack Complexities for Leakage Below the Threshold}
\label{below}
% In this section, we consider the second scenario, which is the leakage below the threshold. In other words, given a vector $x$ hidden, the submission of $y$ such that $d(x,y)\leq\varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge.

The second scenario is considered, involving leakage below the threshold. Specifically, assuming the hidden target vector $x$, submitting another vector $y$ such that $d(x,y)\leq\varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may leak additional information. It is important to note that some systems, such as error-correcting codes, purposely leak information below the threshold and so this is the most likely scenario.

\paragraph{The distance is leaked}
% The first case is when the distance is given to the attacker as the extra gain of knowledge. 
% The first step is to get a vector below the threshold. To do so, the attacker must perform an exhaustive search attack in $q^{n-\varepsilon}$ steps. Then, she can perform a hill-climbing attack in $qn$ steps. Hence, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon}+qn)$.

The first case occurs when the distance is given to the attacker as extra information. 
\begin{theorem}\label{th-below-leak-dist}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and a fuzzy matcher $\Xi$ such that $\Xi.\texttt{Match}$ leaks the distance below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+qn)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
The first step involves obtaining a vector below the threshold, which requires performing an exhaustive search attack in $q^{n-\varepsilon}$ steps. Then, a hill-climbing attack can be executed in $qn$ steps. Therefore, the overall complexity is in $O(q^{n-\varepsilon}+qn)$.\\
$\blacksquare$
\end{proof}

\paragraph{The position are leaked}
% In this case, the extra information given to the attacker is the position of the error, but she ignored the value of each error. As in the previous scenario, the first step is to get a vector below the threshold.  To do so, the attacker must perform an exhaustive search attack in $q^{n-\varepsilon}$ steps. Then she must perform an exhaustive search on the erroneous positions in $q^{\varepsilon}$ steps. Hence, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon}+q^{\varepsilon})$.

The position of the errors is the extra information given to the attacker, while their values remain secret. 
\begin{theorem}\label{th-below-leak-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the position of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q^{\varepsilon})$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
The first step is to fall inside the ball, which requires the attacker to perform an exhaustive search attack in $q^{n-\varepsilon}$ steps. Subsequently, an exhaustive search on the erroneous positions must be performed, which takes $q^{\varepsilon}$ steps. Hence, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon}+q^{\varepsilon})$.
\\ $\blacksquare$
\end{proof}


\begin{table*}[]
%\resizebox{\columnwidth}{!}{%
\centering
\begin{tabular}{ccccc}
\toprule
\multicolumn{1}{l}{Threshold related}   & Leakage                      & Complexity type & Worst case complexity in Big-$O$ & Average complexity in Big-$O$              \\
\midrule
\multirow{4}{*}{Above} & Distance                     & Lin.       & $n(q+m)-\varepsilon$  &       $-$       \\
                               & Position                     & Exp.        &   $q^{n-\varepsilon} + nm$  & $q^{n(1-1/q)-\varepsilon}+nm$              \\
                               & Distance and position        & Lin.       & $n(q + m) - \varepsilon$   &  $n(q+m-1)-\varepsilon$         \\
                               & Distance, position, and values & Const.     & $1$       &                  $-$        \\
                               \midrule
\multirow{5}{*}{Below} & Distance                     & Exp.       & $q^{n-\varepsilon}+qn$   &          $-$ \\
                               & Position                     & Exp.       & $q^{n-\varepsilon}+q^{\varepsilon}$ & $-$ \\
                               & Distance and positions        & Exp.       & $q^{n-\varepsilon}+q\varepsilon$  & $-$ \\
                               & Positions and values (accumulation) & Lin. & $\infty$  &  $\sum_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{n-j}{n}\right)^{-1}$\\
                               & Distance, positions and values & Exp.       & $q^{n-\varepsilon}$      &  $-$         \\
                               \midrule
\multirow{5}{*}{Both} & Minimal                      & Exp.       & $q^{n-\varepsilon}+nm$  & $-$\\

                               & Distance                     & Lin.       & $nq$     &   $-$                        \\
                               & Positions                     & Exp.       &  $q^n$  &   $q^{n(1-1/q)}$                \\
                               & Distance and positions        & Lin.       &   $nq$  &   $nq(1-1/q)$                  \\
                               & Distance, positions and values & Const.    & $1$         &     $-$                   \\
                               \bottomrule
\end{tabular}
%}
\caption{Summary of all leakage exploits and their complexities, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$. The dash in the second column signifies that the worst-case complexity prevails. The average complexity of the accumulation attack assumes uniformly distributed errors across each authentication session.}
\label{Leak_table}
\end{table*}

\paragraph{The distance and the position are leaked}

% In this case, the distance and the position of the errors are given to the attacker when she tries a vector above the threshold. She performed an exhaustive search to get below the threshold in $q^{n-\varepsilon}$ steps. Then, she performs a hill-climbing attack on the faulty coordinates in $q\varepsilon$ steps. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+q\varepsilon)$.

In this case, the distance and the positions of the errors are given to the attacker when a vector below the threshold is queried.
\begin{theorem}\label{th-below-leak-dist-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance and the positions of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q\varepsilon)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
An exhaustive search is performed by the attacker to fall below the threshold in $q^{n-\varepsilon}$ steps. Subsequently, a hill-climbing attack is executed on the faulty coordinates, which takes $q\varepsilon$ steps. Therefore, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+q\varepsilon)$.\\
$\blacksquare$
\end{proof}



\paragraph{The distance, the positions, and the values are leaked}

% In this last case, the distance, the position of the errors and the value of each error is leaked. In this case, we are facing an error-correcting mechanism that allow the correction below the threshold. It is clear that the cost of this attack is equivalent to the exhaustive search to get a vector below the threshold. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon})$.

In this last case, the distance, the position of the errors, and the value of each error are leaked. 
\begin{theorem}\label{th-below-leak-dist-pos-and-val}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the position of the errors, and the value of each error below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon})$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
We are confronted with an error-correcting mechanism that allows the correction below the threshold. The cost of this attack is equivalent to the cost of an exhaustive search aiming at a vector below the threshold. As a result, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon})$.
\\
$\blacksquare$
\end{proof}



\subsection{Leakage Below and Above the Threshold}
\label{both}
% In this section, we consider the last scenario, which is the leakage independent of the threshold. In other words, given a vector $x$ hidden, the submission of $y$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge.
The last scenario is considered, which involves a leakage independent of the threshold. In other words, when a hidden vector $x$ is targeted, the queried vector $y$ to the $\sigma_{x,\varepsilon}$ oracle may result in the leak of additional information. Most of the reasoning comes from the previous cases.


\paragraph{Minimal Leakage (single bit of information leakage)}
This case is the same for the three possible scenarios (above, below, and both). 
\begin{theorem}\label{th-both-minimal}
    Given $\varepsilon$ a threshold, $x$ a vector in $\mathbb{Z}_q^n$ and a fuzzy matcher $\Xi$, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+nm)$ queries to $\sigma_{x,\epsilon}$, with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.       
\end{theorem}
\begin{proof}
The best chance for the attacker is to find a vector in the ball of $x$. Then, she performs the center search attack~\cite{pagnin2014leakage}. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+nm)$ with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
\\
$\blacksquare$
\end{proof}



\paragraph{Leakage of Distance}
When the distance is given to the attacker, she can perform a hill-climbing attack in $O(nq)$. This is the classical setup for a hill-climbing attack~\cite{lasry2018methodology}.
\begin{theorem}\label{th-both-dist-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, an attacker can retrieve $x$ in $O(nq)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}


\paragraph{Leakage of Position(s)}
In this case, the extra information given to the attacker is the positions of the errors, but the corresponding values remain secret.
\begin{theorem}\label{th-both-pos-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors, an attacker can retrieve $x$ in an average number of $O(q^{n(1-1/q)})$ (resp. a worst-case number of $O(q^{n})$) queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
She has to perform an exhaustive search for the erroneous bits. Hence, the average complexity of the attack to recover $x$, in this case, is $O(q^{n(1-1/q)})$, while the worst case complexity is $O(q^{n})$.
\\
$\blacksquare$
\end{proof}


\paragraph{Leakage of Distance and Position(s)}
In this case, the distance and the positions of the errors are given to the attacker when she guesses a vector.
\begin{theorem}\label{th-both-dist-and-pos-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks  the distance and the positions of the errors, an attacker can retrieve $x$ in an average number of $O(qn(1-1/q))$ (resp. a worst-case number of $O(qn)$) queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
She has to perform a hill-climbing attack on the erroneous values.
Hence, the average complexity of the attack to recover $x$ in this case is $O(qn(1-1/q))$, while the worst-case complexity is $O(qn)$.
\\
$\blacksquare$
\end{proof}


\paragraph{Leakage of Distance, Position(s) and value(s)}
In this last case, the distance, the positions of the errors and corresponding values are leaked. 
\begin{theorem}\label{th-both-dist-pos-and-val-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the positions of the errors and their values, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
In this case, it is clear that the complexity is in $O(1)$.


Information leakage is related to the properties and the design of the obfuscated distance.
Attacks for each leakage are summarized in Table~\ref{Leak_table}.



\section{Conclusion}
\label{Conclu}
% In this paper, information leakage of a fuzzy matcher was investigated, and the security loss associated with the best generic attack was evaluated. Scenarios of distance leakage, error position leakage, distance and position leakage, and distance, position, and error value leakage were explored for all three possible setups, \textit{i.e.}, above the threshold, below the threshold, and both. It was found that many scenarios significantly impact security. This paper provides insights into this security loss in the event of information leakage and proposes a straightforward attack to exploit it.
Our investigation into the information leakage of a fuzzy matcher has shed light on critical security vulnerabilities that arise under various scenarios. By evaluating the impact of different types of leakage, including distance, error position, and error value, we have gained insights into the potential risks posed to data privacy and security in practical applications. 

Our analysis encompasses all possible setups, both above and below the threshold, allowing us to identify specific conditions under which information leakage can have a substantial effect on the overall security of the system. The simplicity and efficacy of the proposed attack for exploiting information leakage underscore the importance of actively addressing potential vulnerabilities for any fuzzy matcher in particular when the leaked information is above the threshold or both above and below the threshold.
%Moreover, the presented attacks, which involve exhaustive search, can be theoretically enhanced using techniques such as \textit{set-covering} and \textit{sampling without replacement}, as demonstrated by Pagnin \textit{et al.}~\cite{pagnin2014leakage}. This has not been discussed because the \textit{set-covering} is an NP-Hard problem which makes the attack in question unusable.
Furthermore, the attacks presented in this study, relying on exhaustive search, have the potential for theoretical improvement by using techniques such as \textit{set-covering} and \textit{sampling without replacement}, as shown by Pagnin \textit{et al.}~\cite{pagnin2014leakage}. %However, it is essential to note that the feasibility of the mentioned approach is blocked due to the NP-hard nature of the \textit{set-covering} problem, rendering the attack impractical. 
However, it is noteworthy to mention that the feasibility of the aforementioned approach is hindered by the NP-hard nature of the \textit{set-covering} problem, which renders the attack impractical.
It is important to highlight that the leakage below the threshold does not significantly hurt the security of the fuzzy matcher while the leakage above significantly decreases the security.
% Ultimately, our research underscores the significance of investigating information leakage in cryptographic systems and highlights the need for continued exploration and development of cryptographic primitives that can resist side-channel attacks and mitigate potential information leaks effectively.
Ultimately, our research emphasizes the critical importance of exploring information leakage in cryptographic systems, highlighting the ongoing necessity for the development of robust cryptographic primitives capable of withstanding side-channel attacks and effectively mitigating potential information leaks.

% The accumulation attack we examined presumes uniformly distributed errors across each authentication session. To our knowledge, there is no existing literature that offers an analysis of the distribution of these errors. In reality, certain errors could occur more frequently. A skewed distribution of the errors could largely increase the expected number of required authentications from the genuine client. 
The accumulation attack we investigated is based on the assumption of errors uniformly distributed throughout each authentication session. As far as we are aware, no previous studies provide an analysis of how these errors are distributed. In practical scenarios, some errors might manifest more frequently. If the distribution of errors is skewed, this could substantially increase the expected number of authentications required from the legitimate user so that the server fully recovers the hidden vector.

\section*{Acknowledgement}
The authors acknowledge the support of the French Agence Nationale de la Recherche (ANR), under grant ANR-20-CE39-0005 (project PRIVABIO).

%\newpage
\bibliographystyle{unsrt}
\bibliography{biblio}

\end{document}
