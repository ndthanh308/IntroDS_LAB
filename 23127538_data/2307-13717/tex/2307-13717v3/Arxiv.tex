\documentclass[10pt,conference]{IEEEtran}
%\documentclass[10pt,journal]{IEEEtran}
\IEEEoverridecommandlockouts
%\usepackage[english]{babel}
%math
%\usepackage{geometry}
\usepackage{amsmath,amsfonts,stmaryrd,amssymb}
%\usepackage{xcolor}
\usepackage{extarrows}
\usepackage{todonotes}
\usepackage{bm}
\usepackage{caption}
\usepackage{paralist}
\usepackage{float}
%\usepackage{times}
\usepackage{url}
%\usepackage{natbib}

%\usepackage[subtle]{savetrees}
%\usepackage[moderate]{savetrees}
%\usepackage[extreme]{savetrees}
\usepackage{booktabs} % For formal tables

%tikz -------------------------------------
\usepackage{tikz}
\usetikzlibrary{shapes}
\newcommand{\f}{ \draw[->,>=latex]}
\usetikzlibrary{decorations.markings}
\usepackage{tkz-base,tkz-fct}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
%------------------------------------------
%cryptocode
\usepackage{cryptocode}

%list
\usepackage{enumitem}

%sout
\usepackage[normalem]{ulem}

%todo
%\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%\let\svtodo\todo\renewcommand\todo[1]{\svtodo[inline]{#1}}

% %for dashed line in tabular
% \usepackage{arydshln}
% \usepackage{pifont}
% \usepackage{verbatim}
\usepackage{hyperref}
\usepackage{multirow}
% \usepackage{chngpage}
% \usepackage{lipsum}
% \usepackage{booktabs}

\usepackage{tabularx}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

% Type macros:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\party}[1]{\ensuremath{\mathit{#1}}}  % Parties are just in math font
\newcommand{\poracle}[2]{\ensuremath{\pi_{\myuser{#1}}^{\myuser{#2}}}} % Party oracles. Lower index for party, upper index for session number

\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\binset}[1]{\ensuremath{\{0,1\}^{#1} }}
\newcommand{\mystate}[2]{\ensuremath{\msg{st}_{\mathsf{#1}}^{#2}}} % Party oracles. Lower index for session number, upper index for party (type)

\newcommand{\myphase}{\ensuremath{\mathsf{phase}}}

\newcommand{\msg}[1]{\ensuremath{\mathsf{#1}}} % Protocol messages are in SF
\providecommand{\primitive}[1]{\ensuremath{\textnormal{#1}}} % primitives are in normal font

\newcommand{\alg}[1]{\ensuremath{\mathtt{a{#1}}}} % algorithms are in TT
\newcommand{\oracle}[1]{\ensuremath{\mathsf{o{#1}}}}

\newcommand{\makett}[1]{\ensuremath{\mathtt{{#1}}}} % algorithms are in TT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Parties:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myparty}{\party{P}}

\newcommand{\myuser}[1]{\party{#1}}
\newcommand{\mysu}{\party{\hat{S}}}


\newcommand{\myalice}{\party{A}}
\newcommand{\mybob}{\party{B}}
\newcommand{\myA}{\myalice}
\newcommand{\myB}{\mybob}

\newcommand{\id}{\ensuremath{\mathsf{ID}}}
\newcommand{\myid}[1]{\ensuremath{{\myuser{#1}}}}
\newcommand{\idp}{\ensuremath{{P} }}
\newcommand{\idq}{\ensuremath{{Q} }}
\newcommand{\elechat}{\ensuremath{\poracle{P}{Q}}}
\newcommand{\aux}{\ensuremath{\mathsf {AD}}}


\newcommand{\myP}{\ensuremath{\party{P}}}
\newcommand{\myQ}{\ensuremath{\party{Q}}}
\newcommand{\myR}{\ensuremath{{\party{R}[s]}}}
\newcommand{\myS}{\ensuremath{{\party{S}[s]}}}

\newcommand{\PARTIES}{\set{P}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Attributes:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\mystage}{\ensuremath{\mathsf{stages}}}
\newcommand{\pstage}[2]{\ensuremath{\poracle{#1}{#2}.\mystage}}

\newcommand{\ptau}[2]{\ensuremath{\poracle{#1}{#2}.T}}
\newcommand{\annosent}{\ensuremath{\mathsf{SentM}}}
\newcommand{\annorec}{\ensuremath{\mathsf{RecM}}}

\newcommand{\ptaurec}[2]{\ensuremath{\ptau{#1}{#2}_{\annorec}}}
\newcommand{\ptausent}[2]{\ensuremath{\ptau{#1}{#2}_{\annosent}}}
\newcommand{\pastptau}[3]{\ensuremath{\ptau{#1}{#2}[#3]}}


\newcommand{\freshbit}[2]{\ensuremath{\poracle{#1}{#2}.\phi}}
\newcommand{\statusbit}[2]{\ensuremath{\poracle{#1}{#2}.{\sf status}}}

\newcommand{\bitreject}{\ensuremath{0}}
\newcommand{\bitaccept}{\ensuremath{1}}
\newcommand{\bitindec}{\ensuremath{\bot}}
\newcommand{\testbit}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{b}[#3]}}
\newcommand{\authbit}[2]{\ensuremath{\poracle{#1}{#2}.\alpha}}
\newcommand{\prole}[2]{\ensuremath{\poracle{#1}{#2}.\msg{role}}}
\newcommand{\roleinit}{\ensuremath{\texttt{Initiator}}}
\newcommand{\roleresp}{\ensuremath{\texttt{Responder}}}
\newcommand{\myrole}{\textnormal{\ensuremath{\texttt{role}}}}

\newcommand{\pastauthbit}[3]{\ensuremath{\poracle{#1}{#2}.\alpha[#3]}}

\newcommand{\pid}{\ensuremath{\mathsf{pid}}}
\newcommand{\sid}{\ensuremath{\mathsf{sid}}}

\newcommand{\psid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{sid}}}
\newcommand{\ppid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{pid}}}

\newcommand{\pastpstate}[3]{\ensuremath{\poracle{#1}{#2}.[#3]}}

\newcommand{\nbparties}{\ensuremath{\mathsf{n}_\PARTIES}}

\newcommand{\qtype}{\ensuremath{\mathsf{q.type}}}
\newcommand{\qinput}{\ensuremath{\mathsf{q.input}}}
\newcommand{\qresp}{\ensuremath{\mathsf{q.rsp}}}

\newcommand{\prchp}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{rchpk}[#3]}} % the public rch key of stage #3 for #1
\newcommand{\pfrec}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{rec}}}



%=====================================
% SAID
%=======================================

\newcommand{\said}{\textsf{SAID}}
\newcommand{\imam}{\textsf{iMAM}}
\newcommand{\SAIDmsk}{\ensuremath{\msg{msk}}}
\newcommand{\SAIDrchk}{\ensuremath{\mathsf{rchk}}}
\newcommand{\SAIDrchpk}{\ensuremath{\mathsf{rchpk}}}
\newcommand{\SAIDmsg}{\ensuremath{\mathsf{M}}}
\newcommand{\SAIDct}{\ensuremath{\mathsf{C}}}
\newcommand{\KDC}{\ensuremath{{KDC}}}


%=====================================
% SCEKE
%=======================================

\newcommand{\sceke}{\textsf{SCEKE}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Keys:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\sk}{\msg{sk}}
\newcommand{\pk}{\msg{pk}}
\newcommand{\ks}{\msg{K}}
\newcommand{\ipk}[1]{\ensuremath{\mathsf{ipk}_{\myuser{#1}}}}
\newcommand{\prek}[1]{\ensuremath{\mathsf{prek}_{\myuser{#1}}}}
\newcommand{\prepk}[1]{\ensuremath{\mathsf{prepk}_{\myuser{#1}}}}
\newcommand{\ephpk}[1]{\ensuremath{\mathsf{ephpk}_{\myuser{#1}}}}
\newcommand{\ephk}[1]{\ensuremath{\mathsf{ephk}_{\myuser{#1}}}}

\newcommand{\epk}[1]{\ensuremath{\mathsf{Epk}_{\myuser{#1}}}}
\newcommand{\esk}[1]{\ensuremath{\mathsf{ek}_{\myuser{#1}}}}


\newcommand{\ik}[1]{\ensuremath{\mathsf{ik}_{\myuser{#1}}}}
\newcommand{\presk}[1]{\ensuremath{\mathsf{presk}_{\myuser{#1}}}}
\newcommand{\ephsk}[2]{\ensuremath{\mathsf{ephsk}_{\myuser{#1}}^{#2}}}

\newcommand{\sidsk}[2]{\ensuremath{\mathsf{sidsk}_{\myuser{#1}}^{#2}}}
\newcommand{\sidpk}[2]{\ensuremath{\mathsf{sidpk}_{\myuser{#1}}^{#2}}}


\newcommand{\sidcsk}[2]{\ensuremath{\myuser{#1}.X\sid}}
\newcommand{\sidcsgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.X\textsf{stage}}}
\newcommand{\sidssgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.\mathtt{1}\textsf{stage}}}


\newcommand{\currentck}[2]{\ensuremath{\poracle{#1}{#2}.\msg{bk}}}
\providecommand{\currentmk}[2]{\ensuremath{ \poracle{#1}{#2}.k[s]}}
\providecommand{\currentrk}[2]{\ensuremath{ \poracle{#1}{#2}.\rk{s}}}

\newcommand{\pastck}[3]{\ensuremath{\poracle{#1}{#2}.\msg{ck}[{#3}]}}

\newcommand{\msgk}[3]{\ensuremath{\myuser{#1}.\mathsf{k}^{{#2},{#3}}}}

\newcommand{\msk}{\ensuremath{\msg{msk}}}
%\newcommand{\msk}{\ensuremath{\msg{msk}}}
\newcommand{\mpk}{\ensuremath{\msg{mpk}}}


\newcommand{\rchk}[2]{\ensuremath{\mathsf{rchk}_{\myuser{#1}}^{#2}}}
\newcommand{\rchpk}[2]{\ensuremath{\mathsf{Rchpk}_{\myuser{#1}}^{#2}}}
%super ratchet keys
\newcommand{\RCHK}[2]{\ensuremath{\mathsf{t}^{\myuser{#1}}_{#2}}}
\newcommand{\RCHPK}[2]{\ensuremath{\mathsf{T}^{\myuser{#1}}_{#2}}}

\newcommand{\skm}[1]{\ensuremath{\mathsf{SKM}_{\myuser{#1}}}}
\newcommand{\pkm}[1]{\ensuremath{\mathsf{PKM}_{\myuser{#1}}}}

\newcommand{\ski}[1]{sk_{#1}}
\newcommand{\pki}[1]{pk_{#1}}

\newcommand{\rk}[1]{\ensuremath{\mathsf{rk}_{#1}}}
\newcommand{\ck}[2]{\ensuremath{\mathsf{ck}_{\myuser{#1}}^{#2}}}
\newcommand{\tagk}[1]{\ensuremath{\mathsf{tag}^{#1}}}
\newcommand{\mk}[2]{\ensuremath{\mathsf{mk}_{\myuser{#1}}^{#2}}}

\newcommand{\expo}[2]{\ensuremath{\mathsf{(#1)}^{#2}}}

%key space
\newcommand{\kspace}{\ensuremath{\mathcal{K}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Protocol messages//variables:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\pastlist}{\set{D}}
%\newcommand{\rand}{\stackrel{{}_{\$}}{\leftarrow}}
\newcommand{\rand}{\ensuremath{\xleftarrow{\$}}}
\newcommand{\atrandom}{\ensuremath{{\leftarrow}_{\text{R}}}}
\newcommand{\expogroup}{\ensuremath{\mathbb{Z}_\myprime}}
\newcommand{\dhgroup}{\ensuremath{\mathbb{G}_\myprime}}

\newcommand{\ms}[1]{\ensuremath{\msg{ms}_{\myuser{#1}}}}
\newcommand{\ltstate}[1]{\ensuremath{\mathsf{lt.st}_{#1}}}
\newcommand{\ephstatek}{\ensuremath{\mathsf{var}}}
\newcommand{\keytypes}{\ensuremath{\mathsf{ktypes}}}
\newcommand{\keyset}{\ensuremath{\mathsf{key.set}}}
\newcommand{\ephstateK}{\mathcal{V}}
\newcommand{\ephstate}[2]{\ensuremath{\poracle{#1}{#2}.\ephstatek}}
\newcommand{\myad}{\ensuremath{\msg{AD}}}

\newcommand{\pastephstate}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{keys}[#3]}}

\newcommand{\pubstate}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{pub.st}}}

\newcommand{\emptystring}{\ensuremath{\varepsilon}}

\newcommand{\KDF}[1]{\ensuremath{{\mathsf{KDF}}_{#1}}}
\newcommand{\HKDF}[1]{\ensuremath{{\mathsf{HKDF}}_{#1}}}
\newcommand{\HMAC}{\ensuremath{\mathsf{HMAC}}}

\newcommand\extracteval[1]{\mathsf{HKDF}.\makett{Ext}(#1)}
\newcommand\expandeval[1]{\mathsf{HKDF}.\makett{XP}(#1)}
\newcommand{\pair}[1]{\ensuremath{e(#1)}}

\newcommand{\trsc}[3]{\poracle{#1}{#2}.Tr[#3]} % transcript for a stage #3, on user #1's side for the convo with #2


%=====================================
% Algorithms
%-=====================================

\newcommand{\fivegp}{\textsf{5GAKE}$_{3}$}
\newcommand{\myprimitive}{\texttt{SCEKE}}
\newcommand{\xnplus}{\texttt{XN}$^{+}$}

\newcommand{\algStart}{\ensuremath{\alg{Start}}}% CRISTINA
\newcommand{\algSend}{\ensuremath{\alg{Send}}}% CRISTINA
\newcommand{\algRKGen}{\ensuremath{\alg{RGen}}}
\newcommand{\algKGen}{\ensuremath{\alg{KeyGen}}}
\newcommand{\algSetup}{\ensuremath{\alg{Setup}}}
\newcommand{\protUReg}{\ensuremath{\Pi_{\mathtt{UReg}}}}
\newcommand{\protStart}{\ensuremath{\Pi_{\mathtt{Start}}}}


\newcommand{\algReceive}{\ensuremath{\alg{Receive}}}
\newcommand{\algextract}{\ensuremath{\makett{Extr}}}

\newcommand{\algttSetup}{\ensuremath{\makett{Setup}}}
\newcommand{\algSIGN}{\ensuremath{\makett{SIGN}}}
\newcommand{\algsign}{\ensuremath{\makett{Sign}}}
\newcommand{\algverify}{\ensuremath{\makett{Vrfy}}}
\newcommand{\algenc}[1]{\ensuremath{\makett{Enc}\left(#1\right)}}
\newcommand{\algdec}[1]{\ensuremath{\makett{Dec}\left(#1\right)}}
\newcommand{\algprf}{\ensuremath{\makett{PRF}}}
\newcommand{\algae}{\ensuremath{\makett{AE}}}
\newcommand{\algaead}{\ensuremath{\makett{AEAD}}}
\newcommand{\algaeadenc}{\ensuremath{\algaead \ensuremath{\makett{.Enc}}}}
\newcommand{\algaeaddec}{\ensuremath{\algaead \ensuremath{\makett{.Dec}}}}

\newcommand{\algmess}{\ensuremath{\makett{Message}}}
\newcommand{\algnonce}{\ensuremath{\makett{Nonce}}}
\newcommand{\algheader}{\ensuremath{\makett{Header}}}

\newcommand{\algmac}{\ensuremath{\makett{MAC}}}

\newcommand{\algaegen}{\ensuremath{\makett{Gen}}}
\newcommand{\algaeinit}{\ensuremath{\makett{AE.Init}}}
\newcommand{\algaedec}{\ensuremath{\makett{AE.Dec}}}
\newcommand{\algaeenc}{\ensuremath{\makett{AE.Enc}}}
\newcommand{\algaestE}{\ensuremath{\mathsf{st}_{\mathsf{E}}}}
\newcommand{\algaestD}{\ensuremath{\mathsf{st}_{\mathsf{D}}}}
\newcommand{\insync}{\ensuremath{\operatorname{\mathsf{in-sync}}}}

\newcommand{\algmain}{\ensuremath{\alg{Main.Exp}}}

\newcommand{\oEnc}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDec}{\ensuremath{\oracle{ADec}}}
\newcommand{\oRDec}{\ensuremath{\oracle{RoR.ADec}}}
\newcommand{\oMess}{\ensuremath{\oracle{Messaging}}}
\newcommand{\oSign}{\ensuremath{\oracle{Sign}}}

\newcommand{\algcommit}{\ensuremath{\makett{Commit}}}
\newcommand{\algmaul}{\ensuremath{\makett{Maul}}}
\newcommand{\algrerand}{\ensuremath{\makett{ReRand}}}
\newcommand{\algopen}{\ensuremath{\makett{Open}}}

\newcommand{\mylist}[1]{\ensuremath{\mathcal{L}_{\mathsf{#1}}}}
\newcommand{\revlist}{\mylist{rev}}
\newcommand{\potlist}{\mylist{maybe}}
\newcommand{\corrlist}{\mylist{corr}}
\newcommand{\tmlist}{\mylist{tm}}
\newcommand{\mallist}{\mylist{mal}}
\newcommand{\lorlist}{\mylist{LoR}}
\newcommand{\cipherlist}{\mylist{ctxt}}
\newcommand{\userlist}{\mylist{usr}}
\newcommand{\sessionlist}{\mylist{\pi}}
\newcommand{\qlist}{\mylist{sign}}
\newcommand{\enclist}{\mylist{enc}}
\newcommand{\qulist}{\mylist{query}}

\newcommand{\shu}[3]{\ensuremath{\mathsf{SHU}(\poracle{#1}{#2},{#3})}} % to know if Send was given honest AD
\newcommand{\rhu}[3]{\ensuremath{\mathsf{RHU}(\poracle{#1}{#2},{#3})}} % to know if Receive was given honest AD


\providecommand{\addtolist}{\ensuremath{\hookleftarrow}}

\providecommand{\successor}[1]{\ensuremath{ {\sf next}(#1)}}
\providecommand{\rdec}{\ensuremath{m}}
\providecommand{\renc}{\ensuremath{c}}
\providecommand{\achoice}{\ensuremath{\beta}}

\providecommand{\forgery}[1]{\ensuremath{{#1}^*}}

\newcommand{\myrelation}{\mathcal{R}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Oracles:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\oUReg}{\ensuremath{\oracle{UReg}}}
\newcommand{\oInit}{\ensuremath{\oracle{Start}}}
\newcommand{\oSend}{\ensuremath{\oracle{Send}}}
\newcommand{\oReceive}{\ensuremath{\oracle{Receive}}}
\newcommand{\oReveal}{\ensuremath{\oracle{Reveal}}}
\newcommand{\oRevealCS}{\ensuremath{\oracle{Reveal.XStage}}}
\newcommand{\oRevealSS}{\ensuremath{\oracle{Reveal.\mathtt{1}Stage}}}
\newcommand{\oCorrupt}{\ensuremath{\oracle{Reveal.XSid}}}
\newcommand{\oEncrypt}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDecrypt}{\ensuremath{\oracle{ADec}}}
\newcommand{\oHSM}{\ensuremath{\oracle{AccessSK}}}
\newcommand{\oracleSet}{\ensuremath{\mathcal{O}}}
\newcommand{\oRevMed}{\ensuremath{\oracle{RevMedKey}}}

\newcommand{\oTest}{\ensuremath{\oracle{Test}}}
\newcommand{\ROM}{\ensuremath{\mathcal{RO}}}

\newcommand{\danger}[1]{\mathsf{Danger(#1)}}
\newcommand{\actdan}[1]{\mathsf{Act.Dan(#1)}}
\newcommand{\hijack}[1]{\mathsf{Hijack(#1)}}
\newcommand{\leak}[1]{\mathsf{Leak(#1)}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Adversaries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\adv}{\ensuremath{\mathcal{A}}}
\newcommand{\adversary}{\ensuremath{\mathcal{A}}}
\newcommand{\challenger}{\ensuremath{\mathcal{C}}}
\newcommand{\bdv}{\ensuremath{\mathcal{B}}}
\newcommand{\cdv}{\ensuremath{\mathcal{C}}}
\newcommand{\ddv}{\ensuremath{\mathcal{D}}}
\newcommand{\edv}{\ensuremath{\mathcal{E}}}
\newcommand{\fdv}{\ensuremath{\mathcal{F}}}
\newcommand{\gdv}{\ensuremath{\mathcal{G}}}
\newcommand{\idv}{\ensuremath{\mathcal{I}}}

\providecommand{\advstate}[1]{\ensuremath{\mathsf{state}_{#1}}}

\newcommand{\simulator}{\ensuremath{\mathsf{Sim}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Advantages & security properties
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\secpar}{\ensuremath{1^\lambda}}
\newcommand{\spar}{\ensuremath{\mathsf{s\param}}}
\newcommand{\ppar}{\ensuremath{\mathsf{p\param}}}
\newcommand{\param}{\ensuremath{\mathsf{param}}}

\newcommand{\myprot}{\ensuremath{\Pi}}

%\newcommand{\proto}[2]{\ensuremath{\mathsf{\Pi^{\myuser{#1}}_{\myuser{#2}}}}}

\newcommand{\scprop}{\ensuremath{\mathsf{SC}}}
\newcommand{\sacce}{\ensuremath{\mathsf{SACCE}}}
\newcommand{\acce}{\ensuremath{\mathsf{ACCE}}}
\newcommand{\ake}{\ensuremath{\mathsf{AKE}}}
\newcommand{\sake}{\ensuremath{\mathsf{S\text{-}AKE}}}

\newcommand{\expgame}[1]{\ensuremath{\mathsf{Exp}_\myprot^{#1}(\lambda ,\adv)}}
\newcommand{\pcsakegame}{\ensuremath{\expgame{\mathsf{PCS\text{-}AKE}}}}
\newcommand{\ooogame}{\ensuremath{\expgame{\mathsf{MLR}}}}



\newcommand{\pfsgame}{\ensuremath{\expgame{\mathsf{AKE}}}}
\newcommand{\exfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\pfsexfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\eufcmagame}{\ensuremath{\expgame{\mathsf{EUF-CMA}}}}
\newcommand{\kdfgame}{\ensuremath{\expgame{\mathsf{KDF}}}}
\newcommand{\lhaegame}{\ensuremath{\expgame{\mathsf{LHAE}}}}
\newcommand{\aeadgame}{\ensuremath{\expgame{\mathsf{AEAD}}}}

\newcommand{\akefwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}S\text{-}AKE}}}}}
\newcommand{\pfsfwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}AKE}}}}}


\newcommand{\eaprop}{\ensuremath{\mathsf{EA}}}
\newcommand{\accprop}{\ensuremath{\mathsf{Acc}}}
\newcommand{\csoundprop}{\ensuremath{\mathsf{CSound}}}

\newcommand{\csound}{\ensuremath{\mathsf{CSound}}}

\newcommand{\nbparty}{\ensuremath{\mathsf{n_P}}}
\newcommand{\nbstages}{\ensuremath{\mathsf{n_S}}}
\newcommand{\nbinstances}{\ensuremath{\mathsf{n_\pi}}}
\newcommand{\nbmedkeys}{\ensuremath{\mathsf{n_{\prek{}}}}}


\newcommand{\Prob}{\mathbb{P}}

\newcommand{\gadvantage}[1]{\ensuremath{\mathsf{Adv}_{#1}}}
\newcommand{\padvantage}[3]{\ensuremath{\mathsf{Adv}^{#3}_{#2}({#1})}}
\newcommand{\advsc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\scprop}}}
\newcommand{\advea}[1]{\ensuremath{\padvantage{#1}{\myprot}{\eaprop}}}
\newcommand{\advacc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\accprop}}}
\newcommand{\advcsound}[1]{\ensuremath{\padvantage{#1}{\myprot}{\csoundprop}}}
%\newcommand{\advsake}[1]{\ensuremath{\padvantage{#1}{\myprot}}}
\newcommand{\advunf}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{Unf}}}}
\newcommand{\advprop}[1]{\ensuremath{\padvantage{#1}{\myprot}{\mathsf{prop}}}}

\newcommand{\advake}[1]{\ensuremath{\padvantage{#1}{\Psi}{\mathsf{AKE}}}}

\newcommand{\advpcs}[1]{\ensuremath{\padvantage{#1}{\Pi}{\mathsf{PCS-AKE}}}}


\newcommand{\advcres}[1]{\ensuremath{\padvantage{#1}{H}{\mathsf{C.Res}}}}
\newcommand{\adveufcma}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{EUF-CMA}}}}

\newcommand{\advgdh}[1]{\ensuremath{\padvantage{#1}{\mathsf{}}{\mathsf{GDH}}}}


\newcommand{\advlhae}[1]{\ensuremath{\padvantage{#1}{\mathsf{\algaead}}{\mathsf{LHAE}}}}

\newcommand{\advsacce}[2]{\ensuremath{\padvantage{#1}{#2}{\sacce}}}
\newcommand{\advacce}[2]{\ensuremath{\padvantage{#1}{#2}{\acce}}}

\newcommand{\advpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{AKE}}}}
\newcommand{\advsake}[2]{\ensuremath{\padvantage{#1}{#2}{\sake}}}


\newcommand{\advexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}
\newcommand{\advpfsexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}


\newcommand{\advfwpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW\text{-}PFS}}}}
\newcommand{\advfwsake}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW}\text{-}\sake}}}
\newcommand{\advAKE}[2]{\ensuremath{\padvantage{#1}{#2}{\ake}}}
\newcommand{\advae}[1]{\ensuremath{\padvantage{#1}{\mathsf{AE}}{\mathsf{stLHAE}}}}
\newcommand{\advaead}[1]{\ensuremath{\padvantage{#1}{\mathsf{Enc,Dec}}{\mathsf{AEAD}}}}

\newcommand{\clock}{\ensuremath{\mathsf{clock}}}
\newcommand{\game}[1]{\ensuremath{\mathbb{G}\mathsf{ame}_{#1}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pname}{On the Leakage of Fuzzy Matchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Layout and style:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\myparagraph}[1]{\vspace{2mm} \noindent \textbf{#1.}}
\newcommand{\mysubpar}[1]{\noindent \hspace{1mm} \textbf{\underline{#1.}} \hspace{1mm}}
\newcommand{\gamehop}[1]{\ensuremath{\mathbb{G}_{#1}} \vspace{1mm}}
\newcommand{\accro}{\ensuremath{\mathsf{3(S)ACCE}}}
\newcommand{\nth}[1]{\ensuremath{{#1}\textnormal{-th}}}

\newcommand{\exec}{\ensuremath{\leftarrow}}

\newcommand{\ie}{\emph{i.e.}, }
\newcommand{\eg}{\emph{e.g.}, }
\newcommand{\etal}{\emph{et al.}}

\newcommand{\Gr}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\Zp}{\mathbb{Z}_p}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\mymax}[2]{\ensuremath{\textsc{MAX}\big[#1, #2\big]}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% proocol's variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\alghash}{\ensuremath{\makett{H}}}
\newcommand{\randomness}{\ensuremath{r}}
\newcommand{\gtor}{\ensuremath{h}}
\newcommand{\generator}{\ensuremath{g}}
\newcommand{\idsign}{\ensuremath{\alg{ID}\algsign}}
\newcommand{\idverify}{\ensuremath{\alg{ID}\algverify}}
\newcommand{\abort}{\ensuremath{\msg{abort}}}
\newcommand{\concat}{\ensuremath{||}}
\newcommand{\ibe}{\ensuremath{\makett{IBE}}}



\newcommand{\ibs}{\ensuremath{\mathsf{IBSig}}}
\newcommand{\ibsSetup}{\ensuremath{\alg{IBS.Setup}}}
\newcommand{\ibsExtract}{\ensuremath{\alg{IBS.Extract}}}
\newcommand{\ibsSign}{\ensuremath{\alg{IBS.Sign}}}
\newcommand{\ibsVf}{\ensuremath{\alg{IBS.Vfy}}}

\newcommand{\ibsparams}{\ensuremath{\mathsf{IBS.ppar}}}
\newcommand{\ibsmpk}{\ensuremath{\mathsf{IBS.mpk}}}
\newcommand{\ibsmsk}{\ensuremath{\mathsf{IBS.msk}}}

\newcommand{\ibssk}{\ensuremath{\mathsf{IBS.sk}}}
\newcommand{\ibsusk}[1]{\ensuremath{\ibssk_{\myid{#1}}}}

\newcommand{\idmpk}{\ensuremath{\mathsf{ID.mpk}}}
\newcommand{\idmsk}{\ensuremath{\mathsf{ID.msk}}}
\newcommand{\idsk}[1]{\ensuremath{\mathsf{ID.sk}_{#1}}}
\newcommand{\mytag}[1]{\ensuremath{\mathsf{tag}^{#1}}}

\newcommand{\meta}{\ensuremath{\mathsf{meta}}}





\newcommand{\idenc}{\ensuremath{\makett{ID}\algenc}}
\newcommand{\signature}{\ensuremath{\mathsf{sgn}}}
\newcommand{\AD}{\textnormal{AD}}
\newcommand{\M}{M}
\newcommand{\dhoutput}{\ensuremath{\Delta}}
\newcommand{\dhout}[1]{\ensuremath{\mathsf{DH}^{#1}}}
% signature on stage x,y
\newcommand{\sig}[1]{\ensuremath{\sigma_{#1}}}
%%%%%%%%%%%%%%
%% ENVIRONMENTS %%
%%%%%%%%%%%%%%
\newtheorem{definition}{Definition}      %commented for LNCS
\newtheorem{theorem}{Theorem}      %commented for LNCS
\newtheorem{proof}{Proof}

%scale (equation)
\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% 5G-AKA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\aka}{\ensuremath{\mathsf{AKA}}}
\newcommand{\topc}{\ensuremath{\mathsf{Top}_C}}
\newcommand{\UE}{\party{UE}}
\newcommand{\HN}{\party{HN}}
\newcommand{\SN}{\party{SN}}
\newcommand{\gNB}{\party{gNB}}
\newcommand{\core}{\party{Core}}

\newcommand{\USIM}{\ensuremath{\mathsf{USIM}}}
\newcommand{\TMSI}{\ensuremath{\mathsf{TMSI}}}
\newcommand{\SUPI}{\ensuremath{\mathsf{SUPI}}}
\newcommand{\SUCI}{\ensuremath{\mathsf{SUCI}}}
\newcommand{\GUTI}{\ensuremath{\mathsf{GUTI}}}
\newcommand{\AG}{Assign-\ensuremath{\mathsf{GUTI}}}
\newcommand{\IMSI}{\ensuremath{\mathsf{IMSI}}}
\newcommand{\SQNU}{\ensuremath{\mathsf{SQN_U}}}
\newcommand{\SQNN}{\ensuremath{\mathsf{SQN_H}}}
\newcommand{\SQNs}{\ensuremath{\mathsf{SQN_s}}}
\newcommand{\pubenc}[2]{\ensuremath{\{#1\}^{#2}_\pk}}

\newcommand{\mycard}{\ensuremath{\mathsf{U}}}
%\newcommand{\sk}{\ensuremath{\mathsf{sk}}}
\newcommand{\sksub}[1]{\ensuremath{\sk_{#1}}}
\newcommand{\skop}{\ensuremath{\sk_\mathsf{op}}}
\newcommand{\sqn}[1]{\ensuremath{\mathsf{SQN_{#1}}}}
\newcommand{\myop}{\ensuremath{\mathsf{H}}}
\newcommand{\av}{\ensuremath{\mathsf{AV}}}
\newcommand{\autn}{\ensuremath{\mathsf{Autn}}}
\newcommand{\res}{\ensuremath{\mathsf{Res}}}
\newcommand{\akey}{\ensuremath{\mathsf{AK}}}
\newcommand{\myterm}{\ensuremath{\mathsf{T}}}
\newcommand{\Mac}{\ensuremath{\mathsf{Mac}}}
\newcommand{\Macsn}{\ensuremath{\Mac_{\mathsf{\myterm}}}}
\newcommand{\MAC}{\ensuremath{\mathsf{MAC}}}
\newcommand{\ckey}{\ensuremath{\mathsf{CK}}}
\newcommand{\ikey}{\ensuremath{\mathsf{IK}}}
\newcommand{\Macns}{\ensuremath{\Mac_{\mathsf{\mycard}}}}
\newcommand{\amf}{\ensuremath{\mathsf{AMF}}}
\newcommand{\RAND}[1]{\ensuremath{\mathsf{R}_{#1}}}
\newcommand{\nametl}{\ensuremath{\mathsf{VLR}}}
\newcommand{\namebackend}{\ensuremath{\mathsf{HLR}}}
\newcommand{\lai}{\ensuremath{\mathsf{LAI}}}
\newcommand{\uid}{\ensuremath{\mathsf{UID}}}
\newcommand{\func}[1]{\ensuremath{#1}}
\newcommand{\funcF}[1]{\ensuremath{\func{\mathcal{F}}_{#1}}}
\newcommand{\funcFstar}[1]{\ensuremath{\funcF{#1}^*}}


\newcommand{\xor}{\ensuremath{\oplus}}

\newcommand{\stack}{\emph{5G-SCEKE}}
\newcommand{\stackplus}{\emph{5G-SCEKE$^{+}$}}



%=================================================
% Comments :
%=================================================
%\usepackage{pifont}
\newlength{\strutdepth}%
\settodepth{\strutdepth}{\strutbox}%
\newcommand{\mycomment}[3]{%
    \noindent{\bfseries
        \color{#2}{#1}\color{black}}%
    \strut\vadjust{\kern-\strutdepth%
        \vtop to \strutdepth{%
            \baselineskip\strutdepth%
            \vss\llap{{\large\color{#2}#3\quad\color{black}}}\null%
        }%
    }%
}

\newcommand{\axel}[1]{\mycomment{#1}{magenta}{Axel}}
\newcommand{\kev}[1]{\mycomment{#1}{blue}{Kevin}}
\newcommand{\pascal}[1]{\mycomment{#1}{olive}{Pascal}}
\newcommand{\leo}[1]{\mycomment{#1}{orange}{Leo}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tikz:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\link}{ \draw[<->,>=latex]}
\newcommand{\att}{ \draw[-latex,dashed,ultra thick]}

\newcommand*{\QEDB}{\null\nobreak\hfill\ensuremath{\square}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% modifications:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\removetext}[1]{{\color{red}{\sout{#1}}}}
\newcommand{\addtext}[1]{{\color{teal}{#1}}}
\newcommand{\replacetext}[2]{\removetext{#1} \addtext{#2}}

\newcommand{\serveur}[0]{\ensuremath{\mathcal{S}}}
\newcommand{\client}[0]{\ensuremath{\mathcal{C}}}
\newcommand{\pwd}[0]{\ensuremath{\mathsf{pwd}}}

\newcommand{\databio}[0]{\ensuremath{\mathsf{bio}}}
\newcommand{\helpvalue}[0]{\ensuremath{\mathcal{\nu}}}
\newcommand{\pubclient}[0]{\ensuremath{\mathsf{P_u}}}
\newcommand{\privclient}[0]{\ensuremath{\mathsf{p_u}}}

\newcommand{\pubserv}[0]{\ensuremath{\mathsf{P_s}}}
\newcommand{\privserv}[0]{\ensuremath{\mathsf{p_s}}}

\newcommand{\keyserv}[0]{\ensuremath{\mathsf{k_s}}}

\newcommand{\rw}[0]{\ensuremath{\mathsf{rw}}}
\newcommand{\hash}[1]{\ensuremath{\mathcal{H}\left(#1\right)}}
\newcommand{\authenv}[1]{\ensuremath{\mathsf{AuthEnv}\left(#1\right)}}
\newcommand{\authenvrw}[1]{\ensuremath{\mathsf{AuthEnv}_{\rw}\left(#1\right)}}
\newcommand{\aec}[0]{\ensuremath{\mathsf{c}}}
\newcommand{\cval}[0]{\ensuremath{\alpha}}
\newcommand{\sval}[0]{\ensuremath{\beta}}


\newcommand{\algen}[2]{\ensuremath{\makett{Enc}_{#1}\left(#2\right)}}

\newcommand{\algencbio}[1]{\ensuremath{\makett{Enc}_{\databio}\left(#1\right)}}
\newcommand{\algdecbio}[1]{\ensuremath{\makett{Dec}_{\databio}\left(#1\right)}}


\newcommand{\Fq}[0]{\ensuremath{\mathbb{F}_q}}
\newcommand{\Fqn}[0]{\ensuremath{\mathbb{F}_q^n}}
\newcommand{\Fdn}[0]{\ensuremath{\mathbb{F}_2^n}}
\newtheorem{theo}{Theorem}[section]
\newtheorem{rem}{Remark}[subsection]
\newtheorem{ex}{Example}[subsection]

\newcounter{protocol}
\newenvironment{protocol}[1]
{\par\addvspace{\topsep}
    \noindent
    \tabularx{\linewidth}{@{} X @{}}
    \hline
    \refstepcounter{protocol}\textbf{Protocol \theprotocol} #1 \\
    \hline}
{\\
    \hline
    \endtabularx
    \par\addvspace{\topsep}}

\newcommand{\sbline}{\\[.5\normalbaselineskip]}% small blank line



\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

\title{\pname
    %\thanks{This study was partially supported by the French ANR project ANR.}
}

\author{\IEEEauthorblockN{DURBET Axel}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne,} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
axel.durbet@uca.fr}\\
\and
\IEEEauthorblockN{THIRY-ATIGHEHCHI Kevin}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne, 
} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
kevin.atighehchi@uca.fr}\\
%\linebreakand 
\linebreakand
\IEEEauthorblockN{CHAGNON Dorine}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne,} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
dorine.chagnon@uca.fr}\\
\and
\IEEEauthorblockN{GROLLEMUND Paul-Marie}
\IEEEauthorblockA{\textit{LMBP, Université Clermont Auvergne,}\\
\textit{CNRS, UMR 6620,}\\
\textit{Aubière, France}\\
paul\_marie.grollemund@uca.fr}\\

}

\maketitle


\begin{abstract}
    In a biometric recognition system, the matcher compares an old and a fresh template to decide if it is a match or not. 
    Beyond the binary output (`yes' or `no'), more information is computed. 
    %Thus, we study the impact of the leakage of such additional information. 
    This paper provides an in-depth analysis of information leakage during distance evaluation, with an emphasis on threshold-based obfuscated distance (\textit{i.e.}, Fuzzy Matcher). Leakage can occur due to a malware infection or the use of a weakly privacy-preserving matcher, exemplified by side channel attacks or partially obfuscated designs. We provide an exhaustive catalog of information leakage scenarios as well as their impacts on the security concerning data privacy. Each of the scenarios leads to generic attacks whose impacts are expressed in terms of computational costs, hence allowing the establishment of upper bounds on the security level.
\end{abstract}

%\tableofcontents
\begin{IEEEkeywords}
Obfuscated Distance, Fuzzy Matcher, Hamming Distance, $L_1$ Distance, Information Leakage, Biometrics, Coupon Collector Problem
\end{IEEEkeywords}

\section{Introduction}\label{intro}

In cryptology, the investigation of obfuscated distance functions is still limited, and articles discussing this topic are relatively recent and scarce. An obfuscated distance function facilitates the computation of the distance between two hidden inputs by multiple parties, wherein each party gains knowledge solely of the distance while preserving the privacy of the actual inputs. These functions can be iteratively applied with various features, and one of their fundamental properties is the preservation of input privacy.

A first approach to design an obfuscated distance function involves employing homomorphic cryptography~\cite{yasuda2017secure,huang2011faster,rane2010privacy}, which enables computations to be directly applied on encrypted data without requiring decryption, thereby ensuring the confidentiality of sensitive information;
Garbled circuit~\cite{huang2011faster,bellare2012foundations,yao1986generate} is a cryptographic primitive based on symmetric encryption and oblivious transfer which is used to privately evaluate a function on encrypted inputs without revealing the inputs or the logic of the function to the evaluator. Functional Encryption~\cite{agrawal2012functional,abdalla2016better,Okamoto2012,DATTA201716IPFE,TOMIDA20202019CIP0003IPFE} enables the implementation of specific functions on encrypted data, providing privacy and enhanced security across a wide range of applications such as the distance evaluation; 
Oblivious transfer~\cite{kiraz2015security,bringer2013shade,bringer2014gshade} enables secure multiparty computation while ensuring input privacy by allowing data exchange without revealing the content; or other mathematical methods based on computational assumptions~\cite{Galbraith2019PFH,KARABINA2016NTT,fleischhacker2021robust,fleischhacker2022property}. The obfuscated distance is also employed for biometric applications, aiming at protecting the privacy of the client while maintaining the effectiveness of the biometric identification process.
These cryptographic primitives can also be designed by relying on a threshold-based obfuscated distance, related to error-correcting codes~\cite{huffman2010fundamentals}, which are designed to detect and correct errors that may arise during digital data transmission or storage, thereby ensuring reliable and precise data retrieval;
Secure sketches and fuzzy extractors~\cite{fuller2020computational,dodis2007fuzzy,wen2018robustly,dodis2008fuzzy,cheon2018reusable} are cryptographic schemes able to extract a consistent and reusable cryptographic key from noisy or biometric data, facilitating secure authentication while accommodating minor variations in the input data;
Fuzzy vaults~\cite{juels2006fuzzy} are cryptographic designs that securely store and retrieve secret information by utilizing error-correcting codes and a noisy input (\textit{e.g.} biometric data), ensuring strong protection against unauthorized access and maintaining data integrity.
All the previous functions and primitives are either founded on or encompass Fuzzy Matcher, which belongs to a subclass of evasive functions. Evasive functions~\cite{Galbraith2019PFH,barak2014obfuscation} are related to a class of functions that represent significant computational challenges for any efficient algorithm attempting to compute their output with high probability on most inputs. 
While many authors focus on fuzzy matching for the Hamming distance, this paper directly tackles the case of vectors in $\mathbb{Z}_q^n$ for the $L_1$ distance. Furthermore, our results can be extended to the Hamming distance as well.
The theoretical security of each considered function and primitive is extensively investigated and well-documented in their respective papers, including the evaluation of the difficulty for an attacker to retrieve the initially hidden input. However, the growing prevalence of side-channel attacks~\cite{HomoLeak,hashemi2023time}, implementation errors, or construction flaws~\cite{carpovLeak} has raised uncertainties about the provided security bounds. One possible concern is the partial leakage of distance calculation information, which could lead to unintended information disclosure during the execution of the function. Such inadvertent disclosures involve significant security and privacy risks, especially in sensitive applications like cryptographic protocols or data privacy frameworks (\textit{e.g.}, biometric systems).


Understanding the impact of information leakage is an important step toward safeguarding sensitive information, and an emphasis is put on this topic.

A deeper understanding of the risks related to information leakage in cryptographic systems is provided, with a specific focus on the domain of fuzzy matching.

As an example, biometric authentication requires evaluating a distance, and password authentication requires an equality test. The attacks of interest can be divided into two categories:

\begin{itemize}
\item \textit{Offline exhaustive search attacks} correspond to attacks where a
leaked but protected database is given to the attacker, but the cryptographic obfuscation mechanism used for the verification of a protected fresh vector (biometric template), or the verification of a protected (hashed) password, is not supposed to leak any information beyond its admissibility.
\item \textit{Online exhaustive search attacks} correspond to attacks where an attacker is forced to interact with the authentication server to deduce information about the target vector.  Such attacks may require malware infection on the server, in order for the attacker to retrieve additional leakage from the matcher, \textit{i.e.}, beyond the minimal information leakage (`yes' or `no').
\end{itemize}

\paragraph*{Related Works} 
Pagnin \textit{et al.}~\cite{pagnin2014leakage} demonstrated that in the context of a Fuzzy Matcher, the result of the matcher can be exploited to retrieve the hidden vector. Their work takes place in the minimal leakage, wherein only the binary output of the matcher is given to the attacker. They explained the execution of this attack and assessed its complexity. Our work shares a similar focus, as similar tools are also examined. However, we extend the analysis by taking into account the possibility of multiple additional information leaks thanks to the matching operation. 
Similar to the aforementioned work, the proposed attacks aim at recovering the original data, which, in the context of biometrics, corresponds to compromising the privacy of the biometric data. This type of attack is considered the most devastating for such systems, as evidenced by Simoens \textit{et al.}~\cite{Simoens2012AFF}.
To the best of our knowledge, this is the only paper that comprehensively investigates this subject.

\paragraph*{Contributions}
We present a deep analysis of potential information leakage in distance evaluation, with a specific focus on threshold-based obfuscated distance. The paper thoroughly describes various scenarios where information leakage may occur and examines their implications for security. To achieve this, we systematically outline generic attacks corresponding to each scenario and assess their complexities. Our contribution is to provide insights into the finer points of information leakage in threshold-based obfuscated distance, thus advancing the field of information security. The discussed scenarios give rise to new attacks as well as a range of attacks that complete the work of Pagnin~\textit{et al.}~\cite{pagnin2014leakage}:
\begin{enumerate}
\item Accumulation attacks that capture potential attacks from an \textit{honest-but-curious} server when a client authenticates to it. These attacks assume the use of privacy-preserving cryptographic primitives for evaluating the distance between two hidden vectors. Specifically, as an example, we assume the use of a cryptographic obfuscator of the distance function.
\item Attacks launched by malicious clients exploiting various information leakages from the matcher in the context of a leaked (but obfuscated) database, or by interacting with the server during an \textit{online exhaustive search attack}. As a summary of our main contributions, the complexity type of our attacks is in Table~\ref{summary_table} along with the scenarios considered.
\end{enumerate}

\begin{table*}[]
\centering
\begin{tabular}{@{}cccc@{}}
\toprule
Complexity type         & Threshold related      & Leakage                      & Theorem \\ \midrule
     \multirow{6}{*}{Exponential}                   & \multirow{5}{*}{Below} & Distance                                       &   \ref{th-below-leak-dist}      \\
                        &                        & Position                                      &   \ref{th-below-leak-pos}      \\
                        &                        & Distance and positions                        &   \ref{th-below-leak-dist-and-pos}      \\
                        & & Positions and values & \ref{th-below-leak-value-and-pos}\\
                        &                  & Distance, positions and values                  &   \ref{th-below-leak-dist-pos-and-val}      \\\cmidrule{2-4}
                       Both &                        & Minimal                                         &   \ref{th-both-minimal}      \\ \midrule
    Linearithmic                     & Both                  & Positions and values (accumulation) & \ref{th-acc} \\ \midrule
\multirow{4}{*}{Linear}   & \multirow{2}{*}{Above} & Distance                                       &   \ref{th-above-leak-dist}      \\
                        &                        & Distance and position                         &   \ref{th-above-leak-dist-and-pos}      \\\cmidrule{2-4}
                        & \multirow{2}{*}{Both}  & Distance                                       &   \ref{th-both-dist-leak}      \\    
                        &                        & Distance and positions                          &   \ref{th-both-dist-and-pos-leak}      \\\midrule
                       
\multirow{6}{*}{Constant} & \multirow{3}{*}{Above}  & Distance, position, and values                   &   \ref{th-above-leak-dist-pos-and-val}    \\
       &                  & Position                                      &   \ref{th-above-leak-pos}      \\

                        & & Position and values & \ref{th-above-leak-val-and-pos} \\\cmidrule{2-4}
                        & \multirow{3}{*}{Both}                   & Distance, positions and values                  &   \ref{th-both-dist-pos-and-val-leak}      \\  
                        &  & Positions                                      &   \ref{th-both-pos-leak}      \\
                        & & Position and values & \ref{th-both-pos-and-val-leak} \\\bottomrule
\end{tabular}
% \caption{\label{summary_table} Different leakage settings and their corresponding exploit complexities.}
\caption{\label{summary_table} Leakage settings and their exploit complexities.}
\end{table*}

\paragraph*{Outline}
Section~\ref{prel} initially presents the fundamental definitions required to read the paper, with a particular emphasis on the matcher. We also introduce certain notations and terminologies and provide a classification of leakages. This comprehensive description of all leakage scenarios enables an analysis of potential information leaks. The key contributions of the paper are highlighted in Section~\ref{attacks}. In the subsection~\ref{AccuAtt:section}, we describe a novel attack paradigm that encompasses the accumulation attack, along with a complete analysis of its complexity. In contrast, the subsections~\ref{below}, \ref{above}, \ref{both} detail various attacks corresponding to the identified scenarios, alongside an assessment of their complexities. A succinct summary of these complexities is provided in Table~\ref{Leak_table}.
%Section~\ref{Conclu} concludes the paper, consolidating all the obtained results and presenting novel perspectives on our work, as well as potential directions for future research.


\section{Preliminaries}
\label{prel}
In this section, the (Obfuscated) Matcher is introduced as a function utilized for verifying the proximity of two hidden inputs. Secondly, the notations used throughout the analysis are presented. Then, a list of all the considered information leakage scenarios is presented.


\subsection{(Obfuscated) Matcher}
\label{Bg}
Let $\Zq^n$ (the set of vectors of size $n$ with value in $\llbracket 0, q-1 \rrbracket$) be a metric space equipped with the distance $d$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. 
A private matching scheme $\Xi$ is a pair of an algorithm \texttt{Hide} and a \texttt{Match} which respectively allow hiding a data $x\in \Zq^n$ and check if a newly provided data $y\in \Zq^n$ is such that $d(x,y) \leq \epsilon$. 

\begin{definition}[Hide]
    \phantom{Go to the line Let bla be a matching\\}
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, a space $\mathbb{K}$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $x\in\Zq^n$,
    \begin{eqnarray*}
        \Xi.\texttt{Hide}: &  \Zq^n & \xrightarrow{} \mathbb{K} \\
        & x & \xrightarrow{} X
    \end{eqnarray*}
    Such that $\Xi.\texttt{Hide}$ can be computed by a polynomial time algorithm (PPT), but any polynomial time randomized algorithm $\mathcal{A}$ that attempts to compute a pseudo-inverse for $\Xi.\texttt{Hide}$ succeeds with negligible probability.
\end{definition}

Once $x$ has been hidden by the function $\Xi.\texttt{Hide}$, it is possible to check if a vector $y$ is close to $x$ with respect to $\epsilon$. In other words, $\Xi.\texttt{Match}$ indicates if $y\in B_\epsilon(x)$, where $B_\epsilon(x) = \lbrace y \in \Zq^n \,| d(x,y)\leq \epsilon \rbrace$ is the ball of radius $\epsilon$ and centered in $x$. 
\begin{definition}[Match]
    \phantom{Go to the line Let  be a matching\\}
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, $x\in \Zq^n$, $\mathbb{K}$ be $\Xi.\texttt{Hide}(\Zq^n)$ and $\epsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $Y\in\mathbb{K}$ the output of $\Xi.\texttt{Hide}(y)$ and $X$ the output of $\Xi.\texttt{Hide}(x)$, 
    \begin{eqnarray*}
        \Xi.\texttt{Match}: &  \mathbb{K} \times \mathbb{K} & \xrightarrow{} \lbrace 0, 1 \rbrace \\
        & Y, X  & \xrightarrow{} \begin{cases}
        0 & \text{ if } d(x,y)\leq \epsilon, \\
        1 & \text{ otherwise}, \\ 
        \end{cases}
    \end{eqnarray*}
    such that $\Xi.\texttt{Match}$ is a deterministic polynomial time algorithm that succeeds with probability $1$.
\end{definition}

\begin{rem}
    Both $\Xi.\texttt{Match}$ inputs are hidden by the function $\Xi.\texttt{Hide}$.
\end{rem}

To simplify, we assume that a vector $y \in \mathbb{Z}_q^n$ can be directly used with $\Xi.\texttt{Match}$, \textit{i.e.}, pre-transformation $\Xi.\texttt{Hide}(y)$ is omitted when it is not necessary. The $\Xi.\texttt{Match}$ function has the possibility to disclose certain information, and its possible leakage scenarios are described in the following sections.

\subsection{Notations and Attacker Models}
\label{Notation}

In the following, we consider the metric space $\Zq^n$ (the set of vectors of size $n$ with value in $\llbracket 0, q-1 \rrbracket$) equipped with the distance $d$. 
Let us define the oracle $\sigma_{x,\epsilon}$ that models the role of $\Xi.\texttt{Match}$, to which the attacker is given access. 
For the sake of simplicity, the threshold $\epsilon$ and the hidden vector $x$ are omitted when the context is explicit.
In this framework, the goal of the attacker is to retrieve the hidden data $x\in\Zq^n$ from the transformation $\Xi.\texttt{Hide}(x)$. To do so, she is performing queries to the oracle $\sigma_{x,\epsilon}$ as well as the function $\Xi.\texttt{Hide}$.
% Moreover, as regards the accumulation attack scenario, the attacker has access to the oracle  $\mathcal{O}_{x,\epsilon}$ which returns $\Xi.\texttt{Hide}(y)$ with $d(x,y)\leq \varepsilon$. Hence, $\mathcal{O}$ returns a new hidden vector from the genuine client during its authentication in the system.
%Moreover, in the leakage below the threshold scenario, the attacker can have access to the oracle $\mathcal{O}_{x,\epsilon}$ to illustrate an attacker which has access to a genuine client for an authentication scheme.
% The different types of information leakage expose the system to different generic attacks.
% These attacks range from the Exhaustive Search Attack to the Center Search Attack. 
%\todo{Paragraphe introductif de la section}
% A matching scheme $\Xi$ as defined in Section~\ref{Bg} can leak some information. 
% To quantify this leakage, we consider the following scenarios. 
% In the following, we consider that $\Xi.\texttt{Match}$ leaks extra information in addition to its answer $0$ or $1$.  In this section, several scenarios to model these information leaks are defined.
A matching scheme $\Xi$, as defined in Section~\ref{Bg}, can leak some information, and we consider that $\Xi.\texttt{Match}$ leaks extra information beyond its binary output ($0$ or $1$). The section comprises two subsections. The first one enumerates the types of information leaks related to a matching scheme and defines the associated scenarios. The second subsection focuses on the various attacks employed to exploit the leaked information. 
%Hence, we present an in-depth analysis of how the leaked information is exploited, and the methodologies utilized (see proofs) to perform these attacks. 
By examining these aspects, we aim to enhance the understanding of the real security of a matching scheme under different leakage scenarios.


\subsection{Typology of Information Leakage}
\label{Leak_type}
% There are three main scenarios. The first one is a leakage of information below the threshold. The second one is the leakage above the threshold. The last one is when the information leaks below and above the threshold. Among these global scenarios, there are several sub-settings. The first one is the absence of leakage, \textit{i.e.} $\Xi.\texttt{Match}$ returns only $0$ or $1$. 
% Then, the following leak can be declined for above the threshold, below or both. 
% Then, we have the knowledge of the distance $d$, the position of the error only, the distance $d$ and the position of the error, and the distance $d$ and the position of the error as well as the value of each error. Table~\ref{Leak_table} summarizes all those possibilities. 
\noindent
%{\color{blue}
% In the case of a biometric system, the information can be intercepted between the matcher and the decision module as shown in Figure~\ref{fig:notratha} (point $8$). This figure is a more detailed version of the Ratha~\textit{et al.}~\cite{Rathasheme} with the decision module and two more threat points. In all the following scenarios except for the accumulation attack, the attacker gets control of the points $4$ and $8$. The point $4$ allows her to submit the template of her choice, and the point $8$ allows her to get more information than the binary output yes/no. In the case of the accumulation attack, only the control of the point $8$ is needed. For more details concerning the other points, the reader is referred to Ratha~\textit{et al.}~\cite{Rathasheme}.
In the context of a biometric system, a critical vulnerability arises when information is intercepted between the matcher and the decision module, as illustrated in Figure~\ref{fig:notratha} (point $8$). This figure builds upon Ratha \textit{et al.}'s~\cite{Rathasheme} research, introducing both the decision module and two additional threat points. Except for the accumulation attack, the attacker gains control over points $4$ and $8$ in all discussed scenarios. Point $4$ allows the submission of a chosen template, while point $8$ grants access to additional information beyond the binary output yes/no. The accumulation attack only necessitates control over point $8$. For detailed insights into the remaining threat points, readers are referred to Ratha~\textit{et al.}'s work~\cite{Rathasheme}.%}
There are three main categories of leakage: 
% The first one involves information leakage below the threshold $\varepsilon$. The second relates to information leakage above $\varepsilon$. The last covers situations where information leaks both below and above the threshold. 
\begin{enumerate}
    \item Information leakage below the threshold. 
    \item Information leakage above the threshold. 
    \item Information leakage both below and above the threshold. 
\end{enumerate}
Among these scenarios, several sub-settings can be identified.
The first sub-setting corresponds to the absence of any leakage, resulting in $\Xi.\texttt{Match}$ yielding only binary outcomes ($0$ or $1$). Then, the following sub-settings are examined: 
\begin{enumerate}
    \item Knowledge of the distance $d$. 
    \item Knowledge of the positions of the errors only.
    \item Knowledge of the positions of the errors and the value.
    \item Knowledge of both the distance $d$ and the positions of the errors.
    \item Knowledge of both the distance and the positions and their corresponding values.
\end{enumerate} 



% Figure environment removed

% All these scenarios and sub-settings are summarized in Table~\ref{Leak_table}.

% \begin{table}[h]
%     \begin{center}
%         \begin{tabular}{@{}ll@{}}
%             \toprule
%             \multicolumn{1}{l}{Threshold}    & \multicolumn{1}{l}{Extra Information} \\ \toprule
%             \multirow{5}{*}{Above}           &  No extra leakage                               \\
%                                              & Distance    \\
%                                              & Position                              \\
%                                              & Distance and position                 \\
%                                              & Position, and value \\
%                                              & Distance, position, and value         \\
%                                                                                          \midrule
%             \multirow{5}{*}{Below}           & No extra leakage                               \\
%                                              & Distance    \\
%                                              & Position                              \\
%                                              & Distance and, position                \\
%                                              & Position, and value \\
%                                              & Distance, position, and value         \\
%                                                                                          \midrule
%             \multirow{5}{*}{Above and Below} & No extra leakage                               \\
%                                              & Distance    \\
%                                              & Position                              \\
%                                              & Distance and position                 \\
%                                              & Position, and value \\
%                                              & Distance, position, and value         \\
%                                                                                          \bottomrule
%         \end{tabular}
%         \caption{\label{Leak_scenario_table} Summary of distance leakages.}
%     \end{center}
% \end{table}

\section{Exploiting the Leakage}
\label{attacks}

\subsection{Leakage Exploit Attacks}

%Having defined the different types of leakage, we now present the attacks. 
Several attacks are related to the different types of aforementioned leakage scenarios. 
The first attack is the exhaustive search, which tests all possible vectors until the right one is found.

\begin{definition}[Exhaustive or Brute-Force Search]
    \label{ExaustiveSearch}
    \phantom{Go to the line\\}
    This attack is a very general problem-solving technique that consists of testing all possibilities until the problem statement is verified. The complexity of this attack is $O(q^n)$ queries to~$\sigma$.
\end{definition}

Then, by considering some extra information, it is possible to perform a hill-climbing attack~\cite{lasry2018methodology}, whose aim is to find the solution by iteratively improving a potential solution. 

\begin{definition}[Hill-climbing attack]
    \label{HillClimAtt}
    \phantom{Go to the line The\\}
    The hill-climbing attack is based on a mathematical optimization technique. It begins with an arbitrary solution and then attempts to improve the solution by applying some slight variations. If the updated solution improves the score obtained with the target function, the previous process is repeated with this new solution until the attack succeeds. The complexity of this attack is in $O(nq)$.
\end{definition}

% Using $\sigma$ and obliviously testing someone else vector which can produce a vector close to $x$ under certain circumstances can lead to the total discovery of $x$.
% By employing the oracles $\sigma$ and $\mathcal{O}$ under specific conditions, the attacker recovers the complete information of $x$ by accumulating some knowledge about $x$ at each query. However, the accumulation attack only applies to special cases, which are examined in more detail in Section~\ref{AccuAtt:section}.
By employing the oracles $\sigma$, the attacker recovers the complete information of $x$ by accumulating some knowledge about $x$ at each query. Additional information can be found in Section~\ref{AccuAtt:section} and throughout the paper.
\begin{definition}[Accumulation Attack]
    \label{AccuAtt}
    \phantom{Go to the line please\\}
    The accumulation attack is a passive attack where the attacker recovers a certain amount of information at each interaction.
    By accumulating this information, the entropy of the target gets smaller until its entropy goes to zero.
    In the end, the attacker has a complete knowledge of the target.
\end{definition}

Note that the accumulation attack works for a limited number of leakage scenarios. Indeed, in the case of the leak of the distance only, the attacker gets no information on the hidden vector.
In~\cite{pagnin2014leakage}, the authors show that from any closed vector $y$ of $x$, \textit{i.e.}, $d(x,y)\leq \varepsilon$, it is possible to retrieve the center $x$ of the ball using~$\sigma$. 
\begin{definition}[Center Search Attack~\cite{pagnin2014leakage,Simoens2012AFF}]
    \label{CentSearAtt}
    \phantom{Go to the line\\}
    This attack aims at finding $x$ the center of the acceptance ball $B_\epsilon(x)$. The starting point of the attack is to find a point $b'$ on the edge of the ball, and then converge to its center. The complexity of this attack is $O(nm)$ where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
\end{definition}


% Note that the Center Search Attack is not always possible. In the case where the threshold, \textit{i.e.} the radius of the ball, is too large compared to the space, the attack does not work. %the number of points that can be reached by leaving the ball to get closer is too small. 
% However, with the normal use of a distance-matching system, where $\varepsilon$ is a small fraction of $n$, this should not happen. 
We refer the reader to the work of Pagnin \textit{et al.}~\cite{pagnin2014leakage} for more details.


\subsection{Accumulation Attack}
\label{AccuAtt:section}
In this attack scenario, each time a genuine client authenticates to a server, the attacker gets the information on the errors the client makes. In other words, the server leaks the position and the error made by the client, but the attacker does not make any queries. This information is defined as observation.
The error locations are assumed to be uniformly distributed. The objective of the attacker is to recover all bits of information regarding the hidden value $x$. This attack is thus related to the coupon collector problem. The coupon collector problem involves a set of $n$ distinct coupons (the coordinates of $x$), where an individual selects coupons one at a time, with replacement. The problem is to calculate the expected number of coupons that must be collected (sampled) to ensure the acquisition of at least one of each unique coupon type. However, in our case, the number of errors is between $0$ and $\varepsilon$. Hence, the result on the coupon collector problem gives us an upper bound. Flajolet \textit{et al.}~\cite{flajolet1992birthday} have shown that the expected number of rounds required to complete the collection is approximately $n\log{n}+\gamma n+ 1/2 + O(1/n)$, where $\gamma\approx0.577$ is the Euler–Mascheroni constant. This result is used in our case under the hypothesis that the client makes at least one error at each authentication. Knowing that fuzzy matchers are mostly used for biometric purposes and knowing the variability of those data, the hypothesis is reasonable. Note that in the worst case, the complexity tends to infinity (\textit{e.g.} if the client always produces the same error).

\begin{theorem}\label{th-acc}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors and their values below the threshold, an attacker can retrieve $x$ in $O\left(n\log{n} +\gamma n\right)$ observations with $\gamma$ the Euler-Mascheroni constant.
\end{theorem}



In order to support Definition~\ref{AccuAtt} and give the ideas for the proof of Theorem~\ref{th-acc}, the subsequent example illustrates an accumulation attack.
\begin{ex}
    \label{ExampleAccuAtt}
    Suppose a setting with a metric space $\mathbb{Z}_2^n$ equipped with the Hamming distance. A client seeks to authenticate to an \textit{honest-but-curious} server that uses a scheme leaking $d_H(x,y)$ and the corresponding errors if $d_H(x,y) \leq \epsilon$.
    As the client is legitimate, \textit{i.e.}, $d_H(x,y) \leq \epsilon$, the server recovers the values of at most $\epsilon$ erroneous bits. The server needs to collect all the bits of the client, turning this problem into a Coupon Collector problem.
    For example, let assume $x = (0,0,1,1,0,1,0)$, $\varepsilon = 3$. The server sets $z = (?,?,?,?,?,?,?)$. Session~1: The client authenticates with $y = (1,1,0,1,0,1,0)$. In this case, $d_H(x,y) = 3 \leq \varepsilon$. The server gets the values of the erroneous bits of the client and updates $z = (0,0,1,?,?,?,?)$. Session~2: the client authenticates with $y = (0,0,0,0,1,1,0)$. In this case, $d_H(x,y) = 3 \leq \varepsilon$, and the server gets the value of the erroneous bits of the client and updates $z = (0,0,1,1,0,?,?)$. Finally, the server has a vector inside the ball. Hence, she is able to perform an impersonation attack because the entropy of $z$ is smaller than the threshold, or she can perform the Center Search Attack~\ref{CentSearAtt}. Some extra steps, give the very last bits.
\end{ex}

\begin{proof}
Using the same argument as in the introduction of the section, the vector $x$ is recovered in $O\left(n\log{n}+\gamma n\right)$ observations of a genuine client.\\
$\blacksquare$
\end{proof}

A lower bound can be computed by considering the work of Ferrante \textit{et al.}~\cite{ferrante2012note,CoupnCollector}. Indeed, they studied a variant where $\varepsilon$ coupons were drawn in each round instead of just one. They show that the expected number of observations is
\begin{align*}
        \sum\limits_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{\binom{n-j}{\epsilon}}{\binom{n}{\epsilon}}\right)^{-1} & \leq N.
\end{align*}
The result of this section can be enhanced by considering a random number of coupons drawn between $0$ and $\varepsilon$ at each round and by considering the distribution of the errors, which is currently an open problem.
It is important to note that in this scenario, the attacker does not control the error. If the attacker controls the error (the location), then, she can get the full knowledge of $x$ in $\lceil n/\varepsilon \rceil$ queries. This scenario can happen in a fault attack, akin to side-channel attacks.


\subsection{Attack Complexities for Leakage Below the Threshold}
\label{below}
The second scenario is considered, involving leakage below the threshold. Specifically, assuming the hidden target vector $x$, submitting another vector $y$ such that $d(x,y)\leq\varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may leak additional information. All fuzzy matchers that involve secure sketches, error-correcting code mechanism always leak information below the threshold. Indeed, most of the time, the distance, the error location and the error itself are computed even if not used.

\paragraph{The distance is leaked}

The first case occurs when the distance is given to the attacker as extra information. 
\begin{theorem}\label{th-below-leak-dist}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and a fuzzy matcher $\Xi$ such that $\Xi.\texttt{Match}$ leaks the distance below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+qn)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
The first step involves obtaining a vector below the threshold, which requires performing an exhaustive search attack in $q^{n-\varepsilon}$ steps. Then, a hill-climbing attack can be executed in $qn$ steps. Therefore, the overall complexity is in $O(q^{n-\varepsilon}+qn)$.\\
$\blacksquare$
\end{proof}

\paragraph{The positions are leaked}
% In this case, the extra information given to the attacker is the position of the error, but she ignored the value of each error. As in the previous scenario, the first step is to get a vector below the threshold.  To do so, the attacker must perform an exhaustive search attack in $q^{n-\varepsilon}$ steps. Then she must perform an exhaustive search on the erroneous positions in $q^{\varepsilon}$ steps. Hence, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon}+q^{\varepsilon})$.

The positions of the errors are the extra information given to the attacker, while their values remain secret. 
\begin{theorem}\label{th-below-leak-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q^\varepsilon)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
The first step is to fall inside the ball, which requires the attacker to perform an exhaustive search attack in $q^{n-\varepsilon}$ steps. Subsequently, an exhaustive search is performed on the erroneous coordinates in $q^\varepsilon$ steps. Hence, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon}+q^\varepsilon)$.
\\ $\blacksquare$
\end{proof}


\begin{table*}[]
\resizebox{\textwidth}{!}{%
\centering
\begin{tabular}{ccccc}
\toprule
\multicolumn{1}{l}{Threshold related}   & Leakage                      & Complexity type & Worst case complexity in Big-$O$ & Average complexity in Big-$O$              \\
\midrule
\multirow{5}{*}{Above} & Distance                     & Lin.       & $n(q+m)-\varepsilon$  &       $-$       \\
                               & Positions                     & Const.        &   $q$  & $-$              \\
                               & Distance and positions        & Const.       & $q$   &  $-$         \\
                               & Position, and values & Const.     & $1$       &                  $-$        \\
                               & Distance, positions, and values & Const.     & $1$       &                  $-$        \\
                               \midrule
\multirow{5}{*}{Below} & Distance                     & Exp.       & $q^{n-\varepsilon}+qn$   &          $-$ \\
                               & Positions                    & Exp.       & $q^{n-\varepsilon}+q^\varepsilon$ & $-$ \\
                               & Distance and positions        & Exp.       & $q^{n-\varepsilon}+q\varepsilon$  & $-$ \\
                               & Positions and values & Exp.       & $q^{n-\varepsilon}$      &  $-$         \\
                               & Distance, positions, and values & Exp.       & $q^{n-\varepsilon}$      &  $-$         \\
                               \midrule
\multirow{7}{*}{Both} & Minimal                      & Exp.       & $q^{n-\varepsilon}+nm$  & $-$\\

                               & Distance                     & Lin.       & $nq$     &   $-$                        \\
                               & Positions                     & Const.       &  $q$  &   $-$                \\
                               & Positions and values (accumulation) & Linearithmic & $\infty$  &  $n\log{n}+\gamma n$\\
                               & Distance and positions        & Const.       &   $q$  &   $-$                  \\
                               & Positions and values & Const.    & $1$         &     $-$                   \\
                               & Distance, positions, and value & Const.    & $1$         &     $-$                   \\
                               \bottomrule
\end{tabular}
}
\caption{Summary of all leakage exploits and their complexities for the average case, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$. The dash in the second column means that the worst-case complexity prevails. The average complexity of the accumulation attack assumes uniformly distributed errors across each authentication session.}
\label{Leak_table}
\end{table*}

\paragraph{The distance and the positions are leaked}

% In this case, the distance and the position of the errors are given to the attacker when she tries a vector above the threshold. She performed an exhaustive search to get below the threshold in $q^{n-\varepsilon}$ steps. Then, she performs a hill-climbing attack on the faulty coordinates in $q\varepsilon$ steps. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+q\varepsilon)$.

In this case, the distance and the positions of the errors are given to the attacker when a vector below the threshold is queried.
\begin{theorem}\label{th-below-leak-dist-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance and the positions of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q\varepsilon)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
An exhaustive search is performed by the attacker to fall below the threshold in $q^{n-\varepsilon}$ steps. Subsequently, a hill-climbing attack is executed on the faulty coordinates, which takes $q\varepsilon$ steps. Therefore, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+q\varepsilon)$.\\
$\blacksquare$
\end{proof}


\paragraph{The positions and the values are leaked}

In this case, the positions and the values of the errors are given to the attacker when a vector below the threshold is queried.
\begin{theorem}\label{th-below-leak-value-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions and the values of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon})$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
We encounter an error-correction mechanism that corrects errors below a certain threshold. The cost associated with this attack is comparable to that of an exhaustive search targeting a vector below the threshold. Consequently, the complexity of the attack for recovering $x$ in this scenario is of the order $O(q^{n-\varepsilon})$.\\
$\blacksquare$
\end{proof}



\paragraph{The distance, the positions, and the values are leaked}

% In this last case, the distance, the position of the errors and the value of each error is leaked. In this case, we are facing an error-correcting mechanism that allow the correction below the threshold. It is clear that the cost of this attack is equivalent to the exhaustive search to get a vector below the threshold. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon})$.

In this last case, the distance, the positions of the errors, and the values of all errors are leaked. 
\begin{theorem}\label{th-below-leak-dist-pos-and-val}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the positions of the errors, and the values of each error below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon})$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
% This is an error-correcting mechanism that allows the correction below the threshold. The cost of this attack is equivalent to the cost of an exhaustive search aiming at a vector below the threshold. As a result, the complexity of the attack to recover $x$, in this case, is in $O(q^{n-\varepsilon})$.
The proof is exactly the same as the previous one.
\\
$\blacksquare$
\end{proof}



\subsection{Leakage Below and Above the Threshold}
\label{both}
% In this section, we consider the last scenario, which is the leakage independent of the threshold. In other words, given a vector $x$ hidden, the submission of $y$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge.
The last scenario is considered, which involves a leakage independent of the threshold. In other words, when a hidden vector $x$ is targeted, the queried vector $y$ to the $\sigma_{x,\varepsilon}$ oracle may result in the leak of additional information. Most of the reasoning comes from the previous cases. This scenario setup highlight how devastating a leakage independent of threshold is devastating for the security beside the minimal leakage.


\paragraph{Minimal Leakage (single bit of information leakage)}
% The minimal leakage scenario is the original way of using a fuzzy matcher. This scenario highlights the fact that the response yes/no is a leakage by itself. This leakage is called minimal, because without it, the system cannot work. As no further leakage hypothesis is needed, this case is the same for the three possible scenarios (above, below, and both) because the matcher always respond.
The basic usage of a fuzzy matcher is characterized by the minimal leakage scenario, where the binary yes/no response itself is considered as a necessary leakage. This minimal leakage is indispensable for the system's works and is consistent across all three possible scenarios (above, below, and both) as the matcher always provides a response. Remark that if the server does not answer above the threshold, the non answer gives the attacker the wanted information.
\begin{theorem}\label{th-both-minimal}
    Given $\varepsilon$ a threshold, $x$ a vector in $\mathbb{Z}_q^n$ and a fuzzy matcher $\Xi$, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+nm)$ queries to $\sigma_{x,\epsilon}$, with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.       
\end{theorem}

\begin{proof}
The best chance for the attacker is to find a vector in the ball of $x$. Then, she performs the center search attack~\cite{pagnin2014leakage}. Hence, the complexity of the attack to recover $x$ in this case is in $O(q^{n-\varepsilon}+nm)$ with $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
\\
$\blacksquare$
\end{proof}



\paragraph{Leakage of Distance}
In this case, the distance between the fresh and old data is provided as extra information to the attacker.
\begin{theorem}\label{th-both-dist-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, an attacker can retrieve $x$ in $O(nq)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
    When the distance is given to the attacker, she can perform a hill-climbing attack in $O(nq)$. This is the classical setup for a hill-climbing attack~\cite{lasry2018methodology}.\\
$\blacksquare$
\end{proof}


\paragraph{Leakage of the Positions}
In this case, the extra information given to the attacker is the positions of the errors, but the corresponding values remain secret.
\begin{theorem}\label{th-both-pos-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors, an attacker can retrieve $x$ in $O(q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
She tries the vector $(0,\dots,0)$, $(1,\dots,1)$ up to, $(q-1,\dots,q-1)$ and keep for each coordinate the right value. Hence, the complexity of the attack to recover $x$, in this case, is $O(q)$.
\\
$\blacksquare$
\end{proof}

Figure~\ref{fig:reverse_master_mind} gives a representation of the attack described above in the case $\mathbb{Z}_4^5$ with a threshold $2$ and the hidden vector $(0,1,3,2,2)$.

% Figure environment removed
\addtolength{\tabcolsep}{0cm}

\begin{rem}
    %The real complexity is $q-1$ because the last exchange is not necessary, as the coordinates at $q-1$ are known after $q-1$ queries.
    The actual complexity is $q-1$ since the final exchange is unnecessary, as the coordinates at $q-1$ become known after $q-1$ queries by inference.
\end{rem}

\paragraph{Leakage of Distance and Positions}
In this case, the distance, and the positions of the errors are given to the attacker when she guesses a vector.
\begin{theorem}\label{th-both-dist-and-pos-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks  the distance and the positions of the errors, an attacker can retrieve $x$ in $O(q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
The proof is the same as the previous case.\\
$\blacksquare$
\end{proof}

\paragraph{Leakage of the Positions and the Values}
In this last case, the positions of the errors and corresponding values are leaked. 
\begin{theorem}\label{th-both-pos-and-val-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors and their values, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
In this case, it is clear that the complexity is in $O(1)$ as it is the same case for above the threshold.
\\
$\blacksquare$
\end{proof}


\paragraph{Leakage of Distance, Positions and values}
In this last case, the distance, the positions of the errors, and corresponding values are leaked. 
\begin{theorem}\label{th-both-dist-pos-and-val-leak}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the positions of the errors and their values, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
As above, it is clear that the complexity is in $O(1)$.
\\
$\blacksquare$
\end{proof}

As the leakage only above the threshold is not realistic but still interesting, the corresponding analysis is in the appendix~\ref{above}. 
% Information leakage is related to the properties and the design of the obfuscated distance. 
Attacks for each leakage are summarized in Table~\ref{Leak_table}.



\section{Conclusion}
\label{Conclu}
Our investigation into the information leakage of a fuzzy matcher has shed light on critical security vulnerabilities that arise under various scenarios. By evaluating the impact of different types of leakage, including distance, error position, and error value, we have gained insights into the potential risks posed to data privacy and security in practical applications. 

Our analysis encompasses both above and below the threshold setups, allowing us to identify specific conditions under which information leakage can have a substantial effect on the overall security of the system. 
% The simplicity and efficacy of the proposed attack for exploiting information leakage underscore the importance of actively addressing potential vulnerabilities for any fuzzy matcher, in particular when the leaked information is above the threshold or both above and below the threshold.
Furthermore, the attacks presented in this study, relying on exhaustive search, have the potential for theoretical improvement by using techniques such as \textit{set-covering} and \textit{sampling without replacement}, as shown by Pagnin \textit{et al.}~\cite{pagnin2014leakage}. 

However, it is noteworthy to mention that the feasibility of the aforementioned approach is hindered by the NP-hard nature of the \textit{set-covering} problem, which renders the attack impractical.
It is important to highlight that the leakage below the threshold does not significantly hurt the security of the fuzzy matcher, while the leakage above significantly decreases the security. Indeed, the attacks that exploit the leakage below the threshold are all exponential, while the ones that exploit information above or both below and above the threshold are mainly constant.

Ultimately, our research emphasizes the critical importance of exploring information leakage in cryptographic systems, highlighting the ongoing necessity for the development of robust cryptographic primitives capable of withstanding side-channel attacks and effectively mitigating potential information leaks.

The accumulation attack we investigated is based on the assumption of errors uniformly distributed throughout each authentication session. As far as we are aware, no previous studies provide an analysis of how these errors are distributed. In practical scenarios, some errors might manifest more frequently. If the distribution of errors is skewed, this could substantially increase the expected number of authentications required from the legitimate user so that the server fully recovers the hidden vector.

\section*{Acknowledgement}
The authors acknowledge the support of the French Agence Nationale de la Recherche (ANR), under grant ANR-20-CE39-0005 (project PRIVABIO).

\bibliographystyle{unsrt}
\bibliography{biblio}

\section{Appendix}
\subsection{Attacks complexities for a leakage above the threshold}
\label{above}

In this section, the first scenario is considered, which involves leakage above the threshold $\varepsilon$. In other words, when a hidden vector $x$ is used, the submission of another vector $y$ such that $d(x,y) > \varepsilon$ to the $\sigma_{x,\varepsilon}$ oracle may lead to the extra gain of knowledge. In the case of identification system, the distance is always computed even if the threshold is exceeded. In this case, this is valuable information the attacker can get.

\paragraph{The distance is leaked}
The first case happens when the distance is provided to the attacker as the extra gain of knowledge. 
\begin{theorem}\label{th-above-leak-dist}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance above the threshold, an attacker can retrieve $x$ in $O(n(q+m)-\varepsilon)$ queries to $\sigma_{x,\varepsilon}$, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.       
\end{theorem}
\begin{proof}
In this situation, a hill-climbing attack can be executed by the attacker until a vector $y$ is obtained, precisely at a distance of $\varepsilon$ from their target $x$. This stage of the attack can be completed within $nq-\varepsilon$ steps. Subsequently, the hill-climbing attack cannot be continued since it falls below the threshold, yielding no further extra information. However, the attacker can now proceed with the center search attack, which requires $nm$ steps, where $m=\mathrm{min}(\lfloor 2\epsilon \rfloor,2\ln q)$.
%
As a result, the complexity of the attack aimed at recovering $x$, in this case, is in $O(n(q+m)-\varepsilon)$.\\
$\blacksquare$
\end{proof}

\paragraph{The positions are leaked}
In this case, the error positions are the extra information provided to the attacker, while the value of each error remains secret. 
\begin{theorem}\label{th-above-leak-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the error positions above the threshold, an attacker can retrieve $x$ in $O(q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
The proof is exactly the same as in the case of both.
\\
$\blacksquare$
\end{proof}

\paragraph{The distance and the position are leaked}
In this case, when the attacker queries a vector above the threshold, she is provided with both the distance and the error positions. 
\begin{theorem}\label{th-above-leak-dist-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance and the positions of the errors above the threshold, an attacker can retrieve $x$ in $O(q)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
The proof is exactly the same as in the case of both.
\\$\blacksquare$
\end{proof}

\paragraph{The positions and the values are leaked}

In this case, when the attacker queries a vector above the threshold, she is provided with both the positions and the values. 
\begin{theorem}\label{th-above-leak-val-and-pos}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions and the values of the errors above the threshold, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}

\begin{proof}
In this case, the query answer is an error-correcting code, hence yielding a complexity of $O(1)$. \\
$\blacksquare$
\end{proof}


\paragraph{The distance, the positions, and the values are leaked}
In this last case, the distance, the error positions, and values are leaked.
\begin{theorem}\label{th-above-leak-dist-pos-and-val}
    Given a threshold $\varepsilon$, a vector $x\in\mathbb{Z}_q^n$ and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, the positions of the errors, and their values above the threshold, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\epsilon}$.       
\end{theorem}
\begin{proof}
In this case, the query answer yields an error-correcting code, hence the complexity is in $O(1)$.
\\
$\blacksquare$
\end{proof}

\end{document}
