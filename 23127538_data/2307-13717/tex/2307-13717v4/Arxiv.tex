\documentclass[10pt,conference]{IEEEtran}
%\documentclass[10pt,journal]{IEEEtran}
\IEEEoverridecommandlockouts
%\usepackage[english]{babel}
%math
%\usepackage{geometry}
\usepackage{amsmath,amsfonts,stmaryrd,amssymb}
%\usepackage{xcolor}
\usepackage{extarrows}
\usepackage{todonotes}
\usepackage{bm}
\usepackage{caption}
\usepackage{paralist}
\usepackage{float}
%\usepackage{times}
\usepackage{url}
%\usepackage{natbib}

%\usepackage[subtle]{savetrees}
%\usepackage[moderate]{savetrees}
%\usepackage[extreme]{savetrees}
\usepackage{booktabs} % For formal tables

%tikz -------------------------------------
\usepackage{tikz}
\usetikzlibrary{shapes}
\newcommand{\f}{ \draw[->,>=latex]}
\usetikzlibrary{decorations.markings}
\usepackage{tkz-base,tkz-fct}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
%------------------------------------------
%cryptocode
\usepackage{cryptocode}

%list
\usepackage{enumitem}

%sout
\usepackage[normalem]{ulem}

%todo
%\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
%\let\svtodo\todo\renewcommand\todo[1]{\svtodo[inline]{#1}}

% %for dashed line in tabular
% \usepackage{arydshln}
% \usepackage{pifont}
% \usepackage{verbatim}
\usepackage{hyperref}
\usepackage{multirow}
% \usepackage{chngpage}
% \usepackage{lipsum}
% \usepackage{booktabs}

\usepackage{tabularx}
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata}

% Type macros:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\party}[1]{\ensuremath{\mathit{#1}}}  % Parties are just in math font
\newcommand{\poracle}[2]{\ensuremath{\pi_{\myuser{#1}}^{\myuser{#2}}}} % Party oracles. Lower index for party, upper index for session number

\newcommand{\set}[1]{\ensuremath{\mathcal{#1}}}
\newcommand{\binset}[1]{\ensuremath{\{0,1\}^{#1} }}
\newcommand{\mystate}[2]{\ensuremath{\msg{st}_{\mathsf{#1}}^{#2}}} % Party oracles. Lower index for session number, upper index for party (type)

\newcommand{\myphase}{\ensuremath{\mathsf{phase}}}

\newcommand{\msg}[1]{\ensuremath{\mathsf{#1}}} % Protocol messages are in SF
\providecommand{\primitive}[1]{\ensuremath{\textnormal{#1}}} % primitives are in normal font

\newcommand{\alg}[1]{\ensuremath{\mathtt{a{#1}}}} % algorithms are in TT
\newcommand{\oracle}[1]{\ensuremath{\mathsf{o{#1}}}}

\newcommand{\makett}[1]{\ensuremath{\mathtt{{#1}}}} % algorithms are in TT


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Parties:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\myparty}{\party{P}}

\newcommand{\myuser}[1]{\party{#1}}
\newcommand{\mysu}{\party{\hat{S}}}


\newcommand{\myalice}{\party{A}}
\newcommand{\mybob}{\party{B}}
\newcommand{\myA}{\myalice}
\newcommand{\myB}{\mybob}

\newcommand{\id}{\ensuremath{\mathsf{ID}}}
\newcommand{\myid}[1]{\ensuremath{{\myuser{#1}}}}
\newcommand{\idp}{\ensuremath{{P} }}
\newcommand{\idq}{\ensuremath{{Q} }}
\newcommand{\elechat}{\ensuremath{\poracle{P}{Q}}}
\newcommand{\aux}{\ensuremath{\mathsf {AD}}}


\newcommand{\myP}{\ensuremath{\party{P}}}
\newcommand{\myQ}{\ensuremath{\party{Q}}}
\newcommand{\myR}{\ensuremath{{\party{R}[s]}}}
\newcommand{\myS}{\ensuremath{{\party{S}[s]}}}

\newcommand{\PARTIES}{\set{P}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Attributes:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\mystage}{\ensuremath{\mathsf{stages}}}
\newcommand{\pstage}[2]{\ensuremath{\poracle{#1}{#2}.\mystage}}

\newcommand{\ptau}[2]{\ensuremath{\poracle{#1}{#2}.T}}
\newcommand{\annosent}{\ensuremath{\mathsf{SentM}}}
\newcommand{\annorec}{\ensuremath{\mathsf{RecM}}}

\newcommand{\ptaurec}[2]{\ensuremath{\ptau{#1}{#2}_{\annorec}}}
\newcommand{\ptausent}[2]{\ensuremath{\ptau{#1}{#2}_{\annosent}}}
\newcommand{\pastptau}[3]{\ensuremath{\ptau{#1}{#2}[#3]}}


\newcommand{\freshbit}[2]{\ensuremath{\poracle{#1}{#2}.\phi}}
\newcommand{\statusbit}[2]{\ensuremath{\poracle{#1}{#2}.{\sf status}}}

\newcommand{\bitreject}{\ensuremath{0}}
\newcommand{\bitaccept}{\ensuremath{1}}
\newcommand{\bitindec}{\ensuremath{\bot}}
\newcommand{\testbit}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{b}[#3]}}
\newcommand{\authbit}[2]{\ensuremath{\poracle{#1}{#2}.\alpha}}
\newcommand{\prole}[2]{\ensuremath{\poracle{#1}{#2}.\msg{role}}}
\newcommand{\roleinit}{\ensuremath{\texttt{Initiator}}}
\newcommand{\roleresp}{\ensuremath{\texttt{Responder}}}
\newcommand{\myrole}{\textnormal{\ensuremath{\texttt{role}}}}

\newcommand{\pastauthbit}[3]{\ensuremath{\poracle{#1}{#2}.\alpha[#3]}}

\newcommand{\pid}{\ensuremath{\mathsf{pid}}}
\newcommand{\sid}{\ensuremath{\mathsf{sid}}}

\newcommand{\psid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{sid}}}
\newcommand{\ppid}[2]{\ensuremath{\poracle{#1}{#2}.\msg{pid}}}

\newcommand{\pastpstate}[3]{\ensuremath{\poracle{#1}{#2}.[#3]}}

\newcommand{\nbparties}{\ensuremath{\mathsf{n}_\PARTIES}}

\newcommand{\qtype}{\ensuremath{\mathsf{q.type}}}
\newcommand{\qinput}{\ensuremath{\mathsf{q.input}}}
\newcommand{\qresp}{\ensuremath{\mathsf{q.rsp}}}

\newcommand{\prchp}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{rchpk}[#3]}} % the public rch key of stage #3 for #1
\newcommand{\pfrec}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{rec}}}



%=====================================
% SAID
%=======================================

\newcommand{\said}{\textsf{SAID}}
\newcommand{\imam}{\textsf{iMAM}}
\newcommand{\SAIDmsk}{\ensuremath{\msg{msk}}}
\newcommand{\SAIDrchk}{\ensuremath{\mathsf{rchk}}}
\newcommand{\SAIDrchpk}{\ensuremath{\mathsf{rchpk}}}
\newcommand{\SAIDmsg}{\ensuremath{\mathsf{M}}}
\newcommand{\SAIDct}{\ensuremath{\mathsf{C}}}
\newcommand{\KDC}{\ensuremath{{KDC}}}


%=====================================
% SCEKE
%=======================================

\newcommand{\sceke}{\textsf{SCEKE}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Keys:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\sk}{\msg{sk}}
\newcommand{\pk}{\msg{pk}}
\newcommand{\ks}{\msg{K}}
\newcommand{\ipk}[1]{\ensuremath{\mathsf{ipk}_{\myuser{#1}}}}
\newcommand{\prek}[1]{\ensuremath{\mathsf{prek}_{\myuser{#1}}}}
\newcommand{\prepk}[1]{\ensuremath{\mathsf{prepk}_{\myuser{#1}}}}
\newcommand{\ephpk}[1]{\ensuremath{\mathsf{ephpk}_{\myuser{#1}}}}
\newcommand{\ephk}[1]{\ensuremath{\mathsf{ephk}_{\myuser{#1}}}}

\newcommand{\epk}[1]{\ensuremath{\mathsf{Epk}_{\myuser{#1}}}}
\newcommand{\esk}[1]{\ensuremath{\mathsf{ek}_{\myuser{#1}}}}


\newcommand{\ik}[1]{\ensuremath{\mathsf{ik}_{\myuser{#1}}}}
\newcommand{\presk}[1]{\ensuremath{\mathsf{presk}_{\myuser{#1}}}}
\newcommand{\ephsk}[2]{\ensuremath{\mathsf{ephsk}_{\myuser{#1}}^{#2}}}

\newcommand{\sidsk}[2]{\ensuremath{\mathsf{sidsk}_{\myuser{#1}}^{#2}}}
\newcommand{\sidpk}[2]{\ensuremath{\mathsf{sidpk}_{\myuser{#1}}^{#2}}}


\newcommand{\sidcsk}[2]{\ensuremath{\myuser{#1}.X\sid}}
\newcommand{\sidcsgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.X\textsf{stage}}}
\newcommand{\sidssgk}[2]{\ensuremath{\poracle{\myuser{#1}}{#2}.\mathtt{1}\textsf{stage}}}


\newcommand{\currentck}[2]{\ensuremath{\poracle{#1}{#2}.\msg{bk}}}
\providecommand{\currentmk}[2]{\ensuremath{ \poracle{#1}{#2}.k[s]}}
\providecommand{\currentrk}[2]{\ensuremath{ \poracle{#1}{#2}.\rk{s}}}

\newcommand{\pastck}[3]{\ensuremath{\poracle{#1}{#2}.\msg{ck}[{#3}]}}

\newcommand{\msgk}[3]{\ensuremath{\myuser{#1}.\mathsf{k}^{{#2},{#3}}}}

\newcommand{\msk}{\ensuremath{\msg{msk}}}
%\newcommand{\msk}{\ensuremath{\msg{msk}}}
\newcommand{\mpk}{\ensuremath{\msg{mpk}}}


\newcommand{\rchk}[2]{\ensuremath{\mathsf{rchk}_{\myuser{#1}}^{#2}}}
\newcommand{\rchpk}[2]{\ensuremath{\mathsf{Rchpk}_{\myuser{#1}}^{#2}}}
%super ratchet keys
\newcommand{\RCHK}[2]{\ensuremath{\mathsf{t}^{\myuser{#1}}_{#2}}}
\newcommand{\RCHPK}[2]{\ensuremath{\mathsf{T}^{\myuser{#1}}_{#2}}}

\newcommand{\skm}[1]{\ensuremath{\mathsf{SKM}_{\myuser{#1}}}}
\newcommand{\pkm}[1]{\ensuremath{\mathsf{PKM}_{\myuser{#1}}}}

\newcommand{\ski}[1]{sk_{#1}}
\newcommand{\pki}[1]{pk_{#1}}

\newcommand{\rk}[1]{\ensuremath{\mathsf{rk}_{#1}}}
\newcommand{\ck}[2]{\ensuremath{\mathsf{ck}_{\myuser{#1}}^{#2}}}
\newcommand{\tagk}[1]{\ensuremath{\mathsf{tag}^{#1}}}
\newcommand{\mk}[2]{\ensuremath{\mathsf{mk}_{\myuser{#1}}^{#2}}}

\newcommand{\expo}[2]{\ensuremath{\mathsf{(#1)}^{#2}}}

%key space
\newcommand{\kspace}{\ensuremath{\mathcal{K}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Protocol messages//variables:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\pastlist}{\set{D}}
%\newcommand{\rand}{\stackrel{{}_{\$}}{\leftarrow}}
\newcommand{\rand}{\ensuremath{\xleftarrow{\$}}}
\newcommand{\atrandom}{\ensuremath{{\leftarrow}_{\text{R}}}}
\newcommand{\expogroup}{\ensuremath{\mathbb{Z}_\myprime}}
\newcommand{\dhgroup}{\ensuremath{\mathbb{G}_\myprime}}

\newcommand{\ms}[1]{\ensuremath{\msg{ms}_{\myuser{#1}}}}
\newcommand{\ltstate}[1]{\ensuremath{\mathsf{lt.st}_{#1}}}
\newcommand{\ephstatek}{\ensuremath{\mathsf{var}}}
\newcommand{\keytypes}{\ensuremath{\mathsf{ktypes}}}
\newcommand{\keyset}{\ensuremath{\mathsf{key.set}}}
\newcommand{\ephstateK}{\mathcal{V}}
\newcommand{\ephstate}[2]{\ensuremath{\poracle{#1}{#2}.\ephstatek}}
\newcommand{\myad}{\ensuremath{\msg{AD}}}

\newcommand{\pastephstate}[3]{\ensuremath{\poracle{#1}{#2}.\mathsf{keys}[#3]}}

\newcommand{\pubstate}[2]{\ensuremath{\poracle{#1}{#2}.\mathsf{pub.st}}}

\newcommand{\emptystring}{\ensuremath{\varepsilon}}

\newcommand{\KDF}[1]{\ensuremath{{\mathsf{KDF}}_{#1}}}
\newcommand{\HKDF}[1]{\ensuremath{{\mathsf{HKDF}}_{#1}}}
\newcommand{\HMAC}{\ensuremath{\mathsf{HMAC}}}

\newcommand\extracteval[1]{\mathsf{HKDF}.\makett{Ext}(#1)}
\newcommand\expandeval[1]{\mathsf{HKDF}.\makett{XP}(#1)}
\newcommand{\pair}[1]{\ensuremath{e(#1)}}

\newcommand{\trsc}[3]{\poracle{#1}{#2}.Tr[#3]} % transcript for a stage #3, on user #1's side for the convo with #2


%=====================================
% Algorithms
%-=====================================

\newcommand{\fivegp}{\textsf{5GAKE}$_{3}$}
\newcommand{\myprimitive}{\texttt{SCEKE}}
\newcommand{\xnplus}{\texttt{XN}$^{+}$}

\newcommand{\algStart}{\ensuremath{\alg{Start}}}% CRISTINA
\newcommand{\algSend}{\ensuremath{\alg{Send}}}% CRISTINA
\newcommand{\algRKGen}{\ensuremath{\alg{RGen}}}
\newcommand{\algKGen}{\ensuremath{\alg{KeyGen}}}
\newcommand{\algSetup}{\ensuremath{\alg{Setup}}}
\newcommand{\protUReg}{\ensuremath{\Pi_{\mathtt{UReg}}}}
\newcommand{\protStart}{\ensuremath{\Pi_{\mathtt{Start}}}}


\newcommand{\algReceive}{\ensuremath{\alg{Receive}}}
\newcommand{\algextract}{\ensuremath{\makett{Extr}}}

\newcommand{\algttSetup}{\ensuremath{\makett{Setup}}}
\newcommand{\algSIGN}{\ensuremath{\makett{SIGN}}}
\newcommand{\algsign}{\ensuremath{\makett{Sign}}}
\newcommand{\algverify}{\ensuremath{\makett{Vrfy}}}
\newcommand{\algenc}[1]{\ensuremath{\makett{Enc}\left(#1\right)}}
\newcommand{\algdec}[1]{\ensuremath{\makett{Dec}\left(#1\right)}}
\newcommand{\algprf}{\ensuremath{\makett{PRF}}}
\newcommand{\algae}{\ensuremath{\makett{AE}}}
\newcommand{\algaead}{\ensuremath{\makett{AEAD}}}
\newcommand{\algaeadenc}{\ensuremath{\algaead \ensuremath{\makett{.Enc}}}}
\newcommand{\algaeaddec}{\ensuremath{\algaead \ensuremath{\makett{.Dec}}}}

\newcommand{\algmess}{\ensuremath{\makett{Message}}}
\newcommand{\algnonce}{\ensuremath{\makett{Nonce}}}
\newcommand{\algheader}{\ensuremath{\makett{Header}}}

\newcommand{\algmac}{\ensuremath{\makett{MAC}}}

\newcommand{\algaegen}{\ensuremath{\makett{Gen}}}
\newcommand{\algaeinit}{\ensuremath{\makett{AE.Init}}}
\newcommand{\algaedec}{\ensuremath{\makett{AE.Dec}}}
\newcommand{\algaeenc}{\ensuremath{\makett{AE.Enc}}}
\newcommand{\algaestE}{\ensuremath{\mathsf{st}_{\mathsf{E}}}}
\newcommand{\algaestD}{\ensuremath{\mathsf{st}_{\mathsf{D}}}}
\newcommand{\insync}{\ensuremath{\operatorname{\mathsf{in-sync}}}}

\newcommand{\algmain}{\ensuremath{\alg{Main.Exp}}}

\newcommand{\oEnc}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDec}{\ensuremath{\oracle{ADec}}}
\newcommand{\oRDec}{\ensuremath{\oracle{RoR.ADec}}}
\newcommand{\oMess}{\ensuremath{\oracle{Messaging}}}
\newcommand{\oSign}{\ensuremath{\oracle{Sign}}}

\newcommand{\algcommit}{\ensuremath{\makett{Commit}}}
\newcommand{\algmaul}{\ensuremath{\makett{Maul}}}
\newcommand{\algrerand}{\ensuremath{\makett{ReRand}}}
\newcommand{\algopen}{\ensuremath{\makett{Open}}}

\newcommand{\mylist}[1]{\ensuremath{\mathcal{L}_{\mathsf{#1}}}}
\newcommand{\revlist}{\mylist{rev}}
\newcommand{\potlist}{\mylist{maybe}}
\newcommand{\corrlist}{\mylist{corr}}
\newcommand{\tmlist}{\mylist{tm}}
\newcommand{\mallist}{\mylist{mal}}
\newcommand{\lorlist}{\mylist{LoR}}
\newcommand{\cipherlist}{\mylist{ctxt}}
\newcommand{\userlist}{\mylist{usr}}
\newcommand{\sessionlist}{\mylist{\pi}}
\newcommand{\qlist}{\mylist{sign}}
\newcommand{\enclist}{\mylist{enc}}
\newcommand{\qulist}{\mylist{query}}

\newcommand{\shu}[3]{\ensuremath{\mathsf{SHU}(\poracle{#1}{#2},{#3})}} % to know if Send was given honest AD
\newcommand{\rhu}[3]{\ensuremath{\mathsf{RHU}(\poracle{#1}{#2},{#3})}} % to know if Receive was given honest AD


\providecommand{\addtolist}{\ensuremath{\hookleftarrow}}

\providecommand{\successor}[1]{\ensuremath{ {\sf next}(#1)}}
\providecommand{\rdec}{\ensuremath{m}}
\providecommand{\renc}{\ensuremath{c}}
\providecommand{\achoice}{\ensuremath{\beta}}

\providecommand{\forgery}[1]{\ensuremath{{#1}^*}}

\newcommand{\myrelation}{\mathcal{R}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Oracles:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\oUReg}{\ensuremath{\oracle{UReg}}}
\newcommand{\oInit}{\ensuremath{\oracle{Start}}}
\newcommand{\oSend}{\ensuremath{\oracle{Send}}}
\newcommand{\oReceive}{\ensuremath{\oracle{Receive}}}
\newcommand{\oReveal}{\ensuremath{\oracle{Reveal}}}
\newcommand{\oRevealCS}{\ensuremath{\oracle{Reveal.XStage}}}
\newcommand{\oRevealSS}{\ensuremath{\oracle{Reveal.\mathtt{1}Stage}}}
\newcommand{\oCorrupt}{\ensuremath{\oracle{Reveal.XSid}}}
\newcommand{\oEncrypt}{\ensuremath{\oracle{AEnc}}}
\newcommand{\oDecrypt}{\ensuremath{\oracle{ADec}}}
\newcommand{\oHSM}{\ensuremath{\oracle{AccessSK}}}
\newcommand{\oracleSet}{\ensuremath{\mathcal{O}}}
\newcommand{\oRevMed}{\ensuremath{\oracle{RevMedKey}}}

\newcommand{\oTest}{\ensuremath{\oracle{Test}}}
\newcommand{\ROM}{\ensuremath{\mathcal{RO}}}

\newcommand{\danger}[1]{\mathsf{Danger(#1)}}
\newcommand{\actdan}[1]{\mathsf{Act.Dan(#1)}}
\newcommand{\hijack}[1]{\mathsf{Hijack(#1)}}
\newcommand{\leak}[1]{\mathsf{Leak(#1)}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Adversaries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\adv}{\ensuremath{\mathcal{A}}}
\newcommand{\adversary}{\ensuremath{\mathcal{A}}}
\newcommand{\challenger}{\ensuremath{\mathcal{C}}}
\newcommand{\bdv}{\ensuremath{\mathcal{B}}}
\newcommand{\cdv}{\ensuremath{\mathcal{C}}}
\newcommand{\ddv}{\ensuremath{\mathcal{D}}}
\newcommand{\edv}{\ensuremath{\mathcal{E}}}
\newcommand{\fdv}{\ensuremath{\mathcal{F}}}
\newcommand{\gdv}{\ensuremath{\mathcal{G}}}
\newcommand{\idv}{\ensuremath{\mathcal{I}}}

\providecommand{\advstate}[1]{\ensuremath{\mathsf{state}_{#1}}}

\newcommand{\simulator}{\ensuremath{\mathsf{Sim}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Advantages & security properties
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\newcommand{\secpar}{\ensuremath{1^\lambda}}
\newcommand{\spar}{\ensuremath{\mathsf{s\param}}}
\newcommand{\ppar}{\ensuremath{\mathsf{p\param}}}
\newcommand{\param}{\ensuremath{\mathsf{param}}}

\newcommand{\myprot}{\ensuremath{\Pi}}

%\newcommand{\proto}[2]{\ensuremath{\mathsf{\Pi^{\myuser{#1}}_{\myuser{#2}}}}}

\newcommand{\scprop}{\ensuremath{\mathsf{SC}}}
\newcommand{\sacce}{\ensuremath{\mathsf{SACCE}}}
\newcommand{\acce}{\ensuremath{\mathsf{ACCE}}}
\newcommand{\ake}{\ensuremath{\mathsf{AKE}}}
\newcommand{\sake}{\ensuremath{\mathsf{S\text{-}AKE}}}

\newcommand{\expgame}[1]{\ensuremath{\mathsf{Exp}_\myprot^{#1}(\lambda ,\adv)}}
\newcommand{\pcsakegame}{\ensuremath{\expgame{\mathsf{PCS\text{-}AKE}}}}
\newcommand{\ooogame}{\ensuremath{\expgame{\mathsf{MLR}}}}



\newcommand{\pfsgame}{\ensuremath{\expgame{\mathsf{AKE}}}}
\newcommand{\exfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\pfsexfgame}{\ensuremath{\expgame{\mathsf{Exf}}}}
\newcommand{\eufcmagame}{\ensuremath{\expgame{\mathsf{EUF-CMA}}}}
\newcommand{\kdfgame}{\ensuremath{\expgame{\mathsf{KDF}}}}
\newcommand{\lhaegame}{\ensuremath{\expgame{\mathsf{LHAE}}}}
\newcommand{\aeadgame}{\ensuremath{\expgame{\mathsf{AEAD}}}}

\newcommand{\akefwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}S\text{-}AKE}}}}}
\newcommand{\pfsfwgame}{\ensuremath{\expgame{\operatorname{\mathsf{FW\text{-}AKE}}}}}


\newcommand{\eaprop}{\ensuremath{\mathsf{EA}}}
\newcommand{\accprop}{\ensuremath{\mathsf{Acc}}}
\newcommand{\csoundprop}{\ensuremath{\mathsf{CSound}}}

\newcommand{\csound}{\ensuremath{\mathsf{CSound}}}

\newcommand{\nbparty}{\ensuremath{\mathsf{n_P}}}
\newcommand{\nbstages}{\ensuremath{\mathsf{n_S}}}
\newcommand{\nbinstances}{\ensuremath{\mathsf{n_\pi}}}
\newcommand{\nbmedkeys}{\ensuremath{\mathsf{n_{\prek{}}}}}


\newcommand{\Prob}{\mathbb{P}}

\newcommand{\gadvantage}[1]{\ensuremath{\mathsf{Adv}_{#1}}}
\newcommand{\padvantage}[3]{\ensuremath{\mathsf{Adv}^{#3}_{#2}({#1})}}
\newcommand{\advsc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\scprop}}}
\newcommand{\advea}[1]{\ensuremath{\padvantage{#1}{\myprot}{\eaprop}}}
\newcommand{\advacc}[1]{\ensuremath{\padvantage{#1}{\myprot}{\accprop}}}
\newcommand{\advcsound}[1]{\ensuremath{\padvantage{#1}{\myprot}{\csoundprop}}}
%\newcommand{\advsake}[1]{\ensuremath{\padvantage{#1}{\myprot}}}
\newcommand{\advunf}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{Unf}}}}
\newcommand{\advprop}[1]{\ensuremath{\padvantage{#1}{\myprot}{\mathsf{prop}}}}

\newcommand{\advake}[1]{\ensuremath{\padvantage{#1}{\Psi}{\mathsf{AKE}}}}

\newcommand{\advpcs}[1]{\ensuremath{\padvantage{#1}{\Pi}{\mathsf{PCS-AKE}}}}


\newcommand{\advcres}[1]{\ensuremath{\padvantage{#1}{H}{\mathsf{C.Res}}}}
\newcommand{\adveufcma}[1]{\ensuremath{\padvantage{#1}{\mathsf{Sign}}{\mathsf{EUF-CMA}}}}

\newcommand{\advgdh}[1]{\ensuremath{\padvantage{#1}{\mathsf{}}{\mathsf{GDH}}}}


\newcommand{\advlhae}[1]{\ensuremath{\padvantage{#1}{\mathsf{\algaead}}{\mathsf{LHAE}}}}

\newcommand{\advsacce}[2]{\ensuremath{\padvantage{#1}{#2}{\sacce}}}
\newcommand{\advacce}[2]{\ensuremath{\padvantage{#1}{#2}{\acce}}}

\newcommand{\advpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{AKE}}}}
\newcommand{\advsake}[2]{\ensuremath{\padvantage{#1}{#2}{\sake}}}


\newcommand{\advexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}
\newcommand{\advpfsexf}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{Exf}}}}


\newcommand{\advfwpfs}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW\text{-}PFS}}}}
\newcommand{\advfwsake}[2]{\ensuremath{\padvantage{#1}{#2}{\mathsf{FW}\text{-}\sake}}}
\newcommand{\advAKE}[2]{\ensuremath{\padvantage{#1}{#2}{\ake}}}
\newcommand{\advae}[1]{\ensuremath{\padvantage{#1}{\mathsf{AE}}{\mathsf{stLHAE}}}}
\newcommand{\advaead}[1]{\ensuremath{\padvantage{#1}{\mathsf{Enc,Dec}}{\mathsf{AEAD}}}}

\newcommand{\clock}{\ensuremath{\mathsf{clock}}}
\newcommand{\game}[1]{\ensuremath{\mathbb{G}\mathsf{ame}_{#1}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% names
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pname}{On the Leakage of Fuzzy Matchers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Layout and style:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\myparagraph}[1]{\vspace{2mm} \noindent \textbf{#1.}}
\newcommand{\mysubpar}[1]{\noindent \hspace{1mm} \textbf{\underline{#1.}} \hspace{1mm}}
\newcommand{\gamehop}[1]{\ensuremath{\mathbb{G}_{#1}} \vspace{1mm}}
\newcommand{\accro}{\ensuremath{\mathsf{3(S)ACCE}}}
\newcommand{\nth}[1]{\ensuremath{{#1}\textnormal{-th}}}

\newcommand{\exec}{\ensuremath{\leftarrow}}

\newcommand{\ie}{\emph{i.e.}, }
\newcommand{\eg}{\emph{e.g.}, }
\newcommand{\etal}{\emph{et al.}}

\newcommand{\Gr}{\mathbb{G}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zq}{\mathbb{Z}_q}
\newcommand{\Zp}{\mathbb{Z}_p}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\mymax}[2]{\ensuremath{\textsc{MAX}\big[#1, #2\big]}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% proocol's variables
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\alghash}{\ensuremath{\makett{H}}}
\newcommand{\randomness}{\ensuremath{r}}
\newcommand{\gtor}{\ensuremath{h}}
\newcommand{\generator}{\ensuremath{g}}
\newcommand{\idsign}{\ensuremath{\alg{ID}\algsign}}
\newcommand{\idverify}{\ensuremath{\alg{ID}\algverify}}
\newcommand{\abort}{\ensuremath{\msg{abort}}}
\newcommand{\concat}{\ensuremath{||}}
\newcommand{\ibe}{\ensuremath{\makett{IBE}}}



\newcommand{\ibs}{\ensuremath{\mathsf{IBSig}}}
\newcommand{\ibsSetup}{\ensuremath{\alg{IBS.Setup}}}
\newcommand{\ibsExtract}{\ensuremath{\alg{IBS.Extract}}}
\newcommand{\ibsSign}{\ensuremath{\alg{IBS.Sign}}}
\newcommand{\ibsVf}{\ensuremath{\alg{IBS.Vfy}}}

\newcommand{\ibsparams}{\ensuremath{\mathsf{IBS.ppar}}}
\newcommand{\ibsmpk}{\ensuremath{\mathsf{IBS.mpk}}}
\newcommand{\ibsmsk}{\ensuremath{\mathsf{IBS.msk}}}

\newcommand{\ibssk}{\ensuremath{\mathsf{IBS.sk}}}
\newcommand{\ibsusk}[1]{\ensuremath{\ibssk_{\myid{#1}}}}

\newcommand{\idmpk}{\ensuremath{\mathsf{ID.mpk}}}
\newcommand{\idmsk}{\ensuremath{\mathsf{ID.msk}}}
\newcommand{\idsk}[1]{\ensuremath{\mathsf{ID.sk}_{#1}}}
\newcommand{\mytag}[1]{\ensuremath{\mathsf{tag}^{#1}}}

\newcommand{\meta}{\ensuremath{\mathsf{meta}}}





\newcommand{\idenc}{\ensuremath{\makett{ID}\algenc}}
\newcommand{\signature}{\ensuremath{\mathsf{sgn}}}
\newcommand{\AD}{\textnormal{AD}}
\newcommand{\M}{M}
\newcommand{\dhoutput}{\ensuremath{\Delta}}
\newcommand{\dhout}[1]{\ensuremath{\mathsf{DH}^{#1}}}
% signature on stage x,y
\newcommand{\sig}[1]{\ensuremath{\sigma_{#1}}}
%%%%%%%%%%%%%%
%% ENVIRONMENTS %%
%%%%%%%%%%%%%%
\newtheorem{definition}{Definition}      %commented for LNCS
\newtheorem{theorem}{Theorem}      %commented for LNCS
\newtheorem{proof}{Proof}

%scale (equation)
\newcommand*{\Scale}[2][4]{\scalebox{#1}{$#2$}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% 5G-AKA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\aka}{\ensuremath{\mathsf{AKA}}}
\newcommand{\topc}{\ensuremath{\mathsf{Top}_C}}
\newcommand{\UE}{\party{UE}}
\newcommand{\HN}{\party{HN}}
\newcommand{\SN}{\party{SN}}
\newcommand{\gNB}{\party{gNB}}
\newcommand{\core}{\party{Core}}

\newcommand{\USIM}{\ensuremath{\mathsf{USIM}}}
\newcommand{\TMSI}{\ensuremath{\mathsf{TMSI}}}
\newcommand{\SUPI}{\ensuremath{\mathsf{SUPI}}}
\newcommand{\SUCI}{\ensuremath{\mathsf{SUCI}}}
\newcommand{\GUTI}{\ensuremath{\mathsf{GUTI}}}
\newcommand{\AG}{Assign-\ensuremath{\mathsf{GUTI}}}
\newcommand{\IMSI}{\ensuremath{\mathsf{IMSI}}}
\newcommand{\SQNU}{\ensuremath{\mathsf{SQN_U}}}
\newcommand{\SQNN}{\ensuremath{\mathsf{SQN_H}}}
\newcommand{\SQNs}{\ensuremath{\mathsf{SQN_s}}}
\newcommand{\pubenc}[2]{\ensuremath{\{#1\}^{#2}_\pk}}

\newcommand{\mycard}{\ensuremath{\mathsf{U}}}
%\newcommand{\sk}{\ensuremath{\mathsf{sk}}}
\newcommand{\sksub}[1]{\ensuremath{\sk_{#1}}}
\newcommand{\skop}{\ensuremath{\sk_\mathsf{op}}}
\newcommand{\sqn}[1]{\ensuremath{\mathsf{SQN_{#1}}}}
\newcommand{\myop}{\ensuremath{\mathsf{H}}}
\newcommand{\av}{\ensuremath{\mathsf{AV}}}
\newcommand{\autn}{\ensuremath{\mathsf{Autn}}}
\newcommand{\res}{\ensuremath{\mathsf{Res}}}
\newcommand{\akey}{\ensuremath{\mathsf{AK}}}
\newcommand{\myterm}{\ensuremath{\mathsf{T}}}
\newcommand{\Mac}{\ensuremath{\mathsf{Mac}}}
\newcommand{\Macsn}{\ensuremath{\Mac_{\mathsf{\myterm}}}}
\newcommand{\MAC}{\ensuremath{\mathsf{MAC}}}
\newcommand{\ckey}{\ensuremath{\mathsf{CK}}}
\newcommand{\ikey}{\ensuremath{\mathsf{IK}}}
\newcommand{\Macns}{\ensuremath{\Mac_{\mathsf{\mycard}}}}
\newcommand{\amf}{\ensuremath{\mathsf{AMF}}}
\newcommand{\RAND}[1]{\ensuremath{\mathsf{R}_{#1}}}
\newcommand{\nametl}{\ensuremath{\mathsf{VLR}}}
\newcommand{\namebackend}{\ensuremath{\mathsf{HLR}}}
\newcommand{\lai}{\ensuremath{\mathsf{LAI}}}
\newcommand{\uid}{\ensuremath{\mathsf{UID}}}
\newcommand{\func}[1]{\ensuremath{#1}}
\newcommand{\funcF}[1]{\ensuremath{\func{\mathcal{F}}_{#1}}}
\newcommand{\funcFstar}[1]{\ensuremath{\funcF{#1}^*}}


\newcommand{\xor}{\ensuremath{\oplus}}

\newcommand{\stack}{\emph{5G-SCEKE}}
\newcommand{\stackplus}{\emph{5G-SCEKE$^{+}$}}



%=================================================
% Comments :
%=================================================
%\usepackage{pifont}
\newlength{\strutdepth}%
\settodepth{\strutdepth}{\strutbox}%
\newcommand{\mycomment}[3]{%
    \noindent{\bfseries
        \color{#2}{#1}\color{black}}%
    \strut\vadjust{\kern-\strutdepth%
        \vtop to \strutdepth{%
            \baselineskip\strutdepth%
            \vss\llap{{\large\color{#2}#3\quad\color{black}}}\null%
        }%
    }%
}

\newcommand{\axel}[1]{\mycomment{#1}{magenta}{Axel}}
\newcommand{\kev}[1]{\mycomment{#1}{blue}{Kevin}}
\newcommand{\pascal}[1]{\mycomment{#1}{olive}{Pascal}}
\newcommand{\leo}[1]{\mycomment{#1}{orange}{Leo}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% tikz:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\link}{ \draw[<->,>=latex]}
\newcommand{\att}{ \draw[-latex,dashed,ultra thick]}

\newcommand*{\QEDB}{\null\nobreak\hfill\ensuremath{\square}}%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% modifications:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\removetext}[1]{{\color{red}{\sout{#1}}}}
\newcommand{\addtext}[1]{{\color{teal}{#1}}}
\newcommand{\replacetext}[2]{\removetext{#1} \addtext{#2}}

\newcommand{\serveur}[0]{\ensuremath{\mathcal{S}}}
\newcommand{\client}[0]{\ensuremath{\mathcal{C}}}
\newcommand{\pwd}[0]{\ensuremath{\mathsf{pwd}}}

\newcommand{\databio}[0]{\ensuremath{\mathsf{bio}}}
\newcommand{\helpvalue}[0]{\ensuremath{\mathcal{\nu}}}
\newcommand{\pubclient}[0]{\ensuremath{\mathsf{P_u}}}
\newcommand{\privclient}[0]{\ensuremath{\mathsf{p_u}}}

\newcommand{\pubserv}[0]{\ensuremath{\mathsf{P_s}}}
\newcommand{\privserv}[0]{\ensuremath{\mathsf{p_s}}}

\newcommand{\keyserv}[0]{\ensuremath{\mathsf{k_s}}}

\newcommand{\rw}[0]{\ensuremath{\mathsf{rw}}}
\newcommand{\hash}[1]{\ensuremath{\mathcal{H}\left(#1\right)}}
\newcommand{\authenv}[1]{\ensuremath{\mathsf{AuthEnv}\left(#1\right)}}
\newcommand{\authenvrw}[1]{\ensuremath{\mathsf{AuthEnv}_{\rw}\left(#1\right)}}
\newcommand{\aec}[0]{\ensuremath{\mathsf{c}}}
\newcommand{\cval}[0]{\ensuremath{\alpha}}
\newcommand{\sval}[0]{\ensuremath{\beta}}


\newcommand{\algen}[2]{\ensuremath{\makett{Enc}_{#1}\left(#2\right)}}

\newcommand{\algencbio}[1]{\ensuremath{\makett{Enc}_{\databio}\left(#1\right)}}
\newcommand{\algdecbio}[1]{\ensuremath{\makett{Dec}_{\databio}\left(#1\right)}}


\newcommand{\Fq}[0]{\ensuremath{\mathbb{F}_q}}
\newcommand{\Fqn}[0]{\ensuremath{\mathbb{F}_q^n}}
\newcommand{\Fdn}[0]{\ensuremath{\mathbb{F}_2^n}}
\newtheorem{theo}{Theorem}[section]
\newtheorem{rem}{Remark}[subsection]
\newtheorem{ex}{Example}[subsection]

\newcounter{protocol}
\newenvironment{protocol}[1]
{\par\addvspace{\topsep}
    \noindent
    \tabularx{\linewidth}{@{} X @{}}
    \hline
    \refstepcounter{protocol}\textbf{Protocol \theprotocol} #1 \\
    \hline}
{\\
    \hline
    \endtabularx
    \par\addvspace{\topsep}}

\newcommand{\sbline}{\\[.5\normalbaselineskip]}% small blank line



\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\begin{document}

\title{\pname
    %\thanks{This study was partially supported by the French ANR project ANR.}
}

\author{\IEEEauthorblockN{DURBET Axel}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne,} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
axel.durbet@uca.fr}\\
\and
\IEEEauthorblockN{THIRY-ATIGHEHCHI Kevin}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne, 
} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
kevin.atighehchi@uca.fr}\\
%\linebreakand 
\linebreakand
\IEEEauthorblockN{CHAGNON Dorine}
\IEEEauthorblockA{\textit{LIMOS, Université Clermont-Auvergne,} \\
\textit{CNRS, Mines Saint-Étienne,}\\
\textit{Aubière, France}\\
dorine.chagnon@uca.fr}\\
\and
\IEEEauthorblockN{GROLLEMUND Paul-Marie}
\IEEEauthorblockA{\textit{LMBP, Université Clermont Auvergne,}\\
\textit{CNRS, UMR 6620,}\\
\textit{Aubière, France}\\
paul\_marie.grollemund@uca.fr}\\

}

\maketitle


\begin{abstract}
    
    In a biometric authentication or identification system, the matcher compares a stored and a fresh template to  determine whether there is a match. This assessment is based on both a similarity score and a predefined threshold.
    For better compliance with privacy legislation,
    the matcher can be built upon a threshold-based obfuscated distance (\textit{i.e.}, Fuzzy Matcher).
    Beyond the binary output ("yes" or "no"), most algorithms perform more precise computations, \textit{e.g.}, the value of the distance. 
    Such precise information is prone to leakage even when not returned by the matcher.
    This can occur due to a malware infection or the use of a weakly privacy-preserving matcher, exemplified by side channel attacks or partially obfuscated designs.
    This paper provides an analysis of information leakage during distance evaluation, with an emphasis on threshold-based obfuscated distance.
    We provide a catalog of information leakage scenarios with their impacts on 
    data privacy.
    Each scenario gives rise to unique attacks with impacts quantified in terms of computational costs, thereby providing a better understanding of the security level.
\end{abstract}

\begin{IEEEkeywords}
Obfuscated Distance, Fuzzy Matcher, Hamming Distance, Information Leakage, Biometric Security, Coupon Collector Problem
\end{IEEEkeywords}

\section{Introduction}\label{intro}
Obfuscated distance functions allow multiple parties to compute the distance between hidden inputs. They reveal partial or complete information about their distance while preserving their privacy.
Several methods exist for designing an obfuscated distance.
The first one is to perform operations directly on encrypted input to preserve confidentiality. Building blocks based on homomorphic cryptography are useful to achieve such computations, as mentioned by Yasuda~\cite{yasuda2017secure}.
Another approach is to compute a predefined function on encrypted input without disclosing any information other than the evaluation of the function. Unlike the aforementioned approach, this method prevents operations on the encrypted inputs. The first method employs
Garbled Circuit, as introduced by Huang~\textit{et al.}~\cite{huang2011faster} and Bellare~\textit{et al.}~\cite{bellare2012foundations}.
The second one involves Functional Encryption as illustrated by Okamoto and Takashima~\cite{Okamoto2012} and Tomida~\cite{tomida2020tightlyIPFE}.
The final approach for executing a secure multiparty computation while ensuring the input privacy is through Oblivious Transfer as showed by Bringer~\cite{bringer2017security} and Kiraz~\textit{et al.}~\cite{kiraz2015security}.

Additional mathematical methodologies for the Hamming distance founded on computational assumptions are possible alternatives. Karabina and Canpolat~\cite{KARABINA2016NTT} present a secure scheme that corrects close inputs and does not require any encryption infrastructure. Input privacy is ensured through the complexity of the discrete logarithm and knapsack problem. 
Likewise, Galbraith and Zobernig~\cite{Galbraith2019PFH} describe a scheme built upon the decisional distributional modular subset product problem, yielding similar outcomes. 
Fleischhacker~\textit{et al.}~\cite{fleischhacker2022property} design Property-Preserving Hash Functions to discern whether two inputs are close with respect to a specified threshold. Input privacy is guaranteed through the robustness and standard lattice hardness assumptions.%}

The obfuscated distance can be used in biometric applications to ensure client privacy while preserving the efficiency of biometric recognition. However, to enhance the privacy of the hidden input, a threshold-based obfuscated distance (\textit{i.e.}, Fuzzy Matcher) related to error-correcting codes is preferred as the distance is not disclosed above the threshold.
Error correcting code enables the detection and correction of errors occurring during data transmission or storage, guaranteeing dependable and accurate data retrieval, as demonstrated by Huffman and Pless~\cite{huffman2010fundamentals}.
Based on the previous building block, Fuzzy Vaults were introduced by Juels and Sudan~\cite{juels2006fuzzy}. 
Fuzzy Vaults ensure the privacy of the biometric input by combining it with false information (chaff points) derived from a secret.
Later, Dodis~\textit{et al.}~\cite{dodis2008fuzzy} develop Secure Sketches and Fuzzy Extractors which respectively allow the recovery of hidden input and the reproduction of a key based on a noisy input. Finally, Fuller~\textit{et al.}~\cite{fuller2020computational} introduced Computational Fuzzy Extractors that guarantee input privacy and rely on computational assumptions instead of information-theoretic assumptions.

The security of the mentioned building blocks is typically assessed through adversarial models that rule out vulnerabilities arising in concrete applications.
They can be subject to implementation errors, malware intrusion, and inherent construction flaws. Furthermore, Aydin and Aysu~\cite{HomoLeak} and Hashemi~\textit{et al.}~\cite{hashemi2023time} have highlighted an increasing prevalence of side-channel attacks. As a result, the provided security analyses  are currently reaching their limits.
One possible concern is the partial leakage of distance computation information, which could lead to unintended information disclosure during the execution of the function. Such inadvertent disclosures pose significant security and privacy risks, especially in sensitive applications like privacy-preserving applications (\textit{e.g.}, biometric recognition systems). 
In this paper, we focus on the following attacks:
\begin{itemize}
\item  \textit{Offline exhaustive search attacks} refer to scenarios for which a leaked yet obfuscated database is available for an attacker. The attacker employs a cryptographic obfuscation scheme to verify a candidate vector, such as a biometric template or utilizes a hash function to validate a candidate hashed password. 
\item \textit{Online exhaustive search attacks} correspond to attacks for which an attacker must interact with the authentication server to infer information about the targeted vector.
In this case, the attacker needs to force the matcher to leak additional information beyond the minimal information leakage (`yes' or `no'), for example via a malware infection.
\end{itemize}


\paragraph*{Related Works}
To the best of our knowledge, two papers investigate information leakage of fuzzy matchers.
Pagnin~\textit{et al.}~\cite{pagnin2014leakage} shows that the output of a fuzzy matcher can be exploited to infer the hidden input.
This type of attack is considered as the most devastating for such systems, as evidenced by Simoens~\textit{et al.}~\cite{Simoens2012AFF}.
The work of Pagnin~\textit{et al.} takes place in the minimal leakage scenario, wherein only the binary output of the matcher is given to the attacker.
The authors present the \textit{Center Search Attack}, designed to recover the hidden enrolled input for any 'valid' biometric template in $\mathbb{Z}_q^n$, where 'valid' refers to inputs within a ball centered at the enrolled template and with a radius equal to the decision threshold $t$. 
This \textit{Center Search Attack} is executed using a number of authentications that is linear with respect to the dimension $n$.
To efficiently locate a valid input, the authors also examine the exhaustive search attack, particularly its application on binary templates ($q=2$). 
They suggest implementing a \textit{sampling without replacement} strategy using their \textit{Tree algorithm} to streamline the identification of a suitable input for the Center Search Attack.
This efficient identification of a proper input requires a number of authentication attempts that is exponential in the space dimension $n$ minus the threshold $t$.
While their work focuses on the minimal leakage scenario, our analysis includes the consideration of multiple additional information leaks that may arise during the matching operation.


\paragraph*{Contributions}
We present an analysis of potential information leakage in distance evaluation, with a specific focus on threshold-based obfuscated distance. 
The contributions consist of various information leakage scenarios, the corresponding generic attacks, and their complexities.
The discussed scenarios give rise to new attacks:% that complete the work of Pagnin~\textit{et al.}~\cite{pagnin2014leakage}:
\begin{itemize}
\item Accumulation attacks that capture potential attacks from an \textit{honest-but-curious} server during a client authentication. These attacks assume the use of privacy-preserving cryptographic building blocks for evaluating the distance between two hidden inputs. Specifically, as an example, we assume the use of a cryptographic obfuscator for the distance function.
\item Attacks from malicious clients exploiting various information leakages from the matcher in the context of a leaked (but obfuscated) database, or by interacting with the server during an \textit{online exhaustive search attack}. 
\end{itemize}

The complexities of the attacks, relying on different scenarios, are summarized in Table~\ref{summary_table}. 


\begin{table*}[]
\centering
\begin{tabular}{@{}cccc@{}}
\toprule
Complexity type         & Distance-to-Threshold Comparison     & Leakage                      & Theorem \\ \midrule
\multirow{3}{*}{Exponential}                   & \multirow{3}{*}{Below} & Distance                                       &   \ref{th-below-leak-dist}      \\
                        &                        & Position                                      &   \ref{th-below-leak-pos}      \\
                        & & Positions and values & \ref{th-below-leak-value-and-pos}\\\cmidrule{2-4}
                        &          Both              & Minimal                                         &   \ref{th-both-minimal}      \\ \midrule
    Linearithmic                     & Below                  & Positions and values (accumulation) & \ref{th-acc} \\ \midrule
\multirow{1}{*}{Linear}      & \multirow{1}{*}{Both}  & Distance                                       &   \ref{th-both-dist-leak}      \\\midrule
                       
\multirow{2}{*}{Constant} & \multirow{2}{*}{Both}                   & Positions                                      &   \ref{th-both-pos-leak}      \\
                        & & Position and values & \ref{th-both-pos-and-val-leak} \\\bottomrule
\end{tabular}
\caption{\label{summary_table} Leakage settings and their exploit complexities.}
\end{table*}

\paragraph*{Outline}
Section~\ref{prel} provides the definition of a fuzzy matcher, introduces some notations and terminologies, and classifies the different information leakages.
Section~\ref{attacks} first introduces the accumulation attack and analyzes its complexity.
This section then provides a description of various attacks corresponding to the identified scenarios, along with their complexities.
Section~\ref{Conclu} provides a discussion of the presented results.

\section{Preliminaries}
\label{prel}
%{\color{blue}
This section introduces the (Obfuscated) Matcher, a function used to test the proximity of two hidden inputs. The notations used throughout this paper are presented, along with a list of all the considered information leakage scenarios.
%}


\subsection{(Obfuscated) Matcher}
\label{Bg}
Let $\Zq^n$ (the set of vectors of size $n$ with value in $\llbracket 0,\dots, q-1 \rrbracket$) be a metric space equipped with the distance $d$ and $\varepsilon\in\mathbb{R}_{\ge 0}$ a threshold. 
A private matching scheme $\Xi$ is a pair of algorithms \texttt{Hide} and \texttt{Match} which respectively allows hiding a data $x\in \Zq^n$ and checking if a newly provided data $y\in \Zq^n$ is such that $d(x,y) \leq \varepsilon$. 
\begin{definition}[Hide]
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, $\mathbb{K}$ a space, and $\varepsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $x\in\Zq^n$,
    \begin{eqnarray*}
        \Xi.\texttt{Hide}: &  \Zq^n & \xrightarrow{} \mathbb{K} \\
        & x & \mapsto X
    \end{eqnarray*}
    such that $\Xi.\texttt{Hide}$ is computed by a polynomial time algorithm (PPT), but any polynomial time randomized algorithm $\mathcal{A}$ that attempts to compute a pseudo-inverse for $\Xi.\texttt{Hide}$ succeeds with negligible probability.
\end{definition}

Once $x$ has been hidden by the function $\Xi.\texttt{Hide}$, it is possible to check using $\Xi.\texttt{Match}$ if a vector $y$ is close to $x$ with respect to a threshold $\varepsilon$. In other words, $\Xi.\texttt{Match}$ indicates if $y\in B_\varepsilon(x)$, where $B_\varepsilon(x) = \lbrace y \in \Zq^n \,| d(x,y)\leq \varepsilon \rbrace$ is the ball of radius $\varepsilon$ and centered in $x$.
\begin{definition}[Match]
    Let $\Xi$ be a matching scheme, $\Zq^n$ be a metric space equipped with the distance $d$, $x\in \Zq^n$, $\mathbb{K}$ be $\Xi.\texttt{Hide}(\Zq^n)$ and $\varepsilon\in\mathbb{R}_{\ge 0}$ a threshold. Given $Y\in\mathbb{K}$ the output of $\Xi.\texttt{Hide}(y)$ and $X\in\mathbb{K}$ the output of $\Xi.\texttt{Hide}(x)$, 
    \begin{eqnarray*}
        \Xi.\texttt{Match}: &  \mathbb{K} \times \mathbb{K} & \xrightarrow{} \lbrace 0, 1 \rbrace \\
        & Y, X  & \mapsto \begin{cases}
        0 & \text{ if } d(x,y)\leq \varepsilon, \\
        1 & \text{ otherwise}, \\ 
        \end{cases}
    \end{eqnarray*}
    such that $\Xi.\texttt{Match}$ is a deterministic polynomial time algorithm that succeeds with probability $1$.
\end{definition}

\begin{rem}
    Both $\Xi.\texttt{Match}$ inputs are hidden by the function $\Xi.\texttt{Hide}$.
\end{rem}


To simplify, we assume that a vector $y \in \mathbb{Z}_q^n$ can be directly used with $\Xi.\texttt{Match}$, \textit{i.e.}, pre-transformation $\Xi.\texttt{Hide}(y)$ is omitted when it is not necessary. The $\Xi.\texttt{Match}$ function has the possibility to disclose certain information, and its possible leakage scenarios are described in the following sections.


\subsection{Examples of Information Leakage}

%This section provides some examples highlighting the idea of information leakage, which motivated the present work.

This section presents some examples of leaking fuzzy matchers, which motivate the present work.


\paragraph{Obfuscated Fuzzy Hamming Distance}
Galbraith \textit{et al.} \cite{Galbraith2019PFH} provide an obfuscator that enables testing whether the Hamming distance between an $n$-bit input and a fixed $n$-bit target vector is smaller than a predetermined threshold.
The primary application discussed is biometric matching, where a biometric reading is acquired and matched with a stored template.
%We utilize the notations from Galbraith~\textit{et al.}~\cite{Galbraith2019PFH}.
Algorithm $7.2$ (\textit{Encoding}) and Algorithm $7.4$ (\textit{Decoding})  of~\cite{Galbraith2019PFH} respectively instantiate the previously defined functions $\Xi.\texttt{Hide}$ and  $\Xi.\texttt{Match}$.
When the distance is below the threshold, this obfuscator decodes the errors and hence leaks their corresponding positions and values.
% {\color{red}
% \textit{Encoding} and \textit{Decoding} design is an obfuscated distance
% that allows correcting an input if this one is close to the enrolled one yielding a leak of information below the threshold. 
% }

\paragraph{Error Correcting Code}
A fuzzy matcher can use an error-correcting code to recover a code word by providing a close input with respect to a threshold and a distance. For instance, syndrome decoding~\cite{esser2022syndrome} identifies error patterns through a matrix-vector product that reveals the position and value of those errors. More generally, all error-correcting codes, by design, leak the position and value of errors.

\paragraph{Inner Product Functional Encryption with Function Privacy}
Another example is a fuzzy matcher built on top of a functional encryption scheme whose functionality is to provide a secret key for evaluating an inner product~\cite{datta2016functional,kim2018function}. The desired distance function (\textit{e.g.}, Hamming distance) can be formulated as an inner product. The security of these building blocks is analyzed in adversarial models that rule out simple attacks like hill-climbing attacks, as the scheme directly leaks the distance.





% To hide the input $x \in \mathbb{Z}_2^n$, the \textit{encoding} algorithm generates a public list of prime numbers $(p_i)_{i \in \lbrace 1, \dots, n \rbrace}$ and encodes them into $X$, which is the product of $p_i$ raised to the power of $x_i$ modulo another prime $q$. In other words, the hidden data is $X = \prod_{i=1}^n p_i^{x_i} \mod q$. This transformation scheme has been proven irreversible, \textit{i.e.}, retrieving $x$ from $X$ is computationally hard. 
% The security relies on the modulo operation disrupting the structure of the product, making factorization impossible if the product exceeds the modulo. Such modulus is chosen with respect to a threshold $t$, such that if the weight of $x$ exceeds $t$, the product exceeds the modulus as well. 

% {\color{purple}
% To retrieve the original input, the \textit{decoding} algorithm takes as input a vector $y\in\mathbb{Z}_2^n$ such that $d(x,y)\leq t$. Subsequently, this input is encoded using the same primes, leading to $Y = \prod_{i=1}^n p_i^{y_i} \mod q$. Since the distance is below the threshold, the product $E = XY^{-1} = \prod_{i=1}^n p_i^{x_i-y_i} \mod q$ can be factorized. Indeed, the weight of $\delta=(|x_1-y_1|,\dots,|x_n-y_n|)$ is below the threshold. The factorization of $E$ yields the indices and values of the errors. This information is then utilized to compute the error vector $m$, such that $x = y + m$.
% The \textit{decoding} algorithm needs to be slightly adapted to fit our $\Xi.\texttt{Match}$ definition. The encoding of the input $y$ will occur outside this algorithm, and it now takes $Y$ as input. There are two possibilities: either the algorithm successfully computes $m$ meaning that the distance between $x$ and $y$ is below the threshold, or the algorithm fails and the distance exceeds the threshold. Consequently, instead of returning $m$, it outputs either yes or no.
% However, as $m$ is still computed in the case where the distance between $x$ and $y$ is below the threshold, this is information that an attacker can retrieve.
% This information grants the attacker access to several details about the hidden inputs such as:
% \begin{itemize}
%     \item The computation of the correcting vector $m$ reveals the distance between $x$ and $y$ as the number of errors is equal to the distance.
%     \item The identification of erroneous bit locations relies on the value of $m$, wherein a value of $1$ for the $i$-th bit in $m$ signifies an error in the $i$-th coordinate.
%     \item Moreover, knowledge of the tested vector $y$ allows for the discovery of the enrolled vector.
% \end{itemize}
% Furthermore, even if we consider that $m$ is not computed, the values of erroneous bits are exposed through tests of divisibility of $E$ by $p_i$ or $p_i^{-1}$ modulo $q$, enabling accumulation attacks.

% }
\subsection{Notations and Attacker Models}
\label{Notation}
In the following, we consider the metric space $\Zq^n$ (the set of vectors of size $n$ with value in $\llbracket 0, q-1 \rrbracket$) equipped with the distance $d$. For this paper, the distance considered is the Hamming distance defined by
$$d(x, y) = \left|\lbrace i\in\lbrace 1,\dots n,\rbrace | x_i \not = y_i\rbrace\right|$$
for two vectors $x=(x_1,\dots,x_n)$ and $y=(y_1,\dots,y_n)$.
The role of $\Xi.\texttt{Match}$ is modeled by an oracle $\sigma_{x,\varepsilon}$, which the attacker has access to.
For the sake of simplicity, the threshold $\varepsilon$ and the hidden input $x$ are omitted when the context is explicit.
In order to infer the hidden input, the attacker performs queries to the oracle $\sigma_{x,\varepsilon}$. %as well as the function $\Xi.\texttt{Hide}$.
A matching scheme $\Xi$, as defined in Section~\ref{Bg}, can leak some information, and we consider that $\Xi.\texttt{Match}$ leaks extra information beyond its binary output ('yes' or 'no'). 


\subsection{Typology of Information Leakage}
\label{Leak_type}
\noindent
In the context of a biometric system, a critical vulnerability arises when information is intercepted between the matcher and the decision module, as illustrated in Figure~\ref{fig:notratha} (point $8$). This figure, based on Ratha~\textit{et al.}'s~\cite{Rathasheme} research, introduces both the decision module and two additional threat points. Except for the accumulation attack, the attacker exploits points $4$ and $8$ in all discussed scenarios. Point $4$ allows the submission of a chosen template, while point $8$ grants access to additional information beyond the binary output yes/no. The accumulation attack only necessitates control over the point $8$. For detailed insights into the remaining threat points, readers are referred to Ratha~\textit{et al.}'s work~\cite{Rathasheme}.%}
There are three main categories of information leakage: 
\begin{itemize}
    \item Below the threshold. 
    \item Above the threshold. 
    \item Both below and above the threshold. 
\end{itemize}
In each of these categories, several sub-settings can be identified.
The first one corresponds to the absence of any leakage, resulting in $\Xi.\texttt{Match}$ yielding only the binary output. 
Then, the following information leakages are examined: 
\begin{itemize}
    \item Leakage 1: the distance $d$. 
    \item Leakage 2: the positions of the errors only.
    \item Leakage 3: the error positions and values.
    \item Leakage 4: both the distance $d$ and the positions of the errors.
    \item Leakage 5: both the distance and the positions and their corresponding erroneous values.
\end{itemize} 
The focus is on leakage below the threshold, as well as instances both below and above the threshold. Since the Hamming distance measures the number of differing coordinates between two inputs, knowledge of the erroneous coordinates implies knowledge of the distance itself.
As a result, Leakage $4$ and Leakage $5$ are respectively identical to Leakage $2$ and Leakage $3$.


% Figure environment removed

\section{Exploiting the Leakage}
\label{attacks}

\subsection{Leakage Exploit Attacks} 
Several attacks are related to the different types of aforementioned leakage scenarios. 
The first attack is the exhaustive search, which tests all possible vectors until the right one is found.

\begin{definition}[Exhaustive or Brute-Force Search]
    \label{ExaustiveSearch}
    This attack is a very general problem-solving technique that consists of testing all possibilities until the problem statement is verified. The complexity of this attack is $O(q^n)$ queries to~$\sigma$.
\end{definition}

Then, by considering some extra information, it is possible to perform a hill-climbing attack~\cite{lasry2018methodology}, whose aim is to find the solution by iteratively improving a potential solution. 

\begin{definition}[Hill-climbing attack]
    \label{HillClimAtt}
    The hill-climbing attack is based on a mathematical optimization technique. It begins with an arbitrary solution and then attempts to improve the solution by applying some slight variations. If the updated solution improves the score obtained with the target function, the previous process is repeated with this new solution until the attack succeeds. The complexity of this attack is $O(nq)$.
\end{definition}

By employing the oracle $\sigma$, the attacker gets full knowledge of $x$ by accumulating some knowledge about it at each query. 
In other words, the accumulation attack allows the attacker to recover the secret vector when a genuine authentication leaks bits of information.
This is the case when the positions and values of the errors are leaked, as with a secure sketch. Additional information is provided in Section~\ref{AccuAtt:section}.
% and throughout the paper.
\begin{definition}[Accumulation Attack]
    \label{AccuAtt}
    The accumulation attack is a passive attack where the attacker recovers a certain amount of information at each interaction.
    By accumulating information, the entropy of the target decreases until its entropy goes to zero.
    In the end, the attacker has a complete knowledge of the target.
\end{definition}


In~\cite{pagnin2014leakage}, the authors show that from any closed vector $y$ of $x$, \textit{i.e.}, $d(x,y)\leq \varepsilon$, it is possible to retrieve the center $x$ of the ball using~$\sigma$. 
\begin{definition}[Center Search Attack~\cite{pagnin2014leakage,Simoens2012AFF}]
    \label{CentSearAtt}
    This attack aims at finding $x$, the center of the acceptance ball $B_\varepsilon(x)$. The starting point of the attack is to find a point $b'$ on the edge of the ball, and then converge to its center. The complexity of this attack is $O(nm)$ where $m=\mathrm{min}(\lfloor 2\varepsilon \rfloor,2\ln q)$.
\end{definition}
We refer the reader to the work of Pagnin~\textit{et al.}~\cite{pagnin2014leakage} for more details.


\subsection{Accumulation Attack}
\label{AccuAtt:section}

%In this attack scenario, each time a genuine client authenticates to a server, the attacker obtains information on the errors the client makes. 
In this attack scenario, upon each authentication of a genuine client to the server, the attacker gains insights into the errors made by the client.
More specifically, the server leaks the position and the error made by the client, but the attacker does not make any queries. The information gathered at a successfull authentication attempt is called an observation.
The error locations are assumed to be uniformly distributed and the objective of the attacker is to recover all bits of information regarding the hidden input~$x$. This attack is thus related to the Coupon Collector's problem. This problem involves determining the expected number of rounds needed to collect a complete set of distinct coupons, with one coupon obtained at each round, and each coupon acquired with equal probability.
%Flajolet~\textit{et al.}~\cite{flajolet1992birthday} have shown 
Using the asymptotic behavior of the harmonic series, the expected number of rounds required to complete the collection is approximately $n\log{n}+\gamma n+ 1/2 + O(1/n)$, where $\gamma\approx0.577$ is the Euler–Mascheroni constant. 
%Note that this result is used under the assumption that the client makes at least one error at each authentication and that the errors are uniformly distributed. 
However, while in the original problem one coupon is obtained at each round, the number of errors made by a client during an authentication session is variable, \textit{i.e.},  between $0$ and~$\varepsilon$. 
%Hence, the result on the coupon collector problem gives us an upper bound. 
Without loss of generality, this asymptotic result holds even for a variable number of errors, and even if the errors are not uniformly distributed, yet each possible error must have a non-zero probability to occur.

\begin{theorem}\label{th-acc}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors and their values below the threshold, an attacker can retrieve $x$ in $O\left(n\log{n} +\gamma n\right)$ observations with $\gamma$ the Euler-Mascheroni constant.
\end{theorem}


To clarify the proof of Theorem~\ref{th-acc}, the following example serves as an illustration of an accumulation attack.

\begin{ex}
    \label{ExampleAccuAtt}
    Suppose a setting with a metric space $\mathbb{Z}_2^n$ equipped with the Hamming distance. A client seeks to authenticate to an \textit{honest-but-curious} server that uses a scheme leaking $d(x,y)$ and the corresponding errors if $d(x,y) \leq \varepsilon$.
    As the client is legitimate, \textit{i.e.}, $d(x,y) \leq \varepsilon$ with a high probability, the server recovers the values of at most $\varepsilon$ erroneous bits. The server needs to collect all the bits of the client, turning this problem into a Coupon Collector problem.
    For example, let assume $x = (0,0,1,1,0,1,0)$, $\varepsilon = 3$. The server sets $z = (?,?,?,?,?,?,?)$. Session~1: The client authenticates with $y = (1,1,0,1,0,1,0)$. In this case, $d(x,y) = 3 \leq \varepsilon$. The server obtains the values of the erroneous bits of the client and updates $z = (0,0,1,?,?,?,?)$. Session~2: the client authenticates with $y = (0,0,0,0,1,1,0)$. In this case, $d(x,y) = 3 \leq \varepsilon$, and the server obtains the value of the erroneous bits of the client and updates $z = (0,0,1,1,0,?,?)$. 
    At this point, the vector lies inside the acceptance ball. 
    Hence, the attacker is able to perform an impersonation attack. 
    She can perform the Center Search Attack~\ref{CentSearAtt}. Some extra steps, give the very last bits.
\end{ex}

\begin{proof}
%{\color{red}Using the same argument as in the introduction of the section}, 
According to the Coupon Collector's problem, the vector $x$ is recovered in $O\left(n\log{n}+\gamma n\right)$ observations of a genuine client.\\
$\blacksquare$
\end{proof}

A lower bound is computed by considering the work of Ferrante~\textit{et al.}~\cite{CoupnCollector}. Their study explores a variant of the problem where $\varepsilon$ coupons are drawn in each round, as opposed to a single coupon. They show that the expected number of observations is
\begin{align*}
        \sum\limits_{j=1}^n (-1)^{j-1} \binom{n}{j}\left(1-\frac{\binom{n-j}{\varepsilon}}{\binom{n}{\varepsilon}}\right)^{-1} & \leq N.
\end{align*}
It is important to note that in this scenario, the attacker does not control the error. If the attacker controls the error locations, then it is possible to obtain $x$ in $\lceil n/\varepsilon \rceil$ queries. This scenario can happen during a fault attack, akin to side-channel attacks.


\subsection{Attack Complexities for Leakage Below the Threshold}
\label{below}
Leakage below the threshold is considered in this section. 
Given the hidden target input $x$, querying $y$ such that $d(x,y)\leq\varepsilon$ to the oracle $\sigma_{x,\varepsilon}$ provides information beyond the binary output.
Concerning fuzzy matchers that employ secure sketches or error-correcting code mechanisms, information leakage deliberately occurs below the threshold for error correction purposes. 
In many instances, information related to the distance, error locations, and errors themselves are either explicitly calculated or can be inferred.


\paragraph{The distance is leaked}

The first case occurs when the distance is given to the attacker as extra information. 
\begin{theorem}\label{th-below-leak-dist}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q\varepsilon)$ queries to $\sigma_{x,\varepsilon}$.       
\end{theorem}

\begin{proof}
The first step is to obtain a vector below the threshold, by performing an exhaustive search attack.
The matcher, using the Hamming distance, requires a minimum of $n-\varepsilon$ accurate coordinates to classify an input as below the threshold and consequently output 'yes'.
Since the attacker specifically targets $n-\varepsilon$ bits, an exhaustive search attack is performed in at most $q^{n-\varepsilon}$ steps to retrieve them.
Then, a hill-climbing attack runs on the remaining $\varepsilon$ bits to minimize the distance at each step. Coordinate by coordinate, the attacker obtains the right value if the distance decreases. Since there are $q$ different values to test on $\varepsilon$ coordinates, determining the correct ones requires a maximum of $q\varepsilon$ steps. Then, the overall complexity is $O(q^{n-\varepsilon}+q\varepsilon)$.\\
$\blacksquare$
\end{proof}

\paragraph{The positions are leaked}
The positions of the errors are the extra information given to the attacker, while their values remain secret. 
\begin{theorem}\label{th-below-leak-pos}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+q)$ queries to~$\sigma_{x,\varepsilon}$.       
\end{theorem}

\begin{proof}
As the leakage occurs solely below the threshold, 
the first step is to find a vector $y\in\mathbb{Z}_q^n$ such that $d(x,y)\leq \varepsilon$.
To identify such a vector, the attacker conducts an exhaustive search attack in $q^{n-\varepsilon}$ steps, as previously shown. 
This is followed by an exhaustive search on the erroneous coordinates, requiring $q^\varepsilon$ steps.
Since $\varepsilon$ coordinates remain unknown, and each coordinate ranges from 0 to $q-1$, every possibility must be examined. By testing all possibilities simultaneously -- for instance, testing all coordinates at 0, then all coordinates at 1, and so forth up to $q-2$, while retaining the correct values -- the original vector can be identified in no more than $q-1$ queries (refer to the example illustrated in Figure~\ref{fig:reverse_master_mind}). Therefore, the complexity of the attack for recovering $x$ is $O(q^{n-\varepsilon}+q)$.
\\ $\blacksquare$
\end{proof}


\begin{table*}[]
\resizebox{\textwidth}{!}{%
\centering
\begin{tabular}{ccccc}
\toprule
\multicolumn{1}{l}{Distance-to-Threshold Comparison}   & Leakage                      & Complexity type & Worst case complexity in Big-$O$ & Average complexity in Big-$O$              \\
\midrule
\multirow{4}{*}{Below} & Distance                     & Exp.       & $q^{n-\varepsilon}+q\varepsilon$   &          $-$ \\
                               & Positions                    & Exp.       & $q^{n-\varepsilon}+q$ & $-$ \\
                               & Positions and values & Exp.       & $q^{n-\varepsilon}$      &  $-$         \\
                               & Positions and values (accumulation) & Linearithmic & $\infty$  &  $n\log{n}+\gamma n$\\
                               \midrule
\multirow{4}{*}{Both} & Minimal                      & Exp.       & $q^{n-\varepsilon}+nm$  & $-$\\

                               & Distance                     & Lin.       & $nq$     &   $-$                        \\
                               & Positions                     & Const.       &  $q$  &   $-$                \\
                               & Positions and values & Const.    & $1$         &     $-$                   \\

                               \bottomrule
\end{tabular}
}
\caption{Summary of all leakage exploits and their complexities for the average case, where $m=\mathrm{min}(\lfloor 2\varepsilon \rfloor,2\ln q)$ and $\gamma\approx0.577$ (the Euler–Mascheroni constant). The dash in the second column means that the worst-case complexity prevails. %The average complexity of the accumulation attack assumes uniformly distributed errors across each authentication session.
The average complexity of the accumulation attack assumes that for each component of the template vector, an error has a non-zero probability to occur.
}
\label{Leak_table}
\end{table*}

\paragraph{The positions and the values are leaked}
In this case, when a vector below the threshold is given to $\sigma_{x,\varepsilon}$ the oracle, the attacker gets information about both error positions and their values. This is similar to an error-correction mechanism designed to correct errors below a given threshold.
\begin{theorem}\label{th-below-leak-value-and-pos}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions and the values of the errors below the threshold, an attacker can retrieve $x$ in $O(q^{n-\varepsilon})$ queries to $\sigma_{x,\varepsilon}$.       
\end{theorem}

\begin{proof}
First, an exhaustive search is performed to find a vector $y$ for which the distance is below the threshold, for a cost of $O(q^{n-\varepsilon})$. Then, given the error positions and the corresponding error values, $y$ yields immediately the recovery of $x$. 
In the end, the complexity of the attack is $O(q^{n-\varepsilon})$.
$\blacksquare$
\end{proof}




\subsection{Leakage Below and Above the Threshold}
\label{both}
The last scenario is considered, which involves a leakage independent of the threshold. In other words, when a hidden vector $x$ is targeted, the queried vector $y$ to  the oracle $\sigma_{x,\varepsilon}$ results in the leak of additional information.

\paragraph{Minimal Leakage (single bit of information leakage)}
The basic usage of a fuzzy matcher is characterized by the minimal leakage scenario, where the binary yes/no response itself is considered a necessary leakage. This minimal leakage is indispensable for the system's work and is consistent across all three possible scenarios (above, below, and both) as the matcher always responds. Remark that if the server does not answer above the threshold, the non-answer gives the attacker the wanted information.
\begin{theorem}\label{th-both-minimal}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher, an attacker can retrieve $x$ in $O(q^{n-\varepsilon}+nm)$ queries to $\sigma_{x,\varepsilon}$, with $m=\mathrm{min}(\lfloor 2\varepsilon \rfloor,2\ln q)$.
\end{theorem}

\begin{proof}
As in the previous cases, the attacker seeks a vector $y$ below the threshold. Such a vector is found by exhaustive search in $q^{n-\varepsilon}$ steps. Then, the attacker performs the center search attack~\cite{pagnin2014leakage} to retrieve the original data. Hence, the complexity of the attack for recovering $x$ in this case is $O(q^{n-\varepsilon}+nm)$ with $m=\mathrm{min}(\lfloor 2\varepsilon \rfloor,2\ln q)$.
\\
$\blacksquare$
\end{proof}


\paragraph{Leakage of Distance}
In this case, $d(x,y)$ the distance between $y\in\mathbb{Z}_q^n$ the fresh input and $x\in\mathbb{Z}_q^n$ the old input is leaked to the attacker regardless of the threshold.
\begin{theorem}\label{th-both-dist-leak}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the distance, an attacker can retrieve $x$ in $O(nq)$ queries to $\sigma_{x,\varepsilon}$.       
\end{theorem}

\begin{proof}
    As the attacker has always access to the distance, it is possible to perform a hill-climbing attack, trying to minimize the distance at each step. The strategy is to find the vector, coordinate by coordinate. As each coordinate has $q$ possible values and there are $n$ coordinates, this is done in $O(nq)$ steps. 
$\blacksquare$
\end{proof}


\paragraph{Leakage of the Positions}
In this case, the extra information given to the attacker is the positions of the errors, but the corresponding values remain secret.
\begin{theorem}\label{th-both-pos-leak}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors, an attacker can retrieve $x$ in $O(q)$ queries to $\sigma_{x,\varepsilon}$.       
\end{theorem}

\begin{proof}
She tries the vector $(0,\ldots,0)$, $(1,\ldots,1)$ up to, $(q-1,\ldots,q-1)$ and keep for each coordinate the right value (see Figure~\ref{fig:reverse_master_mind}). Hence, the complexity of the attack to recover $x$ is $O(q)$.
\\
$\blacksquare$
\end{proof}

Figure~\ref{fig:reverse_master_mind} gives a representation of the attack described above in the case $\mathbb{Z}_4^5$ with a threshold $2$ and the hidden vector $(0,1,3,2,2)$. Note that the actual complexity is $q-1$ since the final exchange is unnecessary, as the coordinates at $q-1$ become known after $q-1$ queries by inference.

% Figure environment removed
\addtolength{\tabcolsep}{0cm}

\paragraph{Leakage of the Positions and the Values}
% In this last case, the positions of the errors and corresponding values are leaked. Unlike the scenario of leakage below the threshold, this is similar to an error-correcting code mechanism without any threshold. This means that any data is corrected without considering the distance between the queried data and the hidden data.
In this last case, the positions of the errors and corresponding values are leaked. Unlike the scenario of leakage below the threshold, such a leak provides an error-correcting code mechanism that operates irrespective of any distance and threshold. %This means that any data is corrected without considering the distance between the queried data and the hidden data.
\begin{theorem}\label{th-both-pos-and-val-leak}
    Given $\varepsilon$ a threshold, $x\in\mathbb{Z}_q^n$ a vector and $\Xi$ a fuzzy matcher such that $\Xi.\texttt{Match}$ leaks the positions of the errors and their values, an attacker can retrieve $x$ in $O(1)$ queries to $\sigma_{x,\varepsilon}$.
\end{theorem}

\begin{proof}
In this case, the submission of any vector gives the position of each error, and how to correct them, yielding a complexity in $O(1)$
\\
$\blacksquare$
\end{proof}
% Attacks for each leakage are summarized in Table~\ref{Leak_table}.
Attacks for each type of leakage along with their complexities are summarized in Table~\ref{Leak_table}. 


\section{Concluding Remarks}
\label{Conclu}
Our investigation into the information leakage of a fuzzy matcher has shed light on critical security vulnerabilities that arise under various scenarios. By evaluating the impact of different types of leakage, including distance, error position, and error value, we have examined into the potential risks posed to data privacy and security in practical applications. 

Our analysis encompasses both below the threshold and both above and below the threshold setups, allowing us to identify specific conditions under which information leakage can have a substantial effect on the overall security of the system. 

Furthermore, the attacks presented in this study, relying on exhaustive search, have the potential for theoretical improvement by using techniques such as \textit{set-covering} and \textit{sampling without replacement}, as shown by Pagnin~\textit{et al.}~\cite{pagnin2014leakage}. 

However, the feasibility of the aforementioned approach is hindered by the NP-hardness of the \textit{set-covering} problem, which makes the attack impractical.
It is important to highlight that the leakage below the threshold does not significantly hurt the security of the fuzzy matcher, while the leakage of both below and above significantly decreases the security. Indeed, the attacks exploiting the leakage below the threshold are primarily exponential, while those exploiting information both below and above the threshold are mainly constant.

% In the end, our research emphasizes the critical importance of exploring information leakage in cryptographic systems, highlighting the ongoing necessity for the development of robust cryptographic primitives capable of withstanding side-channel attacks and effectively mitigating potential information leaks.

The accumulation attack we investigated is based on the assumption of errors uniformly distributed throughout each authentication session. 
The result of the accumulation attack could be further refined by considering a variable number of coupons, randomly drawn between $0$ and $\varepsilon$ in each round, while acknowledging the actual distribution of the errors. As far as we are aware, no previous studies provide an analysis 
of the distribution of the errors.
% of how these errors are distributed. 
In practical scenarios, some errors manifest more frequently. A skewed distribution of errors substantially increases the expected number of authentications required from the legitimate user so that the server recovers the hidden input. 
Further research involves refining the accumulation attack as suggested above and exploring other distance metrics, such as $L_1$ (Manhattan) and $L_2$.

% Another possibility involves investigating other distances, such as $L_1$ (\textit{i.e.}, Manhattan) and $L_2$.

% improving the presented attacks.%, applying those attacks on existing systems, and conducting an in-depth analysis of the identification scenario.
% through the establishment of attack bounds on identity usurpation in the information leakage framework.

\section{Acknowledgement}
\noindent
The authors acknowledge the support of the French Agence Nationale de la Recherche (ANR), under grant ANR-20-CE39-0005 (project PRIVABIO).

\bibliographystyle{unsrt}
\bibliography{biblio}


\end{document}
