\paragraph{Notation.} 
Throughout this paper, we denote the number of nodes in a graph by $n$, the number of edges by $m$, and the number of $\ell$-cliques by $\Delta_\ell$. For an $\ell'$-clique $K$ for some $1 \le \ell' \le \ell$, we use $\Delta_\ell(K)$ to denote the number of $\ell$-cliques containing $K$. For the special case of $\ell = 2$, we use $\deg(v) := \Delta_2(v)$. For integer $k$, we use $K_k$ to denote a $k$-clique. 

For a nonnegative integer $n$, we use $[n]$ to denote $\{1, 2, \ldots, n\}$. 

\paragraph{Matrix multiplication.} We use $\omega < 2.37286$ to denote the matrix multiplication exponent~\cite{alman2021refined}. For any constants $a, b, c \ge 0$, we use $\omega(a, b, c)$ to denote the exponent of multiplying an $n^a \times n^b$ matrix by an $n^b \times n^c$ matrix. The current best bounds for rectangular matrix multiplication are given by \cite{LU18}. 

We denote by $\MM(A, B, C)$ the runtime of multiplying an $A \times B$ by a $B \times C$ matrix. If $A \leq B \leq C$, we can loosely bound $\MM(A, B, C)$ in terms of $\omega$ as follows:
$$\MM(A, B, C) \leq O\left(A^\omega \cdot \frac{BC}{A^2}\right) = O(A^{\omega - 2}BC).$$
This bound is obtained by splitting the matrix multiplication into $\frac{B}{A} \cdot \frac{C}{A}$ instances of square matrix multiplication of size $A$, and it is in general weaker than the bound in \cite{LU18}. 

\paragraph{H\"{o}lder's Inequality.} To analyze the runtime of our algorithms, we often utilize a reformulation of H\"{o}lder's inequality.

\begin{lemma}[H\"{o}lder's Inequality]
    Given $p, q \in (1, \infty)$ such that $1/p + 1/q = 1$, the following inequality holds for any $x_1, \ldots, x_k, y_1, \ldots, y_k \geq 0$:
$$\sum_{k=1}^n x_ky_k \leq \left( \sum_{k=1}^n x_k^p\right)^{1/p} \left(\sum_{k=1}^n y_k^q\right)^{1/q}.$$
\end{lemma}
We restate H\"{o}lder's Inequality as follows. This is the version that we use in our runtime analyses. 
\begin{corollary}\label{cor:holders_useful}
    Given $\alpha, \beta \in (0, 1)$ such that $\alpha + \beta = 1$, the following inequality holds for any $x_1, \ldots, x_k, y_1, \ldots, y_k \geq 0$:
    $$\sum_{k=1}^n x_k^\alpha y_k^\beta \leq \left( \sum_{k=1}^n x_k\right)^{\alpha} \left(\sum_{k=1}^n y_k\right)^{\beta}$$
\end{corollary}


\subsection{Problem Definitions} 
Now, we define the main clique problems that we consider in this paper. 

\begin{definition}[$\cliquedet{k, \ell}$]
Given a graph $G=(V, E)$ and  the list $L$ of all $\ell$-cliques in $G$, decide whether $G$ contains a $k$-clique. 
\end{definition}

\begin{definition}[$\cliquelist{k, \ell}$]
Given a graph $G=(V, E)$ and  the list $L$ of all $\ell$-cliques in $G$, list all $k$-cliques in $G$. 
\end{definition}

In $\cliquelist{k, \ell}$, we use $t$ to denote the total number of $k$-cliques in the graph. However, as we will show in Section~\ref{sec:prelim:basic}, we can equivalently (up to $\tO(1)$ factor) use $t$ to denote the number of $k$-cliques we wish to list. 

\subsection{Basic Clique Listing Algorithms}
\label{sec:prelim:basic}
Next, we give some standard algorithms and reductions. 

\begin{lemma}
    Suppose $\cliquedet{k, \ell}$ can be solved in time $D(\Delta_\ell)$. Then, given the list of all $\ell$-cliques in a graph, one can find a $k$-clique in $\tilde{O}(D(\Delta_\ell))$ time.
\end{lemma}
\begin{proof}
    Let the input graph be $G = (V, E)$, with list $L$ of all $\ell$-cliques. Without loss of generality, we may assume that $|V| \leq O(\Delta_\ell)$ by deleting all nodes that are not in any $\ell$-clique (since such a node cannot be in a $k$-clique).
    
    If $|V| \leq k$, brute force and check if the graph has a $k$-clique. Otherwise, run $\cliquedet{k, \ell}$ on the graph. If it has a $k$-clique, arbitrarily partition $V$ into $k+1$ sets, $V_1, \dots, V_{k+1}$. Now, for each $i \in [k+1],$ consider the subgraph on node set $V_{-i}=\cup_{j\in[k+1]\setminus\{i\}} V_j$, and run $\cliquedet{k, \ell}$. Note that each such subgraph contains at most $\Delta_\ell$ $\ell$-cliques. 
    For some $i$, it must be the case that the graph on $V_{-i}$ contains a $k$-clique as we partitioned into $k+1$ parts and a $k$-clique has only $k$ nodes. Recurse on exactly one such subgraph $V_{-i}$ on which the detection algorithm returned ``YES''.
    
    Since the depth of this recursion is $O(\log_{\frac{k+1}{k}} |V|) = O(\log \Delta_\ell)$, and we call $\cliquedet{k, \ell}$ on $O(1)$ instances at each step, we have a runtime of $\tilde{O}(D(\Delta_\ell))$ as desired.
\end{proof}

\begin{lemma}
\label{lem:simple_list_ub}
$\cliquelist{k, \ell}$ can be solved in time $\tO(\Delta_\ell^{k/\ell})$.
\end{lemma}

\begin{proof}

We will prove by induction on the following stronger statement: 
given a list $L$ of $\ell$-cliques in a graph (not necessarily all $\ell$-cliques), one can list all $k$-cliques covered by these $\ell$-cliques in the graph in  time  $\tilde{O}\left(|L|^{k/\ell}\right)$, where a $k$-clique $K$ is covered by a list $L$ of $\ell$-cliques if every $\ell$-clique subgraph of $K$ lies in $L$.

When $\ell = 1$, it suffices to use brute-force to list all $k$-cliques. Now suppose $\ell > 1$. 

First, we find  all $(\ell-1)$-cliques that are contained in at most $x$ (and at least $1$) $\ell$-cliques in the list in $O(|L|)$ time. If an $(\ell-1)$-clique $K$ is contained in $y \leq x$ $\ell$-cliques in the list, then we  can list all $k$-cliques containing $K$ in $\tilde{O}(y^{k-\ell+1}) \le \tilde{O}(y \cdot x^{k-\ell})$ time by brute-force. Over all such $(\ell-1)$-cliques, the total running time is thus $\tilde{O}(|L| x^{k-\ell})$. 


The number of $(\ell-1)$-cliques that are contained in at least one of the $\ell$-cliques in $L$ and  are not considered above is $O(|L| / x)$. Let $L'$ be the list of these $O(|L|/x)$ $(\ell-1)$-cliques. 
If a $k$-clique $K$ is not found above, then all of its $(\ell-1)$-clique subgraphs are in the list $L'$, i.e., $K$ is covered by $L'$. 
By induction, we can find the list of all $k$-cliques that are covered by $(\ell-1)$-cliques in $L'$ in $\tilde{O}((|L| / x)^{k/(\ell-1)})$ time. This combined with the $k$-cliques listed in the previous case gives all the $k$-cliques covered by $L$. 

Setting $x = |L|^{1/\ell}$ gives the desired $\tilde{O}(|L|^{k/\ell})$ time, and thus completes the induction. 
\end{proof}

The proof of Lemma~\ref{lem:simple_list_ub} also implies that the number of $k$-cliques in a graph with $\Delta_\ell$ $\ell$-cliques is $O(\Delta_\ell^{k/\ell})$.

\begin{lemma}
\label{lem:list_exponent_monotone}
Fix $1 \le \ell < k$. Suppose there is a $T(\Delta_\ell, x)$ time algorithm for $\cliquelist{k, \ell}$ where the total number of $k$-cliques is $\Theta(\Delta_\ell^x)$. Then for any $x' < x$, $\cliquelist{k, \ell}$ on graphs where the total number of $k$-cliques is $\Theta(\Delta_\ell^{x'})$ can be solved in $O(T(\Delta_\ell, x))$ time. 
\end{lemma}
\begin{proof}
First of all, by Lemma~\ref{lem:simple_list_ub}, $x \le \frac{k}{\ell}$. 
We then add a complete $k$-partite graph to the graph where the number of nodes in each part is $\Delta_\ell^{x/k}$. This way, the number of $k$-cliques in the graph is increased by $\Delta_\ell^{x}$, and the number of $\ell$-cliques is increased by $\Delta_\ell^{\ell x / k} \le \Delta_\ell$. Thus, the number of $k$-cliques in the graph is $(\Delta'_\ell)^x$, where $\Delta'_\ell = \Theta(\Delta_\ell)$ is the new number of $\ell$-cliques in the graph. Therefore, we can run the $T(\Delta_\ell, x)$ time algorithm on the new graph in $\Theta(T(\Delta_\ell, x))$ time. Once we list all the $k$-cliques in the new graph, we can return those that belong to the original graph. 
\end{proof}

Let $f(\Delta_\ell, t)$ be the runtime of $\cliquelist{k, \ell}$ when the graph has (an unknown number of) $t$ cliques in total, and let $g(\Delta_\ell, t)$ be the runtime of listing $\min\{\Delta_k, t\}$ distinct $k$-cliques, given the list of all $\ell$-cliques in the graph and a specified $t$ as input. We assume $f(\tO(\Delta_\ell), \tO(t)) = \tO(f(\Delta_\ell, t))$ and $g(\tO(\Delta_\ell), \tO(t)) = \tO(g(\Delta_\ell, t))$. This is true for all of our algorithms as well as any algorithm that has at most a polynomial dependence on $\Delta_\ell$ and $t$. 

The following lemma shows that $f(\Delta_\ell, t) =  \tilde{\Theta}(g(\Delta_\ell, t))$. Therefore, we use both of these two notions interchangeably for the definition of $\cliquelist{k,\ell}$. In particular, given an instance of $\cliquelist{k, \ell}$ with an unknown number of $k$-cliques, the proof of Lemma~\ref{lem:equivalence_specify} allows us to assume that we know an $2$-approximation of $\Delta_k$, with only $\tO(1)$ loss in the running time. 


\begin{lemma}
\label{lem:equivalence_specify}
    $f(\Delta_\ell, t) =  \tilde{\Theta}(g(\Delta_\ell, t))$.
\end{lemma}
\begin{proof}
    We first show $f(\Delta_\ell, t) =  \tO(g(\Delta_\ell, t))$. Let $\mathcal{A}$ be an algorithm for listing a specified number of $k$-cliques. 
    Given an $n$-node graph $G$ and the list of $\Delta_\ell$ cliques, we run $O(\log n)$ instances of $\mathcal{A}$ in parallel. More specifically, we specify these instances to list $2^0, 2^1, \ldots, 2^{\lceil \log(n^k+1)\rceil}$ $k$-cliques respectively. We wait until one of the instances finishes listing all $k$-cliques in the graph. Suppose $t$ is the actual number of $k$-cliques in the graph, and we specify $\mathcal{A}$ to list $2^{\lceil \log t\rceil}$  $k$-cliques, then it will finish within $g(\Delta_\ell, O(t))=\tO(g(\Delta_\ell, t))$ time. 
    Since we run $O(\log n)$ instances in parallel, the overall running time is $\tO(g(\Delta_\ell, t))$. 

    Next, we show $g(\Delta_\ell, t) =  \tO(f(\Delta_\ell, t))$. Let $\mathcal{B}$ be an algorithm for $\cliquelist{k, \ell}$. Given a graph $G = (V, E)$, a list of all $\ell$-cliques and a parameter $t$, we need to list $\min\{t, \Delta_k\}$ $k$-cliques in $\tO(f(\Delta_\ell, t))$ time. First, we run $\mathcal{B}$ for $\tO(f(\Delta_\ell, 2^k t))=\tO(f(\Delta_\ell, t))$ time. By Lemma~\ref{lem:list_exponent_monotone}, if $\Delta_k \le 2^k t$, $\mathcal{B}$ will finish in $\tO(f(\Delta_\ell, 2^k t)$) time, and we are done. Now, we assume the number of $k$-cliques in $G$ is at least $2^k t$.
    
    We create a $k$-partite graph $G'=(V',E')$ as follows. Let $V' = V_1 \sqcup \dots \sqcup V_k$ where each $V_i$ is a copy of $V$. Let $v_i$ be the copy of node $v \in V$ in $V_i$. Add edges $(u_i, v_j)$ between nodes $u_i \in V_i$ and $v_j \in V_j$ if and only if $i\neq j$ and $(u, v) \in E$. Clearly, the number of $k$-cliques in $G'$ is at least $2^k (k!) t$, and we need to list $(k!) t$ distinct $k$-cliques in $G'$ in order to produce $t$ distinct $k$-cliques in $G$. Also, the number of $\ell$-cliques in $G'$ is $O(\Delta_\ell)$. Then we partition each $V_i$ arbitrarily into two sets $V_{i, 0}$ and $V_{i,1}$ of size $n/2$. We run $\mathcal{B}$ on each of the $2^k$ induced subgraphs on the sets $V_{1,b_1}, V_{2, b_2}, \dots, V_{k, b_k}$, where $b_i \in \{0, 1\}$ for $\tO(f(O(\Delta_\ell), 2^k (k!) t)) = \tO(f(\Delta_\ell, t))$ time. By the pigenhole principle, one of the subgraphs contain at least $(k!) t$ $k$-cliques. If $\mathcal{B}$ finishes on that subgraph, we are done. Otherwise, $\mathcal{B}$ does not finish on that subgraph, and by Lemma~\ref{lem:list_exponent_monotone}, that subgraph must have more than $2^k (k!) t$ distinct $k$-cliques, so we can recurse on that induced subgraph. Overall, the running time is $\tO(f(\Delta_\ell, t))$ because the recursion depth is $O(\log n)$.
\end{proof}

\cite{bjorklund2014listing} gave similar reductions from listing a specified number of  $t$ triangles to listing all $\Delta_3$ triangles in $n$-node or $m$-edge graphs. Their reduction is more efficient than ours when $t$ is much smaller than $\Delta_3$. However, their reduction requires an algorithm for {\em counting} the number of triangles. We instead provide a black box reduction that does not rely on counting, that works for arbitrary $k,\ell$, and is
 more self-contained and efficient enough for our purpose. 