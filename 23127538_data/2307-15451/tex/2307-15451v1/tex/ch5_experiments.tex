\section{Experimental Evaluation}\label{sec:eval}
    In this section, we describe our experimental evaluation of the Answer Set Programming (ASP) encodings of \textsc{delphic} and of the traditional Kripke semantics for DEL. Due to space constraints, we provide a brief overview of the encodings\footnote{The full code and documentation of the ASP encodings are available at \url{github.com/a-burigana/delphic\_asp}.} (the full presentation can be found in the arXiv Appendix).

    The aim of the evaluation is to compare the semantics of \textsc{delphic} and the traditional Kripke-based one in terms of both time and space. We do so by testing the encodings on epistemic planning benchmarks collected from the literature\footnote{Due to space limits, the description of the benchmarks is delegated to the arXiv Appendix. All benchmarks are available at \url{github.com/a-burigana/delphic\_asp}.} (\eg \emph{Collaboration and Communication}, \emph{Grapevine} and \emph{Selective Communication}). Time and space performances are respectively evaluated on the total solving time (given in seconds) and the grounding size (\ie the number of ground ASP atoms) provided by the ASP-solver \emph{clingo} output statistics. We now describe the encodings (Section \ref{sec:encodings}) and discuss the obtained results (Section \ref{sec:results}).

    \subsection{ASP Encodings}\label{sec:encodings}
        Since our goal is to achieve a fair comparison the two semantics, we implemented a baseline ASP encoding for both of them. Although optimizations for both encoding are possible, the baseline implementations are sufficient to show our claim. Towards the goal of a fair and transparent comparison, we opted for a declarative language such as ASP (notice that, as our goal is simply to compare the two baselines, the choice of an alternative declarative language would make little difference). In fact, while imperative approaches would render the comparison less clear, as one would need to delve into opaque implementation details, ASP allows to write the code that is transparent and easy to analyze. In fact, the two ASP encodings are very similar, since the representation of \textsc{delphic} objects (possibility/eventuality spectrums) and DEL objects (MPKMs/MPEMs) closely mirror each other. The only difference is in the two update operators (\ie union update and product update). This homogeneity is instrumental to obtain a fair experimental comparison of the two encodings.
        
        We now briefly describe our encodings, assuming that the reader is familiar with the basics concepts of ASP. The two encodings were developed by following the formal definitions of \textsc{delphic} and DEL objects (possibility/eventuality spectrums and MPKMs/MPEMs) and update operators (union and product update) introduced in the previous sections. To increase the efficiency of the solving and grounding phases, the two encodings make use of the \emph{multi-shot} solving approach provided by the ASP-solver \emph{clingo}, which allows for a fine-grained control over grounding and solving of ASP programs. Specifically, this approach allows one to divide an ASP encoding into sub-programs, then handling grounding and solving of these sub-programs separately. In particular, this technique is useful to implement \emph{incremental solving}, which, at each time step, allows to extend the ASP program in order to look for solutions of increasing size.
        Intuitively, every step mimics a Breadth-First Search over the planning state space: at each time step $\asp{t}$, if a solution is not found (\ie there is no plan of length $\asp{t}$ that satisfies the goal), the ASP program is expanded to look for a longer plan.
        For a detailed introduction on multi-shot ASP, we refer the reader to \cite{journals/tplp/Gebser2019,journals/tplp/Kaminski2023}.

        Finally, to visually witness the compactness that possibility spectrums provide w.r.t. MPKMs (see Remark \ref{rem:compactness}), we exploited the Python API offered by \emph{clingo} to implement a graphical representation of the epistemic states visited by the planner. This provides an immediate way of concretely compare the size of output of the two encodings on a given domain instance. Due to space reasons, we report an example of graphical comparison in the arXiv Appendix.

    \subsection{Results}\label{sec:results}
        We ran our test on a 1.4GHz Quad-Core Intel Core i5 machine with 8GB of memory and with a macOS 12.6 operating system and using \emph{clingo} version 5.6.2 with timeout (t.o.) of 10 minutes. The results are shown in Figure \ref{fig:results}. Space and time results are expressed in number of ASP atoms and in seconds, respectively.
        The comparison clearly shows that the \textsc{delphic} encoding outperforms the one based on the traditional Kripke semantics both in terms of space and time. As shown in Figure \ref{fig:results}.a, the number of ASP atoms produced by the \textsc{delphic} encoding is smaller than the ones produced by the Kripke-based ones. The ``spikes'' witnessed in the latter case are found in presence of instances with longer solutions. This indicates that \textsc{delphic} scales much better in terms of plan length than the traditional Kripke-semantics. In turn, this is positively reflected by the time results graph. In fact, observing space and time results together, we can see how the growth of the size of the epistemic states negatively affects the planning process in terms of time performances. This concretely shows that possibilities can be exploited to achieve more efficient planning tools, thus allowing epistemic planners to be able to deal with the full range of features offered by DEL.
        
        % Figure environment removed

        We now analyze the results in detail. The central factor that contributes to the performance gains of \textsc{delphic} is the fact that possibilities allow for a more efficient use of space during the computation of a solution. Specifically, this efficiency results from two key aspects. First, as shown in Remark \ref{rem:compactness}, possibility spectrums are able to represent epistemic information in a more compact way. Working with compact objects contributes significantly to reducing the size of epistemic states after sequences of updates. Second, as shown in Example \ref{ex:union-update}, possibilities naturally allow to reuse previously calculated information (\ie other possibilities that were calculated in previous states). We give a more concrete example of this property in Figure \ref{fig:delphic-reuse}, that shows a sequence of epistemic states (surrounded by rectangles) from a generalization of the Coin in the Box domain of Example \ref{ex:k_model}. We clearly see how the possibilities $\poss{w_0}$ and $\poss{w_1}$ are \emph{reused} in the epistemic states $s_1$, $s_2$, $s_3$ and $s_4$.
        %
        The space efficiency provided by \textsc{delphic} is clearly witnessed in Figure \ref{fig:results}.a. In presence of instances with longer solutions, \textsc{delphic} outperforms the Kripke-based representation, as the latter requires a considerable amount of space to compute a solution (\ie the spikes of the graph).

        % Figure environment removed

        The space efficiency of \textsc{delphic} is directly reflected on time performances. Indeed, in Figure \ref{fig:results}.b are shown the same peaks in correspondence of instances with longer solutions. As a result, we can conclude that the \textsc{delphic} framework allows for a more scalable implementation both in terms of space and time performances. Finally, we point out that the analyzed performance gains are obtained in the \emph{average case}, as there exist extreme (\emph{worst}) cases where the two semantics produce epistemic states with the same structure. In fact, we recall that the \textsc{delphic} framework is semantically equivalent to the Kripke-based one (Theorem \ref{th:delphic_eq}). Thus, we can conclude that \textsc{delphic} provides a practical and usable framework for DEL planning that can be exploited to tackle a wide range of concrete epistemic planning scenarios.
        
        We close this section by noting that a similar, but less general result, was obtained by Fabiano et al. \cite{conf/icaps/Fabiano2020}, where a possibility-based semantics is compared to the traditional Kripke-based one on a fragment of DEL called $\mal$ \cite{journals/corr/Baral2015}, that allows three kinds of actions, \ie \emph{ontic}, \emph{sensing} and \emph{announcement} actions. Since \textsc{delphic} is equivalent to the full DEL framework (see Theorem \ref{th:delphic_eq}), our comparison indeed provides a generalization of the claim made by Fabiano et al.
        % We point out that the timings of our ASP encoding of the Kripke semantics are comparable to those obtained by the solver EFP 2.0 \cite{conf/icaps/Fabiano2020}, that also implements the Kripke semantics. In particular:
        % \begin{enumerate*}
        %     \item the results for the \textbf{Gr} and \textbf{AL} domains of our encoding outperform those of EFP 2.0 (Table 1, column 9 and Table 4, column 4, respectively);
        %     \item our encoding is less performing than, but nonetheless comparable to, EFP 2.0 on the \textbf{CB} and \textbf{CC} domains.
        % \end{enumerate*}
        