\section{A Quantum Toolkit for Generic Group Actions}\label{sec:ggam}

Here, we recall a definition of the generic group action model (GGAM), and show how to use it to give quantum security proofs.

\paragraph{A Shoup-style generic group action.} There have been several different proposals for how to define generic group actions~\cite{AC:MonZha22,PKC:DHKKLR23,EC:BonGuaZha23,EPRINT:OrsZan23}. Here, we briefly give a definition in the style of Shoup~\cite{EC:Shoup97}. To help disambiguate between the different models, we will adapt terminology from~\cite{C:Zhandry22b} and refer to ours as the \emph{Random Set Representation} model.

We first fix a (family of) groups $\G=(\G_\lambda)_\lambda$. We also fix a length function $m:\Z\rightarrow\Z$ with the property that $m(\lambda)\geq\log_2|\G_\lambda|$. We call $m$ the \emph{label length}. In this model, for a given security parameter $\lambda$, a random injection $L:\G_\lambda\rightarrow\{0,1\}^{m}$ is chosen, where $m=m(\lambda)$. Think of $L(g)$ as representing $g*x_\lambda$; we call $L$ the labeling function. $\Xs_\lambda$ will then be the image of $\G_\lambda$ under$L$. All parties are then given the following:
\begin{itemize}
	\item As input, all parties receive the string $L(0)$, where $0\in\G_\lambda$ is the identity. $L(0)$ represents $x_\lambda$.
	\item All parties can then make ``group action'' queries. For classical algorithms, such a query takes the form $(\ell,g)\in\{0,1\}^m\times\G_\lambda$. The response to the query is $L(g+L^{-1}(\ell))$; if $\ell$ is not in the image of $L$, then the response to the query is $\bot$. For quantum algorithms, we follow the usual convention for modeling superposition queries to classical functions, and have the query perform the map:
	\[\sum_{\ell,g,\ell'}\alpha_{\ell,g,\ell'}|\ell,g,\ell'\rangle\mapsto\sum_{\ell,g,\ell'}\alpha_{\ell,g,\ell'}|\ell,g,\ell'\oplus L(g+L^{-1}(\ell))\rangle\]
	The set $\Xs_\lambda$ will be interpreted as the image of $\G_\lambda$ under $L$. Note that group action queries allow for testing membership in $\Xs_\lambda$: $\Xs_\lambda$ are exactly the set of strings where the group action query does not output $\bot$.
\end{itemize}
We call the oracle above $\GGAM_{\G,m}$. In the classical setting, we usually consider queries to the oracle to have unit cost while computation outside the oracle queries is free. If following this convention, our model essentially corresponds to the model considered in~\cite{PKC:DHKKLR23}. However, in the quantum setting, considering the query complexity alone is insufficient, as discrete logarithms can be solved in polynomial query complexity~\cite{EttHoy00}. Therefore, it is necessary to consider the total cost of an algorithm as including both the queries (unit cost per query) and the computation outside the queries.

\subsection{On other Styles of Generic Group Actions}

Other styles of generic group action are possible. For example,~\cite{AC:MonZha22} consider a similar model except where the group itself is also hidden behind an oracle. We might call this the \emph{Random Group, Random Set Representation} model. It is also possible to consider a version that is akin to Maurer's~\cite{IMA:Maurer05} generic group model, where instead of random labels for every element one only receives handles. This is the kind of model considered in~\cite{EC:BonGuaZha23,EPRINT:OrsZan23}. Following the terminology of~\cite{C:Zhandry22b}, this can be called the Type Safe model. We note that it does not make much sense to consider the group as an idealized object while allowing complete access to the set. Since quantum algorithms can solve discrete logarithms, they can essentially ``undo'' the labelling of the group. This means any such ``Random Group Representation'' effectively is just a standard-model group action, defeating the purpose of considering an idealized model.

Here, we discuss why these alternate models come with limitations. First we observe that hiding the group behind an oracle puts more idealized constraints on the adversary, and is therefore a less accurate modeling of group actions.

Worse is the case of Type Safe models. In the classical generic group setting, as first proved in~\cite{PROVSEC:JagSch08} and clarified in~\cite{C:Zhandry22b}, when it comes to proving security, the Type Safe and Random Representation models can usually be treated as equivalent\footnote{This is not the case when using the models to prove \emph{impossibility} results, where even classical there is a major difference between the two models.}. This equivalence would carry over to the classical setting for generic group actions. However, we observe that the equivalence proved in~\cite{PROVSEC:JagSch08,C:Zhandry22b} does \emph{not} hold in the quantum setting. This observation was first made, but not elaborated on, by~\cite{EPRINT:HhaYamYun23}.

In more detail, one direction of the equivalence --- converting an adversary in the Type Safe model into one in the Random Representation model --- is trivial, both classically and quantumly. We just use the random labels from the random representation model as the handles for the Type Safe adversary. For the other direction, the classical proof will construct a Type Safe adversary out of a Random Representation adversary by choosing the random labels itself. The challenge is that the Random Representation adversary will expect identical labels on certain related queries, namely if it computes the same element $g*x_\lambda$ in multiple ways. To account for this, the Type Safe adversary maintains a table of all the queries made so far, and the labels generated for those queries. Then if it ever needs to output an element that was already produced, it can use the table to make sure it uses the same label.

In the quantum setting, maintaining this table is problematic, as it requires recording the queries made by the adversary. Quantum queries cannot be recorded without perturbing them, and if the adversary detects any disturbance it may abort and refuse to work. Such an adversary would break the classical reduction. We note that sometimes it is possible to record quantum queries~\cite{C:Zhandry19}, but the recording has to be done in careful ways that limit applications. In particular, such query recording is usually done on random oracles, and there has so far been no techniques for recording queries for complicated structures like group action oracles.

Thus, based on our current understanding, the Random Set Representation model defined above seems to be ``at least as good'' as any other model for group actions in the quantum setting, and may in fact be ``better'' than the other models. For this reason, we focus on the Random Set Representation model. We leave exploring the exact relationship between the models as an interesting open question.

\paragraph{Algebraic Group Action Model.} In Section~\ref{sec:knowledge}, we consider a different idealized model called the Algebraic Group Action Model, the quantum and group action version of the classical Algebraic Group Model (AGM)~\cite{C:FucKilLos18}. In the classical world, this model is ``between'' the Type Safe model and the standard model, in the sense that security in the algebraic model implies security in the Type Safe model (which in turn often implies security in the Random Representation model, per~\cite{C:Zhandry22b}). However, in Section~\ref{sec:knowledge}, we explain that the quantum analog of this model is actually problematic, and the proof of ``between-ness'' does not hold quantumly, for similar reasons as to why the equivalence between Random Representation and Type Safe models does not appear to hold quantumly. As such, it seems that the (Random Representation) generic group action model actually \emph{better} captures available attacks than the algebraic group action model.




\subsection{Our Framework for Quantum GGAM Security Proofs.}

\paragraph{Challenges with the quantum GGAM.} The problem with the quantum GGAM, as observed by~\cite{PKC:DHKKLR23}, is that we cannot hope for unconditional security results, as the discrete logarithm is easy if we only count quantum query complexity.~\cite{PKC:DHKKLR23} take the approach of instead considering the Algebraic Group Action Model (AGAM). We discuss the pitfalls of this approach in Section~\ref{sec:knowledge}. Here we instead observe that we can recover a meaningful model by counting both queries and computational cost. However, because we cannot hope to prove unconditional query complexity lower bounds, we must instead resort to making computational assumptions and giving reduction-style arguments. This means arguments in the quantum GGAM will look very different that proofs in the classical GGM. To the best of our knowledge, there have been no prior security proofs in the quantum GGAM. We therefore develop some new tools and techniques for giving such proofs, including a proof of security of our quantum money scheme.



\paragraph{Our Abstract Framework.} We first give a very abstract framework, which we will then apply the framework to the GGAM.

Let $\Ys$ be a set, and $\Fs$ be a family of functions $f:\Ys\rightarrow\Ys$. Let $y_0\in\Ys$ be a specific starting element in $\Ys$. Consider a random injection $L:\Ys\rightarrow\{0,1\}^{m'}$, and consider the oracle $\Os$ which maps $\Os(L(y),f)=L(f(y))$; $\Os$ outputs $\bot$ on any string that is not in the image of $L$. We will give the adversary $L(y_0)$ and also superposition access to $\Os$.

Now consider a set $\Ys'\subset\{0,1\}^s$, and suppose we have a not-necessarily-random injection $\Gamma:\Ys\rightarrow\Ys'$ (meaning $s\geq |\Ys|$). We also have a procedure $P$ which is able to map $P(\Gamma(y),f)=\Gamma(f(y))$. However, unlike the oracle $\Os$ considered above, this procedure $P$ may output value other than $\bot$ when given inputs that are not in the image of $\Gamma$. Our goal is to, nevertheless, simulate $\Os$ using $P$.

Concretely, we will choose a random injection $\Pi:\{0,1\}^s\rightarrow\{0,1\}^{m'}$, and simulate $\Os$ with the oracle $\Os'(\Pi(z),f)=\Pi(P(z,f))$; $\Os'$ will output $\bot$ on any input not in the image of $\Pi$. We will then give the adversary $\Pi(\Gamma(y_0))$, ad quantum query access to $\Os'$.


\paragraph{Application to the GGAM.} In our case, we will have $\Ys$ be a group $\G_\lambda$. $\Fs$ will include for each $h\in\G_\lambda$ the map $g\mapsto h+g$. The distinguished element $y_0$ is just $0\in\G_\lambda$. In this way, $\Os$ becomes the generic group action oracle, with labeling function $L$. However, we also include extra operations in $\Fs$, the exact operations will depend on the application.

Our goal will be to simulate $\Os$, the generic group action oracle with extra operations, using only a plain group action $(\G,\Xs,*)$. $(\G,\Xs,*)$ could be a standard-model group action, or perhaps a plain generic group action. We will assume $\Xs_\lambda\subseteq\{0,1\}^{m}$ for some polynomial $m=m(\lambda)$. This ``base'' group action will be the source of hardness. We will therefore make some hopefully simple and mild computational assumptions about $(\G,\Xs,*)$, and hope to derive useful hardness results about the expanded group action $\Os$.

To do so, we will let $\Ys'=\Xs_\lambda^{\otimes k}$ for some $k$. We will also choose some integers $c_1,\dots,c_k$ whose GCD is 1, and starting set elements $y_1,\dots,y_k$. Then define $\Gamma(g)=((c_1g)*y_1,(c_2g)*y_2,\cdots,(c_kg)*y_k)$. Since the GCD of the $c_i$ is 1, the map $\Gamma(g)$ is injective. 

For $f$ corresponding to adding group element $h$, we can set $P((z_1,\dots,z_k),h)=((c_1h)*z_1,\cdots,(c_kh)*z_k)$. Note that this will have the correct effect, as $P(\Gamma(g),h)=\Gamma(h+g)$. For simulating other functions $f\in\Fs$, we will rely on other transformations to the vector $(z_1,\dots,z_k)$, which will depend on the application.


\paragraph{Correctness of the Simulation.}

\begin{lemma}\label{lem:ggamsim} Fix $y_0,\Ys,\Ys',\Gamma,\Fs$ as above. Assume $m'\geq s+t$ for some $t$. Then consider any quantum algorithm $\As$ which makes $q$ quantum queries to its oracle. Then:
	\[\left|\Pr\left[\As^{\Os}(L(y_0))=1\right]-\Pr\left[\As^{\Os'}(\Pi(\Gamma(y_0)))=1\right]\right|<O(q\times 2^{-t/2})\]
Above, $L,\Pi$ are random injections, with $\Os,\Os'$ being derived from them as above. The probabilities are over the random choice of $L,\Pi$ and the randomness of $\As$. Note that our order of quantifiers allows $\As$ to depend on $y_0,\Ys,\Ys',\Gamma,\Fs$.
\end{lemma}
\begin{proof}We prove security via a sequence of hybrids.
\paragraph{Hybrid 0.} This is the case where we run $\As^{\Os}(L(y_0))$ where $L:\Ys\rightarrow\{0,1\}^{m'}$ is uniform random injection. Let $p_0$ be the probability of outputting 1.
\paragraph{Hybrid 1.} Here, we run $\As^{\Os}(L(y_0))$, except that we set $L$ to be the function $L(y)=\Pi(\Gamma(y))$, where $\Pi$ is a random injection. But since $\Gamma$ is an injection, this means $L$ is a random injection anyway, so the distribution of $L$ and hence $\Os$ is identical to {\bf Hybrid 0}. Therefore, if we let $p_1$ be the probability $p_0$ outputs 1 in {\bf Hybrid 1}, we have $p_1=p_0$. Observe that $L(y_0)=\Pi(\Gamma(y_0))$.


\paragraph{Hybrid 2.} Here, we run $\As^{\Os'}(\Pi(\Gamma(y_0)))$. Let $p_2$ be the probability of outputting 1. On all points that $\Os$ accepts, $\Os'$ behaves identically. Likewise, on any point that $\Os'$ rejects, $\Os'$ rejects as well. The only difference between this and {\bf Hybrid 1} is that here, $\Os'$ may accept elements that were rejected by $\Os$, namely elements that are in the image of $\Pi$ but not in the image of $L=\Pi\circ\Gamma$. We will show that these potential changes are nevertheless undetectable except with small probability.

Consider running $\As^{\Os}(L(y_0))$ where $L(y)=\Pi(\Gamma(y))$ as in {\bf Hybrid 1}. However, we only sample $\Pi$ on inputs $z$ that are in the image of $\Gamma$; for all other inputs $z$, $\Pi$ remains unspecified. Observe that {\bf Hybrid 1} never needs to evaluate $\Pi$ on $z$ outside of the image of $\Gamma$, since the oracle $\Os$ will anyway reject in these cases. Let $S\subseteq\{0,1\}^{m'}$ be the set of images of $\Pi$ sampled so far.

Now imagine simulating the rest of $\Pi$. Let $T\subset\{0,1\}^{m'}$ be the set of images of $\Pi$ for $z\in \Ys'$ that are not in the image of $\Gamma$. Observe that $T$ is a random subset of size $|\Ys'|\setminus |\Ys|\leq |\Ys'|\leq 2^s$. We now observe that the only points where $\Os$ and $\Os'$ differ are on pairs $(\ell,f)$ for $\ell\in T$: for $\ell\in S$, the two faithfully compute the same function and are identical, while for $\ell\notin T\cup S$, both output $\bot$.


From here, concluding that $p_1$ and $p_2$ are close is a standard argument. The expected total query weight in {\bf Hybrid 1} on points $(\ell,f)$ for $\ell\in T$ is at most $|T|/2^{m'}\leq 2^{-t}$. Then via standard results in quantum query complexity~\cite{BBBV97}, the difference in acceptance probabilities $|p_1-p_2|$ is at most $O(\sqrt{q^2 2^{-t}})=O(q\times 2^{-t/2})$. Thus $|p_0-p_2|\leq O(q\times 2^{-t/2})$, as desired.\end{proof}

Next, we recall a lemma that shows that random injections can be simulated quantumly:

\begin{lemma}[\cite{AC:Zhandry21}]\label{lem:injectionsim} Random injections with quantum query access can be simulated efficiently.
\end{lemma}

With Lemmas~\ref{lem:ggamsim} and~\ref{lem:injectionsim} in hand, we now turn to security proofs in the GGAM.

\subsection{Group Actions with Twists}

In group actions based on isogenies, it is possible to compute a ``twist'', which maps $g*x_\lambda\mapsto (-g)*x_\lambda$. It is straightforward to update our notion of group action and generic group action to incorporate twists. Let $\GGAM^\pm_{\G,m}$ denote the generic group action relative to group $\G$ with label length $m$. Such twists effectively allow for the dihedral group to act on the set $\Xs_\lambda$. An important question is whether having this larger (non-abelian) group act on $\Xs_\lambda$ can be damaging for security. Here, we show that, at least generically, the existence of twists plausibly has little impact on security.

\paragraph{Assumptions with Negation.} We consider variants of standard assumptions on group actions where additional ``negation'' elements are given out. For example:

\begin{assumption}\label{def:dlogpm} The \emph{discrete log assumption with negation} (DLog$^\pm$) holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\[\Pr[\As(g*x_\lambda,(-g)*x_\lambda)=g:g\gets\G_\lambda]\leq\negl(\lambda)\enspace .\]
\end{assumption}
\begin{assumption}\label{def:cdhpm} The \emph{computational Diffie-Hellman assumption with negation} (CDH$^\pm$) holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\[\Pr\left[\As\left(\substack{a*x_\lambda,b*x_\lambda,\\(-a)*x_\lambda,(-b)*x_\lambda}\right)=(a+b)*x_\lambda: a,b\gets\Gs_\lambda\right]\leq\negl(\lambda)\enspace .\]
\end{assumption}
\begin{assumption}\label{def:ddhpm} The \emph{decisional Diffie-Hellman assumption with negation} (DDH$^\pm$) holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\begin{align*}&\left|\Pr\left[\As\left(\substack{a*x_\lambda,b*x_\lambda,c*x_\lambda,\\(-a)*x_\lambda,(-b)*x_\lambda,(-c)*x_\lambda}\right)=1: a,b,c\gets\Gs_\lambda\right]\right.\\&\left.-\Pr\left[\As\left(\substack{a*x_\lambda,b*x_\lambda,(a+b)*x_\lambda,\\(-a)*x_\lambda,*(-b)*x_\lambda,(-a-b)*x_\lambda}\right)=1:a,b\gets\Gs_\lambda\right]\right|\leq\negl(\lambda)\enspace .\end{align*}
\end{assumption}

Note that the $^\pm$ versions od DLog, CDH, DDH imply their ordinary counterparts. Moreover, the assumptions are \emph{equivalent} to the ordinary versions on group actions with twists. Also, note that, while~\cite{AC:MonZha22} prove the equivalence of ordinary DLog and CDH, their proof does not necessarily apply to the $^\pm$ versions, and an equivalence between these versions may be incomparable since it would start from a stronger property, but also reach a stronger conclusion.

\paragraph{Our Result.} We now show that, the negation assumptions allow us to lift to security under twists, generically.

\begin{theorem}Let $(\G,\Xs,*)$ be a group with $\Xs\subseteq\{0,1\}^m$ such that DLog$^\pm$ (resp. CDH$^\pm$, DDH$^\pm$) holds. Let $m'\geq 2m+\omega(\log\lambda)$. Then DLog$^\pm$ (resp. CDH$^\pm$, DDH$^\pm$) hold in $\GGAM^{\pm}_{\G,m'}$, the GGAM with twists relative to group $\G$ and with label length $m'$.\end{theorem}
\begin{proof}We prove the case of DDH, the other proofs being nearly identical. Let $\As^{\GGAM^\pm_{\G,m}}$ be a supposed adversary for DDH$^\pm$ in $\GGAM^\pm_{\G,m}$, the GGAM with twists and with label length $m'$. Let $\epsilon$ be the distinguishing advantage of $\As$, and $q$ the polynomial number of queries. We construct a new adversary $\Bs$ for DDH$^\pm$ in the group action $(\G,\Xs,*)$ as follows.
\begin{itemize}
	\item $\Bs$, on input $u^+,v^+,w^+,u^-,v^-,w^-$, will chose a random injective function $\Pi$ from $\{0,1\}^{2m}\rightarrow\{0,1\}^{m'}$. To make $\Bs$ efficient, we will actually use Lemma~\ref{lem:injectionsim} to efficiently simulate $\Pi$. For simplicity in the following proof, we will treat $\Bs$ as actually using a true random injection.
	\item $\Bs$ will compute $X=\Pi(x_\lambda,x_\lambda),U=\Pi(u^+,u^-),V=\Pi(v^+,v^-),W=\Pi(w^+,w^-)$.
	\item $\Bs$ will then run $\As(X,U,V,W)$\enspace\footnote{Recall that in the definition of DDH, the adversary is only given $U,V,W$. However, in the generic group action model, we additionally give all parties the starting point $X$.}, simulating its queries as follows:
	\begin{itemize}
		\item For queries to the group action $(\ell,g)$, $\Bs$ simulates the query by computing $(z_1,z_2)\gets\Pi^{-1}(\ell)$, and then returning $\Pi(g*z_1,(-g)*z_2)$. For superposition queries, $\Bs$ simply runs this computation in superposition. Note that if we let $\Gamma(g)=(g*x_\lambda,(-g)*x_\lambda)$, then $\Bs$ simulates these queries exactly as prescribed  above in our general framework, for constants $c_1=1,c_2=-1$ and $y_1=y_2=x_\lambda$.
		
		\item When $\As$ makes a twist query on label $\ell$, $\Bs$ computes $(z_1,z_2)\gets\Pi^{-1}(\ell)$, and then computes $\ell'=\Pi(z_2,z_1)$ and responds with $\ell'$. For superposition queries, $\Bs$ simply runs this computation in superposition. Observe that the twist of $\Pi(\Gamma(g))$ is exactly $\Pi(\Gamma(-g))$.
	\end{itemize}
	
	\item $\Bs$ then outputs whatever $\As$ outputs.
\end{itemize}
We now prove security via a sequence of hybrids.
\paragraph{Hybrid 0.}. Here, we run $\As^{\Os}(X,U=a*X,V=b*X,W=c*X)$ for a random injection $L$, where $X=L(0)$, $a,b,c$ are uniform in $\G_\lambda$, and $*$ denotes the action defined by $\Os$. Let $p_0$ be the probability $\As$ outputs 1.
\paragraph{Hybrid 1.} Here, $\Bs$ is given $u^+,v^+,w^+,u^-,v^-,w^-=a*y,b*y,c*y,(-a)^y,(-b)*y,(-c)*y$, and simulates $\As$ as described above. Let $p_1$ be the probability $\As$ (and hence $\Bs$) outputs 1. Observe that $X,U,V,W=L(0),L(a),L(b),L(c)$, where $L$ is the implicit labeling function $L(g)=\Pi(g*x_\lambda,(-g)*x_\lambda)$. Since $\Bs$ simulates twist queries by mapping $L(g)\mapsto L(-g)$, $\Bs$ correctly simulates the view of $\As$ in {\bf Hybrid 0}, except that $\Os'$ and the twist oracle operate on values $\Pi(z_1,z_2)$ that might not be in the image of $L$. But we can invoke Lemma~\ref{lem:ggamsim} to conclude that $|p_0-p_1|\leq O(q\times 2^{2m-m'})=q\times\negl(\lambda)=\negl(\lambda)$.
\paragraph{Hybrid 2.} Here, $\Bs$ is $u^+,v^+,w^+,u^-,v^-,w^-=a*y,b*y,(a+b)*y,(-a)^y,(-b)*y,(-a-b)*y$, and simulates $\As$ as described above. Let $p_2$ be the probability $\As$ (and hence $\Bs$) outputs 1. By Assumption~\ref{def:ddhpm}, $|p_1-p_2|\leq\negl(\lambda)$.
\paragraph{Hybrid 3.} Now we run $\As^{\Os}(X,U=a*X,V=b*X,W=(a+b)*X)$. Let $p_3$ be the probability $\As$ outputs 1. By a similar argument for going from {\bf Hybrid 0} to {\bf Hybrid 1}, we conclude that $|p_2-p_3|\leq\negl(\lambda)$ is negligible. Piecing everything together, we have that $\epsilon=|p_0-p_3|\leq\negl(\lambda)$, thereby proving DDH$^\pm$ holds in $\GGAM^\pm_{\G,m'}$.\end{proof}





\subsection{Computing Banknotes With Complementary Serial Numbers}

Here, we prove that it is hard in generic group action to compute two banknotes for our scheme with ``complementary'' serial numbers that sum to zero. 

\begin{theorem}\label{thm:almostlightning}Let $(\G,\Xs,*)$ be a group with $\Xs\subseteq\{0,1\}^m$ such that DDH holds (Assumption~\ref{def:ddh}). Let $m'\geq 4m+\omega(\log\lambda)$. Let $(\gen^{\GGAM_{\G,m'}},\ver^{\GGAM_{\G,m'}})$ be the quantum money construction from Construction~\ref{constr:main}, using the generic group action $\GGAM_{\G,m'}$. Consider a QPT adversary $\Bs^{\GGAM_{\G,m'}}$ making queries to $\GGAM_{\G,m'}$, which takes as input the security parameter $\lambda$, and outputs a serial number $h\in\G_\lambda$ and two potentially entangled states $\$_1,\$_2$, which it tries to pass off as two banknnotes. For all such $\Bs$, there exists a negligible $\negl(\lambda)$ such that the following holds:
	\[\Pr\left[\ver^{\GGAM_{\G,m'}}(h,\$_1)=\ver^{\GGAM_{\G,m'}}(-h,\$_2)=1:(h,\$_1,\$_2)\gets\Bs^{\GGAM_{\G,m'}}(1^\lambda)\right]\leq\negl(\lambda)\enspace .\]
\end{theorem}
Notice that the statement above is \emph{almost} the statement that $(\gen^{\GGAM_{\G,m'}},\ver^{\GGAM_{\G,m'}})$ is a quantum lightning scheme, except that the second banknote is verified with respect to $-h$ instead of $h$. Theorem~\ref{thm:almostlightning} is therefore not quite enough to prove the security of our scheme, since it could be the case that it is possible to output many banknotes with the same serial number, even if it is impossible to output two with complementary numbers. We give a different proof below in Section~\ref{sec:qlightningsec} based on a stronger assumption which proves our scheme quantum lightning. We use the result here as a warm-up to our later result, which is based on a more complex assumption. Moreover, Theorem~\ref{thm:almostlightning} lets us prove that it is generically hard to output the uniform superposition $\frac{1}{\sqrt{|\G_\lambda|}}\sum_{g\in\G_\lambda}|L(g)\rangle$, which is just the banknote $|\G^0_\lambda*L(0)\rangle$ with serial number $0$. We state and prove this fact before proving Theorem~\ref{thm:almostlightning}.
\begin{corollary}\label{cor:nozero}Let $(\G,\Xs,*)$ be a group with $\Xs\subseteq\{0,1\}^m$ such that DDH holds (Assumption~\ref{def:ddh}). Let $m'\geq 4m+\omega(\log\lambda)$. Let $L$ be the labeling function for the generic group action $\GGAM_{\G,m'}$. Then for any QPT adversary $\As^{\GGAM_{\G,m'}}$ making queries to $\GGAM_{\G,m'}$ which outputs a state $\rho$, there exists a negligible $\negl(\lambda)$ such that $\langle\G^0_\lambda*L(0)|\rho|\G^0_\lambda*L(0)\rangle\leq\negl(\lambda)$.
\end{corollary}
\begin{proof} Consider an adversary $\As^{\GGAM_{\G,m'}}$ outputting a mixed state $\rho$ and let $\epsilon=\langle\G^0_\lambda*L(0)|\rho|\G^0_\lambda*L(0)\rangle\leq\negl(\lambda)$. We will assume for simplicity that we can project exactly onto $|\G^0_\lambda*L(0)\rangle$; using our verifier from Section~\ref{sec:constr} introduces negligible error that is easily accounted for. By applying this projection to $\rho$, we have that $\As^{\GGAM_{\G,m'}}$ outputs $|\G^0_\lambda*L(0)\rangle$ with probability $\epsilon$. We will therefore assume we have the state $|\G^0_\lambda*L(0)\rangle$.
	
Apply in superposition the map $|x\rangle\mapsto|x,x\rangle$. Now we have the state 
\[\frac{1}{\sqrt{|\G_\lambda|}}\sum_{g\in\G_\lambda}|L(g),L(g)\rangle\]
We can equivalently write this state as:
\[\frac{1}{\sqrt{|\G_\lambda|}}\sum_{h\in\G_\lambda}|\G^h_\lambda*L(0)\rangle|\G^{-h}_\lambda*L(0)\rangle\]
We therefore apply our algorithm ${\sf Findh}$ from Theorem~\ref{thm:computeh} to the first register. The output will be a random serial number $h$, and the state will collapse to $|\G^h_\lambda*L(0)\rangle|\G^{-h}_\lambda*L(0)\rangle$. We output this, which solves the problem in Theorem~\ref{thm:almostlightning}. Thus, we conclude that $\epsilon$ must be negligible.
\end{proof}

We now turn to proving Theorem~\ref{thm:almostlightning}.
\begin{proof}Consider an adversary $\Bs^{\GGAM_{\G,m'}}$, and define: \[\epsilon:=\Pr\left[\ver^{\GGAM_{\G,m'}}(h,\$_1)=\ver^{\GGAM_{\G,m'}}(-h,\$_2)=1:(h,\$_1,\$_2)\gets\Bs^{\GGAM_{\G,m'}}(1^\lambda)\right]\]
We will assume that $\ver^{\GGAM_{\G,m'}}(h,\$)$ projects onto the correct banknote $|\G^h_\lambda*L(0)\rangle$; this assumption only introduces a negligible error which is easily accounted for. Therefore, with probability $\epsilon$, $\Bs$ outputs $h$ and exactly the states $|\G^h_\lambda*L(0)\rangle,|\G^{-h}_\lambda*L(0)\rangle$.

We now construct an adversary $\As$ for DDH on the group action $(\G,\Xs,*)$. $\As$, on input $(u,v,w)$, will choose a random injection $\Pi:\{0,1\}^{4m}\rightarrow\{0,1\}^{m'}$. It will then compute $X=\Pi(x_\lambda,u,v,w)$. $\As$ will then run $\Bs(X)$, simulating its queries $(\ell,g)$ to the group action as follows: compute $(z_1,z_2,z_3,z_4)\gets\Pi^{-1}(\ell)$, and then return $\Pi(g*z_1,(-g)*z_2,g*z_3,(-g)*z_4)$. For superposition queries, $\As$ simply runs this computation in superposition. Note that if we let $\Gamma(g)=(g*x_\lambda,(-g)*u,g*v,(-g)*w)$, then $\As$ simulates these queries exactly as prescribed above in our general framework, for constants $c_1=1,c_2=-1,c_3=1,c_4=-1$ and $(y_1,y_2,y_3,y_4)=(x_\lambda,u,v,w)$.
	
Finally, when $\Bs$ produces serial number $h$ and banknotes $\$_1,\$_2$, $\As$ does the following:
\begin{itemize}
	\item Run $\ver^{\Os'}(h,\$_1)$ and $\ver^{\Os'}(-h,\$_2)$, answering the queries of $\ver$ using the simulated group action oracle. If either run rejects, output a random bit. Otherwise, let $\$_1',\$_2'$ be the resulting states of the verifier.
	\item In superposition, it applies the following map $\ell\mapsto\ell'$ to $\$_2'$:
	\begin{itemize}
		\item First map $\ell\mapsto\Pi^{-1}(\ell)=(z_1,z_2,z_3,z_4)$
		\item Now map $(z_1,z_2,z_3,z_4)\mapsto\ell'=\Pi(z_2,z_1,z_4,z_3)$.
	\end{itemize}
	Let $\$_2''$ be the result of this map.
	\item Apply the swap test to $\$_1',\$_2''$, outputting whatever the swap test outputs.
\end{itemize}
	
By applying Lemma~\ref{lem:ggamsim}, we can conclude that $\$_1,\$_2$ are actually superpositions over elements of the form $L(g)=\Pi(g*z_1,(-g)*z_2,g*z_3,(-g)*z_4)$ for varying $g$. Then using our characterization of the accepting states of $\ver$, we see that both runs of $\ver$ simulteneously accept with probability $\epsilon$, and in this case $\$_1'=|\G_\lambda^h*L(0)\rangle,\$_2'=|\G_\lambda^{-h}*L(0)\rangle$.

We must analyze the effect of the map $\ell\mapsto\ell'$ on $|\G_\lambda^{-h}*L(0)\rangle$. We break into two cases:
\begin{itemize}
	\item $u=a*x_\lambda,v=b*x_\lambda,w=(a+b)*x_\lambda$. Let $\ell=L(g)=\Pi(g*z_1,(-g)*z_2,g*z_3,(-g)*z_4)=\Pi(g*x_\lambda,(a-g)*x_\lambda,(b+g)*x_\lambda,(a+b-g)*x_\lambda)$, which maps to $\ell'=\Pi((a-g)*x_\lambda,g*x_\lambda,(a+b-g)*x_\lambda,(b+g)*x_\lambda)=L(a-g)$.
	
	Therefore, $|\G_\lambda^{-h}*L(0)\rangle$ maps to
	\begin{align*}|\G_\lambda^{-h}*L(0)\rangle&=\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g,-h)|L(g)\rangle\\&\mapsto\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g,-h)|L(a-g)\rangle\\&=\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(a-g,-h)|L(g)\rangle\\&=\chi(a,-h)\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g,h)|L(g)\rangle\\&=\chi(a,-h)|\G_\lambda^{h}*L(0)\rangle\end{align*}
	
	Thus, in this case, $\As$ obtains two copies of $|\G_\lambda^{h}*L(0)\rangle$, which the swap test will accept with probability 1. Therefore, the probability $\As$ outputs 1 is $\frac{1}{2}(1-\epsilon)+\epsilon=\frac{1+\epsilon}{2}$.
	\item $u=a*x_\lambda,v=b*x_\lambda,w=c*x_\lambda$ with $c\neq a+b$. In this case, $\ell=L(g)=\Pi(g*x_\lambda,(a-g)*x_\lambda,(b+g)*x_\lambda,(c-g)*x_\lambda)$ maps to $\ell'=\Pi((a-g)*x_\lambda,g*x_\lambda,(c-g)*x_\lambda,(b+g)*x_\lambda)$. However, $\ell'$ is \emph{not} equal to $L(g')$ for any $g'$. Indeed, in order for $\ell'=L(g')$, we get several equations:
	\[g'=a-g\;\;\;\;a-g'=g\;\;\;\;b+g'=c-g'\;\;\;\;c-g'=b+g\]
	The first two equations require that $g'=a-g$, while the last two require that $g'=c-b-g\neq a-g$. Hence, the state $\$_2''$ has disjoint support from the state $|\G_\lambda^{h}*L(0)\rangle$, and hence is orthogonal to it. Therefore, the swap test will accept with probability exactly 1/2. The overall probability $\As$ outputs 1 is therefore exactly $1/2$.
\end{itemize}
Thus, we see that $\As$ has advantage $\epsilon/2$ in distinguishing DDH, breaking the assumption.\end{proof}



\subsection{Security of our Quantum Lightning Scheme}\label{sec:qlightningsec}

Here, we prove the generic security of our quantum lightning scheme (Construction~\ref{constr:main}). We do not know how to prove security under any standard group action-based assumption. We instead introduce a novel assumption that appears plausible, but needs extra cryptanalysis to be certain.

\paragraph{The Decisional 2x Assumption (D2X).} A classical "Diffie-Hellman Exponent" assumption is to distinguish $g^a,g^{a^2}$ from $g^a,g^b$ for uniform $a,b$. The group action equivalent would be to distinguish $a*x_\lambda,(2a)*x_\lambda$ from $a*x_\lambda,b*x_\lambda$ for uniform $a,b\in\G_\lambda$. Our assumption is based on this assumption. Hover, we need something a bit stronger. In particular, we need not just the set element $(2a)*x_\lambda$ or $b*x_\lambda$, but the ability to query on an \emph{arbitrary} set element $y$ and receive $(2a)*y$ or $b*y$. In th classical group setting, this would correspond to receiving $g^a$, and then being able to query the function $h\mapsto h^{a^2}$ or $h\mapsto h^b$. 

Note that if allowing arbitrary queries to this oracle, the problem is \emph{easy} in many cases. In particular, suppose the order of $\G_\lambda$ is odd with order $2t-1$. Then by querying the oracle $t$ times, we can compute $y_1=(2a)*x_\lambda,y_2=(2a)*y_1=(4a)*x_\lambda,\cdots$, ultimately computing $y_t=(2ta)*x_\lambda=a*x_\lambda$. On the other hand, if the oracle maps $y\mapsto b*x_\lambda$ for a random $b$, then $y_t=(tb)*x_\lambda\neq a*x_\lambda$. This allows for distinguishing the two cases.

Therefore, we only allow a \emph{single} query to the oracle. In this case, a single query does not appear sufficient for breaking the assumption. The adversary, on input $u=a*x_\lambda$, can send $u$ to the oracle, receiving $(3a)*x_\lambda$ or $(a+b)*x_\lambda$. Or it can send $x_\lambda$ to the oracle, receiving $(2a)*x_\lambda$ or $b*x_\lambda$. It can also act on these elements by known constants, computing either $(2a+c)*x_\lambda,(3a+d)*x_\lambda$, or $(b+c)*x_\lambda,(a+b+d)*x_\lambda$. It can also act on the original element $u$, and also on $x_\lambda$ by known constants, receiving $(a+e)*x_\lambda,f*x_\lambda$. Intuitively, it seems the only way the adversary can distinguish between these cases is to find constants $c,d,e,f$ that cause a collision between elements when the oracle acts by $2a$, but no collision when the oracle acts by $b$. However, for any constants $c,d,e,f$, the probability of a collision occurring in either case is negligible. Based on this intuitive argument, it is possible to prove that this assumption is generically hard against \emph{classical} algorithms. We do not, however, know if there is a clever quantum algorithm that breaks the assumption. However, it seems plausible that there is no such efficient quantum algorithm.

We will also allow the query to be quantum, and for technical reasons, we will use an \emph{in place} oracle, meaning $\sum_g\alpha_g|g*x_\lambda\rangle\mapsto \sum_g\alpha_g|(2a+g)*x_\lambda\rangle$, as opposed to the using ``standard'' oracle which maps $\sum_{g,y}\alpha_{g,y}|g*x_\lambda,y\rangle\mapsto \sum_{g,y}\alpha_{g,y}|g*x_\lambda,y\oplus |(g+2a)*x_\lambda\rangle$.

\begin{assumption}\label{def:D2X/min} The Decisional 2X Assumption with minimal oracle (D2X/min) assumption holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\[\left|\Pr\left[\As^{M_{2a}^1}(a*x_\lambda)=1: a\gets\Gs_\lambda\right]-\Pr\left[\As^{M_b}(a*x_\lambda)=1: a,b\gets\Gs_\lambda\right]\right|\leq\negl(\lambda)\enspace .\]
	Above, $M_{c}$ is the in-place (or ``minimal'') oracle mapping $y\mapsto c*y$, and $M_{c}^1$ means the adversary can make only a single query to $M_c$.
\end{assumption}

If we insist on standard oracles, we can instead utilize the following assumption:
\begin{assumption}\label{def:D2X/std} The Decisional 2X Assumption with standard oracle (D2X/std) assumption holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\[\left|\Pr\left[\As^{S_{2a}^1,S_{-2a}^1}(a*x_\lambda)=1: a\gets\Gs_\lambda\right]-\Pr\left[\As^{S_b^1,S_{-b}^1}(a*x_\lambda)=1: a,b\gets\Gs_\lambda\right]\right|\leq\negl(\lambda)\enspace .\]
	Above, $S_{c}$ is the standard oracle mapping $(y,z)\mapsto (y,z\oplus (c*y))$, and $S_{c}^1$ means the adversary can make only a single query to $S_c$.
\end{assumption}
The following lemma is straightforward:
\begin{lemma}\label{lem:standard2min2dx} If D2X/std holds on a group action $(\G,\Xs,*)$, then so does D2X/min
\end{lemma}
\begin{proof}We simply use the oracles $S_c^1,S_{-c}^1$ to simulate the oracle $M_c^1$ in the obvious way.
\end{proof}


\paragraph{Our security proof.} We now prove the generic security of our quantum lightning scheme.

\begin{theorem}\label{thm:main} Let $(\G,\Xs,*)$ be a group with $\Xs\subseteq\{0,1\}^m$ such that D2X/min holds (Assumption~\ref{def:D2X/min}). Let $m'\geq 2m+\omega(\log\lambda)$. Let $(\gen^{\GGAM_{\G,m'}},\ver^{\GGAM_{\G,m'}})$ be the quantum money construction from Construction~\ref{constr:main}, using the generic group action $\GGAM_{\G,m'}$. Then the quantum money construction is a secure quantum lightning scheme.\end{theorem}
\begin{proof}Consider an adversary $\Bs^{\GGAM_{\G,m'}}$ for quantum lightning security, and let $\epsilon$ be the probability that $\Bs$ wins. We will assume that $\ver^{\GGAM_{\G,m'}}(h,\$)$ projects onto the correct banknote $|\G^h_\lambda*L(0)\rangle$; this assumption only introduces a negligible error which is easily accounted for. Therefore, with probability $\epsilon$, $\Bs$ outputs $h$ and exactly two copies of the state $|\G^h_\lambda*L(0)\rangle$.
	
We now construct an adversary $\As$ for D2X/min on the group action $(\G,\Xs,*)$. $\As$, on input $u=a*x_\lambda$, will choose a random injection $\Pi:\{0,1\}^{2m}\rightarrow\{0,1\}^{m'}$. It will then compute $X=\Pi(x_\lambda,u)$. $\As$ will then run $\Bs(X)$, simulating its queries $(\ell,g)$ to the group action as follows: compute $(z_1,z_2)\gets\Pi^{-1}(\ell)$, and then return $\Pi(g*z_1,g*z_2)$. For superposition queries, $\As$ simply runs this computation in superposition. Note that if we let $\Gamma(g)=(g*x_\lambda,g*u)$, then $\As$ simulates these queries exactly as prescribed above in our general framework, for constants $c_1=c_2=1$ and $(y_1,y_2)=(x_\lambda,u)$.
	
Finally, when $\Bs$ produces serial number $h$ and banknotes $\$_1,\$_2$, $\As$ does the following:
\begin{itemize}
	\item Run $\ver^{\Os'}(h,\$_1)$ and $\ver^{\Os'}(h,\$_2)$, answering the queries of $\ver$ using the simulated group action oracle. If either run rejects, output a random bit. Otherwise, let $\$_1',\$_2'$ be the resulting states of the verifier.
	\item In superposition, it applies the following map $\ell\mapsto\ell'$ to $\$_2'$:
		\begin{itemize}
			\item First map $\ell\mapsto\Pi^{-1}(\ell)=(z_1,z_2)$
			\item Use the oracle $M_c$ from the D2X/min assumption to replace $z_1$ with $z_1'=c*z_1$, where $c=2a$ or $b$.
			\item Now map $(z_1',z_2)\mapsto\ell'=\Pi(z_2,z_1')$.
		\end{itemize}
		Let $\$_2''$ be the result of this map.
		\item Apply the swap test to $\$_1',\$_2''$, outputting whatever the swap test outputs.
	\end{itemize}
	
By applying Lemma~\ref{lem:ggamsim}, we can conclude that $\$_1,\$_2$ are actually superpositions over elements of the form $L(g)=\Pi(g*z_1,g*z_2)$ for varying $g$. Then using our characterization of the accepting states of $\ver$, we see that both runs of $\ver$ simulteneously accept with probability $\epsilon$, and in this case $\$_1'=\$_2'=|\G_\lambda^h*L(0)\rangle,\$_2'$.
	
We must analyze the effect of the map $\ell\mapsto\ell'$ on $|\G_\lambda^{h}*L(0)\rangle$. We break into two cases:
	\begin{itemize}
		\item $M_c$ implements the action $y\mapsto c*y$ with $c=2a$. Let $\ell=L(g)=\Pi(g*z_1,g*z_2)=\Pi(g*x_\lambda,(a+g)*x_\lambda)$, which maps to $\ell'=\Pi(g*x_\lambda,(2g)*x_\lambda=L(a+g)$.
		
		Therefore, $|\G_\lambda^{h}*L(0)\rangle$ maps to
		\begin{align*}|\G_\lambda^{h}*L(0)\rangle&=\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g,h)|L(g)\rangle\\&\mapsto\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g,h)|L(a+g)\rangle\\&=\frac{1}{\sqrt{|\G_\lambda}}\sum_g \chi(g-a,h)|L(g)\rangle\\&=\chi(a,-h)|\G_\lambda^{h}*L(0)\rangle\end{align*}
		
		Thus, in this case, $\As$ obtains two copies of $|\G_\lambda^{h}*L(0)\rangle$, which the swap test will accept with probability 1. Therefore, the probability $\As$ outputs 1 is $\frac{1}{2}(1-\epsilon)+\epsilon=\frac{1+\epsilon}{2}$.
		
		
		\item $M_c$ implements the action $y\mapsto c*y$ with $c=b$ for a random $b$. In this case, $\ell=L(g)=\Pi(g*x_\lambda,(a+g)*x_\lambda)$ maps to $\ell'=\Pi((a+g)*x_\lambda,(g+b)*x_\lambda)$. However, $\ell'$ is \emph{not} equal to $L(g')$ for any $g$. Indeed, in order for $\ell'=L(g')$, we get several equations:
		\[g'=a+g\;\;\;\;a+g'=g+b\]
		The first equation requires that $g'=a+g$, while the last one requires that $g'=g+b-a\neq g+a$. Hence, the state $\$_2''$ has disjoint support from the state $|\G_\lambda^{h}*L(0)\rangle$, and hence is orthogonal to it. Therefore, the swap test will accept with probability exactly 1/2. The overall probability $\As$ outputs 1 is therefore exactly $1/2$.
	\end{itemize}
	Thus, we see that $\As$ has advantage $\epsilon/2$ in distinguishing DDH, breaking the assumption.
\end{proof}