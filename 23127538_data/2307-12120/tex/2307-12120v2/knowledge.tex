\section{On Quantum Knowledge Assumptions and Algebraic Adversaries}\label{sec:knowledge}

In this section, we explore knowledge assumptions in the quantum setting, as well the algebraic model for group actions. We find significant issues with both settings. Nevertheless, we give a second security proof for our quantum lightning scheme (Construction~\ref{constr:main}), this time using knowledge assumptions.

\subsection{The Knowledge of Group Element Assumption (KGEA)}

Here, we discuss a new assumption that we define, called the Knowledge of Group Element Assumption (KGEA). This is an analog of the classical Knowledge of Exponent Assumption (KEA)~\cite{C:Damgaard91}, but adapted for quantum adversaries and group actions. It can also be seen as an adaptation of the Knowledge of Path assumption of~\cite{EC:LiuMonZha23}, specialized to group actions. Despite coming from plausible origins, however, we will see that the assumption is, in fact, false. This leads to concerns over the more general Knowledge of Path assumption. We give a candidate replacement assumption that avoids our attack, but more cryptanalysis is needed to understand the new assumption.

\paragraph{The Knowledge of Group Element Assumption (KGEA).} This assumption states, informally, that any algorithm that produces a set element $y$ must ``know'' $g$ such that $y=g*x_\lambda$. Implicit in this assumption is the requirement that it is hard to obliviously sample set elements; we discuss later how to model security when oblivious sampling is possible. In the classical setting, the KGEA assumption would be formalized as follows:

\begin{assumption}\label{def:ckgea} The \emph{classical knowledge of group element assumption} (C-KGEA) holds on a group action $(\G,\Xs,*)$ if the following is true. For any probabilistic polynomial time (PPT) adversary $\As$, there exists a PPT ``extractor'' $\Es$ and a negligible $\epsilon$ such that:
	\[\Pr\left[y\in\Xs\wedge y\neq g*x_\lambda:\substack{y\gets\As(1^\lambda; r)\\g\gets\Es(1^\lambda,r)}\right]\leq\epsilon(\lambda)\enspace .\]
	Above, $r$ are the random coins given to $\As$, which are also given to $\Es$, and the probability is taken over uniform $r$ and any additional randomness of $\Es$.
\end{assumption}
In other words, if $\As$ outputs any set element, it must ``know'' how to derive that set element from $x_\lambda$, since it can compute $g$ such that $y=g*x_\lambda$ using $\Es$ and its random coins. Note that once the random coins are fixed, $\As$ is deterministic. %Also, note that it is possible to consider relaxed versions of this definition, where we only require $\Es$ to output $g$ with non-negligible probability.

As observed by~\cite{EC:LiuMonZha23}, when moving to the quantum setting, the problem with Assumption~\ref{def:ckgea} is that quantum algorithms do not have to flip random coins to generate randomness, and instead their output may be a measurement applied to a quantum state, the result being inherently randomized even if the quantum state is fixed. Thus there is no meaningful way to give the same random coins to $\Es$.

The solution used in~\cite{EC:LiuMonZha23} is to, instead of giving $\Es$ the same inputs as $\As$, give $\Es$ the remaining state of $\As$ at the \emph{end} of the computation. This requires some care, since an algorithm can of course forget any bit of information by simply throwing it away. A more sophisticated way to lose information is to perform other measurements on the state, say measuring in the Fourier basis. The solution in~\cite{EC:LiuMonZha23} is to require that $\As$ makes no measurements at all, \emph{except} for measuring the final output. Note that the Principle of Delayed Measurement implies that it is always possible without loss of generality to move all measurements to the final output. Then $\Es$ is given both the output and the remaining quantum state of $\As$, and tries to compute $g$. Note that in the classical setting, if we restrict to \emph{reversible} $\As$, this formulation of giving $\Es$ the final state of $\As$ is equivalent to given $\Es$ the randomness, since the randomness can be computed by reversing $\As$. Similar to how we can assume a quantum $\As$ makes all its measurements at the end, in we can always assume without loss of generality that a classical $\As$ is reversible. Thus, in the classical setting these two definitions coincide. Adapting to our setting, this approach yields the following assumption:

\begin{assumption}\label{def:qkgea} The \emph{quantum knowledge of group element assumption} (Q-KGEA) holds on a group action $(\G,\Xs,*)$ if the following is true. For any quantum polynomial time (QPT) adversary $\As$ which performs no measurements except for its final output, there exists a QPT extractor $\Es$ and negligible $\epsilon$ such that 
	\[\Pr\left[y\in\Xs\wedge y\neq g*x_\lambda:\substack{(y,|\psi\rangle)\gets\As(1^\lambda)\\g\gets\Es(y,|\psi\rangle)}\right]\leq\epsilon(\lambda)\enspace .\]
\end{assumption}
Above, $y$ is considered as the output of $\As$, and the only measurements applied to $\As$ is the measurement of $y$ to obtain the output.

\paragraph{Our Attack on Q-KGEA.}\label{sec:KGEAattack} Here, we show that Q-KGEA is \emph{false}. 

\begin{theorem}\label{thm:kgeaattack} On any group action where the discrete logarithm assumption holds (Assumption~\ref{def:dlog}), Q-KGEA (Assumption~\ref{def:qkgea}) does not hold.
\end{theorem}
\begin{proof}Our proof will use the {\sf Findh} algorithm developed in Section~\ref{sec:compserial}. We first recall the functionality guaranteed by the algorithm. The algorithm takes as input the state $|\G_\lambda^h*x_\lambda\rangle=\frac{1}{\sqrt{|\G_\lambda|}}\sum_{g\in\G_\lambda}\chi(g,h)|g*x_\lambda\rangle$, and outputs $h$, while leaving $|\G_\lambda^h*x_\lambda\rangle$ intact. In other words, it maps $|\G_\lambda^h*x_\lambda\rangle\mapsto |\G_\lambda^h*x_\lambda\rangle|h\rangle$.

Now, recall that the $|\G_\lambda^h*x_\lambda\rangle$ form a basis. In particular, observe that $|x_\lambda\rangle=\frac{1}{\sqrt{|\G_\lambda|}}\sum_h|\G_\lambda^h*x_\lambda\rangle$. Therefore, we have that
\[{\sf Findh}|x_\lambda\rangle=\frac{1}{\sqrt{|\G_\lambda|}}\sum_h|\G_\lambda^h*x_\lambda\rangle|h\rangle\]

We can now apply an arbitrary $h$-dependent phase to the state, and then uncompute $h$. The result is that we have applied an arbitrary phase to whatever state we started from, but in the Fourier domain of the group. That is, let $F:\G\mapsto\R$ be an arbitrary function. We can apply the phase $|h\rangle\mapsto e^{iF(h)}|h\rangle$, and then uncompute $h$. The result is that $|x_\lambda\rangle$ maps to

\begin{equation}\label{eqn:attack}\frac{1}{\sqrt{|\G_\lambda|}}\sum_h e^{iF(h)}|\G_\lambda^h*x_\lambda\rangle=\frac{1}{|\G_\lambda|}\sum_{g}|g*x_\lambda\rangle\left(\sum_h\chi(g,h)e^{iF(h)}\right)\end{equation}

Now suppose we apply Q-KGEA to the algorithm producing this state. When we measure the register, all we get is a sample of $|g*x_\lambda\rangle$ according to some distribution, with no side information. The Q-KGEA assumption then implies an algorithm $\Es$ which can recover $g$ just given $|g*x_\lambda\rangle$. Therefore, if we can guarantee that measuring the state in Equation~\ref{eqn:attack} gives a uniform choice of $g$, then $\Es$ must be solving discrete logarithms, breaking Assumption~\ref{def:dlog}.

It is not hard to devise a function $F$ which makes the resulting sample $g$ uniform. For example, if $\G=\Z_N$ for an odd integer $N$, we can let $F(h)=2\pi h^2/N$. Then the probability of observing $g$ is 
\[\frac{1}{|\G_\lambda|^2}\times \left|\sum_he^{i2\pi (gh+h^2)/N}\right|^2=\frac{1}{|\G_\lambda|^2}\times |\G_\lambda|=\frac{1}{|\G_\lambda|}\]
as desired, where above we used the fact about quadratic Gauss sums that $\sum_he^{i2\pi (gh+h^2)/N}$ is equal to $|\G_\lambda|^{-1/2}$, up to phase.
\end{proof}



\paragraph{Our Modified Knowledge Assumption.} We propose a simple way to circumvent the attack above. Our basic observation is that, while the attack in Theorem~\ref{thm:kgeaattack} allows for obliviously sampling elements in arbitrary group actions, it does not appear useful for actually breaking cryptosystems. After all, all the attack is doing is sampling random set elements, which can anyway be sampled easily by choosing a random group element $g$ and computing $g*x_\lambda$. Thus, while strictly speaking violating the knowledge assumption, the attack appears useless for actually breaking cryptosystems.

More generally, for ``nice'' cryptographic games (which we will define shortly), in particular games that only use the group action interface and do not themselves obliviously sample elements, it seems that giving the adversary the ability to obliviously sample elements is no help in breaking the game. We therefore postulate that, for any adversary $\As$ that wins such a nice game, there is a different adversary $\As'$ for which the KGEA assumption can be appled, yielding an extractor \emph{for that} $\As'$. Thus, even if the original $\As$ can obliviously sample elements, we essentially assume that $\As'$ cannot, and therefore $\Es$ is possible. We now make this intuition precise.

\medskip

We first introduce the notion of generic group action games. Note that we will only be interested in \emph{games} that are given by generic algorithms; we will always treat the adversary as non-generic.

Briefly, a generic group action game is given by an interactive algorithm (``challenger'') ${\sf Ch}$. ${\sf Ch}$ is limited to only performing group action computations that are ``generic'' and only interacts with the group action through oracles implementing the group action interface. Specifically, a generic algorithm is an oracle-aided algorithm $\Bs$ that has access to oracles ${\sf GA}=({\sf Start},{\sf Act},{\sf Mem})$. Here, ${\sf Start}$ is the oracle that takes as input the empty query, and outputs a string $\tilde{x}$ representing $x_\lambda$. ${\sf Act}$ is the oracle that takes as input a group element $g\in\G_\lambda$ and a string $\tilde{y}$ representing a set element $y$, and outputs a string $\tilde{z}$ representing $z=g*x$. Finally, ${\sf Mem}$ is a membership testing oracle, that tests is a given string $\tilde{x}$ represents an actual set element. From a generic game, we obtain a standard model game by implementing the oracles ${\sf Start},{\sf Act},{\sf Mem}$ with the algorithms for an actual group action: ${\sf Start}$ outputs the actual set element $x_\lambda$, ${\sf Act}$ is the group action $*$, and ${\sf Mem}$ is the membership tester for the set $\Xs_\lambda$. For a concrete group action $(\G,\Xs,*)$, we denote this standard-model game by ${\sf Ch}^{(\G,\Xs,*)}$.

%Notice that a generic group action game cannot obliviously sample elements, since it is not given any interface to the group action other than the group action itself.

For any algorithm $\As$, we say the algorithm $\delta(\lambda)$-breaks ${\sf Ch}^{(\G,\Xs,*)}$ if ${\sf Ch}^{(\G,\Xs,*)}(1^\lambda)$ outputs 1 with probability at least $\delta(\lambda)$ when interacting with $\As$.

We say that ${\sf Ch}$ is one-round if it sends a single classical string to $\As$, and then receives a single quantum message from $\As$, before deciding if $\As$ wins.

\medskip

We now give our modified KGEA assumption.

\begin{assumption}\label{def:qmkgea} The \emph{quantum modified knowledge of group element assumption} (Q-mKGEA) holds on a group action $(\G,\Xs,*)$ if the following is true. Consider a one-round generic group action game ${\sf Ch}$ and any quantum polynomial time (QPT) adversary $\As$ that $1-\delta$-breaks ${\sf Ch}^{(\G,\Xs,*)}$ for a negligible $\delta$. Write the message from $\As$ to ${\sf Ch}^{(\G,\Xs,*)}$ as $\rho_{1,2}$, as a joint system over two registers $1,2$. Consider measuring the first register, to obtain a set element $y$. Denote this as $(y,|\psi\rangle)\gets\As'(1^\lambda)\Leftrightarrow {\sf Ch}^{(\G,\Xs,*)}(1^\lambda)$. Then for all such $\delta,\As,{\sf Ch}$, there exists another  negligible $\delta'$, a QPT $\As'$ that also $1-\delta'$-breaks ${\sf Ch}^{(\G,\Xs,*)}$, and moreover there exists a QPT extractor $\Es$ and negligible $\epsilon$ such that 
	\[\Pr\left[y\in\Xs\wedge y\neq g*x_\lambda:\substack{(y,|\psi\rangle)\gets\As'(1^\lambda)\Leftrightarrow {\sf Ch}^{(\G,\Xs,*)}(1^\lambda)\\g\gets\Es(y,|\psi\rangle)}\right]\leq\epsilon(\lambda)\enspace .\]
\end{assumption}

Intuitively, this assumption says that if $\As$ wins some game, we might not be able to apply the KGEA extractor to it. However, there is some other $\As'$ that also wins the game, and that we \emph{can} apply the KGEA extractor to. 


\begin{remark}Our solution with Assumption~\ref{def:qmkgea} also resolves the problem that, for group actions based on isogenies over elliiptic curves, it is \emph{classically} possible to sample certain set element obliviously, thus violating the plain KGEA assumption. A different remedy used in~\cite{EC:LiuMonZha23} explicitly assumes a probabilistic classical procedure $S()$ for obliviously sampling set elements, and modifies the KGEA assumption so that the extractor either outputs (1) an explanation relative to $x_\lambda$ \emph{or} (2) an explanation relative to some input $y$ together with the random coins $r$ that are fed into $S$ so that $y=S(r)$. This approach works, but is not robust, in the sense that if another sampling procedure is found, it would contradict even the modified assumption. Moreover, our attack in Theorem~\ref{thm:kgeaattack} shows that, when specialized to group actions, even this approach fails, since there is a quantum procedure for sampling elements that has no randomness at all, and therefore can not be explained. Our solution is robust to new sampling procedures being found as well as our quantum sampler. Nevertheless, more cryptanalysis is needed to understand if the assumption is sound.
\end{remark}





\subsection{Quantum Lightning Security Using Q-mKGEA}\label{sec:security}

Here, we give an alternative and incomparable proof of security of our quantum lightning construction to the proof given in Section~\ref{sec:ggam}. Our proof here does not require generic group actions, but instead requires our Q-mKGEA assumption. Thus, it achieves a trade-off by giving a standard-model justification, but the computational assumption is more suspect.



\paragraph{The Discrete Log Assumption, with Help.} We now define a strengthening of the Discrete Log assumption (Assumption~\ref{def:dlog}), which allows the adversary limited query access to a computational Diffie Hellman (CDH) oracle. 

\begin{assumption}\label{def:dlogminimalcdh} We say that the \emph{Discrete Log with a single minimal CDH query} assumption (DLog/1-minCDH) assumption holds if the following is true. For any QPT adversary $\As$ playing the following game, parameterized by $\lambda$, there is a negligible $\epsilon$ such that $\As$ wins with probability at most $\epsilon(\lambda)$:
	\begin{itemize}
		\item The challenger, on input $\lambda$, chooses a random $g\in\G_\lambda$. It sends $\lambda$ to $\As$
		\item $\As$ submits a superposition query $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|y,z\rangle$. Here, $y$ is a set element that forms the query, and $z$ is the internal state of the adversary when making the query. The challenger responds with $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|(-g)*y,z\rangle$\enspace\footnote{Note that this operation is unitary and efficiently computable since $y\mapsto(-g)*y$ is efficiently computable and efficiently reversible given $g$.}. 
		\item The challenger sends $g*x$ to $\As$.
		\item $\As$ outputs a guess $g'$ for $g$. It wins if $g'=g$.
	\end{itemize}
\end{assumption}

Note that Assumption~\ref{def:dlogminimalcdh} uses a ``minimal'' oracle for the CDH oracle, meaning is replaces $y$ with $(-g)*y$. This is only a possibility because $y\mapsto(-g)*y$ is reversible; otherwise the query would not be unitary. The minimal oracle, however, is somewhat non-standard. So we here define a slightly different assumption which uses ``standard'' oracles:

\begin{assumption}\label{def:dlogstandardcdh} We say that the \emph{Discrete Log with a double standard CDH query} assumption (DLog/2-stdCDH) assumption holds if the following is true. For any QPT adversary $\As$ playing the following game, parameterized by $\lambda$, there is a negligible $\epsilon$ such that $\As$ wins with probability at most $\epsilon(\lambda)$:
	\begin{itemize}
		\item The challenger, on input $\lambda$, chooses a random $g\in\G_\lambda$. It sends $\lambda$ to $\As$.
		\item $\As$ submits a superposition query $\sum_{y\in\Xs,w,z\in\{0,1\}^*}\alpha_{y,w,z}|y,w,z\rangle$. Here, $y$ is a set element that forms the query, $w$ is a string that forms the response register, and $z$ is the internal state of the adversary when making the query. The challenger responds with $\sum_{y\in\Xs,w,z\in\{0,1\}^*}\alpha_{y,w,z}|y,w\oplus[(-g)*y],z\rangle$. 
		\item $\As$ submits a second superposition query $\sum_{y\in\Xs,w,z\in\{0,1\}^*}\alpha_{y,w,z}|y,w,z\rangle$. The challenger responds with $\sum_{y\in\Xs,w,z\in\{0,1\}^*}\alpha_{y,w,z}|y,w\oplus[g*y],z\rangle$. 
		\item The challenger sends $g*x$ to $\As$.
		\item $\As$ outputs a guess $g'$ for $g$. It wins if $g'=g$.
	\end{itemize}
\end{assumption}

\begin{lemma}\label{lem:standard2mindlog} If DLog/2-stdCDH (Assumption~\ref{def:dlogstandardcdh}) holds in a group action, then so does DLog/1-minCDH (Assumption~\ref{def:dlogminimalcdh}).
\end{lemma}
\begin{proof}Like the proof of Lemma~\ref{lem:standard2min2dx}, Lemma~\ref{lem:standard2mindlog} follows by using the two standard oracle queries to simulate a single minimal oracle query.\end{proof}
	
	%Consider a supposed adversary $\As$ for DLog/1-minCDH with non-negligible winning probability $\epsilon$. We construct a new adversary $\Bs$ for DLog/2-stdCDH with the same non-negligible winning probability as follows. $\Bs$ runs $\As$ until $\As$ makes its superposition query $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|y\rangle_\Ys|z\rangle_\Zs$. $\Bs$ then initializes a new register $\Rs$ with the state $|0\rangle$. $\Bs$ then submits $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|y\rangle_\Ys|0\rangle_\Rs|z\rangle_\Zs$ as its first query. In response, it receives $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|y\rangle_\Ys|(-g)*y\rangle_\Rs|z\rangle_\Zs$. Now it swaps the roles of $\Rs$ and $\Ys$, and makes its second query on $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|(-g)*y\rangle_\Ys|y\rangle_\Rs|z\rangle_\Zs$. In response it receives $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|(-g)*y\rangle_\Ys|0\rangle_\Rs|z\rangle_\Zs$. Then it discards the $\Rs$ register, and sends the resulting state $\sum_{y\in\Xs,z\in\{0,1\}^*}\alpha_{y,z}|(-g)*y\rangle_\Ys|z\rangle_\Zs$ to $\As$. 
	
	%Afterward, when $\Bs$ receives $g*x$, it forwards it to $\As$, and then outputs whatever $g'$ that $\As$ outputs. Thus, we see that $\Bs$ correctly simulates the view of $\As$, and thus the probability $\Bs$ wins is the same as $\As$, namely $\epsilon$. 

From this point forward, we will use DLog/1-minCDH as our assumption; Lemma~\ref{lem:standard2mindlog} then shows that we could have instead used DLog/2-stdCDH.

\paragraph{The security proof.} We are now ready to formally state and prove security.

\begin{theorem}\label{thm:main2} Assuming Q-mKGEA (Assumption~\ref{def:qmkgea}) and DLog/1-minCDH (Assumption~\ref{def:dlogminimalcdh}) both hold on a group action $(\G,\Xs,*)$, then Construction~\ref{constr:main} is a quantum lightning scheme.
\end{theorem}
\begin{remark}Before proving Theorem~\ref{thm:main}, we briefly discuss how to handle the case of non-uniform attackers, since in this setting quantum lightning is insecure without some modifications. Note that even against non-uniform attackers, DLog/1-minCDH still plausibly holds. However, Q-KGEA certainly does not, as a non-uniform attacker may have a $y$ hard-coded for which it does not know the discrete log with $x_\lambda$. As discussed in Section~\ref{sec:prelim}, there are several possibilities. 
	\begin{itemize}
		\item The first is to restrict to non-uniform attackers that only have classical advice. While classical advice does not appear to be useful in breaking Construction~\ref{constr:main}, it still allows for breaking Q-KGEA; thus while our scheme may be secure in this setting, the security proof would be vacuous.
		\item The second is to use a probabilistically generated group action, and define Q-KGEA and DLog/1-minCDH accordingly. For quantum money security, it would suffice to have $\gen$ create the parameters of the group action and then include them in the serial number, since the serial number is generated honestly. For quantum lightning security, we would instead need the parameters to be generated by a trusted third party and then placed in a common random string (CRS). 
		\item The final option is to use the human ignorance approach~\cite{VIETCRYPT:Rogaway06}, where we explicitly state our security theorem as transforming a quantum lightning adversary into a Q-KGEA adversary; while such Q-KGEA adversaries exist in the non-uniform setting without a CRS, they are presumably unknown to human knowledge. As a consequence, a quantum lightning attacker, while existing, would likewise be unknown to human knowledge. 
	\end{itemize}
	For simplicity, state and prove Theorem~\ref{thm:main} in the uniform setting; either probabilistically generating the group action or using human ignorance would require straightforward modifications. 
\end{remark}

\noindent We now are ready to prove Theorem~\ref{thm:main}.

\begin{proof}Consider a QPT quantum lightning adversary $\As$ which breaks security with non-negligible success probability $\epsilon$. Since an adversary can always tell if it succeeded by running $\ver$, we can run $\As'$ multiple times to boost the probability of a successful break. In particular, we can run $\As'$ for $\lambda\epsilon$, and at except with probability $1-2^{-\Theta(\lambda)}$, at least one of the runs will succeed. This allows us to conclude without loss of generality that $\As'$ has success probability $1-2^{-\Theta(\lambda)}$. We can then invoke Q-mKGEA (Assumption~\ref{def:qmkgea}) to arrive at an adversary $\As$ which also breaks quantum lightning security with high success probability.
	
	
By Theorem~\ref{thm:reject}, we know that if $\As$ outputs a serial number $h$, the states outputted are exponentially close to two copies of $|\G_\lambda^h*x_\lambda\rangle$.
	
For simplicity in the following proof, we will assume the probability of passing verification is actually 1; it is straightforward to adapt the proof to the case of negligible error.
	
Next, we purify $\As$, and assume that before measurement, $\As$ outputs a pure state $|\psi\rangle$. By our assumption that the success probability is 1, $|\psi\rangle$ will have the form
	\[|\psi\rangle=\sum_{h}\alpha_h|\phi_h\rangle|\G_\lambda^h*x_\lambda\rangle|\G_\lambda^h*x_\lambda\rangle=\frac{1}{|\G_\lambda|}\sum_h\alpha_h|\phi_h\rangle\chi(h,g_1+g_2)|g_1*x\rangle_{\Ms_1}|g_2*x\rangle_{\Ms_2}\enspace.\]
	Above, $|\phi_h\rangle$ are arbitrary normalized states representing whatever state the adversary contains after outputting its banknotes, and $\sum_h\|\alpha_h\|^2=1$.
	
	Now consider the adversary $\Bs$ which first constructs $|\psi\rangle$, and then measures the register $\Ms_2$ to obtain $y_2=g_2*x$. 
	\begin{claim}$g_2$ is uniform in $\G$.
	\end{claim}
	\begin{proof}Consider additionally measuring $\Ms_1$ in the basis $\{|\G_\lambda^h*x_\lambda\rangle\}$. This this measurement is on a different register than the measurement on $\Ms_2$, measuring $\Ms_1$ does not affect the output distribution of $\Ms_2$ (though the results may be correlated). But the measurement on $\Ms_1$ determines $h$, and conditioned on $h$, $\Ms_2$ collapses to $|\G_\lambda^h*x_\lambda\rangle$. Regardless of what $h$ is, measuring $|\G_\lambda^h*x_\lambda\rangle$ gives a uniformly random element in $\Xs$. Thus, even without measuring $\Ms_1$, the measurement of $\Ms_2$ gives a uniform element in $\Xs$.\end{proof}
	
	Therefore, after measuring $\Ms_2$, the state $|\psi\rangle$ then collapses to \[|\psi_{g_2*x_\lambda}\rangle:=\frac{1}{\sqrt{|\G_\lambda|}}\sum_h\alpha_h|\phi_h\rangle\chi(h,g_1+g_2)|g_1*x\rangle_{\Ms_1}\enspace .\]
	
	\begin{claim}There is a QPT procedure ${\sf Map}$ such that ${\sf Map}(g,|\psi_{y}\rangle)=|\psi_{g*y}\rangle$.
	\end{claim}
	\begin{proof}${\sf Map}$ simply applies the map $y\mapsto (-g)*y$ to $\Ms_1$ in superposition. Then we have that:
		\begin{align*}
			{\sf Map}(g,|\psi_{g_2*x_\lambda}\rangle)&=\frac{1}{\sqrt{|\G_\lambda|}}\sum_h\alpha_h|\phi_h\rangle\chi(h,g_1+g_2)|(g_1-g)*x\rangle_{\Ms_1}\\
			&=\frac{1}{\sqrt{|\G_\lambda|}}\sum_h\alpha_h|\phi_h\rangle\chi(h,g_1'+g+g_2)|g_1'*x\rangle_{\Ms_1}=|\psi_{(g+g_2)*y}\rangle=|\psi_{g*(g_2*y)}\rangle
		\end{align*}
		Above we used the change of variables $g_1'=g_1-g$.
	\end{proof}
	
	Now we invoke Q-KGEA (Assumption~\ref{def:qkgea}) on the adversary $\Bs$. Since $\Bs$ always outputs a valid set element, this means there is another QPT algorithm $\Es$ such that 
	\[\Pr[\Es(g_2*x_\lambda,|\psi_{g_2*x_\lambda}\rangle)=g_2]\geq 1-\negl(\lambda)\]
	
	Above, the probability is over $g_2*x_\lambda$, as well as any randomness incurred when executing $\Es$. We note by a simple random self-reduction that we can insist the above probability holds for \emph{all} $g_2*x_\lambda$, where the randomness is only over $\Es$. Indeed, given $|\psi_{g_2*x_\lambda}\rangle,g_2*x_\lambda$, we can choose a random $g$ and compute $g_2'*x_\lambda$ as $g*(g_2*x_\lambda)$ where $g_2'=g+g_2$. Likewise, we can compute $|\psi_{g_2'*x_\lambda}\rangle$ as ${\sf Map}(g,|\psi_{g_2*x_\lambda}\rangle)$. This gives a random instance on which to apply $\Es$, giving $g_2'$ with probability $1-\negl(\lambda)$, regardless of $g_2$. Then we can compute $g_2=g_2'-g$. We thus compute $g_2$ with overwhelming probability, even in the worst case. We will therefore assume without loss of generality that this is the case for $\Es$.
	
	For simplicity, we will actually assume that the probability is 1; it is straightforward to handle the case the probability is negligibly close to 1. By the Gentle Measurement Lemma~\cite{Winter99}, $\Es$ can compute $g_2$ without altering the state $|\psi_{g_2*x}\rangle$. Thus, by combining $\Bs$ and $\Es$, we can compute both $|\psi_{g_2*x}\rangle$ and $g_2$ with probability 1. We can then compute ${\sf Map}(-g_2,|\psi_{g_2*x_\lambda}\rangle)=|\psi_{x_\lambda}\rangle$.
	
	We now describe a new algorithm $\Cs$ which breaks DLog/1-minCDH (Assumption~\ref{def:dlogminimalcdh}). $\Cs$ works as follows:
	\begin{itemize}
		\item It constructs $|\psi_{x_\lambda}\rangle$ as above.
		\item It makes its query to the DLog/1-minCDH challenger, setting $\Ms_1$ as the query register. This query simulates the operation ${\sf Map}(g,\cdot)$, where $g$ is the group element chosen by the challenger. Thus, at the end of the query, $\Cs$ has $|\psi_{g*x_\lambda}\rangle$.
		\item Now upon receiving $g*x_\lambda$ from the challenger, run $\Es(g*x_\lambda,|\psi_{g*x_\lambda}\rangle)$. By the guarantees of $\Es$, the output will be $g$.
	\end{itemize}
	Thus we see that $\Cs$ breaks the DLog/1-minCDH assumption. This completes the security proof.\end{proof}













\subsection{Algebraic Group Actions.}

Next we turn to the Algebraic Group Action Model (AGAM), considered by a couple recent works~\cite{PKC:DHKKLR23,EPRINT:OrsZan23}. This is an analog of the Algebraic Group Model (AGM)~\cite{C:FucKilLos18}, adapted to group actions and quantum attackers. This model considers algebraic adversaries, which are algorithms where, any time they produce a set element output, must also ``explain'' the output in terms of the set elements the adversary saw as input. That is, if the algebraic adversary has so far been given set elements $y_1,\dots,y_\ell$, when it outputs a new element $y$, it must also output a group element $g\in \G_\lambda$ and index $i$ such that $y=g*y_i$.

In the classical world, a common refrain is that the AGM is ``between'' the generic group model and standard model. As formalized by Zhandry~\cite{C:Zhandry22b}, this is true in a particular sense: any ``nice'' security game that is secure in the standard model is also secure in the AGM, and in turn any nice security game that is secure in the AGM is also secure in the appropriate generic group model. The statements also hold true for group actions, provided we still restrict to the classical world. Here, ``nice'' comes with some important restrictions. The game must be ``single stage'', meaning there is only a single adversary interacting with the challenger. Moreover, the game must be a ``type safe'' game, which for group actions informally means the algorithms can pass set elements around and perform group action computations on them as a black box, but cannot maniluate the individual bits of the set element representations.

We might expect, therefore, that the AGAM is also ``between'' the GGAM and the standard model quantumly. However, this appears not to be the case, or at least it does not follow from any obvious adaptation of existing work. There are at least three problems.

The first is closely related to the issue with knowledge assumptions explored above. After all, the motivation for the AGAM, following the motivation from the AGM, is that we would expect the only way to output set elements is to actually derive them from existing set elements via the group action, in which case we would seem to know how to explain the new elements in terms of existing elements. In the classical setting, you can indeed show that this is true generically. However, our attack on the Q-KGEA assumption (Theorem~\ref{thm:kgeaattack}) shows that this is not true quantumly. Namely, it is possible to output a superposition of set element where one does not ``know'' how to derive those elements from input elements.

For the second issue, consider the security game for our quantum lightning scheme. Recall that the adversary must output some $h$ along with two copies of $|\G^h*x_\lambda\rangle=\frac{1}{\sqrt{|\G_\lambda|}}\sum_g \chi(h,g)|g*x_\lambda\rangle$. An algebraic adversary would have to ``explain'' this state, meaning it must output two copies of
\[\frac{1}{\sqrt{|\G_\lambda|}}\sum_{g}\chi(h,g)|g*x_\lambda,g\rangle\]
But here, note that if the challenger tries to verify the banknote state, the verification will actually \emph{fail}, since the state is entangled with $g$. Worse, observe that the state produced by the algebraic adversary is actually trivial to construct for any given $h$, by first constructing $\frac{1}{\sqrt{|\G_\lambda|}}\sum_{g}\chi(h,g)|g\rangle$ and then applying the group action operation. Thus, we see that the algebraic adversary can actually trivially produce two copies of the requisite state. This is in contrast to the actual banknote state $|\G^h*x_\lambda\rangle$, where it appears only possible to sample actual banknotes for a random $h$, but not produce a banknote for a given $h$; indeed the security of our scheme inherently relies on this difficult. That is, the state required of the algebraic adversary is trivial, whereas the state required by a standard-model adversary is presumably hard to construct. This is in contrast to the classical world, where the algebraic adversary's task is always at least as hard as the real-world adversary.



The third issue is the claim that any game which is secure in the classical AGM/AGAM is also secure in the classical GGM/GGAM. This claim, or at least the classical proof of it, does not hold quantumly. This is because the proof relies on the ability to view the adversary's queries to the group/group action oracle and extract information from them. Specifically, in the classical AGAM, the only way the adversary can obtain new set elements is to act on existing elements by querying the group action. By writing down the input set and group element as well as the output group element, we can remember how we derived all set elements. Importantly, for any set element we produce, we can trace that set element back to an input set element, and see that the output element was obtained via a sequence of actions by group elements on the original input element. By multiplying these group actions together, we can explain the output element in terms of the input set element.
	
This strategy, however, does not work quantumly. Consider for example the hardness assumption DLog/minCDH (Assumption~\ref{def:dlogminimalcdh}). Here, the adversary can query on a superposition $\sum_y \alpha_y |y\rangle$ of set elements, and get the resulting superposition obtained by action of a secret group element $(-g)$: $\sum_y \alpha_y |(-g)*y\rangle$
	
In the AGAM, we would ask the adversary queries on $\sum_y \alpha_y |y,{\tt Explain}_y\rangle$, where ${\sf Explain}_y$ is an explanation of $y$ in terms of the elements the adversary has seen so far. In the case of DLog/minCDH, the only element seen by the time the adversary must make its query is $x_\lambda$, and so ${\sf Explain}_y$ is the unique $h$ such that $y=h*x_\lambda$. Thus, the adversary's query takes the form $\sum_h \alpha_{h*x_\lambda} |h*x_\lambda,h\rangle$. In response, it receives \[|\phi_{\sf AGAM}\rangle=\sum_h \alpha_{h*x_\lambda} |(h-g)*x_\lambda,h\rangle\]

On the other hand, a generic adversary would have just \[|\phi_{\sf GGAM}\rangle=\sum_h \alpha_{h*x_\lambda} |(h-g)*x_\lambda\rangle\]

While in the classical setting, having the extra information $h$ about $y$ does not cause problems (it can just be erased or ignored), this extra information is problematic quantumly. For example, it might be that having $|\phi_{\sf GGAM}\rangle$ allows for solving some task, whereas having $\sum_h \alpha_{h*x_\lambda} |(h-g)*x_\lambda,h\rangle$ does not. In such a case, we find that the task is hard in the AGAM, despite being easy in the GGAM and even in the standard model. In particular, if we want the AGAM to be ``between'' the GGAM and standard models, we would need to rule this situation out, meaning we would need a way to map the state $|\phi_{\sf AGAM}\rangle$ containing the explanation back to the state $|\phi_{\sf GGM}\rangle$ without the explanation. This mapping, in general, will be intractible, as it requires un-computing $h$ from $|(h-g)*x_\lambda$. 
	
\medskip

Based on these issues, we see that the AGAM is probably \emph{not} a reasonable model for quantum attacks, at least when the game is inherently quantum, as with the security of our quantum lightning scheme or with assumptions that allow quantum queries. On the other hand, the model might be reasonable for ``classically stated'' security games, such as ordinary discrete log or CDH. However, these problems do not arise at all for generic group actions. Therefore, based on this discussion, we posit that generic group actions should be the preferred method for analyzing cryptosystems and security games.