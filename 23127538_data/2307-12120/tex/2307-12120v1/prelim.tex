\section{Preliminaries}\label{sec:prelim}

Here we give our notation and definitions. We assume the reader is familiar with the basics of quantum computation.

\subsection{Quantum Fourier Transform over Abelian Groups} 

Let $\G$ be an abelian group, which we will denote additively. We here define our notation for the quantum Fourier transform over $\G$. Write $\G=\Z_{n_1}\times \Z_{n_2}\times\Z_{n_k}$ where $\Z_{n_j}$ are the additive cyclic groups on $n_j$ elements, and associate elements $g\in\G$ with tuples $g=(g_1,\dots,g_k)$ where $g_j\in\Z_{n_j}$. Then define $\chi:\G^2\rightarrow\C$ by
\[\chi_\G(g,h)=\prod_{j=1}^k e^{i2\pi g_j h_j/n_j}\]
Observe the following:
\begin{align*}
	\chi_\G(g,h)&=\chi_\G(h,g)&
	\chi_\G(g_1+g_2,h)&=\chi_\G(g_1,h)\times\chi_\G(g_2,h)\\
	\chi_\G(-g,h)&=\chi_\G(g,h)^{-1}&
	\sum_{g\in\G}\chi_\G(g,h)&=\begin{cases}|\G|&\text{ if }h=1_\G\\0&\text{ if }h\neq 1_\G\end{cases}
\end{align*}


The quantum Fourier transform (QFT) over $\G$ is the unitary $\QFT_\G$ defined as 
\[\QFT_\G|g\rangle=\frac{1}{\sqrt{|\G|}}\sum_{h\in\G}\chi(g,h)|h\rangle\enspace.\]
Observe that $\QFT_\G=\QFT_{\Z_{n_1}}\otimes\cdots\otimes\QFT_{\Z_{n_k}}$. Therefore, since the standard QFT corresponds to $\QFT_{\Z_{n_j}}$ and can be implemented efficiently, so can $\QFT_\G$.

From this point on, we will only work with a single group, so we will drop the sub-script and simply write $\chi(g,h),\QFT$, etc.





\subsection{Quantum Money and Quantum Lightning} 

Here we define quantum money and quantum lightning. In the case of quantum money, we focus on \emph{mini-schemes}~\cite{STOC:AarChr12}, which are essentially the setting where there is only ever a single valid banknote produced by the mint. As shown in~\cite{STOC:AarChr12}, such mini-schemes can be upgraded generically to full quantum money schemes using digital signatures. 

\paragraph{Syntax.} Both quantum money mini-schemes and quantum lightning share the same syntax:
\begin{itemize}
	\item $\gen(1^\lambda)$ is a quantum polynomial-time (QPT) algorithm that takes as input the security parameter (written in unary) which samples a classical serial number $\sigma$ and quantum banknote $\$$. 
	\item $\ver(\sigma,\$)$ takes as input the serial number and a supposed banknote, and either accepts or rejects, denoted by $1$ and $0$ respectively.
\end{itemize}

\paragraph{Correctness.} Both quantum money mini-schemes and quantum lightning have the same correctness requirement, namely that valid banknotes produced by $\gen$ are accepted by $\ver$. Concretely, there exists a negligible function $\negl(\lambda)$ such that
\[\Pr[\ver(\sigma,\$)=1:(\sigma,\$)\gets\gen(1^\lambda)]\geq 1-\negl(\lambda)\enspace.\]

\paragraph{Security.} We now discuss the security requirements, which differ between quantum money and quantum lightning.

\begin{definition}Consider a QPT adversary $\As$, which takes as input a serial number $\sigma$ and banknote $\$$, and outputs two potentially entangled states $\$_1,\$_2$, which it tries to pass off as two banknnotes. $(\gen,\ver)$ is a secure \emph{quantum money mini-scheme} if, for all such $\As$, there exists a negligible $\negl(\lambda)$ such that the following holds:
\[\Pr\left[\ver(\sigma,\$_1)=\ver(\sigma,\$_2)=1:\substack{(\sigma,\$)\gets\gen(1^\lambda)\\(\$_1,\$_2)\gets\As(\sigma,\$)}\right]\leq\negl(\lambda)\enspace .\]
\end{definition}
\begin{definition}Consider a QPT adversary $\Bs$, which takes as input the security parameter $\lambda$, and outputs a serial number $\sigma$ and two potentially entangled states $\$_1,\$_2$, which it tries to pass off as two banknnotes. $(\gen,\ver)$ is a secure \emph{quantum lightning} scheme if, for all such $\Bs$, there exists a negligible $\negl(\lambda)$ such that the following holds:
	\[\Pr\left[\ver(\sigma,\$_1)=\ver(\sigma,\$_2)=1:(\sigma,\$_1,\$_2)\gets\Bs(1^\lambda)\right]\leq\negl(\lambda)\enspace .\]
\end{definition}
Quantum lightning trivially implies quantum money: any quantum money adversary $\As$ can be converted into a quantum lightning adversary $\Bs$ by having $\Bs$ run both $\gen$ and $\As$. But quantum lightning is potentially stronger, as it means that even if the serial number is chosen adversarially, it remains hard to devise two valid banknotes. This in particular means there is some security against the mint, which yields a number of additional applications, as discussed by~\cite{EC:Zhandry19b}.

\begin{remark}One limitation of quantum lightning as defined above is that it cannot hold against non-uniform attackers with quantum advice, as such attackers could have $\sigma,\$_1,\$_2$ hard-coded in their advice. The situation is analogous to the case of collision resistance, where unkeyed hash functions cannot be secure against non-uniform attackers. This limitation be remedied by either insisting on only uniform attackers or attackers with classical advice. Alternatively, one can work in a trusted setup model, where a trusted third party generates a common reference string that is then inputted into $\gen,\ver$. A third option is to use the ``human ignorance'' approach~\cite{VIETCRYPT:Rogaway06}, in which we would formalize security proofs as explicitly transforming a quantum lightning adversary into an adversary for some other task, the latter adversary existing but is presumably unknown to human knowledge. We will largely ignore these issues throughout this work, but occasionally make brief remarks about what the various approaches would look like.
\end{remark}

\subsection{Group Actions}

An (abelian) group action consists of a family of (abelian) groups $\G=(\G_\lambda)_\lambda$ (written additively), a family of sets $\Xs=(\Xs_\lambda)_\lambda$, and a binary operation $*:\G_\lambda\times \Xs_\lambda\rightarrow \Xs_\lambda$ satisfying the following properties:
\begin{itemize}
	\item {\bf Identity:} If $0\in \G_\lambda$ is the identity element, then $0*x=x$ for any $x\in \Xs_\lambda$.
	\item {\bf Compatibility:} For all $g,h\in \G_\lambda$ and $x\in \Xs_\lambda$, $(g+h)*x=g*(h*x)$.
\end{itemize}
We will additionally require the following properties:
\begin{itemize}
	\item {\bf Efficiently computable:} There is a QPT procedure ${\sf Construct}$ which, on input $1^\lambda$, outputs a description of $\G_\lambda$ and an element $x_\lambda\in\Xs_\lambda$. The operation $*$ is also computable by a QPT algorithm.
	\item {\bf Efficiently Recognizable:} There is a QPT procedure ${\sf Recog}$ which recognizes elements in $\Xs_\lambda$. That is, for any $\lambda$ and any string $y$ (not necessarily in $\Xs_\lambda)$, ${\sf Recog}(1^\lambda,y)$ accepts $y$ with overwhelming probability if $y\in\Xs_\lambda$, and rejects with overwhelming probability if $y\notin\Xs_\lambda$.
	\item {\bf Regular:} For every $y\in\Xs_\lambda$, there is exactly one $g\in\G_\lambda$ such that $y=g*x_\lambda$. 
\end{itemize}

\paragraph{Cryptographic group actions.} At a minimum, a cryptographically useful group action will satisfy the following discrete log assumption:
\begin{assumption}\label{def:dlog} The \emph{discrete log assumption} (DLog) holds on a group action $(\G,\Xs,*)$ if, for all QPT adversaries $\As$, there exists a negligible $\lambda$ such that 
	\[\Pr[\As(g*x_\lambda)=g:g\gets\G_\lambda]\leq\negl(\lambda)\enspace .\]
\end{assumption}

We will always assume a group action that satisfies the DLog assumption, and this assumption provides intuition for what may and may not be hard on a group action. However, the discrete log assumption will not be sufficient for justifying the security of our construction.

\begin{remark}For simplicity, we model the group actions as being deterministically computed from the security parameter. We could alternatively imagine the group actions being probabilistic, in which case they would be set up by some probabilistic procedure. The parameters would then be part of a common reference string that is supplied to all parties, including the adversary.
\end{remark}


