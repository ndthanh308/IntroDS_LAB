\chapter{Computability, Trees, and Preliminary Concepts}
\label{chap2}
% next resets the equation numbers to start at 1 at the start of the chapter
\setcounter{equation}{0}
\renewcommand{\theequation}{\thechapter.\arabic{equation}}




%------------------------------------------------------------------------------

\epigraph{The Analytical Engine has no pretensions whatever to originate anything. It can do whatever we know how to order it to performâ€¦But it is likely to exert an indirect and reciprocal influence on science itself.}{\textit{Ada Lovelace, \\ in a Letter to Charles Babbage}}

In this chapter we will present the background theory for the rest of this volume. We will give definitions, theorems, and select proofs to lay the logical and mathematical groundwork for later chapters. 

\section{Preliminaries}

We will use the following standard notation throughout this work:

\begin{definition}
We shall make use of the standard logical notation:
\begin{itemize}
\item $\forall x$ and $\exists x$ for `for all $x$' and `there exists $x$' respectively.
\item $x \wedge y$ and $x \vee y$ for logical `$x$ AND $y$' and `$x$ OR $y$' respectively.
\item In general, variables and constants will be in lower case Roman lettering: $a,b,c,x,y,z,\ldots$
\item Lower case Roman letters such as $f,g,h,s,t,\ldots$ can also be used for function names.
\item In general, sets will be in upper case Roman lettering: $X, Y, Z, \ldots$
\item We shall use $A \rightarrow B$ to denote logical implication.
\item We shall use $A \cap B$ and $A \cup B$ to denote set intersection and union of $A$ and $B$.
\item We shall use $A \setminus B$ to denote the set $A$ with any elements found in $B$ removed, the standard set-minus.
\item Greek letters $\alpha, \beta, \gamma, \ldots$ shall be used primarily for ordinals, with the exception of $\varphi$ which is used for Turing Machines.
\item We shall use $\mathbb{N}, \mathbb{Z}, \mathbb{Q}, \mathbb{R}$ to mean the natural numbers, integers, rationals, and reals respectively.
\item For a given set $A$, let $\mathcal{P}(A)$ denote the \emph{powerset} of $A$ - the set of all subsets of $A$.
\item Unless otherwise indicated, our computable functions will be of the form $f: \omega \rightarrow \omega$.
\end{itemize}
\end{definition}

\begin{definition}[Cantor Pairing Function]
We shall use the standard Cantor pairing function to represent ordered pairs $\langle x,y \rangle$ as follows: \[ \langle x,y \rangle = \frac{(x+y)(x+y+1)}{2} + y \]
\end{definition}

We will shorten the notation for ordered $n$-tuples as $\langle x_1, x_2, \ldots, x_n \rangle$, with $\langle x,y,z \rangle = \langle \langle x,y \rangle , z \rangle$, and so forth. We fix this coding for the duration of this thesis, which will serve our definition of `computable' later.

We denote the set of natural numbers by its ordinal notation $\omega$, allowing for $\mathbb{N}$ to be used where it will avoid confusion.

\section{Computability}\label{sec:Computability}\index{Computability Theory}

We will use standard definitions, using \cite{Cooper2003computability} as our main reference text.

\begin{definition}\label{def:CompRel}
Let a \emi{computable relation} $R_e \subseteq \omega \times \omega)$ be a computable relation such that for some Turing Machine $e$, $$ R(x,y) \iff (\exists y) \varphi_e(x) = y $$ 
\end{definition}

\begin{definition}[First Layer of the Arithmetical Hierarchy]\label{def:CompRel}
We define the following notation for logical complexity of formulas as follows:
\begin{itemize}
\item If for all $x \in \omega$ we have $$ x \in A \iff (\exists y)R(x,y) $$ for a computable relation $R$, then we say that $A$ is a $\Sigma^0_1$ set, or $A \in \Sigma^0_1$.
\item If for all $x \in \omega$ we have $$ x \in A \iff (\forall y)R(x,y) $$ for a computable relation $R$, then we say that $A$ is a $\Pi^0_1$ set, or $A \in \Pi^0_1$.
\item If $A \in \Sigma^0_1 \cap \Pi^0_1$ then we say that $A$ is $\Delta^0_1$, or write $A \in \Delta^0_1$.
\end{itemize}
\end{definition}

Note that we rely on alternating existential/universal quantifiers, called \emph{prenex normal form}, in the structure of our formulae to properly ascertain which layer of any hierarchy we are at. Given this arithmetical hierarchy, we will later denote the `analytic' (also called `inductive') hierarchy in the same way, with a superscript of $1$ - $\Pi^1_1$, $\Sigma^1_1$, and $\Delta^1_1$. We will also find the following definition useful:

\begin{definition}[Skolem/Herbrand Normal Form]\index{Skolem/Herbrand normal form}
In the simplest form that we require in this thesis, a function is in Skolem (Herbrand) normal form if all of the existentially (universally) quantified terms are replaced by functions that take the preceding universally (existentially) quantified variable as input.

We always begin with formulae in prenex normal form. An example of Skolemisation is taking $$\forall x \, \exists y \, \forall z \, [P(x,y,z)]$$ and producing $$\forall x \, \forall z \, [P(x,f(x),z)]$$ for some \emi{Skolem function} $f$. Likewise, Herbrandization is taking some formula $$\exists x \, \forall y \, \exists z \, [P(x,y,z)]$$ and producing some $$\exists x \, \exists z \, [P(x,g(x),z)]$$ for some \emph{Herbrand function} $g$.
\end{definition}

\subsection{Turing Machines}\label{subsec:TMs}\index{Turing Machine}

We define a Turing Machine as follows:

\begin{definition}\label{def:TM}
A \emi{Turing Machine} (abbreviated to `TM') consists of a bi-infinite row of cells called the `tape', upon which are written symbols according to a `program' $P$ held in the TM `head' that moves sequentially along the tape. A program is a set of 5-tuples of the following form: $$ ( s,q,s',q',\{ L, R \} ) $$ where $s$ and $q$ are respectively the current symbol and state, $s'$ is the symbol to be written in place of $s$, and $q'$ is the next internal state for the TM to switch to. The final item instructs the head to move left or right, denoted $L$ or $R$ respectively.
\end{definition}

Before a TM is run, we set the input in symbols on the tape, set the head at position 0, and set the internal state to the starting state denoted $q_0$. We then allow the TM to operate along the input on the tape according to its program $P$.

Let us denote $\varphi_e(x)$ as the $e^{\text{th}}$ TM, under some chosen, effective enumeration of all possible Turing Machines, acting on input $x$. We say that our computation halts if we reach the reserved halting state, after which no more computation is performed. If such a computation halts, whatever is on the tape when it halts is considered the output. If the $e^{\text{th}}$ TM halts on input $x$ with output $y$, we write this $\varphi_e(x) \downarrow = y$. Where $\varphi_e(x)$ does not halt, we write $\varphi_e(x) \uparrow$.

\begin{definition}
A function $f : \omega \rightarrow \omega$ is \emi{computable} if there exists some $e$ s.t. $f = \varphi_e$.
\end{definition}

\begin{definition}[Halting Problem]\label{def:HP}\index{halting problem}
For any given TM $\varphi_e$ and some input $x$, is there a decidable method of determining if $\varphi_e(x)$ halts?
\end{definition}

\begin{definition}
There exists a Turing machine $U$ - the \emi{Universal Turing Machine} - which if given input $(e,n)$ can simulate $\varphi_e(n)$. That is to say, $\varphi_U(e,n) = \varphi_e(n)$.
\end{definition}

Alan Turing introduced these concepts in \cite{Turing1936a}, and determined that it the Halting Problem was in fact \emph{undecidable}, meaning that there is no universal Turing Machine that can decide it.

\subsection{Enumeration in Stages}

Given the discrete way in which we formulate Turing Machines, it is natural to press `stop' every now and again and see how our computation might be going. To do this, we can talk of successive stages of a computation, and the current configuration of the Turing Machine's tape at that particular point.

\begin{definition}\label{def:stagecomp}
For any TM $\varphi_e$:
\begin{itemize}
\item Let $\varphi_{e,s} (x)$ denote the computation $\varphi_e(x)$ carried out up to stage $s$.
\item Let $C_{e,s}$ denote the bi-infinite sequence corresponding to the tape configuration of $\varphi_e(x)$ at stage $s$ of the computation.
\end{itemize}
\end{definition}

\begin{theorem}[\protect{\cite[Thm. 5.2.10]{Cooper2003computability}}]\label{thm:DownarrowThm}
For any computation $\varphi_e(x)$, $$\varphi_e(x) \downarrow \iff (\exists s) \varphi_{e,s}(x) \text{ is in the HALT state} $$
\end{theorem}

\begin{proof}
If our computation has halted, then it has managed to reach the `HALT' state in the program. This necessarily means that a finite number of steps has been carried out before we halt. Thus, $s$ exists. 
\end{proof}

This gives the following corollary immediately:

\begin{corollary}[\protect{\cite[E. 5.2.14]{Cooper2003computability}}]
For any $e$, $\{ x : (\exists s) \varphi_{e,s}(x) \downarrow \}$ is a $\Sigma^0_1$ set.
\end{corollary}

\subsection{Core Background to Computability Theory}\label{subsec:ComputabilityTheory}\index{computability theory}

Computability Theory arose out of the work of G\"{o}del, Church, Turing, Kleene, P\'{e}ter, and Post - their foundational papers are collected in \cite{Davis:2004}. A core thematic idea arising out of this study, originally called `Recursion theory', was the {\em Church-Turing Thesis} defined as follows in \cite[p.42]{Cooper2003computability}:

\begin{definition}[Church-Turing Thesis]
For a given function $f$: $$ f \text{ is effectively computable } \iff f \text{ is recursive } \iff f \text{ is Turing computable.}$$
\end{definition}

This states that any algorithm we can come up with can be performed on a Turing Machine. As Cooper points out in section 2.5 in \cite{Cooper2003computability}, this gives us the security that our intuition for computability is matched with relevant details when it is needed. 

We can extend idea of what is computable to sets and trees, which we can initiate with the following definitions.

\begin{definition}
Let $\chi_A$ denote the \emi{characteristic function} of a set $A \subseteq \omega$.
\end{definition}

\begin{definition}
A set $A$ is \emi{computable} if the characteristic function $\chi_A$ is computable.
\end{definition}

That is to say that a set $A \subseteq \omega$ is computable if there exists $e$ such that for each $x \in \omega$

$$ \varphi_e(x) = \begin{cases}
			0 	& x \notin A \\
			1 	& x \in A  
			\end{cases}$$

We can also define what it is for a set to be \emi{computably enumerable}:

\begin{definition}[Computably Enumerable Sets]
We say that a set $A$ is \emi{computably enumerable}, or \emph{c.e.}, if $A = \emptyset$ or for some computable $f$, \[ A = range(f) = \{ f(0), f(1), f(2), \ldots \} \]
\end{definition}

There is an early result due to Post (see \cite[p.72]{Cooper2003computability}):

\begin{theorem}[\protect{\cite[Thm. 5.1.5]{Cooper2003computability}}]\label{thm:comp2ce}
If $A \subseteq \omega$ is computable, then $A$ is c.e.
\end{theorem}

\begin{proof}
Let $A$ be computable. Then we have a computable characteristic function $\chi_A$ that can decide for any $x \in \omega$ the question ``$x \in A$?", meaning there is a code $i$ such that $\varphi_i = \chi_A$. 

Given this $i$, we construct a Turing Machine that contains the machine given by $i$ and recursively answers the questions ``$0 \in A$?", ``$1 \in A$?", $\ldots$ in succession. For each positive answer to ``$x \in A$?" we enumerate $x$ into $A$, giving our result.
\end{proof}

In a similar way, we can prove other basic results, such as:

\begin{theorem}[\protect{\cite[Thm. 5.1.7]{Cooper2003computability}}]
$A$ is computable if and only if both $A$ and $\overline{A}$ are c.e.
\end{theorem}

\begin{proof}
($\rightarrow$) \, This follows from \ref{thm:comp2ce} above.
\newline
($\leftarrow$) \, If both $A$ and $\overline{A}$ are computably enumerable by computable functions $f$ and $g$ respectively, then we can construct $\chi_A$ by means of a TM that for all $x \in \omega$ computes both $f(x)$ and $g(x)$. Clearly one of these will give an answer, as both sets are c.e., and so $\chi_A$ is computable.
\end{proof}

However, the inverse arguments fail, which is where computability theory starts to get much more interesting.

\begin{theorem}[\protect{\cite[Thm. 5.3.1]{Cooper2003computability}}]
There exists a computably enumerable set that is is not computable.
\end{theorem}

We first define Post's Set:
\begin{definition}[Post's Set]\index{Post's Set}\label{PostsSet}
Let $ K = \{ e : \varphi_e(e)\downarrow \} $.
\end{definition}

\begin{proof}
We first note that Post's set $K$ is $\Sigma^0_1$, and thereby computably enumerable, as $$ e \in K \iff e \in W_e \iff \exists s \, \varphi_{e,s}(e) \downarrow .$$

However, to see that $K$ is not computable, it suffices to show that $\overline{K}$ is not computably enumerable. To see this, let $\overline{K}$ be computably enumerable for contradiction. Then $K = W_i$ for some $i \in \omega$, giving $$ x \in W_i \iff x \in \overline{K} \iff x \notin K \iff x \notin W_x $$ For $x=e$ this forces a contradiction by forcing different answers for ``$j \in \overline{K}$"? and ``$j \in W_j$?" for all $j \in \omega$.
\end{proof}

\subsection{Conventional theorems in Computability}

There are two standard, and very important theorems in computability - the $s$-$m$-$n$ theorem, and the recursion theorem, which we will give brief exposition and proofs of. These statements and proofs are based on \cite{Cooper2003computability} and \cite{Soare1987}.

\begin{theorem}[$s$-$m$-$n$ Theorem, \protect{\cite[Thm. 4.2.6]{Cooper2003computability}}]\label{thm:smn}
For every $m,n \geq 1$ there exists a 1-1 computable function $s^m_n$ of $m+1$ variables, such that for all $x, y_1, y_2, \ldots y_m$: $$ \varphi^{(n)}_{s^m_n(x,y_1,y_2,\ldots,y_m)} = \lambda z_1,z_2,\ldots,z_n [ \varphi^{m+n}_x(y_1,\ldots,y_m,z_1,\ldots,z_n) ] $$
\end{theorem}

Here, the notation of $\varphi_x^y$ denotes the machine with index $x$ that takes $y$-many inputs. This theorem is the only time we shall use this notation in this thesis - later, the subscript shall be used to denote Oracle sets.

Note, here we use the standard $\lambda$-notation for the substitution of $z_1, z_2, \ldots$ into our computable function. The notation of $m$ and $n$ in $s^m_n$ denote the number of parameters into the computable function $s$.

\begin{proof}[Proof sketch]
For $m=n=1$, let the TM $\varphi_{s^1_1(x,y)}(z)$ obtain $\varphi_x$, and then apply $\varphi_x(y,z)$. Such an $s = s^1_1$ is computable, as it is some effective procedure on $x$ and $y$. If it is not 1-1, then we can make it so by `padding' the process, and then letting the resultant $s'$ be s.t. $\varphi_{s(x,y)} = \varphi_{s'(x,y)}$, ordering our inputs $\langle x,y \rangle$ using a standard pairing function.
\end{proof}

\begin{theorem}[Kleene's Recursion Theorem, \protect{\cite[Thm. 4.4.1]{Cooper2003computability}}]\label{thm:recursion}
For every computable function $f$ there exists an $n$ - called the \emi{fixed point} of $f$ - s.t. \[ \varphi_n = \varphi_{f(n)} \]
\end{theorem}

\begin{proof}
Define the `diagonal' function $d(u)$ as follows: 
\[ \varphi_{d(u)} = 
\begin{cases}
	\varphi_{\varphi_u(u)} & \text{if } \varphi_u(u)\downarrow \\
	\uparrow & \text{otherwise}
\end{cases} \]

Note that by \ref{thm:smn}, $d(u)$ is 1-1 and total. $d$ is also independent of the $f$ that we are interested in.

For such a given $f$, let $i$ be the index given by \[ \varphi_i = f \circ d \]

\underline{Claim:} We claim that $n = d(i)$ is some fixed point for $f$. 

Note that, $f$ gives that $\varphi_i$ is total (as $d$ is total, above), so $\varphi_{d(i)} = \varphi_{\varphi_i(i)}$. Thus our result follows from the following equivalences: \[ \varphi_n = \varphi_{d(i)} = \varphi_{\varphi_i(i)} = \varphi_{fd(i)} = \varphi_{f(n)} \]
\end{proof}

In the previous proof, we constructed a function we described as \emph{diagonal}. Let \emi{diagonalization}, the construction of a diagonal function, be as follows: let $e$ be the index of $\varphi_e$, which we diagonalise $e$ by running $\varphi_e(e)$. 

This technique was first introduced by G\"odel in \cite{godel31} to give us unprovable statements, and was later used by Turing in \cite{Turing1936a} in relation to proving the non-computability of the halting problem. The set of \emph{Diagonally Non-Recursive} functions, or \emi{DNR}, is composed of all the computable functions $f$ such that $f(e) \neq \varphi_e(e)$ for all $e$, and is the subject of current study in modern mathematical logic. A thorough introduction and treatment can be found in \cite{Hirschfeldt2014}. 

We can also note that the numbers for which $\varphi_n = \varphi_{f(n)}$ need not be unique for any given $f$. 

\subsection{Computable Notions of Reducibility}

In speaking about computability, we often want to relativise two sets between each other. To do this, we will need the following definitions. We will begin with a more basic form of reducibility, called $m$-reducibility. This is defined in \cite{Cooper2003computability} as follows:

\begin{definition}[$m$-Reducibility]\label{def:mred}
Given set $A$ and $B$, we say that $A$ is \emi{$m$-reducible} to $B$, written $A \leq_m B$, if there is a computable function $f : \omega \rightarrow \omega$ such that for all $x \in \omega$: \[ x \in A \iff f(x) \in B \] If our function $f$ is injective, we say that $A$ is \emi{1-reducible} to $B$, written $A \leq_1 B$.
\end{definition}

Although $m$-reducibility was introduced \emph{after} Turing reducibility (see \ref{def:Turingred} below), it is a slightly easier-to-formulate version of reducibility between two sets. Cooper in \cite[p.103]{Cooper2003computability} gives the intuition for $m$-reducibility as $A$ being in some sense ``at least as computable" as $B$. 

From the definition \ref{def:mred} above, we can derive that \[ A \leq_m B \iff \overline{A} \leq_m \overline{B} \] which follows from the fact that $A = f^{-1}(B)$, and following from a general fact about pre-images we get that $\overline{A} = f^{-1}(\overline{B})$

Additionally, we can prove relatively straightforward theorems that give a good flavour of how theorems around $m$-reducibility are carried out:

\begin{theorem}[\protect{\cite[Thm. 7.1.2]{Cooper2003computability}}]
The ordering $\leq_m$ is:
\begin{enumerate}
\item reflexive.
\item transitive.
\item if $A \leq_m B$ and $B$ is computable, then $A$ is computable.
\item if $A \leq_m B$ and $B$ is c.e., then $A$ is c.e.
\end{enumerate}
\end{theorem}

\begin{proof}
\item
\textbf{1. - Reflexive} Clearly $A \leq_m A$ as for all $x$, $f(x) = x$ is computable. \qed 
\newline
\textbf{2. - Transitive} Let $A \leq_m B$ be given by $f$, and $B \leq_m C$ be given by $g$. We can get $A \leq_m C$ by \[ x \in A \iff f(x) \in B \iff g(f(x)) \in C \] so $A \leq_m C$ by $g \circ f$. \qed
\newline
For the next two proofs, let $A \leq_m B$ by a computable $f$. \newline
\textbf{3.} If $B$ is computable, then $\chi_A = \chi_B \circ f$, which is computable. \qed
\newline
\textbf{4.} Let $B \in \Sigma^0_1$, with $$x \in B \iff \exists y R(x,y)$$ for a computable relation $R$. Then $$x \in A \iff \exists y R(f(x), y)$$ giving us immediately that $A \in \Sigma^0_1$ also.
\end{proof}

Following on from these normal forms, we can prove that not just computable sets are $\Sigma^0_1$, but also computably enumerable sets are $\Sigma^0_1$ complete. This important intuition will be complimented by successive results in later sections.

\begin{theorem}[\protect{\cite[Thm. 5.1.5]{Cooper2003computability}}]
The following are equivalent:
\begin{enumerate}
\item $A$ is c.e.,
\item $A \in \Sigma^0_1$.
\end{enumerate}
\end{theorem}

\begin{proof}
\item
\textbf{$1 \rightarrow 2$} Let $A$ be c.e. - if $A = \emptyset$, then $x \in A \iff \exists x (x = x+1)$. Let $A = range(f)$ for some computable function $f$. Then \[ x \in A \iff \exists s (f(s) = x) \] where $f$ is now a computable relation between $s$ and $x$. 
\newline
\textbf{$2 \rightarrow 1$} Let $A \in \Sigma^0_1$ such that there is a computable $R$ giving \[ \exists y R(x,y) \iff x \in A \] we then construct a TM $e$ such that on input $y$, it will search through all possible $x \in \omega$ and $R(x,y)$ (computable) with the following outcomes:
$$ \varphi_e(y) = 
\begin{cases}
	x & \text{if } R(x,y) \\
	\uparrow & \text{otherwise}
\end{cases} $$
	
Thus, $ (\exists x) \varphi_e(y) = x \iff x \in A$ with $A$ also being c.e.
\end{proof}

\subsection{Turing Reducibility and the Jump Operator}

Although $m$-reducibility is incredibly useful, we can generalise it to a notion of \emph{Turing reducibility} by means of the following definitions - first proposed by Turing in 1939, but following the outline in \cite{Cooper2003computability}.

\begin{definition}[Oracle Turing Machines]
We define an \emi{oracle Turing machine} to be a normal Turing machine, but with access to an extra tape - called the \emi{oracle} - and makes use of \emph{query quadruples} $(q_i, S_k, q_j, q_k)$ that allow the Turing machine to behave as follows. Let $\varphi_e^A(x)$ be the $e^{th}$ TM on input $x$ and oracle $A$:
\begin{itemize}
\item The TM computes as before until it encounters a query quadruple.
\item The TM, then in state $q_i$, will read the current value on the work tape, call it $n$, and then query the oracle tape to ask $\text{is } n \in A?$.
\item Depending on the output of the query, the TM will then:
\begin{itemize}
\item State $q_j$ if $n \in A$.
\item State $q_k$ if $n \notin A$.
\end{itemize}
\end{itemize}
\end{definition}

Note, this definition does not require our oracle sets to be computable nor enumerable - just that they are there. In fact, it is explicitly why oracle Turing Machines were introduced - in order to analyse questions like ``is the halting problem all there is?'' Essentially, we can now ask ``What can we compute knowing the characteristic function of a, not necessarily computable, set $A$?" This breakthrough from Turing allowed us to reason about problems `beyond' the halting problem, by talking about \emi{Turing reducibility}.

\begin{definition}[Turing Reducibility]\label{def:Turingred}
We say that a set $A$ is \emi{Turing reducible} to a set $B$, written $A \leq_T B$ if for some $e$, $$\chi_A = \varphi_e^B$$.
\end{definition}

It is worth noting, however, that Turing reducibility is finer than $m$-reducibility, as evidenced by the following result:

\begin{theorem}[\protect{\cite[Thm. 4.2.6]{Cooper2003computability}}]
There exists $A$ and $B$ s.t. $A \leq_T B$ but $A \nleq_m B$.
\end{theorem}

\begin{proof}
Consider $C$ a non-computable computably enumerable set, with $\overline{C}$ its compliment. It is clear that $$ C \leq_T \overline{C} $$ but as $C$ is non-computable, we also have that $$ C \nleq_m \overline{C} $$
\end{proof}

The outcome of Turing's work was the Turing hierarchy, which is defined by taking successive `jumps' which we define as follows.

\begin{definition}
Let $A, B$ be given sets:
\begin{itemize}
\item We write $A \equiv_T B$ if $A \leq_T B$ and $B \leq_T A$.
\item We define the \emi{Turing degree} - also called the \emph{degree of unsolvability} - for some $A \subseteq \omega$ to be \[ deg(A) =_{def} \{ X \subseteq \omega : X \equiv_T  A \} \] 
\item We can write $\boldsymbol{\mathcal{D}}$ for the collection of all such degrees, and can define the partial ordering $\leq$ on $\boldsymbol{\mathcal{D}}$ induced by $\leq_T$ as: \[ deg(B) \leq deg(A) \Longleftrightarrow_{def} B \leq_T A \]
\end{itemize}
\end{definition}

It follows from this and some other results that three is in fact a partial order on $\mathcal{D}$, however this is beyond the scope of this thesis. Returning to Post's set, $K$, we state the following theorems - omitting proofs that can be found in \cite{Cooper2003computability}. 

\begin{definition}
For $n,e \in \omega$, let $HALT = { (n,e) : \varphi_e(n)\downarrow}$.
\end{definition}

\begin{theorem}[\protect{\cite[Thm. 5.3.1]{Cooper2003computability}}]
$$ HALT \leq_T K $$
\end{theorem}

Thus, $K$ is incomputable, and so things that $K$ reduces to are also necessarily incomputable. We also need the following idea of \emph{index sets}.

\begin{definition}
Let $\mathcal{A}$ be a set of partial computable functions - or of computably enumerable sets. The \emi{index set} of $\mathcal{A}$ is then the set $A$ of all the indices of elements of $\mathcal{A}$.
\end{definition}

\begin{theorem}[Rice's Theorem, \protect{\cite[Thm. 7.1.11]{Cooper2003computability}}]\index{Rice's theorem}
If $A$ is an index set - with $A \neq \emptyset$ and $A \neq \omega$ - then $K \leq_m A$ or $K \leq_m \overline{A}$. 
\end{theorem}

This result gives us the following corollary:

\begin{corollary}[\protect{\cite[Cor. 7.1.12]{Cooper2003computability}}]
Every non-trivial index set is incomputable.
\end{corollary}

This gives us a window into the core intuition behind Rice's important result on computable functions - that every non-trivial semantic property is fundamentally undecidable, by means of $m$-reducibility of $K$ into index sets.

\section{Computable Trees}

We denote Cantor space by $2^{\omega}$, and Baire space by $\omega^{\omega}$. For any alphabet $\Sigma$, we denote the set of strings $\sigma = (\sigma(0), \sigma(1), \ldots, \sigma(n-1))$ of length $n$ by $\Sigma^n$. We denote the set of arbitrary length finite strings by $\Sigma^{< \omega}$, and similarly for Cantor space we use $2^{< \omega}$, and for Baire space we shall use $\omega^{< \omega}$.

Let $|\sigma |$ denote the length of the string $\sigma \in \Sigma^{< \omega}$. We denote the initial segment of $\sigma$ of length $n$ by $\sigma \upharpoonright n$. For $\sigma$ and $\tau$, where $| \sigma | = i$ and $| \tau | = j$, we write $\sigma^{\frown} \tau$ for the string $(\sigma(0), \sigma(1), \ldots \sigma(i-1), \tau(0), \tau(1), \ldots, \tau(j-1))$, which we call the \emi{concatenation} of $\sigma$ and $\tau$. We write $\tau \prec \sigma$ if $\tau$ is an \emi{initial segment}, or \emi{initial substring}, of $\sigma$ - that is, there is some $n < | \sigma |$ such that for all $0 \leq i \leq n$ it holds that $\tau(i) = \sigma(i)$.

\subsection{Trees and $\Pi^0_1$ Classes}

The source for this section is Cenzer's chapter titled ``$\Pi^0_1$ Classes in Computability Theory" in \cite{Cenzer-griffor1999handbook}. 

\begin{definition}\label{def:trees}
A \emi{tree} is a set $T \subset \Sigma^{< \omega}$ that is closed under initial segments. That is, for all $\tau \in \Sigma^{< \omega}$ such that $|\tau| \leq |\sigma |$ it is true that $ \forall \sigma \in T \, (\tau \prec \sigma \rightarrow \tau \in T)$.
\end{definition}

We say that $\sigma$ is a {\em successor} to some $\tau \in T$ if there exists some $s \in \Sigma^{< \omega}$ s.t. $\sigma = \tau^{\frown} s$. If $\sigma \in T$ is a successor of some $\tau \in T$ and $| \sigma | = | \tau | + 1$ we say that $\sigma$ is an \emi{immediate successor} of $\tau$. 

\begin{definition}
We say that a tree $T$ is \emi{finitely branching} if for every $\tau \in T$ there are finitely many immediate successors in $T$.
\end{definition}

For every $T \subset 2^{< \omega}$ or $T \subset \Sigma^{< \omega}$ (for a finite alphabet $\Sigma$), $T$ can only be finitely branching.

\begin{definition}
We will make use of the following definitions for paths through a tree $T$:
\begin{itemize}
\item An \emi{infinite path} through $T$ is a sequence $(x(0), x(1), \ldots)$ such that $x \upharpoonright n \in T$ for all $n \in \omega$.
\item Denote by $[T]$ the set of infinite paths through $T$.
\end{itemize}
\end{definition}

We also state what it is for a set to be a $\Pi^0_1$ class, which is congruent with earlier definitions of $\Pi^0_1$ sets we stated earlier.

\begin{definition}\index{$\Pi^0_1$ Classes}
\begin{itemize}
\item A formula is $\Delta_0$ if it is a primitive recursive function.
\item A set $X \subset \omega^{\omega}$ is a $\Pi^0_1$ class if there is a $\Delta_0$ formula $\varphi(n,x)$ in the language of first order arithmetic such that $ x \in X \iff (\forall n) \varphi(n,x)$.
\end{itemize}
\end{definition}

A definition of Primitive Recursive Functions as well as other definitions we use here can be found in Cooper \cite[Sec. 2.1 p.12]{Cooper2003computability}.

The $\Pi^0_1$ classes may be described topologically as effectively closed subsets of the product space $\omega^{\omega}$. Early results in the study of $\Pi^0_1$ classes were carried out by Kleene, who proved the Kleene basis theorem in 1943. Further work was carried out by Kreisel, Shoenfield, Jockush, Soare, \etal.

The topology on Baire space, $\omega^{\omega}$ is determined by a basis of intervals given by $I(\sigma) = \{ x : \sigma \prec x \} $. A subset $P \subset \omega^{\omega}$ is closed iff $P = [T]$ for some tree $T$, hence our description of $\Pi^0_1$ classes as effectively closed subsets of Baire space.

Note that each interval given by $I$ is also closed, thus we can describe the intervals as \emi{clopen}. Note also that for Cantor space, $2^{\omega}$, the clopen sets are just the finite unions of intervals. 

Given these definitions we can state the core intuition for a $\Pi^0_1$ class as a tree in terms of some fixed initial segment $\sigma$ for which the $\Pi^0_1$ class is the set of points that are all possible extensions of $\sigma$ - the cone of extensions above this fixed initial segment.

We now wish to formalise the relationship between $\Pi^0_1$ classes and trees by means of the following Lemma: 

\begin{lemma}[\protect{\cite[p.41,Lem. 1.1]{Cenzer-griffor1999handbook}}]\label{lemma:trees-rec-rels}
For any class $P \subset \omega^{\omega}$, the following are equivalent:
\begin{enumerate}
\item $P = [T]$ for some computable tree $T \subset \omega^{< \omega}$.
\item $P = [T]$ for some primitive recursive tree $T$.
\item $P = \{ x : \forall n (R(n,x) )\}$ for some computable relation $R_e$,
\item $P = [T]$ for some $\Pi^0_1$ tree $T \subset \omega^{< \omega}$.
\end{enumerate}
\end{lemma}

Recall our definitions of computable relation (definition \ref{def:ArithH}) and tree (definition \ref{def:trees}) above.

\begin{proof}
A proof of this can be found in \cite[p.41]{Cenzer-griffor1999handbook}.
	%\mc{TODO Griffor (Cenzer) p.41}
\end{proof}


Armed with this characterisation, we can equate the enumeration of computable trees with effectively enumerated $\Pi^0_1$ classes, as demonstrated in the following lemma.

\begin{lemma}[\protect{\cite[p.41,Lem. 1.2]{Cenzer-griffor1999handbook}}]
There is a uniformly recursive sequence $T_e$ of primitive recursive trees such that, for every $\Pi^0_1$ class $P$, there is some $e$ such that it holds that $$P = [T_e]$$
\end{lemma}

\begin{proof}
Let $\pi_0, \pi_1, \ldots$ be a recursive enumeration of the primitive recursive functions such that $\pi_i : \omega \rightarrow \{ 0,1 \}$. Define the $e^{th}$ such tree by \[ \sigma \in T_e \iff (\forall \tau \preceq \sigma) \pi_e(\langle \tau \rangle_n ) = 1 \] where $\langle \tau \rangle_n = \langle n, (\tau(0), \tau(1),\ldots,\tau(n-1)) \rangle$.

$T_e$ is a tree, and if $T$ is a primitive recursive tree with characteristic function $\pi_e$, then $T = T_e$. By lemma \ref{lemma:trees-rec-rels}, every $\Pi^0_1$ class is thereby equal to one of the $[T_e]$. 
\end{proof}

\section{Kleene's $\mathcal{O}$ and $\Pi^1_1$-Completeness}

In this section we will outline results that give the relationship between well-founded trees and $\Sigma^1_1$-completeness. Our preliminary definitions are as follows.

Unless otherwise stated, the material in this section is based on \cite{Cooper2003computability} and \cite{sacks_2017}. 

\begin{definition}[Ordinal]\label{def:ordinal}
We define ordinals as follows:
\begin{itemize}
\item A \emi{totally ordered set} is a set $A$ with a relation $\leq$ such that the following hold:
\begin{itemize}
\item (Reflexivity) $\forall a \in A (a \leq a)$
\item (Antisymmetry) $(a \leq b \wedge b \leq a) \rightarrow a = b$
\item (Transitivity) $(a \leq b \wedge b \leq c) \rightarrow a \leq c$
\item (Comparability) $\forall a,b \in A (a \leq b \vee b \leq a)$
\end{itemize}
\item A \emi{well-ordered set} is a totally ordered set $A$ together with a relation $\leq$ such that every subset $S \subseteq A$ has a least element.
\item Two sets $A, B \subseteq \omega$ are said to be \emi{order isomorphic} iff there exists a bijection $f:A \rightarrow B$ between $A$ and $B$ such that for all $a_1, a_2 \in A$ \[ a_1 \leq a_2 \iff f(a_1) \leq f(a_2) \]
\item Two well-ordered sets $A,B \subseteq \omega$ have the same \emi{order type} iff they are order isomorphic.
\item An \emph{ordinal number} or \emi{ordinal} (in the language due to Cantor) is just an order type of some well-ordered set.
\end{itemize}
\end{definition}

\textbf{NB} - later, in definition \ref{def:well-ord}, we will formalise the difference between a totally-ordered and well-ordered set. Specifically that the well-foundedness of such as set forces the relation to be irreflexive and connected.

\begin{definition}[\bf{Ord}]
We denote the set of all ordinals - that is, the set of every possible order type - as \textbf{Ord}.
\end{definition}

We now have all the basic machinery we need to describe the computable, or recursive ordinals.

\subsection{Ordinal Notations and Kleene's $\mathcal{O}$}

The aim of Kleene's construction is to analyse the structure of the computable ordinals, by means of creating representations of each as natural numbers.

The resulting theory identified that the computable ordinals form an initial segment of \textbf{Ord}, sitting strictly below the least non-computable ordinal, which we shall call the \emph{Church-Kleene ordinal}, denoted $\omega_1^{CK}$.

We will begin this journey into categorising and enumerating the computable ordinals by first defining a way of formulating \emph{notations} for the ordinals. The core idea here is that we can construct things that represent ordinals - including successor ordinals and limit ordinals - but in a way that can be more easily manipulated and understood for our present purposes. 

\begin{definition}[Ordinal Notation Ordering]\index{ordinal notations}
We first define the ordering $<_\mathcal{O}$:
\begin{itemize}
\item If $x$ and $y$ are both notations for constructive ordinals, then let $x <_\mathcal{O} y$ be for ``$x$ is less than $y$ according to the ordering of notations."
\item Given an ordinal can have two different notations, $<_\mathcal{O}$ is not linear.
\end{itemize}
\end{definition}

We can regard $x <_\mathcal{O} y$ as a set of ordered pairs - thus it is the closure of a finite set $X$ under some $\Sigma^1_1$-closure condition $A(X)$ we we define below.

\begin{definition}
Let $X$ be a finite set, the closure condition $A(X)$ has three clauses:
\begin{enumerate}
\item $\forall u,v (\langle u,v \rangle \in X \rightarrow \langle v, 2^v \rangle \in X )$ (Successors)
\item $\forall n (\varphi_e(n) \downarrow \wedge \langle \varphi_e(n) , \varphi_e(n+1) \rangle \in X) \rightarrow \forall n ( \langle \varphi_e(n), 3 \cdot 5^e \rangle \in X)$ (Limits)
\item $\forall u,v,w (\langle u,v \rangle, \langle v,w \rangle \in X \rightarrow \langle u,w \rangle \in X) $ (Transitivity)
\end{enumerate}
\end{definition}

Thus, there is some least $X$ such that $\langle 1,2 \rangle \in X$, with $A(X)$. We let $<_\mathcal{O}$ be this least such $X$. 

\subsection{Kleene's $\mathcal{O}$}

We can now define Kleene's $\mathcal{O}$ as follows:

\begin{definition}[Kleene's $\mathcal{O}$]
Let $\mathcal{O}$ denote the set of notations for constructive ordinals. $\mathcal{O}$ forms the field of $<_\mathcal{O}$.
\end{definition}

We will use the following definition of notations, noting that they are all defined recursively for future purposes.

\begin{definition}
Let the function $| \cdot | : \mathcal{O} \rightarrow \text{\textbf{Ord}}$ be defined by transfinite recursion on $<_\mathcal{O}$ as follows:
\begin{align*}  |1| & =  0 \\
| 2^u | & =  |u| + 1 \\
| 3 \cdot 5^e | & = \lim_{n\to\infty} | \varphi_e(n) |
\end{align*}
\end{definition}

We can now define all of the constructive ordinals in the following manner.

\begin{definition}[Constructive Ordinals]
An ordinal $\delta \in \text{\textbf{Ord}}$ is a \emi{constructive ordinal} if $\delta = u$ for some $u \in \mathcal{O}$. 
\end{definition}


\subsection{Kleene's $\mathcal{O}$, and Well-foundedness}

We define well-foundedness as follows: 

\begin{definition}[Well-founded relations]\label{def:well-fdd}
A binary relation $R$ is \emi{well-founded} if there is no $f$ s.t. \[ \forall x (R(f(x+1),f(x)) \]
\end{definition}

We are now ready for the following theorem:

\begin{theorem}[\protect{\cite[Thm. 2.2]{sacks_2017}}]
\begin{enumerate}
\item $<_\mathcal{O}$ and $\mathcal{O}$ are $\Pi^1_1$
\item $<_\mathcal{O}$ is a well-founded partial ordering.
\item For $v \in \mathcal{O}$, the restriction of $<_\mathcal{O}$ to $\{ u | u <_\mathcal{O} v \}$ is linear.
\end{enumerate}	
\end{theorem}

Our proof comes directly from \cite{sacks_2017}.

\begin{proof}
\textbf{1.} A full proof of 1. can be found in \cite[p.9]{sacks_2017}
\newline
\textbf{2.} The following \emi{natural enumeration} of $<_\mathcal{O}$ is equivalent to a redefinition of $<_\mathcal{O}$ by means of transfinite recursion on ordinals, as follows:
\begin{itemize}
\item \textbf{Stage 0}: enumerate $1 <_\mathcal{O} 2$.
\item \textbf{Stage $\delta + 1$}: enumerate all $v <_\mathcal{O} 2^v$ and $u <_\mathcal{O} 2^v$ if $u <_\mathcal{O} v$ was enumerated at stage $\delta$.
\item \textbf{Stage $\lambda$ (limit)}: enumerate $\varphi_e(n) <_\mathcal{O} 3 \cdot 5^e$ and $u <_\mathcal{O} 3 \cdot 5^e$, if not enumerated at some earlier stage, if for each $n$ it holds that $\varphi_e(n) <_\mathcal{O} \varphi_e(n+1)$ was enumerated at an earlier stage, and if for some $n,u <_\mathcal{O} \varphi_e(n)$ was also enumerated at an earlier stage.
\end{itemize}

By induction on each stage $\gamma$, a pair enumerated at some stage $\gamma$ belongs to $<_\mathcal{O}$. On the other hand, the set of all pairs enumerated into $<_\mathcal{O}$ is a solution of $A(X)$, and so contains $<_\mathcal{O}$. 

By induction on $u <_\mathcal{O} v$ and $v <_\mathcal{O} w$, then $u <_\mathcal{O} v$ is enumerated at an earlier stage than $v <_\mathcal{O} w$. It then follows that $<_\mathcal{O}$ is well-founded, else there would otherwise be a descending infinite sequence of ordinals.

\leavevmode\\ \textbf{3.}
We prove this by induction on $<_\mathcal{O}$. Assume $u_1, u_2 <_\mathcal{O} v$, we check that one of the following hold:
\begin{itemize}
\item $u_1 <_\mathcal{O} u_2$,
\item $u_1 = u_2$, or
\item $u_2 <_\mathcal{O} u_1$.
\end{itemize}

If $v = 2^u$, then (1) above implies that $u_1, u_2 \leq_\mathcal{O} u$ and our result follows by induction. Else, if $v = 3 \cdot 5^e$, then we apply (2) to get the result.
\end{proof}
We can now prove the following facts about ordinal notations and their addition:

\begin{definition}\label{def:recI}
\begin{itemize}
\item Let $+_\mathcal{O}$ be such that if $a,b \in \mathcal{O}$, then $a +_\mathcal{O} b \in \mathcal{O}$ and $$|a +_\mathcal{O} b | = |a| + |b| $$
\item Let $h$ be a recursive function such that $$ \varphi_{h(e,a,d)} \simeq \varphi_e(a, \varphi_d(n)) $$
\item Let $I$ be a recursive function such that
\begin{align*}
a & \text{  if } b = 1 \\
\varphi_{I(e)}(a,b) \simeq 2^{\varphi_e(a,m)} & \text{  if } b = 2^m \\
3 \cdot 5^{h(e,a,d)} & \text{  if } b = 3 \cdot 5^d \\
7 & \text{  otherwise}
\end{align*}
\end{itemize}
\end{definition}

It is worth noting that, because our breaking up of $\mathcal{O}$ into notations for zero, successors, and limits is effective, $I$ above is recursive, even though $<_\mathcal{O}$ is non-recursive. Also, the clause for $I(e)$ is sensible even if $a,b \notin \mathcal{O}$.

\begin{theorem}[Kleene, \protect{\cite[Thm. 3.4]{sacks_2017}}]
The recursive function $+_\mathcal{O}$ has the following properties. For all $a$, and $b$:
\begin{enumerate}
\item $a,b \in \mathcal{O} \iff a +_\mathcal{O} b \in \mathcal{O}$.
\item $a,b \in \mathcal{O} \Rightarrow | a +_\mathcal{O} b | = |a| + |b|$.
\item $a,b \in \mathcal{O} \wedge b \neq 1 \Rightarrow a <_\mathcal{O} (a +_\mathcal{O} b)$.
\item $a \in \mathcal{O} \wedge c <_\mathcal{O} b \iff (a +_\mathcal{O} c ) <_\mathcal{O} (a +_\mathcal{O} b)$.
\item $a \in \mathcal{O} \wedge b=c \in \mathcal{O} \iff (a +_\mathcal{O} b) = (a +_\mathcal{O} c)$.
\end{enumerate}
\end{theorem}

\begin{proof}
Can be found in Sacks \cite{sacks_2017} I.3.4 p.13.
\end{proof}

Due to our computable approach, and the fact that our notations for ordinals are, in particular, very computable, we can get theorems such as the following:

\begin{definition}
Denote by $W_e$ the $e^{th}$ computably enumerable subset of $\omega$, the domain of $\varphi_e$.
\end{definition}

The intuition here is that $W_e$ is the `set of inputs that $\varphi_e$ halts on' - which is why we use the domain of $\varphi_e$ in our definition.

\begin{theorem}[Kleene, \protect{\cite[Thm. 3.5]{sacks_2017}}]\label{thm:pinit}
There exists a computable function $p$ such that for all $b \in \mathcal{O}$, $$W_{p(b)} = \{ a : a \leq_\mathcal{O} b \} $$
\end{theorem}

\begin{proof}
The required properties of $p$ are as follows:
\begin{align*}
	W_{p(1)} & = \emptyset \\ 
	W_{p(2^a)} & = \{a\} \cup W_{p(a)} \numberthis \label{C2:Eq1} \\
	W_{p(3 \cdot 5^d)} & = \bigcup\limits_{n \in \omega} \{ W_{p(\varphi_d(n))} : \varphi_d(n)\downarrow \} 
\end{align*}

By induction on $<_\mathcal{O}$ we get that any $p$ that satisfies all of \ref{C2:Eq1} will also satisfy our theorem. As such, we want to show the existence of such a computable $p$, specifically by means of effective transfinite recursion on $p$. Let $e_0$ be any G\"odel number for some TM, and let $i$ and $j$ be computable functions such that:
\begin{align*}
	W_{e_0} & = \emptyset \\
	W_{i(e,a)} & = \{a\} \cup W_{\varphi_e(a)} \numberthis \label{C2:Eq2} \\
	W_{j(e,d)} & = \bigcup\limits_{n \in \omega} \{ W_{\varphi_e(\varphi_d(n))} : n < \omega \}
\end{align*}

In \ref{C2:Eq2}, it is intended that when $\varphi_e(a) \uparrow$, that $W_{\varphi_e(a)} = W_{\varphi_e(\varphi_d(n))} = \emptyset$. We can now obtain a recursive $I$ (similar to \ref{def:recI} above) such that:
\begin{align*}
e_0 & \text{  if } b = 1 \\
\varphi_{I(e)}(b) \simeq i(e,a) & \text{  if } b = 2^a \\
j(e,d) & \text{  if } b = 3 \cdot 5^d \\
0 & \text{  otherwise}
\end{align*}

By theorem \ref{thm:recursion}, the fixed point theorem, $I$ necessarily has a fixed point $c$ where $\varphi_{I(c)} \simeq \varphi_c$. Let $p(b)$ be $\varphi_c(b)$. Then
\begin{align*}
e_0 & \text{  if } b = 1 \\
p(b) = i(e,a) & \text{  if } b = 2^a \\
j(e,d) & \text{  if } b = 3 \cdot 5^d \\
0 & \text{  otherwise}
\end{align*}

Given $i$ and $j$ are both computable and total, we get that \ref{C2:Eq2}$\rightarrow$\ref{C2:Eq1}.
\end{proof}
We are also able to obtain the existence of similar recursive functions:
\begin{theorem}[Kleene, \protect{\cite[Thm. 3.5]{sacks_2017}}]\label{thm:Kleeneq}
There exists a recursive function $q$ such that for all $b \in \mathcal{O}$, $$W_{q(b)} = \{ \langle x,y \rangle : x <_\mathcal{O} y <_\mathcal{O} b \} $$
\end{theorem}

\begin{proof}
Essentially the same as for the proof of theorem \ref{thm:pinit}, with the modification that we adjust the definition \ref{C2:Eq1} and \ref{C2:Eq2} preserve all of the pairs $\langle x,y \rangle$ s.t. $x <_\mathcal{O} y <_\mathcal{O} a$ in our recursive definition of $i$.
\end{proof}

\subsection{Recursive Ordinals and well-founded Relations}

We can now show that every c.e. subset of $\mathcal{O}$ is bounded in a ``highly effective manner."\cite[p.15]{sacks_2017} 

\begin{theorem}[\protect{\cite[Lem. 4.1]{sacks_2017}}]
There exists a computable $g$ such that for all $e$:
\begin{enumerate}
	\item $g(e) \in \mathcal{O} \iff W_e \subseteq \mathcal{O}$,
	\item $g(e) \in \mathcal{O} \Rightarrow |a| < |g(e)| \text{ for all } a \in W_e$.
\end{enumerate}
\end{theorem}

\begin{proof}
A proof can be found in Sacks \cite{sacks_2017} p.16.
\end{proof}

We now formalize our definition \ref{def:ordinal}.

\begin{definition}\label{def:well-ord}
A binary relation $R(x,y)$ is a \emi{well-ordering} if it is:
\begin{enumerate}
\item (Connected) $(\forall x,y) ( R(x,y) \vee R(y,x) \vee x=y )$
\item (Transitive) $(\forall x,y,z) ( R(x,y) \wedge R(y,z) \rightarrow R(x,z) )$
\item (well-founded) if $S \neq \emptyset$, $S$ is a subset of the field of $R$, then $\exists y \in S$ such that $(\forall x \in S) \neg R(x,y)$
\\ Note, that 3. implies:
\item (Irreflexive) $(\exists x) \neg R(x,x)$
\item (Antisymmetric) $(\forall x,y) (R(x,y) \rightarrow R(y,x))$
\end{enumerate}
\end{definition}

Given the well-foundedness of a well-ordering relation, we can define the \emi{height} of $R$ as follows:

\begin{definition}
\begin{itemize}
\item Let $R$ be a well-founded binary relation, then it has a height, denoted by $|R|$, measured by some ordinal. 
\item Let $\beta$ be an ordinal variable. $\mu \beta$ is then the ``least $\beta$ such that..."
\item $|x| = \mu \beta \, [ R(y,x) \rightarrow |y| < \beta]$
\item $|R| = \mu \beta \, \forall x \, [ x \in \text{ field of } R \rightarrow |x| < \beta ]$
\end{itemize}
\end{definition}

We can also enumerate computable relations:

\begin{definition}
Let $R_e$ denote $R_e(x,y) \iff \varphi_e(x,y)$.
\end{definition}

Thus, we can enumerate all computable relations. We shall let $$\textbf{Rel}=\{ R_e : e < \omega \}$$

\begin{lemma}[\protect{\cite[Lem. 4.3]{sacks_2017}}]\label{lemma:Rwellfdd}
There exists a computable $f$ such that, for all $e$:
\begin{itemize}
	\item $R_e \text{ is well-founded } \iff f(e) \in \mathcal{O}$, and
	\item $R_e \text{ is well-founded } \rightarrow |R_e| \leq |f(e)|$
\end{itemize}
\end{lemma}

This lemma gives rise to the following theorem due to Kleene and Markwald:

\begin{theorem}[Kleene-Markwald, \protect{\cite[Thm. 4.4]{sacks_2017}}]
The computable ordinals are equal to the constructive ordinals.
\end{theorem}

\begin{proof}
A proof can be found in Sacks \cite{sacks_2017} p. 18.
\end{proof}

\subsection{$\mathcal{O}$, Well-foundedness, and $\Pi^1_1$ Sets}

In this subsection, we will build on our theory and present the ordinal analysis of $\Pi^1_1$ Sets.

\begin{definition}
Let $\overline{f}(x) = \{ \langle i, f(i) \rangle : i < x \}$, essentially that, for $p_i$ being the $i^{th}$ prime, $p_0 = 2$: $$ \overline{f}(x) = \prod\limits_{i < x} p_i^{1+f(i)} $$ If $y = \overline{f}(x)$ for some $f$ and $x$, we say that $y$ is a \emi{sequence number}.
\end{definition}

This $\overline{f}(x)$ can be thought of as the code for the graph of $f \upharpoonright x$ - essentially, it is the code for the sequence $\langle f(0), f(1), \ldots, f(x-1) \rangle$, with $f(0) = 1$. We can denote the length of $x$ as $len(\overline{f}(x))$. We can thus view $y$ as $\langle y_0, y_1, \ldots , y_{len(y)-1} \rangle$.

If $y$ and $z$ are both sequence numbers, then we say that `$y$ is \emi{properly extended} by $z$', written $y \prec_{seq} z$ if $len(y) < len(z)$ and for all $i < len(y)$ we have that $y_i = z_i$.

\begin{definition}
Let \textbf{Seq} denote the set of all sequence numbers.
\end{definition}

\textbf{Seq} is a computable set, and $\prec_{seq}$ is a computable, antisymmetric, transitive binary relation. We can think of $(\textbf{Seq},\prec_{seq})$ as presenting Baire space, $\omega^\omega$ as a tree - which is why it is useful in the study of $\Pi^1_1$ sets.

We denote $S_R(y)$ to be the restriction of $(\textbf{Seq},\prec_{seq})$ to the sequence numbers $\overline{f}(x)$ such that $$S_R(y) = \forall i < x [ \neg R(\overline{f}(i),y) ] $$

The following proposition begins our connection between well-foundedness and formulae in the normal form $\Pi^1_1$:

\begin{proposition}[\protect{\cite[Prop. 5.3]{sacks_2017}}]\label{prop:wellfddR}
$\forall f \exists x (R(\overline{f}(x), y)) \iff S_R(y) \text{ is well-founded.}$
\end{proposition}

\begin{proof}
Fix some $y$.  $\neg (\forall x \, \exists x \, R(\overline{f}(x),y)$ if and only if there is some $f$ such that $\forall x \, \neg R(\overline{f}(x),y)$ if and only if there is some $f$ such that $f(0) > f(1) > f(2) > \ldots$ in an infinite descending sequence $S_R(y)$ if and only if $S_R(y)$ is not well-founded.
\end{proof}

We can now continue our analysis with the following normalisation of $\Pi^1_1$ predicates and theorems. We note that for any computable relation $R_1(f,x,y)$ we can find $e$ such that $\varphi_e^f(x,y) = 0 \iff R_1(f,x,y)$. Using this, we can prove the following, denoting by $WF$ the set of all well-founded trees - we now show the following lemma:

\begin{lemma}[\protect{\cite[Sec. 5.2]{sacks_2017}}]\label{lemma:wellfddTreesPi11}
For each $\Pi^1_1$ set P, $$ P \leq_m WF $$
\end{lemma}

\begin{proof}
Let some $B \in \Pi^1_1$. By the above, there is some computable $R$ such that for all $y$, $$ y \in B \iff \forall f \, \exists x \, R(\overline{f}(x),y) $$ By proposition \ref{prop:wellfddR}, we get $$ y \in B \iff S_R(y) \text{ is well-founded.} $$
\end{proof}

We can thus extend this lemma to a result due to Kleene:

\begin{theorem}[Kleene, \protect{\cite[Thm. 5.4]{sacks_2017}}]\label{thm:KleenePi11O}
For each $\Pi^1_1$ set $P$, $$P \leq_m \mathcal{O}$$
\end{theorem}

\begin{proof}
Let $B \in \Pi^1_1$. As for \ref{lemma:wellfddTreesPi11}, we have that there is some computable $R$ such that for all $y$, $$ y \in B \iff \forall f \, \exists x \, R(\overline{f}(x),y) $$ and again by \ref{prop:wellfddR}, we get $$ y \in B \iff S_R(y) \text{ is well-founded.} $$

Given the $S_R(y)$ is computable uniformly in $y$ - that is, we only require one TM with which to carry our the computation - we have that there exists a computable function $g$ such that $S_R(y) = R_{g(y)}$. Let $f$ be as in lemma \ref{lemma:Rwellfdd}, then $$ y \in B \iff f(g(y)) \in \mathcal{O} $$
\end{proof}

This gives us the following useful corollary:

\begin{corollary}[\protect{\cite[Cor. 5.5]{sacks_2017}}]\label{cor:OnotSigma11}
$\mathcal{O} \notin \Sigma^1_1$
\end{corollary}

\begin{proof}
This proof is structurally similar to one that a complete c.e. subset of $\omega$ is not computable.

We first note that for any set $S$ such that for some $A \in \Sigma^1_1$, if $S \leq_m A$, then $S$ must also be $\Sigma^1_1$. So, by \ref{prop:wellfddR}, we have that if $\mathcal{O}$ were $\Sigma^1_1$, then every $\Pi^1_1$ set would also be $\Sigma^1_1$. 

Thus it suffices that we can find some $A \in \Pi^1_1$ such that $A \notin \Sigma^1_1$. Define $Q(y)$ to be $\forall f \, \exists x \, \varphi_y^{f \upharpoonright x}(y)$. Suppose $( \neg Q(y) \in \Pi^1_1 )$, then $\neg Q(y)$ is equivalent to the statement that there exists $e$, $\forall f \, \exists x \, \varphi_e^{f \upharpoonright x}(y)$. So $\neg Q(y) \iff Q(y)$.
\end{proof}

We can now prove the result due to Spector about the $\Sigma^1_1$-boundedness of $\mathcal{O}$:

\begin{theorem}[Spector, 1955 - \protect{\cite[Cor. 5.6]{sacks_2017}}]
Let $X \subseteq \mathcal{O}$ and $X \in \Sigma^1_1$. There exists some $b \in \mathcal{O}$ such that $\forall x \in X \, (|x| \leq |b|)$.
\end{theorem}

\begin{proof}
As for the proof of \ref{thm:KleenePi11O}, we can replace $\mathcal{O}$ with $B$ and find a computable function $t$ such that for all $y$, $$ y \in \mathcal{O} \iff R_{t(y)} \text{ is well-founded} $$

Let our $Q(y)$ be $$ \exists z \, [ z \in X \wedge \exists f \, \forall u,v \, (R_{t(y)}(u,v) \rightarrow \langle f(u) , f(v) \rangle \in W_{q(z)}) ] $$ where $W_{q(z)}$ is as per \ref{thm:Kleeneq}. $Q(y) \in \Sigma^1_1$. If $Q(y)$ holds then we have $R_{t(y)}$ must be well-founded. 

Suppose that $b$ does not exist, then if $R_{t(y)}$ is well-founded, then by \ref{lemma:Rwellfdd} there is some $z \in X \subseteq \mathcal{O}$ such that $|R_{t(y)}| < |z|$, and thereby $Q(y)$ holds. But $y \in \mathcal{O}$ is $\Sigma^1_1$, contradicting \ref{cor:OnotSigma11}.
\end{proof}

We can thus get the following corollary:

\begin{corollary}[\protect{\cite[Ex. 5.7]{sacks_2017}}]\label{cor:CompTreesPi11}
The set of all well-founded computable trees is $\Pi^1_1$ complete.
\end{corollary}

It should be noted that in later chapters, \ref{lemma:wellfddTreesPi11} and \ref{cor:CompTreesPi11} will be particularly useful, as it will form the basis for our theorems that relate the well-foundedness of trees to tilings of the plane using infinite prototile sets (see Chap. 2 for definitions of these terms). 

\section{Trees, Ordinals, and the Arithmetical and Analytic Hierarchies}

We have outlined in previous sections various definitions that will be used in our work in later chapters. There are some deep and illuminating connections between these objects, which we hope to outline and illustrate in this section. Unless otherwise stated, all results can be found in \cite{Cenzer-griffor1999handbook} and \cite{Cooper2003computability}.

\subsection{Fundamental Results}\label{sec:KLemmaWKL}

Our formulation of K\"onig's lemma comes from \cite{Pudlak2013} and \cite{Kaye2007}.

\begin{lemma}[K\"onig's Lemma, \protect{\cite[Thm. 3.13]{Kaye2007}}]
Every infinite finitely branching tree has an infinite branch.
\end{lemma}

\begin{proof}
We prove this for $T$, a binary tree. For a string $\sigma$ with $|\sigma| = n$, let $$ T_\sigma =  \{ \tau \in T : \tau \upharpoonright n = \sigma \} \cup \{ \sigma \upharpoonright k : k < n \}$$ We shall call $T_\sigma$ the \emph{subtree of $T$ below $\sigma$}. Though it is easy to check that $T$ is a tree, it may or not be infinite. 

We want $\gamma \in T$ such that the tree $T_\gamma$ below $\gamma$ is infinite. Let this be our induction hypothesis. Suppose we have some $\gamma$, with $| \gamma | = n$ and $T_\gamma$ is infinite. Since our tree $T$ is binary, we have $$ T_\gamma = \{ \tau \in T:\tau \upharpoonright (n+1) = \gamma^\frown 0 \} \cup \{ \tau \in T: \tau \upharpoonright (n+1) = \gamma^\frown 1 \} \cup \{ \gamma \upharpoonright k : k \leq n \} $$

The third of these sets is clearly finite, so one of the first two - corresponding to '0' and '1'respectively - must be infinite, by our induction hypothesis. 

If the first of these is infinite, we set $\gamma(n+1) = \gamma^\frown 0$, and so we have $$ T_{\gamma(n+1)} = \{ \tau \in T: \tau \upharpoonright (n+1) = \gamma^\frown 0 \} \cup \{ \gamma^\frown 0  \} \cup \{ \gamma \upharpoonright k : k \leq n \} $$ which is infinite. In the other case, we do the same for $\gamma(n+1) = \gamma^\frown 1$, which gives us the same infinite tree $T_{\gamma(n+1)}$ as before.

In both cases, we have defined $\gamma(n+1)$ and proved our induction hypothesis for $n+1$.

\end{proof}

This lemma is rather famous throughout the mathematical \oe{}uvre - indeed, in other reference texts such as \cite{GrunbaumTP}, this theorem features in reference to the compactness of Wang tiles as ``K\"onig's Infinity Lemma". This is something we shall later make use of in proving this result in chapter 2.

K\"onig's Lemma applied to trees with a bound on the number of children for each node, then we say that this is \emph{Weak K\"onig's Lemma} (WKL). WKL is a very important principle studied in reverse mathematics, such as a compactness principle for Cantor space. This is not, however, within the scope of this thesis to study or present.

%\subsection{Ordinals and $\Pi^0_1$ Classes}
%\mc{TODO - remove, as CB rank isn't used anywhere else...}
%
%It is possible to characterise a rank for recursive $\Pi^0_1$ classes by means of the Cantor-Bendixson rank.
%
%\begin{definition}[Cantor-Bendixson Rank]
%We define the Cantor-Bendixson rank as follows:
%\begin{itemize}
%	\item The \emi{Cantor-Bendixson derivative} $D(P)$ of a compact subset $P \subset \omega^{\omega}$ is the set of non-isolated points of $P$. 
%\begin{itemize}
%\item A point $x \in P$, $x \notin D(P)$ iff there is some open set $U$ such that $U \cap P = \{x\}$.
%\item For $P$ a compact set, $D(P) = \emptyset$ iff $P$ is finite.
%\end{itemize}
%\item The \emi{iterated Cantor-Bendixson derivative} $D^\alpha(P)$ of a closed set $P$ is defined for all ordinals $\alpha$ by transfinite induction:
%\begin{align*}
%	D^0(P) & = P \\
%	D^{\alpha+1}(P) & = D(D^\alpha(P)) \\
%	D^\lambda(P) & = \bigcap\limits_{\alpha < \lambda} D^\alpha(P)
%\end{align*}
%\item The \emi{Cantor-Bendixson rank} of a closed set $P$ is the least ordinal $\alpha$ such that $ D^{\alpha+1}(P) = D^\alpha(P)$.
%\item The Cantor-Bendixson rank of a set $A$ is the least ordinal $\alpha$ such that $A \in D^\alpha(P) \setminus D^{\alpha + 1}(P)$
%\end{itemize}
%\end{definition}
%
%\begin{lemma}\label{lemma:CBrankPi01}
%For any $x \in 2^\omega$, the following are equivalent:
%\begin{enumerate}
%\item $x$ is computable,
%\item $\{x\}$ is a $\Pi^0_1$ class,
%\item $x$ has Cantor-Bendixson rank of 0.
%\end{enumerate}
%\end{lemma}
%
%\begin{proof}
%Let $x$ be computable, then $\{x\} = [T]$, given \[ \sigma \in T \iff (\forall i < |\sigma|) (\sigma(i) = x(i)) \]
%
%Now suppose that $x$ is a $\Pi^0_1$ class. Then the rank of $x$ in $\{x\}$ is 0, so the Cantor-Bendixson rank of $x$ is 0. 
%
%Suppose $x$ has a Cantor-Bendixson rank of 0, and let $P = [T]$ be a $\Pi^0_1$ class with $x$ isolated in $P$, and $T$ is a computable tree. For each sufficiently large $n$, $x \upharpoonright n + 1$ is a unique path of length $n$ with an extension in $P$. As such, we can compute $x \upharpoonright n+1$ - to give us $x(n)$ - by seeking the least $m$ such that all strings $\sigma \in T$ with $| \sigma | = m$, have the same initial segment $\sigma \upharpoonright n$.
%\end{proof}
%
%Theorems and lemmas such as \ref{lemma:CBrankPi01} demonstrate only a small part of a very rich theory surrounding $\Pi^0_1$ classes, and how such objects have deep links to other areas of logic, especially reverse mathematics and computability theory.

\subsection{Trees and Analytic Sets}

We start by defining the extendible nodes of a tree:

\begin{definition}
For a tree $T$, we define the set of \emi{extendible nodes} $Ext(T)$ by \[ \sigma \in Ext(T) \iff (\exists x) (x \in [T] \wedge \sigma \prec x) \]
\end{definition}

This definition allows us to collect all of the initial segments of the points $x$ that lie in some tree $T$. Our aim is to use this set to establish $Ext(T)$ as a basis for trees whose sets of paths are $\Pi^0_1$ sets. By this, we mean that any extension in $Ext(T)$ is a $\Pi^0_1$ set. We first establish what a basis is:

\begin{definition}
Let $\Theta \subseteq \mathcal{P}(\omega^\omega)$ be a collection of subclasses of $\omega^{\omega}$. A set $\Gamma \subset \omega^{\omega}$ is a \emi{basis} if every class $C \in \Theta$, there is some $x \in C$ such that $x \in \Gamma$.
\end{definition}

This gives us natural formulation for `basis theorems', such as the following extracted from \cite[p.52]{Cenzer-griffor1999handbook}.

\begin{theorem}[\protect{\cite[Remark p.51]{Cenzer-griffor1999handbook}}]
The class $\Delta^0_0$ of computable functions is a basis for the family of open subclasses of Baire space.
\end{theorem}

However, we will present the following result - the Kleene Basis theorem.

\begin{theorem}[Kleene Basis Theorem, \protect{\cite[Thm. 3.1]{Cenzer-griffor1999handbook}}]
For any tree $T$ such that a $\Pi^0_1$ class $P = [T] \neq \emptyset$, $P$ contains a member that is computable in $Ext(T)$.
\end{theorem}

\begin{proof}
The infinite path $x$ through $T$ can be computably defined by letting $x(0)$ be the least $n$ such that the sequence $(n) \in Ext(T)$. We continue the construction by letting, for every $k$, $x(k+1)$ be the least $n$ such that $(x(0),x(1),\ldots,x(k),n) \in Ext(T)$.
\end{proof}

We can also prove the following result:

\begin{theorem}[\protect{\cite[Thm. 3.3]{Cenzer-griffor1999handbook}}]
For any recursive tree $T \subset \omega^{< \omega}$, $Ext(T)$ is a $\Sigma^1_1$ set.
\end{theorem}

\begin{proof}
This follows from the following characterisation: \[ \sigma \in Ext(T) \iff (\exists x)(\forall n > |\sigma|) (x \upharpoonright n \in T \wedge \sigma \prec x \upharpoonright n) \]
\end{proof}

These results solidify the fundamental link that we will use later, specifically that the well- or ill-foundedness of a tree $T \subset \omega^{<\omega}$ is complete to $\Pi^1_1$ and $\Sigma^1_1$ formulae. This is a fact that is central to our results in chapter 3 and beyond.
