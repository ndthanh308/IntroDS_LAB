\makeatletter \let \proof \axp@oldproof \let \endproof \endaxp@oldproof \let \section \axp@oldsection 
\global \def \axp@protectref@ii {\ref {axp@sii}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@ii }{Hopcroft's Inequality}}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{0}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mylemmarp} [\ref {axp@ri}]\axp@forward@target {axp@fw@ri}{}\axp@redefinelabels \rpleti \end {axp@mylemmarp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    Let $r$ be the root of $T$.
    We prove by the induction on the size of $T$.

    (\textbf{Base case}).
    $T$ is a tree whose vertex is only $r$.
    Thus we have
    \begin{equation*}
        \sum_{v \in \vertex(T)} \sum_{\substack{u \in \ch(v) \\ (v, u) \not\in S}} w(u)
        = \sum_{\substack{u \in \varnothing = \ch(r) \\ (v, u) \not\in S}} w(u)
        = 0
        = \bigl| \varnothing \bigr| \cdot w(r)
        = \sum_{l \in \leaves(T)}  \bigl| \treepath(r, l) \setminus S \bigr| \cdot w(l).
    \end{equation*}

    (\textbf{Induction step}).
    Let $U = \ch(r) \cap S$ and $W = \ch(r) \setminus S$.
    The following calculation shows the inequality:
    \begin{align*}
        & \sum_{v \in \vertex(T)} \sum_{\substack{u \in \ch(v) \\ (v, u) \not\in S}} w(u)
        \\
        & = \sum_{r' \in W} w(r')
            + \sum_{r' \in U \cup W} \sum_{v \in \vertex(\subtree(r'))} \sum_{\substack{u \in \ch(v) \\ (v, u) \not\in S}} w(u)
        \\
        & \ge \sum_{r' \in W} w(r')
            + \sum_{r' \in U \cup W} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l)
        \\
        & \hspace{10cm} \text{induction hypothesis}
        \\
        & = \sum_{r' \in U} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l)
            + \sum_{r' \in W} \left( w(r') + \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l) \right)
        \\
        & \ge \sum_{r' \in U} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l)
            + \sum_{r' \in W} \left( \sum_{l \in \leaves(\subtree(r'))} w(l) + \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l) \right)
        \\
        & \hspace{9cm} \text{by $\displaystyle w(r') \ge \sum_{l \in \leaves(\subtree(r'))} w(l)$}
        \\
        & = \sum_{r' \in U} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l)
            + \sum_{r' \in W} \sum_{l \in \leaves(\subtree(r'))}  \left( w(l) +  \bigl| \treepath(r', l) \setminus S \bigr| \cdot w(l) \right)
        \\
        & = \sum_{r' \in U} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r, l) \setminus S \bigr| \cdot w(l)
            + \sum_{r' \in W} \sum_{l \in \leaves(\subtree(r'))}  \bigl| \treepath(r, l) \setminus S \bigr| \cdot w(l)
        \\
        & = \sum_{l \in \leaves(T)}  \bigl| \treepath(r, l) \setminus S \bigr| \cdot w(l).
    \end{align*}

    When $w$ is tight,
    we have $w(r') = \sum_{l \in \leaves(\subtree(r'))} w(l)$ for every $r' \in W$,
    and the equality holds.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{1}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mylemmarp} [\ref {axp@rii}]\axp@forward@target {axp@fw@rii}{}\axp@redefinelabels \rpletii \end {axp@mylemmarp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    Let $\langle (v_1, u_1), \dots , (v_m, u_m) \rangle$ be
    the sequence of the light edges of $\lpath(r, v)$ in the order from $r$ to $v$.
    Since $u_i \ne h_{v_i}$,
    we have $2 \cdot w(u_i) \le w(v_i)$.
    We also have $w(v_{i+1}) \le w(u_i)$.
    Hence, the following inequality holds:
    \begin{align*}
        w(r) & \ge w(v_1) \ge 2 \cdot w(u_1)
        \\
        & \ge 2 \cdot w(v_2) \ge 2^2 \cdot w(u_2)
        \\
        & \dots
        \\
        & \ge 2^{m-1} \cdot w(v_m) \ge 2^{m} \cdot w(u_m)
        \\
        & \ge 2^{m} \cdot w(v).
    \end{align*}
    Taking the logarithm of both sides yields $|\lpath(r,v)| = m \le \log_2 w(r) - \log_2 w(v)$.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{1}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mytheoremrp} [\ref {axp@riii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (Hopcroft's inequality)]\axp@forward@target {axp@fw@riii}{}\axp@redefinelabels \rpletiii \end {axp@mytheoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    Let $w'$ be the tightening of $w$.
    By \cref{lem:property-strictification},
    $w'$ is a tight weight function, and
    $h$ is also a heavy child choice for $w'$.
    If we have
    \begin{equation}\label{eq:Hopcroft-inequality-strict}
        \sum_{v \in \vertex(T)} \sum_{u \in \lch_h(v)} w'(u)
        \;\le\;
        w'(r) \log_2 w'(r) - \sum_{ l \in \leaves(T), w'(l) \ne 0 } w'(l) \log_2 w'(l)
    \end{equation}
    then the desired inequality holds:
    \begin{align*}
        \sum_{v \in \vertex(T)} \sum_{u \in \lch_h(v)} w(u)
        & \le \sum_{v \in \vertex(T)} \sum_{u \in \lch_h(v)} w'(u)
        & \text{\cref{lem:property-strictification}}
        \\
        & \le w'(r) \log_2 w'(r) - \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} w'(l) \log_2 w'(l)
        \\
        & \le w(r) \log_2 w(r) - \sum_{\substack{l \in \leaves(T) \\ w(l) \ne 0}} w(l) \log_2 w(l).
        & \text{\cref{lem:property-strictification}}
    \end{align*}

    Now, our goal is to show (\ref{eq:Hopcroft-inequality-strict}).
    It is proven by the following calculation:
    \begin{align*}
        & \sum_{v \in \vertex(T)} \sum_{u \in \lch_h(v)} w'(u)
        \\
        & = \sum_{l \in \leaves(T)} \sum_{(v, u) \in \lpath(r, l)} w'(l)
        & \text{$w'$: tight, and \cref{lem:path-tate-yoko}}
        \\
        & = \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} \sum_{(v, u) \in \lpath(r, l)} w'(l)
        &
        \\
        & \le \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} (\log_2 w'(r) - \log_2 w'(l)) \cdot w'(l)
        & \text{\cref{lem:light-edge-bound}}
        \\
        & = \left( \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} w'(l) \right) \log_2 w'(r) - \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} w'(l) \log_2 w'(l)
        \\
        & = w'(r) \log_2 w'(r) - \sum_{\substack{l \in \leaves(T) \\ w'(l) \ne 0}} w'(l) \log_2 w'(l).
    \end{align*}
\end {axp@oldproof}
\global \def \axp@protectref@v {\ref {axp@sv}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@v }{The Naive Fibrational Algorithm $\PRNaive $}}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{2}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mylemmarp} [\ref {axp@riv}\ifdefined \thm@notefont \the \thm@notefont \fi {} (loop invariant)]\axp@forward@target {axp@fw@riv}{}\axp@redefinelabels \rpletiv \end {axp@mylemmarp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    Firstly we prove the following two lemmas.

    \begin{mylemmarep}\label{lem:well-compatible-fib}
        Assume a $\clat$-fibration  $p \colon \cate \to \catc$ satisfies \cref{assum:well-compatible-fib}.
        Now let
        $\{ \kappa_i \colon A_i \monoto C \}_{i \in I}$ be a mono-sink in $\catc$ that is pairwise disjoint,
        $\lambda \colon B \monoto C$ be a monomorphism with $A_i \cap B \cong 0$ for each $i \in I$, $P_i \in \cate_{A_i}$,
        and $R \in \cate_B$. Then we have
        $\pull{\lambda} \left( \left( \textstyle\bigsqcup_{i \in I} \push{(\kappa_i)}(P_i) \right) \sqcup \push{\lambda}(R) \right) = R$.
    \end{mylemmarep}

    The above claim can be understood as follows:
    when a monomorphism $B \monoto C$ is added to a mono-sink $\{\kappa_i \colon A_i \monoto C\}_{i \in I}$,
    if $B$ is disjoint from each $A_{i}$ ($A_i \cap B \cong 0$),
    then the objects $P_{i}$ above $A_{i}$ do not interfere with $R$ above $B$.
    \begin{equation*}
        \begin{tikzpicture}[baseline=1cm, scale=0.7]
            \node (cate) at (3.5, 2) {$\cate$} ;
            \node (catc) at (3.5, 0) {$\catc$} ;
            \draw[->] (cate) -- node[right]{$p$} (catc) ;
            % E
            \node (Pudots) at (-1.4, 2.4) {$\ddots$} ;
            \node (Pi)     at (-1, 1.9) {$P_i$} ;
            \node (Pddots) at (-0.6, 1.6) {$\ddots$} ;
            \node (R)      at (0.5, 1.3) {$R$} ;
            \node (lamR)   at (2.5, 1.3) {$\push{\lambda}R$} ;
            \node (kapPi)  at (2.5, 1.9) {$\push{(\kappa_i)}P_i$} ;
            \draw[|->] (R)  -- node[below] {$\push{\lambda}$} (lamR) ;
            \draw[|->] (Pi) -- node[above] {$\push{(\kappa_i)}$} (kapPi) ;
            % C
            \node (Audots) at (-1.4, 0.4) {$\ddots$} ;
            \node (Ai)     at (-1, -0.1) {$A_i$} ;
            \node (Addots) at (-0.6, -0.4) {$\ddots$} ;
            \node (B)      at (0.5, -0.7) {$B$} ;
            \node (C)      at (2.5, 0) {$C$} ;
            \draw[>->] (B) -- node[below]{$\lambda$} (C) ;
            \draw[>->] (Ai) -- node[above]{$\kappa_i$} (C) ;
        \end{tikzpicture}
    \end{equation*}

    Cond.~\itemref{item:good-fib-fibre-modular} can be equationally expressed by
    \begin{math}
        \pull{\lambda} (\push{\kappa}(Q) \sqcup \push{\lambda}(R)) = (\pull{\lambda} \push{\kappa}(Q)) \sqcup (\pull{\lambda} \push{\lambda}(R))
    \end{math};
    it can be thought of as a fibrational analogue of \emph{modularity} of a lattice.

    \begin{inlineproof}
        Let $A = \bigcup_{i \in I} A_i$, $\kappa \colon A \monoto C$,
        and $\iota_i \colon A_i \monoto A$ for each $i \in I$.
        Notice that the following diagram is a pullback
        since $\sub(\catc)_C$ is distributive (Cond.~\itemref{item:good-fib-distributive}):
        \begin{equation}\label{diag:empty-intersection}
            \begin{tikzcd}
                0 = B \cap (\bigcup_{i \in I} A_i)
                \ar[d, >->]
                \ar[r, >->]
                \ar[rd, phantom, "\usebox\pullback", very near start]
                &
                B
                \ar[d, >->, "\lambda"]
                \\
                \bigcup_{i \in I} A_i
                \ar[r, >->, "\kappa"]
                &
                C\mathrlap{\text{.}}
            \end{tikzcd}
        \end{equation}
        We have
        \begin{align*}
            & \pull{\lambda} \left(
                \left( \bigsqcup_{i \in I} \push{(\kappa_i)}(P_i) \right)
                \sqcup \push{\lambda}(R)
            \right)
            \\
            & =
            \pull{\lambda} \left(
                \left( \bigsqcup_{i \in I} \push{(\kappa \circ \iota_i)}(P_i) \right)
                \sqcup \push{\lambda}(R)
            \right)
            \\
            & =
            \pull{\lambda} \left(
                \push{\kappa} \left( \bigsqcup_{i \in I} \push{(\iota_i)}(P_i) \right)
                \sqcup \push{\lambda}(R)
            \right)
            & \text{$\push{\kappa}$: left adjoint}
            \\
            & =
            \left( \pull{\lambda}  \push{\kappa} \left( \bigsqcup_{i \in I} \push{(\iota_i)}(P_i) \right) \right)
            \sqcup
            \left( \pull{\lambda} \push{\lambda}(R) \right)
            & \text{Cond.~\itemref{item:good-fib-fibre-modular}}
            \\
            & = \bot \sqcup R
            & \text{\cref{diag:empty-intersection} and Cond.~\itemref{item:good-fib-no-interference}}
            \\
            & = R.
        \end{align*}
    \end{inlineproof}

    The following lemma intuitively says that a partitioning can be refined by another partitioning of one of its leaves, in the manner shown as follows.
    \begin{equation*}
        \begin{tikzpicture}
            \node (C) at (0, 0) {$C$};
            % Cj
            \node (C0)    at (-1.4, 1) {$C_0$};
            \node (C1)    at (-1.4, 0.5) {$C_1$};
            \node (Cdots) at (-1.4, 0) {$\vdots$};
            \node (Cm)    at (-1.4, -0.5) {$C_m$};
            \draw[>->] (C0) -- node[above]{$\kappa_0$} (C) ;
            \draw[>->] (C1) -- node[below]{$\kappa_1$} (C) ;
            \draw[>->] (Cm) -- node[below]{$\kappa_m$} (C) ;
            % Dk
            \node (D0)    at (-2.8, 1.5) {$D_0$} ;
            \node (Ddots) at (-2.8, 1) {$\vdots$} ;
            \node (Dn)    at (-2.8, 0.5) {$D_n$} ;
            \draw[>->] (D0) -- node[above]{$\lambda_0$} (C0) ;
            \draw[>->] (Dn) -- node[below]{$\lambda_n$} (C0) ;
        \end{tikzpicture}
    \end{equation*}
    \begin{mylemmarep}\label{lem:part-part}
        Let $p \colon \cate \to \catc$ be a $\clat$-fibration that satisfies the three conditions in \cref{lem:well-compatible-fib}, $C\in \catc$,
        % be an object,
        $R\in \cate_{C}$,
        % be an object of a fibre,
        %of $\cate_{C}$ for some object $C \in \catc$,
        $\{ \kappa_{j} \colon C_{j} \monoto C\}_{j \in \{0, \dots, m\}} $ be an $R$-partitioning of $C$,
        $R_0$ be an object of $\cate_{C_0}$,
        and $\{ \lambda_{k} \colon D_{k} \monoto C_0 \}_{k \in \{0, \dots, n\}}$ be an $R_0$-partitioning of $C_0$.
        The family of monomorphisms
        \begin{equation*}
        \textstyle
            \Pi = \left\{ \kappa_0 \circ \lambda_k \colon D_k \monoto C \right\}_{k \in \{0,\dots , n\} }
            \cup \left\{ \kappa_j \colon C_j \monoto C \right\}_{j \in \{1, \dots, m\}}
        \end{equation*}
        is a $Q$-partitioning of $C$ where
        \begin{equation*}  \textstyle
            Q =
            \bigl( \bigsqcup_{k = 0}^n {\push{(\kappa_0 \circ \lambda_k)}(\top_{D_k})} \bigr)
            \sqcup
            \left( \bigsqcup_{j = 1}^m {\push{(\kappa_j )}(\top_{C_j})} \right)
            =
            \push{(\kappa_0)}(R_0)
            \sqcup
            \left( \bigsqcup_{j = 1}^m {\push{(\kappa_j )}(\top_{C_j})} \right).
        \end{equation*}
    \end{mylemmarep}
    \begin{inlineproof}
        We check that $\Pi$ satisfies the conditions \itemref{item:R-part-cond-1}--\itemref{item:R-part-cond-3} of \cref{def:R-partitioning}.

        $\Pi$ satisfies \cref{def:R-partitioning}.\itemref{item:R-part-cond-2} by the definition of $Q$.

        For each $k \in \{ 0, \dots , n\}$ and $j \in \{ 1 , \dots, m \}$,
        we have $D_k \cap C_j = 0$.
        Since $\{ \kappa_{j} \colon C_{j} \monoto C\}_{j \in \{0, \dots, m\}} $ and
        $\{ \lambda_{k} \colon D_{k} \monoto C_0 \}_{k \in \{0, \dots, n\}}$
        are partitioning, we have $C_j \cap C_{j'} = 0$ for $j, j' \in \{ 1, \dots, m \}$ with $j \ne j'$
        and $D_k \cap D_{k'} = 0$ for $k, k' \in \{ 1, \dots, n \}$ with $k \ne k'$.
        Moreover, we have $C_j \not\cong 0$ and $D_k \not\cong 0$ for each $j$ and $k$.
        Thus, $\Pi$ satisfies \cref{def:R-partitioning}.\itemref{item:R-part-cond-3}.

        We have
        \begin{align*}
            \pull{\kappa_j}(Q)
            & = \pull{\kappa_j}\left(
                \push{(\kappa_0)}(R_0)
                \sqcup
                \left( \bigsqcup_{j' = 1}^m {\push{(\kappa_{j'} )}(\top_{C_{j'}})} \right)
                \right)
            \\
            & = \top_{C_j}
            & \text{\cref{lem:well-compatible-fib}}
        \end{align*}
        for $j \in \{ 1, \dots, m \}$,
        and
        \begin{align*}
            & \pull{(\kappa_0 \circ \lambda_k)}(Q)
            \\
            & = \pull{(\kappa_0 \circ \lambda_k)}\left(
                \left( \bigsqcup_{k' = 0}^n {\push{(\kappa_0 \circ \lambda_{k'})}(\top_{D_{k'}})} \right)
                \sqcup
                \left( \bigsqcup_{j = 1}^m {\push{(\kappa_j )}(\top_{C_j})} \right)
                \right)
            \\
            & = \top_{D_k}
            & \text{\cref{lem:well-compatible-fib}}
        \end{align*}
        for $k \in \{ 0, \dots, n \}$.
        Hence, $\Pi$ satisfies \cref{def:R-partitioning}.\itemref{item:R-part-cond-1}.
        Therefore, $\Pi$ is a $Q$-partitioning of $C$.
    \end{inlineproof}


    We go back to the proof of \cref{lem:naive-invariant}.
    We write $R_i$ and $T_i$ for $R$ and $T$, respectively, at the beginning (line \ref{line:naive-main-loop}) of the $i$-th iteration of the main loop.
    We prove \itemref{item:naive-inv-part} and \itemref{item:naive-inv-R} by the induction on $i$.

    (\textbf{Base case}).
    We have $R_0 = \top_C$ and $T_0 = \{ \epsilon \}$.
    The mono-sink is $\{ \kappa_{\epsilon} \colon C_{\epsilon} \monoto C \}$, and this is an $R_0$-partitioning of $C$.
    We also have $\nu(\pull{c}\lift{F}) \sqsubseteq \top_C = R_0$.

    (\textbf{Induction step}).
    Assume that $\{ \kappa_{\sigma} \colon C_{\sigma} \monoto \}_{\sigma \in \leaves(T_i)}$ is an $R_i$-partitioning
    and $\nu(\pull{c}\lift{F}) \sqsubseteq R_i$.
    By $\nu(\pull{c}\lift{F}) \sqsubseteq R_i$,
    we have $\nu(\pull{c}\lift{F}) = \pull{c}\lift{F}(\nu(\pull{c}\lift{F})) \sqsubseteq \pull{c}\lift{F}(R_i) = R_{i + 1}$.
    Hence, \itemref{item:naive-inv-R} holds for $i + 1$.
    By \cref{lem:part-part} and the induction hypothesis, we have
    $\{ \kappa_{\sigma} \colon C_{\sigma} \monoto C \}_{\sigma \in \leaves(T_{i + 1})}$ is an $R_{i + 1}$-partitioning.
    Therefore, \itemref{item:naive-inv-part} holds for $i + 1$.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{2}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mylemmarp} [\ref {axp@rv}\ifdefined \thm@notefont \the \thm@notefont \fi {} (termination)]\axp@forward@target {axp@fw@rv}{}\axp@redefinelabels \rpletv \end {axp@mylemmarp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    We write $R_i$ for $R$ at the beginning (line \ref{line:naive-main-loop}) of the $i$-th iteration of the main loop,
    and have
    \begin{equation*}
        R_0 = \top_{C}, \quad R_1 = \pull{c}\lift{F} R_0, \quad \dots, \quad R_{i + 1} = \pull{c}\lift{F} R_i, \quad \dots.
    \end{equation*}
    We have $R_1 \sqsubseteq \top_C = R_0$.
    It is proven by the induction on $i$ and the functoriality of $\pull{c}\lift{F}$ that
    $R_{i} = \pull{c}\lift{F} R_{i - 1} \sqsubseteq R_{i - 1}$ holds for each $i$ such that $R_i$ is defined.
    By this observation and the condition in line \ref{line:naive-main-loop}, we have the strictly descending sequence in $\cate_C$:
    $ R_0 \sqsupset R_1 \sqsupset \cdots \sqsupset R_n \sqsupset \cdots$.
    Since $\cate_C$ is well-founded, the length of the sequence is finite,
    that is \cref{algo:naive} terminates.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{2}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mypropositionrp} [\ref {axp@rvi}\ifdefined \thm@notefont \the \thm@notefont \fi {} (correctness of the naive algorithm)]\axp@forward@target {axp@fw@rvi}{}\axp@redefinelabels \rpletvi \end {axp@mypropositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    By \cref{lem:naive-termination}, \cref{algo:naive} terminates.
    From the termination condition (line \ref{line:naive-main-loop}) of the main loop,
    $R = \pull{c}\lift{F}R$ holds when the algorithm terminates.
    Hence, $R$ is a fixed point.
    By \cref{lem:naive-invariant}.\itemref{item:naive-inv-R},
    $R$ is greater than or equal to the greatest fixed point $\nu(\pull{c}\lift{F})$ of the functor $\pull{c}\lift{F}$.
    Thus, we have $R = \nu(\pull{c}\lift{F})$.
\end {axp@oldproof}
\global \def \axp@protectref@vi {\ref {axp@svi}}
\axp@section {\appendixsectionformat {\protect \axp@protectref@vi }{Optimised Algorithms with Hopcroft's Inequality}}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mypropositionrp} [\ref {axp@rvii}]\axp@forward@target {axp@fw@rvii}{}\axp@redefinelabels \rpletvii \end {axp@mypropositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    We only prove that $p \colon \eqrel \to \sets$ satisfies
    the premise \itemref{item:good-fib-fibre-modular} of \cref{lem:well-compatible-fib}.
    The other conditions are easy to check.

    Given injections $\kappa \colon A \monoto C$ and $\lambda \colon B \monoto C$ in $\sets$
    and equivalence relations $R$ on $A$ and $S$ on $B$.
    We want to show
    $(\pull{\lambda} \push{\kappa} R) \sqcup (\pull{\lambda} \push{\kappa} S)
    = \pull{\lambda} ((\push{\kappa} R) \sqcup (\push{\lambda} S))$.
    For any $(x,y) \in \pull{\lambda} ((\push{\kappa} R) \sqcup (\push{\lambda} S))$,
    we have $(\lambda(x) , \lambda(y)) \in (\push{\kappa} R) \sqcup (\push{\lambda} S)$.
    Hence, there exist $m \in \nat$ and $z_0 , \dots, z_m \in C$ such that
    $z_0 = \lambda(x)$, $z_m = \lambda(y)$, and
    $(z_i, z_{i+1}) \in \push{\kappa}R$ or $(z_i, z_{i+1}) \in \push{\lambda}S$
    for each $i = 0, \dots, m-1$.
    We can assume that $z_i \ne z_{i+1}$
    and $z_i \in \lambda(B)$
    for each $i$ without loss of generality
    since $\lambda(x), \lambda(y) \in \lambda(B)$.
    Thus, the sequence
    $x = \lambda^{-1}(z_0), \lambda^{-1}(z_1), \dots, \lambda^{-1}(z_m) = y$ in $B$
    satisfies
    $(\lambda^{-1}(z_i), \lambda^{-1}(z_{i+1})) \in \pull{\lambda} \push{\kappa} R$ or
    $(\lambda^{-1}(z_i), \lambda^{-1}(z_{i+1})) \in \pull{\lambda} \push{\lambda} S$
    for each $i$.
    This means $(x, y) \in (\pull{\lambda} \push{\kappa} R) \sqcup (\pull{\lambda} \push{\lambda} S)$.
    Hence, $\pull{\lambda} ((\push{\kappa} R) \sqcup (\push{\lambda} S)) \sqsubseteq (\pull{\lambda} \push{\kappa} R) \sqcup (\pull{\lambda} \push{\lambda} S)$ holds.
    Conversely, we can show
    $\pull{\lambda} ((\push{\kappa} R) \sqcup (\push{\lambda} S)) \sqsupseteq (\pull{\lambda} \push{\kappa} R) \sqcup (\pull{\lambda} \push{\lambda} S)$
    by the similar argument.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mypropositionrp} [\ref {axp@rviii}\ifdefined \thm@notefont \the \thm@notefont \fi {} (loop invariants)]\axp@forward@target {axp@fw@rviii}{}\axp@redefinelabels \rpletviii \end {axp@mypropositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    We first prove lemmas to prove the loop invariants.
    The next technical lemma follows easily from the fibredness of $\lift{F}$.
    \begin{mylemma}\label{lem:successor-and-partition}
        Let $m \colon A \to C$ be a morphism in $\catc$ and $P_1, P_2 \in \cate_C$.
        If $\pull{m} P_1 = \pull{m} P_2$,
        then, for any $C' \in \catc$,
        $\kappa \colon C' \to C$ and $\lambda \colon C' \to FA$
        such that $c \circ \kappa = Fm \circ \lambda$,
        we have
        $\pull{\kappa}(\pull{c}\lift{F}P_1) = \pull{\kappa}(\pull{c}\lift{F}P_2)$.
    \end{mylemma}
    \begin{inlineproof}
        For $j = 1, 2$, we have
        \begin{align*}
            \pull{\kappa}(\pull{c}\lift{F}P_j)
            & = \pull{\lambda}(\pull{(Fm)} \lift{F}P_j)
            & c \circ \kappa = Fm \circ \lambda
            \\
            & = \pull{\lambda}(\lift{F} (\pull{m} P_j)).
            & \text{\cref{assum}.\itemref{assum:fibred}}
        \end{align*}
        Hence,
        by the assumption $\pull{m}P_1 = \pull{m}P_2$,
        we obtain
        $\pull{\kappa}(\pull{c}\lift{F}P_1)
        = \pull{\lambda}(\lift{F} (\pull{m} P_1))
        = \pull{\lambda}(\lift{F} (\pull{m} P_2))
        = \pull{\kappa}(\pull{c}\lift{F} P_2)$.
    \end{inlineproof}

    The next lemma (\cref{lem:partition-not-changed}) identifies the subobject of $C$
    that is ``unaffected'' by the refinement from $R_{i}$ to $R_{i+1}$,
    that is, by the tree expansion at the $i$-th iteration.
    It is not hard to see that the untouched leaves in \begin{math}
    \bigcup_{\sigma \in \leaves(T) \setminus \{ \rho \} } C_\sigma
    \end{math} belong to that ``unaffected'' part.
    A crucial observation---central to the Hopcroft-type optimisation---is that \emph{at most one} new child $C_{\rho k_0}$ can also be added,
    where we pick  the heavy one for better complexity.

    \begin{mylemma}\label{lem:partition-not-changed}
        Let $\rho$ be the leaf $\rho \in \leaves(T_i) \setminus \leaves(T_{i+1})$
        that was chosen in \textbf{Partitioning} of the $i$-th iteration, and
        $k_0\in\{0,\dotsc, n_{\rho}\}$ be the  index
        that was chosen in \textbf{Relabelling} of the $i$-th iteration.
        We have $\pull{m}(R_i) = \pull{m}(R_{i+1})$
        for the morphism
        $m \colon C_{\rho k_0} \cup \left( \bigcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \} } C_\sigma \right) \monoto C$.
    \end{mylemma}
    \begin{inlineproof}
        Let $P = \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\kappa_{\sigma})} (\top_{C_{\sigma}}) $,
        and $R_{\rho} = \bigsqcup_{k \in \{ 0, \dots , n_{\rho}\}} \push{(\kappa'_{\rho k})} (\top_{C_{\rho k}})$.
        By \cref{lem:well-compatible-fib}.\itemref{item:good-fib-distributive}, the following diagram is pullback:
        \begin{equation*}
            \begin{tikzcd}
                C_{\rho k_0}
                \ar[d, >->, "\iota'"']
                \ar[r, >->, "{\kappa'_{k_0}}"]
                \ar[rd, phantom, "\usebox\pullback", very near start]
                &
                C_{\rho}
                \ar[d, >->, "\kappa_{\rho}"]
                \\
                C_{\rho k_0} \cup \left( \bigcup_{\sigma \in \leaves(T_i) \setminus \{\rho\}} C_{\sigma} \right)
                \ar[r, >-> ,"m"]
                &
                C \mathrlap{\text{.}}
            \end{tikzcd}
        \end{equation*}
        Thus, the following diagram commutes by \cref{lem:well-compatible-fib}.\itemref{item:good-fib-no-interference}.
        \begin{equation}\label{diag:no-interference-for-correctness}
            \begin{tikzcd}
                \cate_{C_{\rho k_0}}
                \ar[d, "\push{\iota'}"']
                &
                \cate_{C_{\rho}}
                \ar[d, "\push{(\kappa_{\rho})}"]
                \ar[l, "\pull{(\kappa'_{k_0})}"']
                \\
                \cate_{C_{\rho k_0} \cup \left( \bigcup_{\sigma \in \leaves(T_i) \setminus \{\rho\}} C_{\sigma} \right)}
                &
                \cate_{C}
                \ar[l, "\pull{m}"]
            \end{tikzcd}
        \end{equation}
        By chasing the diagram, we have
        \begin{equation}\label{eq:mQi}
            \begin{split}
                \pull{m} (\push{(\kappa_{\rho})} (\top_{C_\rho}))
                & = \push{\iota'} (\pull{(\kappa'_{k_0})} (\top_{C_\rho}))
                & \text{\cref{diag:no-interference-for-correctness}}
                \\
                & = \push{\iota'} (\top_{C_{\rho k_0}}),
                & \text{$\pull{(\kappa'_{k_0})}$: right adjoint and $\top$: limit}
            \end{split}
        \end{equation}
        and
        \begin{equation}\label{eq:mQi1}
            \begin{split}
                \pull{m} \left( \push{(\kappa_{\rho})} (R_{\rho}) \right)
                & = \push{\iota'} \left( \pull{(\kappa'_{k_0})} (R_{\rho}) \right)
                & \text{\cref{diag:no-interference-for-correctness}}
                \\
                & = \push{\iota'} (\top_{C_{\rho k_0}}).
                & \text{$\{ \kappa'_{\rho k} \colon C_{\rho k} \monoto C_{\rho}\}_{k}$ is $R_{\rho}$-partitioning}
            \end{split}
        \end{equation}
        There are monomorphisms
        $\iota_{\sigma} \colon C_{\sigma} \monoto C_{\rho k_0} \cup \bigcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \} } C_{\sigma}$
        for each $\sigma \in \leaves(T_i) \setminus \{ \rho \}$ with $\kappa_{\sigma} = m \circ \iota_{\sigma}$.
        We have
        \begin{align*}
            & \pull{m} (R_i)
            &
            \\
            & = \pull{m} \left( \bigsqcup_{\sigma \in \leaves(T_i)} \push{(\kappa_{\sigma})} (\top_{C_{\sigma}}) \right)
            & \text{Definition of $R_i$}
            \\
            & = \pull{m} \left( \push{(\kappa_{\rho})}(\top_{C_\rho}) \sqcup \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\kappa_{\sigma})} (\top_{C_{\sigma}}) \right)
            &
            \\
            & = \pull{m} \left( \push{(\kappa_{\rho})}(\top_{C_\rho}) \sqcup \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(m \circ \iota_{\sigma})} (\top_{C_{\sigma}}) \right)
            & \text{$\kappa_{\sigma} = m \circ \iota_{\sigma}$}
            \\
            & = \pull{m} \left( \push{(\kappa_{\rho})}(\top_{C_\rho}) \sqcup \push{m} \left( \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\iota_{\sigma})} (\top_{C_{\sigma}}) \right) \right)
            & \text{$\push{m}$: left adjoint}
            \\
            & = \pull{m} \push{(\kappa_{\rho})}(\top_{C_\rho}) \sqcup \pull{m} \push{m} \left( \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\iota_{\sigma})} (\top_{C_{\sigma}}) \right)
            & \text{\cref{lem:well-compatible-fib}.\itemref{item:good-fib-fibre-modular}}
            \\
            & = \push{\iota'} (\top_{C_{\rho k_0}}) \sqcup \pull{m} \push{m} \left( \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\iota_{\sigma})} (\top_{C_{\sigma}}) \right)
            & \text{(\ref{eq:mQi})}
        \end{align*}
        and
        \begin{align*}
            & \pull{m} (R_{i+1})
            &
            \\
            & = \pull{m} \left(
                \left(
                    \bigsqcup_{k = 0}^{n_{\rho}} \push{(\kappa_{\rho} \circ \kappa'_{\rho k})}(\top_{C_{\rho k}})
                \right)
                \sqcup
                \left(
                    \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\kappa_{\sigma})} (\top_{C_{\sigma}})
                \right)
            \right)
            & \text{Definition of $R_{i+1}$}
            \\
            & = \pull{m}
            \left(
                \push{(\kappa_{\rho})}(R_{\rho})
                \sqcup
                \left(
                    \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\kappa_{\sigma})} (\top_{C_{\sigma}})
                \right)
            \right)
            & \text{$\push{(\kappa_{\rho})}$: left adjoint}
            \\
            & = \pull{m}
            \left(
                \push{(\kappa_{\rho})}(R_{\rho})
                \sqcup
                \left(
                    \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(m \circ \iota_{\sigma})} (\top_{C_{\sigma}})
                \right)
            \right)
            & \text{$\kappa_{\sigma} = m \circ \iota_{\sigma}$}
            \\
            & = \pull{m}
            \left(
                \push{(\kappa_{\rho})}(R_{\rho})
                \sqcup
                \push{m}
                \left(
                    \bigsqcup_{\sigma \in \leaves(T_i)} \push{(\iota_{\sigma})} (\top_{C_{\sigma}})
                \right)
            \right)
            & \text{$\push{m}$: left adjoint}
            \\
            & = \pull{m}\push{(\kappa_{\rho})}(R_{\rho})
                \sqcup
                \pull{m} \push{m}
                \left(
                    \bigsqcup_{\sigma \in \leaves(T_i)} \push{(\iota_{\sigma})} (\top_{C_{\sigma}})
                \right)
            & \text{\cref{lem:well-compatible-fib}.\itemref{item:good-fib-fibre-modular}}
            \\
            & = \push{\iota'} (\top_{C_{\rho k_0}})
                \sqcup
                \pull{m} \push{m} \left( \bigsqcup_{\sigma \in \leaves(T_i) \setminus \{ \rho \}} \push{(\iota_{\sigma})} (\top_{C_{\sigma}}) \right).
            & \text{(\ref{eq:mQi1})}
        \end{align*}
        Therefore, we obtain $\pull{m}(R_i) = \pull{m}(R_{i+1})$.
    \end{inlineproof}


    We illustrate the proof of \cref{lem:partition-not-changed}.
    See \cref{fig:example-partition-not-changed}.
    A set $C$ is the disjoint union $C_0 \cup C_1 \cup C_2$, where $C_0 = C_{00} \cup C_{01} \cup C_{02}$.
    An equivalence relation $R$ on $C$ corresponds to a partitioning $\{ C_0, C_1, C_2 \}$,
    and an equivalence relation $R'$ on $C$ corresponds to a partitioning $\{ C_{00}, C_{01}, C_{02}, C_1, C_2 \}$.
    As illustrated in \cref{fig:example-partition-not-changed},
    when restricted to $C_{00} \cup C_{1} \cup C_{2}$,
    $R$ and $R'$ coincide.
    This restriction yields the same equivalence relation,
    and \cref{lem:partition-not-changed} formalises this coincidence.
    An important observation is that,
    we cannot \emph{add} one extra to the restriction.
    For example,
    if we restrict $R$ and $R'$ to $C_{00} \cup C_{01} \cup C_1 \cup C_2$ (with both $C_{00} $ and $C_{01}$ included),
    we have $ \pull{m}(R) \ne \pull{m}(R')$,
    as depicted in \cref{fig:non-example-partition-not-changed}.
    \begin{figure}[ht]
        \centering
        \begin{tikzpicture}
            % C
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (C'begin) at (1.7, 0) ;
            \coordinate (Cbegin)  at ($ (C'begin) + (0, \marginV) $);
            \node (C') at (0, 0.5) {$C_{00} \cup C_{1} \cup C_{2}$} ;
            \node (C'eq) at ($ (C') + (1.4, 0) $) {$=$} ;
            \node (C) at ($ (C') + (0, \marginV) $) {$C$} ;
            \node (Ceq) at ($ (C) + (1.4, 0) $) {$=$} ;
            \draw[>->] (C') -- node[left]{$m$} (C) ;
            \draw[fill=gray!10] (C'begin)
                -- ($ (C'begin) + (\Cwidth, 0) $)
                -- ($ (C'begin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (C'begin) + (\Cwidth / 3, \Cheight / 2) $)
                -- ($ (C'begin) + (\Cwidth / 3, \Cheight) $)
                -- ($ (C'begin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Cbegin)
                -- ($ (Cbegin) + (\Cwidth, 0) $)
                -- ($ (Cbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Cbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (C00) at ($ (Cbegin) + (\Cwidth / 6,     \Cheight / 4 * 3) $) {$C_{00}$};
            \node (C01) at ($ (Cbegin) + (\Cwidth / 2,     \Cheight / 4 * 3) $) {$C_{01}$};
            \node (C02) at ($ (Cbegin) + (\Cwidth / 6 * 5, \Cheight / 4 * 3) $) {$C_{02}$};
            \node (C1)  at ($ (Cbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (C2)  at ($ (Cbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw[dashed] ($ (Cbegin) + (0, \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 3,     \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth / 3,     \Cheight) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth / 3 * 2, \Cheight) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 2, 0) $) -- ($ (Cbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
        \end{tikzpicture}
        \begin{tikzpicture}
            % Q
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (mQbegin) at (1, 0) ;
            \coordinate (Qbegin)  at ($ (mQbegin) + (0, \marginV) $);
            \node (mQ) at (0, 0.5) {$\pull{m}(R)$} ;
            \node (mQeq) at ($ (mQ) + (0.7, 0) $) {$=$} ;
            \node (Q) at ($ (mQ) + (0, \marginV) $) {$R$} ;
            \node (Qeq) at ($ (Q) + (0.7, 0) $) {$=$} ;
            \draw[|->] (Q) -- node[left]{$\pull{m}$} (mQ) ;
            \draw[fill=gray!10] (mQbegin)
                -- ($ (mQbegin) + (\Cwidth, 0) $)
                -- ($ (mQbegin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3, \Cheight) $)
                -- ($ (mQbegin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Qbegin)
                -- ($ (Qbegin) + (\Cwidth, 0) $)
                -- ($ (Qbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Qbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (QC0) at ($ (Qbegin) + (\Cwidth / 2, \Cheight / 4 * 3) $) {$C_0$};
            \node (QC1) at ($ (Qbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (QC2) at ($ (Qbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw ($ (Qbegin) + (0, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 2, 0) $) -- ($ (Qbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (0, \Cheight / 2) $) -- ($ (mQbegin) + (\Cwidth / 3, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (\Cwidth / 2, 0) $) -- ($ (mQbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
        \end{tikzpicture}
        \begin{tikzpicture}
            % Q'
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (mQbegin) at (1, 0) ;
            \coordinate (Qbegin)  at ($ (mQbegin) + (0, \marginV) $);
            \node (mQ) at (0, 0.5) {$\pull{m}(R')$} ;
            \node (mQeq) at ($ (mQ) + (0.7, 0) $) {$=$} ;
            \node (Q) at ($ (mQ) + (0, \marginV) $) {$R'$} ;
            \node (Qeq) at ($ (Q) + (0.7, 0) $) {$=$} ;
            \draw[|->] (Q) -- node[left]{$\pull{m}$} (mQ) ;
            \draw[fill=gray!10] (mQbegin)
                -- ($ (mQbegin) + (\Cwidth, 0) $)
                -- ($ (mQbegin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3, \Cheight) $)
                -- ($ (mQbegin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Qbegin)
                -- ($ (Qbegin) + (\Cwidth, 0) $)
                -- ($ (Qbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Qbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (QC00) at ($ (Qbegin) + (\Cwidth / 6,     \Cheight / 4 * 3) $) {$C_{00}$};
            \node (QC01) at ($ (Qbegin) + (\Cwidth / 2,     \Cheight / 4 * 3) $) {$C_{01}$};
            \node (QC02) at ($ (Qbegin) + (\Cwidth / 6 * 5, \Cheight / 4 * 3) $) {$C_{02}$};
            \node (QC1) at ($ (Qbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (QC2) at ($ (Qbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw ($ (Qbegin) + (0, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 3,     \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth / 3,     \Cheight) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth / 3 * 2, \Cheight) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 2, 0) $) -- ($ (Qbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (0, \Cheight / 2) $) -- ($ (mQbegin) + (\Cwidth / 3, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (\Cwidth / 2, 0) $) -- ($ (mQbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
        \end{tikzpicture}
        \caption{An example situation of \cref{lem:partition-not-changed} in $\eqrel \to \sets$: $\pull{m}(R) = \pull{m}(R')$.}
        \label{fig:example-partition-not-changed}
    \end{figure}
    \begin{figure}[ht]
        \centering
        \begin{tikzpicture}[baseline=0]
            % C
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (C'begin) at (1.7, 0) ;
            \coordinate (Cbegin)  at ($ (C'begin) + (0, \marginV) $);
            \node (C') at (0, 0.5) {$C_{00} \cup C_{01}$} ;
            \node (C'additional) at (0.2, 0) {${} \cup C_{1} \cup C_{2}$} ;
            \node (C'eq) at ($ (C') + (1.4, 0) $) {$=$} ;
            \node (C) at ($ (C') + (0, \marginV) $) {$C$} ;
            \node (Ceq) at ($ (C) + (1.4, 0) $) {$=$} ;
            \draw[>->] (C') -- node[left]{$m$} (C) ;
            \draw[fill=gray!10] (C'begin)
                -- ($ (C'begin) + (\Cwidth, 0) $)
                -- ($ (C'begin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (C'begin) + (\Cwidth / 3 * 2, \Cheight / 2) $)
                -- ($ (C'begin) + (\Cwidth / 3 * 2, \Cheight) $)
                -- ($ (C'begin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Cbegin)
                -- ($ (Cbegin) + (\Cwidth, 0) $)
                -- ($ (Cbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Cbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (C00) at ($ (Cbegin) + (\Cwidth / 6,     \Cheight / 4 * 3) $) {$C_{00}$};
            \node (C01) at ($ (Cbegin) + (\Cwidth / 2,     \Cheight / 4 * 3) $) {$C_{01}$};
            \node (C02) at ($ (Cbegin) + (\Cwidth / 6 * 5, \Cheight / 4 * 3) $) {$C_{02}$};
            \node (C1)  at ($ (Cbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (C2)  at ($ (Cbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw[dashed] ($ (Cbegin) + (0, \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 3,     \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth / 3,     \Cheight) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) -- ($ (Cbegin) + (\Cwidth / 3 * 2, \Cheight) $) ;
            \draw[dashed] ($ (Cbegin) + (\Cwidth / 2, 0) $) -- ($ (Cbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
        \end{tikzpicture}
        \begin{tikzpicture}[baseline=0]
            % Q
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (mQbegin) at (1, 0) ;
            \coordinate (Qbegin)  at ($ (mQbegin) + (0, \marginV) $);
            \node (mQ) at (0, 0.5) {$\pull{m}(R)$} ;
            \node (mQeq) at ($ (mQ) + (0.7, 0) $) {$=$} ;
            \node (Q) at ($ (mQ) + (0, \marginV) $) {$R$} ;
            \node (Qeq) at ($ (Q) + (0.7, 0) $) {$=$} ;
            \draw[|->] (Q) -- node[left]{$\pull{m}$} (mQ) ;
            \draw[fill=gray!10] (mQbegin)
                -- ($ (mQbegin) + (\Cwidth, 0) $)
                -- ($ (mQbegin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight) $)
                -- ($ (mQbegin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Qbegin)
                -- ($ (Qbegin) + (\Cwidth, 0) $)
                -- ($ (Qbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Qbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (QC0) at ($ (Qbegin) + (\Cwidth / 2, \Cheight / 4 * 3) $) {$C_0$};
            \node (QC1) at ($ (Qbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (QC2) at ($ (Qbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw ($ (Qbegin) + (0, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 2, 0) $) -- ($ (Qbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (0, \Cheight / 2) $) -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (\Cwidth / 2, 0) $) -- ($ (mQbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
        \end{tikzpicture}
        \begin{tikzpicture}[baseline=0]
            % Q'
            \pgfmathsetmacro{\Cwidth}{2.4}
            \pgfmathsetmacro{\Cheight}{1}
            \pgfmathsetmacro{\marginV}{1.5}
            \coordinate (mQbegin) at (1, 0) ;
            \coordinate (Qbegin)  at ($ (mQbegin) + (0, \marginV) $);
            \node (mQ) at (0, 0.5) {$\pull{m}(R')$} ;
            \node (mQeq) at ($ (mQ) + (0.7, 0) $) {$=$} ;
            \node (Q) at ($ (mQ) + (0, \marginV) $) {$R'$} ;
            \node (Qeq) at ($ (Q) + (0.7, 0) $) {$=$} ;
            \draw[|->] (Q) -- node[left]{$\pull{m}$} (mQ) ;
            \draw[fill=gray!10] (mQbegin)
                -- ($ (mQbegin) + (\Cwidth, 0) $)
                -- ($ (mQbegin) + (\Cwidth, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $)
                -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight) $)
                -- ($ (mQbegin) + (0, \Cheight) $)
                -- cycle ;
            \draw[fill=gray!10] (Qbegin)
                -- ($ (Qbegin) + (\Cwidth, 0) $)
                -- ($ (Qbegin) + (\Cwidth, \Cheight) $)
                -- ($ (Qbegin) + (0, \Cheight) $)
                -- cycle ;
            \node (QC00) at ($ (Qbegin) + (\Cwidth / 6,     \Cheight / 4 * 3) $) {$C_{00}$};
            \node (QC01) at ($ (Qbegin) + (\Cwidth / 2,     \Cheight / 4 * 3) $) {$C_{01}$};
            \node (QC02) at ($ (Qbegin) + (\Cwidth / 6 * 5, \Cheight / 4 * 3) $) {$C_{02}$};
            \node (QC1) at ($ (Qbegin) + (\Cwidth / 4, \Cheight / 4) $) {$C_1$};
            \node (QC2) at ($ (Qbegin) + (\Cwidth / 4 * 3, \Cheight / 4) $) {$C_2$};
            \draw ($ (Qbegin) + (0, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth, \Cheight / 2) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 3,     \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth / 3,     \Cheight) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) -- ($ (Qbegin) + (\Cwidth / 3 * 2, \Cheight) $) ;
            \draw ($ (Qbegin) + (\Cwidth / 2, 0) $) -- ($ (Qbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (0, \Cheight / 2) $) -- ($ (mQbegin) + (\Cwidth / 3 * 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (\Cwidth / 2, 0) $) -- ($ (mQbegin) + (\Cwidth / 2, \Cheight / 2) $) ;
            \draw ($ (mQbegin) + (\Cwidth / 3, \Cheight / 2) $) -- ($ (mQbegin) + (\Cwidth / 3, \Cheight) $) ;
        \end{tikzpicture}
        \caption{We cannot add more than one child to the domain of $m$ in \cref{lem:partition-not-changed}.}
        \label{fig:non-example-partition-not-changed}
    \end{figure}


    We go back to the proof of \cref{prop:loop-invariant}.
    The claim \itemref{item:keep-partitioning} follows from \cref{lem:part-part} and the induction on $i$.
    The claim \itemref{item:gfp-R} follows from
    the assumption that $p$ admits monotone partitioning (\cref{assum}.\itemref{assum:monotone-partitioning})
    and the induction on $i$.
    We prove \itemref{item:clean-leaf-top} by the induction on $i$.

    (\textbf{Base case}).
    We have $C^{\clean, 0}_{\epsilon} = 0$.
    Hence, from \cref{assum}.\itemref{assum:fibre-0},
    we have $\pull{({\kappa^{\clean,0}_{\epsilon}})}\pull{\kappa_{\epsilon}}\pull{c}\lift{F}(R_0) = \top_{C^{\clean, 0}_{\epsilon}}$.

    (\textbf{Induction step}).
    We assume that \itemref{item:clean-leaf-top} holds for $i$,
    and need to show \itemref{item:clean-leaf-top} for $i+1$.
    For each $\sigma \in \leaves(T_{i+1})$,
    $C^{\clean, i+1}_{\sigma}$ is defined by the following pullback:
    \begin{equation*}
        \begin{tikzcd}
            C^{\clean, i+1}_{\sigma}
            \ar[dd, >->]
            \ar[r, "\kappa"]
            \ar[rd, phantom, "\usebox\pullback", very near start]
            &
            C^{\clean, i}_{\sigma}
            \ar[d, >->, "\kappa^{\clean, i}_{\sigma}"]
            \\
            &
            C_{\sigma}
            \ar[d, >->, "\kappa_{\sigma}"]
            \\
            B
            \ar[r, "l"]
            \ar[d, "h"']
            \ar[rd, phantom, "\usebox\pullback", very near start]
            &
            C
            \ar[d, "c"]
            \\
            F\left(  C_{\rho k_0} \cup \left( \bigcup_{\sigma \in \leaves(T) \setminus \{ \rho \} } C_\sigma \right) \right)
            \ar[r, "Fm"']
            &
            FC \mathrlap{\quad.}
        \end{tikzcd}
    \end{equation*}
    Applying \cref{lem:successor-and-partition} to the above diagram and the result of \cref{lem:partition-not-changed},
    we have
    \begin{equation}
        \pull{(\kappa^{\clean, i+1}_{\sigma})} \pull{\kappa_{\sigma}} \pull{c} \lift{F} R_{i+1}
        = \pull{(\kappa^{\clean, i+1}_{\sigma})} \pull{\kappa_{\sigma}} \pull{c} \lift{F} R_{i}.
    \end{equation}
    If $\sigma \in T_i$, the right-hand side is calculated as:
    \begin{align*}
        \pull{(\kappa^{\clean, i+1}_{\sigma})} \pull{\kappa_{\sigma}} \pull{c} \lift{F} R_{i}
        & = \pull{\kappa} \pull{(\kappa^{\clean, i}_{\sigma})} \pull{\kappa_{\sigma}} \pull{c} \lift{F} R_{i}
        &
        \\
        & = \pull{\kappa} (\top_{C^{\clean, i}_{\sigma}})
        & \text{Induction hypothesis}
        \\
        & = \top_{C^{\clean, i+1}_{\sigma}}.
        & \text{$\push{\kappa} \dashv \pull{\kappa}$ and $\top_{C^{\clean, i}_{\sigma}}$ is a limit}
    \end{align*}
    Otherwise, we have $\sigma = \rho k$ for some $k \in \{ 0, \dots , n_{\rho} \}$
    where $\rho \in \leaves(T_i)$ is the chosen leaf at the \textbf{Partitioning} step.
    Then, we have
    \begin{align*}
        & \pull{(\kappa^{\clean, i+1}_{\rho k})} \pull{\kappa_{\rho k}} \pull{c} \lift{F} R_{i}
        &
        \\
        & = \pull{(\kappa^{\clean, i+1}_{\rho k})} \pull{\kappa_{\rho k, k}} \pull{\kappa_{\rho}} \pull{c} \lift{F} R_{i}
        & \kappa_{\rho k} = \kappa_{\rho} \circ \kappa_{\rho k, k}
        \\
        & = \pull{(\kappa^{\clean, i+1}_{\rho k})} (\top_{C_{\rho k}})
        & \text{\cref{def:R-partitioning}.\itemref{item:R-part-cond-1}}
        \\
        & = \top_{C^{\clean, i+1}_{\rho k}}.
        & \text{$\push{(\kappa^{\clean, i+1}_{\rho k})} \dashv \pull{(\kappa^{\clean, i+1}_{\rho k})}$ and $\top_{C_{\rho k}}$ is a limit}
    \end{align*}
    Hence, we have
    $\pull{(\kappa^{\clean, i+1}_{\sigma})} \pull{\kappa_{\sigma}} \pull{c} \lift{F} R_{i+1} = \top_{C^{\clean, i+1}_{\sigma}}$
    for each $\sigma \in \leaves(T_{i+1})$.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mypropositionrp} [\ref {axp@rix}\ifdefined \thm@notefont \the \thm@notefont \fi {} (termination)]\axp@forward@target {axp@fw@rix}{}\axp@redefinelabels \rpletix \end {axp@mypropositionrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    To prove termination,
    we use the lexicographical order $\trianglelefteq$
    on $\cate_{C} \times \nat$, where the order of $\nat$ is the usual order $\le$.
    The order $\le$ is well-founded,
    and $\sqsubseteq$ is well-founded by \cref{assum}.\itemref{assum:well-founded}.
    Thus, $\trianglelefteq$ is also well-founded.
    Let $d_i = |\{ \sigma \in \leaves(T_i) \mid C^{\clean, i}_{\sigma} \ne C_{\sigma} \}|$.

    We show that
    if $C^{\clean, i}_{\rho} \ne C^{i}_{\rho}$ holds for some $\rho \in \leaves(T)$,
    then we have $(R_{i + 1}, d_{i + 1}) \triangleleft (R_i , d_i)$.
    Suppose that, at the line \ref{line:choose-a-leaf} of the $i$-th iteration of the main loop,
    a leaf $\rho \in \leaves(T_i)$ such that $C^{\clean, i}_{\rho} \ne C^{i}_{\rho}$ is chosen.
    We have two cases.

    \textbf{Case} $\pull{(c \circ \kappa_{\rho})} (\lift{F} R_i) \sqsubset \top_{C_\rho}$.
    In this case, we have $R_i \sqsubset R_{i + 1}$ by \cref{assum}.\itemref{assum:inj-on-obj}.
    Thus, $(R_{i + 1}, d_{i + 1}) \triangleleft (R_i , d_i)$ holds.

    \textbf{Case} $\pull{(c \circ \kappa_{\rho})} (\lift{F} R_i) = \top_{C_\rho}$.
    In this case,
    the line \ref{line:mark-all-states-clean} is executed,
    and the number of $\sigma \in T$ with $C^{\clean}_{\sigma} \ne C_{\sigma}$ reduces: $d_{i + 1} < d_i$.

    By the above argument shows that,
    after finite number of iteration, we have $C^{\clean}_{\rho} = C_{\rho}$ for all $\rho \in \leaves(T)$.
    This means that \cref{algo:fibrational-block-specified} terminates.
\end {axp@oldproof}
\setcounter {axp@equationx}{\c@equation }\setcounter {equation}{3}
{\pretocmd {\@begintheorem }{\patchcmd {\thmhead }{\@acmplainnotefont }{}{}{}\patchcmd {\thmhead }{\the \thm@notefont }{}{}{}\patchcmd {\thmhead }{(}{}{}{}\patchcmd {\thmhead }{)}{}{}{}}{}{} \begin {axp@mytheoremrp} [\ref {axp@rx}\ifdefined \thm@notefont \the \thm@notefont \fi {} (correctness)]\axp@forward@target {axp@fw@rx}{}\axp@redefinelabels \rpletx \end {axp@mytheoremrp} }
\setcounter {equation}{\c@axp@equationx }
\begin {axp@oldproof}
    Termination is ensured by \cref{prop:termination}.
    Let $R$, $T$ and $\{ C_{\sigma} \monoto C \}_{\sigma \in \leaves(T)}$ be
    as defined in the last iteration of the main loop.
    Our goal is to show that $\{ C_{\sigma} \monoto C \}_{\sigma \in \leaves(T)}$ is a $\nu (\pull{c} \lift{F})$-partitioning of $C$.

    We prove $R = \pull{c}\lift{F}(R)$.
    By \cref{prop:loop-invariant},
    $\{ C_{\sigma} \monoto C \}_{\sigma \in \leaves(T)}$ is an $R$-partitioning.
    We also have $\pull{\kappa_{\sigma}}(\pull{c}\lift{F}(R)) = \top_{C_{\sigma}}$ for each $\sigma \in \leaves(T)$.
    Thus, we have
    \begin{align*}
        R
        & = \bigsqcup_{\sigma \in \leaves(T)} \push{(\kappa_{\sigma})}(\top_{C_{\sigma}})
        & \text{the definition of $R$}
        \\
        & = \bigsqcup_{\sigma \in \leaves(T)} \push{(\kappa_{\sigma})}(\pull{\kappa_{\sigma}}(\pull{c}\lift{F}(R)))
        & \text{\cref{def:R-partitioning}.\itemref{item:R-part-cond-2}}
        \\
        & = \pull{c}\lift{F}(R).
        & \text{\cref{assum}.\itemref{assum:monotone-partitioning}}
    \end{align*}
    From \cref{prop:loop-invariant}.\itemref{item:gfp-R},
    we have $\nu(\pull{c}\lift{F}) \sqsubseteq R$.
    Hence, we have $R = \nu(\pull{c}\lift{F})$.
\end {axp@oldproof}
    \section{Illustration of Runs of \cref{algo:eqrel-sets-optimized}}
    \label{appendix:illustRun}

    We illustrate \cref{algo:eqrel-sets-optimized} for non-deterministic automata.

    \begin{myexample}
        Let $\Sigma = \{ a, b \}$, $C = \{ x, y, z, w, v \}$, $\nondet_{\Sigma}$ be the functor from \cref{example:F-coalg},
        and $\lift{\nondet_{\Sigma}} = \rellift{\nondet_{\Sigma}}$ (\cref{def:relation-lifting}).
        \begin{figure}
            \footnotesize
            \centering
            (4 steps) $\cdots$
            \begin{tikzpicture}[scale=0.9, x=4mm, segment length=2mm]\draw[->, decorate, decoration={snake,amplitude=1pt}, line width=1.5pt] (0,0) to node[above=2mm]{$\wCard$} (-1,0) ;\end{tikzpicture}
            \begin{minipage}{2.3cm}
                \centering
                \partitioningexample{
                \begin{pgfonlayer}{background}
                    \fill[lipicsYellow] \convexpath{x,y,v}{1cm} node[above of=x, yshift=-3.5cm, text=black]{$C_{01}$};
                    \fill[lipicsYellow] (z) circle[radius=1] node[xshift=1.5cm,yshift=-1cm,text=black] {$C_1$};
                    \fill[lipicsYellow] (w) circle[radius=1] node[xshift=0cm,yshift=-1.5cm,text=black] {$C_{00}$};
                \end{pgfonlayer}
                }
                {dirty} % x
                {dirty} % y
                {dirty} % z
                {dirty} % w
                {clean} % v
                %at the end of the second iteration
            \end{minipage}
            \begin{tikzpicture}[scale=0.9, x=4mm, segment length=2mm]\draw[->, decorate, decoration={snake,amplitude=1pt}, line width=1.5pt] (0,0) to node[above=2mm]{$\wCard$} (-1,0) ;\end{tikzpicture}
            \begin{minipage}{2.4cm}
                \centering
                \partitioningexample{
                \begin{pgfonlayer}{background}
                    \fill[lipicsYellow] node[above of=x, yshift=-3.5cm, text=black]{$C_0$}
                        \hobbyconvexpath{x,y,w,v}{1cm};
                    \fill[lipicsYellow] (z) circle[radius=1] node[xshift=1.5cm, yshift=-1cm, text=black] {$C_1$};
                \end{pgfonlayer}
                }
                {dirty} % x
                {dirty} % y
                {clean} % z
                {dirty} % w
                {dirty} % v
                %at the end of the first iteration
            \end{minipage}
            \begin{tikzpicture}[scale=0.9, x=4mm, segment length=2mm]\draw[->, decorate, decoration={snake,amplitude=1pt}, line width=1.5pt] (0,0) to node[above=2mm]{$\wPred$} (1,0) ;\end{tikzpicture}
            \begin{minipage}{2.3cm}
                \centering
                \partitioningexample{
                \begin{pgfonlayer}{background}
                    \fill[lipicsYellow] \convexpath{x,y,v}{1cm} node[above of=x, yshift=-3.5cm, text=black] {$C_{01}$};
                    \fill[lipicsYellow] (z) circle[radius=1] node[xshift=1.5cm,yshift=-1cm,text=black] {$C_1$};
                    \fill[lipicsYellow] (w) circle[radius=1] node[xshift=0cm,yshift=-1.5cm,text=black] {$C_{00}$};
                \end{pgfonlayer}
                }
                {dirty} % x
                {dirty} % y
                {clean} % z
                {clean} % w
                {dirty} % v
                %at the end of the second iteration
            \end{minipage}
            \begin{tikzpicture}[scale=0.9, x=4mm, segment length=2mm]\draw[->, decorate, decoration={snake,amplitude=1pt}, line width=1.5pt] (0,0) to node[above=2mm]{$\wPred$} (1,0) ;\end{tikzpicture}
            $\cdots$ (2 steps)
            \caption{
                The snapshots at the end of first and second iterations of
                $\PRHopcroftEqRel{(\nondet_{\Sigma}, \lift{\nondet_{\Sigma}}), \wCard}$
                and $\PRHopcroftEqRel{(\nondet_{\Sigma}, \lift{\nondet_{\Sigma}}), \wPred}$ for $c$.
                Yellow areas depict partitions which are refined as the main loop repeats.
                Clean states are white and dirty states are black.}\label{fig:execution-example}
        \end{figure}
        We define a coalgebra $c \colon C \to \nondet_{\Sigma}C$ as shown in \cref{fig:execution-example}.
        We compare the executions $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$ and $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$.
        At the both initialisations (Line \ref{line:initialisation}),
        we have a tree whose sole leaf is equal to $C$, which represents the initial partition, and every state in $C$ marked as dirty.

        In the first iteration, both $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$ and $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$
        split $C_{\epsilon}$ and obtain $C_0$ and $C_1$.
        The $k_0$ chosen at Line~\ref{line:choose-an-index} is $0$ (i.e. $C_0$) in both algorithms,
        and predecessors of $z$ are marked as dirty (the centre figure of \cref{fig:execution-example}).

        In the second iteration, both $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$ and $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$
        split $C_0$ and obtain $C_{00}$ and $C_{01}$.
        The $k_0$ chosen at Line~\ref{line:choose-an-index} of $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$
        is $1$ (i.e. $C_{01}$) because $\wCard(C_{01}) = 3 > 1 = \wCard(C_{00})$, and
        predecessors of $w$ are marked as dirty (the left figure of \cref{fig:execution-example})..
        The $k_0$ chosen at Line~\ref{line:choose-an-index} of $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$
        is $0$ (i.e. $C_{00}$) because $\wPred(C_{00}) = 4 > 3 = \wPred(C_{01})$, and
        predecessors of the states in $C_{01}$ are marked as dirty (the right figure of \cref{fig:execution-example}).

        $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$ marks
        states as dirty less than $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$.
        Hence, $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wPred}$
        terminates in fewer steps compared with $\PRHopcroftEqRel{(\nondet_\Sigma, \lift{\nondet_{\Sigma}}), \wCard}$.
    \end{myexample}
